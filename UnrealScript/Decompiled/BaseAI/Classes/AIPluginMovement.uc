/*******************************************************************************
 * AIPluginMovement generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AIPluginMovement extends AITickablePlugin within BaseAIController
    abstract
    native(Plugin);

enum EMoveRequestDestinationType
{
    MRDT_Invalid,
    MRDT_Vector,
    MRDT_Actor,
    MRDT_MAX
};

struct native MoveParameters
{
    var BaseAITypes.EBaseMoveMood MoveMood;
    var BaseAITypes.EBaseMoveType MoveType;
    var Actor RotateAtEndToMatch;
    var Actor FollowingActor;
    var bool bMovementCanBeInaccurate;
    var bool bMoveThroughLastPoint;
    var bool bStartPathFollowingShooting;
    var bool bEndPathFollowingShooting;
    var bool bForceAnyMove;
    var bool bAllowedToFire;

    structdefaultproperties
    {
        MoveMood=EBaseMoveMood.BMM_Fast
        MoveType=EBaseMoveType.BMT_Normal
        RotateAtEndToMatch=none
        FollowingActor=none
        bMovementCanBeInaccurate=false
        bMoveThroughLastPoint=false
        bStartPathFollowingShooting=true
        bEndPathFollowingShooting=false
        bForceAnyMove=false
        bAllowedToFire=false
    }
};

struct native MoveRequestDestination
{
    var Vector VectorDest;
    var Actor ActorDest;
    var AIPluginMovement.EMoveRequestDestinationType Type;

    structdefaultproperties
    {
        VectorDest=(X=0,Y=0,Z=0)
        ActorDest=none
        Type=EMoveRequestDestinationType.MRDT_Invalid
    }
};

struct native MovementRequest
{
    var native MoveParameters MoveParams;
    var float AcceptableDistance;
    var Vector DestOffset;
    var Vector MidPointOffset;
    var native MoveRequestDestination Destination;
    var native NavigationPath PreComputedPath;
    var BaseAITypes.EActionPriority Priority;
    var const Object Observer;
    var bool bStickToNavmesh;
    var bool bStickToActionArea;
    var bool bDynamicDestOffset;
    var bool bDynamicMidPoint;
    var bool bPostProcessPath;
    var int QueryID;

    structdefaultproperties
    {
        AcceptableDistance=0
        DestOffset=(X=0,Y=0,Z=0)
        MidPointOffset=(X=0,Y=0,Z=0)
        Priority=EActionPriority.AP_Invalid
        Observer=none
        bStickToNavmesh=false
        bStickToActionArea=false
        bDynamicDestOffset=false
        bDynamicMidPoint=false
        bPostProcessPath=false
        QueryID=0
    }
};

var MovementRequest MoveRequest;
var transient float GoalDistanceSq;
var const BaseAITypes.EActionPriority ActionPriority;
var const BaseAITypes.EActionPriority MovementLock;
var const transient bool bObserverNotified;
var const transient bool bDontNotifyObserver;
var transient bool bDontRestartByKismet;
var float MinimumSuccessDistance;

// Export UAIPluginMovement::execMoveToRequest(FFrame&, void* const)
native function bool MoveToRequest(out MovementRequest Request);

// Export UAIPluginMovement::execMoveToPointRequest(FFrame&, void* const)
native function bool MoveToPointRequest(Vector InDestLocation, BaseAITypes.EActionPriority CommandPriority, optional Object ActionObserver, optional bool bStopAtEnd, optional bool bStickToNavmesh, optional float AcceptableDistance, optional Actor RotateAtEndToMatch)
{
    bStopAtEnd = true;
    bStickToNavmesh = true;                                            
}

// Export UAIPluginMovement::execMoveToActorRequest(FFrame&, void* const)
native function bool MoveToActorRequest(Actor inPawnGoal, BaseAITypes.EActionPriority CommandPriority, optional Object ActionObserver, optional bool bInAllowedToFire, optional float AcceptableDistance, optional Vector DestOffset, optional Vector MidPointOffset, optional bool bDynamicMidPoint, optional bool bStopAtEnd, optional bool bStickToNavmesh)
{
    bInAllowedToFire = true;                
    bStopAtEnd = true;
    bStickToNavmesh = true;                                                
}

// Export UAIPluginMovement::execFollowPlugInsPath(FFrame&, void* const)
native function bool FollowPlugInsPath(NavigationPath InPath, BaseAITypes.EActionPriority CommandPriority, optional Object ActionObserver, optional bool bStopAtEnd, optional Actor RotateAtEndToMatch, optional float AcceptableDistance)
{
    bStopAtEnd = true;                                        
}

// Export UAIPluginMovement::execAbortMove(FFrame&, void* const)
native function bool AbortMove(bool bNewRequest);

// Export UAIPluginMovement::execSetMovementLock(FFrame&, void* const)
native function SetMovementLock(bool bLock, optional BaseAITypes.EActionPriority Priority, optional bool bNewRequest)
{
    Priority = 1;                        
}

// Export UAIPluginMovement::execSuccess(FFrame&, void* const)
protected native function Success();

// Export UAIPluginMovement::execFailure(FFrame&, void* const)
protected native function Failure();

// Export UAIPluginMovement::execRePath(FFrame&, void* const)
native function bool RePath();

// Export UAIPluginMovement::execGetDestination(FFrame&, void* const)
native final function Vector GetDestination(out MovementRequest Request);

final function AIPluginMovement.EMoveRequestDestinationType GetDestinationType()
{
    return MoveRequest.Destination.Type;
}

function StopMovement();

function bool MoveUnreachable(Vector AttemptedDest, Actor AttemptedTarget)
{
    if(AttemptedTarget != none)
    {
        Outer.AILog_Internal((string(GetFuncName()) $ " AttemptedTarget: ") $ string(AttemptedTarget), 'PathWarning');
    }
    return false;
}

state Succeeding extends DebugState
{Begin:

    Outer.AILog_Internal("Moving - END:" @ string(GetStateName()), 'Move');
    Success();
    stop;                    
}

state Failing extends DebugState
{Begin:

    Outer.AILog_Internal("Moving - END:" @ string(GetStateName()), 'Move');
    Failure();
    stop;                    
}

state Aborting extends DebugState
{Begin:

    Outer.AILog_Internal("Moving - Aborted", 'Move');
    StopMovement();
    stop;                    
}

state Idling extends DebugState
{Begin:

    Outer.AILog_Internal("Idling", 'Move');
    StopMovement();
    stop;            
}

defaultproperties
{
    MoveRequest=(AcceptableDistance=0,DestOffset=(X=0,Y=0,Z=0),MidPointOffset=(X=0,Y=0,Z=0),Priority=EActionPriority.AP_Invalid,Observer=none,bStickToNavmesh=true,bStickToActionArea=false,bDynamicDestOffset=false,bDynamicMidPoint=false,bPostProcessPath=false,QueryID=0)
    MinimumSuccessDistance=160
}