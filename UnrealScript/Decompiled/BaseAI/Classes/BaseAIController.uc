/*******************************************************************************
 * BaseAIController generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class BaseAIController extends GameAIController
    native
    config(AI)
    hidecategories(Navigation)
    implements(PlugInOwnerInterface);

struct native LocalEnemyInfo
{
    var array<float> PerceptionTimestamp;
    var BaseAITypes.EWSPerceptionMode LatestPerception;
    var BaseAITypes.EWSPerceptionMode DominantPerception;
    var int VisibleCoverActions;
    var float CurrentThreat;
    var Vector LatestLocation;
    var Pawn Pawn;
    var bool bSeenBefore;
    var bool bIsPlayer;

    structdefaultproperties
    {
        PerceptionTimestamp=none
        LatestPerception=EWSPerceptionMode.WSPM_None
        DominantPerception=EWSPerceptionMode.WSPM_None
        VisibleCoverActions=0
        CurrentThreat=0
        LatestLocation=(X=0,Y=0,Z=0)
        Pawn=none
        bSeenBefore=false
        bIsPlayer=false
    }
};

var transient BaseAIPawn MyBaseAIPawn;
var transient BaseAISquad BaseSquad;
var const array<AITickablePlugin> TickablePlugins;
var export editinline PluginSquad SquadPlugin;
var export editinline AIPluginMovement MovementPlugin;
var class<AIPluginMovement> MovementPluginClass;
var export editinline AIPluginLeap LeapPlugin;
var class<AIPluginLeap> LeapPluginClass;
var export editinline AIPluginStuckFix StuckFixPlugin;
var class<AIPluginStuckFix> StuckFixPluginClass;
var transient BaseAiPlugInHistory MyAiPlugInHistory;
var bool bUsePerceptionHearing;
var bool bAlwaysAssignEnemy;
var bool bUseNavMesh;
var bool bUsePluginsForMovement;
var float LastEnemySightedTime;
var array<Actor> TargetList;
var array<Actor> ProhibitedTargetList;
var transient BaseAIPawn SquadAssignedTarget;
var array<LocalEnemyInfo> LocalEnemyList;
/** -----------------------------------------------------------------------  debug variables ----------------------------------------------------------------------- */
var(Debug) config int PlugInHistoryNum;

event InitializeAIClass();

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    super(Controller).Possess(inPawn, bVehicleTransition);
    if(inPawn != none)
    {
        MyBaseAIPawn = BaseAIPawn(inPawn);
    }
}

function PawnDied(Pawn inPawn)
{
    Cleanup();
    super(Controller).PawnDied(inPawn);
}

// Export UBaseAIController::execUpdateEnemyRange(FFrame&, void* const)
native final function float UpdateEnemyRange();

// Export UBaseAIController::execUpdateEnemyAngle(FFrame&, void* const)
native final function BaseAITypes.EWSSymbolicAngle UpdateEnemyAngle();

// Export UBaseAIController::execCleanup(FFrame&, void* const)
native function Cleanup(optional bool bBeingDestroyed);

function BaseAiPlugInHistory GetAiPlugInHistory()
{
    return MyAiPlugInHistory;
}

function float GetTimeSince(float Time2Test)
{
    return WorldInfo.TimeSeconds - Time2Test;
}

// Export UBaseAIController::execBroadcastEnemyKnowledge(FFrame&, void* const)
native function int BroadcastEnemyKnowledge(Pawn EnemyPawn, BaseAITypes.EWSPerceptionMode Perception);

// Export UBaseAIController::execRemoveEnemy(FFrame&, void* const)
native function RemoveEnemy(Pawn EnemyPawn);

// Export UBaseAIController::execRemoveAllEnemies(FFrame&, void* const)
native function RemoveAllEnemies();

// Export UBaseAIController::execIsFriendlyPawn(FFrame&, void* const)
native final function bool IsFriendlyPawn(Pawn TestPlayer);

// Export UBaseAIController::execIsFriendly(FFrame&, void* const)
native function bool IsFriendly(Controller TestPlayer);

// Export UBaseAIController::execUpdateEnemyPerception(FFrame&, void* const)
native final function UpdateEnemyPerception(optional bool bSkipResponseDelay);

// Export UBaseAIController::execSelectTargetInternal(FFrame&, void* const)
native function bool SelectTargetInternal(bool bOnlyFromTargetList);

// Export UBaseAIController::execSetEnemy(FFrame&, void* const)
native event bool SetEnemy(Pawn NewEnemy);

// Export UBaseAIController::execSelectEnemy(FFrame&, void* const)
native function bool SelectEnemy();

// Export UBaseAIController::execSelectTarget(FFrame&, void* const)
native function bool SelectTarget();

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageTyp)
{
    if(KilledPawn == Focus)
    {
        Focus = none;
    }
    RemoveEnemy(KilledPawn);
    super(Controller).NotifyKilled(Killer, Killed, KilledPawn, damageTyp);
}

function StopMovement(optional BaseAITypes.EActionPriority ActionPriority)
{
    ActionPriority = 1;
    if(MovementPlugin != none)
    {
        MovementPlugin.AbortMove(false);
    }
    if(LeapPlugin != none)
    {
        LeapPlugin.AbortMove(false);
    }
    if(StuckFixPlugin != none)
    {
        StuckFixPlugin.AbortMove(false);
    }
}

// Export UBaseAIController::execDrawEnemyPerception(FFrame&, void* const)
native function DrawEnemyPerception(Canvas DrawCanvas);

function DrawDebugTextToHud(HUD HUD, string Text, optional Color TextColor);

defaultproperties
{
    bAlwaysAssignEnemy=true
}