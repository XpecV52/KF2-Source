/*******************************************************************************
 * AIPluginLeap generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AIPluginLeap extends AITickablePlugin within BaseAIController
    abstract
    native(Plugin);

struct native LeapRequest
{
    var Actor TheJumpDownNavPointPathObject;
    var int LandSpotIndex;
    var float EdgesDropHeight;
    var BaseAITypes.EActionPriority Priority;
    var const Object Observer;
    var int QueryID;

    structdefaultproperties
    {
        TheJumpDownNavPointPathObject=none
        LandSpotIndex=0
        EdgesDropHeight=0
        Priority=EActionPriority.AP_Invalid
        Observer=none
        QueryID=0
    }
};

var Actor BaseForLanding;
var Vector LeapDirection;
var transient Vector LocationAtStartOfLeap;
var transient Vector ClosestLocOnEdge;
var transient Vector ExpectedLandingLoc;
var const BaseAITypes.EActionPriority ActionPriority;
var const transient bool bObserverNotified;
var const transient bool bDontNotifyObserver;
var transient bool bDontRestartByKismet;
var bool bCollisionOffPhase;
var bool bConfigOnlyTraceUp;
var bool bWantTotalMovementControl;
var float ConfigFactorToIncreaseCalcedLeapVolBy;
var float ConfigFactorToIncreasePlottedLeapVolBy;
var float ConfigFactorToReduceLeapProjectionSizeBy;
var float ConfigDistanceOutFromDropEdgeToCalcDropLoc;
var float PercentageOfLeapImmuneFromCollision;
var float ConfigPercentageOfLeapImmuneFromCollision;
var float ConfigDesiredLeapSpeed;
var float ConfigMinSpeedAllowed;
var float ConfigMaxSpeedAllowed;
var float ConfigBaseLeapZ;
var float ConfigDesiredZPct;
var LeapRequest MyLeapRequest;

function bool Leap(const out LeapRequest InLeapRequest)
{
    MyLeapRequest = InLeapRequest;
    ScriptCommonMovePreparation(1);
    GotoState('Command_SpecialMove');
    return true;
}

event string GetDumpString()
{
    return "LeapDirection:" @ string(LeapDirection);
}

event bool ScriptCommonMovePreparation(BaseAITypes.EActionPriority Priority)
{
    bCollisionOffPhase = false;
    return true;
}

event ScriptCleanUp()
{
    Outer.MyBaseAIPawn.bLeaping = false;
    Outer.AILog_Internal(string(GetFuncName()) @ " Turning me on because ScriptCleanUp: ");
    TurnMeOn();
}

// Export UAIPluginLeap::execSuccess(FFrame&, void* const)
protected native function Success();

// Export UAIPluginLeap::execFailure(FFrame&, void* const)
protected native function Failure();

// Export UAIPluginLeap::execAbortMove(FFrame&, void* const)
native function bool AbortMove(bool bNewRequest);

function TestForTimeToTurnCollisionBackOn()
{
    local float TimeDelta;

    if(bCollisionOffPhase)
    {
        if(HasPercentOfZDiffBeenCovered())
        {
            Outer.AILog_Internal(string(GetFuncName()) @ " Turning me on because HasPercentOfZDiffBeenCovered: ");
            TurnMeOn();            
        }
        else
        {
            TimeDelta = Outer.WorldInfo.TimeSeconds - Outer.MyBaseAIPawn.TimeStartedLeap;
            if(TimeDelta > Outer.MyBaseAIPawn.TimeImmuneWhileLeaping)
            {
                Outer.AILog_Internal((string(GetFuncName()) @ " Turning me on because of time in leap of: ") @ string(TimeDelta));
                TurnMeOn();
            }
        }
    }
}

function bool HasPercentOfZDiffBeenCovered();

function TurnMeOn()
{
    Outer.MyBaseAIPawn.SetCollision(true, true);
    Outer.MyBaseAIPawn.bCollideWorld = true;
    Outer.MyBaseAIPawn.SetPushesRigidBodies(true);
    bCollisionOffPhase = false;
}

function Vector GetJumpVelForDropEdge(out float TimeToReachLandLoc);

function Vector GetJumpVelForUsingJumpDownNavPointPathObject(out float TimeToReachLandLoc);

function NotifyLanded();

state Succeeding extends DebugState
{Begin:

    Outer.AILog_Internal("Leaping - END:" @ string(GetStateName()), 'Leap');
    Success();
    stop;                
}

state Failing extends DebugState
{Begin:

    Outer.AILog_Internal("Leaping - END:" @ string(GetStateName()), 'Leap');
    Failure();
    stop;                
}

state Aborting extends DebugState
{Begin:

    Outer.AILog_Internal("Leaping - Aborted", 'Leap');
    Outer.StopMovement();
    stop;        
}

state Idling extends DebugState
{Begin:

    Outer.AILog_Internal("Leaping - Idling so doing nothing", 'Leap');
    stop;        
}

state Command_SpecialMove
{
    ignores LeapLoopPreSleepDataUpdate;

    function BeginState(name PreviousStateName)
    {
        super(Object).BeginState(PreviousStateName);
        if(MyLeapRequest.TheJumpDownNavPointPathObject != none)
        {
            SetDesiredDirectionForJumpDoenNavPointEdge();            
        }
        else
        {
            SetDesiredDirectionForDropEdge();
        }
        bWantTotalMovementControl = true;
    }

    function bool IfShowLeapDownDebugArtifacts()
    {
        return false;
    }

    function Vector GetCurrentJumpEdgeDirectionOfLeap()
    {
        return vector(MyLeapRequest.TheJumpDownNavPointPathObject.Rotation);
    }

    function float GetDistanceDownRangeToFocusForDropEdgeLeap()
    {
        return 500;
    }

    function SetDesiredDirectionForDropEdge()
    {
        local Vector newFocalPoint;

        LeapDirection = GetCurrentJumpEdgeDirectionOfLeap();
        Outer.Focus = none;
        newFocalPoint = Outer.Pawn.Location + (LeapDirection * (GetDistanceDownRangeToFocusForDropEdgeLeap()));
        Outer.SetFocalPoint(newFocalPoint);
        if(IfShowLeapDownDebugArtifacts())
        {
            Outer.DrawDebugStar(newFocalPoint, 300, 255, 165, 0, true);
        }
        Outer.SetDesiredRotation(rotator(LeapDirection));
    }

    function SetDesiredDirectionForJumpDoenNavPointEdge()
    {
        local Vector newFocalPoint;

        if(BaseForLanding == none)
        {
            return;
        }
        LeapDirection = BaseForLanding.Location - Outer.Pawn.Location;
        Outer.Focus = none;
        newFocalPoint = BaseForLanding.Location;
        Outer.SetFocalPoint(newFocalPoint);
        if(IfShowLeapDownDebugArtifacts())
        {
            Outer.DrawDebugStar(newFocalPoint, 300, 255, 165, 0, true);
        }
        Outer.SetDesiredRotation(rotator(LeapDirection));
    }

    function bool DoLeap()
    {
        return false;
    }
    J0x00:
    if(!Outer.Pawn.ReachedDesiredRotation())
    {
        Sleep(0.03);
        goto J0x00;
    }
    if(DoLeap())
    {
        J0x58:

        LeapLoopPreSleepDataUpdate();
        Sleep(0);
        TestForTimeToTurnCollisionBackOn();
        if(!(Outer.Pawn.Physics != 2))
            goto J0x58;
        Outer.AILog_Internal(string(GetFuncName()) @ " Pawn.Physics != PHYS_Falling, so landed");
        Outer.MyBaseAIPawn.bLeaping = false;
        Outer.MyBaseAIPawn.SetCollision(true, true, true);
        Outer.Focus = Outer.Enemy;
        NotifyLanded();
    }
    bWantTotalMovementControl = false;
    GotoState('Succeeding');
    stop;                    
}

defaultproperties
{
    MyLeapRequest=(TheJumpDownNavPointPathObject=none,LandSpotIndex=-1,EdgesDropHeight=0,Priority=EActionPriority.AP_Invalid,Observer=none,QueryID=0)
}