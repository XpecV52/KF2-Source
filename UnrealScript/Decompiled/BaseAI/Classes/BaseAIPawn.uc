/*******************************************************************************
 * BaseAIPawn generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class BaseAIPawn extends GamePawn
    abstract
    native
    nativereplication
    config(Game)
    hidecategories(Navigation);

const kBreadCrumbsMax = 10;

struct native Breadcrumbs
{
    var transient Vector Crumbs[10];
    var transient byte CurrentCrumb;
    var float CrumbDistanceSq;

    structdefaultproperties
    {
        Crumbs[0]=(X=0,Y=0,Z=0)
        Crumbs[1]=(X=0,Y=0,Z=0)
        Crumbs[2]=(X=0,Y=0,Z=0)
        Crumbs[3]=(X=0,Y=0,Z=0)
        Crumbs[4]=(X=0,Y=0,Z=0)
        Crumbs[5]=(X=0,Y=0,Z=0)
        Crumbs[6]=(X=0,Y=0,Z=0)
        Crumbs[7]=(X=0,Y=0,Z=0)
        Crumbs[8]=(X=0,Y=0,Z=0)
        Crumbs[9]=(X=0,Y=0,Z=0)
        CurrentCrumb=0
        CrumbDistanceSq=10000
    }
};

var transient BaseAIController MyBaseAI;
var byte LastTeamNum;
var transient byte MyAIType;
var transient Breadcrumbs MyBreadCrumbs;
var const array<BaseAIPawn> Attackers;
var const array<int> AttackersPerTypeCount;
var transient bool bLeaping;
var transient float TimeStartedLeap;
var transient float TimeImmuneWhileLeaping;

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    Class'BaseAISubsystem'.static.DecreaseTeamSize(GetTeamNum());
    if((MyBaseAI != none) && MyBaseAI.Enemy != none)
    {
        BaseAIPawn(MyBaseAI.Enemy).RemoveAttacker(self);
    }
    return super(Pawn).Died(Killer, DamageType, HitLocation);
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super(Pawn).PossessedBy(C, bVehicleTransition);
    MyBaseAI = BaseAIController(C);
    if(MyBaseAI != none)
    {
        LastTeamNum = MyBaseAI.GetTeamNum();
    }
}

function UnPossessed()
{
    MyBaseAI = none;
    super(Pawn).UnPossessed();
}

simulated function NotifyTeamChanged()
{
    super(Pawn).NotifyTeamChanged();
    LastTeamNum = GetTeamNum();
}

// Export UBaseAIPawn::execGetAttackerCount(FFrame&, void* const)
native final function int GetAttackerCount(optional int AIType)
{
    AIType = -1;            
}

// Export UBaseAIPawn::execRemoveAttacker(FFrame&, void* const)
native final function RemoveAttacker(BaseAIPawn Attacker);

// Export UBaseAIPawn::execDrawCrumbs(FFrame&, void* const)
native final function DrawCrumbs(HUD HUD);

defaultproperties
{
    MyBreadCrumbs=(Crumbs=(X=0,Y=0,Z=0),Crumbs[1]=(X=0,Y=0,Z=0),Crumbs[2]=(X=0,Y=0,Z=0),Crumbs[3]=(X=0,Y=0,Z=0),Crumbs[4]=(X=0,Y=0,Z=0),Crumbs[5]=(X=0,Y=0,Z=0),Crumbs[6]=(X=0,Y=0,Z=0),Crumbs[7]=(X=0,Y=0,Z=0),Crumbs[8]=(X=0,Y=0,Z=0),Crumbs[9]=(X=0,Y=0,Z=0),CurrentCrumb=0,CrumbDistanceSq=10000)
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__BaseAIPawn.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__BaseAIPawn.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__BaseAIPawn.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__BaseAIPawn.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__BaseAIPawn.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}