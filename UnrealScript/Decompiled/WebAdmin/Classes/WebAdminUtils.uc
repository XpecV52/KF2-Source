/*******************************************************************************
 * WebAdminUtils generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class WebAdminUtils extends Object;

struct TranslitEntry
{
    var string F;
    var string T;

    structdefaultproperties
    {
        F=""
        T=""
    }
};

struct DateTime
{
    var int Year;
    var int Month;
    var int Day;
    var int Hour;
    var int minute;
    var int second;

    structdefaultproperties
    {
        Year=0
        Month=0
        Day=0
        Hour=0
        minute=0
        second=0
    }
};

var const localized array<localized TranslitEntry> translit;
var const localized string msgUnknownTeam;
var const array<string> monthNames;
var const array<string> dayNames;
var const array<int> dowTable;

static final function string translitText(coerce string inp)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < default.translit.Length)
    {
        inp = Repl(inp, default.translit[I].F, default.translit[I].T);
        ++ I;
        goto J0x0B;
    }
    return inp;
}

static final function string HTMLEscape(coerce string inp)
{
    inp = translitText(inp);
    inp = Repl(inp, "&", "&amp;");
    inp = Repl(inp, "<", "&lt;");
    inp = Repl(inp, "\"", "&quot;");
    return Repl(inp, ">", "&gt;");
}

static final function string Trim(coerce string inp)
{
    local int B, E;

    B = 0;
    E = Len(inp) - 1;
    J0x23:

    if(B < E)
    {
        if(Asc(Mid(inp, B, 1)) > 32)
        {
            goto J0x69;
        }
        ++ B;
        goto J0x23;
    }
    J0x69:

    if(E >= B)
    {
        if(Asc(Mid(inp, E, 1)) > 32)
        {
            goto J0xAF;
        }
        -- E;
        goto J0x69;
    }
    J0xAF:

    return Mid(inp, B, (E - B) + 1);
}

static final function string ColorToHTMLColor(Color clr)
{
    return (("#" $ Right(ToHex(clr.R), 2)) $ Right(ToHex(clr.G), 2)) $ Right(ToHex(clr.B), 2);
}

static final function Color HTMLColorToColor(string clr)
{
    local Color res;
    local int Col;

    clr = Trim(clr);
    if(Left(clr, 1) == "#")
    {
        clr = Mid(clr, 1);
    }
    if(Len(clr) != 6)
    {
        return res;
    }
    Col = FromHex(clr);
    if(clr == "<<invalid>>")
    {
        return res;
    }
    res.R = byte((Col & 16711680) >>> 16);
    res.G = byte((Col & 65280) >>> 8);
    res.B = byte(Col & 255);
    res.A = 255;
    return res;
}

static final function int FromHex(out string hx)
{
    local int res, I, T, S;

    if(Len(hx) > 8)
    {
        hx = "<<invalid>>";
        return -1;
    }
    hx = Caps(hx);
    S = 0;
    I = Len(hx) - 1;
    J0x67:

    if(I >= 0)
    {
        T = Asc(Mid(hx, I, 1));
        if((T >= 48) && T <= 57)
        {
            T -= 48;            
        }
        else
        {
            if((T >= 65) && T <= 70)
            {
                T -= 55;                
            }
            else
            {
                hx = "<<invalid>>";
                return -1;
            }
        }
        if(S > 0)
        {
            T = T << S;
        }
        res = res | T;
        S += 4;
        -- I;
        goto J0x67;
    }
    return res;
}

static final function bool getDateTime(out DateTime Record, string ts)
{
    local int Idx;
    local array<string> parts;

    ts -= " ";
    Idx = InStr(ts, "-");
    if(Idx == -1)
    {
        return false;
    }
    ParseStringIntoArray(Left(ts, Idx), parts, "/", false);
    if(parts.Length != 3)
    {
        return false;
    }
    Record.Year = int(parts[0]);
    Record.Month = int(parts[1]);
    Record.Day = int(parts[2]);
    ParseStringIntoArray(Mid(ts, Idx + 1), parts, ":", false);
    if(parts.Length != 3)
    {
        return false;
    }
    Record.Hour = int(parts[0]);
    Record.minute = int(parts[1]);
    Record.second = int(parts[2]);
    return true;
}

static final function string convertToRfc2109Date(string dateString)
{
    local array<string> parts;
    local int Month, dow;

    ParseStringIntoArray(dateString, parts, " ", true);
    if(parts.Length != 5)
    {
        LogInternal(("Cannot convert date " $ dateString) $ " to RFC 2019, not the correct number of parts", 'webadmin');
        return "";
    }
    Month = default.monthNames.Find(parts[1];
    if(Month == -1)
    {
        LogInternal((("Cannot convert date " $ dateString) $ " to RFC 2019, unknown month: ") $ parts[1], 'webadmin');
        return "";
    }
    dow = getDayOfWeek(int(parts[2]), Month, int(parts[0]));
    if((dow < 0) || dow > 6)
    {
        LogInternal((("Cannot convert date " $ dateString) $ " to RFC 2019, wrong day of week value: ") $ string(dow), 'webadmin');
        return "";
    }
    return (((((((default.dayNames[dow] $ ", ") $ parts[0]) $ "-") $ parts[1]) $ "-") $ parts[2]) @ parts[3]) @ parts[4];
}

static final function int getDayOfWeek(int Year, int Month, int Day)
{
    if(Month < 3)
    {
        -- Year;
    }
    return (((((Year + (Year / 4)) - (Year / 100)) + (Year / 400)) + default.dowTable[Month - 1]) + Day) % 7;
}

static final function string getLocalized(coerce string Data)
{
    local array<string> parts;

    if(!Left(Data, 9) ~= "<Strings:")
    {
        return Data;
    }
    Data = Mid(Data, 9, Len(Data) - 10);
    ParseStringIntoArray(Data, parts, ".", true);
    if(parts.Length >= 3)
    {
        return Localize(parts[1], parts[2], parts[0]);
    }
    return "";
}

static final function parseUrlOptions(out array<KeyValuePair> Options, string URL)
{
    local string Part;
    local array<string> parts;
    local int Idx, I;
    local KeyValuePair kv;

    ParseStringIntoArray(URL, parts, "?", true);
    foreach parts(Part,)
    {
        I = InStr(Part, "=");
        if(I == -1)
        {
            kv.Key = Part;
            kv.Value = "";            
        }
        else
        {
            kv.Key = Left(Part, I);
            kv.Value = Mid(Part, I + 1);
        }
        Idx = 0;
        J0x11E:

        if(Idx < Options.Length)
        {
            if(kv.Key ~= Options[Idx].Key)
            {
                goto J0x18E;
            }
            ++ Idx;
            goto J0x11E;
        }
        J0x18E:

        LogInternal((("Add " $ kv.Key) $ " at ") $ string(Idx));
        Options[Idx] = kv;        
    }    
}

static final function bool maskedCompare(coerce string Target, string Mask, optional bool caseInsensitive)
{
    local int Idx;
    local string Part;
    local bool greedy;

    if(caseInsensitive)
    {
        Mask = Caps(Mask);
        Target = Caps(Target);
    }
    J0x38:

    if((Mask == "*") || Mask == "**")
    {
        return true;
    }
    Idx = InStr(Mask, "*");
    if(Idx < 0)
    {
        return Target == Mask;
    }
    if(Idx > 0)
    {
        Part = Left(Mask, Idx);
        Mask = Mid(Mask, Idx);
        if(Left(Target, Len(Part)) != Part)
        {
            return false;
        }
        Target = Mid(Target, Len(Part));        
    }
    else
    {
        greedy = Left(Mask, 2) == "**";
        Idx = InStr(Mask, "*",,, ((greedy) ? 2 : 1));
        if(Idx < 0)
        {
            Idx = Len(Mask);
        }
        if(greedy)
        {
            Part = Mid(Mask, 2, Idx - 1);
            Mask = Mid(Mask, Idx + 1);            
        }
        else
        {
            Part = Mid(Mask, 1, Idx - 1);
            Mask = Mid(Mask, Idx);
        }
        if(Len(Part) == 0)
        {            
        }
        else
        {
            Idx = InStr(Target, Part, greedy);
            if(Idx == -1)
            {
                return false;
            }
            Target = Mid(Target, Idx + Len(Part));
        }
    }
    if(!((Len(Mask) == 0) || Len(Target) == 0))
        goto J0x38;
    return ((Target == Mask) || Mask == "*") || Mask == "**";
}

static final function string removeUrlOption(string URL, coerce string Option)
{
    local array<string> opts;

    opts[0] = Option;
    return removeUrlOptions(URL, opts);
}

static final function string removeUrlOptions(string URL, array<string> Options)
{
    local string opt;
    local int Idx, End;

    foreach Options(opt,)
    {
        Idx = 0;
        J0x22:

        if(Idx != -1)
        {
            Idx = InStr(URL, opt,, true, Idx);
            if(Idx == -1)
            {                
            }
            else
            {
                if((Idx > 0) && Mid(URL, Idx - 1, 1) != "?")
                {
                    Idx += Len(opt);                    
                }
                else
                {
                    End = Idx + Len(opt);
                    if(End >= Len(URL))
                    {                        
                    }
                    else
                    {
                        if(Mid(URL, End, 1) == "=")
                        {
                            End = InStr(URL, "?",,, Idx);
                            if(End == -1)
                            {
                                End = Len(URL);
                            }                            
                        }
                        else
                        {
                            if(Mid(URL, End, 1) != "?")
                            {
                                Idx = End;
                                goto J0x1D1;
                            }
                        }
                    }
                    URL = Mid(URL, 0, Idx - 1) $ Mid(URL, End);
                }
            }
            J0x1D1:

            goto J0x22;
        }        
    }    
    return URL;
}

static function string getTeamNameEx(TeamInfo Team)
{
    if(Team == none)
    {
        return getTeamName(-1);
    }
    if(Team.GetHumanReadableName() ~= "Team")
    {
        return getTeamName(Team.TeamIndex);
    }
    return Team.GetHumanReadableName();
}

static function string getTeamName(int Index)
{
    return Repl(default.msgUnknownTeam, "%d", string(Index + 1));
}

static function string extractIp(string Str)
{
    local int Idx;

    if(InStr(Str, ".") > 0)
    {
        Idx = InStr(Str, ":");
        if(Idx != -1)
        {
            Str = Left(Str, Idx);
        }
    }
    return Str;
}

static function string UniqueNetIdToString(UniqueNetId aId)
{
    local UniqueNetId Empty;

    if(Empty == aId)
    {
        return "";
    }
    return Class'OnlineSubsystem'.static.UniqueNetIdToString(aId);
}

static function string iso8601datetime(int Year, int Month, int Day, int Hour, int minute, int second, int MSec)
{
    return (((((((((((("" $ string(Year)) $ "-") $ Right("0" $ string(Month), 2)) $ "-") $ Right("0" $ string(Day), 2)) $ "T") $ Right("0" $ string(Hour), 2)) $ ":") $ Right("0" $ string(minute), 2)) $ ":") $ Right("0" $ string(second), 2)) $ ".") $ Right("00" $ string(MSec), 3);
}

defaultproperties
{
    msgUnknownTeam="Team #%d"
    monthNames(0)=""
    monthNames(1)="Jan"
    monthNames(2)="Feb"
    monthNames(3)="Mar"
    monthNames(4)="Apr"
    monthNames(5)="May"
    monthNames(6)="Jun"
    monthNames(7)="Jul"
    monthNames(8)="Aug"
    monthNames(9)="Sep"
    monthNames(10)="Oct"
    monthNames(11)="Nov"
    monthNames(12)="Dec"
    dayNames(0)="Sun"
    dayNames(1)="Mon"
    dayNames(2)="Tue"
    dayNames(3)="Wed"
    dayNames(4)="Thu"
    dayNames(5)="Fri"
    dayNames(6)="Sat"
    dowTable(0)=0
    dowTable(1)=3
    dowTable(2)=2
    dowTable(3)=5
    dowTable(4)=0
    dowTable(5)=3
    dowTable(6)=5
    dowTable(7)=1
    dowTable(8)=4
    dowTable(9)=6
    dowTable(10)=2
    dowTable(11)=4
}