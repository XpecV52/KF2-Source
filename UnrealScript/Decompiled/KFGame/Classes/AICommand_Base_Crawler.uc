/*******************************************************************************
 * AICommand_Base_Crawler generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Base_Crawler extends AICommand_Base_Zed within KFAIController_ZedCrawler;

var KFWallPathNode LeapTarget;
var bool bJumpingToWall;
var Vector TempDest;
var Vector OriginalTrans;
var Actor TempMoveGoal;

function Pushed()
{
    super.Pushed();
    OriginalTrans = Outer.Pawn.Mesh.Translation;
    if(Outer.OldFloor == vect(0, 0, 0))
    {
        Outer.OldFloor = vect(0, 0, 1);
    }
    GotoState(DefaultStateName);
}

function Paused(GameAICommand NewCommand)
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((((string(self) $ " ") $ string(GetFuncName())) $ "() Paused for ") $ string(NewCommand), 'Crawler');
    }
    super.Paused(NewCommand);
}

function BeginMoveToWall();

function SightCheck();

function Resumed(name OldCommandName)
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal(((((string(self) $ " ") $ string(GetFuncName())) $ "() (OldCommandName: ") $ string(OldCommandName)) $ ")", 'Crawler');
    }
    super.Resumed(OldCommandName);
}

function CheckWalls()
{
    local KFWallPathNode KFWP, BestKFWP;
    local float bestDist;

    Outer.DisableSeePlayer(0);
    Outer.Enemy = none;
    foreach Outer.WorldInfo.AllNavigationPoints(Class'KFWallPathNode', KFWP)
    {
        if((BestKFWP == none) || VSize(KFWP.Location - Outer.Pawn.Location) < bestDist)
        {
            if(KFWP.Location.Z > 350)
            {
                bestDist = VSize(KFWP.Location - Outer.Pawn.Location);
                BestKFWP = KFWP;
            }
        }        
    }    
    LeapTarget = BestKFWP;
    Outer.StopAllLatentMovement();
}

function SetTempDest()
{
    local Vector V, ProjFocus, X, EnemyLoc;
    local float Distance;

    if(Outer.Enemy == none)
    {
        Outer.Enemy = Outer.GetALocalPlayerController().Pawn;
    }
    EnemyLoc = Outer.Enemy.Location;
    EnemyLoc.Z = Outer.Pawn.Location.Z + RandRange(-64, 64);
    V = EnemyLoc - Outer.Pawn.Location;
    Distance = V Dot Outer.Pawn.Floor;
    ProjFocus = EnemyLoc - (Distance * Outer.Pawn.Floor);
    X = Normal(ProjFocus - Outer.Pawn.Location);
    if(X != vect(0, 0, 0))
    {
        TempDest = ProjFocus;        
    }
}
