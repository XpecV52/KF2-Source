/*******************************************************************************
 * KFAiBaseRangedBehavior generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAiBaseRangedBehavior extends Object within KFAIController
    native(AI);

struct native RangedLocValidationData
{
    var bool bCalulatedThisEngagement;
    var bool bLastLosArcCheckValid;
    var float RadiusOfFireCheckPath;
    var Vector FireLastPointToStrikeFrom;
    var Vector FireLastLocOfEndOfArc;
    var Vector FireLastLocOfBlockage;
    var array<Vector> LogAlgosSegmentEnds;
    var array<bool> LogAlgosSegmentValiditys;

    structdefaultproperties
    {
        bCalulatedThisEngagement=false
        bLastLosArcCheckValid=false
        RadiusOfFireCheckPath=0
        FireLastPointToStrikeFrom=(X=0,Y=0,Z=0)
        FireLastLocOfEndOfArc=(X=0,Y=0,Z=0)
        FireLastLocOfBlockage=(X=0,Y=0,Z=0)
        LogAlgosSegmentEnds=none
        LogAlgosSegmentValiditys=none
    }
};

struct native RangedStrikeData
{
    var() float HeightAboveTargetForRangedStrikeInUU;
    var() float XY_DistanceFromTargetForRangedStrikeInUU;
    var float XY_DistanceSqFromTargetForRangedStrikeInUU;
    var() float RangedFireIdealSpeed;
    var() float RangedFireMaxSpeed;
    var() float RangedFireMinSpeed;
    /** is the requested pct of the arc in the z direction (0=arc horizontally, 0.5 = arc at 45 degrees).  This is the starting point for finding a arc.  (Defaults to 0.05). the purpose of this is to bias the test in cases where there is more than one solution */
    var() float DesiredZPercentOfArc;
    /** IntentionalMissRangedFireIdealSpeed */
    var() float IntentionalMissRangedFireIdealSpeed;
    /** IntentionalMissRangedFireMaxSpeed */
    var() float IntentionalMissRangedFireMaxSpeed;
    /** IntentionalMissRangedFireMinSpeed */
    var() float IntentionalMissRangedFireMinSpeed;
    /** is the requested pct of the arc in the z direction (0=arc horizontally, 0.5 = arc at 45 degrees).  This is the starting point for finding a arc.  (Defaults to 0.05). the purpose of this is to bias the test in cases where there is more than one solution */
    var() float IntentionalMissDesiredZPercentOf;
    /** IntentionalMissFrontOffsetDistance */
    var() float IntentionalMissFrontOffsetDistance;
    /** IntentionalMissSideOffsetDistance */
    var() float IntentionalMissSideOffsetDistance;
    /** IntentionalMissHeightOffsetDistance */
    var() float IntentionalMissHeightOffsetDistance;
    var() Vector ShapeOfProjectileForCalc;
    var() float PercentOfArcToCheckForCalc;
    /** Alternate percentage of arcs to check after the defult beam the pill in value in order of Preferred arc */
    var() array<float> AltDesiredZPercentOfList;

    structdefaultproperties
    {
        HeightAboveTargetForRangedStrikeInUU=100
        XY_DistanceFromTargetForRangedStrikeInUU=1100
        XY_DistanceSqFromTargetForRangedStrikeInUU=0
        RangedFireIdealSpeed=1200
        RangedFireMaxSpeed=2500
        RangedFireMinSpeed=100
        DesiredZPercentOfArc=0.1
        IntentionalMissRangedFireIdealSpeed=1200
        IntentionalMissRangedFireMaxSpeed=2500
        IntentionalMissRangedFireMinSpeed=100
        IntentionalMissDesiredZPercentOf=0.2
        IntentionalMissFrontOffsetDistance=100
        IntentionalMissSideOffsetDistance=0
        IntentionalMissHeightOffsetDistance=0
        ShapeOfProjectileForCalc=(X=1,Y=1,Z=1)
        PercentOfArcToCheckForCalc=1
        AltDesiredZPercentOfList=none
    }
};

var KFAIController MyAiCtrl;
var transient array<RangedLocValidationData> StrikeLocValidationInfoList;
var protected transient int StrikeZoneForCurrentAttack;
var transient array<Vector> ProjMeshLocations;
var transient Vector ProjImpactLocation;
var transient Vector ProjExplosionLocation;
var transient int StrikeLastCalcArcSuccessId;
var transient array<Vector> LogAlgosSegmentEnds;
var transient array<bool> LogAlgosSegmentValiditys;
var transient Vector FireLastLocOfBlockage;
var transient Vector FireLastLocOfTarget;
var transient Vector ProjStartLocation;
var int TotalNumberOfPossibileFireLocationsPerFormationSlot;
var protected bool bIntentionalMiss;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) bool bUseTargetsCurrentLocAtRelease;
/** bCheckIfCanMoveToStrikeLocationBeforeTestingForLane */
var(RangedStrike) bool bCheckIfCanMoveToStrikeLocationBeforeTestingForLane;
/** bAbleToAdjustAimPositionForGameplay */
var(RangedStrike) bool bAbleToAdjustAimPositionForGameplay;
/** SleepTimeDuringRangeAttackDamageAssessment */
var(RangedStrike) float SleepTimeDuringRangeAttackDamageAssessment;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) float NumOfStrikeLocationsToLookForAtEachRange;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) float HorizontalSeperationBetweenPointsForStrike;
/** How far from the location of the pawn to the location where the projectile will be spawned */
var(RangedStrike) Vector OffsetForCalcOfForStrike;
/** MinRangeFromOrbitBeforeLookingForTierOffsetStrikeLocations */
var(RangedStrike) float MinRangeFromOrbitBeforeLookingForTierOffsetStrikeLocations;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) int ForceAllAttacksFromThisTier;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) int ForceAllAttacksFromThisZone;
/** This data is used for normal from any where position ing */
var(RangedStrike) array<RangedStrikeData> StrikeInfoByZone;
/** How far from the VS the flyer should be at when striking */
var(RangedStrike) float HieghtOffTargetPointForEndOfFireArc;
/** IntentionalMissChance */
var(RangedStrike) float IntentionalMissChance;
var transient int TotalNumOfAttemptsToFindFireStrikeLaneThisEngagement;
var transient ImpactInfo StrikeLaneBlockageImpactInfo;

function Setup()
{
    local RangedLocValidationData newLocData;
    local int iter;

    TotalNumOfAttemptsToFindFireStrikeLaneThisEngagement = -1;
    TotalNumberOfPossibileFireLocationsPerFormationSlot = int(NumOfStrikeLocationsToLookForAtEachRange);
    iter = 0;
    J0x2F:

    if(iter < TotalNumberOfPossibileFireLocationsPerFormationSlot)
    {
        StrikeLocValidationInfoList.AddItem(newLocData;
        ++ iter;
        goto J0x2F;
    }
    InitRangeFireData();
}

simulated function InitRangeFireData()
{
    local int iter;

    StrikeLastCalcArcSuccessId = -1;
    iter = 0;
    J0x1A:

    if(iter < StrikeInfoByZone.Length)
    {
        StrikeInfoByZone[iter].XY_DistanceSqFromTargetForRangedStrikeInUU = StrikeInfoByZone[iter].XY_DistanceFromTargetForRangedStrikeInUU * StrikeInfoByZone[iter].XY_DistanceFromTargetForRangedStrikeInUU;
        ++ iter;
        goto J0x1A;
    }
}

function float GetRangedFireMidZoneRangeForThisZone(int Zone)
{
    return 1000;
}

// Export UKFAiBaseRangedBehavior::execFindCurrentFireFromAnywhereZone(FFrame&, void* const)
native final function int FindCurrentFireFromAnywhereZone(Actor TargetOfLob);

function Vector GetBestCurrentVelocityForThisTarget(Actor TargetToCalcFor)
{
    if(TargetToCalcFor != none)
    {
        return TargetToCalcFor.Velocity;
    }
    return vect(0, 0, 0);
}

function SetStrikeZoneInfo(int ZoneId)
{
    StrikeZoneForCurrentAttack = ZoneId;
}

function DrawFireAttackDebug()
{
    local int iter, iterLobArc;
    local Vector previousLobArcLoc;

    iter = 0;
    J0x0B:

    if(iter < StrikeLocValidationInfoList.Length)
    {
        if(StrikeLocValidationInfoList[iter].bCalulatedThisEngagement)
        {
            previousLobArcLoc = StrikeLocValidationInfoList[iter].FireLastPointToStrikeFrom;
            iterLobArc = 0;
            J0x88:

            if(iterLobArc < StrikeLocValidationInfoList[iter].LogAlgosSegmentEnds.Length)
            {
                if(StrikeLocValidationInfoList[iter].LogAlgosSegmentValiditys[iterLobArc])
                {
                    Outer.DrawDebugLine(previousLobArcLoc, StrikeLocValidationInfoList[iter].LogAlgosSegmentEnds[iterLobArc], 127, 255, 212);                    
                }
                else
                {
                    if(StrikeLocValidationInfoList[iter].FireLastLocOfBlockage == vect(0, 0, 0))
                    {
                        Outer.DrawDebugLine(previousLobArcLoc, StrikeLocValidationInfoList[iter].LogAlgosSegmentEnds[iterLobArc], 28, 255, 174);
                        Outer.DrawDebugStar(previousLobArcLoc, 75, 28, 255, 174);                        
                    }
                    else
                    {
                        Outer.DrawDebugLine(previousLobArcLoc, StrikeLocValidationInfoList[iter].LogAlgosSegmentEnds[iterLobArc], 255, 28, 174);
                        Outer.DrawDebugStar(StrikeLocValidationInfoList[iter].FireLastLocOfBlockage, 25, 255, 28, 174);
                    }
                }
                previousLobArcLoc = StrikeLocValidationInfoList[iter].LogAlgosSegmentEnds[iterLobArc];
                ++ iterLobArc;
                goto J0x88;
            }            
        }
        else
        {
            goto J0x32C;
        }
        ++ iter;
        goto J0x0B;
    }
    J0x32C:

    if(FireLastLocOfBlockage != vect(0, 0, 0))
    {
        Outer.DrawDebugStar(FireLastLocOfBlockage, 25, 255, 0, 255);
    }
    if(FireLastLocOfTarget != vect(0, 0, 0))
    {
        Outer.DrawDebugStar(FireLastLocOfTarget, 25, 0, 255, 0);
    }
    previousLobArcLoc = Outer.MyKFPawn.Location;
    iter = 0;
    J0x412:

    if(iter < LogAlgosSegmentEnds.Length)
    {
        if(LogAlgosSegmentValiditys[iter])
        {
            if(StrikeLastCalcArcSuccessId == 1)
            {
                Outer.DrawDebugLine(previousLobArcLoc, LogAlgosSegmentEnds[iter], 0, 255, 0);
                Outer.DrawDebugStar(LogAlgosSegmentEnds[iter], 5, 0, 255, 0);                
            }
            else
            {
                Outer.DrawDebugLine(previousLobArcLoc, LogAlgosSegmentEnds[iter], 0, 0, 255);
                Outer.DrawDebugStar(LogAlgosSegmentEnds[iter], 5, 0, 0, 255);
            }            
        }
        else
        {
            Outer.DrawDebugLine(previousLobArcLoc, LogAlgosSegmentEnds[iter], 255, 0, 0);
            Outer.DrawDebugStar(FireLastLocOfBlockage, 25, 255, 0, 255);
        }
        previousLobArcLoc = LogAlgosSegmentEnds[iter];
        ++ iter;
        goto J0x412;
    }
    Outer.DrawDebugStar(ProjStartLocation, 25, 255, 0, 0);
    iter = 0;
    J0x635:

    if(iter < ProjMeshLocations.Length)
    {
        Outer.DrawDebugStar(ProjMeshLocations[iter], 5, 0, 255, 255);
        ++ iter;
        goto J0x635;
    }
    if(ProjExplosionLocation != vect(0, 0, 0))
    {
        Outer.DrawDebugSphere(ProjExplosionLocation, 35, 8, 255, 0, 255);
    }
    if(ProjImpactLocation != vect(0, 0, 0))
    {
        Outer.DrawDebugSphere(ProjImpactLocation, 25, 8, 0, 255, 255);
    }
}

function SetAllPastStrikeLocValidationInfoToExpired()
{
    local int iter;

    iter = 0;
    J0x0B:

    if(iter < (StrikeLocValidationInfoList.Length - 1))
    {
        StrikeLocValidationInfoList[iter].bCalulatedThisEngagement = false;
        ++ iter;
        goto J0x0B;
    }
}
