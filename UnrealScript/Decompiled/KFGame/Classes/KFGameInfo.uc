/*******************************************************************************
 * KFGameInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGameInfo extends FrameworkGame
    native
    config(Game)
    hidecategories(Navigation,Movement,Collision);

const TeamDeathPenaltyPerc = 0.05f;
const GBE_Inventory = 'Inventory';
const GBE_TraderOpen = 'TraderOpen';
const GBE_WaveStart = 'WaveStart';
const GBE_Buy = 'Buy';
const GBE_Sell = 'Sell';
const GBE_Pickup = 'Pickup';
const GBE_Respawn = 'Respawn';
const GBE_Kills = 'Kills';
const GBE_Deaths = 'Deaths';

enum EGameLength
{
    GL_Short,
    GL_Normal,
    GL_Long,
    GL_MAX
};

enum EForcedMusicType
{
    EFM_MainMenu,
    EFM_Credits,
    EFM_Boss1,
    EFM_Boss2,
    EFM_Boss3,
    EFM_MAX
};

struct native sGameMode
{
    var string FriendlyName;
    var string ClassNameAndPath;
    var bool bSoloPlaySupported;
    var int DifficultyLevels;
    var int Lengths;
    var int LocalizeID;

    structdefaultproperties
    {
        FriendlyName=""
        ClassNameAndPath=""
        bSoloPlaySupported=false
        DifficultyLevels=0
        Lengths=0
        LocalizeID=0
    }
};

struct native GameMapCycle
{
    var array<string> Maps;

    structdefaultproperties
    {
        Maps=none
    }
};

struct native KFPlayerReservation
{
    var UniqueNetId PlayerID;
    var int Timer;

    structdefaultproperties
    {
        PlayerID=(Uid=none)
        Timer=0
    }
};

struct native PlayerGroupStruct
{
    var byte Team;
    var array<UniqueNetId> PlayerGroup;

    structdefaultproperties
    {
        Team=128
        PlayerGroup=none
    }
};

var const int POINTS_FOR_BOSS_KILL;
var const int POINTS_FOR_WAVE_COMPLETION;
var const int POINTS_PENALTY_FOR_DEATH;
var KFGameReplicationInfo MyKFGRI;
var class<KFPawn_Customization> CustomizationPawnClass;
var globalconfig float FriendlyFireScale;
var KFTeamInfo_Human Teams[2];
var bool bOnePlayerAtStart;
var bool bStartFinalCount;
var config bool bWaitForNetPlayers;
var globalconfig bool bDisableKickVote;
var globalconfig bool bDisablePublicTextChat;
var globalconfig bool bDisableVOIP;
var globalconfig bool bPartitionSpectators;
var globalconfig bool bDisablePickups;
var globalconfig bool bDisableMapVote;
var globalconfig bool bDisableTeamCollision;
var globalconfig bool bEnableDeadToVOIP;
var globalconfig bool bDisablePublicVOIPChannel;
var const bool bCanPerkAlwaysChange;
var bool bZedTimeBlendingOut;
var config bool bEnableGameAnalytics;
var config bool bRecordGameStatsFile;
var globalconfig bool bUseMapList;
var config bool bLogScoring;
var config bool bLogAIDefaults;
var bool bLogReservations;
var bool bLogAnalytics;
var config bool bLogAICount;
var protected const bool bIsCustomGame;
var private const bool bIsUnrankedGame;
var const bool bEnableServerVersionCheck;
var bool bIsVersusGame;
var bool bNVAlwaysDramatic;
var bool bNVBlockDramatic;
var bool bNVAlwaysHeadshot;
var bool bNVDebugDamage;
var bool bLogGroupTeamBalance;
var int HumanDeaths;
var class<KFGFxMoviePlayer_Manager> KFGFxManagerClass;
var globalconfig int GameLength;
var config int MinNetPlayers;
var globalconfig int ReadyUpDelay;
var globalconfig int GameStartDelay;
var config int EndOfGameDelay;
var config array<config sGameMode> GameModes;
var globalconfig float KickVotePercentage;
var globalconfig float TimeBetweenFailedVotes;
var globalconfig float MapVotePercentage;
var globalconfig float MapVoteDuration;
var globalconfig string ServerMOTD;
var globalconfig Color ServerMOTDColor;
var globalconfig string BannerLink;
var globalconfig string WebsiteLink;
var globalconfig Color WebLinkColor;
var globalconfig string ClanMotto;
var globalconfig Color ClanMottoColor;
var const config float ServerExpirationForKillWhenEmpty;
var const int ReconnectRespawnTime;
var private const float XPMultiplier;
var KFGameDifficultyInfo DifficultyInfo;
var class<KFGameDifficultyInfo> DifficultyInfoClass;
var class<KFGameDifficultyInfo> DifficultyInfoConsoleClass;
var array<KFTraderTrigger> TraderList;
var array<KFPickupFactory> ItemPickups;
var array<KFPickupFactory> AmmoPickups;
var array<KFPickupFactory> AllPickupFactories;
var byte NumWeaponPickups;
var byte NumAmmoPickups;
var const byte ForcedNumLivingPlayers;
var array<float> DeathPenaltyModifiers;
var array<float> MaxRespawnDosh;
var int MaxGameDifficulty;
var array<float> GameLengthDoshScale;
var array< class<KFAISpawnManager> > SpawnManagerClasses;
var KFGameConductor GameConductor;
var class<KFGameConductor> GameConductorClass;
var KFAIDirector AIDirector;
var int AIAliveCount;
var int NumAISpawnsQueued;
var private const int NumAlwaysRelevantZeds;
var KFAISpawnManager SpawnManager;
var protected const array< class<KFPawn_Monster> > AIClassList;
var protected const array< class<KFPawn_Monster> > AIBossClassList;
/** What percentage of normal game speed to slow down the game during ZedTime */
var() float ZedTimeSlomoScale;
/** How long to blend out zed time dilation for */
var() float ZedTimeBlendOutTime;
var float ZedTimeRemaining;
var int ZedTimeExtensionsUsed;
var float LastZedTimeEvent;
var class<KFGameplayEventsWriter> GameplayEventsWriterClass;
var transient KFGameplayEventsWriter GameplayEventsWriter;
var globalconfig array<config GameMapCycle> GameMapCycles;
var globalconfig int ActiveMapCycle;
var globalconfig int MapCycleIndex;
var config array<config string> InValidMaps;
var KFDialogManager DialogManager;
var class<KFDialogManager> DialogManagerClass;
var class<KFTraderVoiceGroupBase> TraderVoiceGroupClass;
var float ActionMusicDelay;
var array<KFMusicTrackInfo> ForcedMusicTracks;
var transient array<KFPlayerReservation> PlayerReservations;
var int ReservationTimeout;
var transient array<PlayerGroupStruct> PlayerGroups;
var const float LastUpToDateCheckTime;
var transient KFSteamWebUpToDateCheck UpToDateChecker;

// Export UKFGameInfo::execGetMonsterAliveCount(FFrame&, void* const)
native function int GetMonsterAliveCount();

// Export UKFGameInfo::execGetLivingPlayerCount(FFrame&, void* const)
native function int GetLivingPlayerCount();

// Export UKFGameInfo::execForceLivingPlayerCount(FFrame&, void* const)
native function ForceLivingPlayerCount(byte NewPlayerNum);

// Export UKFGameInfo::execRefreshMonsterAliveCount(FFrame&, void* const)
native function RefreshMonsterAliveCount();

// Export UKFGameInfo::execGetAIDirector(FFrame&, void* const)
native function KFAIDirector GetAIDirector();

// Export UKFGameInfo::execIsMapAllowedInCycle(FFrame&, void* const)
native function bool IsMapAllowedInCycle(string MapName);

// Export UKFGameInfo::execMapCycleNeedsInit(FFrame&, void* const)
native function bool MapCycleNeedsInit();

// Export UKFGameInfo::execSetGameUnranked(FFrame&, void* const)
native final function SetGameUnranked(bool bUnranked);

// Export UKFGameInfo::execIsUnrankedGame(FFrame&, void* const)
protected native function bool IsUnrankedGame();

static event class<GameInfo> SetGameType(string MapName, string Options, string Portal)
{
    local string ThisMapPrefix;
    local int I;
    local class<GameInfo> NewGameType;
    local string GameOption;

    if(Class'WorldInfo'.static.IsMenuLevel(MapName))
    {
        return Class'KFGameInfo_Entry';
    }
    GameOption = ParseOption(Options, "Game");
    if(GameOption != "")
    {
        return default.Class;
    }
    MapName = StripPlayOnPrefix(MapName);
    ThisMapPrefix = Left(MapName, InStr(MapName, "-"));
    I = 0;
    J0xC0:

    if(I < default.DefaultMapPrefixes.Length)
    {
        if(default.DefaultMapPrefixes[I].Prefix ~= ThisMapPrefix)
        {
            NewGameType = class<GameInfo>(DynamicLoadObject(default.DefaultMapPrefixes[I].GameType, Class'Class'));
            if(NewGameType != none)
            {
                return NewGameType;
            }
        }
        ++ I;
        goto J0xC0;
    }
    I = 0;
    J0x18B:

    if(I < default.CustomMapPrefixes.Length)
    {
        if(default.CustomMapPrefixes[I].Prefix ~= ThisMapPrefix)
        {
            NewGameType = class<GameInfo>(DynamicLoadObject(default.CustomMapPrefixes[I].GameType, Class'Class'));
            if(NewGameType != none)
            {
                return NewGameType;
            }
        }
        ++ I;
        goto J0x18B;
    }
    return default.Class;
}

static function string StripPlayOnPrefix(string MapName)
{
    if(Left(MapName, 6) ~= "UEDPIE")
    {
        return Right(MapName, Len(MapName) - 6);        
    }
    else
    {
        if(Left(MapName, 5) ~= "UEDPC")
        {
            return Right(MapName, Len(MapName) - 5);            
        }
        else
        {
            if(Left(MapName, 6) ~= "UEDPS3")
            {
                return Right(MapName, Len(MapName) - 6);                
            }
            else
            {
                if(Left(MapName, 6) ~= "UED360")
                {
                    return Right(MapName, Len(MapName) - 6);                    
                }
                else
                {
                    if(Left(MapName, 6) ~= "UEDIOS")
                    {
                        return Right(MapName, Len(MapName) - 6);
                    }
                }
            }
        }
    }
    return MapName;
}

static function PreloadContentClasses(KFGameReplicationInfo GRI);

static function string GetGameModeFriendlyNameFromNum(int GameModeNum)
{
    return default.GameModes[Max(GameModeNum, 0)].FriendlyName;
}

static function string GetGameModeFriendlyNameFromClass(string GameModeClassString)
{
    return default.GameModes[Max(default.GameModes.Find('ClassNameAndPath', GameModeClassString, 0)].FriendlyName;
}

static function int GetGameModeNumFromClass(string GameModeClassString)
{
    return default.GameModes.Find('ClassNameAndPath', GameModeClassString;
}

static function string GetGameModeClassFromNum(int GameModeNum)
{
    return default.GameModes[Max(GameModeNum, 0)].ClassNameAndPath;
}

static function int GetLocalizeIDFromFriendlyName(string FriendlyNameString)
{
    return default.GameModes[Max(default.GameModes.Find('FriendlyName', FriendlyNameString, 0)].LocalizeID;
}

static function bool IsGameModeSoloPlayAllowed(int GameModeNum)
{
    return default.GameModes[GameModeNum].bSoloPlaySupported;
}

function string GetFriendlyNameForCurrentGameMode()
{
    return GetGameModeFriendlyNameFromClass("KFGameContent." $ string(Class));
}

function int GetGameModeNum()
{
    return GetGameModeNumFromClass(PathName(default.Class));
}

function string GetFullGameModePath()
{
    return GetGameModeClassFromNum(GetGameModeNum());
}

// Export UKFGameInfo::execSetNeedsRestart(FFrame&, void* const)
native function SetNeedsRestart();

// Export UKFGameInfo::execDisableServerTakeover(FFrame&, void* const)
native final function DisableServerTakeover();

// Export UKFGameInfo::execSetNeedsReload(FFrame&, void* const)
native function SetNeedsReload();

// Export UKFGameInfo::execStaticSetNeedsRestart(FFrame&, void* const)
native static function StaticSetNeedsRestart();

event InitGame(string Options, out string ErrorMessage)
{
    super(GameInfo).InitGame(Options, ErrorMessage);
    GameLength = Clamp(GetIntOption(Options, "GameLength", GameLength), 0, SpawnManagerClasses.Length - 1);
    GameDifficulty = float(Clamp(int(GameDifficulty), 0, MaxGameDifficulty));
    if((OnlineSub != none) && OnlineSub.GetLobbyInterface() != none)
    {
        OnlineSub.GetLobbyInterface().LobbyJoinGame();
    }
    if(Role == ROLE_Authority)
    {
        if(DialogManagerClass != none)
        {
            DialogManager = Spawn(DialogManagerClass);
        }
    }
    if((ParseOption(Options, "Private")) ~= "1")
    {
        GameEngine(Class'Engine'.static.GetEngine()).bPrivateServer = true;
        UpdateGameSettings();
    }
    if(MapCycleNeedsInit())
    {
        MapCycleIndex = -1;
        SaveConfig();
    }
    GameStartDelay = Clamp(GetIntOption(Options, "GameStartDelay", GameStartDelay), 0, 60);
    ReadyUpDelay = Clamp(GetIntOption(Options, "ReadyUpDelay", ReadyUpDelay), 0, 300);
    EndOfGameDelay = Clamp(GetIntOption(Options, "EndOfGameDelay", EndOfGameDelay), 0, 120);
    FriendlyFireScale = FClamp(GetFloatOption(Options, "FriendlyFireScale", FriendlyFireScale), 0, 1);
    CheckForCustomSettings();
    CreateDifficultyInfo(Options);
}

function CreateDifficultyInfo(string Options)
{
    if((DifficultyInfoConsoleClass != none) && WorldInfo.IsConsoleBuild() || WorldInfo.IsConsoleDedicatedServer())
    {
        LogInternal("Using difficulty override class:" @ string(DifficultyInfoConsoleClass));
        DifficultyInfo = new (self) DifficultyInfoConsoleClass;        
    }
    else
    {
        DifficultyInfo = new (self) DifficultyInfoClass;
    }
    DifficultyInfo.SetDifficultySettings(GameDifficulty);
}

static function float GetFloatOption(string Options, string ParseString, float CurrentValue)
{
    local string InOpt;

    InOpt = ParseOption(Options, ParseString);
    if(InOpt != "")
    {
        return float(InOpt);
    }
    return CurrentValue;
}

// Export UKFGameInfo::execCheckForCustomSettings(FFrame&, void* const)
protected native function CheckForCustomSettings();

event PreBeginPlay()
{
    WorldInfo.TWApplyTweaks();
    super(GameInfo).PreBeginPlay();
    MyKFGRI = KFGameReplicationInfo(GameReplicationInfo);
    InitGRIVariables();
    CreateTeam(0);
    InitGameConductor();
    InitAIDirector();
    InitTraderList();
    ReplicateWelcomeScreen();
    WorldInfo.TWLogsInit();
}

event PostBeginPlay()
{
    InitAllPickups();
    InitGameplayEventWriter();
    super(GameInfo).PostBeginPlay();
    if(WasLaunchedByPlayfab())
    {
        SetTimer(ServerExpirationForKillWhenEmpty, true, 'CheckPopulation');
    }
}

function InitGameplayEventWriter()
{
    if(bRecordGameStatsFile && GameplayEventsWriterClass != none)
    {
        LogInternal("Recording game events with" @ string(GameplayEventsWriterClass));
        GameplayEventsWriter = new (self) GameplayEventsWriterClass;        
    }
    else
    {
        LogInternal("Gameplay events will not be recorded.");
    }
}

function ReplicateWelcomeScreen()
{
    local WorldInfo WI;

    WI = Class'WorldInfo'.static.GetWorldInfo();
    if(WI.NetMode != NM_DedicatedServer)
    {
        return;
    }
    if(MyKFGRI != none)
    {
        MyKFGRI.ServerAdInfo.BannerLink = BannerLink;
        MyKFGRI.ServerAdInfo.ServerMOTD = Repl(ServerMOTD, "@nl@", Chr(10));
        MyKFGRI.ServerAdInfo.WebsiteLink = WebsiteLink;
        MyKFGRI.ServerAdInfo.ClanMotto = ClanMotto;
    }
}

event PreLogin(string Options, string Address, const UniqueNetId UniqueId, bool bSupportsAuth, out string ErrorMessage)
{
    local bool bSpectator, bPerfTesting;
    local string DesiredDifficulty, DesiredWaveLength, DesiredGameMode;

    if(((WorldInfo.NetMode != NM_Standalone) && bUsingArbitration) && bHasArbitratedHandshakeBegun)
    {
        ErrorMessage = PathName(WorldInfo.Game.GameMessageClass) $ ".ArbitrationMessage";
        return;
    }
    if((AccessControl != none) && AccessControl.IsIDBanned(UniqueId))
    {
        LogInternal(Address @ "is banned, rejecting...");
        ErrorMessage = "<Strings:KFGame.KFLocalMessage.BannedFromServerString>";
        return;
    }
    if((WorldInfo.NetMode == NM_DedicatedServer) && !HasOption(Options, "bJoinViaInvite"))
    {
        DesiredDifficulty = ParseOption(Options, "Difficulty");
        if((DesiredDifficulty != "") && float(int(DesiredDifficulty)) != GameDifficulty)
        {
            LogInternal((("Got bad difficulty" @ DesiredDifficulty) @ "expected") @ string(GameDifficulty));
            ErrorMessage = "<Strings:KFGame.KFLocalMessage.ServerNoLongerAvailableString>";
            return;
        }
        DesiredWaveLength = ParseOption(Options, "GameLength");
        if((DesiredWaveLength != "") && int(DesiredWaveLength) != GameLength)
        {
            LogInternal((("Got bad wave length" @ DesiredWaveLength) @ "expected") @ string(GameLength));
            ErrorMessage = "<Strings:KFGame.KFLocalMessage.ServerNoLongerAvailableString>";
            return;
        }
        DesiredGameMode = ParseOption(Options, "Game");
        if((DesiredGameMode != "") && !DesiredGameMode ~= (GetFullGameModePath()))
        {
            LogInternal((("Got bad wave length" @ DesiredGameMode) @ "expected") @ (GetFullGameModePath()));
            ErrorMessage = "<Strings:KFGame.KFLocalMessage.ServerNoLongerAvailableString>";
            return;
        }
    }
    bPerfTesting = (ParseOption(Options, "AutomatedPerfTesting")) ~= "1";
    bSpectator = (bPerfTesting || (ParseOption(Options, "SpectatorOnly")) ~= "1") || (ParseOption(Options, "CauseEvent")) ~= "FlyThrough";
    if(AccessControl != none)
    {
        AccessControl.PreLogin(Options, Address, UniqueId, bSupportsAuth, ErrorMessage, bSpectator);
    }
}

event PostLogin(PlayerController NewPlayer)
{
    local KFPlayerController KFPC;
    local int OldNumSpectators;

    OldNumSpectators = NumSpectators;
    super(GameInfo).PostLogin(NewPlayer);
    if((PlayfabInter != none) && PlayfabInter.IsRegisteredWithPlayfab())
    {
        SetTimer(1.5, false, 'UpdateGameSettings');        
    }
    else
    {
        if(OldNumSpectators != NumSpectators)
        {
            UpdateGameSettings();
        }
    }
    KFPC = KFPlayerController(NewPlayer);
    if(KFPC != none)
    {
        if(KFPC.PlayerReplicationInfo.bOnlySpectator)
        {
            KFPC.ClientSetFrontEnd(KFGFxManagerClass, true);            
        }
        else
        {
            if(KFPC.GetTeamNum() == 255)
            {
                if(!Class'Engine'.static.IsEditor() && !Class'KFGameEngine'.static.CheckSkipLobby())
                {
                    KFPC.CreateCustomizationPawn();
                }
                if((KFPC.Pawn != none) && KFPawn_Customization(KFPC.Pawn) != none)
                {
                    KFPawn_Customization(KFPC.Pawn).SetServerHidden(true);
                    KFPC.SetCameraMode('PlayerZedWaiting');
                }
                KFPC.ClientSetFrontEnd(KFGFxManagerClass, false);                
            }
            else
            {
                KFPC.ClientSetFrontEnd(KFGFxManagerClass, false);
                if(!Class'Engine'.static.IsEditor() && !Class'KFGameEngine'.static.CheckSkipLobby())
                {
                    KFPC.CreateCustomizationPawn();
                }
            }
        }
    }
}

function Logout(Controller Exiting)
{
    local int OldNumSpectators;

    OldNumSpectators = NumSpectators;
    super(GameInfo).Logout(Exiting);
    if((PlayfabInter != none) && PlayfabInter.IsRegisteredWithPlayfab())
    {
        SetTimer(1.5, false, 'UpdateGameSettings');        
    }
    else
    {
        if(OldNumSpectators != NumSpectators)
        {
            UpdateGameSettings();
        }
    }
    if((PlayfabInter != none) && PlayfabInter.IsRegisteredWithPlayfab())
    {
        if(PlayerController(Exiting) != none)
        {
            SetTimer(0.01, false, 'CheckPopulation');
            if((Exiting.PlayerReplicationInfo != none) && Exiting.PlayerReplicationInfo.PlayfabPlayerId != "")
            {
                PlayfabInter.ServerNotifyPlayerLeft(Exiting.PlayerReplicationInfo.PlayfabPlayerId);
            }
        }
    }
}

function ProcessServerTravel(string URL, optional bool bAbsolute)
{
    super(GameInfo).ProcessServerTravel(URL, bAbsolute);
    Class'KFMapTravelData'.static.SetLastTravelTime(WorldInfo.RealTimeSeconds);
    Class'KFMapTravelData'.static.SetLastGameMap(WorldInfo.GetMapName(true));
    LogInternal("SESSIONS - Clearing ConsoleGameSessionGuid for a new map" @ URL);
    KFGameEngine(Class'Engine'.static.GetEngine()).ConsoleGameSessionGuid = "";
}

function CheckPopulation()
{
    local bool bNeedsShutdown;
    local int I;

    if(!bLevelChange && WasLaunchedByPlayfab())
    {
        bNeedsShutdown = true;
        I = 0;
        J0x35:

        if(I < GameReplicationInfo.PRIArray.Length)
        {
            if(!GameReplicationInfo.PRIArray[I].bBot)
            {
                bNeedsShutdown = false;
                goto J0xC2;
            }
            ++ I;
            goto J0x35;
        }
    }
    J0xC2:

    if(bNeedsShutdown)
    {
        LogInternal("Server needs shutdown! Exiting now");        
        ConsoleCommand("Exit");
    }
}

event InitAIDirector()
{
    AIDirector = new (self) Class'KFAIDirector';
    AIDirector.Initialize();
}

function InitGameConductor()
{
    GameConductor = new (self) GameConductorClass;
    GameConductor.Initialize();
}

function InitGRIVariables()
{
    MyKFGRI.GameDifficulty = byte(GameDifficulty);
    MyKFGRI.GameLength = byte(GameLength);
    MyKFGRI.bVersusGame = bIsVersusGame;
}

function bool AllowCheats(PlayerController P)
{
    return false;
}

function InitTraderList()
{
    local KFTraderTrigger MyTrader;

    TraderList.Remove(0, TraderList.Length;
    foreach DynamicActors(Class'KFTraderTrigger', MyTrader)
    {
        TraderList.AddItem(MyTrader;        
    }    
}

function InitAllPickups()
{
    if(bDisablePickups || DifficultyInfo == none)
    {
        NumWeaponPickups = 0;
        NumAmmoPickups = 0;        
    }
    else
    {
        NumWeaponPickups = byte(float(ItemPickups.Length) * DifficultyInfo.GetItemPickupModifier());
        NumAmmoPickups = byte(float(AmmoPickups.Length) * DifficultyInfo.GetAmmoPickupModifier());
    }
    if(BaseMutator != none)
    {
        BaseMutator.ModifyPickupFactories();
    }
    ResetAllPickups();
}

function ResetAllPickups()
{
    local int I;

    AllPickupFactories.Remove(0, AllPickupFactories.Length;
    I = 0;
    J0x21:

    if(I < ItemPickups.Length)
    {
        AllPickupFactories.AddItem(ItemPickups[I];
        ++ I;
        goto J0x21;
    }
    I = 0;
    J0x72:

    if(I < AmmoPickups.Length)
    {
        AllPickupFactories.AddItem(AmmoPickups[I];
        ++ I;
        goto J0x72;
    }
    ResetPickups(ItemPickups, NumWeaponPickups);
    ResetPickups(AmmoPickups, NumAmmoPickups);
}

function ResetPickups(array<KFPickupFactory> PickupList, int NumPickups)
{
    local byte I, ChosenIndex;
    local array<KFPickupFactory> PossiblePickups;

    PossiblePickups = PickupList;
    I = 0;
    J0x1F:

    if(I < NumPickups)
    {
        ChosenIndex = byte(Rand(PossiblePickups.Length));
        PossiblePickups[ChosenIndex].Reset();
        PossiblePickups.Remove(ChosenIndex, 1;
        ++ I;
        goto J0x1F;
    }
    I = 0;
    J0xAC:

    if(I < PossiblePickups.Length)
    {
        PossiblePickups[I].StartSleeping();
        ++ I;
        goto J0xAC;
    }
}

function EnableNewPickup(array<KFPickupFactory> PickupList, float RespawnDelay, KFPickupFactory LastPickup)
{
    local KFPickupFactory ActiveFactory;

    ActiveFactory = DetermineNextPickup(PickupList, LastPickup);
    if(BaseMutator != none)
    {
        BaseMutator.ModifyActivatedPickupFactory(ActiveFactory, RespawnDelay);
    }
    ActivateNextPickup(ActiveFactory, int(RespawnDelay));
    LastPickup.StartSleeping();
}

function KFPickupFactory DetermineNextPickup(array<KFPickupFactory> PickupList, KFPickupFactory LastPickup)
{
    local byte I;
    local array<KFPickupFactory> PossibleFactories;

    I = 0;
    J0x0C:

    if(I < PickupList.Length)
    {
        if(((PickupList[I] != LastPickup) && PickupList[I].IsInState('Sleeping')) && !PickupList[I].bToBeActivated)
        {
            PossibleFactories.AddItem(PickupList[I];
        }
        ++ I;
        goto J0x0C;
    }
    if(PossibleFactories.Length > 0)
    {
        return PossibleFactories[Rand(PossibleFactories.Length)];        
    }
    else
    {
        return LastPickup;
    }
}

function ActivateNextPickup(KFPickupFactory NextFactory, int RespawnDelay)
{
    if(NextFactory != none)
    {
        NextFactory.bToBeActivated = true;
        NextFactory.SetTimer(float(RespawnDelay),, 'Reset');
    }
}

function CustomizationPointsInitialized()
{
    local KFPlayerController KFPC;
    local KFPawn_Customization KFPCustom;

    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.Pawn != none)
        {
            KFPCustom = KFPawn_Customization(KFPC.Pawn);
            if((KFPCustom != none) && !KFPCustom.bUsingCustomizationPoint)
            {
                KFPCustom.MoveToCustomizationPoint();
            }
        }        
    }    
}

function Pawn SpawnDefaultPawnFor(Controller NewPlayer, NavigationPoint StartSpot)
{
    local class<Pawn> DefaultPlayerClass;
    local Rotator StartRotation;
    local Pawn ResultPawn;

    DefaultPlayerClass = GetDefaultPlayerClass(NewPlayer);
    StartRotation.Yaw = StartSpot.Rotation.Yaw;
    ResultPawn = Spawn(DefaultPlayerClass,,, StartSpot.Location, StartRotation,, true);
    if(ResultPawn == none)
    {
        LogInternal((("Couldn't spawn player of type " $ string(DefaultPlayerClass)) $ " at ") $ string(StartSpot));
    }
    return ResultPawn;
}

function KFPawn SpawnCustomizationPawn(NavigationPoint StartSpot)
{
    local Rotator StartRotation;
    local KFPawn_Customization ResultPawn;

    StartRotation.Yaw = StartSpot.Rotation.Yaw;
    ResultPawn = Spawn(CustomizationPawnClass,,, StartSpot.Location, StartRotation,, true);
    if(ResultPawn == none)
    {
        LogInternal((("Couldn't spawn player of type " $ string(CustomizationPawnClass)) $ " at ") $ string(StartSpot));
    }
    ResultPawn.SetUpdatedMovementData(StartSpot.Location, StartRotation);
    return ResultPawn;
}

function StartHumans()
{
    local KFPlayerController KFPC;
    local int NumPlayerPawns;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        if(bGameEnded)
        {            
            return;
        }
        if((KFPC.Pawn == none) || KFPawn_Customization(KFPC.Pawn) != none)
        {
            if(KFPC.CanRestartPlayer() && KFPC.GetTeamNum() != 255)
            {
                RestartPlayer(KFPC);
            }
        }
        if((KFPC.Pawn != none) || KFPC.bWaitingForClientPerkData)
        {
            ++ NumPlayerPawns;
        }        
    }    
    bOnePlayerAtStart = NumPlayerPawns == 1;
}

function RestartPlayer(Controller NewPlayer)
{
    local KFPlayerController KFPC;
    local KFPerk MyPerk;

    KFPC = KFPlayerController(NewPlayer);
    if((KFPC != none) && KFPC.GetTeamNum() != 255)
    {
        MyPerk = KFPC.GetPerk();
        if((MyPerk == none) || !MyPerk.bInitialized)
        {
            KFPC.WaitForPerkAndRespawn();
            return;
        }
    }
    if((NewPlayer.Pawn != none) && KFPawn_Customization(NewPlayer.Pawn) != none)
    {
        NewPlayer.Pawn.Destroy();
    }
    super(GameInfo).RestartPlayer(NewPlayer);
    if(NewPlayer.Pawn != none)
    {
        if(KFPC != none)
        {
            KFPC.InitGameplayPostProcessFX();
            KFPC.ClientSetCameraFade(true, MakeColor(255, 255, 255, 255), vect2d(1, 0), 0.6, true);
        }
    }
}

function float RatePlayerStart(PlayerStart P, byte Team, Controller Player)
{
    local float Rating;

    Rating = super(GameInfo).RatePlayerStart(P, Team, Player);
    if(P.bEnabled)
    {
        if(!CheckSpawnProximity(P, Player, Team))
        {
            return 5.1;
        }
    }
    return Rating;
}

function bool ShouldSpawnAtStartSpot(Controller Player)
{
    local PlayerStart StartSpot;

    if(((Player != none) && Player.StartSpot != none) && (IsInitialSpawnPointSelection()) || (Player.PlayerReplicationInfo != none) && Player.PlayerReplicationInfo.bWaitingPlayer)
    {
        StartSpot = PlayerStart(Player.StartSpot);
        if(StartSpot == none)
        {
            return true;
        }
        return (RatePlayerStart(StartSpot, Player.GetTeamNum(), Player)) >= 6;
    }
    return false;
}

function KFCustomizationPoint FindCustomizationStart(Controller Player)
{
    local KFCustomizationPoint CP;

    foreach AllActors(Class'KFCustomizationPoint', CP)
    {
        if(CheckSpawnProximity(CP, Player, Player.GetTeamNum(), true))
        {            
            return CP;
        }        
    }    
    return CP;
}

function bool CheckSpawnProximity(NavigationPoint P, Controller Player, byte TeamNum, optional bool bCustomizationPoint)
{
    local PlayerController PC;
    local KFPawn_Customization CPawn;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC == Player)
        {
            continue;            
        }
        if((IsInitialSpawnPointSelection()) && !bCustomizationPoint)
        {
            if((PC.StartSpot == P) && PC.GetTeamNum() == TeamNum)
            {                
                return false;
            }
            continue;
        }
        if((PC.Pawn != none) && !PC.Pawn.bHidden)
        {
            if(bCustomizationPoint)
            {
                CPawn = KFPawn_Customization(PC.Pawn);
                if((CPawn != none) && CPawn.bServerHidden)
                {
                    continue;                    
                }
            }
            if(VSizeSq(PC.Pawn.Location - P.Location) < Square(2.1 * PC.Pawn.GetCollisionRadius()))
            {                
                return false;
            }
        }        
    }    
    return true;
}

function bool IsInitialSpawnPointSelection()
{
    return bWaitingToStartMatch;
}

function SetPlayerDefaults(Pawn PlayerPawn)
{
    local KFPawn KFP;

    KFP = KFPawn(PlayerPawn);
    if((KFP != none) && KFP.GetPerk() != none)
    {
        if(KFP.GetPerk() != none)
        {
            KFP.GetPerk().SetPlayerDefaults(KFP);
        }
        KFP.bIgnoreTeamCollision = bDisableTeamCollision;
    }
    if(BaseMutator != none)
    {
        BaseMutator.ModifyPlayer(PlayerPawn);
    }
    PlayerPawn.PhysicsVolume.ModifyPlayer(PlayerPawn);
}

function bool IsWaveActive();

static function float GetNumAlwaysRelevantZeds()
{
    return float(default.NumAlwaysRelevantZeds);
}

function SetMonsterDefaults(KFPawn_Monster P)
{
    local float HealthMod, HeadHealthMod, TotalSpeedMod, StartingSpeedMod, DamageMod;

    local int LivingPlayerCount;

    LivingPlayerCount = GetLivingPlayerCount();
    DamageMod = 1;
    HealthMod = 1;
    HeadHealthMod = 1;
    if(P.bVersusZed)
    {
        DifficultyInfo.GetVersusHealthModifier(P, byte(LivingPlayerCount), HealthMod, HeadHealthMod);
        HealthMod *= GameConductor.CurrentVersusZedHealthMod;
        HeadHealthMod *= GameConductor.CurrentVersusZedHealthMod;
        P.DifficultyDamageMod = DamageMod * GameConductor.CurrentVersusZedDamageMod;
        StartingSpeedMod = 1;
        TotalSpeedMod = 1;        
    }
    else
    {
        DifficultyInfo.GetAIHealthModifier(P, GameDifficulty, byte(LivingPlayerCount), HealthMod, HeadHealthMod);
        DamageMod = DifficultyInfo.GetAIDamageModifier(P, GameDifficulty, bOnePlayerAtStart);
        P.DifficultyDamageMod = DamageMod;
        StartingSpeedMod = DifficultyInfo.GetAISpeedMod(P, GameDifficulty);
        TotalSpeedMod = GameConductor.CurrentAIMovementSpeedMod * StartingSpeedMod;
    }
    P.GroundSpeed = P.default.GroundSpeed * TotalSpeedMod;
    P.SprintSpeed = P.default.SprintSpeed * TotalSpeedMod;
    P.NormalGroundSpeed = P.GroundSpeed;
    P.NormalSprintSpeed = P.SprintSpeed;
    P.InitialGroundSpeedModifier = StartingSpeedMod;
    P.Health = int(float(P.default.Health) * HealthMod);
    if(P.default.HealthMax == 0)
    {
        P.HealthMax = int(float(P.default.Health) * HealthMod);        
    }
    else
    {
        P.HealthMax = int(float(P.default.HealthMax) * HealthMod);
    }
    P.ApplySpecialZoneHealthMod(HeadHealthMod);
    P.GameResistancePct = DifficultyInfo.GetDamageResistanceModifier(byte(LivingPlayerCount));
    if(bLogAIDefaults)
    {
        LogInternal(("==== SetMonsterDefaults for pawn: " @ string(P)) @ "====");
    }
    if(bLogAIDefaults)
    {
        LogInternal((((("HealthMod: " @ string(HealthMod)) @ "Original Health: ") @ string(P.default.Health)) @ " Final Health = ") @ string(P.Health));
    }
    if(bLogAIDefaults)
    {
        LogInternal((((("HeadHealthMod: " @ string(HeadHealthMod)) @ "Original Head Health: ") @ string(P.default.HitZones[0].GoreHealth)) @ " Final Head Health = ") @ string(P.HitZones[0].GoreHealth));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("GroundSpeedMod: " @ string(TotalSpeedMod)) @ " Final Ground Speed = ") @ string(P.GroundSpeed));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("SprintSpeedMod: " @ string(TotalSpeedMod)) @ " Final Sprint Speed = ") @ string(P.SprintSpeed));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("DamageMod: " @ string(DamageMod)) @ " Final Melee Damage = ") @ string(P.MeleeAttackHelper.BaseDamage * DamageMod));
    }
}

function SetTeam(Controller Other, KFTeamInfo_Human NewTeam)
{
    if(((Other.PlayerReplicationInfo == none) || Other.PlayerReplicationInfo.bOnlySpectator) || NewTeam == Other.PlayerReplicationInfo.Team)
    {
        return;
    }
    if(Other.PlayerReplicationInfo.Team != none)
    {
        Other.PlayerReplicationInfo.Team.RemoveFromTeam(Other);
        Other.PlayerReplicationInfo.Team = none;
    }
    if((NewTeam == none) || (NewTeam != none) && NewTeam.AddToTeam(Other))
    {
        if((NewTeam != none) && ((WorldInfo.NetMode != NM_Standalone) || PlayerController(Other) == none) || PlayerController(Other).Player != none)
        {
            BroadcastLocalizedMessage(GameMessageClass, 3, Other.PlayerReplicationInfo, none, NewTeam);
        }
        GameConductor.HandlePlayerChangedTeam();
    }
    Other.PlayerReplicationInfo.bNetDirty = true;
    Other.PlayerReplicationInfo.bForceNetUpdate = true;
}

function CreateTeam(int TeamIndex)
{
    Teams[TeamIndex] = Spawn(Class'KFTeamInfo_Human');
    GameReplicationInfo.SetTeam(TeamIndex, Teams[TeamIndex]);
}

function byte PickTeam(byte Current, Controller C, const out UniqueNetId PlayerID)
{
    return 0;
}

function bool ChangeTeam(Controller Other, int N, bool bNewTeam)
{
    if(PlayerController(Other) == none)
    {
        SetTeam(Other, Teams[N]);
        return true;
    }
    if(((Other.PlayerReplicationInfo != none) && !Other.PlayerReplicationInfo.bOnlySpectator) && Other.PlayerReplicationInfo.Team != Teams[0])
    {
        SetTeam(Other, Teams[0]);
        return true;
    }
    return false;
}

function bool CanSpectate(PlayerController Viewer, PlayerReplicationInfo ViewTarget)
{
    local PlayerController TargetController;

    if(ViewTarget.RemoteRole == ROLE_None)
    {
        return false;
    }
    TargetController = PlayerController(ViewTarget.Owner);
    return ((TargetController != none) && TargetController.Pawn != none) && TargetController.Pawn.IsAliveAndWell();
}

function ReduceDamage(out int Damage, Pawn injured, Controller InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType, Actor DamageCauser)
{
    local class<KFDamageType> KFDT;

    KFDT = class<KFDamageType>(DamageType);
    if(((KFDT != none) && InstigatedBy != none) && InstigatedBy == injured.Controller)
    {
        if(KFDT.default.bNoInstigatorDamage)
        {
            Damage = 0;            
        }
        else
        {
            if(!KFDT.default.bIgnoreSelfInflictedScale)
            {
                Damage *= DifficultyInfo.GetSelfInflictedDamageMod();
            }
        }
        Momentum = vect(0, 0, 0);
    }
    if(((Damage > 0) && InstigatedBy != none) && InstigatedBy != injured.Controller)
    {
        if(injured.IsHumanControlled() && injured.GetTeamNum() == InstigatedBy.GetTeamNum())
        {
            Damage *= FriendlyFireScale;
            Momentum = vect(0, 0, 0);
        }
    }
    super(GameInfo).ReduceDamage(Damage, injured, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser);
}

function Killed(Controller Killer, Controller KilledPlayer, Pawn KilledPawn, class<DamageType> DT)
{
    local KFPlayerReplicationInfo KilledPRI;
    local KFPlayerController KFPC;
    local int PlayerScoreDelta, TeamPenalty;
    local KFPerk KFPCP;
    local KFPawn_Monster MonsterPawn;
    local string KillerLabel;
    local class<DamageType> LastHitByDamageType;

    if((KilledPlayer != none) && KilledPlayer.bIsPlayer)
    {
        if(((KilledPlayer.GetTeamNum() == 0) && Killer != none) && Killer.GetTeamNum() == 255)
        {
            GameConductor.NotifyHumanTeamPlayerDeath();
        }
        KilledPRI = KFPlayerReplicationInfo(KilledPlayer.PlayerReplicationInfo);
        if(KilledPRI != none)
        {
            if(KilledPlayer == Killer)
            {
                KillerLabel = "self";                
            }
            else
            {
                if(Killer != none)
                {
                    if(Killer.Pawn != none)
                    {
                        KillerLabel = string(Killer.Pawn.Class.Name);                        
                    }
                    else
                    {
                        KillerLabel = string(Killer.Class.Name);
                    }                    
                }
                else
                {
                    KillerLabel = "Player";
                }
            }
            PlayerScoreDelta = GetAdjustedDeathPenalty(KilledPRI);
            if(bLogScoring)
            {
                LogInternal((("SCORING: Player" @ KilledPRI.PlayerName) @ "next starting dosh =") @ string(float(PlayerScoreDelta) + KilledPRI.Score));
            }
            KilledPRI.AddDosh(PlayerScoreDelta);
            TeamPenalty = GetAdjustedTeamDeathPenalty(KilledPRI);
            if(KilledPRI.Team != none)
            {
                KFTeamInfo_Human(KilledPRI.Team).AddScore(-TeamPenalty);
                if(bLogScoring)
                {
                    LogInternal(("SCORING: Team lost" @ string(TeamPenalty)) @ "dosh for a player dying");
                }
            }
            KilledPRI.PlayerHealth = 0;
            KilledPRI.PlayerHealthPercent = 0;
        }
        KFPC = KFPlayerController(KilledPlayer);
        if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
        {
            WorldInfo.TWLogEvent("player_death", KilledPRI, KillerLabel, string(DT.Name), "#" $ string(MyKFGRI.WaveNum), ((KFPC != none) ? KFPC.GetPerk().PerkName : ""), string(((KFPC != none) ? KFPC.GetPerk().GetLevel() : byte(0))), (((KilledPawn != none) && KilledPawn.InvManager != none) ? KFInventoryManager(KilledPawn.InvManager).DumpInventory() : ""));
        }
    }
    super(GameInfo).Killed(Killer, KilledPlayer, KilledPawn, DT);
    if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
    {
        GameplayEventsWriter.LogPlayerKillDeath(104, 200, Killer, DT, KilledPlayer);
    }
    if(Killer != KilledPlayer)
    {
        CheckZedTimeOnKill(Killer, KilledPlayer, KilledPawn, DT);
    }
    if((KilledPawn != none) && KilledPawn.GetTeamNum() == 255)
    {
        if(Killer != none)
        {
            KFPC = KFPlayerController(Killer);
            if(KFPC != none)
            {
                MonsterPawn = KFPawn_Monster(KilledPawn);
                if(MonsterPawn != none)
                {
                    LastHitByDamageType = GetLastHitByDamageType(DT, MonsterPawn, Killer);
                    KFPC.AddZedKill(MonsterPawn.Class, byte(GameDifficulty), LastHitByDamageType);
                    KFPCP = KFPC.GetPerk();
                    if(KFPCP != none)
                    {
                        if(KFPCP.CanEarnSmallRadiusKillXP(LastHitByDamageType))
                        {
                            CheckForBerserkerSmallRadiusKill(MonsterPawn, KFPC);
                        }
                        KFPCP.AddVampireHealth(KFPC, LastHitByDamageType);
                    }
                }
            }
        }
        RefreshMonsterAliveCount();
        if(SpawnManager != none)
        {
            -- MyKFGRI.AIRemaining;
            if(bLogAICount)
            {
                LogInternal("@@@@ ZED COUNT DEBUG: MyKFGRI.AIRemaining =" @ string(MyKFGRI.AIRemaining));
            }
            if(bLogAICount)
            {
                LogInternal("@@@@ ZED COUNT DEBUG: AIAliveCount =" @ string(AIAliveCount));
            }
        }
    }
}

function class<DamageType> GetLastHitByDamageType(class<DamageType> DT, KFPawn_Monster P, Controller Killer)
{
    local class<KFDamageType> RealDT;

    if(DT == none)
    {
        return none;
    }
    RealDT = class<KFDamageType>(DT);
    if(RealDT != none)
    {
        if(((RealDT.default.WeaponDef == none) && P.HitFxInfo.DamageType != none) && Killer == P.LastHitBy)
        {
            if((!RealDT.default.bAnyPerk && !RealDT.default.bCausedByWorld) && RealDT.default.DoT_Type != 3)
            {
                WarnInternal(("Damage Type " @ string(RealDT.Name)) @ " has not had its weapon definition initialized");
            }
            RealDT = P.HitFxInfo.DamageType;
        }        
    }
    else
    {
        WarnInternal("GetLastHitByDamageType() Received non-KFDamageType damagetype:" @ string(DT));
    }
    return RealDT;
}

function BroadcastDeathMessage(Controller Killer, Controller Other, class<DamageType> DamageType)
{
    if(Killer == none)
    {
        if(Other.GetTeamNum() != 255)
        {
            BroadcastLocalized(self, Class'KFLocalMessage_Game', 27, none, Other.PlayerReplicationInfo, DamageType);
        }        
    }
    else
    {
        if(Killer == Other)
        {
            BroadcastLocalized(self, Class'KFLocalMessage_Game', 28, none, Other.PlayerReplicationInfo);            
        }
        else
        {
            if(((Killer.Pawn != none) && !Killer.Pawn.IsHumanControlled()) || KFAIController(Killer) != none)
            {
                BroadcastLocalized(self, Class'KFLocalMessage_Game', 27, none, Other.PlayerReplicationInfo, ((Killer.Pawn != none) ? Killer.Pawn.Class : Class'KFPawn_Human'));                
            }
            else
            {
                BroadcastLocalized(self, Class'KFLocalMessage_PlayerKills', 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo);
            }
        }
    }
}

function int GetAdjustedDeathPenalty(KFPlayerReplicationInfo KilledPlayerPRI, optional bool bLateJoiner)
{
    bLateJoiner = false;
}

function int GetAdjustedTeamDeathPenalty(KFPlayerReplicationInfo KilledPlayerPRI)
{
    return Round((KilledPlayerPRI.Score * GameDifficulty) * 0.05);
}

function BossDied(Controller Killer, optional bool bCheckWaveEnded)
{
    bCheckWaveEnded = true;
}

static function int GetBossKillScore()
{
    return default.POINTS_FOR_BOSS_KILL;
}

function ScoreDamage(int DamageAmount, int HealthBeforeDamage, Controller InstigatedBy, Pawn DamagedPawn, class<DamageType> DamageType)
{
    if((((InstigatedBy == none) || !InstigatedBy.bIsPlayer) || InstigatedBy.PlayerReplicationInfo == none) || InstigatedBy.GetTeamNum() == DamagedPawn.GetTeamNum())
    {
        return;
    }
    DamageAmount = Min(DamageAmount, HealthBeforeDamage);
    KFPlayerReplicationInfo(InstigatedBy.PlayerReplicationInfo).DamageDealtOnTeam += DamageAmount;
}

function ScoreKill(Controller Killer, Controller Other)
{
    if(((Killer != none) && Killer.PlayerReplicationInfo != none) && Killer != Other)
    {
        ++ Killer.PlayerReplicationInfo.Kills;
        Killer.bForceNetUpdate = true;
        if(Other.Pawn.IsA('KFPawn_Monster'))
        {
            ScoreMonsterKill(Killer, Other, KFPawn_Monster(Other.Pawn));
        }
    }
    if((((Killer != none) && Other != none) && Killer == Other) && Other.Pawn.IsA('KFPawn_Monster'))
    {
        ScoreMonsterKill(Killer, Other, KFPawn_Monster(Other.Pawn));
    }
    ModifyScoreKill(Killer, Other);
    if((Killer != none) || MaxLives > 0)
    {
        CheckScore(Killer.PlayerReplicationInfo);
    }
}

protected function ScoreMonsterKill(Controller Killer, Controller Monster, KFPawn_Monster MonsterPawn)
{
    if(MonsterPawn != none)
    {
        if(MonsterPawn.DamageHistory.Length > 0)
        {
            DistributeMoneyAndXP(MonsterPawn.Class, MonsterPawn.DamageHistory, Killer);
            if((MonsterPawn.IsStalkerClass() && MonsterPawn.LastStoredCC != none) && MonsterPawn.bIsCloakingSpottedByTeam)
            {
                AddPlayerXP(MonsterPawn.LastStoredCC, int(MonsterPawn.GetXPValue(byte(GameDifficulty))), Class'KFPerk_Commando');
            }
        }
    }
    if((WorldInfo.NetMode == NM_DedicatedServer) && Killer.GetTeamNum() == 0)
    {
        if((KFPlayerController(Killer) != none) && KFPlayerController(Killer).MatchStats != none)
        {
            KFPlayerController(Killer).MatchStats.RecordZedKill(MonsterPawn.Class, none);
        }
    }
}

function CheckForBerserkerSmallRadiusKill(KFPawn_Monster MonsterPawn, KFPlayerController KFPC)
{
    local KFPawn_Human KFPH;

    if(KFPC == none)
    {
        return;
    }
    foreach WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
    {
        if(((KFPH != none) && KFPH.IsAliveAndWell()) && KFPH.Controller != KFPC)
        {
            if(VSizeSq(KFPH.Location - MonsterPawn.Location) <= float(Class'KFPerk_Berserker'.static.GetSmallRadiusKillDistanceSQ()))
            {
                KFPC.AddSmallRadiusKill(byte(GameDifficulty));
                break;
            }
        }        
    }    
}

function float GetAdjustedAIDoshValue(class<KFPawn_Monster> MonsterClass)
{
    local float TempValue;

    TempValue = float(MonsterClass.static.GetDoshValue());
    TempValue *= DifficultyInfo.GetKillCashModifier();
    ModifyAIDoshValueForPlayerCount(TempValue);
    TempValue *= GameLengthDoshScale[GameLength];
    return TempValue;
}

function ModifyAIDoshValueForPlayerCount(out float ModifiedValue)
{
    local float DoshMod;

    DoshMod = float(GetNumPlayers()) / DifficultyInfo.GetPlayerNumMaxAIModifier(byte(GetNumPlayers()));
    ModifiedValue *= DoshMod;
}

function int GetNumPlayers()
{
    return super(GameInfo).GetNumPlayers();
}

function int GetNumHumanTeamPlayers()
{
    local Controller C;
    local int HumanTeamPlayers;

    foreach WorldInfo.AllControllers(Class'Controller', C)
    {
        if(((C.bIsPlayer && C.PlayerReplicationInfo != none) && !C.PlayerReplicationInfo.bOnlySpectator) && C.GetTeamNum() == 0)
        {
            ++ HumanTeamPlayers;
        }        
    }    
    return HumanTeamPlayers;
}

protected function DistributeMoneyAndXP(class<KFPawn_Monster> MonsterClass, const out array<DamageInfo> DamageHistory, Controller Killer)
{
    local int I, J, TotalDamage, EarnedDosh;
    local float AdjustedAIValue, ScoreDenominator, XP;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo DamagerKFPRI;
    local KFPerk InstigatorPerk;

    I = 0;
    J0x0B:

    if(I < DamageHistory.Length)
    {
        TotalDamage += int(DamageHistory[I].TotalDamage);
        ++ I;
        goto J0x0B;
    }
    if(TotalDamage <= 0)
    {
        WarnInternal("Total damage given to this zed is less or equal zero! This should never happen");
        return;
    }
    AdjustedAIValue = GetAdjustedAIDoshValue(MonsterClass);
    ScoreDenominator = AdjustedAIValue / float(TotalDamage);
    I = 0;
    J0x10F:

    if(I < DamageHistory.Length)
    {
        if((((DamageHistory[I].DamagerController != none) && DamageHistory[I].DamagerController.bIsPlayer) && DamageHistory[I].DamagerPRI.GetTeamNum() == 0) && DamageHistory[I].DamagerPRI != none)
        {
            EarnedDosh = Round(DamageHistory[I].TotalDamage * ScoreDenominator);
            DamagerKFPRI = KFPlayerReplicationInfo(DamageHistory[I].DamagerPRI);
            if(DamagerKFPRI != none)
            {
                if(Killer.PlayerReplicationInfo != DamagerKFPRI)
                {
                    ++ DamagerKFPRI.Assists;
                    if(DamageHistory[I].DamagePerks.Length == 1)
                    {
                        DamageHistory[I].DamagePerks[0].static.ModifyAssistDosh(EarnedDosh);
                    }
                }
                DamagerKFPRI.AddDosh(EarnedDosh, true);
                if(DamagerKFPRI.Team != none)
                {
                    KFTeamInfo_Human(DamagerKFPRI.Team).AddScore(EarnedDosh);
                    if(DamageHistory[I].DamagePerks.Length <= 0)
                    {                        
                    }
                    else
                    {
                        KFPC = KFPlayerController(DamagerKFPRI.Owner);
                        if(KFPC != none)
                        {
                            InstigatorPerk = KFPC.GetPerk();
                            if(InstigatorPerk.ShouldGetAllTheXP())
                            {
                                AddPlayerXP(KFPC, int(MonsterClass.static.GetXPValue(byte(GameDifficulty))), InstigatorPerk.Class);                                
                            }
                            else
                            {
                                XP = MonsterClass.static.GetXPValue(byte(GameDifficulty)) / float(DamageHistory[I].DamagePerks.Length);
                                J = 0;
                                J0x569:

                                if(J < DamageHistory[I].DamagePerks.Length)
                                {
                                    AddPlayerXP(KFPC, FCeil(XP), DamageHistory[I].DamagePerks[J]);
                                    ++ J;
                                    goto J0x569;
                                }
                            }
                        }
                    }
                }
            }
        }
        ++ I;
        goto J0x10F;
    }
}

// Export UKFGameInfo::execAddPlayerXP(FFrame&, void* const)
private native final function AddPlayerXP(KFPlayerController PC, int XP, class<KFPerk> PerkClass);

function DramaticEvent(float ZedTimeChance, optional float Duration)
{
    local float TimeSinceLastEvent;
    local KFPlayerController KFPC;

    Duration = 3;
    if(bNVBlockDramatic)
    {
        return;
    }
    TimeSinceLastEvent = WorldInfo.TimeSeconds - LastZedTimeEvent;
    if(BaseMutator != none)
    {
        BaseMutator.ModifyZedTime(TimeSinceLastEvent, ZedTimeChance, Duration);
    }
    if((TimeSinceLastEvent < 10) && ZedTimeChance < 1)
    {
        return;
    }
    if(TimeSinceLastEvent > float(60))
    {
        ZedTimeChance *= 4;        
    }
    else
    {
        if(TimeSinceLastEvent > float(30))
        {
            ZedTimeChance *= 2;
        }
    }
    if((FRand() <= ZedTimeChance) && Duration > ZedTimeRemaining)
    {
        ZedTimeRemaining = Duration;
        bZedTimeBlendingOut = false;
        LastZedTimeEvent = WorldInfo.TimeSeconds;
        SetZedTimeDilation(ZedTimeSlomoScale);
        foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
        {
            if(KFPC != none)
            {
                KFPC.EnterZedTime();
            }            
        }        
    }
}

function Tick(float DeltaTime)
{
    if(ZedTimeRemaining > 0)
    {
        TickZedTime(DeltaTime);
    }
}

function TickZedTime(float DeltaTime)
{
    local float TrueTimeFactor;
    local KFPlayerController KFPC;

    TrueTimeFactor = 1 / (CustomTimeDilation * WorldInfo.TimeDilation);
    ZedTimeRemaining -= (DeltaTime * TrueTimeFactor);
    if(ZedTimeRemaining <= float(0))
    {
        bZedTimeBlendingOut = false;
        SetZedTimeDilation(1);
        ZedTimeExtensionsUsed = 0;        
    }
    else
    {
        if(ZedTimeRemaining < ZedTimeBlendOutTime)
        {
            if(!bZedTimeBlendingOut)
            {
                bZedTimeBlendingOut = true;
                foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
                {
                    if(KFPC != none)
                    {
                        KFPC.FadeOutZedTime();
                    }                    
                }                
            }
            SetZedTimeDilation(Lerp(1, ZedTimeSlomoScale, ZedTimeRemaining / ZedTimeBlendOutTime));
        }
    }
}

function bool IsZedTimeActive()
{
    return ZedTimeRemaining > 0;
}

function SetZedTimeDilation(float NewTimeDilation)
{
    SetGameSpeed(NewTimeDilation);
}

function CheckZedTimeOnKill(Controller Killer, Controller KilledPlayer, Pawn KilledPawn, class<DamageType> DamageType)
{
    local bool bIsHuman;
    local KFPlayerController KFPC;
    local KFPerk KillersPerk;
    local class<KFDamageType> KFDT;

    KFDT = class<KFDamageType>(DamageType);
    if((KFDT != none) && KFDT.default.DoT_Type != 0)
    {
        return;
    }
    if(IsZedTimeActive())
    {
        KFPC = KFPlayerController(Killer);
        if(KFPC != none)
        {
            KillersPerk = KFPC.GetPerk();
            if(((ZedTimeRemaining > 0) && KillersPerk != none) && KillersPerk.GetZedTimeExtension(KFPC.GetLevel()) > float(ZedTimeExtensionsUsed))
            {
                DramaticEvent(1);
                ++ ZedTimeExtensionsUsed;
            }
        }        
    }
    else
    {
        if(bNVAlwaysDramatic)
        {
            DramaticEvent(1);
        }
        bIsHuman = KilledPawn.IsA('KFPawn_Human');
        if(bIsHuman)
        {
            DramaticEvent(0.05);
            return;
        }
        if(KilledPawn.Controller == none)
        {
            return;
        }
        if(((Killer != none) && Killer.Pawn != none) && VSizeSq(Killer.Pawn.Location - KilledPawn.Location) < float(90000))
        {
            DramaticEvent(0.05);            
        }
        else
        {
            DramaticEvent(0.025);
        }
    }
}

function NotifyHeadshotKill(Controller Killer, Pawn KilledPawn)
{
    if(bNVAlwaysDramatic)
    {
        DramaticEvent(1);
    }
    if(((Killer != none) && Killer.Pawn != none) && VSizeSq(Killer.Pawn.Location - KilledPawn.Location) > Square(2500))
    {
        DramaticEvent(0.05);        
    }
    else
    {
        DramaticEvent(0.03);
    }
}

function NotifyNavigationChanged(NavigationPoint N)
{
    local KFAIController AI;
    local int Idx;

    if(N.bBlocked)
    {
        foreach WorldInfo.AllControllers(Class'KFAIController', AI)
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging && AI != none)
            {
                AI.AILog_Internal((((string(GetFuncName()) $ "() Notifying ") $ string(AI)) $ " that navigation has changed for ") $ string(N), 'PathWarning');
            }
            if(!AI.bMovingToGoal)
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && AI != none)
                {
                    AI.AILog_Internal((((string(GetFuncName()) $ "() ** Skipping notification for ") $ string(AI)) $ " because bMovingToGoal was false. bPreparingMove? : ") $ string(AI.bPreparingMove), 'PathWarning');
                }
                continue;                
            }
            Idx = AI.RouteCache.Find(N;
            if(Idx >= 0)
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && AI != none)
                {
                    AI.AILog_Internal((((string(GetFuncName()) $ "() setting bReEvaluatePath to true for ") $ string(AI)) $ " thanks to ") $ string(N), 'PathWarning');
                }
                AI.bReevaluatePath = true;
                AI.MoveTimer = -1;
                AI.ForcePauseAndRepath();
                continue;
            }
            if(!Class'Engine'.static.GetEngine().bDisableAILogging && AI != none)
            {
                AI.AILog_Internal((((((((("** WARNING ** " $ string(GetFuncName())) $ " for ") $ string(N)) $ " not telling ") $ string(AI)) $ " to reevaluate path because I couldn't find ") $ string(N)) $ " in the routecache! bPreparingMove: ") $ string(AI.bPreparingMove), 'PathWarning');
            }            
        }        
    }
}

function byte GetGameIntensityForMusic();

static function bool ShouldPlayActionMusicTrack(KFGameReplicationInfo GRI);

static function bool ShouldPlayMusicAtStart();

simulated function ForceMenuMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[0]);
}

simulated function ForceCreditsMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[1]);
}

simulated function ForceHansMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[2]);
}

simulated function ForcePatriarchMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[3]);
}

simulated function ForceMatriarchMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[4]);
}

function string GetNextMap()
{
    local array<string> MapList;
    local int I;

    if(bUseMapList && GameMapCycles.Length > 0)
    {
        if(MapCycleIndex == -1)
        {
            MapList = GameMapCycles[ActiveMapCycle].Maps;
            MapCycleIndex = GetCurrentMapCycleIndex(MapList);
            if(MapCycleIndex == -1)
            {
                MapCycleIndex = 0;
            }
        }
        I = 0;
        J0xA8:

        if(I < GameMapCycles[ActiveMapCycle].Maps.Length)
        {
            MapCycleIndex = (((MapCycleIndex + 1) < GameMapCycles[ActiveMapCycle].Maps.Length) ? MapCycleIndex + 1 : 0);
            if(IsMapAllowedInCycle(GameMapCycles[ActiveMapCycle].Maps[MapCycleIndex]))
            {
                SaveConfig();
                return GameMapCycles[ActiveMapCycle].Maps[MapCycleIndex];
            }
            ++ I;
            goto J0xA8;
        }
        return string(WorldInfo.GetPackageName());        
    }
    else
    {
        return string(WorldInfo.GetPackageName());
    }
    return "";
}

function int GetCurrentMapCycleIndex(const out array<string> MapList)
{
    return MapList.Find(string(WorldInfo.GetPackageName());
}

exec function MaintenanceRestart()
{
    SetNeedsRestart();
}

function UnregisterPlayer(PlayerController PC)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(PC);
    if(KFPC != none)
    {
        if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
        {
            WorldInfo.TWLogEvent("player_disconnected", KFPC.PlayerReplicationInfo, "#" $ string(MyKFGRI.WaveNum));
        }
        KFPC.ClientWriteAndFlushStats();
    }
    super(GameInfo).UnregisterPlayer(PC);
}

function AddInactivePRI(PlayerReplicationInfo PRI, PlayerController PC)
{
    local KFPlayerReplicationInfo NewKFPRI;

    if(!PRI.bFromPreviousLevel && !PRI.bOnlySpectator)
    {
        NewKFPRI = KFPlayerReplicationInfo(PRI);
        NewKFPRI.LastQuitTime = WorldInfo.TimeSeconds;
    }
    super(GameInfo).AddInactivePRI(PRI, PC);
}

function bool FindInactivePRI(PlayerController PC)
{
    local KFPlayerReplicationInfo NewKFPRI;

    if(super(GameInfo).FindInactivePRI(PC))
    {
        NewKFPRI = KFPlayerReplicationInfo(PC.PlayerReplicationInfo);
        ++ NewKFPRI.NumTimesReconnected;
        return true;
    }
    return false;
}

function bool UniqueIdPresent(out array<UniqueNetId> PlayerIDs, UniqueNetId PlayerID)
{
    local UniqueNetId I;

    foreach PlayerIDs(I,)
    {
        if(I == PlayerID)
        {            
            return true;
        }        
    }    
    return false;
}

function bool ReservationPresent(UniqueNetId PlayerID)
{
    local KFPlayerReservation I;

    foreach PlayerReservations(I,)
    {
        if(I.PlayerID == PlayerID)
        {            
            return true;
        }        
    }    
    return false;
}

function UniqueIdAdd(out array<UniqueNetId> PlayerIDs, UniqueNetId PlayerID)
{
    if(!UniqueIdPresent(PlayerIDs, PlayerID))
    {
        PlayerIDs.AddItem(PlayerID;
    }
}

function bool AtCapacity(bool bSpectator, const optional UniqueNetId PlayerID)
{
    if(bSpectator)
    {
        return super(GameInfo).AtCapacity(bSpectator);
    }
    if((GetAvailableReservations()) <= 0)
    {
        return !ReservationPresent(PlayerID);
    }
    return super(GameInfo).AtCapacity(bSpectator);
}

event MakeReservations(const string URLOptions, const UniqueNetId PlayerID, out string OutError)
{
    local array<UniqueNetId> Reservations;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.MakeReservations");
    }
    ReadReservations(URLOptions, PlayerID, Reservations);
    if(Reservations.Length > 0)
    {
        if(!AddPlayerReservations(Reservations))
        {
            if(bLogReservations)
            {
                LogInternal("KFGameInfo.MakeReservations failed");
            }
            OutError = ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".MaxedOutMessage>";
        }
    }
}

event PlayerController Login(string Portal, string Options, const UniqueNetId UniqueId, out string ErrorMessage)
{
    local PlayerController SpawnedPC;
    local string ClientAuthTicket, PlayerfabPlayerId;

    SeatPlayer(UniqueId);
    SpawnedPC = super(GameInfo).Login(Portal, Options, UniqueId, ErrorMessage);
    if(((PlayfabInter != none) && PlayfabInter.IsRegisteredWithPlayfab()) && SpawnedPC != none)
    {
        LogInternal("Player login with options" @ Options);
        ClientAuthTicket = ParseOption(Options, "AuthTicket");
        PlayerfabPlayerId = ParseOption(Options, "PlayfabPlayerId");
        LogInternal((("Player controller log in with auth ticket" @ ClientAuthTicket) @ "and playfab player id") @ PlayerfabPlayerId);
        if(ClientAuthTicket != "")
        {
        }
        SpawnedPC.PlayerReplicationInfo.PlayfabPlayerId = PlayerfabPlayerId;
        ReadGameplayTimeForPlayer(PlayerfabPlayerId);
    }
    return SpawnedPC;
}

event SendServerMaintenanceMessage()
{
    BroadcastLocalizedMessage(Class'KFLocalMessage', 4);
}

function UniqueReservationAdd(UniqueNetId PlayerID)
{
    local KFPlayerReservation I, Reservation;
    local bool bFound;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.UniqueReservationAdd" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
    }
    bFound = false;
    foreach PlayerReservations(I,)
    {
        if(I.PlayerID == PlayerID)
        {
            bFound = true;            
        }
        else
        {            
        }
    }    
    if(!bFound)
    {
        if(bLogReservations)
        {
            LogInternal("KFGameInfo.UniqueReservationAdd adding" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
        }
        Reservation.PlayerID = PlayerID;
        Reservation.Timer = 0;
        PlayerReservations.AddItem(Reservation;
    }
}

function RemoveDuplicates(out array<UniqueNetId> PlayerIDs)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PlayerIDs.Length)
    {
        if(ReservationPresent(PlayerIDs[I]))
        {
            PlayerIDs.Remove(I, 1;            
        }
        else
        {
            ++ I;
        }
        goto J0x0B;
    }
}

function StripFromMatchmakingGroups(const out UniqueNetId PlayerID)
{
    local int GroupIndex, MemberIndex;

    if(bLogGroupTeamBalance)
    {
        LogInternal(("StripFromMatchmakingGroups: Checking if player" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID)) @ "is already in a group");
    }
    GroupIndex = PlayerGroups.Length - 1;
    J0x9B:

    if(GroupIndex >= 0)
    {
        MemberIndex = PlayerGroups[GroupIndex].PlayerGroup.Length - 1;
        J0xDE:

        if(MemberIndex >= 0)
        {
            if(PlayerGroups[GroupIndex].PlayerGroup[MemberIndex] == PlayerID)
            {
                if(bLogGroupTeamBalance)
                {
                    LogInternal((("StripFromMatchmakingGroups: Removing player" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID)) @ "from group") @ string(GroupIndex));
                }
                PlayerGroups[GroupIndex].PlayerGroup.Remove(MemberIndex, 1;
            }
            -- MemberIndex;
            goto J0xDE;
        }
        if(PlayerGroups[GroupIndex].PlayerGroup.Length == 0)
        {
            if(bLogGroupTeamBalance)
            {
                LogInternal(("StripFromMatchmakingGroups: Removing empty group" @ string(GroupIndex)) @ "from group list");
            }
            PlayerGroups.Remove(GroupIndex, 1;
        }
        -- GroupIndex;
        goto J0x9B;
    }
}

function AddPlayerMatchmakingGroup(const out array<UniqueNetId> PlayerIDs)
{
    local UniqueNetId I;
    local PlayerGroupStruct TempPlayerGroup;
    local int LogIndex;
    local UniqueNetId StupidUnrealscriptBS;

    if(PlayerIDs.Length < 2)
    {
        LogInternal("AddPlayerMatchmakingGroup: Not creating a group for a single player.");
        return;
    }
    foreach PlayerIDs(I,)
    {
        StripFromMatchmakingGroups(I);        
    }    
    TempPlayerGroup.PlayerGroup = PlayerIDs;
    PlayerGroups.Add(1;
    PlayerGroups[PlayerGroups.Length - 1] = TempPlayerGroup;
    if(bLogGroupTeamBalance)
    {
        LogInternal(("AddPlayerMatchmakingGroup: Adding new matchmaking group at position" @ string(PlayerGroups.Length - 1)) @ "with members:");
        LogIndex = 0;
        J0x15D:

        if(LogIndex < PlayerGroups[PlayerGroups.Length - 1].PlayerGroup.Length)
        {
            StupidUnrealscriptBS = PlayerGroups[PlayerGroups.Length - 1].PlayerGroup[LogIndex];
            LogInternal("	" $ Class'OnlineSubsystem'.static.UniqueNetIdToString(StupidUnrealscriptBS));
            ++ LogIndex;
            goto J0x15D;
        }
    }
}

function bool AddPlayerReservations(out array<UniqueNetId> PlayerIDs)
{
    local UniqueNetId PlayerID;
    local int OldCount;

    RemoveDuplicates(PlayerIDs);
    if(PlayerIDs.Length == 0)
    {
        return true;
    }
    if(PlayerIDs.Length > (GetAvailableReservations()))
    {
        return false;
    }
    AddPlayerMatchmakingGroup(PlayerIDs);
    OldCount = PlayerReservations.Length;
    foreach PlayerIDs(PlayerID,)
    {
        UniqueReservationAdd(PlayerID);        
    }    
    if((OldCount == 0) && PlayerReservations.Length > 0)
    {
        SetTimer(1, true, 'TimeReservations');
    }
    return true;
}

function TimeReservations()
{
    local int I;
    local UniqueNetId stupid;

    I = 0;
    J0x0B:

    if(I < PlayerReservations.Length)
    {
        stupid = PlayerReservations[I].PlayerID;
        if(PlayerReservations[I].Timer > ReservationTimeout)
        {
            if(bLogReservations)
            {
                LogInternal(("KFGameInfo.TimeReservations expiring player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
            }
            PlayerReservations.Remove(I, 1;
            if(bLogGroupTeamBalance)
            {
                LogInternal("TimeReservations: expiring player" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
            }
            StripFromMatchmakingGroups(stupid);            
        }
        else
        {
            if(PlayerReservations[I].Timer >= 0)
            {
                ++ PlayerReservations[I].Timer;
                if(bLogReservations)
                {
                    if(bLogReservations)
                    {
                        LogInternal(((("KFGameInfo.TimeReservations player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid)) @ "=") @ string(PlayerReservations[I].Timer));
                    }
                }
            }
            ++ I;
        }
        goto J0x0B;
    }
    if(PlayerReservations.Length == 0)
    {
        ClearTimer('TimeReservations');
    }
}

function ReadReservations(const string URLOptions, const UniqueNetId PlayerID, out array<UniqueNetId> Reservations)
{
    local string OptionsCopy, Option, Key, Value;
    local UniqueNetId Id;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ReadReservations reading reservations from" @ URLOptions);
    }
    OptionsCopy = URLOptions;
    Reservations.Remove(0, Reservations.Length;
    J0x7B:

    if((GrabOption(OptionsCopy, Option)) && Reservations.Length < 5)
    {
        GetKeyValue(Option, Key, Value);
        if((Len(Key) == 6) && Left(Key, 5) ~= "party")
        {
            if(Class'OnlineSubsystem'.static.StringToUniqueNetId(Value, Id))
            {
                if(bLogReservations)
                {
                    LogInternal("KFGameInfo.ReadReservations for player" @ Key);
                }
                UniqueIdAdd(Reservations, Id);
            }            
        }
        else
        {
            if((Key ~= "SpectatorOnly") && Value ~= "1")
            {
                if(bLogReservations)
                {
                    LogInternal(((("KFGameInfo.ReadReservations found" @ Key) $ "=") $ Value) @ "in URL, making no reservations");
                }
                Reservations.Remove(0, Reservations.Length;
                return;
            }
        }
        goto J0x7B;
    }
    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ReadReservations for player" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
    }
    UniqueIdAdd(Reservations, PlayerID);
}

event bool ConfirmReservation(const UniqueNetId PlayerID)
{
    local KFPlayerReservation I;
    local UniqueNetId stupid;
    local int Index;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ConfirmReservation");
    }
    foreach PlayerReservations(I, Index)
    {
        if(I.PlayerID == PlayerID)
        {
            stupid = I.PlayerID;
            if(bLogReservations)
            {
                if(bLogReservations)
                {
                    LogInternal(("KFGameInfo.ConfirmReservation for player" @ string(Index)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
                }
            }
            PlayerReservations[Index].Timer = -1;
            if(bLogReservations)
            {
                LogInternal(((("KFGameInfo.TimeReservations" @ string(Index)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid)) @ "timer is") @ string(PlayerReservations[Index].Timer));
            }            
            return true;
        }        
    }    
    return false;
}

event bool SeatPlayer(const UniqueNetId SeatedPlayerID)
{
    local int I;
    local UniqueNetId stupid;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.SeatPlayer");
    }
    I = 0;
    J0x32:

    if(I < PlayerReservations.Length)
    {
        if(PlayerReservations[I].PlayerID == SeatedPlayerID)
        {
            if(bLogReservations)
            {
                stupid = PlayerReservations[I].PlayerID;
                if(bLogReservations)
                {
                    LogInternal(("KFGameInfo.SeatPlayer for player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
                }
            }
            PlayerReservations.Remove(I, 1;
            return true;
        }
        ++ I;
        goto J0x32;
    }
    return false;
}

function int GetAvailableReservations()
{
    return (MaxPlayers - (GetNumPlayers())) - PlayerReservations.Length;
}

// Export UKFGameInfo::execAllowBalanceLogging(FFrame&, void* const)
native static function bool AllowBalanceLogging();

// Export UKFGameInfo::execAllowAnalyticsLogging(FFrame&, void* const)
native static function bool AllowAnalyticsLogging();

function LogPlayersInventory()
{
    local PlayerController PC;
    local Inventory Item;
    local string InvString;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if((PC.Pawn != none) && PC.Pawn.InvManager != none)
        {
            InvString = "";
            Item = PC.Pawn.InvManager.InventoryChain;
            J0x102:

            if(Item != none)
            {                
                InvString $= (string(Item.Class.Name) $ ",");
                Item = Item.Inventory;
                goto J0x102;
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((string('Inventory') $ ",") $ PC.PlayerReplicationInfo.PlayerName) $ ",") $ InvString);
            }
        }        
    }    
}

function LogPlayersDosh(name EventName)
{
    local KFPlayerController PC;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        if((PC.PlayerReplicationInfo != none) && !PC.PlayerReplicationInfo.bIsSpectator)
        {
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((((string(EventName) $ ",") $ PC.PlayerReplicationInfo.PlayerName) $ ",") $ "$") $ string(PC.PlayerReplicationInfo.Score)) $ ",") $ string(PC.GetPerk()));
            }
        }        
    }    
}

function LogPlayersKillCount()
{
    local KFPlayerController PC;
    local PlayerReplicationInfo PRI;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        PRI = PC.PlayerReplicationInfo;
        if((PRI != none) && !PRI.bIsSpectator)
        {
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Kills') $ ",") $ PRI.PlayerName) $ ",") $ string(PRI.Kills)) $ ",") $ string(PC.GetPerk()));
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Deaths') $ ",") $ PRI.PlayerName) $ ",") $ string(PRI.Deaths)) $ ",") $ string(PC.GetPerk()));
            }
        }        
    }    
}

function SetCountdown(bool bFinalCountdown, byte CountdownTime)
{
    local KFPlayerController PC;
    local byte TeamNum;

    bStartFinalCount = bFinalCountdown;
    SetTimer(float(CountdownTime), false, 'LobbyCountdownComplete');
    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        if(bFinalCountdown)
        {
            TeamNum = PC.GetTeamNum();
            if((TeamNum == 0) && !ShouldSpawnAtStartSpot(PC))
            {
                PC.StartSpot = none;
                PC.StartSpot = FindPlayerStart(PC, TeamNum);
            }
            PC.ClientSetCountdown(bFinalCountdown, CountdownTime, PC.StartSpot);
            continue;
        }
        PC.ClientSetCountdown(bFinalCountdown, CountdownTime);        
    }    
}

function ResetCountDown()
{
    local KFPlayerController KFPC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.ClientResetCountdown();        
    }    
}

function LobbyCountdownComplete()
{
    local KFPlayerController KFPC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.PlayerReplicationInfo.bReadyToPlay = true;        
    }    
    StartMatch();
}

private final function CheckServerUnlock()
{
    local bool bWasAvailableForTakeover;
    local KFGameEngine KFEngine;
    local PlayfabInterface Playfab;

    if((GetNumPlayers()) == 0)
    {
        KFEngine = KFGameEngine(Class'Engine'.static.GetEngine());
        Playfab = KFEngine.GetPlayfabInterface();
        if(Playfab != none)
        {
            Playfab.serverDeallocate();
        }
        if(KFEngine.IsLockedServer())
        {
            bWasAvailableForTakeover = KFEngine.bAvailableForTakeover;
            KFEngine.UnlockServer();
            if(!bWasAvailableForTakeover && KFEngine.bAvailableForTakeover)
            {
                AccessControl.SetGamePassword("");
                StripPasswordFromLastURL(KFEngine);
            }
            if(bWasAvailableForTakeover != KFEngine.bAvailableForTakeover)
            {
                UpdateGameSettings();
            }
        }
    }
}

// Export UKFGameInfo::execStripPasswordFromLastURL(FFrame&, void* const)
private native final function StripPasswordFromLastURL(KFGameEngine Engine);

function StartMatch()
{
    bWaitingToStartMatch = false;
    super(GameInfo).StartMatch();
    bDelayedStart = false;
    MyKFGRI.RemainingTime = 0;
    MyKFGRI.bStopCountDown = true;
    ClearTimer('StartMatch');
    ClearTimer('LobbyCountdownComplete');
    if(GameplayEventsWriter != none)
    {
        GameplayEventsWriter.StartLogging(0);
    }
}

function bool ShouldStartMatch()
{
    if(bWaitForNetPlayers && WorldInfo.NetMode != NM_Standalone)
    {
        return NumPlayers >= MinNetPlayers;
    }
    return true;
}

function bool CheckAllPlayersReady()
{
    local int I;
    local array<KFPlayerReplicationInfo> KFPRIArray;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    I = 0;
    J0x34:

    if(I < KFPRIArray.Length)
    {
        if(!IsPlayerReady(KFPRIArray[I]))
        {
            return false;
        }
        ++ I;
        goto J0x34;
    }
    return true;
}

function bool MajorityPlayersReady()
{
    local int I, readyPlayers;
    local array<KFPlayerReplicationInfo> KFPRIArray;
    local float readyPercent;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    if(KFPRIArray.Length == 0)
    {
        return false;
    }
    I = 0;
    J0x46:

    if(I < KFPRIArray.Length)
    {
        if(IsPlayerReady(KFPRIArray[I]))
        {
            ++ readyPlayers;
        }
        ++ I;
        goto J0x46;
    }
    if(readyPlayers == 0)
    {
        return false;
    }
    readyPercent = float(readyPlayers) / float(KFPRIArray.Length);
    return readyPercent >= 0.5;
}

function bool AnyPlayerReady()
{
    local int I;
    local array<KFPlayerReplicationInfo> KFPRIArray;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    I = 0;
    J0x34:

    if(I < KFPRIArray.Length)
    {
        if(IsPlayerReady(KFPRIArray[I]))
        {
            return true;
        }
        ++ I;
        goto J0x34;
    }
    return false;
}

function bool IsPlayerReady(KFPlayerReplicationInfo PRI)
{
    return PRI.bReadyToPlay;
}

function UpdateCurrentMapVoteTime(byte NewTime, optional bool bStartTime);

function ReadGameplayTimeForPlayer(const string ForPlayerId)
{
    local array<string> Keys;

    Keys.AddItem("LastCrateGiftTime";
    Keys.AddItem("GameplayTime";
    PlayfabInter.ServerRetrieveInternalUserData(ForPlayerId, Keys);
}

function ResetGameplayTimeForPlayer(const string ForPlayerId)
{
    local array<string> Keys, Values;

    Keys.AddItem("LastCrateGiftTime";
    Values.AddItem(GenerateUTCTimeStamp();
    Keys.AddItem("GameplayTime";
    Values.AddItem("0";
    PlayfabInter.ServerUpdateInternalUserData(ForPlayerId, Keys, Values);
}

function AwardCrateToPlayer(string PlayfabPlayerId)
{
    local array<string> ItemIds;

    ItemIds.AddItem("910000";
    PlayfabInter.ServerGrantItemsForUser(PlayfabPlayerId, ItemIds);
}

event AddGameplayTimeForPlayer(KFPlayerReplicationInfo ForPRI, int AmountToAdd, optional bool bFinal)
{
    local array<string> Keys, Values;

    if((ForPRI.PlayfabPlayerId != "") && ForPRI.SecondsOfGameplay >= 0)
    {
        ForPRI.SecondsOfGameplay += AmountToAdd;
        if(bFinal && HasEnoughTimeForReward(ForPRI))
        {
            ResetGameplayTimeForPlayer(ForPRI.PlayfabPlayerId);
            ForPRI.SecondsOfGameplay = 0;
            AwardCrateToPlayer(ForPRI.PlayfabPlayerId);            
        }
        else
        {
            if(AmountToAdd > 0)
            {
                Keys.AddItem("GameplayTime";
                Values.AddItem(string(ForPRI.SecondsOfGameplay);
                PlayfabInter.ServerUpdateInternalUserData(ForPRI.PlayfabPlayerId, Keys, Values);
            }
        }
    }
}

// Export UKFGameInfo::execGenerateUTCTimeStamp(FFrame&, void* const)
native function string GenerateUTCTimeStamp();

// Export UKFGameInfo::execHasEnoughTimeForReward(FFrame&, void* const)
native function bool HasEnoughTimeForReward(KFPlayerReplicationInfo PRI);

function OnRetreivedPFInternalUserData(const string ForPlayerId, array<string> Keys, array<string> Values)
{
    local KFPlayerReplicationInfo ForPRI;
    local int I;
    local bool bFoundCrateGiftValue, bFoundGameplayValue;

    ForPRI = KFPlayerReplicationInfo(GameReplicationInfo.GetPRIByPlayfabId(ForPlayerId));
    if(ForPRI != none)
    {
        I = 0;
        J0x55:

        if(I < Keys.Length)
        {
            if(Keys[I] == "LastCrateGiftTime")
            {
                ForPRI.LastCrateGiftTimestamp = Values[I];
                bFoundCrateGiftValue = true;                
            }
            else
            {
                if(Keys[I] == "GameplayTime")
                {
                    ForPRI.SecondsOfGameplay = int(Values[I]);
                    bFoundGameplayValue = true;
                }
            }
            ++ I;
            goto J0x55;
        }
        if(!bFoundCrateGiftValue)
        {
            ForPRI.LastCrateGiftTimestamp = "Empty";
        }
        if(!bFoundGameplayValue)
        {
            ForPRI.SecondsOfGameplay = 0;
        }
    }
}

// Export UKFGameInfo::execCheckNextMap(FFrame&, void* const)
native function string CheckNextMap(string NextMap);

function OnAIChangeEnemy(BaseAIController AI, Pawn Enemy)
{
    if(BaseMutator != none)
    {
        BaseMutator.ModifyAIEnemy(AI, Enemy);
    }
}

auto state PendingMatch
{
    event Timer()
    {
        global.Timer();
        if(bDelayedStart)
        {
            if(ShouldStartMatch())
            {
                if(!IsTimerActive('LobbyCountdownComplete') && MajorityPlayersReady())
                {
                    MyKFGRI.RemainingTime = ReadyUpDelay;
                    MyKFGRI.bStopCountDown = false;
                    SetCountdown(false, byte(ReadyUpDelay));                    
                }
                else
                {
                    if(IsTimerActive('LobbyCountdownComplete') && !MajorityPlayersReady())
                    {
                        ClearTimer('LobbyCountdownComplete');
                        MyKFGRI.bStopCountDown = true;
                        ResetCountDown();
                    }
                }
                if(CheckAllPlayersReady())
                {
                    if(!bStartFinalCount)
                    {
                        SetCountdown(true, byte(GameStartDelay));
                    }                    
                }
                else
                {
                    if(bStartFinalCount)
                    {
                        SetCountdown(false, byte(MyKFGRI.RemainingTime));
                    }
                }                
            }
            else
            {
                if(IsTimerActive('LobbyCountdownComplete'))
                {
                    ClearTimer('LobbyCountdownComplete');
                    MyKFGRI.bStopCountDown = true;
                }
            }
            if(!IsTimerActive('CheckServerUnlock'))
            {
                SetTimer(float(ReadyUpDelay), false, 'CheckServerUnlock');
            }
        }
    }
    stop;    
}

defaultproperties
{
    POINTS_FOR_BOSS_KILL=10000
    POINTS_FOR_WAVE_COMPLETION=1000
    POINTS_PENALTY_FOR_DEATH=100
    CustomizationPawnClass=Class'KFPawn_Customization'
    bWaitForNetPlayers=true
    bEnableDeadToVOIP=true
    bCanPerkAlwaysChange=true
    bUseMapList=true
    bLogReservations=true
    bLogGroupTeamBalance=true
    KFGFxManagerClass=Class'KFGFxMoviePlayer_Manager'
    GameLength=1
    MinNetPlayers=1
    ReadyUpDelay=90
    GameStartDelay=4
    EndOfGameDelay=15
    GameModes(0)=(FriendlyName="Survival",ClassNameAndPath="KFGameContent.KFGameInfo_Survival",bSoloPlaySupported=true,DifficultyLevels=4,Lengths=4,LocalizeID=0)
    GameModes(1)=(FriendlyName="Versus",ClassNameAndPath="KFGameContent.KFGameInfo_VersusSurvival",bSoloPlaySupported=false,DifficultyLevels=0,Lengths=0,LocalizeID=1)
    KickVotePercentage=0.5
    TimeBetweenFailedVotes=10
    MapVoteDuration=60
    ServerMOTD="Welcome to our server. \\n \\n Have fun and good luck!"
    ServerMOTDColor=(B=254,G=254,R=254,A=192)
    BannerLink="http://art.tripwirecdn.com/TestItemIcons/MOTDServer.png"
    WebsiteLink="http://killingfloor2.com/"
    WebLinkColor=(B=254,G=254,R=254,A=192)
    ClanMotto="This is the clan motto."
    ClanMottoColor=(B=254,G=254,R=254,A=192)
    ServerExpirationForKillWhenEmpty=120
    ReconnectRespawnTime=30
    DifficultyInfoClass=Class'KFGameDifficultyInfo'
    DeathPenaltyModifiers(0)=0.05
    DeathPenaltyModifiers(1)=0.1
    DeathPenaltyModifiers(2)=0.2
    DeathPenaltyModifiers(3)=0.25
    GameLengthDoshScale(0)=1.75
    GameLengthDoshScale(1)=1
    GameLengthDoshScale(2)=0.8
    GameConductorClass=Class'KFGameConductor'
    NumAlwaysRelevantZeds=3
    ZedTimeSlomoScale=0.2
    ZedTimeBlendOutTime=0.5
    GameMapCycles(0)=(Maps=("KF-BurningParis","KF-Bioticslab","KF-Outpost","KF-VolterManor","KF-Catacombs","KF-EvacuationPoint","KF-Farmhouse","KF-BlackForest","KF-Prison","KF-ContainmentStation","KF-HostileGrounds","KF-InfernalRealm","KF-ZedLanding"))
    DialogManagerClass=Class'KFDialogManager'
    ActionMusicDelay=5
    ForcedMusicTracks(0)=KFMusicTrackInfo'WW_MMNU_Login.TrackInfo'
    ForcedMusicTracks(1)=KFMusicTrackInfo'WW_MMNU_Login.TrackInfo'
    ForcedMusicTracks(2)=KFMusicTrackInfo'WW_MACT_Default.TI_SH_Boss_DieVolter'
    ForcedMusicTracks(3)=KFMusicTrackInfo'WW_MACT_Default.TI_Boss_Patriarch'
    ForcedMusicTracks(4)=KFMusicTrackInfo'WW_MACT_Default.TI_ID_Murderer'
    ReservationTimeout=32
    bRestartLevel=false
    bPauseable=false
    bTeamGame=true
    bWaitingToStartMatch=true
    bRequiresPushToTalk=true
    DefaultPawnClass=Class'KFPawn_Human'
    HUDType=Class'KFGFxHudWrapper'
    MaxPlayersAllowed=6
    AccessControlClass=Class'KFAccessControl'
    PlayerControllerClass=Class'KFPlayerController'
    PlayerReplicationInfoClass=Class'KFPlayerReplicationInfo'
    GameReplicationInfoClass=Class'KFGameReplicationInfo'
    PopulationManagerClass=Class'GameFramework.GameCrowdPopulationManager'
    OnlineGameSettingsClass=Class'KFOnlineGameSettings'
}