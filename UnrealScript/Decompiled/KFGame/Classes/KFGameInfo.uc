/*******************************************************************************
 * KFGameInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGameInfo extends FrameworkGame
    native
    config(Game)
    hidecategories(Navigation,Movement,Collision);

const TeamDeathPenaltyPerc = 0.05f;
const MAX_GAMELENGTHS = 3;
const GBE_Inventory = 'Inventory';
const GBE_TraderOpen = 'TraderOpen';
const GBE_WaveStart = 'WaveStart';
const GBE_Buy = 'Buy';
const GBE_Sell = 'Sell';
const GBE_Pickup = 'Pickup';
const GBE_Respawn = 'Respawn';
const GBE_Kills = 'Kills';
const GBE_Deaths = 'Deaths';

enum EGameLength
{
    GL_Short,
    GL_Normal,
    GL_Long,
    GL_Custom,
    GL_MAX
};

enum EForcedMusicType
{
    EFM_MainMenu,
    EFM_Credits,
    EFM_Boss1,
    EFM_Boss2,
    EFM_Boss3,
    EFM_MAX
};

struct native GameMapCycle
{
    var array<string> Maps;

    structdefaultproperties
    {
        Maps=none
    }
};

struct PlayerReservation
{
    var UniqueNetId PlayerID;
    var int Timer;

    structdefaultproperties
    {
        PlayerID=(Uid=none)
        Timer=0
    }
};

var KFGameReplicationInfo MyKFGRI;
var class<KFPawn_Customization> CustomizationPawnClass;
var globalconfig float FriendlyFireScale;
var KFTeamInfo_Human Teams[2];
var bool bOnePlayerAtStart;
var bool bStartFinalCount;
var config bool bWaitForNetPlayers;
var globalconfig bool bDisableKickVote;
var globalconfig bool bDisablePublicTextChat;
var globalconfig bool bDisableVOIP;
var globalconfig bool bPartitionSpectators;
var globalconfig bool bDisablePickups;
var globalconfig bool bDisableMapVote;
var globalconfig bool bDisableTeamCollision;
var bool bEnableDeadToDeadVOIP;
var const bool bCanPerkAlwaysChange;
var bool bZedTimeBlendingOut;
var config bool bEnableGameAnalytics;
var config bool bEnableDevAnalytics;
var globalconfig bool bUseMapList;
var config bool bLogScoring;
var config bool bLogAIDefaults;
var bool bLogReservations;
var bool bLogAnalytics;
var bool bIsCustomGame;
var bool bIsUnrankedGame;
var const bool bEnableUpToDateCheck;
var bool bNVAlwaysDramatic;
var bool bNVBlockDramatic;
var bool bNVAlwaysHeadshot;
var bool bNVDebugDamage;
var class<KFGFxMoviePlayer_Manager> KFGFxManagerClass;
var globalconfig int GameLength;
var config int MinNetPlayers;
var config int ReadyUpDelay;
var config int GameStartDelay;
var config int EndOfGameDelay;
var globalconfig float KickVotePercentage;
var globalconfig float TimeBetweenFailedVotes;
var globalconfig float MapVotePercentage;
var globalconfig float MapVoteDuration;
var const int ReconnectRespawnTime;
var KFDifficultyInfo DifficultyInfo;
var KFDifficultyInfo DifficultyTemplate;
var array<KFTraderTrigger> TraderList;
var array<KFPickupFactory> ItemPickups;
var array<KFPickupFactory> AmmoPickups;
var array<KFPickupFactory> AllPickupFactories;
var byte NumWeaponPickups;
var byte NumAmmoPickups;
var const byte ForcedNumLivingPlayers;
var array<float> DeathPenaltyModifiers;
var array<float> MaxRespawnDosh;
var KFAIDirector AIDirector;
var int AIAliveCount;
var int NumAISpawnsQueued;
var KFAISpawnManager SpawnManager;
var protected const array< class<KFPawn_Monster> > AIClassList;
var protected const array< class<KFPawn_Monster> > AIBossClassList;
/** What percentage of normal game speed to slow down the game during ZedTime */
var() float ZedTimeSlomoScale;
/** How long to blend out zed time dilation for */
var() float ZedTimeBlendOutTime;
var float ZedTimeRemaining;
var int ZedTimeExtensionsUsed;
var float LastZedTimeEvent;
var class<KFGameplayEventsWriter> GameplayEventsWriterClass;
var transient KFGameplayEventsWriter GameplayEventsWriter;
var transient KFGameStatsUploader MCPUploader;
var globalconfig array<config GameMapCycle> GameMapCycles;
var globalconfig int ActiveMapCycle;
var globalconfig int MapCycleIndex;
var KFDialogManager DialogManager;
var class<KFDialogManager> DialogManagerClass;
var class<KFTraderVoiceGroupBase> TraderVoiceGroupClass;
var float ActionMusicDelay;
var array<KFMusicTrackInfo> ForcedMusicTracks;
var transient array<PlayerReservation> PlayerReservations;
var int ReservationTimeout;
var const float LastUpToDateCheckTime;
var transient KFSteamWebUpToDateCheck UpToDateChecker;

// Export UKFGameInfo::execGetMonsterAliveCount(FFrame&, void* const)
native function int GetMonsterAliveCount();

// Export UKFGameInfo::execGetLivingPlayerCount(FFrame&, void* const)
native function int GetLivingPlayerCount();

// Export UKFGameInfo::execForceLivingPlayerCount(FFrame&, void* const)
native function ForceLivingPlayerCount(byte NewPlayerNum);

// Export UKFGameInfo::execRefreshMonsterAliveCount(FFrame&, void* const)
native function RefreshMonsterAliveCount();

// Export UKFGameInfo::execGetAIDirector(FFrame&, void* const)
native function KFAIDirector GetAIDirector();

// Export UKFGameInfo::execIsMapAllowedInCycle(FFrame&, void* const)
native function bool IsMapAllowedInCycle(string MapName);

// Export UKFGameInfo::execMapCycleNeedsInit(FFrame&, void* const)
native function bool MapCycleNeedsInit();

// Export UKFGameInfo::execSetGameUnranked(FFrame&, void* const)
native function SetGameUnranked(bool bUnranked);

static event class<GameInfo> SetGameType(string MapName, string Options, string Portal)
{
    local string ThisMapPrefix;
    local int I;
    local class<GameInfo> NewGameType;
    local string GameOption;

    if(Class'WorldInfo'.static.IsMenuLevel(MapName))
    {
        return Class'KFGameInfo_Entry';
    }
    GameOption = ParseOption(Options, "Game");
    if(GameOption != "")
    {
        return default.Class;
    }
    MapName = StripPlayOnPrefix(MapName);
    ThisMapPrefix = Left(MapName, InStr(MapName, "-"));
    I = 0;
    J0xC0:

    if(I < default.DefaultMapPrefixes.Length)
    {
        if(default.DefaultMapPrefixes[I].Prefix ~= ThisMapPrefix)
        {
            NewGameType = class<GameInfo>(DynamicLoadObject(default.DefaultMapPrefixes[I].GameType, Class'Class'));
            if(NewGameType != none)
            {
                return NewGameType;
            }
        }
        ++ I;
        goto J0xC0;
    }
    I = 0;
    J0x18B:

    if(I < default.CustomMapPrefixes.Length)
    {
        if(default.CustomMapPrefixes[I].Prefix ~= ThisMapPrefix)
        {
            NewGameType = class<GameInfo>(DynamicLoadObject(default.CustomMapPrefixes[I].GameType, Class'Class'));
            if(NewGameType != none)
            {
                return NewGameType;
            }
        }
        ++ I;
        goto J0x18B;
    }
    return default.Class;
}

static function string StripPlayOnPrefix(string MapName)
{
    if(Left(MapName, 6) ~= "UEDPIE")
    {
        return Right(MapName, Len(MapName) - 6);        
    }
    else
    {
        if(Left(MapName, 5) ~= "UEDPC")
        {
            return Right(MapName, Len(MapName) - 5);            
        }
        else
        {
            if(Left(MapName, 6) ~= "UEDPS3")
            {
                return Right(MapName, Len(MapName) - 6);                
            }
            else
            {
                if(Left(MapName, 6) ~= "UED360")
                {
                    return Right(MapName, Len(MapName) - 6);                    
                }
                else
                {
                    if(Left(MapName, 6) ~= "UEDIOS")
                    {
                        return Right(MapName, Len(MapName) - 6);
                    }
                }
            }
        }
    }
    return MapName;
}

static function PreloadContentClasses(KFGameReplicationInfo GRI);

// Export UKFGameInfo::execSetNeedsRestart(FFrame&, void* const)
native static function SetNeedsRestart(bool bOutOfDate);

event InitGame(string Options, out string ErrorMessage)
{
    super(GameInfo).InitGame(Options, ErrorMessage);
    GameLength = Clamp(GetIntOption(Options, "GameLength", GameLength), 0, 3);
    OnlineSub.GetLobbyInterface().LobbyJoinGame();
    if(Role == ROLE_Authority)
    {
        if(DialogManagerClass != none)
        {
            DialogManager = Spawn(DialogManagerClass);
        }
    }
    if(MapCycleNeedsInit())
    {
        MapCycleIndex = -1;
        SaveConfig();
    }
    bIsCustomGame = CheckForCustomSettings();
    GameStartDelay = Clamp(GetIntOption(Options, "GameStartDelay", GameStartDelay), 0, 60);
    ReadyUpDelay = Clamp(GetIntOption(Options, "ReadyUpDelay", ReadyUpDelay), 0, 300);
    EndOfGameDelay = Clamp(GetIntOption(Options, "EndOfGameDelay", EndOfGameDelay), 0, 120);
    FriendlyFireScale = FClamp(GetFloatOption(Options, "FriendlyFireScale", FriendlyFireScale), 0, 1);
}

static function float GetFloatOption(string Options, string ParseString, float CurrentValue)
{
    local string InOpt;

    InOpt = ParseOption(Options, ParseString);
    if(InOpt != "")
    {
        return float(InOpt);
    }
    return CurrentValue;
}

protected function bool CheckForCustomSettings()
{
    return (bDisablePickups || MaxPlayers < 6) || FriendlyFireScale > 0;
}

event PreBeginPlay()
{
    super(GameInfo).PreBeginPlay();
    DifficultyInfo = new (self) Class'KFDifficultyInfo' (DifficultyTemplate);
    DifficultyInfo.SetDifficultySettings(GameDifficulty);
    MyKFGRI = KFGameReplicationInfo(GameReplicationInfo);
    InitGRIVariables();
    CreateTeam(0);
    InitAIDirector();
    InitTraderList();
}

event PostBeginPlay()
{
    InitAllPickups();
    InitGameplayEventWriter();
    super(GameInfo).PostBeginPlay();
}

function InitGameplayEventWriter()
{
    if(bEnableGameAnalytics && GameplayEventsWriterClass != none)
    {
        LogInternal("Recording game events with" @ string(GameplayEventsWriterClass));
        GameplayEventsWriter = new (self) GameplayEventsWriterClass;        
    }
    else
    {
        LogInternal("Gameplay events will not be recorded.");
    }
}

function EndLogging(string Reason)
{
    local WorldInfo WI;

    if((bEnableGameAnalytics && GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
    {
        GameplayEventsWriter.EndLogging();
        WI = Class'WorldInfo'.static.GetWorldInfo();
        if(OnlineSub != none)
        {
            UploadGameplayStats();            
        }
        else
        {
            if(bLogAnalytics)
            {
                LogInternal((("Stats upload skipped. OnlineSub:" @ string(OnlineSub)) @ "NetMode:") @ string(WI.NetMode));
            }
        }        
    }
    else
    {
        if(bLogAnalytics)
        {
            LogInternal((((("End logging skipped for stats. bLog:" @ string(bEnableGameAnalytics)) @ "Writer:") @ string(GameplayEventsWriter)) @ "InProgress:") @ ((GameplayEventsWriter != none) ? string(GameplayEventsWriter.IsSessionInProgress()) : "False"));
        }
    }
    super(GameInfo).EndLogging(Reason);
}

function UploadGameplayStats()
{
    local TWOnlineEventsInterface MCPInterface;
    local WorldInfo WI;

    if(((bEnableGameAnalytics && GameplayEventsWriter != none) && OnlineSub != none) && MCPUploader == none)
    {
        MCPInterface = TWOnlineEventsInterface(OnlineSub.GetNamedInterface('AnalyticsUpload'));
        WI = Class'WorldInfo'.static.GetWorldInfo();
        if(MCPInterface != none)
        {
            MCPUploader = new (none) Class'KFGameStatsUploader';
            MCPUploader.Init(GameplayEventsWriter);
            if((((WI.NetMode == NM_DedicatedServer) && MCPUploader.bUploadDedicatedServer) || (WI.NetMode == NM_ListenServer) && MCPUploader.bUploadListenServer) || (WI.NetMode == NM_Standalone) && MCPUploader.bUploadOfflineGame)
            {
                UploadGameplayStatsInternal();                
            }
            else
            {
                if(bLogAnalytics)
                {
                    LogInternal("Upload disabled for NetMode:" @ string(WI.NetMode));
                }
            }            
        }
        else
        {
            if(bLogAnalytics)
            {
                LogInternal("Upload skipped for stats. No MCPInterface.");
            }
        }        
    }
    else
    {
        if(bLogAnalytics)
        {
            LogInternal((((((("Upload skipped for stats. bLog:" @ string(bEnableGameAnalytics)) @ "Writer:") @ string(GameplayEventsWriter)) @ "Uploader:") @ string(MCPUploader)) @ "InProgress:") @ string(GameplayEventsWriter.IsSessionInProgress()));
        }
    }
}

function UploadGameplayStatsInternal()
{
    local TWOnlineEventsInterface MCPInterface;

    MCPInterface = TWOnlineEventsInterface(OnlineSub.GetNamedInterface('AnalyticsUpload'));
    if(MCPInterface != none)
    {
        if(MCPUploader.IsFinishedFlushing())
        {
            MCPUploader.UploadGameplayStats(MCPInterface);
            MCPUploader = none;            
        }
        else
        {
            if(bLogAnalytics)
            {
                LogInternal("Waiting for MCPUploader.IsFinishedFlushing()");
            }
            SetTimer(0.2, false, 'UploadGameplayStatsInternal');
        }        
    }
    else
    {
        if(bLogAnalytics)
        {
            LogInternal("No MCP Interface found for upload.");
        }
    }
}

event PreLogin(string Options, string Address, const UniqueNetId UniqueId, bool bSupportsAuth, out string ErrorMessage)
{
    local bool bSpectator, bPerfTesting;

    if(((WorldInfo.NetMode != NM_Standalone) && bUsingArbitration) && bHasArbitratedHandshakeBegun)
    {
        ErrorMessage = PathName(WorldInfo.Game.GameMessageClass) $ ".ArbitrationMessage";
        return;
    }
    if((AccessControl != none) && AccessControl.IsIDBanned(UniqueId))
    {
        LogInternal(Address @ "is banned, rejecting...");
        ErrorMessage = "<Strings:KFGame.KFLocalMessage.BannedFromServerString>";
        return;
    }
    bPerfTesting = (ParseOption(Options, "AutomatedPerfTesting")) ~= "1";
    bSpectator = (bPerfTesting || (ParseOption(Options, "SpectatorOnly")) ~= "1") || (ParseOption(Options, "CauseEvent")) ~= "FlyThrough";
    if(AccessControl != none)
    {
        AccessControl.PreLogin(Options, Address, UniqueId, bSupportsAuth, ErrorMessage, bSpectator);
    }
}

event PostLogin(PlayerController NewPlayer)
{
    local KFPlayerController KFPC;
    local int OldNumSpectators;

    OldNumSpectators = NumSpectators;
    super(GameInfo).PostLogin(NewPlayer);
    if(OldNumSpectators != NumSpectators)
    {
        UpdateGameSettings();
    }
    KFPC = KFPlayerController(NewPlayer);
    if(KFPC != none)
    {
        if(KFPC.PlayerReplicationInfo.bOnlySpectator)
        {
            KFPC.ClientSetFrontEnd(KFGFxManagerClass, true);            
        }
        else
        {
            KFPC.ClientSetFrontEnd(KFGFxManagerClass, false);
            if(!Class'Engine'.static.IsEditor() && !Class'KFGameEngine'.static.CheckSkipLobby())
            {
                KFPC.CreateCustomizationPawn();
            }
        }
    }
}

function Logout(Controller Exiting)
{
    local int OldNumSpectators;

    OldNumSpectators = NumSpectators;
    super(GameInfo).Logout(Exiting);
    if(OldNumSpectators != NumSpectators)
    {
        UpdateGameSettings();
    }
}

event InitAIDirector()
{
    AIDirector = new (self) Class'KFAIDirector';
    AIDirector.Initialize();
}

function InitGRIVariables()
{
    MyKFGRI.GameDifficulty = byte(GameDifficulty);
    MyKFGRI.GameLength = byte(GameLength);
}

function bool AllowCheats(PlayerController P)
{
    return false;
}

function InitTraderList()
{
    local KFTraderTrigger MyTrader;

    TraderList.Remove(0, TraderList.Length;
    foreach DynamicActors(Class'KFTraderTrigger', MyTrader)
    {
        TraderList.AddItem(MyTrader;        
    }    
}

function InitAllPickups()
{
    if(bDisablePickups)
    {
        NumWeaponPickups = 0;
        NumAmmoPickups = 0;        
    }
    else
    {
        NumWeaponPickups = byte(float(ItemPickups.Length) * DifficultyInfo.GetItemPickupModifier());
        NumAmmoPickups = byte(float(AmmoPickups.Length) * DifficultyInfo.GetAmmoPickupModifier());
    }
    if(BaseMutator != none)
    {
        BaseMutator.ModifyPickupFactories();
    }
    ResetAllPickups();
}

function ResetAllPickups()
{
    local int I;

    AllPickupFactories.Remove(0, AllPickupFactories.Length;
    I = 0;
    J0x21:

    if(I < ItemPickups.Length)
    {
        AllPickupFactories.AddItem(ItemPickups[I];
        ++ I;
        goto J0x21;
    }
    I = 0;
    J0x72:

    if(I < AmmoPickups.Length)
    {
        AllPickupFactories.AddItem(AmmoPickups[I];
        ++ I;
        goto J0x72;
    }
    ResetPickups(ItemPickups, NumWeaponPickups);
    ResetPickups(AmmoPickups, NumAmmoPickups);
}

function ResetPickups(array<KFPickupFactory> PickupList, int NumPickups)
{
    local byte I, ChosenIndex;
    local array<KFPickupFactory> PossiblePickups;

    PossiblePickups = PickupList;
    I = 0;
    J0x1F:

    if(I < NumPickups)
    {
        ChosenIndex = byte(Rand(PossiblePickups.Length));
        PossiblePickups[ChosenIndex].Reset();
        PossiblePickups.Remove(ChosenIndex, 1;
        ++ I;
        goto J0x1F;
    }
    I = 0;
    J0xAC:

    if(I < PossiblePickups.Length)
    {
        PossiblePickups[I].StartSleeping();
        ++ I;
        goto J0xAC;
    }
}

function EnableNewPickup(array<KFPickupFactory> PickupList, float RespawnDelay, KFPickupFactory LastPickup)
{
    local KFPickupFactory ActiveFactory;

    ActiveFactory = DetermineNextPickup(PickupList, LastPickup);
    if(BaseMutator != none)
    {
        BaseMutator.ModifyActivatedPickupFactory(ActiveFactory, RespawnDelay);
    }
    ActivateNextPickup(ActiveFactory, int(RespawnDelay));
    LastPickup.StartSleeping();
}

function KFPickupFactory DetermineNextPickup(array<KFPickupFactory> PickupList, KFPickupFactory LastPickup)
{
    local byte I;
    local array<KFPickupFactory> PossibleFactories;

    I = 0;
    J0x0C:

    if(I < PickupList.Length)
    {
        if(((PickupList[I] != LastPickup) && PickupList[I].IsInState('Sleeping')) && !PickupList[I].bToBeActivated)
        {
            PossibleFactories.AddItem(PickupList[I];
        }
        ++ I;
        goto J0x0C;
    }
    if(PossibleFactories.Length > 0)
    {
        return PossibleFactories[Rand(PossibleFactories.Length)];        
    }
    else
    {
        return LastPickup;
    }
}

function ActivateNextPickup(KFPickupFactory NextFactory, int RespawnDelay)
{
    if(NextFactory != none)
    {
        NextFactory.bToBeActivated = true;
        NextFactory.SetTimer(float(RespawnDelay),, 'Reset');
    }
}

function CustomizationPointsInitialized()
{
    local KFPlayerController KFPC;
    local KFPawn_Customization KFPCustom;

    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.Pawn != none)
        {
            KFPCustom = KFPawn_Customization(KFPC.Pawn);
            if((KFPCustom != none) && !KFPCustom.bUsingCustomizationPoint)
            {
                KFPCustom.MoveToCustomizationPoint();
            }
        }        
    }    
}

function Pawn SpawnDefaultPawnFor(Controller NewPlayer, NavigationPoint StartSpot)
{
    local class<Pawn> DefaultPlayerClass;
    local Rotator StartRotation;
    local Pawn ResultPawn;

    DefaultPlayerClass = GetDefaultPlayerClass(NewPlayer);
    StartRotation.Yaw = StartSpot.Rotation.Yaw;
    ResultPawn = Spawn(DefaultPlayerClass,,, StartSpot.Location, StartRotation,, true);
    if(ResultPawn == none)
    {
        LogInternal((("Couldn't spawn player of type " $ string(DefaultPlayerClass)) $ " at ") $ string(StartSpot));
    }
    return ResultPawn;
}

function KFPawn SpawnCustomizationPawn(NavigationPoint StartSpot)
{
    local Rotator StartRotation;
    local KFPawn ResultPawn;

    StartRotation.Yaw = StartSpot.Rotation.Yaw;
    ResultPawn = Spawn(CustomizationPawnClass,,, StartSpot.Location, StartRotation,, true);
    if(ResultPawn == none)
    {
        LogInternal((("Couldn't spawn player of type " $ string(CustomizationPawnClass)) $ " at ") $ string(StartSpot));
    }
    return ResultPawn;
}

function StartHumans()
{
    local PlayerController P;
    local int NumPlayerPawns;

    foreach WorldInfo.AllControllers(Class'PlayerController', P)
    {
        if((P.Pawn == none) || KFPawn_Customization(P.Pawn) != none)
        {
            if(bGameEnded)
            {                
                return;                
            }
            else
            {
                if(P.CanRestartPlayer())
                {
                    RestartPlayer(P);
                }
            }
        }
        if(P.Pawn != none)
        {
            ++ NumPlayerPawns;
        }        
    }    
    bOnePlayerAtStart = NumPlayerPawns == 1;
}

function RestartPlayer(Controller NewPlayer)
{
    local KFPlayerController KFPC;

    if((NewPlayer.Pawn != none) && KFPawn_Customization(NewPlayer.Pawn) != none)
    {
        NewPlayer.Pawn.Destroy();
    }
    super(GameInfo).RestartPlayer(NewPlayer);
    SetTeam(NewPlayer, Teams[0]);
    KFPC = KFPlayerController(NewPlayer);
    if(KFPC != none)
    {
        KFPC.InitGameplayPostProcessFX();
    }
}

function float RatePlayerStart(PlayerStart P, byte Team, Controller Player)
{
    local float Rating;

    Rating = super(GameInfo).RatePlayerStart(P, Team, Player);
    if(!CheckPointCollision(P, Player))
    {
        return 0.01;
    }
    return Rating;
}

function KFCustomizationPoint FindCustomizationStart(Controller Player)
{
    local KFCustomizationPoint CP;

    foreach AllActors(Class'KFCustomizationPoint', CP)
    {
        if(CheckPointCollision(CP, Player))
        {
            break;
        }        
    }    
    return CP;
}

function bool CheckPointCollision(NavigationPoint P, Controller Player)
{
    local KFPlayerController KFPC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        if((KFPC != Player) && KFPC.Pawn != none)
        {
            if(VSizeSq(KFPC.Pawn.Location - P.Location) < Square(2.1 * KFPC.Pawn.GetCollisionRadius()))
            {                
                return false;
            }
        }        
    }    
    return true;
}

function SetPlayerDefaults(Pawn PlayerPawn)
{
    local KFPawn KFP;

    KFP = KFPawn(PlayerPawn);
    if((KFP != none) && KFP.GetPerk() != none)
    {
        if(KFP.GetPerk() != none)
        {
            KFP.GetPerk().SetPlayerDefaults(KFP);
        }
        KFP.bIgnoreTeamCollision = bDisableTeamCollision;
    }
    if(BaseMutator != none)
    {
        BaseMutator.ModifyPlayer(PlayerPawn);
    }
    PlayerPawn.PhysicsVolume.ModifyPlayer(PlayerPawn);
}

function bool IsWaveActive();

function SetAIDefaults(KFPawn_Monster P)
{
    local float HealthMod, HeadHealthMod, GroundSpeedMod, HiddenSpeedMod, DamageMod, SprintChance,
	    SprintDamagedChance;

    local byte NumLivingPlayers;
    local KFCharacterInfo_Monster MonsterInfo;

    NumLivingPlayers = byte(GetLivingPlayerCount());
    MonsterInfo = P.GetCharacterMonsterInfo();
    if(MonsterInfo != none)
    {
        DifficultyInfo.GetAIHealthModifier(MonsterInfo, GameDifficulty, NumLivingPlayers, HealthMod, HeadHealthMod);
        SprintChance = DifficultyInfo.GetCharSprintChanceByDifficulty(MonsterInfo, GameDifficulty);
        SprintDamagedChance = DifficultyInfo.GetCharSprintWhenDamagedChanceByDifficulty(MonsterInfo, GameDifficulty);
        DamageMod = DifficultyInfo.GetAIDamageModifier(MonsterInfo, GameDifficulty, bOnePlayerAtStart);        
    }
    else
    {
        DamageMod = DifficultyInfo.GetBaseAIDamageModifier();
    }
    GroundSpeedMod = DifficultyInfo.GetAdjustedAIGroundSpeedMod();
    HiddenSpeedMod = DifficultyInfo.GetAIHiddenSpeedModifier(NumLivingPlayers);
    if(KFAIController_Monster(P.Controller) != none)
    {
        KFAIController_Monster(P.Controller).DifficultyDamageMod = DamageMod;
    }
    P.HiddenGroundSpeed = P.default.HiddenGroundSpeed * HiddenSpeedMod;
    P.GroundSpeed = P.default.GroundSpeed * GroundSpeedMod;
    P.SprintSpeed = P.default.SprintSpeed * GroundSpeedMod;
    P.NormalGroundSpeed = P.GroundSpeed;
    P.Health = int(float(P.default.Health) * HealthMod);
    if(P.default.HealthMax == 0)
    {
        P.HealthMax = int(float(P.default.Health) * HealthMod);        
    }
    else
    {
        P.HealthMax = int(float(P.default.HealthMax) * HealthMod);
    }
    P.ApplySpecialZoneHealthMod(HeadHealthMod);
    if(P.PawnAnimInfo != none)
    {
        P.PawnAnimInfo.SetDifficultyValues(DifficultyInfo);
    }
    P.SetCanSprint(FRand() <= SprintChance);
    P.SetCanSprintWhenDamaged(FRand() <= SprintDamagedChance);
    if(BaseMutator != none)
    {
        BaseMutator.ModifyAI(P);
    }
    if(bLogAIDefaults)
    {
        LogInternal(("==== SetAIDefaults for pawn: " @ string(P)) @ "====");
    }
    if(bLogAIDefaults)
    {
        LogInternal((((("HealthMod: " @ string(HealthMod)) @ "Original Health: ") @ string(P.default.Health)) @ " Final Health = ") @ string(P.Health));
    }
    if(bLogAIDefaults)
    {
        LogInternal((((("HeadHealthMod: " @ string(HeadHealthMod)) @ "Original Head Health: ") @ string(P.default.HitZones[0].GoreHealth)) @ " Final Head Health = ") @ string(P.HitZones[0].GoreHealth));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("GroundSpeedMod: " @ string(GroundSpeedMod)) @ " Final Ground Speed = ") @ string(P.GroundSpeed));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("HiddenSpeedMod: " @ string(HiddenSpeedMod)) @ " Final Hidden Speed = ") @ string(P.HiddenGroundSpeed));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("SprintSpeedMod: " @ string(GroundSpeedMod)) @ " Final Sprint Speed = ") @ string(P.SprintSpeed));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("DamageMod: " @ string(DamageMod)) @ " Final Melee Damage = ") @ string(P.MeleeAttackHelper.BaseDamage * DamageMod));
    }
    if(bLogAIDefaults)
    {
        LogInternal((("bCanSprint: " @ string(P.bCanSprint)) @ " from SprintChance: ") @ string(SprintChance));
    }
}

function SetTeam(Controller Other, KFTeamInfo_Human NewTeam)
{
    if(Other.PlayerReplicationInfo == none)
    {
        return;
    }
    if(Other.PlayerReplicationInfo.Team != none)
    {
        Other.PlayerReplicationInfo.Team.RemoveFromTeam(Other);
        Other.PlayerReplicationInfo.Team = none;
    }
    if((NewTeam == none) || (NewTeam != none) && NewTeam.AddToTeam(Other))
    {
        if((NewTeam != none) && ((WorldInfo.NetMode != NM_Standalone) || PlayerController(Other) == none) || PlayerController(Other).Player != none)
        {
            BroadcastLocalizedMessage(GameMessageClass, 3, Other.PlayerReplicationInfo, none, NewTeam);
        }
    }
}

function CreateTeam(int TeamIndex)
{
    Teams[TeamIndex] = Spawn(Class'KFTeamInfo_Human');
    GameReplicationInfo.SetTeam(TeamIndex, Teams[TeamIndex]);
}

function byte PickTeam(byte Current, Controller C)
{
    return 0;
}

function bool CanSpectate(PlayerController Viewer, PlayerReplicationInfo ViewTarget)
{
    return ViewTarget.RemoteRole != ROLE_None;
}

function ReduceDamage(out int Damage, Pawn injured, Controller InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType, Actor DamageCauser)
{
    local class<KFDamageType> KFDT;

    KFDT = class<KFDamageType>(DamageType);
    if(((KFDT != none) && InstigatedBy != none) && InstigatedBy == injured.Controller)
    {
        if(KFDT.default.bNoInstigatorDamage)
        {
            Damage = 0;            
        }
        else
        {
            if(!KFDT.default.bIgnoreSelfInflictedScale)
            {
                Damage *= DifficultyInfo.GetSelfInflictedDamageMod();
            }
        }
        Momentum = vect(0, 0, 0);
    }
    if(((Damage > 0) && InstigatedBy != none) && InstigatedBy != injured.Controller)
    {
        if((injured.GetTeamNum() != 255) && injured.GetTeamNum() == InstigatedBy.GetTeamNum())
        {
            Damage *= FriendlyFireScale;
            Momentum = vect(0, 0, 0);
        }
    }
    super(GameInfo).ReduceDamage(Damage, injured, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser);
}

function Killed(Controller Killer, Controller KilledPlayer, Pawn KilledPawn, class<DamageType> DT)
{
    local KFPlayerReplicationInfo KilledPRI;
    local KFPlayerController KFPC;
    local int PlayerScoreDelta, TeamPenalty;
    local KFPerk KFPCP;
    local KFPawn_Monster MonsterPawn;

    super(GameInfo).Killed(Killer, KilledPlayer, KilledPawn, DT);
    if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
    {
        GameplayEventsWriter.LogPlayerKillDeath(104, 200, Killer, DT, KilledPlayer);
    }
    if(Killer != KilledPlayer)
    {
        CheckZedTimeOnKill(Killer, KilledPlayer, KilledPawn, DT);
    }
    if(KilledPawn.IsA('KFPawn_Monster'))
    {
        KFPC = KFPlayerController(Killer);
        MonsterPawn = KFPawn_Monster(KilledPawn);
        if(((KFPC != none) && KFPC.bIsPlayer) && MonsterPawn != none)
        {
            KFPC.AddZedKill(MonsterPawn.Class, byte(GameDifficulty), DT);
            KFPCP = KFPC.GetPerk();
            if(KFPCP != none)
            {
                if(KFPCP.CanEarnSmallRadiusKillXP(DT))
                {
                    CheckForBerserkerSmallRadiusKill(MonsterPawn, KFPC);
                }
                KFPCP.AddVampireHealth(KFPC, DT);
            }
        }
        AIAliveCount = GetMonsterAliveCount();
        if(SpawnManager != none)
        {
            -- MyKFGRI.AIRemaining;
        }
    }
    if((KilledPlayer != none) && KilledPlayer.bIsPlayer)
    {
        KilledPRI = KFPlayerReplicationInfo(KilledPlayer.PlayerReplicationInfo);
        if(KilledPRI != none)
        {
            PlayerScoreDelta = GetAdjustedDeathPenalty(KilledPRI);
            if(bLogScoring)
            {
                LogInternal((("SCORING: Player" @ KilledPRI.PlayerName) @ "next starting dosh =") @ string(float(PlayerScoreDelta) + KilledPRI.Score));
            }
            KilledPRI.AddDosh(PlayerScoreDelta);
            TeamPenalty = GetAdjustedTeamDeathPenalty(KilledPRI);
            KilledPRI.Team.Score -= float(TeamPenalty);
            if(bLogScoring)
            {
                LogInternal(("SCORING: Team lost" @ string(TeamPenalty)) @ "dosh for a player dying");
            }
            KilledPRI.PlayerHealth = 0;
        }
        KFPawn_Human(KilledPawn).BroadcastDeathMessage(Killer);
    }
}

function int GetAdjustedDeathPenalty(KFPlayerReplicationInfo KilledPlayerPRI, optional bool bLateJoiner)
{
    bLateJoiner = false;
}

function int GetAdjustedTeamDeathPenalty(KFPlayerReplicationInfo KilledPlayerPRI)
{
    return Round((KilledPlayerPRI.Score * GameDifficulty) * 0.05);
}

function BossDied(Controller Killer);

function ScoreKill(Controller Killer, Controller Other)
{
    if(((Killer != none) && Killer.PlayerReplicationInfo != none) && Killer != Other)
    {
        ++ Killer.PlayerReplicationInfo.Kills;
        Killer.bForceNetUpdate = true;
        if(Other.Pawn.IsA('KFPawn_Monster'))
        {
            ScoreMonsterKill(Killer, Other, KFPawn_Monster(Other.Pawn));
        }
    }
    if((((Killer != none) && Other != none) && Killer == Other) && Other.Pawn.IsA('KFPawn_Monster'))
    {
        ScoreMonsterKill(Killer, Other, KFPawn_Monster(Other.Pawn));
    }
    ModifyScoreKill(Killer, Other);
    if((Killer != none) || MaxLives > 0)
    {
        CheckScore(Killer.PlayerReplicationInfo);
    }
}

function ScoreMonsterKill(Controller Killer, Controller Monster, KFPawn_Monster MonsterPawn)
{
    local KFAIController KFAIC;

    KFAIC = KFAIController(Monster);
    if(KFAIC != none)
    {
        if(KFAIC.DamageHistory.Length > 0)
        {
            DistributeMoneyAndXP(MonsterPawn.Class, KFAIC.DamageHistory, Killer);
        }
    }
    if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
    {
        GameplayEventsWriter.LogZedKilled(Killer, Monster, MonsterPawn);
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        if((KFPlayerController(Killer) != none) && KFPlayerController(Killer).MatchStats != none)
        {
            KFPlayerController(Killer).MatchStats.RecordZedKill(MonsterPawn.Class, none);
        }
    }
}

function CheckForBerserkerSmallRadiusKill(KFPawn_Monster MonsterPawn, KFPlayerController KFPC)
{
    local KFPawn_Human KFPH;

    if(KFPC == none)
    {
        return;
    }
    foreach WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
    {
        if(((KFPH != none) && KFPH.IsAliveAndWell()) && KFPH.Controller != KFPC)
        {
            if(VSizeSq(KFPH.Location - MonsterPawn.Location) <= float(Class'KFPerk_Berserker'.static.GetSmallRadiusKillDistanceSQ()))
            {
                if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
                {
                    GameplayEventsWriter.LogPlayerIntEvent(1302, KFPC, Class'KFPerk_Berserker'.static.GetSmallRadiusKillXP(byte(GameDifficulty)));
                }
                KFPC.AddSmallRadiusKill(byte(GameDifficulty));
                break;
            }
        }        
    }    
}

function float GetAdjustedAIDoshValue(class<KFPawn_Monster> MonsterClass)
{
    local float TempValue;

    TempValue = float(MonsterClass.static.GetDoshValue());
    TempValue *= DifficultyInfo.GetKillCashModifier();
    ModifyAIDoshValueForPlayerCount(TempValue);
    return TempValue;
}

function ModifyAIDoshValueForPlayerCount(out float ModifiedValue)
{
    local float DoshMod;

    DoshMod = float(GetNumPlayers()) / DifficultyInfo.GetPlayerNumMaxAIModifier(byte(GetNumPlayers()));
    ModifiedValue *= DoshMod;
}

function int GetNumPlayers()
{
    return super(GameInfo).GetNumPlayers();
}

function DistributeMoneyAndXP(class<KFPawn_Monster> MonsterClass, const out array<DamageInfo> DamageHistory, Controller Killer)
{
    local int I, J, TotalDamage, EarnedDosh;
    local float AdjustedAIValue, ScoreDenominator, XP;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo DamagerKFPRI;

    I = 0;
    J0x0B:

    if(I < DamageHistory.Length)
    {
        TotalDamage += int(DamageHistory[I].TotalDamage);
        ++ I;
        goto J0x0B;
    }
    if(TotalDamage <= 0)
    {
        WarnInternal("Total damage given to this zed is less or equal zero! This should never happen");
        return;
    }
    AdjustedAIValue = GetAdjustedAIDoshValue(MonsterClass);
    ScoreDenominator = AdjustedAIValue / float(TotalDamage);
    I = 0;
    J0x10F:

    if(I < DamageHistory.Length)
    {
        if(((DamageHistory[I].DamagerController != none) && DamageHistory[I].DamagerController.bIsPlayer) && DamageHistory[I].DamagerPRI != none)
        {
            EarnedDosh = Round(DamageHistory[I].TotalDamage * ScoreDenominator);
            if(bLogScoring)
            {
                LogInternal((((("SCORING: Player" @ DamageHistory[I].DamagerPRI.PlayerName) @ "received") @ string(EarnedDosh)) @ "dosh for killing a") @ string(MonsterClass));
            }
            DamagerKFPRI = KFPlayerReplicationInfo(DamageHistory[I].DamagerPRI);
            if(DamagerKFPRI != none)
            {
                DamagerKFPRI.AddDosh(EarnedDosh, true);
                if(Killer.PlayerReplicationInfo != DamagerKFPRI)
                {
                    ++ DamagerKFPRI.Assists;
                }
                if(DamagerKFPRI.Team != none)
                {
                    DamagerKFPRI.Team.Score += float(EarnedDosh);
                    if(DamageHistory[I].DamagePerks.Length <= 0)
                    {                        
                    }
                    else
                    {
                        KFPC = KFPlayerController(DamagerKFPRI.Owner);
                        if(KFPC != none)
                        {
                            XP = MonsterClass.static.GetXPValue(byte(GameDifficulty)) / float(DamageHistory[I].DamagePerks.Length);
                            J = 0;
                            J0x494:

                            if(J < DamageHistory[I].DamagePerks.Length)
                            {
                                KFPC.AddPlayerXP(FCeil(XP), DamageHistory[I].DamagePerks[J]);
                                if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
                                {
                                    GameplayEventsWriter.LogZedKilledPerPlayer(KFPC, float(TotalDamage), int(XP), EarnedDosh, DamageHistory[I].DamagePerks[J]);
                                }
                                ++ J;
                                goto J0x494;
                            }
                        }
                    }
                }
            }
        }
        ++ I;
        goto J0x10F;
    }
    if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
    {
        GameplayEventsWriter.DeathEvent.CommitToDisk();
    }
}

function DramaticEvent(float ZedTimeChance, optional float Duration)
{
    local float TimeSinceLastEvent;
    local KFPlayerController KFPC;

    Duration = 3;
    if(bNVBlockDramatic)
    {
        return;
    }
    TimeSinceLastEvent = WorldInfo.TimeSeconds - LastZedTimeEvent;
    if(BaseMutator != none)
    {
        BaseMutator.ModifyZedTime(TimeSinceLastEvent, ZedTimeChance, Duration);
    }
    if((TimeSinceLastEvent < 10) && ZedTimeChance < 1)
    {
        return;
    }
    if(TimeSinceLastEvent > float(60))
    {
        ZedTimeChance *= 4;        
    }
    else
    {
        if(TimeSinceLastEvent > float(30))
        {
            ZedTimeChance *= 2;
        }
    }
    if((FRand() <= ZedTimeChance) && Duration > ZedTimeRemaining)
    {
        ZedTimeRemaining = Duration;
        bZedTimeBlendingOut = false;
        LastZedTimeEvent = WorldInfo.TimeSeconds;
        SetZedTimeDilation(ZedTimeSlomoScale);
        foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
        {
            if(KFPC != none)
            {
                KFPC.EnterZedTime();
            }            
        }        
    }
}

function Tick(float DeltaTime)
{
    if(ZedTimeRemaining > 0)
    {
        TickZedTime(DeltaTime);
    }
}

function TickZedTime(float DeltaTime)
{
    local float TrueTimeFactor;
    local KFPlayerController KFPC;

    TrueTimeFactor = 1 / (CustomTimeDilation * WorldInfo.TimeDilation);
    ZedTimeRemaining -= (DeltaTime * TrueTimeFactor);
    if(ZedTimeRemaining <= float(0))
    {
        bZedTimeBlendingOut = false;
        SetZedTimeDilation(1);
        ZedTimeExtensionsUsed = 0;        
    }
    else
    {
        if(ZedTimeRemaining < ZedTimeBlendOutTime)
        {
            if(!bZedTimeBlendingOut)
            {
                bZedTimeBlendingOut = true;
                foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
                {
                    if(KFPC != none)
                    {
                        KFPC.FadeOutZedTime();
                    }                    
                }                
            }
            SetZedTimeDilation(Lerp(1, ZedTimeSlomoScale, ZedTimeRemaining / ZedTimeBlendOutTime));
        }
    }
}

function bool IsZedTimeActive()
{
    return ZedTimeRemaining > 0;
}

function SetZedTimeDilation(float NewTimeDilation)
{
    SetGameSpeed(NewTimeDilation);
}

function CheckZedTimeOnKill(Controller Killer, Controller KilledPlayer, Pawn KilledPawn, class<DamageType> DamageType)
{
    local bool bIsHuman;
    local KFPlayerController KFPC;
    local KFPerk KillersPerk;
    local class<KFDamageType> KFDT;

    KFDT = class<KFDamageType>(DamageType);
    if((KFDT != none) && KFDT.default.DoT_Type != 0)
    {
        return;
    }
    if(IsZedTimeActive())
    {
        KFPC = KFPlayerController(Killer);
        if(KFPC != none)
        {
            KillersPerk = KFPC.GetPerk();
            if(((ZedTimeRemaining > 0) && KillersPerk != none) && KillersPerk.GetZedTimeExtension(KFPC.GetLevel()) > float(ZedTimeExtensionsUsed))
            {
                DramaticEvent(1);
                ++ ZedTimeExtensionsUsed;
            }
        }        
    }
    else
    {
        if(bNVAlwaysDramatic)
        {
            DramaticEvent(1);
        }
        bIsHuman = KilledPawn.IsA('KFPawn_Human');
        if(bIsHuman)
        {
            DramaticEvent(0.05);
            return;
        }
        if(KilledPawn.Controller == none)
        {
            return;
        }
        if(((Killer != none) && Killer.Pawn != none) && VSizeSq(Killer.Pawn.Location - KilledPawn.Location) < float(90000))
        {
            DramaticEvent(0.05);            
        }
        else
        {
            DramaticEvent(0.025);
        }
    }
}

function NotifyHeadshotKill(Controller Killer, Pawn KilledPawn)
{
    if(bNVAlwaysDramatic)
    {
        DramaticEvent(1);
    }
    if(((Killer != none) && Killer.Pawn != none) && VSizeSq(Killer.Pawn.Location - KilledPawn.Location) > Square(2500))
    {
        DramaticEvent(0.05);        
    }
    else
    {
        DramaticEvent(0.03);
    }
}

function NotifyNavigationChanged(NavigationPoint N)
{
    local KFAIController AI;
    local int Idx;


    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */
    /*@Error*/
    foreach WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        break;
        @NULL
        @NULL
        -- @NULL;
        string(GetFuncName()) $ "() Notifying ";
        string(AI)        
        " that navigation has changed for "        
        string(N)        
        'PathWarning'
        ,
        ,
        ,        
        if(!AI.bMovingToGoal)
        {
            if(AI != none)
            {
                AI.AILog_Internal((((string(GetFuncName()) $ "() ** Skipping notification for ") $ string(AI)) $ " because bMovingToGoal was false. bPreparingMove? : ") $ string(AI.bPreparingMove), 'PathWarning');
                continue;
                goto J0x441;
                Idx = AI.RouteCache.Find(N;
            }
        }
        if(Idx >= 0)
        {
            if(AI != none)
            {
                AI.AILog_Internal((((string(GetFuncName()) $ "() setting bReEvaluatePath to true for ") $ string(AI)) $ " thanks to ") $ string(N), 'PathWarning');
                AI.bReevaluatePath = true;
            }
            AI.MoveTimer = -1;
            AI.ForcePauseAndRepath();
            goto J0x440;
            /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
                
            */

            /*@Error*/
            AI.AILog_Internal((((((((("** WARNING ** " $ string(GetFuncName())) $ " for ") $ string(N)) $ " not telling ") $ string(AI)) $ " to reevaluate path because I couldn't find ") $ string(N)) $ " in the routecache! bPreparingMove: ") $ string(AI.bPreparingMove), 'PathWarning');
        }                
    }
}

function byte GetGameIntensityForMusic();

static function bool ShouldPlayActionMusicTrack(KFGameReplicationInfo GRI);

static function bool ShouldPlayMusicAtStart();

simulated function ForceMenuMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[0]);
}

simulated function ForceCreditsMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[1]);
}

simulated function ForceHansMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[2]);
}

simulated function ForcePatriarchMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[3]);
}

simulated function ForceMatriarchMusicTrack()
{
    MyKFGRI.ForceNewMusicTrack(default.ForcedMusicTracks[4]);
}

function string GetNextMap()
{
    local array<string> MapList;
    local int I;

    if(bUseMapList && GameMapCycles.Length > 0)
    {
        if(MapCycleIndex == -1)
        {
            MapList = GameMapCycles[ActiveMapCycle].Maps;
            MapCycleIndex = GetCurrentMapCycleIndex(MapList);
            if(MapCycleIndex == -1)
            {
                MapCycleIndex = 0;
            }
        }
        I = 0;
        J0xA8:

        if(I < GameMapCycles[ActiveMapCycle].Maps.Length)
        {
            MapCycleIndex = (((MapCycleIndex + 1) < GameMapCycles[ActiveMapCycle].Maps.Length) ? MapCycleIndex + 1 : 0);
            if(IsMapAllowedInCycle(GameMapCycles[ActiveMapCycle].Maps[MapCycleIndex]))
            {
                SaveConfig();
                return GameMapCycles[ActiveMapCycle].Maps[MapCycleIndex];
            }
            ++ I;
            goto J0xA8;
        }
        return string(WorldInfo.GetPackageName());        
    }
    else
    {
        return string(WorldInfo.GetPackageName());
    }
    return "";
}

function int GetCurrentMapCycleIndex(const out array<string> MapList)
{
    return MapList.Find(string(WorldInfo.GetPackageName());
}

exec function MaintenanceRestart()
{
    SetNeedsRestart(false);
}

function UnregisterPlayer(PlayerController PC)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(PC);
    if(KFPC != none)
    {
        KFPC.ClientWriteAndFlushStats();
    }
    super(GameInfo).UnregisterPlayer(PC);
}

function AddInactivePRI(PlayerReplicationInfo PRI, PlayerController PC)
{
    local KFPlayerReplicationInfo NewKFPRI;

    if(!PRI.bFromPreviousLevel && !PRI.bOnlySpectator)
    {
        NewKFPRI = KFPlayerReplicationInfo(PRI);
        NewKFPRI.LastQuitTime = WorldInfo.TimeSeconds;
    }
    super(GameInfo).AddInactivePRI(PRI, PC);
}

function bool FindInactivePRI(PlayerController PC)
{
    local KFPlayerReplicationInfo NewKFPRI;

    if(super(GameInfo).FindInactivePRI(PC))
    {
        NewKFPRI = KFPlayerReplicationInfo(PC.PlayerReplicationInfo);
        ++ NewKFPRI.NumTimesReconnected;
        return true;
    }
    return false;
}

function bool UniqueIdPresent(out array<UniqueNetId> PlayerIDs, UniqueNetId PlayerID)
{
    local UniqueNetId I;

    foreach PlayerIDs(I,)
    {
        if(I == PlayerID)
        {            
            return true;
        }        
    }    
    return false;
}

function bool ReservationPresent(UniqueNetId PlayerID)
{
    local PlayerReservation I;

    foreach PlayerReservations(I,)
    {
        if(I.PlayerID == PlayerID)
        {            
            return true;
        }        
    }    
    return false;
}

function UniqueIdAdd(out array<UniqueNetId> PlayerIDs, UniqueNetId PlayerID)
{
    if(!UniqueIdPresent(PlayerIDs, PlayerID))
    {
        PlayerIDs.AddItem(PlayerID;
    }
}

function bool AtCapacity(bool bSpectator, const optional UniqueNetId PlayerID)
{
    if(bSpectator)
    {
        return super(GameInfo).AtCapacity(bSpectator);
    }
    if((GetAvailableReservations()) <= 0)
    {
        return !ReservationPresent(PlayerID);
    }
    return super(GameInfo).AtCapacity(bSpectator);
}

event MakeReservations(const string URLOptions, const UniqueNetId PlayerID, out string OutError)
{
    local array<UniqueNetId> Reservations;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.MakeReservations");
    }
    ReadReservations(URLOptions, PlayerID, Reservations);
    if(Reservations.Length > 0)
    {
        if(!AddPlayerReservations(Reservations))
        {
            if(bLogReservations)
            {
                LogInternal("KFGameInfo.MakeReservations failed");
            }
            OutError = PathName(WorldInfo.Game.GameMessageClass) $ ".MaxedOutMessage";
        }
    }
}

event PlayerController Login(string Portal, string Options, const UniqueNetId UniqueId, out string ErrorMessage)
{
    SeatPlayer(UniqueId);
    return super(GameInfo).Login(Portal, Options, UniqueId, ErrorMessage);
}

event SendServerMaintenanceMessage()
{
    BroadcastLocalizedMessage(Class'KFLocalMessage', 4);
}

function UniqueReservationAdd(UniqueNetId PlayerID)
{
    local PlayerReservation I, Reservation;
    local bool bFound;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.UniqueReservationAdd" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
    }
    bFound = false;
    foreach PlayerReservations(I,)
    {
        if(I.PlayerID == PlayerID)
        {
            bFound = true;            
        }
        else
        {            
        }
    }    
    if(!bFound)
    {
        if(bLogReservations)
        {
            LogInternal("KFGameInfo.UniqueReservationAdd adding" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
        }
        Reservation.PlayerID = PlayerID;
        Reservation.Timer = 0;
        PlayerReservations.AddItem(Reservation;
    }
}

function RemoveDuplicates(out array<UniqueNetId> PlayerIDs)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PlayerIDs.Length)
    {
        if(ReservationPresent(PlayerIDs[I]))
        {
            PlayerIDs.Remove(I, 1;            
        }
        else
        {
            ++ I;
        }
        goto J0x0B;
    }
}

function bool AddPlayerReservations(out array<UniqueNetId> PlayerIDs)
{
    local UniqueNetId PlayerID;
    local int OldCount;

    RemoveDuplicates(PlayerIDs);
    if(PlayerIDs.Length == 0)
    {
        return true;
    }
    if(PlayerIDs.Length > (GetAvailableReservations()))
    {
        return false;
    }
    OldCount = PlayerReservations.Length;
    foreach PlayerIDs(PlayerID,)
    {
        UniqueReservationAdd(PlayerID);        
    }    
    if((OldCount == 0) && PlayerReservations.Length > 0)
    {
        SetTimer(1, true, 'TimeReservations');
    }
    return true;
}

function TimeReservations()
{
    local int I;
    local UniqueNetId stupid;

    I = 0;
    J0x0B:

    if(I < PlayerReservations.Length)
    {
        stupid = PlayerReservations[I].PlayerID;
        if(bLogReservations)
        {
            LogInternal(((("KFGameInfo.TimeReservations" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid)) @ "timer is") @ string(PlayerReservations[I].Timer));
        }
        if(PlayerReservations[I].Timer > ReservationTimeout)
        {
            if(bLogReservations)
            {
                LogInternal(("KFGameInfo.TimeReservations expiring player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
            }
            PlayerReservations.Remove(I, 1;            
        }
        else
        {
            if(PlayerReservations[I].Timer >= 0)
            {
                ++ PlayerReservations[I].Timer;
                if(bLogReservations)
                {
                    if(bLogReservations)
                    {
                        LogInternal(((("KFGameInfo.TimeReservations player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid)) @ "=") @ string(PlayerReservations[I].Timer));
                    }
                }
            }
            ++ I;
        }
        goto J0x0B;
    }
    if(PlayerReservations.Length == 0)
    {
        ClearTimer('TimeReservations');
    }
}

function ReadReservations(const string URLOptions, const UniqueNetId PlayerID, out array<UniqueNetId> Reservations)
{
    local string OptionsCopy, Option, Key, Value;
    local UniqueNetId Id;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ReadReservations reading reservations from" @ URLOptions);
    }
    OptionsCopy = URLOptions;
    Reservations.Remove(0, Reservations.Length;
    J0x7B:

    if((GrabOption(OptionsCopy, Option)) && Reservations.Length < 5)
    {
        GetKeyValue(Option, Key, Value);
        if((Len(Key) == 6) && Left(Key, 5) ~= "party")
        {
            if(Class'OnlineSubsystem'.static.StringToUniqueNetId(Value, Id))
            {
                if(bLogReservations)
                {
                    LogInternal("KFGameInfo.ReadReservations for player" @ Key);
                }
                UniqueIdAdd(Reservations, Id);
            }            
        }
        else
        {
            if((Key ~= "SpectatorOnly") && Value ~= "1")
            {
                if(bLogReservations)
                {
                    LogInternal(((("KFGameInfo.ReadReservations found" @ Key) $ "=") $ Value) @ "in URL, making no reservations");
                }
                Reservations.Remove(0, Reservations.Length;
                return;
            }
        }
        goto J0x7B;
    }
    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ReadReservations for player" @ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerID));
    }
    UniqueIdAdd(Reservations, PlayerID);
}

event bool ConfirmReservation(const UniqueNetId PlayerID)
{
    local PlayerReservation I;
    local UniqueNetId stupid;
    local int Index;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.ConfirmReservation");
    }
    foreach PlayerReservations(I, Index)
    {
        if(I.PlayerID == PlayerID)
        {
            stupid = I.PlayerID;
            if(bLogReservations)
            {
                if(bLogReservations)
                {
                    LogInternal(("KFGameInfo.ConfirmReservation for player" @ string(Index)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
                }
            }
            PlayerReservations[Index].Timer = -1;
            if(bLogReservations)
            {
                LogInternal(((("KFGameInfo.TimeReservations" @ string(Index)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid)) @ "timer is") @ string(PlayerReservations[Index].Timer));
            }            
            return true;
        }        
    }    
    return false;
}

event bool SeatPlayer(const UniqueNetId SeatedPlayerID)
{
    local int I;
    local UniqueNetId stupid;

    if(bLogReservations)
    {
        LogInternal("KFGameInfo.SeatPlayer");
    }
    I = 0;
    J0x32:

    if(I < PlayerReservations.Length)
    {
        if(PlayerReservations[I].PlayerID == SeatedPlayerID)
        {
            if(bLogReservations)
            {
                stupid = PlayerReservations[I].PlayerID;
                if(bLogReservations)
                {
                    LogInternal(("KFGameInfo.SeatPlayer for player" @ string(I)) @ Class'OnlineSubsystem'.static.UniqueNetIdToString(stupid));
                }
            }
            PlayerReservations.Remove(I, 1;
            return true;
        }
        ++ I;
        goto J0x32;
    }
    return false;
}

function int GetAvailableReservations()
{
    return (MaxPlayers - (GetNumPlayers())) - PlayerReservations.Length;
}

// Export UKFGameInfo::execAllowBalanceLogging(FFrame&, void* const)
native static function bool AllowBalanceLogging();

function LogPlayersInventory()
{
    local PlayerController PC;
    local Inventory Item;
    local string InvString;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if((PC.Pawn != none) && PC.Pawn.InvManager != none)
        {
            InvString = "";
            Item = PC.Pawn.InvManager.InventoryChain;
            J0x102:

            if(Item != none)
            {                
                InvString $= (string(Item.Class.Name) $ ",");
                Item = Item.Inventory;
                goto J0x102;
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((string('Inventory') $ ",") $ PC.PlayerReplicationInfo.PlayerName) $ ",") $ InvString);
            }
        }        
    }    
}

function LogPlayersDosh(name EventName)
{
    local KFPlayerController PC;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        if((PC.PlayerReplicationInfo != none) && !PC.PlayerReplicationInfo.bIsSpectator)
        {
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((((string(EventName) $ ",") $ PC.PlayerReplicationInfo.PlayerName) $ ",") $ "$") $ string(PC.PlayerReplicationInfo.Score)) $ ",") $ string(PC.GetPerk()));
            }
        }        
    }    
}

function LogPlayersKillCount()
{
    local KFPlayerController PC;
    local PlayerReplicationInfo PRI;

    if(!AllowBalanceLogging())
    {
        return;
    }
    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        PRI = PC.PlayerReplicationInfo;
        if((PRI != none) && !PRI.bIsSpectator)
        {
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Kills') $ ",") $ PRI.PlayerName) $ ",") $ string(PRI.Kills)) $ ",") $ string(PC.GetPerk()));
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Deaths') $ ",") $ PRI.PlayerName) $ ",") $ string(PRI.Deaths)) $ ",") $ string(PC.GetPerk()));
            }
        }        
    }    
}

function SetCountdown(bool bFinalCountdown, byte CountdownTime)
{
    local KFPlayerController KFPC;

    bStartFinalCount = bFinalCountdown;
    SetTimer(float(CountdownTime), false, 'LobbyCountdownComplete');
    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.ClientSetCountdown(bFinalCountdown, CountdownTime);        
    }    
}

function ResetCountDown()
{
    local KFPlayerController KFPC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.ClientResetCountdown();        
    }    
}

function LobbyCountdownComplete()
{
    local KFPlayerController KFPC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.PlayerReplicationInfo.bReadyToPlay = true;        
    }    
    StartMatch();
}

function CheckServerUnlock()
{
    if((GetNumPlayers()) == 0)
    {
        KFGameEngine(Class'Engine'.static.GetEngine()).UnlockServer();
    }
}

function StartMatch()
{
    local KFPlayerController PC;

    super(GameInfo).StartMatch();
    bDelayedStart = false;
    MyKFGRI.RemainingTime = 0;
    MyKFGRI.bStopCountDown = true;
    ClearTimer('StartMatch');
    ClearTimer('LobbyCountdownComplete');
    if(GameplayEventsWriter != none)
    {
        GameplayEventsWriter.StartLogging(0);
        if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
        {
            GameplayEventsWriter.LogSurvivalInfo(int(GameDifficulty), int(GameDifficulty));
        }
        foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
        {
            if((GameplayEventsWriter != none) && GameplayEventsWriter.IsSessionInProgress())
            {
                GameplayEventsWriter.LogKFPlayerPerk(1101, PC, PC.CurrentPerk.Class);
            }            
        }        
    }
}

function bool ShouldStartMatch()
{
    if(bWaitForNetPlayers && WorldInfo.NetMode != NM_Standalone)
    {
        return NumPlayers >= MinNetPlayers;
    }
    return true;
}

function bool CheckAllPlayersReady()
{
    local int I;
    local array<KFPlayerReplicationInfo> KFPRIArray;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    I = 0;
    J0x34:

    if(I < KFPRIArray.Length)
    {
        if(!IsPlayerReady(KFPRIArray[I]))
        {
            return false;
        }
        ++ I;
        goto J0x34;
    }
    return true;
}

function bool MajorityPlayersReady()
{
    local int I, readyPlayers;
    local array<KFPlayerReplicationInfo> KFPRIArray;
    local float readyPercent;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    I = 0;
    J0x34:

    if(I < KFPRIArray.Length)
    {
        if(IsPlayerReady(KFPRIArray[I]))
        {
            ++ readyPlayers;
        }
        ++ I;
        goto J0x34;
    }
    readyPercent = float(readyPlayers) / float(KFPRIArray.Length);
    return readyPercent >= 0.5;
}

function bool AnyPlayerReady()
{
    local int I;
    local array<KFPlayerReplicationInfo> KFPRIArray;

    MyKFGRI.GetKFPRIArray(KFPRIArray);
    I = 0;
    J0x34:

    if(I < KFPRIArray.Length)
    {
        if(IsPlayerReady(KFPRIArray[I]))
        {
            return true;
        }
        ++ I;
        goto J0x34;
    }
    return false;
}

function bool IsPlayerReady(KFPlayerReplicationInfo PRI)
{
    local KFPlayerController KFPC;

    if(Class'KFGameEngine'.static.CheckSkipLobby() || Class'Engine'.static.IsEditor())
    {
        return true;
    }
    if(PRI.bReadyToPlay)
    {
        KFPC = KFPlayerController(PRI.Owner);
        if((KFPC != none) && (KFPC.CurrentPerk == none) || !KFPC.CurrentPerk.bInitialized)
        {
            LogInternal(("ERROR: Failed to load perk for:" @ string(KFPC)) @ string(KFPC.CurrentPerk));
            return false;
        }
        return true;
    }
    return false;
}

function UpdateCurrentMapVoteTime(byte NewTime, optional bool bStartTime);

function OnAIChangeEnemy(BaseAIController AI, Pawn Enemy)
{
    if(BaseMutator != none)
    {
        BaseMutator.ModifyAIEnemy(AI, Enemy);
    }
}

auto state PendingMatch
{
    event Timer()
    {
        global.Timer();
        if(bDelayedStart)
        {
            if(ShouldStartMatch())
            {
                if(!IsTimerActive('LobbyCountdownComplete') && MajorityPlayersReady())
                {
                    MyKFGRI.RemainingTime = ReadyUpDelay;
                    MyKFGRI.bStopCountDown = false;
                    SetCountdown(false, byte(ReadyUpDelay));                    
                }
                else
                {
                    if(IsTimerActive('LobbyCountdownComplete') && !MajorityPlayersReady())
                    {
                        ClearTimer('LobbyCountdownComplete');
                        MyKFGRI.bStopCountDown = true;
                        ResetCountDown();
                    }
                }
                if(CheckAllPlayersReady())
                {
                    if(!bStartFinalCount)
                    {
                        SetCountdown(true, byte(GameStartDelay));
                    }                    
                }
                else
                {
                    if(bStartFinalCount)
                    {
                        SetCountdown(false, byte(MyKFGRI.RemainingTime));
                    }
                }                
            }
            else
            {
                if(IsTimerActive('LobbyCountdownComplete'))
                {
                    ClearTimer('LobbyCountdownComplete');
                    MyKFGRI.bStopCountDown = true;
                }
            }
            if(KFGameEngine(Class'Engine'.static.GetEngine()).IsLockedServer() && !IsTimerActive('CheckServerUnlock'))
            {
                SetTimer(float(ReadyUpDelay), false, 'CheckServerUnlock');
            }
        }
    }
    stop;    
}

defaultproperties
{
    CustomizationPawnClass=Class'KFPawn_Customization'
    bWaitForNetPlayers=true
    bCanPerkAlwaysChange=true
    bUseMapList=true
    KFGFxManagerClass=Class'KFGFxMoviePlayer_Manager'
    GameLength=1
    MinNetPlayers=1
    ReadyUpDelay=120
    GameStartDelay=4
    EndOfGameDelay=15
    KickVotePercentage=0.5
    TimeBetweenFailedVotes=10
    MapVoteDuration=60
    ReconnectRespawnTime=30
    DifficultyTemplate=KFDifficultyInfo'GP_Difficulty_ARCH.Difficulty'
    DeathPenaltyModifiers(0)=0.05
    DeathPenaltyModifiers(1)=0.1
    DeathPenaltyModifiers(2)=0.2
    DeathPenaltyModifiers(3)=0.25
    ZedTimeSlomoScale=0.2
    ZedTimeBlendOutTime=0.5
    GameMapCycles(0)=(Maps=("KF-BurningParis","KF-Bioticslab","KF-Outpost","KF-VolterManor","KF-Catacombs","KF-EvacuationPoint"))
    DialogManagerClass=Class'KFDialogManager'
    ActionMusicDelay=5
    ForcedMusicTracks(0)=KFMusicTrackInfo'WW_MMNU_Login.TrackInfo'
    ForcedMusicTracks(1)=KFMusicTrackInfo'WW_MMNU_Login.TrackInfo'
    ForcedMusicTracks(2)=KFMusicTrackInfo'WW_MACT_Default.TI_SH_Boss_DieVolter'
    ForcedMusicTracks(3)=KFMusicTrackInfo'WW_MACT_Default.TI_ID_Murderer'
    ForcedMusicTracks(4)=KFMusicTrackInfo'WW_MACT_Default.TI_ID_Murderer'
    ReservationTimeout=32
    bRestartLevel=false
    bTeamGame=true
    bWaitingToStartMatch=true
    bRequiresPushToTalk=true
    DefaultPawnClass=Class'KFPawn_Human'
    HUDType=Class'KFGFxHudWrapper'
    MaxPlayersAllowed=6
    AccessControlClass=Class'KFAccessControl'
    PlayerControllerClass=Class'KFPlayerController'
    PlayerReplicationInfoClass=Class'KFPlayerReplicationInfo'
    GameReplicationInfoClass=Class'KFGameReplicationInfo'
    PopulationManagerClass=Class'GameFramework.GameCrowdPopulationManager'
    OnlineGameSettingsClass=Class'KFOnlineGameSettings'
}