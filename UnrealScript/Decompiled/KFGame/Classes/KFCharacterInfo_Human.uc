/*******************************************************************************
 * KFCharacterInfo_Human generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFCharacterInfo_Human extends KFCharacterInfoBase
    hidecategories(Object)
    implements(KFUnlockableAsset);

const NUM_FAVE_WEAPS = 8;

struct SkinVariant
{
    var() const int UnlockAssetID;
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /** The material this outfit can use */
    var() MaterialInstance Skin;

    structdefaultproperties
    {
        UnlockAssetID=0
        UITexture=none
        Skin=none
    }
};

struct OutfitVariants
{
    var() const int UnlockAssetID;
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /** Outfit mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /** Reference to the different skin variants for a particular outfit mesh */
    var() array<SkinVariant> SkinVariations;

    structdefaultproperties
    {
        UnlockAssetID=0
        UITexture=none
        MeshName=""
        SkinVariations=none
    }
};

struct AttachmentOverrideList
{
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bHat;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bFace;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bEyes;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bJaw;

    structdefaultproperties
    {
        bHat=false
        bFace=false
        bEyes=false
        bJaw=false
    }
};

struct AttachmentVariants
{
    var() const int UnlockAssetID;
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /**  
     *Whether the attachment is a skeletal mesh. Otherwise, it is treated as a static mesh attachment.
     *               Skeletal meshe animations are parented with the body mesh and must share the same skeletaon.
     */
    var() bool bIsSkeletalAttachment;
    /** Attachment mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /**  
     *Name of the socket that it attaches to. The socket MUST exist in the body mesh for static mesh
     *               attachments to work. SocketName is also used to resolve conflicts - when more than one attachment
     *               tries to attach to the same socket, it will replace the previously existing attachment. It will keep
     *               both if there is no conflict. NOTE: Skeletal meshes do not use sockets for attachment, but the socket name
     *               can still be used for conflit resolution.
     */
    var() name SocketName;
    /** Translation relative to given socket (for additional control) */
    var() Vector RelativeTranslation<EditCondition=!bIsSkeletalAttachment>;
    /** Rotation relative to given socket (for additional control) */
    var() Rotator RelativeRotation<EditCondition=!bIsSkeletalAttachment>;
    /** Scale relative to given socket (for additional control) */
    var() Vector RelativeScale;
    /** Distance at which the attachment will be hidden (distance culled). If 0, it is never culled */
    var() float MaxDrawDistance;
    /** Material ID used for skin variations for this attachment (default is 0) */
    var() int SkinMaterialID;
    /** Reference to the different skin variants for a particular attachment mesh */
    var() array<SkinVariant> SkinVariations;
    /** List of sockets that this attachment will detach, if they are currently attached to a player */
    var() AttachmentOverrideList OverrideList;

    structdefaultproperties
    {
        UnlockAssetID=0
        UITexture=none
        bIsSkeletalAttachment=false
        MeshName=""
        SocketName=None
        RelativeTranslation=(X=0,Y=0,Z=0)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        RelativeScale=(X=1,Y=1,Z=1)
        MaxDrawDistance=0
        SkinMaterialID=0
        SkinVariations=none
        OverrideList=(bHat=false,bFace=false,bEyes=false,bJaw=false)
    }
};

struct FirstPersonArmVariants
{
    /** Mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /** Reference to the different skin variants for a particular arms mesh */
    var() array<MaterialInstance> SkinVariants;

    structdefaultproperties
    {
        MeshName=""
        SkinVariants=none
    }
};

var() const int UnlockAssetID;
var(General) Texture DefaultHeadPortrait;
var(General) array<Texture> DefaultTeamHeadPortrait;
/** Matches the FamilyID in the CustomCharData */
var(General) string FamilyID;
/** Faction that this family belongs to. */
var(General) string Faction;
/** Whether these are female characters */
var(General) bool bIsFemale;
/** The material ID for the skin in the mesh */
var(ThirdPerson) int HeadMaterialID;
var(ThirdPerson) int BodyMaterialID;
/** The outfit variants for a character. Used for Character Customization */
var(ThirdPerson) array<OutfitVariants> BodyVariants;
/** The head variants for a character. Used for Character Customization */
var(ThirdPerson) array<OutfitVariants> HeadVariants;
/** Various cosmetic variants for a character. Used for Character Customization */
var(ThirdPerson) array<AttachmentVariants> CosmeticVariants;
/** The outfit variants for a character. Used for Character Customization */
var(FirstPerson) array<FirstPersonArmVariants> CharacterArmVariants;
/** Package to load to find the arm mesh for this char. */
var(FirstPerson) string ArmMeshPackageName;
/** Name of mesh within ArmMeshPackageName to use for arms. */
var(FirstPerson) SkeletalMesh ArmMesh;
/** Package that contains team-skin materials for first-person arms. */
var(FirstPerson) string ArmSkinPackageName;
var(FaveWeapons) name FavoriteWeaponClassNames[8];

function int GetAssetId()
{
    return UnlockAssetID;
}

function SkeletalMesh GetFirstPersonArms()
{
    if(ArmMesh == none)
    {
        WarnInternal("Unable to load first person arms");
    }
    return ArmMesh;
}

function MaterialInterface GetFirstPersonArmsMaterial(int TeamNum)
{
    return GetFirstPersonArms().Materials[0];
}

function Texture GetCharPortrait(int TeamNum)
{
    return ((TeamNum < DefaultTeamHeadPortrait.Length) ? DefaultTeamHeadPortrait[TeamNum] : DefaultHeadPortrait);
}

function int GetFavoriteWeaponIndexOf(Weapon W)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < 8)
    {
        if(W.Class.Name == FavoriteWeaponClassNames[I])
        {
            return I;
        }
        ++ I;
        goto J0x0B;
    }
    return -1;
}

simulated function SetCharacterFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    super.SetCharacterFromArch(KFP, KFPRI);
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    KFPRI.CharPortrait = GetCharPortrait(KFPRI.GetTeamNum());
    if(bIsFemale)
    {
        KFPRI.TTSSpeaker = byte(Rand(4));        
    }
    else
    {
        KFPRI.TTSSpeaker = byte(Rand(5) + 4);
    }
}

simulated function SetCharacterMeshFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local int AttachmentIdx;

    super.SetCharacterMeshFromArch(KFP, KFPRI);
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    SetBodyMeshAndSkin(KFPRI.RepCustomizationInfo.BodyMeshIndex, KFPRI.RepCustomizationInfo.BodySkinIndex, KFP, KFPRI);
    SetHeadMeshAndSkin(KFPRI.RepCustomizationInfo.HeadMeshIndex, KFPRI.RepCustomizationInfo.HeadSkinIndex, KFP, KFPRI);
    AttachmentIdx = 0;
    J0x153:

    if(AttachmentIdx < 3)
    {
        DetatchAttachment(AttachmentIdx, KFP);
        ++ AttachmentIdx;
        goto J0x153;
    }
    AttachmentIdx = 0;
    J0x198:

    if(AttachmentIdx < 3)
    {
        SetAttachmentMeshAndSkin(KFPRI.RepCustomizationInfo.AttachmentMeshIndices[AttachmentIdx], KFPRI.RepCustomizationInfo.AttachmentSkinIndices[AttachmentIdx], KFP, KFPRI);
        ++ AttachmentIdx;
        goto J0x198;
    }
}

simulated function byte GetValidVarriantIndex(out array<OutfitVariants> VarriantList, byte StartingIndex)
{
    local byte I;
    local OutfitVariants CurrentBodyVariant;

    I = 0;
    J0x0C:

    if(I < VarriantList.Length)
    {
        CurrentBodyVariant = VarriantList[I];
        if(Class'KFUnlockManager'.static.GetAvailableOutfit(CurrentBodyVariant))
        {
            return I;
        }
        ++ I;
        goto J0x0C;
    }
    return 0;
}

simulated function byte GetValidSkinIndex(out array<SkinVariant> SkinList, byte StartingIndex)
{
    local byte I;
    local SkinVariant CurrentSkinVariant;

    I = 0;
    J0x0C:

    if(I < SkinList.Length)
    {
        CurrentSkinVariant = SkinList[I];
        if(Class'KFUnlockManager'.static.GetAvailableSkin(CurrentSkinVariant))
        {
            return I;
        }
        ++ I;
        goto J0x0C;
    }
    return 0;
}

simulated function byte GetValidAttachmentIndex(out array<AttachmentVariants> AttachmentList, byte StartingIndex)
{
    local byte I;
    local AttachmentVariants CurrentAttachmentVariant;

    I = 0;
    J0x0C:

    if(I < AttachmentList.Length)
    {
        CurrentAttachmentVariant = AttachmentList[I];
        if(Class'KFUnlockManager'.static.GetAvailableAttachment(CurrentAttachmentVariant))
        {
            return I;
        }
        ++ I;
        goto J0x0C;
    }
    return 0;
}

simulated function SetBodyMeshAndSkin(byte CurrentBodyMeshIndex, byte CurrentBodySkinIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local string CharBodyMeshName;
    local SkeletalMesh CharBodyMesh;
    local OutfitVariants CurrentBodyVariant;
    local SkinVariant CurrentSkinVariant;

    if(BodyVariants.Length > 0)
    {
        CurrentBodyMeshIndex = ((CurrentBodyMeshIndex < BodyVariants.Length) ? CurrentBodyMeshIndex : 0);
        CurrentBodyVariant = BodyVariants[CurrentBodyMeshIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableOutfit(CurrentBodyVariant) && KFP.IsLocallyControlled())
        {
            CurrentBodyMeshIndex = GetValidVarriantIndex(BodyVariants, CurrentBodyMeshIndex);
            CurrentBodyVariant = BodyVariants[CurrentBodyMeshIndex];
        }
        CurrentSkinVariant = CurrentBodyVariant.SkinVariations[CurrentBodySkinIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableSkin(CurrentSkinVariant) && KFP.IsLocallyControlled())
        {
            CurrentBodySkinIndex = GetValidSkinIndex(CurrentBodyVariant.SkinVariations, CurrentBodySkinIndex);
        }
        CharBodyMeshName = BodyVariants[CurrentBodyMeshIndex].MeshName;
        CharBodyMesh = SkeletalMesh(DynamicLoadObject(CharBodyMeshName, Class'SkeletalMesh'));
        KFP.Mesh.SetSkeletalMesh(CharBodyMesh);
        KFPRI.RepCustomizationInfo.BodyMeshIndex = CurrentBodyMeshIndex;
        KFPRI.RepCustomizationInfo.BodySkinIndex = CurrentBodySkinIndex;
        if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetBodySkinMaterial(BodyVariants[CurrentBodyMeshIndex], CurrentBodySkinIndex, KFP);
        }        
    }
    else
    {
        WarnInternal("Character does not have a valid mesh");
    }
}

protected simulated function SetBodySkinMaterial(OutfitVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            NewSkinIndex = ((NewSkinIndex < CurrentVariant.SkinVariations.Length) ? NewSkinIndex : 0);
            KFP.Mesh.SetMaterial(BodyMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);            
        }
        else
        {
            I = 0;
            J0x12B:

            if(I < KFP.Mesh.GetNumElements())
            {
                KFP.Mesh.SetMaterial(I, none);
                ++ I;
                goto J0x12B;
            }
        }
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.Mesh != none)
    {
        KFP.BodyMIC = KFP.Mesh.CreateAndSetMaterialInstanceConstant(BodyMaterialID);
    }
}

protected simulated function SetHeadSkinMaterial(OutfitVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            NewSkinIndex = ((NewSkinIndex < CurrentVariant.SkinVariations.Length) ? NewSkinIndex : 0);
            KFP.ThirdPersonHeadMeshComponent.SetMaterial(HeadMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);            
        }
        else
        {
            I = 0;
            J0x12B:

            if(I < KFP.ThirdPersonHeadMeshComponent.GetNumElements())
            {
                KFP.ThirdPersonHeadMeshComponent.SetMaterial(I, none);
                ++ I;
                goto J0x12B;
            }
        }
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.ThirdPersonHeadMeshComponent != none)
    {
        KFP.HeadMIC = KFP.ThirdPersonHeadMeshComponent.CreateAndSetMaterialInstanceConstant(HeadMaterialID);
    }
}

simulated function SetHeadMeshAndSkin(byte CurrentHeadMeshIndex, byte CurrentHeadSkinIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local string CharHeadMeshName;
    local SkeletalMesh CharHeadMesh;
    local OutfitVariants HeadVariant;
    local SkinVariant HeadSkinVariant;

    if(HeadVariants.Length > 0)
    {
        CurrentHeadMeshIndex = ((CurrentHeadMeshIndex < HeadVariants.Length) ? CurrentHeadMeshIndex : 0);
        HeadVariant = HeadVariants[CurrentHeadMeshIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableOutfit(HeadVariant) && KFP.IsLocallyControlled())
        {
            CurrentHeadMeshIndex = GetValidVarriantIndex(HeadVariants, CurrentHeadMeshIndex);
            HeadVariant = HeadVariants[CurrentHeadMeshIndex];
        }
        HeadSkinVariant = HeadVariant.SkinVariations[CurrentHeadSkinIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableSkin(HeadSkinVariant) && KFP.IsLocallyControlled())
        {
            CurrentHeadSkinIndex = GetValidSkinIndex(HeadVariant.SkinVariations, CurrentHeadSkinIndex);
            HeadSkinVariant = HeadVariant.SkinVariations[CurrentHeadSkinIndex];
        }
        CharHeadMeshName = HeadVariants[CurrentHeadMeshIndex].MeshName;
        CharHeadMesh = SkeletalMesh(DynamicLoadObject(CharHeadMeshName, Class'SkeletalMesh'));
        KFP.ThirdPersonHeadMeshComponent.SetSkeletalMesh(CharHeadMesh);
        KFP.ThirdPersonHeadMeshComponent.SetScale(DefaultMeshScale);
        KFP.ThirdPersonHeadMeshComponent.SetParentAnimComponent(KFP.Mesh);
        KFP.ThirdPersonHeadMeshComponent.SetShadowParent(KFP.Mesh);
        KFP.ThirdPersonHeadMeshComponent.SetLODParent(KFP.Mesh);
        KFP.AttachComponent(KFP.ThirdPersonHeadMeshComponent);
        if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetHeadSkinMaterial(HeadVariants[CurrentHeadMeshIndex], CurrentHeadSkinIndex, KFP);
        }
        KFPRI.RepCustomizationInfo.HeadMeshIndex = CurrentHeadMeshIndex;
        KFPRI.RepCustomizationInfo.HeadSkinIndex = CurrentHeadSkinIndex;
    }
}

function bool IsAttachmentSupported(byte CurrentAttachmentMeshIndex, KFPawn KFP)
{
    local name CharAttachmentSocketName;

    if(CosmeticVariants.Length > 0)
    {
        if(CosmeticVariants[CurrentAttachmentMeshIndex].bIsSkeletalAttachment)
        {
            return true;            
        }
        else
        {
            CharAttachmentSocketName = CosmeticVariants[CurrentAttachmentMeshIndex].SocketName;
            return KFP.Mesh.GetSocketByName(CharAttachmentSocketName) != none;
        }        
    }
    else
    {
        return false;
    }
}

protected simulated function SetAttachmentSkinMaterial(int PawnAttachmentIndex, AttachmentVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            NewSkinIndex = ((NewSkinIndex < CurrentVariant.SkinVariations.Length) ? NewSkinIndex : 0);
            KFP.ThirdPersonAttachments[PawnAttachmentIndex].SetMaterial(CurrentVariant.SkinMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);            
        }
        else
        {
            I = 0;
            J0x148:

            if(I < KFP.ThirdPersonAttachments[PawnAttachmentIndex].GetNumElements())
            {
                KFP.ThirdPersonAttachments[PawnAttachmentIndex].SetMaterial(I, none);
                ++ I;
                goto J0x148;
            }
        }
    }
}

simulated function SetAttachmentMeshAndSkin(byte CurrentAttachmentMeshIndex, byte CurrentAttachmentSkinIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local string CharAttachmentMeshName;
    local name CharAttachmentSocketName;
    local bool bIsSkeletalAttachment;
    local StaticMesh CharAttachmentStaticMesh;
    local SkeletalMesh CharacterAttachmentSkelMesh;
    local float MaxDrawDistance;
    local editinline StaticMeshComponent StaticAttachment;
    local editinline SkeletalMeshComponent SkeletalAttachment;
    local SkeletalMeshSocket AttachmentSocket;
    local Vector AttachmentLocationRelativeToSocket, AttachmentScaleRelativeToSocket;
    local Rotator AttachmentRotationRelativeToSocket;
    local int AttachmentSlotIndex;
    local AttachmentVariants AttachmentVariant;
    local SkinVariant AttachmentSkin;

    DetatchConflictingAttachments(CurrentAttachmentMeshIndex, KFP, KFPRI);
    AttachmentSlotIndex = GetAttachmentSlotIndex(CurrentAttachmentMeshIndex, KFP);
    if((CosmeticVariants.Length > 0) && CurrentAttachmentMeshIndex < CosmeticVariants.Length)
    {
        AttachmentVariant = CosmeticVariants[CurrentAttachmentMeshIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableAttachment(AttachmentVariant) && KFP.IsLocallyControlled())
        {
            CurrentAttachmentMeshIndex = GetValidAttachmentIndex(CosmeticVariants, CurrentAttachmentMeshIndex);
            AttachmentVariant = CosmeticVariants[CurrentAttachmentMeshIndex];
        }
        AttachmentSkin = AttachmentVariant.SkinVariations[CurrentAttachmentSkinIndex];
        if(!Class'KFUnlockManager'.static.GetAvailableSkin(AttachmentSkin) && KFP.IsLocallyControlled())
        {
            CurrentAttachmentSkinIndex = GetValidSkinIndex(AttachmentVariant.SkinVariations, CurrentAttachmentSkinIndex);
            AttachmentSkin = AttachmentVariant.SkinVariations[CurrentAttachmentSkinIndex];
        }
        CharAttachmentMeshName = CosmeticVariants[CurrentAttachmentMeshIndex].MeshName;
        CharAttachmentSocketName = CosmeticVariants[CurrentAttachmentMeshIndex].SocketName;
        MaxDrawDistance = CosmeticVariants[CurrentAttachmentMeshIndex].MaxDrawDistance;
        AttachmentLocationRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeTranslation;
        AttachmentRotationRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeRotation;
        AttachmentScaleRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeScale;
        bIsSkeletalAttachment = CosmeticVariants[CurrentAttachmentMeshIndex].bIsSkeletalAttachment;
        if(bIsSkeletalAttachment)
        {
            if(SkeletalMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]) != none)
            {
                SkeletalAttachment = SkeletalMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]);                
            }
            else
            {
                SkeletalAttachment = new (KFP) Class'SkeletalMeshComponent';
                SkeletalAttachment.SetActorCollision(false, false);
                KFP.ThirdPersonAttachments[AttachmentSlotIndex] = SkeletalAttachment;
            }
            CharacterAttachmentSkelMesh = SkeletalMesh(DynamicLoadObject(CharAttachmentMeshName, Class'SkeletalMesh'));
            SkeletalAttachment.SetSkeletalMesh(CharacterAttachmentSkelMesh);
            SkeletalAttachment.SetParentAnimComponent(KFP.Mesh);
            SkeletalAttachment.SetLODParent(KFP.Mesh);
            SkeletalAttachment.SetScale(DefaultMeshScale);
            SkeletalAttachment.SetCullDistance(MaxDrawDistance);
            SkeletalAttachment.SetShadowParent(KFP.Mesh);
            SkeletalAttachment.SetLightingChannels(KFP.PawnLightingChannel);
            KFP.AttachComponent(SkeletalAttachment);            
        }
        else
        {
            if(StaticMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]) != none)
            {
                StaticAttachment = StaticMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]);                
            }
            else
            {
                StaticAttachment = new (KFP) Class'StaticMeshComponent';
                StaticAttachment.SetActorCollision(false, false);
                KFP.ThirdPersonAttachments[AttachmentSlotIndex] = StaticAttachment;
            }
            CharAttachmentStaticMesh = StaticMesh(DynamicLoadObject(CharAttachmentMeshName, Class'StaticMesh'));
            StaticAttachment.SetStaticMesh(CharAttachmentStaticMesh);
            StaticAttachment.SetScale(DefaultMeshScale);
            StaticAttachment.SetCullDistance(MaxDrawDistance);
            StaticAttachment.SetShadowParent(KFP.Mesh);
            StaticAttachment.SetLightingChannels(KFP.PawnLightingChannel);
            AttachmentSocket = KFP.Mesh.GetSocketByName(CharAttachmentSocketName);
            KFP.Mesh.AttachComponent(StaticAttachment, AttachmentSocket.BoneName, AttachmentSocket.RelativeLocation + AttachmentLocationRelativeToSocket, AttachmentSocket.RelativeRotation + AttachmentRotationRelativeToSocket, AttachmentSocket.RelativeScale * AttachmentScaleRelativeToSocket);
        }
        KFP.ThirdPersonAttachmentBitMask = KFP.ThirdPersonAttachmentBitMask | (1 << AttachmentSlotIndex);
        KFP.ThirdPersonAttachmentSocketNames[AttachmentSlotIndex] = CharAttachmentSocketName;
        if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetAttachmentSkinMaterial(AttachmentSlotIndex, CosmeticVariants[CurrentAttachmentMeshIndex], CurrentAttachmentSkinIndex, KFP);
        }
        KFPRI.RepCustomizationInfo.AttachmentMeshIndices[AttachmentSlotIndex] = CurrentAttachmentMeshIndex;
        KFPRI.RepCustomizationInfo.AttachmentSkinIndices[AttachmentSlotIndex] = CurrentAttachmentSkinIndex;
    }
    if(CurrentAttachmentMeshIndex == 255)
    {
        RemoveAttachmentMeshAndSkin(AttachmentSlotIndex, KFP, KFPRI);
    }
}

simulated function ClearAllAttachments(KFPawn KFP, KFPlayerReplicationInfo KFPRI)
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < 3)
    {
        RemoveAttachmentMeshAndSkin(I, KFP, KFPRI);
        ++ I;
        goto J0x0C;
    }
}

function bool HasSocketConflict(KFPawn KFP, name SocketName, out int OutConflictAttachmentIndex)
{
    local int AttachmentIdx;

    AttachmentIdx = 0;
    J0x0B:

    if(AttachmentIdx < 3)
    {
        if((KFP.ThirdPersonAttachmentSocketNames[AttachmentIdx] != 'None') && KFP.ThirdPersonAttachmentSocketNames[AttachmentIdx] == SocketName)
        {
            OutConflictAttachmentIndex = AttachmentIdx;
            return true;
        }
        ++ AttachmentIdx;
        goto J0x0B;
    }
    OutConflictAttachmentIndex = -1;
    return false;
}

function DetatchConflictingAttachments(byte CurrentAttachmentMeshIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local name CharAttachmentSocketName;
    local int AttachmentIdx;

    if((CosmeticVariants.Length > 0) && CurrentAttachmentMeshIndex < CosmeticVariants.Length)
    {
        CharAttachmentSocketName = CosmeticVariants[CurrentAttachmentMeshIndex].SocketName;
        AttachmentIdx = 0;
        J0x6A:

        if(AttachmentIdx < 3)
        {
            if((KFP.ThirdPersonAttachmentSocketNames[AttachmentIdx] != 'None') && KFP.ThirdPersonAttachmentSocketNames[AttachmentIdx] == CharAttachmentSocketName)
            {
                RemoveAttachmentMeshAndSkin(AttachmentIdx, KFP, KFPRI);                
            }
            else
            {
                if(GetOverrideCase(KFP.ThirdPersonAttachmentSocketNames[AttachmentIdx], CurrentAttachmentMeshIndex))
                {
                    RemoveAttachmentMeshAndSkin(AttachmentIdx, KFP, KFPRI);
                }
            }
            ++ AttachmentIdx;
            goto J0x6A;
        }
    }
}

function bool GetOverrideCase(name SocketName, byte AttachmentIndex)
{
    switch(SocketName)
    {
        case 'Hat_Attach':
            return CosmeticVariants[AttachmentIndex].OverrideList.bHat;
        case 'Face_Attach':
            return CosmeticVariants[AttachmentIndex].OverrideList.bFace;
        case 'Eyes_Attach':
            return CosmeticVariants[AttachmentIndex].OverrideList.bEyes;
        case 'Jaw_Attach':
            return CosmeticVariants[AttachmentIndex].OverrideList.bJaw;
        default:
            return false;
            break;
    }
}

function int GetAttachmentSlotIndex(byte CurrentAttachmentMeshIndex, KFPawn KFP)
{
    local int AttachmentIdx;

    AttachmentIdx = 0;
    J0x0B:

    if(AttachmentIdx < 3)
    {
        if((KFP.ThirdPersonAttachmentBitMask & (1 << AttachmentIdx)) == 0)
        {
            return AttachmentIdx;
        }
        ++ AttachmentIdx;
        goto J0x0B;
    }
}

simulated function RemoveAttachmentMeshAndSkin(int PawnAttachmentIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    DetatchAttachment(PawnAttachmentIndex, KFP);
    if(KFPRI != none)
    {
        KFPRI.RepCustomizationInfo.AttachmentMeshIndices[PawnAttachmentIndex] = 255;
        KFPRI.RepCustomizationInfo.AttachmentSkinIndices[PawnAttachmentIndex] = 255;
    }
}

function DetatchAttachment(int PawnAttachmentIndex, KFPawn KFP)
{
    if(KFP.ThirdPersonAttachments[PawnAttachmentIndex] != none)
    {
        if(SkeletalMeshComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]) != none)
        {
            KFP.DetachComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]);            
        }
        else
        {
            KFP.Mesh.DetachComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]);
        }
    }
    KFP.ThirdPersonAttachmentBitMask = KFP.ThirdPersonAttachmentBitMask & ~1 << PawnAttachmentIndex;
    KFP.ThirdPersonAttachmentSocketNames[PawnAttachmentIndex] = 'None';
}

simulated function SetFirstPersonArmsFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    SetArmsMeshAndSkin(KFPRI.RepCustomizationInfo.BodyMeshIndex, KFPRI.RepCustomizationInfo.BodySkinIndex, KFP, KFPRI);
}

simulated function SetArmsMeshAndSkin(byte ArmsMeshIndex, byte ArmsSkinIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local byte CurrentArmMeshIndex, CurrentArmSkinIndex;
    local string CharArmMeshName;
    local SkeletalMesh CharArmMesh;

    if(((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.IsHumanControlled()) && KFP.IsLocallyControlled())
    {
        if(CharacterArmVariants.Length > 0)
        {
            CurrentArmMeshIndex = ((ArmsMeshIndex < CharacterArmVariants.Length) ? ArmsMeshIndex : 0);
            CharArmMeshName = CharacterArmVariants[CurrentArmMeshIndex].MeshName;
            CharArmMesh = SkeletalMesh(DynamicLoadObject(CharArmMeshName, Class'SkeletalMesh'));
            KFP.ArmsMesh.SetSkeletalMesh(CharArmMesh);
            if(CharacterArmVariants[CurrentArmMeshIndex].SkinVariants.Length > 0)
            {
                CurrentArmSkinIndex = ((ArmsSkinIndex < CharacterArmVariants[CurrentArmMeshIndex].SkinVariants.Length) ? ArmsSkinIndex : 0);
                KFP.ArmsMesh.SetMaterial(0, CharacterArmVariants[CurrentArmMeshIndex].SkinVariants[CurrentArmSkinIndex]);                
            }
            else
            {
                KFP.ArmsMesh.SetMaterial(0, none);
            }            
        }
        else
        {
            if(ArmMesh != none)
            {
                KFP.ArmsMesh.SetMaterial(0, none);
                KFP.ArmsMesh.SetSkeletalMesh(ArmMesh);                
            }
            else
            {
                WarnInternal("Character does not have a valid arms mesh");
            }
        }
    }
}
