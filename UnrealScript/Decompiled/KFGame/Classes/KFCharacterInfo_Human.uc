/*******************************************************************************
 * KFCharacterInfo_Human generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFCharacterInfo_Human extends KFCharacterInfoBase
    native(Pawn)
    hidecategories(Object)
    implements(KFUnlockableAsset);

const NUM_FAVE_WEAPS = 8;

struct native SkinVariant
{
    var() const int UnlockAssetID;
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /** The material this outfit can use */
    var() MaterialInstance Skin;

    structdefaultproperties
    {
        UnlockAssetID=0
        UITexture=none
        Skin=none
    }
};

struct native OutfitVariants
{
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /** Outfit mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /** Reference to the different skin variants for a particular outfit mesh */
    var() array<SkinVariant> SkinVariations;

    structdefaultproperties
    {
        UITexture=none
        MeshName=""
        SkinVariations=none
    }
};

struct native AttachmentOverrideList
{
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bHat;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bFace;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bEyes;
    /** List of booleans that will effect which items can be attached with the current attachment */
    var() bool bJaw;
    /** List of cosmetic indices that this attachment will detach, if they are currently attached to a player */
    var() array<byte> SpecialOverrideIds;

    structdefaultproperties
    {
        bHat=false
        bFace=false
        bEyes=false
        bJaw=false
        SpecialOverrideIds=none
    }
};

struct native AttachmentVariants
{
    /** The path to this skins package and texture */
    var() Texture UITexture;
    /**  
     *Whether the attachment is a skeletal mesh. Otherwise, it is treated as a static mesh attachment.
     *               Skeletal meshe animations are parented with the body mesh and must share the same skeletaon.
     */
    var() bool bIsSkeletalAttachment;
    /** If set enables the material mask parameter on the assigned head variant */
    var() bool bMaskHeadMesh;
    /** Attachment mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /**  
     *Name of the socket that it attaches to. The socket MUST exist in the body mesh for static mesh
     *               attachments to work. SocketName is also used to resolve conflicts - when more than one attachment
     *               tries to attach to the same socket, it will replace the previously existing attachment. It will keep
     *               both if there is no conflict. NOTE: Skeletal meshes do not require sockets for attachment, but the socket name
     *               can still be used for conflit resolution.
     */
    var() name SocketName;
    /** Translation relative to given socket (for additional control) */
    var() Vector RelativeTranslation<EditCondition=!bIsSkeletalAttachment>;
    /** Rotation relative to given socket (for additional control) */
    var() Rotator RelativeRotation<EditCondition=!bIsSkeletalAttachment>;
    /** Scale relative to given socket (for additional control) */
    var() Vector RelativeScale;
    /** Distance at which the attachment will be hidden (distance culled). If 0, it is never culled */
    var() float MaxDrawDistance;
    /** Material ID used for skin variations for this attachment (default is 0) */
    var() int SkinMaterialID;
    /** Reference to the different skin variants for a particular attachment mesh */
    var() array<SkinVariant> SkinVariations;
    /** List of sockets that this attachment will detach, if they are currently attached to a player */
    var() AttachmentOverrideList OverrideList;

    structdefaultproperties
    {
        UITexture=none
        bIsSkeletalAttachment=false
        bMaskHeadMesh=false
        MeshName=""
        SocketName=None
        RelativeTranslation=(X=0,Y=0,Z=0)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        RelativeScale=(X=1,Y=1,Z=1)
        MaxDrawDistance=0
        SkinMaterialID=0
        SkinVariations=none
        OverrideList=(bHat=false,bFace=false,bEyes=false,bJaw=false,SpecialOverrideIds=none)
    }
};

struct native FirstPersonArmVariants
{
    /** Mesh name. Must be of form PackageName.MeshName */
    var() string MeshName;
    /** Reference to the different skin variants for a particular arms mesh */
    var() array<MaterialInstance> SkinVariants;

    structdefaultproperties
    {
        MeshName=""
        SkinVariants=none
    }
};

var() const int UnlockAssetID;
var(General) Texture DefaultHeadPortrait;
var(General) array<Texture> DefaultTeamHeadPortrait;
/** Matches the FamilyID in the CustomCharData */
var(General) string FamilyID;
/** Faction that this family belongs to. */
var(General) string Faction;
/** Whether these are female characters */
var(General) bool bIsFemale;
/** The material ID for the skin in the mesh */
var(ThirdPerson) int HeadMaterialID;
var(ThirdPerson) int BodyMaterialID;
/** The outfit variants for a character. Used for Character Customization */
var(ThirdPerson) const array<OutfitVariants> BodyVariants;
/** The head variants for a character. Used for Character Customization */
var(ThirdPerson) const array<OutfitVariants> HeadVariants;
/** Various cosmetic variants for a character. Used for Character Customization */
var(ThirdPerson) const array<AttachmentVariants> CosmeticVariants;
/** The outfit variants for a character. Used for Character Customization */
var(FirstPerson) array<FirstPersonArmVariants> CharacterArmVariants;
/** Package to load to find the arm mesh for this char. */
var(FirstPerson) string ArmMeshPackageName;
/** Name of mesh within ArmMeshPackageName to use for arms. */
var(FirstPerson) SkeletalMesh ArmMesh;
/** Package that contains team-skin materials for first-person arms. */
var(FirstPerson) string ArmSkinPackageName;
var(FaveWeapons) editconst name FavoriteWeaponClassNames[8];
var(FaveWeapons) editoronly class<KFWeaponDefinition> FavoriteWeaponClassDefs[8]<AllowAbstract=>;

function int GetAssetId()
{
    return UnlockAssetID;
}

function SkeletalMesh GetFirstPersonArms()
{
    if(ArmMesh == none)
    {
        WarnInternal("Unable to load first person arms");
    }
    return ArmMesh;
}

function Texture GetCharPortrait(int TeamNum)
{
    return ((TeamNum < DefaultTeamHeadPortrait.Length) ? DefaultTeamHeadPortrait[TeamNum] : DefaultHeadPortrait);
}

function int GetFavoriteWeaponIndexOf(Weapon W)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < 8)
    {
        if(W.Class.Name == FavoriteWeaponClassNames[I])
        {
            return I;
        }
        ++ I;
        goto J0x0B;
    }
    return -1;
}

simulated function SetCharacterFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    super.SetCharacterFromArch(KFP, KFPRI);
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    KFPRI.CharPortrait = GetCharPortrait(KFPRI.GetTeamNum());
    if(bIsFemale)
    {
        KFPRI.TTSSpeaker = byte(Rand(4));        
    }
    else
    {
        KFPRI.TTSSpeaker = byte(Rand(5) + 4);
    }
}

simulated function SetCharacterMeshFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local int AttachmentIdx, CosmeticMeshIdx;
    local bool bMaskHeadMesh;

    super.SetCharacterMeshFromArch(KFP, KFPRI);
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    SetBodyMeshAndSkin(KFPRI.RepCustomizationInfo.BodyMeshIndex, KFPRI.RepCustomizationInfo.BodySkinIndex, KFP);
    SetHeadMeshAndSkin(KFPRI.RepCustomizationInfo.HeadMeshIndex, KFPRI.RepCustomizationInfo.HeadSkinIndex, KFP);
    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        AttachmentIdx = 0;
        J0x17F:

        if(AttachmentIdx < 3)
        {
            DetachAttachment(AttachmentIdx, KFP);
            ++ AttachmentIdx;
            goto J0x17F;
        }
        AttachmentIdx = 0;
        J0x1C4:

        if(AttachmentIdx < 3)
        {
            CosmeticMeshIdx = KFPRI.RepCustomizationInfo.AttachmentMeshIndices[AttachmentIdx];
            if(CosmeticMeshIdx != 255)
            {
                bMaskHeadMesh = bMaskHeadMesh || CosmeticVariants[CosmeticMeshIdx].bMaskHeadMesh;
                SetAttachmentMeshAndSkin(byte(CosmeticMeshIdx), KFPRI.RepCustomizationInfo.AttachmentSkinIndices[AttachmentIdx], KFP, KFPRI);
            }
            ++ AttachmentIdx;
            goto J0x1C4;
        }
        if(bMaskHeadMesh && KFP.HeadMIC != none)
        {
            KFP.HeadMIC.SetScalarParameterValue('Scalar_Mask', 1);
        }
    }
}

private final function SetBodyMeshAndSkin(byte CurrentBodyMeshIndex, byte CurrentBodySkinIndex, KFPawn KFP)
{
    local string CharBodyMeshName;
    local SkeletalMesh CharBodyMesh;

    if(BodyVariants.Length > 0)
    {
        CurrentBodyMeshIndex = ((CurrentBodyMeshIndex < BodyVariants.Length) ? CurrentBodyMeshIndex : 0);
        CharBodyMeshName = BodyVariants[CurrentBodyMeshIndex].MeshName;
        CharBodyMesh = SkeletalMesh(DynamicLoadObject(CharBodyMeshName, Class'SkeletalMesh'));
        KFP.Mesh.SetSkeletalMesh(CharBodyMesh);
        if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetBodySkinMaterial(BodyVariants[CurrentBodyMeshIndex], CurrentBodySkinIndex, KFP);
        }        
    }
    else
    {
        WarnInternal("Character does not have a valid mesh");
    }
}

protected simulated function SetBodySkinMaterial(OutfitVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            NewSkinIndex = ((NewSkinIndex < CurrentVariant.SkinVariations.Length) ? NewSkinIndex : 0);
            KFP.Mesh.SetMaterial(BodyMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);            
        }
        else
        {
            I = 0;
            J0x12B:

            if(I < KFP.Mesh.GetNumElements())
            {
                KFP.Mesh.SetMaterial(I, none);
                ++ I;
                goto J0x12B;
            }
        }
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.Mesh != none)
    {
        KFP.BodyMIC = KFP.Mesh.CreateAndSetMaterialInstanceConstant(BodyMaterialID);
    }
}

protected simulated function SetHeadSkinMaterial(OutfitVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            NewSkinIndex = ((NewSkinIndex < CurrentVariant.SkinVariations.Length) ? NewSkinIndex : 0);
            KFP.ThirdPersonHeadMeshComponent.SetMaterial(HeadMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);            
        }
        else
        {
            I = 0;
            J0x12B:

            if(I < KFP.ThirdPersonHeadMeshComponent.GetNumElements())
            {
                KFP.ThirdPersonHeadMeshComponent.SetMaterial(I, none);
                ++ I;
                goto J0x12B;
            }
        }
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.ThirdPersonHeadMeshComponent != none)
    {
        KFP.HeadMIC = KFP.ThirdPersonHeadMeshComponent.CreateAndSetMaterialInstanceConstant(HeadMaterialID);
    }
}

private final function SetHeadMeshAndSkin(byte CurrentHeadMeshIndex, byte CurrentHeadSkinIndex, KFPawn KFP)
{
    local string CharHeadMeshName;
    local SkeletalMesh CharHeadMesh;

    if(HeadVariants.Length > 0)
    {
        CurrentHeadMeshIndex = ((CurrentHeadMeshIndex < HeadVariants.Length) ? CurrentHeadMeshIndex : 0);
        CharHeadMeshName = HeadVariants[CurrentHeadMeshIndex].MeshName;
        CharHeadMesh = SkeletalMesh(DynamicLoadObject(CharHeadMeshName, Class'SkeletalMesh'));
        KFP.ThirdPersonHeadMeshComponent.SetSkeletalMesh(CharHeadMesh);
        KFP.ThirdPersonHeadMeshComponent.SetScale(DefaultMeshScale);
        KFP.ThirdPersonHeadMeshComponent.SetParentAnimComponent(KFP.Mesh);
        KFP.ThirdPersonHeadMeshComponent.SetShadowParent(KFP.Mesh);
        KFP.ThirdPersonHeadMeshComponent.SetLODParent(KFP.Mesh);
        KFP.AttachComponent(KFP.ThirdPersonHeadMeshComponent);
        if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetHeadSkinMaterial(HeadVariants[CurrentHeadMeshIndex], CurrentHeadSkinIndex, KFP);
        }
    }
}

function bool IsAttachmentAvailable(const out AttachmentVariants Attachment, Pawn PreviewPawn)
{
    if(!Class'KFUnlockManager'.static.GetAvailableAttachment(Attachment))
    {
        LogInternal(("Attachment" @ Attachment.MeshName) @ "is not purchased.");
        return false;        
    }
    else
    {
        if((Attachment.bIsSkeletalAttachment && Attachment.SocketName != 'None') && PreviewPawn.Mesh.GetSocketByName(Attachment.SocketName) == none)
        {
            LogInternal(("Attachment" @ Attachment.MeshName) @ "is missing a required socket.");
            return false;
        }
    }
    return true;
}

protected simulated function SetAttachmentSkinMaterial(int PawnAttachmentIndex, const out AttachmentVariants CurrentVariant, byte NewSkinIndex, KFPawn KFP)
{
    local int I;

    if(KFP.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(CurrentVariant.SkinVariations.Length > 0)
        {
            if(NewSkinIndex < CurrentVariant.SkinVariations.Length)
            {
                KFP.ThirdPersonAttachments[PawnAttachmentIndex].SetMaterial(CurrentVariant.SkinMaterialID, CurrentVariant.SkinVariations[NewSkinIndex].Skin);                
            }
            else
            {
                LogInternal("Out of bounds skin index for" @ CurrentVariant.MeshName);
                RemoveAttachmentMeshAndSkin(PawnAttachmentIndex, KFP);
            }            
        }
        else
        {
            I = 0;
            J0x190:

            if(I < KFP.ThirdPersonAttachments[PawnAttachmentIndex].GetNumElements())
            {
                KFP.ThirdPersonAttachments[PawnAttachmentIndex].SetMaterial(I, none);
                ++ I;
                goto J0x190;
            }
        }
    }
}

private final function SetAttachmentMeshAndSkin(byte CurrentAttachmentMeshIndex, byte CurrentAttachmentSkinIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local string CharAttachmentMeshName;
    local name CharAttachmentSocketName;
    local bool bIsSkeletalAttachment;
    local StaticMesh CharAttachmentStaticMesh;
    local SkeletalMesh CharacterAttachmentSkelMesh;
    local float MaxDrawDistance;
    local editinline StaticMeshComponent StaticAttachment;
    local editinline SkeletalMeshComponent SkeletalAttachment;
    local SkeletalMeshSocket AttachmentSocket;
    local Vector AttachmentLocationRelativeToSocket, AttachmentScaleRelativeToSocket;
    local Rotator AttachmentRotationRelativeToSocket;
    local int AttachmentSlotIndex;

    if(KFP.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    AttachmentSlotIndex = GetAttachmentSlotIndex(CurrentAttachmentMeshIndex, KFP);
    if((CosmeticVariants.Length > 0) && CurrentAttachmentMeshIndex < CosmeticVariants.Length)
    {
        CharAttachmentMeshName = CosmeticVariants[CurrentAttachmentMeshIndex].MeshName;
        CharAttachmentSocketName = CosmeticVariants[CurrentAttachmentMeshIndex].SocketName;
        MaxDrawDistance = CosmeticVariants[CurrentAttachmentMeshIndex].MaxDrawDistance;
        AttachmentLocationRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeTranslation;
        AttachmentRotationRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeRotation;
        AttachmentScaleRelativeToSocket = CosmeticVariants[CurrentAttachmentMeshIndex].RelativeScale;
        bIsSkeletalAttachment = CosmeticVariants[CurrentAttachmentMeshIndex].bIsSkeletalAttachment;
        if(bIsSkeletalAttachment)
        {
            if(SkeletalMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]) != none)
            {
                if(KFP.IsLocallyControlled())
                {
                    if((CharAttachmentSocketName != 'None') && KFP.Mesh.GetSocketByName(CharAttachmentSocketName) == none)
                    {
                        RemoveAttachmentMeshAndSkin(AttachmentSlotIndex, KFP, KFPRI);
                        return;
                    }
                }
                SkeletalAttachment = SkeletalMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]);                
            }
            else
            {
                SkeletalAttachment = new (KFP) Class'SkeletalMeshComponent';
                SkeletalAttachment.SetActorCollision(false, false);
                KFP.ThirdPersonAttachments[AttachmentSlotIndex] = SkeletalAttachment;
            }
            CharacterAttachmentSkelMesh = SkeletalMesh(DynamicLoadObject(CharAttachmentMeshName, Class'SkeletalMesh'));
            SkeletalAttachment.SetSkeletalMesh(CharacterAttachmentSkelMesh);
            SkeletalAttachment.SetParentAnimComponent(KFP.Mesh);
            SkeletalAttachment.SetLODParent(KFP.Mesh);
            SkeletalAttachment.SetScale(DefaultMeshScale);
            SkeletalAttachment.SetCullDistance(MaxDrawDistance);
            SkeletalAttachment.SetShadowParent(KFP.Mesh);
            SkeletalAttachment.SetLightingChannels(KFP.PawnLightingChannel);
            KFP.AttachComponent(SkeletalAttachment);            
        }
        else
        {
            if(StaticMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]) != none)
            {
                StaticAttachment = StaticMeshComponent(KFP.ThirdPersonAttachments[AttachmentSlotIndex]);                
            }
            else
            {
                StaticAttachment = new (KFP) Class'StaticMeshComponent';
                StaticAttachment.SetActorCollision(false, false);
                KFP.ThirdPersonAttachments[AttachmentSlotIndex] = StaticAttachment;
            }
            CharAttachmentStaticMesh = StaticMesh(DynamicLoadObject(CharAttachmentMeshName, Class'StaticMesh'));
            StaticAttachment.SetStaticMesh(CharAttachmentStaticMesh);
            StaticAttachment.SetScale(DefaultMeshScale);
            StaticAttachment.SetCullDistance(MaxDrawDistance);
            StaticAttachment.SetShadowParent(KFP.Mesh);
            StaticAttachment.SetLightingChannels(KFP.PawnLightingChannel);
            AttachmentSocket = KFP.Mesh.GetSocketByName(CharAttachmentSocketName);
            KFP.Mesh.AttachComponent(StaticAttachment, AttachmentSocket.BoneName, AttachmentSocket.RelativeLocation + AttachmentLocationRelativeToSocket, AttachmentSocket.RelativeRotation + AttachmentRotationRelativeToSocket, AttachmentSocket.RelativeScale * AttachmentScaleRelativeToSocket);
        }
        KFP.ThirdPersonAttachmentBitMask = KFP.ThirdPersonAttachmentBitMask | (1 << AttachmentSlotIndex);
        KFP.ThirdPersonAttachmentSocketNames[AttachmentSlotIndex] = CharAttachmentSocketName;
        SetAttachmentSkinMaterial(AttachmentSlotIndex, CosmeticVariants[CurrentAttachmentMeshIndex], CurrentAttachmentSkinIndex, KFP);
    }
    if(CurrentAttachmentMeshIndex == 255)
    {
        RemoveAttachmentMeshAndSkin(AttachmentSlotIndex, KFP, KFPRI);
    }
}

function DetachConflictingAttachments(byte NewAttachmentMeshIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local name NewAttachmentSocketName;
    local int I, CurrentAttachmentIdx;

    if((CosmeticVariants.Length > 0) && NewAttachmentMeshIndex < CosmeticVariants.Length)
    {
        NewAttachmentSocketName = CosmeticVariants[NewAttachmentMeshIndex].SocketName;
        I = 0;
        J0x6A:

        if(I < 3)
        {
            CurrentAttachmentIdx = KFPRI.RepCustomizationInfo.AttachmentMeshIndices[I];
            if(CurrentAttachmentIdx == 255)
            {                
            }
            else
            {
                if((KFP.ThirdPersonAttachmentSocketNames[I] != 'None') && KFP.ThirdPersonAttachmentSocketNames[I] == NewAttachmentSocketName)
                {
                    RemoveAttachmentMeshAndSkin(I, KFP, KFPRI);                    
                }
                else
                {
                    if(GetOverrideCase(byte(CurrentAttachmentIdx), NewAttachmentMeshIndex))
                    {
                        RemoveAttachmentMeshAndSkin(I, KFP, KFPRI);                        
                    }
                    else
                    {
                        if(GetOverrideCase(NewAttachmentMeshIndex, byte(CurrentAttachmentIdx)))
                        {
                            RemoveAttachmentMeshAndSkin(I, KFP, KFPRI);                            
                        }
                    }
                }
            }
            ++ I;
            goto J0x6A;
        }
    }
}

function bool GetOverrideCase(byte AttachmentIndex1, byte AttachmentIndex2)
{
    if(CosmeticVariants[AttachmentIndex2].OverrideList.SpecialOverrideIds.Find(AttachmentIndex1 != -1)
    {
        return true;
    }
    switch(CosmeticVariants[AttachmentIndex1].SocketName)
    {
        case 'Hat_Attach':
            return CosmeticVariants[AttachmentIndex2].OverrideList.bHat;
        case 'Face_Attach':
            return CosmeticVariants[AttachmentIndex2].OverrideList.bFace;
        case 'Eyes_Attach':
            return CosmeticVariants[AttachmentIndex2].OverrideList.bEyes;
        case 'Jaw_Attach':
            return CosmeticVariants[AttachmentIndex2].OverrideList.bJaw;
        default:
            return false;
            break;
    }
}

function int GetAttachmentSlotIndex(byte CurrentAttachmentMeshIndex, KFPawn KFP)
{
    local int AttachmentIdx;

    AttachmentIdx = 0;
    J0x0B:

    if(AttachmentIdx < 3)
    {
        if((KFP.ThirdPersonAttachmentBitMask & (1 << AttachmentIdx)) == 0)
        {
            return AttachmentIdx;
        }
        ++ AttachmentIdx;
        goto J0x0B;
    }
}

simulated function RemoveAttachmentMeshAndSkin(int PawnAttachmentIndex, KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    DetachAttachment(PawnAttachmentIndex, KFP);
    if(KFPRI != none)
    {
        KFPRI.ClearCharacterAttachment(PawnAttachmentIndex);
    }
}

function DetachAttachment(int PawnAttachmentIndex, KFPawn KFP)
{
    if(KFP.ThirdPersonAttachments[PawnAttachmentIndex] != none)
    {
        if(SkeletalMeshComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]) != none)
        {
            KFP.DetachComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]);            
        }
        else
        {
            KFP.Mesh.DetachComponent(KFP.ThirdPersonAttachments[PawnAttachmentIndex]);
        }
    }
    KFP.ThirdPersonAttachmentBitMask = KFP.ThirdPersonAttachmentBitMask & ~1 << PawnAttachmentIndex;
    KFP.ThirdPersonAttachmentSocketNames[PawnAttachmentIndex] = 'None';
}

simulated function SetFirstPersonArmsFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    if(KFPRI == none)
    {
        WarnInternal("Does not have a KFPRI" @ string(self));
        return;
    }
    SetArmsMeshAndSkin(KFPRI.RepCustomizationInfo.BodyMeshIndex, KFPRI.RepCustomizationInfo.BodySkinIndex, KFP);
}

simulated function SetArmsMeshAndSkin(byte ArmsMeshIndex, byte ArmsSkinIndex, KFPawn KFP)
{
    local byte CurrentArmMeshIndex, CurrentArmSkinIndex;
    local string CharArmMeshName;
    local SkeletalMesh CharArmMesh;

    if(((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.IsHumanControlled()) && KFP.IsLocallyControlled())
    {
        if(CharacterArmVariants.Length > 0)
        {
            CurrentArmMeshIndex = ((ArmsMeshIndex < CharacterArmVariants.Length) ? ArmsMeshIndex : 0);
            CharArmMeshName = CharacterArmVariants[CurrentArmMeshIndex].MeshName;
            CharArmMesh = SkeletalMesh(DynamicLoadObject(CharArmMeshName, Class'SkeletalMesh'));
            KFP.ArmsMesh.SetSkeletalMesh(CharArmMesh);
            if(CharacterArmVariants[CurrentArmMeshIndex].SkinVariants.Length > 0)
            {
                CurrentArmSkinIndex = ((ArmsSkinIndex < CharacterArmVariants[CurrentArmMeshIndex].SkinVariants.Length) ? ArmsSkinIndex : 0);
                KFP.ArmsMesh.SetMaterial(0, CharacterArmVariants[CurrentArmMeshIndex].SkinVariants[CurrentArmSkinIndex]);                
            }
            else
            {
                KFP.ArmsMesh.SetMaterial(0, none);
            }            
        }
        else
        {
            if(ArmMesh != none)
            {
                KFP.ArmsMesh.SetMaterial(0, none);
                KFP.ArmsMesh.SetSkeletalMesh(ArmMesh);                
            }
            else
            {
                WarnInternal("Character does not have a valid arms mesh");
            }
        }
    }
}
