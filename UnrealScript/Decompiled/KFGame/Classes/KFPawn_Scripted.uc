/*******************************************************************************
 * KFPawn_Scripted generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_Scripted extends KFPawn
    native(Pawn)
    config(Game)
    hidecategories(Navigation)
    implements(KFInterface_TriggerOwner);

var const localized string ScriptedPawnString;
var repnotify KFCharacterInfo_ScriptedPawn ScriptedCharArchTemplate;
var KFCharacterInfo_ScriptedPawn ScriptedCharArch;
var bool bCanCurrentlyBeTargetedByZeds;
var transient bool bZedInProximity;
var transient bool bPlayerInProximity;
var repnotify transient bool bActive;
var transient bool bStartInactive;
/** Whether to block PCs */
var() bool bBlockPlayers<DisplayName=Block Human Players>;
/** Whether to block PC controlled zeds (team == 255) */
var() bool bBlockZedPlayers<DisplayName=Block Zed Players>;
/** Whether to block AI Zeds */
var() bool bBlockMonsters<DisplayName=Block AI>;
/** Whether to block anything when at zero health or marked dead */
var() bool bBlockInStoppedState<DisplayName=Block When In Stopped State>;
var bool bIsInStoppedState;
var repnotify transient KFWeldableComponent WeldableComponent;
var repnotify transient KFWeldableTrigger WeldableTrigger;
var transient KFTrigger_NotifyOwner ZedProximityTrigger;
var transient KFTrigger_NotifyOwner PlayerProximityTrigger;
var repnotify byte CurrentState;
var byte PreviousState;
var string IconPath;
var KFDoorActor BlockingDoor;
var float SpeedScalarForObstacles;
var array<ExtraVFXInfo> ScriptedStateVFX;
var float RecentDamageTimerLength;
var MaterialInterface DefaultMaterial;
var delegate<Delegate_OnReachedRouteMarker> __Delegate_OnReachedRouteMarker__Delegate;
var delegate<Delegate_OnEndedRoute> __Delegate_OnEndedRoute__Delegate;
var delegate<Delegate_OnTakeDamage> __Delegate_OnTakeDamage__Delegate;
var delegate<Delegate_OnHealDamage> __Delegate_OnHealDamage__Delegate;
var delegate<Delegate_OnChangeState> __Delegate_OnChangeState__Delegate;

replication
{
     if(bNetDirty)
        CurrentState, ScriptedCharArchTemplate, 
        WeldableComponent, WeldableTrigger, 
        bActive;
}

delegate Delegate_OnReachedRouteMarker(int MarkerIdx, SplineActor Marker, int SubIdx, float DistSinceLastMarker);

delegate Delegate_OnEndedRoute(bool bSuccess);

delegate Delegate_OnTakeDamage(int Damage);

delegate Delegate_OnHealDamage(int HealAmount);

delegate Delegate_OnChangeState(int CurrState, int PrevState);

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'ScriptedCharArchTemplate':
            SetCharacterArch(ScriptedCharArchTemplate, true);
            InitializeWeldableComponent();
            break;
        case 'WeldableComponent':
            InitializeWeldableComponent();
            break;
        case 'WeldableTrigger':
            InitializeWeldableTrigger();
            break;
        case 'CurrentState':
            SetPawnState(CurrentState);
            break;
        case 'bActive':
            SetActive(bActive);
            break;
        default:
            super.ReplicatedEvent(VarName);
            break;
            break;
    }
}

function Initialize(KFCharacterInfo_ScriptedPawn InCharInfo, int InHealth, int InHealthMax)
{
    local int I;

    if(Role < ROLE_Authority)
    {
        return;
    }
    SetCharacterArch(InCharInfo, true);
    if(ScriptedCharArch.bDisableCollisionOnStart)
    {
        SetCollision(false, false);
    }
    Health = Clamp(InHealth, 1, InHealthMax);
    HealthMax = InHealthMax;
    if(ScriptedCharArch.bPawnCanBeWelded || ScriptedCharArch.bPawnCanBeUnwelded)
    {
        InitializeWeldable();
    }
    if(!ScriptedCharArch.bPawnCanBeKilled)
    {
        I = 0;
        J0x103:

        if(I < ScriptedCharArch.States.Length)
        {
            ScriptedCharArch.States[I].HealthPctThreshold = FMax(ScriptedCharArch.States[I].HealthPctThreshold, 1.1 / float(HealthMax));
            ++ I;
            goto J0x103;
        }
    }
    if(ScriptedCharArch.bUseZedProximityTrigger || ScriptedCharArch.bUsePlayerProximityTrigger)
    {
        InitializeProximityTriggers();
    }
    DefaultMaterial = Mesh.GetMaterial(0);
    SetPawnState(0);
    UpdatePawnState();
    SetCanBeTargeted(false);
    if(ScriptedCharArch.bIsFlyingPawn)
    {
        SetPhysics(4);
        bCollideWorld = false;        
    }
    else
    {
        SetPhysics(1);
        bCollideWorld = true;
    }
}

function InitializeWeldable()
{
    WeldableComponent = Spawn(Class'KFWeldableComponent', self);
    InitializeWeldableComponent();
    WeldableTrigger = Spawn(Class'KFWeldableTrigger', self);
    InitializeWeldableTrigger();
    WeldableTrigger.SetCollision(false, false);
    UpdateWeldIntegrity();
}

simulated function InitializeWeldableComponent()
{
    local float WeldCompRadius, WeldCompHeight;
    local KFGameReplicationInfo KFGRI;

    if((ScriptedCharArch != none) && WeldableComponent != none)
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        WeldableComponent.SetOwner(self);
        WeldableComponent.SetBase(self);
        WeldableComponent.MaxWeldIntegrity = int(ScriptedCharArch.PawnMaxWeldIntegrityPerPlayer[KFGRI.GetNumPlayers() - 1]);
        if(Role == ROLE_Authority)
        {
            WeldableComponent.WeldIntegrity = WeldableComponent.MaxWeldIntegrity;
        }
        WeldableComponent.bWeldable = ScriptedCharArch.bPawnCanBeWelded;
        WeldableComponent.bUnweldable = ScriptedCharArch.bPawnCanBeUnwelded;
        WeldableComponent.__Delegate_OnWeldIntegrityChanged__Delegate = OnWelded;
        WeldCompRadius = WeldableComponent.GetCollisionCylinderRadius();
        WeldCompHeight = WeldableComponent.GetCollisionCylinderHeight();
        WeldableComponent.SetCollisionCylinderSize(WeldCompRadius * ScriptedCharArch.PawnWeldableComponentScale, WeldCompHeight);
        WeldableComponent.SetCollision(bActive, false);
    }
}

simulated function InitializeWeldableTrigger()
{
    if(WeldableTrigger != none)
    {
        WeldableTrigger.SetOwner(self);
        WeldableTrigger.SetBase(self);
        WeldableTrigger.WeldableComponent = WeldableComponent;
    }
}

simulated function InitializeProximityTriggers()
{
    local float TrigRadius, TrigHeight;

    PlayerProximityTrigger = Spawn(Class'KFTrigger_NotifyOwner', self);
    PlayerProximityTrigger.SetOwner(self);
    PlayerProximityTrigger.SetBase(self);
    TrigRadius = CylinderComponent(PlayerProximityTrigger.CollisionComponent).CollisionRadius;
    TrigHeight = CylinderComponent(PlayerProximityTrigger.CollisionComponent).CollisionHeight;
    CylinderComponent(PlayerProximityTrigger.CollisionComponent).SetCylinderSize(TrigRadius * ScriptedCharArch.PlayerProximityTriggerScale, TrigHeight);
    ZedProximityTrigger = Spawn(Class'KFTrigger_NotifyOwner', self);
    ZedProximityTrigger.SetOwner(self);
    ZedProximityTrigger.SetBase(self);
    TrigRadius = CylinderComponent(ZedProximityTrigger.CollisionComponent).CollisionRadius;
    TrigHeight = CylinderComponent(ZedProximityTrigger.CollisionComponent).CollisionHeight;
    CylinderComponent(ZedProximityTrigger.CollisionComponent).SetCylinderSize(TrigRadius * ScriptedCharArch.ZedProximityTriggerScale, TrigHeight);
}

simulated function OnWelded(int Amount, KFPawn Welder)
{
    local float WeldAmountPct, HealAmount;

    if((Role == ROLE_Authority) && WeldableComponent != none)
    {
        WeldAmountPct = float(Amount) / float(WeldableComponent.MaxWeldIntegrity);
        HealAmount = WeldAmountPct * float(HealthMax);
        Health += int(HealAmount);
        UpdateWeldIntegrity();
        UpdatePawnState(1);
        if(__Delegate_OnHealDamage__Delegate != none)
        {
            Delegate_OnHealDamage(int(HealAmount));
        }
    }
}

simulated function UpdateWeldIntegrity()
{
    if((Role == ROLE_Authority) && WeldableComponent != none)
    {
        WeldableComponent.SetWeldIntegrity(int((float(Health) / float(HealthMax)) * float(WeldableComponent.MaxWeldIntegrity)));
    }
}

simulated function SetEscortPawnOnHud()
{
    local KFPlayerController KFPC;

    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if((KFPC.myGfxHUD != none) && KFPC.myGfxHUD.bossHealthBar != none)
        {
            KFPC.myGfxHUD.bossHealthBar.SetEscortPawn(self);
        }        
    }    
}

simulated function RemoveEscortPawnOnHud()
{
    local KFPlayerController KFPC;

    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if((KFPC.myGfxHUD != none) && KFPC.myGfxHUD.bossHealthBar != none)
        {
            KFPC.myGfxHUD.bossHealthBar.DeActivate();
        }        
    }    
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super.PossessedBy(C, bVehicleTransition);
    if(KFAIController(C) != none)
    {
        MyKFAIC = KFAIController(C);
    }
    KFGameInfo(WorldInfo.Game).Teams[0].AddToTeam(C);
}

simulated event byte ScriptGetTeamNum()
{
    return 0;
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    if(((InstigatedBy.GetTeamNum() == GetTeamNum()) || !bCanCurrentlyBeTargetedByZeds) || !bActive)
    {
        InDamage = 0;        
    }
    else
    {
        super.AdjustDamage(InDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
        if((InDamage >= Health) && !ScriptedCharArch.bPawnCanBeKilled)
        {
            InDamage = Max(Health - 1, 0);
        }
    }
}

function Timer_RecentDamage();

function bool WasAttackedRecently()
{
    return IsTimerActive('Timer_RecentDamage');
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int OldHealth, actualDamage;

    OldHealth = Health;
    super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    actualDamage = OldHealth - Health;
    if(actualDamage > 0)
    {
        SetTimer(RecentDamageTimerLength, false, 'Timer_RecentDamage', self);
        if(WeldableComponent != none)
        {
            UpdateWeldIntegrity();
        }
        UpdatePawnState(-1);
        if(__Delegate_OnTakeDamage__Delegate != none)
        {
            Delegate_OnTakeDamage(actualDamage);
        }
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation, optional bool bUseHitImpulse)
{
    bUseHitImpulse = true;
    TryPlayHitReactionAnim(HitDirection, HitFxInfo.DamageType, HitFxInfo.HitBoneIndex);
}

simulated function bool TryPlayHitReactionAnim(Vector HitDirection, class<KFDamageType> DamageType, byte HitZoneIdx)
{
    local KFPawn.EPawnOctant AnimDir;
    local KFPawnAnimInfo.EHitReactionAnimType HitReactionType;
    local KFAfflictionManager.EHitZoneBodyPart BodyPart;
    local bool bOnlyAdditiveHits;

    if((DamageType == none) || ActorTimeSince(NextHitReactionAnim_ActorTime) < float(0))
    {
        return false;
    }
    if(IsDoingSpecialMove())
    {
        bOnlyAdditiveHits = true;
        if(!SpecialMoves[SpecialMove].bAllowHitReactions)
        {
            return false;
        }
    }
    BodyPart = (((HitZoneIdx != 255) && HitZoneIdx < HitZones.Length) ? HitZones[HitZoneIdx].Limb : 0);
    HitReactionType = 0;
    bOnlyAdditiveHits = bOnlyAdditiveHits || VSizeSq(Velocity) > 50;
    if(!bOnlyAdditiveHits)
    {
        HitReactionType = AfflictionHandler.GetPredictedHitReaction(DamageType, BodyPart);
    }
    switch(BodyPart)
    {
        case 2:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 4;                
            }
            else
            {
                AnimDir = 6;
            }
            break;
        case 3:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 5;                
            }
            else
            {
                AnimDir = 7;
            }
            break;
        default:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            break;
            break;
    }
    return PawnAnimInfo.PlayHitReactionAnim(self, HitReactionType, AnimDir);
}

simulated function bool CanBeHealed()
{
    return ScriptedCharArch.bPawnCanBeHealed;
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bRepairArmor, optional bool bMessageHealer)
{
    local bool Result;
    local int PrevHealth;

    bRepairArmor = true;
    bMessageHealer = true;
    if(!bActive || !ScriptedCharArch.bPawnCanBeHealed)
    {
        return false;
    }
    PrevHealth = Health;
    Result = super.HealDamage(Amount, Healer, DamageType, bRepairArmor, bMessageHealer);
    UpdateWeldIntegrity();
    UpdatePawnState(1);
    if(__Delegate_OnHealDamage__Delegate != none)
    {
        Delegate_OnHealDamage(Health - PrevHealth);
    }
    return Result;
}

function UpdatePawnState(optional int HealthDelta)
{
    local int I;
    local float HealthPct;

    HealthDelta = 0;
    HealthPct = float(Health) / float(HealthMax);
    if(HealthDelta > 0)
    {
        I = 0;
        J0x41:

        if(I < CurrentState)
        {
            if(HealthPct >= ScriptedCharArch.States[I].HealthPctThreshold)
            {
                goto J0xB4;
            }
            ++ I;
            goto J0x41;
        }
        J0xB4:
        
    }
    else
    {
        I = CurrentState;
        J0xCC:

        if(I < (ScriptedCharArch.States.Length - 1))
        {
            if(HealthPct >= ScriptedCharArch.States[I + 1].HealthPctThreshold)
            {
                goto J0x159;
            }
            ++ I;
            goto J0xCC;
        }
    }
    J0x159:

    SetPawnState(I);
}

simulated function SetPawnState(int InState)
{
    local int ExitTransitionType, EnterTransitionType;

    if((Role == ROLE_Authority) && InState == CurrentState)
    {
        return;
    }
    if(ScriptedCharArchTemplate != none)
    {
        if(CharacterArch == none)
        {
            SetCharacterArch(ScriptedCharArchTemplate, true);
        }
        if(Role == ROLE_Authority)
        {
            CurrentState = byte(InState);
            SetCanBeTargeted(ScriptedCharArch.States[InState].bCanBeTargetedByZeds);
        }
        if(CurrentState != PreviousState)
        {
            UpdatePawnSpeed();
            bIsInStoppedState = ScriptedCharArch.States[CurrentState].SpeedScalar <= 0;
            if(PreviousState < CurrentState)
            {
                ExitTransitionType = 1;
                EnterTransitionType = 2;                
            }
            else
            {
                if(PreviousState > CurrentState)
                {
                    ExitTransitionType = 2;
                    EnterTransitionType = 1;
                }
            }
            StopExtraVFX(name("EnterState" $ string(PreviousState)));
            PlayExtraVFX(name((("ExitState" $ string(PreviousState)) $ "-") $ string(ExitTransitionType)));
            PlayExtraVFX(name((("EnterState" $ string(CurrentState)) $ "-") $ string(EnterTransitionType)));
            PlayExtraVFX(name("ExitState" $ string(PreviousState)));
            PlayExtraVFX(name("EnterState" $ string(CurrentState)));
            CheckScriptedPawnMaterial();
            DoSpecialMove(43, true);
        }
        if(__Delegate_OnChangeState__Delegate != none)
        {
            Delegate_OnChangeState(CurrentState, PreviousState);
        }
        PreviousState = CurrentState;
    }
}

simulated function CheckScriptedPawnMaterial()
{
    if(bActive && ScriptedCharArch.States[CurrentState].HighlightedStateMaterial != none)
    {
        Mesh.SetMaterial(0, ScriptedCharArch.States[CurrentState].HighlightedStateMaterial);        
    }
    else
    {
        if(ScriptedCharArch.States[CurrentState].DefaultStateMaterial != none)
        {
            Mesh.SetMaterial(0, ScriptedCharArch.States[CurrentState].DefaultStateMaterial);            
        }
        else
        {
            Mesh.SetMaterial(0, DefaultMaterial);
        }
    }
}

function bool IsBlockedByZed()
{
    return ScriptedCharArch.bUseZedProximityTrigger && bZedInProximity;
}

function UpdatePawnSpeed()
{
    GroundSpeed = ScriptedCharArch.PawnSpeed * ScriptedCharArch.States[CurrentState].SpeedScalar;
    if(IsBlockedByZed())
    {
        GroundSpeed *= ScriptedCharArch.SpeedScalarForZedProximity;
    }
    if(ScriptedCharArch.bUsePlayerProximityTrigger && bPlayerInProximity)
    {
        GroundSpeed *= ScriptedCharArch.SpeedScalarForPlayerProximity;
    }
    GroundSpeed *= SpeedScalarForObstacles;
}

simulated function bool IsInCriticalCondition()
{
    return CurrentState == (ScriptedCharArch.States.Length - 1);
}

simulated function name GetStateTransitionAnim()
{
    if(CurrentState != PreviousState)
    {
        if(ScriptedCharArch.States[CurrentState].EnterAnim != 'None')
        {
            return ScriptedCharArch.States[CurrentState].EnterAnim;            
        }
        else
        {
            if((PreviousState != 255) && ScriptedCharArch.States[PreviousState].ExitAnim != 'None')
            {
                return ScriptedCharArch.States[PreviousState].ExitAnim;
            }
        }
    }
    return 'None';
}

simulated function SetCharacterArch(KFCharacterInfoBase Info, optional bool bForce)
{
    local int I, J;
    local ExtraVFXInfo FX;

    super.SetCharacterArch(Info, bForce);
    if(Role == ROLE_Authority)
    {
        ScriptedCharArchTemplate = KFCharacterInfo_ScriptedPawn(Info);
    }
    ScriptedCharArch = KFCharacterInfo_ScriptedPawn(CharacterArch);
    I = 0;
    J0x75:

    if(I < ScriptedCharArch.States.Length)
    {
        J = 0;
        J0xAD:

        if(J < ScriptedCharArch.States[I].EnterFX.Length)
        {
            FX.VFX = ScriptedCharArch.States[I].EnterFX[J].VFX;
            FX.SFXStartEvent = ScriptedCharArch.States[I].EnterFX[J].SFX;
            FX.SocketName = ScriptedCharArch.States[I].EnterFX[J].SocketName;
            FX.Label = name("EnterState" $ string(I));
            if(ScriptedCharArch.States[I].EnterFX[J].TransitionType != 0)
            {
                FX.Label = name((string(FX.Label) $ "-") $ string(ScriptedCharArch.States[I].EnterFX[J].TransitionType));
            }
            ScriptedStateVFX.AddItem(FX;
            ++ J;
            goto J0xAD;
        }
        J = 0;
        J0x3C0:

        if(J < ScriptedCharArch.States[I].ExitFX.Length)
        {
            FX.VFX = ScriptedCharArch.States[I].ExitFX[J].VFX;
            FX.SFXStartEvent = ScriptedCharArch.States[I].ExitFX[J].SFX;
            FX.SocketName = ScriptedCharArch.States[I].ExitFX[J].SocketName;
            FX.Label = name("ExitState" $ string(I));
            if(ScriptedCharArch.States[I].ExitFX[J].TransitionType != 0)
            {
                FX.Label = name((string(FX.Label) $ "-") $ string(ScriptedCharArch.States[I].ExitFX[J].TransitionType));
            }
            ScriptedStateVFX.AddItem(FX;
            ++ J;
            goto J0x3C0;
        }
        ++ I;
        goto J0x75;
    }
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local KFAIController KFAIC;

    KFAIC = KFAIController(Controller);
    if((KFAIC != none) && KFAIC.CommandList != none)
    {
        KFAIC.AbortCommand(KFAIC.CommandList);
    }
    return super.Died(Killer, DamageType, HitLocation);
}

function HandleMomentum(Vector Momentum, Vector HitLocation, class<DamageType> DamageType, optional TraceHitInfo HitInfo)
{
    if(ScriptedCharArch.bPawnHandlesMomentum)
    {
        super.HandleMomentum(Momentum, HitLocation, DamageType, HitInfo);
    }
}

function bool CanBeGrabbed(KFPawn GrabbingPawn, optional bool bIgnoreFalling, optional bool bAllowSameTeamGrab)
{
    return ScriptedCharArch.bPawnCanBeGrabbed;
}

event Landed(Vector HitNormal, Actor FloorActor)
{
    super.Landed(HitNormal, FloorActor);
    bCollideWorld = false;
}

function StartRoute(SplineActor SplineStart, SplineActor SplineEnd, int SegmentGranularity)
{
    Class'AICommand_ScriptedPawn_TraverseSpline'.static.TraverseSpline(MyKFAIC, SplineStart, SplineEnd, SegmentGranularity);
}

function ReachedRouteMarker(int MarkerIdx, SplineActor Marker, int SubIdx, float DistSinceLastMarker)
{
    if(__Delegate_OnReachedRouteMarker__Delegate != none)
    {
        Delegate_OnReachedRouteMarker(MarkerIdx, Marker, SubIdx, DistSinceLastMarker);
    }
}

function ReachedGoal()
{
    FinishSequence();
    Finish(false);
}

function EndedRoute(bool bSuccess)
{
    FinishSequence();
    if(bSuccess)
    {
        Finish(true);
    }
    if(__Delegate_OnEndedRoute__Delegate != none)
    {
        Delegate_OnEndedRoute(bSuccess);
    }
}

function FinishSequence()
{
    local int I;
    local Sequence GameSeq;
    local array<SequenceObject> AllPawnStartActions;

    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(Class'KFSeqAct_StartScriptedPawn', true, AllPawnStartActions);
        I = 0;
        J0x75:

        if(I < AllPawnStartActions.Length)
        {
            KFSeqAct_StartScriptedPawn(AllPawnStartActions[I]).CheckPawnFinished(self);
            ++ I;
            goto J0x75;
        }
        AllPawnStartActions.Length = 0;
        GameSeq.FindSeqObjectsByClass(Class'KFSeqAct_RestartScriptedPawn', true, AllPawnStartActions);
        I = 0;
        J0x117:

        if(I < AllPawnStartActions.Length)
        {
            KFSeqAct_RestartScriptedPawn(AllPawnStartActions[I]).CheckPawnFinished(self);
            ++ I;
            goto J0x117;
        }
    }
}

function Start()
{
    SetCollision(true, true);
    if(WeldableComponent != none)
    {
        WeldableComponent.SetCollision(bActive, false);
    }
    if(WeldableTrigger != none)
    {
        WeldableTrigger.SetCollision(bActive, false);
    }
    UpdatePawnState();
    if(bStartInactive)
    {
        SetActive(false);
    }
}

simulated function PlayFinishedSounds()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < ScriptedCharArch.FinishSoundEvents.Length)
    {
        PlaySoundBase(ScriptedCharArch.FinishSoundEvents[I], false, WorldInfo.NetMode == NM_DedicatedServer);
        ++ I;
        goto J0x0B;
    }
}

function Finish(bool bHide)
{
    if(ScriptedCharArch.bHideOnFinish)
    {
        if(bHide)
        {
            SetPhysics(0);
            SetHidden(true);
            PlayFinishedSounds();
        }
        SetCollision(false, false);        
    }
    else
    {
        if(bHide)
        {
            GroundSpeed = 0;
            Velocity = vect(0, 0, 0);
        }
    }
    DamageOverTimeArray.Length = 0;
    SetCanBeTargeted(false);
    if(WeldableComponent != none)
    {
        WeldableComponent.SetCollision(false, false);
    }
    if(WeldableTrigger != none)
    {
        WeldableTrigger.SetCollision(false, false);
    }
    SetActive(false);
}

simulated event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local Vector ToOther;

    if(KFPawn(Other) != none)
    {
        ToOther = Normal(Other.Location - Location);
        if((ToOther Dot HitNormal) < float(0))
        {
            KFPawn(Other).AddVelocity(HitNormal * -ScriptedCharArch.PawnBumpImpulse, vect(0, 0, 0), none);            
        }
    }
}

function bool CanAITargetThisPawn(Controller TargetingController)
{
    return bCanCurrentlyBeTargetedByZeds;
}

function SetCanBeTargeted(bool InCanBeTargeted)
{
    local bool bCouldPreviouslyBeTargetedByZeds;
    local KFPawn_Monster KFPM;

    bCouldPreviouslyBeTargetedByZeds = bCanCurrentlyBeTargetedByZeds;
    bCanCurrentlyBeTargetedByZeds = ((ScriptedCharArch != none) && ScriptedCharArch.States[CurrentState].bCanBeTargetedByZeds) && InCanBeTargeted;
    if(bCouldPreviouslyBeTargetedByZeds && !bCanCurrentlyBeTargetedByZeds)
    {
        foreach WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
        {
            if(KFPM.GetEnemy() == self)
            {
                KFAIController(KFPM.Controller).FindNewEnemy();
            }            
        }        
    }
}

simulated function Texture2D GetStateIconTexture()
{
    if(CurrentState == 255)
    {
        return none;
    }
    return ScriptedCharArch.States[CurrentState].Icon;
}

function NotifyTriggerTouch(KFTrigger_NotifyOwner Sender, Actor Toucher, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    local KFPawn_Monster Zed;
    local KFPawn_Human Player;

    if(Sender == ZedProximityTrigger)
    {
        if(ScriptedCharArch.bUseZedProximityTrigger)
        {
            Zed = KFPawn_Monster(Toucher);
            if(Zed != none)
            {
                bZedInProximity = true;
                if(bCanCurrentlyBeTargetedByZeds && KFAIController(Zed.Controller) != none)
                {
                    KFAIController(Zed.Controller).SetEnemy(self);
                }
            }
        }
        UpdatePawnSpeed();
    }
    if(Sender == PlayerProximityTrigger)
    {
        if(ScriptedCharArch.bUsePlayerProximityTrigger)
        {
            Player = KFPawn_Human(Toucher);
            if(Player != none)
            {
                bPlayerInProximity = true;
            }
        }
        UpdatePawnSpeed();
    }
}

function NotifyTriggerUnTouch(KFTrigger_NotifyOwner Sender, Actor UnToucher)
{
    local KFPawn_Monster Zed;
    local KFPawn_Human Player;

    if(Sender == ZedProximityTrigger)
    {
        if(ScriptedCharArch.bUseZedProximityTrigger)
        {
            Zed = KFPawn_Monster(UnToucher);
            if(Zed != none)
            {
                bZedInProximity = false;
                foreach ZedProximityTrigger.TouchingActors(Class'KFPawn_Monster', Zed)
                {
                    if(Zed != UnToucher)
                    {
                        bZedInProximity = true;
                        break;
                    }                    
                }                
            }
        }
        UpdatePawnSpeed();
    }
    if(Sender == PlayerProximityTrigger)
    {
        if(ScriptedCharArch.bUsePlayerProximityTrigger)
        {
            Player = KFPawn_Human(UnToucher);
            if(Player != none)
            {
                bPlayerInProximity = false;
                foreach PlayerProximityTrigger.TouchingActors(Class'KFPawn_Human', Player)
                {
                    if(Player != UnToucher)
                    {
                        bPlayerInProximity = true;
                        break;
                    }                    
                }                
            }
        }
        UpdatePawnSpeed();
    }
}

simulated function SetActive(bool Inactive)
{
    if(Role == ROLE_Authority)
    {
        if(bActive == Inactive)
        {
            return;
        }
        bActive = Inactive;
        SetCanBeTargeted(bActive);
        UpdateWeldIntegrity();
        UpdatePawnSpeed();
    }
    if(WeldableComponent != none)
    {
        WeldableComponent.SetCollision(bActive, false);
    }
    if(WeldableTrigger != none)
    {
        WeldableTrigger.SetCollision(bActive, false);
    }
    if(Inactive)
    {
        SetEscortPawnOnHud();        
    }
    else
    {
        RemoveEscortPawnOnHud();
    }
    CheckScriptedPawnMaterial();
}

simulated function bool ShouldShowOnHUD()
{
    return bActive;
}

simulated function float GetHealthPercent()
{
    return FClamp(float(Health) / float(HealthMax), 0, 1);
}

static function string GetLocalizedName()
{
    return default.ScriptedPawnString;
}

simulated function string GetIconPath()
{
    return IconPath;
}

simulated function StartDoorWait(KFDoorActor door)
{
    BlockingDoor = door;
    SpeedScalarForObstacles = 0;
    UpdatePawnSpeed();
    SetTimer(0.5, true, 'Timer_DoorWait', self);
}

simulated function PlayExtraVFX(name FXLabel)
{
    local int I;
    local ExtraVFXAttachmentInfo VFXAttachment;
    local bool bActivatedExistingSystem;

    if((WorldInfo.NetMode != NM_DedicatedServer) && FXLabel != 'None')
    {
        I = 0;
        J0x4D:

        if(I < ExtraVFXAttachments.Length)
        {
            if(ExtraVFXAttachments[I].Info.Label == FXLabel)
            {
                bActivatedExistingSystem = true;
            }
            ++ I;
            goto J0x4D;
        }
        if(!bActivatedExistingSystem)
        {
            I = 0;
            J0xE0:

            if(I < ScriptedStateVFX.Length)
            {
                if(ScriptedStateVFX[I].Label == FXLabel)
                {
                    VFXAttachment.VFXComponent = SpawnExtraVFX(ScriptedStateVFX[I]);
                    VFXAttachment.Info = ScriptedStateVFX[I];
                    ExtraVFXAttachments.AddItem(VFXAttachment;
                }
                ++ I;
                goto J0xE0;
            }
        }
    }
    super.PlayExtraVFX(FXLabel);
}

simulated function Timer_DoorWait()
{
    if(((BlockingDoor == none) || BlockingDoor.bIsDoorOpen) || BlockingDoor.bIsDestroyed)
    {
        BlockingDoor = none;
        SpeedScalarForObstacles = 1;
        UpdatePawnSpeed();
        ClearTimer('Timer_DoorWait', self);
    }
}

defaultproperties
{
    ScriptedPawnString="Escort"
    bBlockZedPlayers=true
    bBlockMonsters=true
    CurrentState=255
    PreviousState=255
    IconPath="ZED_Patriarch_UI.ZED-VS_Icon_Boss"
    SpeedScalarForObstacles=1
    RecentDamageTimerLength=5
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_Scripted.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    LeftFootBoneName=None
    RightFootBoneName=None
    LeftHandBoneName=None
    RightHandBoneName=None
    HeadBoneName=None
    TorsoBoneName=None
    PelvisBoneName=None
    AfflictionHandler=KFAfflictionManager'Default__KFPawn_Scripted.Afflictions'
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Scripted.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses(0)=none
        SpecialMoveClasses(1)=none
        SpecialMoveClasses(2)=none
        SpecialMoveClasses(3)=none
        SpecialMoveClasses(4)=none
        SpecialMoveClasses(5)=none
        SpecialMoveClasses(6)=none
        SpecialMoveClasses(7)=none
        SpecialMoveClasses(8)=none
        SpecialMoveClasses(9)=none
        SpecialMoveClasses(10)=none
        SpecialMoveClasses(11)=none
        SpecialMoveClasses(12)=none
        SpecialMoveClasses(13)=none
        SpecialMoveClasses(14)=none
        SpecialMoveClasses(15)=none
        SpecialMoveClasses(16)=none
        SpecialMoveClasses(17)=none
        SpecialMoveClasses(18)=none
        SpecialMoveClasses(19)=none
        SpecialMoveClasses(20)=none
        SpecialMoveClasses(21)=none
        SpecialMoveClasses(22)=none
        SpecialMoveClasses(23)=none
        SpecialMoveClasses(24)=none
        SpecialMoveClasses(25)=none
        SpecialMoveClasses(26)=none
        SpecialMoveClasses(27)=none
        SpecialMoveClasses(28)=none
        SpecialMoveClasses(29)=none
        SpecialMoveClasses(30)=none
        SpecialMoveClasses(31)=none
        SpecialMoveClasses(32)=none
        SpecialMoveClasses(33)=none
        SpecialMoveClasses(34)=none
        SpecialMoveClasses(35)=none
        SpecialMoveClasses(36)=none
        SpecialMoveClasses(37)=none
        SpecialMoveClasses(38)=none
        SpecialMoveClasses(39)=none
        SpecialMoveClasses(40)=none
        SpecialMoveClasses(41)=none
        SpecialMoveClasses(42)=none
        SpecialMoveClasses(43)=class'KFSM_PlaySingleAnim_ScriptedPawn'
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_Scripted.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_Scripted.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_Scripted.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_Scripted.WeaponAmbientEchoHandler'
    SecondaryWeaponAkComponent=AkComponent'Default__KFPawn_Scripted.SecondaryWeaponAkSoundComponent'
    FootstepAkComponent=AkComponent'Default__KFPawn_Scripted.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_Scripted.DialogAkSoundComponent'
    PowerUpAkComponent=AkComponent'Default__KFPawn_Scripted.PowerUpAkSoundComponent'
    AccelRate=0
    ControllerClass=Class'KFAIController_ScriptedPawn'
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Scripted.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=108
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Scripted.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_Scripted.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=108
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Scripted.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_Scripted.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Scripted.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_Scripted.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_Scripted.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_Scripted.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_Scripted.DialogAkSoundComponent'
    Components(8)=AkComponent'Default__KFPawn_Scripted.PowerUpAkSoundComponent'
    Components(9)=AkComponent'Default__KFPawn_Scripted.SecondaryWeaponAkSoundComponent'
    bAlwaysRelevant=true
    bCanBeAdheredTo=false
    bCanBeFrictionedTo=false
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=108
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Scripted.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}