/*******************************************************************************
 * KFPlayerReplicationInfoVersus generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPlayerReplicationInfoVersus extends KFPlayerReplicationInfo
    native(ReplicationInfo)
    nativereplication
    hidecategories(Navigation,Movement,Collision);

var PlayerController PlayerOwner;
var private Vector PawnLocationCompressed;
var private Vector LastReplicatedSmoothedLocation;

replication
{
     if(!bNetOwner && bNetDirty)
        PawnLocationCompressed;
}

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    if(Role == ROLE_Authority)
    {
        PlayerOwner = PlayerController(Owner);
    }
}

simulated function Pawn GetOwnerPawn()
{
    local Pawn aPawn;

    foreach WorldInfo.AllPawns(Class'Pawn', aPawn)
    {
        if(aPawn.PlayerReplicationInfo == self)
        {            
            return aPawn;
        }        
    }    
    return none;
}

function SetPlayerTeam(TeamInfo NewTeam)
{
    super(PlayerReplicationInfo).SetPlayerTeam(NewTeam);
    if(NewTeam == none)
    {
        return;
    }
    PlayerOwner = PlayerController(Owner);
    SetTimer(1, true, 'UpdateReplicatedVariables');
}

function UpdateReplicatedVariables()
{
    if((((!bIsSpectator && PlayerOwner != none) && PlayerOwner.GetTeamNum() == 0) && PlayerOwner.Pawn != none) && PlayerOwner.Pawn.IsAliveAndWell())
    {
        UpdatePawnLocation();        
    }
    else
    {
        if(!IsZero(PawnLocationCompressed))
        {
            PawnLocationCompressed = vect(0, 0, 0);
        }
    }
    UpdateReplicatedPlayerHealth();
}

function UpdatePawnLocation()
{
    PawnLocationCompressed = PlayerOwner.Pawn.Location;
    PawnLocationCompressed *= 0.01;
}

function UpdateReplicatedPlayerHealth()
{
    local Pawn OwnerPawn;

    if(PlayerOwner != none)
    {
        OwnerPawn = PlayerOwner.Pawn;
        if((OwnerPawn != none) && OwnerPawn.Health != PlayerHealth)
        {
            PlayerHealth = byte(OwnerPawn.Health);
            PlayerHealthPercent = FloatToByte(float(OwnerPawn.Health) / float(OwnerPawn.HealthMax));
        }
    }
}

function IncrementDeaths(optional int Amt)
{
    Amt = 1;
    super.IncrementDeaths(Amt);
    PawnLocationCompressed = vect(0, 0, 0);
}

simulated function Vector GetReplicatedPawnIconLocation(float BlendSpeed)
{
    local Vector UncompressedLocation;

    UncompressedLocation = PawnLocationCompressed * 100;
    if(((BlendSpeed > float(0)) && !IsZero(UncompressedLocation)) && VSizeSq(UncompressedLocation - LastReplicatedSmoothedLocation) < Square(500))
    {
        LastReplicatedSmoothedLocation = VInterpTo(LastReplicatedSmoothedLocation, UncompressedLocation, WorldInfo.DeltaSeconds, VSize(UncompressedLocation - LastReplicatedSmoothedLocation) * BlendSpeed);        
    }
    else
    {
        LastReplicatedSmoothedLocation = UncompressedLocation;
    }
    return LastReplicatedSmoothedLocation;
}

simulated function VOIPStatusChanged(PlayerReplicationInfo Talker, bool bIsTalking)
{
    if(Talker.GetTeamNum() != GetTeamNum())
    {
        return;
    }
    super.VOIPStatusChanged(Talker, bIsTalking);
}
