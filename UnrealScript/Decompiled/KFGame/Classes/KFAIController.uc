/*******************************************************************************
 * KFAIController generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController extends BaseAIController
    native(AI)
    config(AI)
    hidecategories(Navigation);

const LATENT_MOVETO = 501;

struct native sBlockedPathInfo
{
    var ReachSpec BlockedReachSpec;
    var NavigationPoint BlockedNav;
    var int BlockedCost;
    var float BlockedTime;

    structdefaultproperties
    {
        BlockedReachSpec=none
        BlockedNav=none
        BlockedCost=0
        BlockedTime=0
    }
};

struct native CooldownData
{
    var() name Tag;
    var() float ActivationTime;
    var() float Duration;

    structdefaultproperties
    {
        Tag=None
        ActivationTime=0
        Duration=0
    }
};

struct native InvalidAnchorItem
{
    /** Anchor that was invalid */
    var() NavigationPoint InvalidNav;
    /** Time of path search that invalidated the anchor */
    var() float InvalidTime;

    structdefaultproperties
    {
        InvalidNav=none
        InvalidTime=0
    }
};

struct native KFAICmdHistoryItem
{
    var class<AICommandBase> CmdClass;
    var string CmdName;
    var float TimeStamp;
    var float Duration;
    var bool bAborted;
    var bool bFailure;
    var bool bSuccess;
    var string VerboseString;

    structdefaultproperties
    {
        CmdClass=none
        CmdName=""
        TimeStamp=0
        Duration=0
        bAborted=false
        bFailure=false
        bSuccess=false
        VerboseString=""
    }
};

struct native DamageInfo
{
    var Controller DamagerController;
    var PlayerReplicationInfo DamagerPRI;
    var float Damage;
    var float TotalDamage;
    var float LastTimeDamaged;
    var array< class<KFPerk> > DamagePerks;

    structdefaultproperties
    {
        DamagerController=none
        DamagerPRI=none
        Damage=0
        TotalDamage=0
        LastTimeDamaged=0
        DamagePerks=none
    }
};

var bool bAllowScriptTeamCheck;
var bool bIdleMoveToNearestEnemy;
var bool bReachedMoveGoal;
var bool bReevaluatePath;
var bool bMovingToGoal;
var bool bMovingToEnemy;
var bool bDirectMoveToGoal;
var bool bMoveGoalInterruptable;
var bool bSkipRouteCacheUpdates;
var bool bFailedToMoveToEnemy;
var transient bool bAvoidChokePoints;
var bool bProbeNotifyOnAddToRouteCache;
var bool bPlannedJump;
var bool CachedLOSCheck;
var bool bIgnoreBlockedPathList;
var bool bShouldUsePathLanes;
var bool bShouldOffsetCorners;
var bool bAlwaysAcceptPartialPaths;
var bool bCanSprint;
var bool bCanSprintWhenDamaged;
var bool bSprintingDisabled;
var config bool bConfigShowMovePointsDebugInfo;
var bool bShowMovePointsDebugInfo;
var config bool bConfigShowHighDetailCombatMovementDebugInfo;
var bool bShowHighDetailCombatMovementDebugInfo;
var config bool bConfigShowVisualStuckZedDebugInfo;
var bool bShowVisualStuckZedDebugInfo;
var config bool bConfigShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
var bool bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
var bool bShowLeapDownDebugArtifacts;
var config bool bConfigShowLeapDownDebugArtifacts;
var bool bShowDoorNavigationDebugArtifacts;
var config bool bConfigShowDoorNavigationDebugArtifacts;
var bool bShowDestructibleNavigationDebugArtifacts;
var config bool bConfigShowDestructibleNavigationDebugArtifacts;
var bool bMindLeader;
var bool LastPathFailTime;
var bool IsRotationLocked;
var bool bSpawnedByEmergeSpecialMove;
var bool bUseTargetedByPlayerEvent;
var bool bBumpedThisFrame;
var config bool bDoNotBlockFriendlyAI;
var config bool bSuperSpeedDoNotBlockFriendlyAI;
var bool bSpecialBumpHandling;
var bool bTryingToGetUnstuck;
var bool bCanTeleportCloser;
var bool bIgnoreStepAside;
var bool bCanStrikeThroughEnemies;
var bool bIsBodyBlocked;
var bool bEnemyIsVisible;
var transient bool bIsVisibleToEnemy;
var transient bool bWasVisibleToEnemy;
var bool bUseDesiredRotationForMelee;
var bool bIamAsClosesToTheEnemyAsICanGet;
/** Force frustration on, regardless of frustration threshold settings */
var(Frustration) bool bForceFrustration;
var transient bool bDefaultCanSprint;
var const bool bCanDoHeavyBump;
var bool bAllowCombatTransitions;
var bool bIsProbingMeleeRangeEvents;
var bool bDebug_DrawAIDebug;
var config bool bDebug_DrawAnchor;
var config bool bDebug_ShowPreparingMove;
var config bool bDebug_ShowStrikeRange;
var config bool bDebug_ShowAllStrikeRange;
var config bool bDebug_LogToProfiler;
var config bool bDebug_DrawPath;
var config bool bDebug_DrawOverheadInfo;
var config bool bUseUniqueAILogFile;
var config bool bDebug_PostRenderInfo;
var config bool bDebug_DrawSeparationSteering;
var bool bHasDebugCommand;
var bool bForceDebugCommand;
var config bool bDebug_DrawAttackAnimInfo;
var config bool bDebug_ShowViewCone;
var bool bDisablePartialPaths;
var config bool bDebugCommandHistory;
var bool bDumpCommandHistoryOnExit;
var bool bDumpedCommandHistory;
var transient KFGameInfo MyKFGameInfo;
var transient KFPawn_Monster MyKFPawn;
var transient KFAIDirector MyAIDirector;
var export editinline KFAISteering Steering;
var class<AICommand> DefaultCommandClass;
var class<AICommand> MeleeCommandClass;
var Actor IntermediateMoveGoal;
var int FailedMoveToEnemyCount;
var float MoveOffset;
var Actor MoveGoal;
var BasedPosition MovePosition;
var Actor MoveFocus;
var float LastDetourCheckTime;
var float LastObstructionTime;
var float LastSprintChangeTime;
var Rotator LockedRotation;
var AICommand CachedAICommandList;
var transient float NextDirectPathCheckTime;
var float DirectPathCheckFrequency_Min;
var float DirectPathCheckFrequency_Max;
var float DirectPathExtentModifier;
var Vector2D SprintWithinEnemyRange;
var float RotationRateMultiplier;
var KFDoorActor PendingDoor;
var float LastLOSCheckTime;
var float MinTimeBetweenLOSChecks;
var KFPathnode BlockedPath;
var float MaxBlockedPathDuration;
var config Color PathNodeShowRouteCacheColor;
var config Vector PathNodeShowRouteCacheCrossOffset;
var config float PathNodeShowRouteCacheCrossSize;
var config Vector PathNodeShowRouteCacheNumberLabelOffset;
var config float PathNodeShowRouteCacheNumberLabelDuration;
var AIPluginMovement KfMovementPlugin;
var AIPluginLeap KfLeapPlugin;
var AIPluginStuckFix KfStuckFixPlugin;
var AIPluginMovement KfWallWalkingPlugIn;
var KFAiBehaviorTypes.MOVEMENT_PHASE_TYPE CurrentMovementPhase;
var KFAiBehaviorTypes.MOVE_FAILURE_TYPE TypeOfMovementStuckOn;
var byte PendingAnimStrikeIndex;
/** The minimum number of zeds remaining before frustration mode (sprint) is activated */
var(Frustration) byte FrustrationThreshold;
var byte CurrentEnemysHistoryIndex;
var byte DebugCurrentStrikeIndex;
var config Color Move_failure_type_none_color;
var config Color Move_failure_type_no_nav_mesh_path_color;
var config Color Move_failure_type_same_intermediate_point_too_many_times_color;
var config Color MoveFailureTypeTargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTo;
var float DefaultMaxTimeAllowedToStayStuckBeforeSuicide;
var float NoNavMeshPathMaxTimeAllowedToStayStuckBeforeSuicide;
var float SameIntermediatePointToManyTimesMaxTimeAllowedToStayStuckBeforeSuicide;
var float TargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTooMaxTimeAllowedToStayStuckBeforeSuicide;
var float SameIntermediatePointToManyTimesDurationAfterStartedMovingAgaintToStopStuckCheck;
var float DefaultMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;
var float NoNavMeshPathMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;
var float SameIntermediatePointToManyTimesMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;
var Texture2D MovementPhaseTypePathNodeNormalMoveToIcon;
var Texture2D MovementPhaseTypePathNodeMoveFailedIcon;
var Texture2D MovementPhaseTypePathNodeMoveToPointIcon;
var Texture2D MovementPhaseTypePathNodeRotateToFocusIcon;
var Texture2D MovementPhaseTypePathNodeDelayMoveIcon;
var Texture2D MovementPhaseTypeUnknownIcon;
var Texture2D MovementPhaseTypeNavMeshNormalMoveToIcon;
var Texture2D MovementPhaseTypeFinalDestMoveTowardsIcon;
var Texture2D MovementPhaseTypeEMT_LOS_MoveTowardsIcon;
var Texture2D MovementPhaseTypeMovingToNavMeshUsingPathNodesIcon;
var Texture2D MovementPhaseTypeFALLBACK_REFUSED_TO_BE_EXPLOTIED_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;
var Texture2D MovementPhaseTypeFALLBACK_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;
var Texture2D TypeOfMovementStuckOnUnknownWhyIcon;
var Texture2D TypeOfMovementStuckOnMOVE_FAILURE_TYPE_NO_NAV_MESH_PATHIcon;
var Texture2D TypeOfMovementStuckOnMOVE_FAILURE_TYPE_SAME_INTERMEDIATE_POINT_TOO_MANY_TIMESIcon;
var Texture2D TypeOfMovementStuckOnMOVE_FAILURE_TYPE_TARGET_OFF_NAV_MESH_AND_CAN_NOT_FIND_LOCAITON_NEAR_THEM_I_CAN_MOVE_TOIcon;
var Texture2D TypeOfMovementStuckOnLookingForBetterIntermediateLoc;
var Texture2D TypeOfMovementStuckOnMoveToBetterIntermediate;
var config Color ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff;
var config Color ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn;
var float DistanceToCheckForClearPathOnNavMeshLocWhenOffNavMesh;
var float DistanceToCheckForNonExploitedOnNavMeshLocWhenOffNavMesh;
var float DistanceToCheckForNonExploitedOnNavMeshLocWhenOnDeadEndOfNavMesh;
var config Color DefaultColorOfValidLocationWhenLookingForLocationsOnNavMesh;
var config Color DefaultColorOfSearchSphereWhenNoValidLocationsFoundWhenLookingForLocationsOnNavMesh;
var config Color ColorOfValidLocationFoundFor1stTryLookingForLocationsOnNavMesh;
var config Color ColorOfSearchSphereWhenNoValidLocationsFoundFor1stTryLookingForLocationsOnNavMesh;
var config Color ColorOfValidLocationFoundFor2ndTryLookingForLocationsOnNavMesh;
var config Color ColorOfSearchSphereWhenNoValidLocationsFoundFor2ndTryLookingForLocationsOnNavMesh;
var config Color ColorOfValidLocationFoundFor3rdTryLookingForLocationsOnNavMesh;
var config Color ColorOfSearchSphereWhenNoValidLocationsFoundFor3rdTryLookingForLocationsOnNavMesh;
var config Color ColorOfValidLocationFoundForLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh;
var config Color ColorOfSearchSphereWhenNoValidLocationsFoundForTryLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh;
var float DistanceToCheckForClearPathOnNavMeshLocWhenEnemyIsOffNavMesh;
var float DistanceToCheckForNonExploitedOnNavMeshLocWhenEnemyIsOffNavMesh;
var float GeneralGoalDistanceForMovingToDoor;
var float RecastEnemyRepathDistance;
var Vector DropEdgeLeapVelocity;
var float MaxRangeToDropEdgeAllowedToLeadFrom;
var float DistanceDownRangeToFocusForDropEdgeLeap;
var config float TimeToShowEdgeTypeForNavMeshPathting;
var Vector LastLeaderPosOffset;
var float LastNotifyHitWallTime;
var Actor LastHitWall;
var Vector LastWallHitNormal;
var int HitWallCount;
var array<sBlockedPathInfo> BlockedPathList;
var KFPawn LastBumper;
var float CurBumpVal;
var float BumpThreshold;
var float BumpDecayRate;
var float BumpGrowthRate;
var float LastStuckCheckTime;
var float TotalStuckCheckCloseRangeTime;
var float LastStuckCheckCloseRangeTime;
/** How often to check and see if this AI is stuck */
var(StuckChecking) float StuckCheckInterval;
/** How slow a zed needs to be moving (squared) in the X/Y access to be considered possibly stuck */
var(StuckChecking) float StuckVelocityThreshholdSquared;
var float StuckPossiblity;
/** The threshold to actually consider this zed stuck when it thinks it might be */
var(StuckChecking) float StuckPossiblityThreshhold;
var float LastStuckTime;
var float LastTeleportCheckTime;
var float LastTeleportTime;
/** How often to check and see if this AI can relocate teleport */
var(Teleport) float TeleportCheckInterval;
/** How long to wait after teleporting to be able to teleport again */
var(Teleport) float TeleportCooldown;
/** How long this zed must be hidden before it can relocate teleport. Must be at least 5, because hidden checks can be delayed as much as 5 seconds */
var(Teleport) float HiddenRelocateTeleportThreshold;
/** How long this zed must ahve been alive before it can relocate teleport. */
var(Teleport) float PostSpawnRelocateTeleportCooldown;
var Vector LastTeleportLocation;
var float LastSpecialMoveEndTime;
var Vector LastStuckCheckLocation;
var float XYMoveStuckThresholdSquared;
var float ZMoveStuckThresholdSquared;
var float StuckCheckEnemyDistThreshholdSquared;
var float NavigationBumpTeamCollisionThreshholdSquared;
var float FallingStuckNoZVelocityTime;
var Pawn StepAsideGoal;
var float MaxStepAsideDist;
var float LastFailedToFindStepAsideLocation;
var Pawn LastBumpedPawn;
var float LastBumpTime;
var float AttackRange;
var float StrikeRange;
var float StrikeRangePercentage;
var float DoorMeleeDistance;
var float MaxMeleeHeightAngle;
var float LastAttackTime_Melee;
var float LastMeleeAttackDecisionTime;
var float LastSelectEnemyTime;
var float LastSetEnemyTime;
var float MinTimeBetweenStatusUpdates;
var float MaxTimeBetweenStatusUPdates;
var float LastMoveFinishTime;
var float MinTimeBetweenEnemyChanges;
var Actor ActorEnemy;
var KFDoorActor DoorEnemy;
var KFPawn MeleeTarget;
var float EnemyVisibilityTime;
var Pawn CachedVisibleEnemy;
var Projectile PendingEvadeProjectile;
var float EvadeGrenadeChance;
var float LastGetStrikeTime;
var const float MaxGetStrikeTime;
/** The amount of time to delay zeds from entering frustration mode after it's first detected */
var(Frustration) float FrustrationDelay;
var float LastFrustrationCheckTime;
var float GoalDistanceWhenMovingToLocationForMeleeStrikeWhenEnemyIsOffNavMesh;
var array<CooldownData> CooldownTimers;
/** Store info for an overall attack cooldown timer so we can throttle all attacks by this zed in certain circumstances */
var() CooldownData OverallAttackCooldownTimer;
/** Attack cooldown time to use when throttling all attacks by this zed in certain circumstances */
var() float LowIntensityAttackCooldown;
var KFAiDirectProjectileFireBehavior DirectProjectileFireBehavior;
var KFAiLeapBehavior LeapBehavior;
var const Vector BaseShapeOfProjectileForCalc;
var float LastShotTime;
var const int ZedBumpEffectThreshold;
var const float ZedBumpObliterationEffectChance;
var const float AggroPlayerHealthPercentage;
var const float AggroPlayerResetTime;
var float MinDistanceToAggroZed;
var const float AggroZedResetTime;
var const float AggroZedHealthPercentage;
var float LastTauntTime;
var float RepeatWalkingTauntTime;
var float NextTauntTime;
var float NextRandomTauntTime;
var config float TauntTeamFactor;
var config Vector2D TauntTimeDelay;
var config Vector2D RandomTauntTimeDelay;
var transient array<InvalidAnchorItem> InvalidAnchorList;
var float TimeFirstSawPlayer;
var Vector ChargeLocation;
var string RecentActionInfo;
var Rotator Debug_StepRot;
var BasedPosition Debug_StepLoc;
var KFPawn ChargeTarget;
var string AIActionStatus;
var config Color Debug_TextColorOverride;
var array<name> EnabledDebugTextCategories;
var KFSpawnVolume MySpawnVolume;
var Vector LocationAtStartOfStuckCheck;
var Vector LocationAtLastStuckCheck;
var AICommand CmdTriggeringHardCoreStuckChecking;
var AITickablePlugin PlugInTriggeringTriggeringHardCoreStuckChecking;
var array<KFAICmdHistoryItem> KFAICommandHistory;
var array<DamageInfo> DamageHistory;

// Export UKFAIController::execBumperSomewhereToGo(FFrame&, void* const)
native function bool BumperSomewhereToGo();

// Export UKFAIController::execLineBlockedByActor(FFrame&, void* const)
native function bool LineBlockedByActor(Vector Start, Vector End, ReachSpec Spec, Actor Actor);

// Export UKFAIController::execIsPawnBlockingLine(FFrame&, void* const)
native function bool IsPawnBlockingLine(Vector Start, Vector End, optional float MinCollisionHeight);

// Export UKFAIController::execComputeTrajectoryByTime(FFrame&, void* const)
native function Vector ComputeTrajectoryByTime(Vector StartPosition, Vector EndPosition, float EndTime);

// Export UKFAIController::execCleanup(FFrame&, void* const)
native function Cleanup(optional bool bBeingDestroyed);

// Export UKFAIController::execAbortCommand(FFrame&, void* const)
native function bool AbortCommand(GameAICommand AbortCmd, optional class<GameAICommand> AbortClass);

// Export UKFAIController::execPushCommand(FFrame&, void* const)
native function PushCommand(GameAICommand NewCommand);

// Export UKFAIController::execPopCommand(FFrame&, void* const)
native function PopCommand(GameAICommand ToBePoppedCommand);

// Export UKFAIController::execIgnoreNotifies(FFrame&, void* const)
native function bool IgnoreNotifies();

// Export UKFAIController::execIsPawnMovingAwayFromMe(FFrame&, void* const)
native function bool IsPawnMovingAwayFromMe(Pawn CheckPawn, optional float MinSpeed);

// Export UKFAIController::execGetPawnBlockingPathTo(FFrame&, void* const)
native function KFPawn GetPawnBlockingPathTo(Pawn EnemyPawn, optional bool bTestTeam);

// Export UKFAIController::execLockPawnRotationTo(FFrame&, void* const)
native function LockPawnRotationTo(Rotator NewRotation);

// Export UKFAIController::execUnlockPawnRotation(FFrame&, void* const)
native function UnlockPawnRotation();

// Export UKFAIController::execIsFriendlyBlockingFireLine(FFrame&, void* const)
native final function bool IsFriendlyBlockingFireLine(Vector FireStart);

// Export UKFAIController::execCalcAimLocToHit(FFrame&, void* const)
native function Vector CalcAimLocToHit(Vector AimSpot, Vector StartFireLoc, float InSpeed, float inMaxSpeed, optional Vector LeadTargetVelocity);

// Export UKFAIController::execEstimateProjectileTimeToTarget(FFrame&, void* const)
native static function float EstimateProjectileTimeToTarget(float Distance, float StartSpeed, float MaxSpeed);

// Export UKFAIController::execFastActorTrace(FFrame&, void* const)
native function bool FastActorTrace(Vector TraceEnd, optional Vector TraceStart, optional Vector BoxExtent, optional bool bTraceComplex);

// Export UKFAIController::execTestTrace(FFrame&, void* const)
native function bool TestTrace(Vector TraceEnd, optional Vector TraceStart);

// Export UKFAIController::execIsPawnInFireLine(FFrame&, void* const)
native function bool IsPawnInFireLine(Pawn CheckPawn, Vector FireStart, Vector FireLine);

// Export UKFAIController::execSuggestNewWanderPoint(FFrame&, void* const)
native final function bool SuggestNewWanderPoint(out Vector out_NewMovePt, Vector TryThisDirFirst, optional float MoveDist)
{
    MoveDist = 1024;                    
}

// Export UKFAIController::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

// Export UKFAIController::execIsLookingAtWall(FFrame&, void* const)
protected native function bool IsLookingAtWall(optional float CheckDist)
{
    CheckDist = 768;            
}

// Export UKFAIController::execCleanUpOnDestroy(FFrame&, void* const)
native function CleanUpOnDestroy();

event SetChargeLocation(Actor Victim, Vector VictimLocation);

event TargetedByPlayer(KFPawn InPlayer);

event PostBeginPlay()
{
    super(Controller).PostBeginPlay();
    DirectProjectileFireBehavior = new (self) Class'KFAiDirectProjectileFireBehavior';
    DirectProjectileFireBehavior.MyAiCtrl = self;
    LeapBehavior = new (self) Class'KFAiLeapBehavior';
    LeapBehavior.MyAiCtrl = self;
    bIamAsClosesToTheEnemyAsICanGet = false;
    DirectProjectileFireBehavior.Setup();
    LeapBehavior.Setup();
    FrustrationDelay = RandRange(default.FrustrationDelay, default.FrustrationDelay * float(2));
}

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    local KFAIDirector Director;

    AILog_Internal((string(GetFuncName()) $ "() possessing pawn ") $ string(inPawn), 'AIController');
    super.Possess(inPawn, bVehicleTransition);
    Disable('SeePlayer');
    if(Steering != none)
    {
        InitSteering();
    }
    Pawn.bCanJump = true;
    Pawn.bCanWalkOffLedges = true;
    MyKFGameInfo = KFGameInfo(WorldInfo.Game);
    if(MyKFGameInfo != none)
    {
        Director = MyKFGameInfo.GetAIDirector();
        if(Director != none)
        {
            MyAIDirector = Director;
            MyAIDirector.NotifyNewPossess(self);
        }
    }
    BeginCombatCommand(none, "Possessed");
    SetTimer(RandRange(1, 3), false, 'StartSteering');
    SetTimer(RandRange(MinTimeBetweenStatusUpdates, MaxTimeBetweenStatusUPdates), false, 'Timer_EvaluateStatus', self);
    SetupDebug();
    if(((!bIsPlayer && MyKFGameInfo.bEnableGameAnalytics) && !bDeleteMe) && WorldInfo.NetMode != NM_Client)
    {
        InitPlayerReplicationInfo();
    }
    bShowVisualStuckZedDebugInfo = MyAIDirector.bShowVisualStuckZedDebugInfo;
    bShowMovePointsDebugInfo = MyAIDirector.bShowMovePointsDebugInfo;
    bShowHighDetailCombatMovementDebugInfo = MyAIDirector.bShowHighDetailCombatMovementDebugInfo;
    bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = MyAIDirector.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
    bShowLeapDownDebugArtifacts = MyAIDirector.bShowLeapDownDebugArtifacts;
    bShowDoorNavigationDebugArtifacts = MyAIDirector.bShowDoorNavigationDebugArtifacts;
    bShowDestructibleNavigationDebugArtifacts = MyAIDirector.bShowDestructibleNavigationDebugArtifacts;
    if(bUsePluginsForMovement)
    {
    }
    if((MyKFPawn != none) && MyKFPawn.PawnAnimInfo != none)
    {
        AttackRange = MyKFPawn.PawnAnimInfo.GetAttackRange(self);
    }
}

function UpdatePendingStrike()
{
    local KFPawnAnimInfo KFPAI;

    if((MyKFPawn == none) || MyKFPawn.PawnAnimInfo == none)
    {
        return;
    }
    DebugCurrentStrikeIndex = PendingAnimStrikeIndex;
    KFPAI = MyKFPawn.PawnAnimInfo;
    if(AttackRange == float(0))
    {
        AttackRange = KFPAI.GetAttackRange(self);
    }
    PendingAnimStrikeIndex = byte(KFPAI.ChooseNextStrike(MyKFPawn, Enemy));
    if(PendingAnimStrikeIndex == 255)
    {
        StrikeRange = 0;
        return;
    }
    UpdateStrikeRange();
    AILog_Internal(((string(GetFuncName()) $ "() using AttackRange of ") $ string(AttackRange)) $ " for attack polling.", 'Command_Attack_Melee');
    return;
}

function UpdateStrikeRange()
{
    local float CollisionRadius;

    if(PendingAnimStrikeIndex != 255)
    {
        CollisionRadius = MyKFPawn.CylinderComponent.CollisionRadius;
        StrikeRange = MyKFPawn.PawnAnimInfo.GetMedianStrikeRange(PendingAnimStrikeIndex, StrikeRangePercentage, CollisionRadius);
        AILog_Internal(((string(GetFuncName()) $ "() using StrikeRange of ") $ string(StrikeRange)) $ " for attack polling.", 'Command_Attack_Melee');
    }
}

event bool CreateTemporaryBlockedPath(NavigationPoint Nav)
{
    local int I, X;

    AILog_Internal((string(GetFuncName()) $ "() for ") $ string(Nav), 'PathWarning');
    I = 0;
    J0x45:

    if(I < RouteCache.Length)
    {
        if(RouteCache[I] == Nav)
        {
            X = 0;
            J0x89:

            if(X < Nav.PathList.Length)
            {
                DebugLogRoute();
                if((RouteCache.Length > (I + 1)) && Nav.PathList[X].End.Actor == RouteCache[I + 1])
                {
                    AILog_Internal((((string(GetFuncName()) $ "() Found a match, calling AddBlockedReachSpec for spec ") $ string(Nav.PathList[X])) $ " on nav point ") $ string(RouteCache[I + 1]));
                    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                    {
                        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIBlockedPath(self, Nav, NavigationPoint(Nav.PathList[X].End.Actor), (("TestBlockedPath from " $ string(Nav)) $ " to ") $ string(Nav.PathList[X].End.Actor));
                    }
                    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                    {
                        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIRedirectedPath(self, IntermediateMoveGoal, (("[HPO]Path:" $ string(IntermediateMoveGoal)) $ " and ") $ string(RouteCache[1]));
                    }
                    AddBlockedReachSpec(Nav.PathList[X], 10000000);
                    return true;
                }
                ++ X;
                goto J0x89;
            }
        }
        ++ I;
        goto J0x45;
    }
    return false;
}

function bool CreateTemporaryBlockedReach(NavigationPoint Nav, ReachSpec Reach)
{
    AILog_Internal(((string(GetFuncName()) $ "() for ") $ string(Nav)) @ string(Reach), 'PathWarning');
    if((Reach != none) && Reach.End.Actor == Nav)
    {
        DebugLogRoute();
        AILog_Internal((((string(GetFuncName()) $ "() Found a match, calling AddBlockedReachSpec for spec ") $ string(Reach)) $ " to nav point ") $ string(Nav));
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIBlockedPath(self, Nav, NavigationPoint(Reach.End.Actor), (("TestBlockedPath from " $ string(Nav)) $ " to ") $ string(Reach.End.Actor));
        }
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIRedirectedPath(self, IntermediateMoveGoal, (("[HPO]Path:" $ string(IntermediateMoveGoal)) $ " and ") $ string(RouteCache[1]));
        }
        AddBlockedReachSpec(Reach, 10000000);
        return true;
    }
    return false;
}

function Timer_EvaluateStatus()
{
    if((WorldInfo.TimeSeconds - LastNotifyHitWallTime) > 3)
    {
        LastHitWall = none;
        LastWallHitNormal = vect(0, 0, 0);
        HitWallCount = 0;
    }
    if(((bHasDebugCommand || MyKFPawn == none) || MyKFPawn.Health <= 0) || MyKFPawn.IsDoingSpecialMove())
    {
        return;
    }
    if((Enemy == none) || !Enemy.IsAliveAndWell())
    {
        FindNewEnemy();
    }
    SetTimer(RandRange(MinTimeBetweenStatusUpdates, MaxTimeBetweenStatusUPdates), false, 'Timer_EvaluateStatus', self);
}

simulated event SetInitialState()
{
    if(GetStateName() != InitialState)
    {
        GotoState(InitialState);
    }
}

function class<AICommand> GetDefaultCommand()
{
    return DefaultCommandClass;
}

function bool ShouldReturnToIdle()
{
    local bool bShouldReturn;

    bShouldReturn = !bMovingToGoal && Enemy == none;
    return bShouldReturn;
}

function SetBestAnchor()
{
    local NavigationPoint BestAnchor;
    local float Dist;

    BestAnchor = Pawn.GetBestAnchor(Pawn, Pawn.Location, true, false, Dist);
    if(BestAnchor != none)
    {
        Pawn.SetAnchor(BestAnchor);
    }
}

function ReturnToIdle();

function AddBasePathConstraints();

final simulated function float GetHealthPercentage()
{
    local Pawn P;

    P = Pawn;
    if(P == none)
    {
        return 1;        
    }
    else
    {
        return float(P.Health) / float(P.HealthMax);
    }
}

function PawnDied(Pawn inPawn)
{
    if(MyKFPawn != none)
    {
        AILog_Internal((((string(GetFuncName()) $ "() InPawn: ") $ string(inPawn)) $ " - Lifetime was ") $ string(WorldInfo.TimeSeconds - MyKFPawn.CreationTime), 'Damage');        
    }
    else
    {
        AILog_Internal((string(GetFuncName()) $ "() InPawn: ") $ string(inPawn), 'Damage');
    }
    if(bDumpCommandHistoryOnExit)
    {
        if(bDebugCommandHistory && !bDumpedCommandHistory)
        {
            bDumpedCommandHistory = true;
            DumpCommandHistory();
        }
    }
    if(MyAIDirector != none)
    {
        MyAIDirector.UnRegisterAIMember(self);
    }
    if(MyKFPawn != none)
    {
        MyKFPawn = none;
    }
    if(((KFPawn_Monster(Pawn) != none) && KFGameInfo(WorldInfo.Game) != none) && TimeFirstSawPlayer >= float(0))
    {
        KFGameInfo(WorldInfo.Game).GameConductor.HandleZedKill(FMax(WorldInfo.TimeSeconds - TimeFirstSawPlayer, 0));
        TimeFirstSawPlayer = -1;
    }
    super.PawnDied(inPawn);
}

function bool AttemptToTeleport(optional float CheckRadius)
{
    local NavigationPoint ResNav;

    CheckRadius = 512;
    AILog_Internal(string(GetFuncName()));
    ResNav = Class'KFPathnode'.static.GetNearestValidFloorNavWithinRadiusToPawn(Pawn, CheckRadius);
    if((ResNav != none) && TeleportToLocation(ResNav.Location, Pawn.Rotation))
    {
        return true;
    }
    return false;
}

event bool TeleportToLocation(Vector NewLoc, Rotator NewRot, optional bool bGiveNavZBuffer, optional bool bCancelCombat, optional bool bCancelMovement)
{
    local Vector OldLocation;

    bGiveNavZBuffer = true;
    bCancelCombat = true;
    bCancelMovement = true;
    AILog_Internal(((string(GetFuncName()) @ string(bCancelCombat)) @ string(bCancelMovement)) @ string(NewLoc), 'PathError');
    if(Pawn != none)
    {
        OldLocation = Pawn.Location;
    }
    if(bGiveNavZBuffer)
    {
        NewLoc.Z += 32;
    }
    if((Pawn != none) && Pawn.SetLocation(NewLoc))
    {
        LastTeleportLocation = OldLocation;
        LastTeleportTime = WorldInfo.TimeSeconds;
        if(Pawn.Physics == 10)
        {
            Pawn.Mesh.SetRBPosition(NewLoc);
        }
        RouteCache_Empty();
        if(bCancelMovement)
        {
            ClearMovementInfo(false);
        }
        if(bCancelCombat && CommandList != none)
        {
            BeginCombatCommand(none, "Teleported");
        }
        Pawn.SetRotation(NewRot);
        Pawn.SetMovementPhysics();
        AIZeroMovementVariables();
        return true;
    }
    AILog_Internal("TELEPORT FAILED?!", 'PathWarning');
    return false;
}

simulated event Destroyed()
{
    local KFDebugLines KFDL;

    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        KFDL.RemoveOwnedDebugLines(Name);
        KFDL.RemoveOwnedDebugSpheres(Name);
        KFDL.RemoveOwnedDebugText3D(Name);
    }
    AbortCommand(CommandList);
    MyKFPawn = none;
    if(MyAIDirector != none)
    {
        MyAIDirector.UnRegisterAIMember(self);
    }
    if(Steering != none)
    {
        Steering.OnOwnerDestroy();
        Steering = none;
    }
    if(MyAIDirector != none)
    {
        MyAIDirector.UnRegisterAIMember(self);
    }
    super(GameAIController).Destroyed();
}

// Export UKFAIController::execHasEnemyWithinDistance(FFrame&, void* const)
native final function bool HasEnemyWithinDistance(float Distance, optional out Pawn out_EnemyPawn, optional bool bExact);

// Export UKFAIController::execGetClosestTimeAndDistToPawn(FFrame&, void* const)
native function GetClosestTimeAndDistToPawn(KFPawn CheckPawn, out float out_ClosestTime, out float out_ClosestDist);

// Export UKFAIController::execIsCloseEnoughToEnemy(FFrame&, void* const)
native function bool IsCloseEnoughToEnemy();

// Export UKFAIController::execInMeleeRange(FFrame&, void* const)
native function bool InMeleeRange(const Vector TestLocation, optional name AttackTag);

// Export UKFAIController::execInAttackTagRange(FFrame&, void* const)
native function bool InAttackTagRange(const name AttackTag, const Vector TestLocation);

// Export UKFAIController::execInAnyAttackTagRange(FFrame&, void* const)
native function bool InAnyAttackTagRange(const Vector TestLocation, out name outAttackTag);

// Export UKFAIController::execInChargeRange(FFrame&, void* const)
native function bool InChargeRange(const Vector TestLocation);

// Export UKFAIController::execEnableMeleeRangeEventProbing(FFrame&, void* const)
native final simulated function EnableMeleeRangeEventProbing();

// Export UKFAIController::execDisableMeleeRangeEventProbing(FFrame&, void* const)
native final simulated function DisableMeleeRangeEventProbing();

// Export UKFAIController::execIsMeleeRangeEventProbingEnabled(FFrame&, void* const)
native final simulated function bool IsMeleeRangeEventProbingEnabled();

// Export UKFAIController::execStopAllLatentMoveExecution(FFrame&, void* const)
native function StopAllLatentMoveExecution();

// Export UKFAIController::execIsTargetedByPlayer(FFrame&, void* const)
native function bool IsTargetedByPlayer(optional out KFPawn outThreateningPlayer);

event bool FindNewEnemy()
{
    local Pawn PotentialEnemy, BestEnemy;
    local float bestDist, newdist;
    local int BestEnemyZedCount, PotentialEnemyZedCount;
    local bool bUpdateBestEnemy;

    if(Pawn == none)
    {
        return false;
    }
    BestEnemy = none;
    foreach WorldInfo.AllPawns(Class'Pawn', PotentialEnemy)
    {
        if((!PotentialEnemy.IsAliveAndWell() || Pawn.IsSameTeam(PotentialEnemy)) || !PotentialEnemy.CanAITargetThisPawn(self))
        {
            continue;            
        }
        newdist = VSizeSq(PotentialEnemy.Location - Pawn.Location);
        if((BestEnemy == none) || bestDist > newdist)
        {
            BestEnemyZedCount = -1;
            bUpdateBestEnemy = true;            
        }
        else
        {
            if(BestEnemyZedCount == -1)
            {
                BestEnemyZedCount = NumberOfZedsTargetingPawn(BestEnemy);
            }
            PotentialEnemyZedCount = NumberOfZedsTargetingPawn(PotentialEnemy);
            if(PotentialEnemyZedCount < BestEnemyZedCount)
            {
                BestEnemyZedCount = PotentialEnemyZedCount;
                bUpdateBestEnemy = true;
            }
        }
        if(bUpdateBestEnemy)
        {
            BestEnemy = PotentialEnemy;
            bestDist = newdist;
            bUpdateBestEnemy = false;
        }        
    }    
    if(((Enemy != none) && BestEnemy != none) && BestEnemy == Enemy)
    {
        return false;
    }
    if(BestEnemy != none)
    {
        ChangeEnemy(BestEnemy);
        return HasValidEnemy();
    }
    return false;
}

function bool GetHasAcceptableEnemyCount(Pawn NewEnemy)
{
    local float NumZedsTargetingCurrentEnemy, NumZedsTargetingNewEnemy, RatioOfZedsOldEnemyToNewEnemy;

    if(Enemy != none)
    {
        NumZedsTargetingCurrentEnemy = float(NumberOfZedsTargetingPawn(Enemy, false, 1000));
        NumZedsTargetingNewEnemy = float(NumberOfZedsTargetingPawn(NewEnemy, false, 1000));
        if(NumZedsTargetingNewEnemy >= float(3))
        {
            AILog_Internal(string(GetFuncName()) $ " New enemy already has a full dance card, stick with current enemy", 'SetEnemy');
            return false;
        }
        if(NumZedsTargetingNewEnemy < float(1))
        {
            AILog_Internal(((string(GetFuncName()) $ " accepting ") $ string(NewEnemy)) $ " because it's closer than our current, and nobody nearby targeting the new enemy", 'SetEnemy');
            return true;            
        }
        else
        {
            RatioOfZedsOldEnemyToNewEnemy = NumZedsTargetingCurrentEnemy / NumZedsTargetingNewEnemy;
            if(RatioOfZedsOldEnemyToNewEnemy <= 0.5)
            {
                AILog_Internal(((string(GetFuncName()) $ " not accepting ") $ string(NewEnemy)) $ " because there are too few zeds targeting the current one", 'SetEnemy');
                return false;
            }
        }
    }
    return true;
}

event bool SetEnemyToZed(Pawn NewEnemy)
{
    local float NewEnemyDist, TimeSinceLastEnemyChange;

    AILog_Internal((string(GetFuncName()) $ "(), desired new enemy: ") $ string(NewEnemy), 'SetEnemy');
    if((((((NewEnemy == none) || !NewEnemy.IsAliveAndWell()) || Pawn == none) || !Pawn.IsAliveAndWell()) || Pawn == NewEnemy) || !NewEnemy.CanAITargetThisPawn(self))
    {
        return false;
    }
    TimeSinceLastEnemyChange = WorldInfo.TimeSeconds - LastSetEnemyTime;
    if(TimeSinceLastEnemyChange < MinTimeBetweenEnemyChanges)
    {
        AILog_Internal(((string(GetFuncName()) $ "() not evaluating because not enough time has passed (") $ string(TimeSinceLastEnemyChange)) $ ") since last SetEnemy() call.", 'SetEnemy');
        return false;
    }
    NewEnemyDist = VSize(NewEnemy.Location - Pawn.Location);
    if(NewEnemyDist < MinDistanceToAggroZed)
    {
        if(!GetHasAcceptableEnemyCount(NewEnemy))
        {
            return false;
        }
        AILog_Internal(((((string(GetFuncName()) $ "() accepting ") $ string(NewEnemy)) $ " because Enemy (") $ string(Enemy)) $ ") dist is > 1.2 * NewEnemy dist", 'SetEnemy');
        ChangeEnemy(NewEnemy);
        return true;
    }
    return false;
}

event bool SetEnemy(Pawn NewEnemy)
{
    local float EnemyDistSq, NewEnemyDistSq, TimeSinceLastEnemyChange;

    AILog_Internal((string(GetFuncName()) $ "(), desired new enemy: ") $ string(NewEnemy), 'SetEnemy');
    if((((((NewEnemy == none) || !NewEnemy.IsAliveAndWell()) || Pawn.IsSameTeam(NewEnemy)) || Pawn == none) || !Pawn.IsAliveAndWell()) || !NewEnemy.CanAITargetThisPawn(self))
    {
        return false;
    }
    if((Enemy != none) && NewEnemy == Enemy)
    {
        if((DoorEnemy != none) && LineOfSightTo(Enemy))
        {
            ChangeEnemy(NewEnemy);
            return true;
        }
        return false;
    }
    if((Enemy == none) || !Enemy.IsAliveAndWell())
    {
        AILog_Internal(((string(GetFuncName()) $ "(), accepting new enemy ") $ string(NewEnemy)) $ " because current enemy is none or dead", 'SetEnemy');
        ChangeEnemy(NewEnemy);
        return true;
    }
    TimeSinceLastEnemyChange = WorldInfo.TimeSeconds - LastSetEnemyTime;
    if(TimeSinceLastEnemyChange < MinTimeBetweenEnemyChanges)
    {
        AILog_Internal(((string(GetFuncName()) $ "() not evaluating because not enough time has passed (") $ string(TimeSinceLastEnemyChange)) $ ") since last SetEnemy() call.", 'SetEnemy');
        return false;
    }
    if((CachedAICommandList != none) && !CachedAICommandList.CanChangeEnemy(NewEnemy))
    {
        AILog_Internal(((string(GetFuncName()) $ "() rejecting ") $ string(NewEnemy)) $ " because an AICommand rejected it", 'SetEnemy');
        return false;
    }
    if(LineOfSightTo(Enemy) && VSize(Enemy.Location - Pawn.Location) < VSize(NewEnemy.Location - Pawn.Location))
    {
        AILog_Internal(((((string(GetFuncName()) $ "() rejecting ") $ string(NewEnemy)) $ " because I have LOS to current enemy (") $ string(Enemy)) $ ") and current enemy is also closer to me", 'SetEnemy');
        return false;
    }
    if(!CanSee(Enemy))
    {
        AILog_Internal((((string(GetFuncName()) $ "() accepting ") $ string(NewEnemy)) $ " because I cannot see my current enemy ") $ string(Enemy), 'SetEnemy');
        ChangeEnemy(NewEnemy);
        return true;
    }
    if(!CanSee(NewEnemy))
    {
        AILog_Internal((((string(GetFuncName()) $ "() rejecting ") $ string(NewEnemy)) $ " because I cannot see it, but I can see my current enemy ") $ string(Enemy), 'SetEnemy');
        return false;
    }
    EnemyDistSq = VSizeSq(Enemy.Location - Pawn.Location);
    if((MyKFPawn != none) && EnemyDistSq < Square(StrikeRange))
    {
        AILog_Internal(((((string(GetFuncName()) $ "() rejecting ") $ string(NewEnemy)) $ " because current enemy (") $ string(Enemy)) $ ") is within my desired melee range", 'SetEnemy');
        return false;
    }
    NewEnemyDistSq = Square(1.2 * VSize(NewEnemy.Location - Pawn.Location));
    if(EnemyDistSq > NewEnemyDistSq)
    {
        if(!GetHasAcceptableEnemyCount(NewEnemy))
        {
            return false;
        }
        AILog_Internal(((((string(GetFuncName()) $ "() accepting ") $ string(NewEnemy)) $ " because Enemy (") $ string(Enemy)) $ ") dist is > 1.2 * NewEnemy dist", 'SetEnemy');
        ChangeEnemy(NewEnemy);
        return true;
    }
    return false;
    if(((MyKFPawn != none) && Enemy != none) && Enemy == NewEnemy)
    {
        MyKFPawn.LookAtPawn(NewEnemy);
    }
    return true;
}

function ChangeEnemy(Pawn NewEnemy, optional bool bCanTaunt)
{
    local Pawn OldEnemy;
    local KFGameInfo KFGI;

    bCanTaunt = true;
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.OnAIChangeEnemy(self, NewEnemy);
    }
    if((Enemy != none) && Enemy != NewEnemy)
    {
        if((bCanTaunt && MyKFPawn != none) && MyKFPawn.CanDoSpecialMove(14))
        {
            MyKFPawn.DoSpecialMove(14);
        }
        OldEnemy = Enemy;
        if(OldEnemy != none)
        {
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIChangedEnemy(self, NewEnemy, OldEnemy, "ChangeEnemy() ");
            }
        }
    }
    AILog_Internal((string(GetFuncName()) $ "() set Enemy to ") $ string(NewEnemy), 'SetEnemy');
    Enemy = NewEnemy;
    BroadcastEnemyKnowledge(NewEnemy, 2);
    if(CachedAICommandList != none)
    {
        if(OldEnemy != none)
        {
            CachedAICommandList.NotifyEnemyChanged(OldEnemy);            
        }
        else
        {
            CachedAICommandList.NotifyEnemyChanged();
        }
    }
    LastSetEnemyTime = WorldInfo.TimeSeconds;
}

function EnableProbingMeleeRangeEvents(optional bool bForce)
{
    if(bForce || !MyKFPawn.IsDoingSpecialMove())
    {
        AILog_Internal(string(GetFuncName()) $ "() setting bIsProbingMeleeRangeEvents to true, restoring ability to melee attack", 'AIController');
        EnableMeleeRangeEventProbing();
        ClearTimer('EnableProbingMeleeRangeEvents');        
    }
    else
    {
        AILog_Internal(string(GetFuncName()) $ "() waiting to restore ability to melee attack, will check again in 0.1 seconds", 'AIController');
        SetTimer(0.25, true, 'EnableProbingMeleeRangeEvents');
    }
}

function ResetProbingMeleeRangeEvents(optional float DelayOverride)
{
    local float Delay;

    Delay = ((DelayOverride > 0) ? DelayOverride : 0.07);
    AILog_Internal(((string(GetFuncName()) $ "() will be resetting bIsProbingMeleeRangeEvents to true in ") $ string(Delay)) $ " seconds", 'Command_Attack_Melee');
    SetTimer(Delay, false, 'EnableProbingMeleeRangeEvents', self);
}

event ReadyToMelee();

function bool IsSuicidal()
{
    return false;
}

function bool IsDoingGrabSpecialMove()
{
    return (MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove(3) || MyKFPawn.IsDoingSpecialMove(4);
}

function bool CanTargetBeGrabbed(KFPawn TargetKFP)
{
    local KFAIController OtherKFAIC;

    if((((TargetKFP == none) || TargetKFP.Health <= 0) || TargetKFP.IsDoingSpecialMove(28)) || TargetKFP.Physics == 2)
    {
        return false;
    }
    foreach WorldInfo.AllControllers(Class'KFAIController', OtherKFAIC)
    {
        if(OtherKFAIC == self)
        {
            continue;            
        }
        if(((OtherKFAIC.MyKFPawn != none) && OtherKFAIC.Enemy == TargetKFP) && OtherKFAIC.IsDoingGrabSpecialMove())
        {            
            return false;
        }        
    }    
    return true;
}

function BeginCombatCommand(class<AICommand> CmdClass, coerce optional string Reason, optional bool bForced)
{
    local class<AICommand_Base_Combat> CurClass;
    local AICommand_Base_Combat CurCommand;

    AILog_Internal(((((((string(GetFuncName()) @ string(CmdClass)) @ "(CommandList:") $ string(CommandList)) $ ") Reason: ") $ Reason) $ " bForced: ") $ string(bForced), 'InitAICommand');
    if(CommandList != none)
    {
        CurCommand = AICommand_Base_Combat(CommandList);
        if(CurCommand != none)
        {
            CurClass = AICommand_Base_Combat(CommandList).Class;
        }
    }
    if(!bForced)
    {
        if((CmdClass != none) && !bAllowCombatTransitions)
        {
            AILog_Internal(string(self) $ " Not allowing combat transition due to scripting", 'InitAICommand');
            return;
        }
        if((CommandList != none) && !CommandList.AllowTransitionTo(CmdClass))
        {
            AILog_Internal(string(self) $ " Current command stack rejected transiton", 'InitAICommand');
            return;
        }
    }
    CleanOutCommandListOnCombatTransition();
    if(CmdClass != none)
    {
        InitalizeBaseCommand(CmdClass);        
    }
    else
    {
        if(CurClass != none)
        {
            ReturnToIdle();
        }
        GotoState('Action_Idle', 'Begin');
    }
}

function InitalizeBaseCommand(class<AICommand> CmdClass)
{
    CmdClass.static.InitCommand(self);
}

function CleanOutCommandListOnCombatTransition()
{
    if(CommandList != none)
    {
        AbortCommand(CommandList);
    }
}

final function Pawn GetClosestEnemy(optional Pawn ExcludePawn)
{
    local Pawn P, Best;
    local float Dist, bestDist;

    bestDist = 1000000;
    foreach WorldInfo.AllPawns(Class'Pawn', P)
    {
        if(!P.IsAliveAndWell() || (ExcludePawn != none) && ExcludePawn == P)
        {
            continue;            
        }
        if((((P.Controller != none) && P.Controller != self) && P.IsAliveAndWell()) && !Pawn.IsSameTeam(P))
        {
            Dist = VSize(P.Location - Pawn.Location);
            if(Dist < bestDist)
            {
                Best = P;
                bestDist = Dist;
            }
        }        
    }    
    AILog_Internal((string(GetFuncName()) $ "() returning closest enemy ") $ string(Best), 'SetEnemy');
    if((Best == none) && ExcludePawn != none)
    {
        Best = ExcludePawn;
    }
    return Best;
}

final event bool IsDoingAttackSpecialMove()
{
    local KFPawn.ESpecialMove KFSM;

    if(MyKFPawn.IsDoingSpecialMove())
    {
        KFSM = MyKFPawn.SpecialMove;
        if((((((KFSM == 1) || KFSM == 3) || KFSM == 4) || KFSM == 18) || KFSM == 2) || KFSM == 21)
        {
            return true;
        }
    }
    return false;
}

function CheckCombatTransition()
{
    local class<AICommand> NewCommand;
    local string Reason;
    local bool bTransition;
    local AICommand_Base_Combat CurCommand;

    AILog_Internal((string(GetFuncName()) $ "() bAllowCombatTransitions: ") $ string(bAllowCombatTransitions), 'CombatTransitions');
    if((((Pawn == none) || !Pawn.IsAliveAndWell()) || !bAllowCombatTransitions) || IsDead())
    {
        return;
    }
    AILog_Internal((string(GetFuncName()) @ string(CommandList)) $ " calling CheckInterruptCombatTransitions now", 'CombatTransitions');
    bTransition = !CheckInterruptCombatTransitions();
    if(bTransition)
    {
        AILog_Internal("bTransition was true from CheckInterruptCombatTransitions()", 'CombatTransitions');
        CurCommand = AICommand_Base_Combat(CommandList);
        if((CurCommand != none) && CurCommand.CheckTransition(NewCommand, Reason))
        {
            AILog_Internal((string(GetFuncName()) $ "() Calling BeginCombatCommand for ") $ string(NewCommand), 'CombatTransitions');
            BeginCombatCommand(NewCommand, Reason);            
        }
        else
        {
            if((CurCommand == none) && (CommandList == none) || CommandList.Class != DefaultCommandClass)
            {
                NewCommand = GetDefaultCommand();
                if(NewCommand == none)
                {
                    AILog_Internal(("WARNING! " $ string(self)) $ " has no default command specified!", 'CombatTransitions');
                    return;
                }
                AILog_Internal((string(GetFuncName()) $ "() Calling BeginCombatCommand for 2 ") $ string(NewCommand), 'CombatTransitions');
                BeginCombatCommand(NewCommand, "No Command Specified");
            }
        }
    }
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageTyp)
{
    if((((((Killer != none) && Killer == self) && KilledPawn != none) && Pawn != none) && !Pawn.IsSameTeam(KilledPawn)) && KilledPawn == Enemy)
    {
        Class'AICommand_TauntEnemy'.static.Taunt(self, KilledPawn, 1);        
    }
    else
    {
        if((KilledPawn != none) && KilledPawn == Enemy)
        {
            FindNewEnemy();
        }
    }
    super.NotifyKilled(Killer, Killed, KilledPawn, damageTyp);
}

final function bool HasValidEnemy(optional Pawn TestEnemy)
{
    if(TestEnemy == none)
    {
        TestEnemy = Enemy;
    }
    if((TestEnemy == none) || !TestEnemy.IsValidEnemyTargetFor(PlayerReplicationInfo, true))
    {
        return false;
    }
    return true;
}

function bool SelectEnemy()
{
    return FindNewEnemy();
}

function bool SelectTarget()
{
    return FindNewEnemy();
}

function bool DoHeavyZedBump(Actor Other, Vector HitNormal)
{
    local int BumpEffectDamage;
    local KFPawn_Monster BumpedMonster;

    if(Other.bCanBeDamaged && KFFracturedMeshGlass(Other) != none)
    {
        KFFracturedMeshGlass(Other).BreakOffAllFragments();
        return true;
    }
    if(((Other.IsA('KFDestructibleActor') && !GetActiveCommand().IsA('AICommand_Melee')) && Other.bCollideActors) && !MyKFPawn.IsDoingSpecialMove())
    {
        AIZeroMovementVariables();
        DisableBump(2);
        NotifyAttackActor(Other);
        return true;
    }
    BumpedMonster = KFPawn_Monster(Other);
    if(((BumpedMonster == none) || !BumpedMonster.IsAliveAndWell()) || BumpedMonster.ZedBumpDamageScale <= float(0))
    {
        return false;
    }
    if((MyKFPawn == none) || !MyKFPawn.IsAliveAndWell())
    {
        return false;
    }
    if(MyKFPawn.bIsSprinting && !MyKFPawn.IsDoingSpecialMove())
    {
        BumpEffectDamage = int(float(ZedBumpEffectThreshold) * BumpedMonster.ZedBumpDamageScale);
        if((BumpedMonster.Health - BumpEffectDamage) <= 0)
        {
            if(FRand() < ZedBumpObliterationEffectChance)
            {
                BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());                
            }
            else
            {
                BumpedMonster.Knockdown(,, vect(1, 1, 1), Pawn.Location, 1000, 100);
            }
            return true;            
        }
        else
        {
            BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());
            BumpedMonster.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(BumpedMonster, HitNormal));
            return true;
        }
    }
    return false;
}

function NotifyMeleeAttackFinished();

function BeginMeleeCommand(Pawn TargetPawn, coerce optional string Reason)
{
    AILog_Internal((string(GetFuncName()) $ "() TargetPawn: ") $ string(TargetPawn), 'Command_Attack_Melee');
    if(AICommand_Base_Zed(CommandList) == none)
    {
        if(TargetPawn != none)
        {
            SetEnemy(TargetPawn);
        }
        if(MeleeCommandClass != (GetDefaultCommand()))
        {
            AILog_Internal((string(GetFuncName()) $ "() calling BeginCombatCommand for ") $ string(MeleeCommandClass), 'Command_Attack_Melee');
            BeginCombatCommand(MeleeCommandClass, Reason, true);
        }
    }
}

function bool IsValidAttackTarget(Actor CheckActor)
{
    if((CheckActor == none) || CheckActor.bTearOff)
    {
        return false;
    }
    return true;
}

function bool IsWithinAttackRange()
{
    local float DistSqToEnemy;

    if((((MyKFPawn == none) || Enemy == none) || !MyKFPawn.IsAliveAndWell()) || !Enemy.IsAliveAndWell())
    {
        if((Enemy == none) || Enemy.Health <= 0)
        {
            Enemy = none;
            SetEnemy(GetClosestEnemy());
            return false;
        }
        return true;
    }
    if(MyKFGameInfo.NumPlayers > 1)
    {
        if(KFPawn(Enemy).IsSurrounded(false, 4, 350) && CanSee(Enemy))
        {
            if(FindNewEnemy())
            {
                AILog_Internal((string(GetFuncName()) $ " found that enemy is surrounded so changed enemy to ") $ string(Enemy), 'ReachedEnemy');
                return false;
            }
        }
    }
    if(MyKFPawn.PawnAnimInfo == none)
    {
        WarnInternal("No PawnAnimInfo defined for " $ string(MyKFPawn));
        return IsCloseEnoughToEnemy();
    }
    DistSqToEnemy = VSizeSq(Enemy.Location - Pawn.Location);
    if(DistSqToEnemy <= (AttackRange * AttackRange))
    {
        return true;
    }
    return false;
}

function bool WithinMeleeHeightDifference(KFPawn EnemyPawn)
{
    local Vector EnemyPawnGroundPos, MyPawnGroundPos, EnemyPawnCylinder, MyPawnCylinder;

    EnemyPawnCylinder.Z = EnemyPawn.CylinderComponent.CollisionHeight;
    MyPawnCylinder.Z = Pawn.CylinderComponent.CollisionHeight;
    EnemyPawnGroundPos = EnemyPawn.Location - EnemyPawnCylinder;
    MyPawnGroundPos = Pawn.Location - MyPawnCylinder;
    return Abs(Normal(EnemyPawnGroundPos - MyPawnGroundPos).Z) < MaxMeleeHeightAngle;
}

function EndOfMeleeAttackNotification();

function NotifyCommandMeleeAttackAborted()
{
    local AICommand_Attack_Melee MeleeCommand;

    AILog_Internal(string(GetFuncName()) $ "()", 'Command_Attack_Melee');
    if((CommandList != none) && GetActiveCommand().IsA('AICommand_Attack_Melee'))
    {
        MeleeCommand = AICommand_Attack_Melee(GetActiveCommand());
        if(MeleeCommand != none)
        {
            AILog_Internal((string(GetFuncName()) $ "() calling AbortCommand for ") $ string(MeleeCommand), 'Command_Attack_Melee');
            AbortCommand(MeleeCommand);
        }
    }
}

function UpdateLastMeleeTime(KFPawn.EAnimSlotStance BodyStance)
{
    LastAttackTime_Melee = WorldInfo.TimeSeconds;
}

function ChooseStrikeByName(name AttackName, optional bool bForce)
{
    local int DesiredStrikeIndex;
    local KFPawnAnimInfo KFPAI;

    if(((AttackName != 'None') && MyKFPawn != none) && MyKFPawn.PawnAnimInfo != none)
    {
        KFPAI = MyKFPawn.PawnAnimInfo;
        DesiredStrikeIndex = KFPAI.GetAttackIndexByTag(AttackName);
        if(DesiredStrikeIndex < 0)
        {
            WarnInternal(("MeleeAttackRandList Tag " $ string(AttackName)) $ " Could not be found in the PawnAnimInfo");
            return;
        }
        if(bForce || KFPAI.CanDoAttackAnim(DesiredStrikeIndex, MyKFPawn, Enemy))
        {
            KFPAI.UpdateAttackCooldown(self, byte(DesiredStrikeIndex));
            return;
        }
    }
    LogInternal((string(self) @ string(GetFuncName())) @ "failed to find a valid attack");
}

event bool CanGrabAttack()
{
    return false;
}

event DoGrabAttack(optional Pawn NewEnemy, optional Actor InTarget, optional float InPostSpecialMoveSleepTime)
{
    InPostSpecialMoveSleepTime = 0;
}

function int NumberOfZedsTargetingPawn(Pawn P, optional bool bExcludeMe, optional float MinDistanceToInclude)
{
    local Controller C;
    local int ZedCount;

    bExcludeMe = true;    
    if((P == none) || !P.IsAliveAndWell())
    {
        return 0;
    }
    foreach WorldInfo.AllControllers(Class'Controller', C)
    {
        if((((C.Enemy == P) && C.Pawn != none) && (C.Pawn != Pawn) || !bExcludeMe) && C.Pawn.IsAliveAndWell())
        {
            if((MinDistanceToInclude == 0) || (MinDistanceToInclude > 0) && VSizeSq(C.Pawn.Location - P.Location) <= (MinDistanceToInclude * MinDistanceToInclude))
            {
                ++ ZedCount;
            }
        }        
    }    
    return ZedCount;
}

function int OtherZedsTargetingMyEnemy()
{
    local KFAIController KFAIC;
    local int ZedCount;

    if((Enemy == none) || !Enemy.IsAliveAndWell())
    {
        return 0;
    }
    foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if(((((KFAIC != self) && KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell()) && KFAIC.Enemy != none) && KFAIC.Enemy == Enemy)
        {
            ++ ZedCount;
        }        
    }    
    return ZedCount;
}

function int GetZedCount(optional float MinDistanceFromMyPawn)
{
    local KFAIController KFAIC;
    local int ZedCount;

    MinDistanceFromMyPawn = 0;
    foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
        {
            if(MinDistanceFromMyPawn > 0)
            {
                if(VSizeSq(KFAIC.Pawn.Location - Pawn.Location) <= (MinDistanceFromMyPawn * MinDistanceFromMyPawn))
                {
                    ++ ZedCount;
                }
                continue;
            }
            ++ ZedCount;
        }        
    }    
    return ZedCount;
}

// Export UKFAIController::execCanSeeByPointsEx(FFrame&, void* const)
native final function bool CanSeeByPointsEx(Vector ViewLocation, Vector TestLocation, Rotator ViewRotation, out Vector outHitLoc, out Actor outHitActor);

function bool AreZedsNear(Vector aLocation, optional bool bRequireCanSee, optional float CheckRadius, optional int MinimalCount)
{
    local int I, ZedCount;
    local Rotator ViewRot;
    local Vector ViewLoc;

    bRequireCanSee = false;
    CheckRadius = 650;
    MinimalCount = 1;
    if(MyAIDirector == none)
    {
        return false;
    }
    I = 0;
    J0x2F:

    if(I < MyAIDirector.AIList.Length)
    {
        if(ZedCount >= MinimalCount)
        {
            return true;
        }
        if(((MyAIDirector.AIList[I] == self) || MyAIDirector.AIList[I].MyKFPawn == none) || MyAIDirector.AIList[I].MyKFPawn.IsUsingSuperSpeed())
        {            
        }
        else
        {
            if((CheckRadius > 0) && VSizeSq(MyAIDirector.AIList[I].Pawn.Location - aLocation) < (CheckRadius * CheckRadius))
            {
                if(bRequireCanSee)
                {
                    MyAIDirector.AIList[I].MyKFPawn.GetActorEyesViewPoint(ViewLoc, ViewRot);
                    if(MyAIDirector.AIList[I].CanSeeByPoints(ViewLoc, aLocation, ViewRot))
                    {
                        ++ ZedCount;                        
                    }
                    else
                    {
                        goto J0x2B6;
                    }                    
                }
                else
                {
                    ++ ZedCount;
                }
            }
        }
        J0x2B6:

        ++ I;
        goto J0x2F;
    }
    return false;
}

function bool CheckCooldownTimer(name CooldownTag)
{
    local int I;

    I = CooldownTimers.Find('Tag', CooldownTag;
    if(I != -1)
    {
        if((WorldInfo.TimeSeconds - CooldownTimers[I].ActivationTime) < CooldownTimers[I].Duration)
        {
            return false;
        }
    }
    return true;
}

function AddCooldownTimer(name CooldownTag, float CoolDownTime)
{
    local int I;
    local CooldownData NewCooldown;

    I = CooldownTimers.Find('Tag', CooldownTag;
    if(I == -1)
    {
        NewCooldown.Tag = CooldownTag;
        I = CooldownTimers.AddItem(NewCooldown;
    }
    CooldownTimers[I].Duration = CoolDownTime;
    CooldownTimers[I].ActivationTime = WorldInfo.TimeSeconds;
}

function SetOverallCooldownTimer(float CoolDownTime)
{
    OverallAttackCooldownTimer.Duration = CoolDownTime;
    OverallAttackCooldownTimer.ActivationTime = WorldInfo.TimeSeconds;
}

function bool CheckOverallCooldownTimer()
{
    if((OverallAttackCooldownTimer.Duration > float(0)) && (WorldInfo.TimeSeconds - OverallAttackCooldownTimer.ActivationTime) < OverallAttackCooldownTimer.Duration)
    {
        return false;
    }
    return true;
}

function bool CheckInterruptCombatTransitions()
{
    local AICommand_Base_Combat CurCommand;

    AILog_Internal((("---- " $ string(GetFuncName())) $ "() IgnoreNotifies? : ") $ string(IgnoreNotifies()), 'CombatTransitions');
    if((((Pawn == none) || !Pawn.IsAliveAndWell()) || IsDead()) || IgnoreNotifies())
    {
        AILog_Internal(("---- " $ string(GetFuncName())) $ "() aborting early", 'CombatTransitions');
        return false;
    }
    if((Enemy != none) && !Enemy.IsAliveAndWell() || Enemy.Controller == none)
    {
        AILog_Internal(string(GetFuncName()) $ "() setting enemy to NONE because they have no controller or they are dead!", 'CombatTransitions');
        SetEnemy(none);
    }
    CurCommand = AICommand_Base_Combat(CommandList);
    if(CurCommand == none)
    {
        AILog_Internal(((("---- " $ string(GetFuncName())) $ "() setting enemy aborting because current command (") $ string(CurCommand)) $ ") isn't a combat based command", 'CombatTransitions');
        return false;
    }
    if((AICommand_Base_Combat(CommandList) != none) && ShouldReturnToIdle())
    {
        AILog_Internal(string(GetFuncName()) $ "() returning true because I have a combat command and ShouldReturnToIdle returned true", 'CombatTransitions');
        return true;
    }
    AILog_Internal(string(GetFuncName()) $ "() returning false", 'CombatTransitions');
    return false;
}

// Export UKFAIController::execActorReachableNoAnchorCheck(FFrame&, void* const)
native final function bool ActorReachableNoAnchorCheck(Actor anActor);

// Export UKFAIController::execIsMovingToJumpPoint(FFrame&, void* const)
native function bool IsMovingToJumpPoint();

// Export UKFAIController::execInitSteering(FFrame&, void* const)
native function InitSteering();

// Export UKFAIController::execGetSteering(FFrame&, void* const)
native function KFAISteering GetSteering();

// Export UKFAIController::execGetRouteCacheDistance(FFrame&, void* const)
native final function float GetRouteCacheDistance();

// Export UKFAIController::execIsInStumble(FFrame&, void* const)
native final simulated function bool IsInStumble();

// Export UKFAIController::execCalcClosestPointTime(FFrame&, void* const)
native function float CalcClosestPointTime(Vector LocA, Vector VelocityA, Vector LocB, Vector VelocityB);

// Export UKFAIController::execSetDirectPathCheckTime(FFrame&, void* const)
native function SetDirectPathCheckTime();

function bool IsDoingLatentMove()
{
    return InLatentExecution(503) || InLatentExecution(501);
}

event StopAllLatentMovement(optional bool bForced)
{
    StopAllLatentMoveExecution();
    AIZeroMovementVariables();
}

function ClearMovementInfo(optional bool bSafeAbort, optional string DebugMsg)
{
    AILog_Internal(string(GetFuncName()) $ "() Aborting movement commands and setting MoveTarget to none", 'Command_MoveToGoal');
    AbortMovementCommands();
    AbortMovementPlugIns();
    MoveTarget = none;
}

event AbortMovementCommands(optional bool bSafeAbort, optional string DebugMsg)
{
    AILog_Internal(string(GetFuncName()) $ "() called, aborting MoveToEnemy and MoveToGoal commands if they are active", 'Command_MoveToGoal');
    if(DebugMsg != "")
    {
        FindCommandOfClass(Class'AICommand_MoveToEnemy').UpdateHistoryString(DebugMsg);
        FindCommandOfClass(Class'AICommand_MoveToGoal').UpdateHistoryString(DebugMsg);
    }
    AbortCommand(none, Class'AICommand_MoveToEnemy');
    AbortCommand(none, Class'AICommand_MoveToGoal');
}

event AbortMovementPlugIns(optional bool bSafeAbort, optional string DebugMsg)
{
    AILog_Internal(string(GetFuncName()) $ "() called, aborting MovementPlugin and LeapPlugin Plug Ins if they are active", 'Movement_Plugins');
    if(DebugMsg != "")
    {
        if(KfMovementPlugin != none)
        {
            KfMovementPlugin.UpdateHistoryString(DebugMsg);
        }
        if(KfLeapPlugin != none)
        {
            KfLeapPlugin.UpdateHistoryString(DebugMsg);
        }
        if(StuckFixPlugin != none)
        {
            StuckFixPlugin.UpdateHistoryString(DebugMsg);
        }
    }
    if(KfMovementPlugin != none)
    {
        KfMovementPlugin.AbortMove(false);
    }
    if(KfLeapPlugin != none)
    {
        KfLeapPlugin.AbortMove(false);
    }
    if(StuckFixPlugin != none)
    {
        StuckFixPlugin.AbortMove(false);
    }
}

function AIZeroMovementVariables(optional bool bForce)
{
    AILog_Internal(((string(WorldInfo.TimeSeconds) $ " ") $ string(GetFuncName())) $ " setting movetimer to -1", 'PathWarning');
    MoveTimer = -1;
    if(Pawn != none)
    {
        if(!bForce && Pawn.Physics == 2)
        {
            return;
        }
        Pawn.ZeroMovementVariables();
    }
}

function StopMovement(optional BaseAI.BaseAITypes.EActionPriority ActionPriority)
{
    ActionPriority = 1;
    super.StopMovement(ActionPriority);
    if(KfWallWalkingPlugIn != none)
    {
        KfWallWalkingPlugIn.AbortMove(false);
    }
}

event StartingMovement()
{
    AILog_Internal(string(self) $ " StartingMovement", 'AIController');
}

event StoppingMovement()
{
    AILog_Internal(string(self) $ " StoppingMovement", 'AIController');
}

event bool AllowedToMove()
{
    return !IsDoingAttackSpecialMove();
}

event ReachedMoveGoal()
{
    AILog_Internal(string(self) $ " Reached MoveGoal!", 'AIController');
}

function ReachedIntermediateMoveGoal()
{
    AILog_Internal(string(self) $ " ReachedIntermediateMoveGoal!", 'AIController');
}

function bool MoveIsInterruptable(optional bool bForce)
{
    return true;
}

function bool MoveGoalIsValid(optional Actor Goal)
{
    if(Goal == none)
    {
        Goal = MoveGoal;
    }
    return Goal != none;
}

function bool MovePointIsValid(optional Vector Point)
{
    if(Point == vect(0, 0, 0))
    {
        Point = GetBasedPosition(MovePosition);
    }
    return Point != vect(0, 0, 0);
}

event Actor GeneratePathTo(Actor Goal, optional float Distance, optional bool bAllowPartialPath)
{
    local Actor PathResult;

    AddBasePathConstraints();
    AILog_Internal((((((string(GetFuncName()) $ "() Goal: ") $ string(Goal)) $ " optional distance: ") $ string(Distance)) $ " bAllowPartialPath: ") $ string(bAllowPartialPath), 'AIController');
    Class'Path_TowardGoal'.static.TowardGoal(Pawn, Goal);
    if(bDisablePartialPaths)
    {
        bAllowPartialPath = false;
    }
    Class'Goal_AtActor'.static.AtActor(Pawn, Goal, Distance, bAllowPartialPath);
    PathResult = FindPathToward(Goal);
    Pawn.ClearConstraints();
    return PathResult;
}

event bool GenerateNavMeshPathTo(Actor Goal, optional float WithinDistance, optional bool bAllowPartialPath)
{
    if(NavigationHandle == none)
    {
        return false;
    }
    NavigationHandle.ClearConstraints();
    Class'NavMeshPath_Toward'.static.TowardGoal(NavigationHandle, Goal);
    Class'NavMeshGoal_At'.static.AtActor(NavigationHandle, Goal, WithinDistance, bAllowPartialPath);
    return NavigationHandle.FindPath();
}

event bool GenerateNavMeshPathToLocation(Vector Goal, optional float WithinDistance, optional bool bAllowPartialPath)
{
    if(NavigationHandle == none)
    {
        return false;
    }
    NavigationHandle.ClearConstraints();
    Class'NavMeshPath_Toward'.static.TowardPoint(NavigationHandle, Goal);
    Class'NavMeshGoal_At'.static.AtLocation(NavigationHandle, Goal, WithinDistance, bAllowPartialPath);
    return NavigationHandle.FindPath();
}

event Actor GenerateDoorlessPathTo(Actor Goal, optional float Distance, optional bool bAllowPartialPath)
{
    local Actor PathResult;
    local KFPawn CheckPawn;

    CheckPawn = KFPawn(Goal);
    AddBasePathConstraints();
    Class'Path_TowardGoal'.static.TowardGoal(Pawn, CheckPawn);
    Class'Path_AvoidClosedDoors'.static.AvoidClosedDoors(Pawn, true);
    Class'Goal_Null'.static.GoUntilBust(Pawn, 2024);
    PathResult = FindPathToward(Goal);
    Pawn.ClearConstraints();
    if(PathResult == none)
    {
        AILog_Internal((((((string(GetFuncName()) $ "() failed to build a path to ") $ string(Goal)) $ ", offset distance was ") $ string(Distance)) $ ", bAllowPartialPath was ") $ string(bAllowPartialPath), 'PathWarning');
    }
    return PathResult;
}

// Export UKFAIController::execAddBlockedReachSpec(FFrame&, void* const)
native function bool AddBlockedReachSpec(ReachSpec BlockedSpec, int BlockedCost);

static function ShowAdvancedRouteEdgeDebugInfo(NavigationHandle KFNavigationHandle2Use, optional bool bShowPathCachePolys)
{
    bShowPathCachePolys = false;
}

function DoPauseAI(float InDuration, optional bool bStopMovement, optional bool bAbortCommands, optional bool bWaitForLanding)
{
    local Vector OldVelocity;
    local bool bWasFalling;

    if(bStopMovement)
    {
        if((Pawn != none) && Pawn.Physics == 2)
        {
            OldVelocity = Pawn.Velocity;
            bWasFalling = true;
        }
        AbortMovementCommands();
        AbortMovementPlugIns();
        if((Pawn != none) && bWasFalling)
        {
            Pawn.Velocity = OldVelocity;
        }
    }
    AILog_Internal((((string(GetFuncName()) $ "() Init AICommand_Pause Duration: ") $ string(InDuration)) $ " Active command: ") $ string(GetActiveCommand()), 'Command_Pause');
    Class'AICommand_Pause'.static.Pause(self, InDuration, bStopMovement);
}

function DoWander(optional Actor WanderGoal, optional float WanderDuration, optional bool bWanderAwayFromGoal, optional float MaxWanderDist)
{
    WanderDuration = -1;    
    MaxWanderDist = 10000;
    Class'AICommand_Wander'.static.BeginWander(self, WanderDuration, WanderGoal, bWanderAwayFromGoal, MaxWanderDist);
}

function DoFleeFrom(Actor FleeFrom, optional float FleeDuration, optional float FleeDistance, optional bool bShouldStopAtGoal)
{
    bShouldStopAtGoal = false;
    Class'AICommand_Flee'.static.FleeFrom(self, FleeFrom, FleeDuration, FleeDistance, bShouldStopAtGoal);
}

event SetMoveGoal(Actor NewMoveGoal, optional Actor NewMoveFocus, optional bool bInterruptable, optional float OffsetDist, optional bool bIsValidCache, optional bool bInCanPathfind, optional bool bForce, optional bool bAllowedToAttack, optional bool bAllowPartialPath)
{
    bInCanPathfind = true;    
    bAllowedToAttack = true;    
    if(bAlwaysAcceptPartialPaths && MyKFPawn.Physics != 8)
    {
        bAllowPartialPath = true;
    }
    bMoveGoalInterruptable = bInterruptable;
    MoveGoal = NewMoveGoal;
    SetBasedPosition(MovePosition, vect(0, 0, 0));
    MoveFocus = NewMoveFocus;
    MoveOffset = OffsetDist;
    AILog_Internal(((((string(GetFuncName()) $ "() initializing AICommand_MoveToGoal") @ string(NewMoveGoal)) @ string(NewMoveFocus)) @ string(bInterruptable)) @ string(bAllowedToAttack), 'InitAICommand');
    if((NewMoveGoal != none) && (MoveIsInterruptable(bForce)) || !bInterruptable)
    {
        Class'AICommand_MoveToGoal'.static.MoveToGoal(self, NewMoveGoal, NewMoveFocus, OffsetDist, bIsValidCache, bInCanPathfind, bAllowedToAttack, bAllowPartialPath);        
    }
    else
    {
        if(NewMoveGoal != none)
        {
            AILog_Internal(string(GetFuncName()) @ "!! -- ignoring movegoal because I already have a moveaction, which is non-interruptable, and the new movegoal IS interruptable.. trumped", 'InitAICommand');
        }
    }
}

final event SetMovePoint(Vector NewMovePoint, optional Actor NewMoveFocus, optional bool bInterruptable, optional float OffsetDist, optional bool bIsValidCache, optional bool bAllowedToAttack, optional bool bAllowPartialPath, optional bool bCanPathfind)
{
    bAllowedToAttack = true;    
    bCanPathfind = true;
    AILog_Internal(((((string(GetFuncName()) $ "() initializing AICommand_MoveToGoal") $ string(NewMovePoint)) @ string(NewMoveFocus)) @ string(bInterruptable)) @ string(bAllowedToAttack), 'InitAICommand');
    bReachedMoveGoal = false;
    bMoveGoalInterruptable = bInterruptable;
    MoveGoal = none;
    SetBasedPosition(MovePosition, NewMovePoint);
    MoveFocus = NewMoveFocus;
    MoveOffset = OffsetDist;
    if(NewMovePoint != vect(0, 0, 0))
    {
        Class'AICommand_MoveToGoal'.static.MoveToPoint(self, NewMovePoint, NewMoveFocus, OffsetDist, bIsValidCache, bCanPathfind, bAllowedToAttack, bAllowPartialPath);
    }
}

final event SetEnemyMoveGoal(Object Observer, optional bool bCompleteMove, optional float GoalDistance, optional float AbandonDistance, optional bool bAllowedToAttack)
{
    GoalDistance = 0;
    AbandonDistance = 0;
    bAllowedToAttack = true;
    AILog_Internal((((((string(GetFuncName()) $ "() initializing AICommand_MoveToEnemy - setting enemy goal Dist:") @ string(GoalDistance)) @ "bCompleteMove?") @ string(bCompleteMove)) @ "bAllowedToAttack?") @ string(bAllowedToAttack), 'InitAICommand');
    PreMoveToEnemy();
    if(bUseNavMesh && bUsePluginsForMovement)
    {        
    }
    else
    {
        Class'AICommand_MoveToEnemy'.static.MoveToEnemy(self, bCompleteMove, GoalDistance, AbandonDistance, bAllowedToAttack, Enemy);
    }
}

function DoStrike();

function bool CanDoStrike();

event RunOverWarning(KFPawn IncomingKFP, float IncomingSpeed, Vector IncomingDir);

final function DoProjectileEvade()
{
    local byte BestDir;

    MyKFPawn.SetHeadTrackTarget(none);
    if((((((MyKFPawn != none) && MyKFPawn.CanDoSpecialMove(15) || MyKFPawn.CanDoSpecialMove(16)) && PendingEvadeProjectile != none) && !PendingEvadeProjectile.bDeleteMe) && !IsZero(PendingEvadeProjectile.Velocity)) && CanEvade())
    {
        BestDir = GetBestEvadeDir(PendingEvadeProjectile.Location, PendingEvadeProjectile.Instigator);
        if(BestDir != 8)
        {
            DoEvade(BestDir, PendingEvadeProjectile, 0.1 + (FRand() * 0.2), true);
        }
    }
    PendingEvadeProjectile = none;
}

function PreMoveToEnemy();

function DoEvade(byte EvadeDir, optional Actor EvadeActor, optional float Delay, optional bool bFrightened, optional bool bTurnToThreat)
{
    AILog_Internal(((string(GetFuncName()) @ string(EvadeDir)) @ string(Pawn.Physics)) @ string(Pawn.Anchor), 'Command_Evade');
    Class'AICommand_Evade'.static.Evade(self, EvadeDir, Delay, bFrightened);
}

function DoStumble(Vector Momentum, KFPawnAfflictions.EHitZoneBodyPart HitZoneLimb)
{
    local AICommand_Attack_Melee MeleeCommand;

    if((CommandList != none) && GetActiveCommand().IsA('AICommand_Attack_Melee'))
    {
        MeleeCommand = AICommand_Attack_Melee(GetActiveCommand());
        if(MeleeCommand != none)
        {
            AILog_Internal(string(GetFuncName()) $ "() Aborting Melee Command", 'InitAICommand');
            AbortCommand(MeleeCommand);
        }
    }
    AILog_Internal(string(GetFuncName()) $ "() Aborting movement commands", 'Command_MoveToGoal');
    AbortMovementCommands();
    AbortMovementPlugIns();
    if((CommandList == none) || !GetActiveCommand().IsA('AICommand_Stumble'))
    {
        AILog_Internal(string(GetFuncName()) $ "() Init AICommand_Stumble", 'InitAICommand');
        Class'AICommand_Stumble'.static.Stumble(self, Momentum, HitZoneLimb);
    }
}

function DoHeadlessWander()
{
    Class'AICommand_HeadlessWander'.static.HeadlessWander(self);
}

function DoPanicWander()
{
    Class'AICommand_PanicWander'.static.PanicWander(self);
}

function EndPanicWander()
{
    local AICommand_PanicWander CurCommand;

    if(GetActiveCommand() != none)
    {
        CurCommand = AICommand_PanicWander(GetActiveCommand());
        if(CurCommand != none)
        {
            CurCommand.EndWander(self);
        }
    }
}

event AttitudeStateChanged(name NewState);

event bool StepAsideFor(Pawn ChkPawn, Vector HitNormal)
{
    local bool bResult, bStepAside, bDelayStep;
    local KFAIController AI;
    local bool bNoFocus;

    AILog_Internal(string(GetFuncName()) @ string(ChkPawn));
    if(!bIgnoreStepAside && !MyKFPawn.IsDoingSpecialMove())
    {
        bResult = true;
        bStepAside = true;
        AI = KFAIController(ChkPawn.Controller);
        if((AI != none) && AI.StepAsideGoal == Pawn)
        {
            AILog_Internal("- other AI is stepping aside for us already");
            bResult = true;
            bStepAside = false;
        }
        if((Pawn.IsSameTeam(ChkPawn) && InLatentExecution(503)) && (Pawn.Velocity Dot ChkPawn.Velocity) > 0)
        {
            bDelayStep = ShouldDelayStepAside(ChkPawn);
            if(!bDelayStep)
            {
                AILog_Internal(string(self) $ " - moving in the same direction as pawn we bumped");
                bResult = true;
                bStepAside = false;
            }
        }
        if(bStepAside && StepAsideGoal != ChkPawn)
        {
            if(GetActiveCommand().IsA('AICommand_Debug'))
            {
                bNoFocus = AICommand_Debug(GetActiveCommand()).bNoFocus;
            }
            bResult = Class'AICommand_StepAside'.static.StepAside(self, ChkPawn, bDelayStep, bNoFocus);
        }
    }
    return bResult;
}

function bool ShouldDelayStepAside(Pawn GoalPawn)
{
    local float VelDotVel, GoalDotVel;
    local Vector VectToGoal, VelDir;

    if(!IsZero(Pawn.Velocity) && !IsZero(GoalPawn.Velocity))
    {
        VelDir = Normal(Pawn.Velocity);
        VelDotVel = Normal(GoalPawn.Velocity) Dot VelDir;
        if(VelDotVel > 0.3)
        {
            VectToGoal = Normal(GoalPawn.Location - Pawn.Location);
            GoalDotVel = VectToGoal Dot VelDir;
            if(GoalDotVel > float(0))
            {
                return true;
            }
        }
    }
    return false;
}

event FailedMove(optional string Reason)
{
    AILog_Internal("FailedMove! Reason: " $ Reason, 'PathWarning');
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIMoveFailure(self, Pawn.Location, Pawn.Rotation, MoveGoal, "4 " $ Reason);
    }
}

function Actor MoveToEnemy_GetMoveFocus()
{
    if(Enemy != none)
    {
        return Enemy;
    }
    return none;
}

function float GetEstimatedGroundSpeedForMoveTimout(bool bDoingLeadinOutWalk)
{
    local float GroundSpeed;

    GroundSpeed = Pawn.GroundSpeed;
    if(MyKFPawn != none)
    {
        GroundSpeed = MyKFPawn.NormalGroundSpeed;
    }
    return GroundSpeed;
}

function float GetMoveTimeOutDuration(Vector Dest, bool bDoingLeadinOutWalk)
{
    local float Dist, GroundSpeed, Duration;

    if(Pawn == none)
    {
        return 5;        
    }
    else
    {
        GroundSpeed = Pawn.GroundSpeed;
    }
    if(MyKFPawn != none)
    {
        GroundSpeed = MyKFPawn.NormalGroundSpeed;
    }
    Dist = VSize(Pawn.Location - Dest);
    if(Pawn.bIsWalking || bDoingLeadinOutWalk)
    {
        GroundSpeed *= Pawn.WalkingPct;
    }
    Duration = FMax(0.5, 2 * (Dist / GroundSpeed));
    AILog_Internal((((string(GetFuncName()) $ "() returning ") $ string(Duration)) $ " for dist of ") $ string(Dist), 'Command_MoveToGoal');
    return Duration;
}

function SetCanSprint(bool bNewSprintStatus)
{
    bCanSprint = bNewSprintStatus;
    if(!bCanSprint || bSprintingDisabled)
    {
        MyKFPawn.bIsSprinting = false;
    }
}

function SetSprintingDisabled(bool bNewSprintStatus)
{
    bSprintingDisabled = bNewSprintStatus;
    if(!bCanSprint || bSprintingDisabled)
    {
        MyKFPawn.bIsSprinting = false;
    }
}

function SetCanSprintWhenDamaged(bool bNewSprintDamagedStatus)
{
    bCanSprintWhenDamaged = bNewSprintDamagedStatus;
    if((!bCanSprint && !bCanSprintWhenDamaged) || bSprintingDisabled)
    {
        MyKFPawn.bIsSprinting = false;
    }
}

function bool CanSetSprinting(bool bNewSprintStatus)
{
    if(bNewSprintStatus && (!bCanSprint && !bCanSprintWhenDamaged) || bSprintingDisabled)
    {
        return false;
    }
    return true;
}

function bool ShouldSprint()
{
    local float DistToEnemy;
    local name AttackTag;

    if((((MyKFPawn != none) && MyKFPawn.IsAliveAndWell()) && Enemy != none) && Enemy.IsAliveAndWell())
    {
        if(IsFrustrated())
        {
            return true;
        }
        if((SprintWithinEnemyRange.X > 0) && SprintWithinEnemyRange.Y > 0)
        {
            DistToEnemy = VSize(Enemy.Location - Pawn.Location);
            if((DistToEnemy > SprintWithinEnemyRange.X) && DistToEnemy < SprintWithinEnemyRange.Y)
            {
                return true;                
            }
            else
            {
                return false;
            }            
        }
        else
        {
            return false;
        }
    }
    if((MyKFPawn == none) || Enemy == none)
    {
        return false;
    }
    if((Enemy.Velocity Dot (Pawn.Location - Enemy.Location)) < 0)
    {
        if(!MyKFPawn.InAnyAttackTagRange(Enemy.Location, AttackTag))
        {
            return true;
        }        
    }
    else
    {
        if(!MyKFPawn.InAnyAttackTagRange(Enemy.Location, AttackTag) && VSize(Pawn.Location - Enemy.Location) > 300)
        {
            return true;
        }
    }
    if(VSize(Enemy.Location - Pawn.Location) <= 512)
    {
        return false;
    }
    return false;
}

function UpdateSprintFrustration(optional byte bForceFrustrationState)
{
    bForceFrustrationState = 255;
    if(FrustrationThreshold > 0)
    {
        if((bForceFrustrationState == 1) || (IsFrustrated()) && bForceFrustrationState != 0)
        {
            bCanSprint = true;            
        }
        else
        {
            bCanSprint = bDefaultCanSprint;
        }
    }
}

function bool IsFrustrated()
{
    if(MyAIDirector.bForceFrustration)
    {
        return true;
    }
    if(bForceFrustration)
    {
        return true;
    }
    if(((FrustrationThreshold > 0) && MyKFGameInfo.MyKFGRI != none) && MyKFGameInfo.MyKFGRI.AIRemaining <= FrustrationThreshold)
    {
        if(LastFrustrationCheckTime == float(0))
        {
            LastFrustrationCheckTime = WorldInfo.TimeSeconds;
        }
        if((WorldInfo.TimeSeconds - LastFrustrationCheckTime) >= FrustrationDelay)
        {
            return true;
        }
    }
    return false;
}

function NotifyCommandFinished(AICommand FinishedCommand);

function NotifyFleeFinished();

event NotifyFailMove(string Reason)
{
    AILog_Internal("NotifyFailMove, Reason: " $ Reason, 'PathWarning');
}

event NotifyPathChanged()
{
    AILog_Internal((string(GetFuncName()) $ "() Command: ") $ string(GetActiveCommand()), 'PathWarning');
}

function bool IsValidDirectMoveGoal(Actor A)
{
    if(ActorReachable(A))
    {
        return true;
    }
    return false;
}

final function SetFailedPathToEnemy(Pawn TestEnemy, optional float Offset)
{
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIMoveFailure(self, Pawn.Location, Pawn.Rotation, MoveGoal, "7 SetFailedpathToEnemy");
    }
    AILog_Internal((((string(GetFuncName()) $ "() TestEnemy: ") $ string(TestEnemy)) $ " Offset: ") $ string(Offset), 'PathWarning');
}

event bool AllowDetourTo(NavigationPoint N)
{
    return true;
}

event FindDirectPath()
{
    if(CachedAICommandList != none)
    {
        CachedAICommandList.FindDirectPath();
    }
    SetDirectPathCheckTime();
}

event bool HandlePathObstruction(Actor BlockedBy)
{
    local bool bResult;

    if((LastObstructionTime == 0) || (WorldInfo.TimeSeconds - LastObstructionTime) > 0.7)
    {
        LastObstructionTime = WorldInfo.TimeSeconds;
        AILog_Internal((string(GetFuncName()) @ string(BlockedBy)) @ string(WorldInfo.TimeSeconds - LastObstructionTime), 'HandlePathObstruction');
        if(CachedAICommandList != none)
        {
            bResult = CommandList.HandlePathObstruction(BlockedBy);
        }
    }
    return bResult;
}

function bool HandleZedBlockedPath();

event FailMove(string Reason)
{
    AILog_Internal((string(GetFuncName()) $ "() REASON: ") $ Reason, 'PathWarning');
}

event MoveUnreachable(Vector AttemptedDest, Actor AttemptedTarget)
{
    AILog_Internal(((string(GetFuncName()) $ "()") $ string(AttemptedDest)) @ string(AttemptedTarget), 'PathWarning');
    if(CachedAICommandList != none)
    {
        CachedAICommandList.MoveUnreachable(AttemptedDest, AttemptedTarget);
    }
    if(KfMovementPlugin != none)
    {
        KfMovementPlugin.MoveUnreachable(AttemptedDest, AttemptedTarget);
    }
}

event ForcePauseAndRepath(optional Actor InInstigator)
{
    bReevaluatePath = true;
    NotifyNeedRepath();
    Class'AICommand_Pause'.static.Pause(self, 0.25 + FRand());
}

function NotifyNeedRepath()
{
    AILog_Internal(string(GetFuncName()) $ "()", 'PathWarning');
    if(CachedAICommandList != none)
    {
        CachedAICommandList.NotifyNeedRepath();
    }
}

final function InvalidateAnchor(NavigationPoint Nav)
{
    local int Idx;

    Idx = InvalidAnchorList.Find('InvalidNav', Nav;
    AILog_Internal((string(GetFuncName()) @ string(Nav)) @ string(Idx), 'PathWarning');
    if(Idx < 0)
    {
        Idx = InvalidAnchorList.Length;
        InvalidAnchorList.Length = Idx + 1;
        InvalidAnchorList[Idx].InvalidNav = Nav;
        InvalidAnchorList[Idx].InvalidTime = WorldInfo.TimeSeconds;
        AILog_Internal(((string(GetFuncName()) $ " Invalidating anchor (") $ string(Nav)) $ ") - setting anchor to NONE", 'PathWarning');
        Pawn.SetAnchor(none);
    }
}

final function NavigationPoint GetFallbackAnchor()
{
    local NavigationPoint LastAnchor, ResultAnchor;
    local float AnchorDist;

    AILog_Internal(string(GetFuncName()) $ "() trying to get fallback anchor", 'PathWarning');
    if((Pawn.Anchor != none) && !Pawn.Anchor.bBlocked)
    {
        AILog_Internal(((string(GetFuncName()) $ "() setting Pawn anchor (") $ string(Pawn.Anchor)) $ ") to bBlocked to true!", 'PathWarning');
        LastAnchor = Pawn.Anchor;
        LastAnchor.bBlocked = true;
    }
    ResultAnchor = Pawn.GetBestAnchor(Pawn, Pawn.Location, true, true, AnchorDist);
    if(LastAnchor != none)
    {
        LastAnchor.bBlocked = false;
        if(LastAnchor == ResultAnchor)
        {
            AILog_Internal("ERROR! LastAnchor == ResultAnchor", 'PathWarning');
        }
    }
    if(ResultAnchor == none)
    {
        FailedToFindFallbackAnchor();
    }
    return ResultAnchor;
}

final function FailedToFindFallbackAnchor()
{
    AILog_Internal(string(self) $ " FailedToFindFallbackAnchor!", 'PathWarning');
    if(Pawn == none)
    {
        return;
    }
}

function bool IsNavInRouteCache(NavigationPoint Nav)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < RouteCache.Length)
    {
        if(RouteCache[I] == Nav)
        {
            return true;
        }
        ++ I;
        goto J0x0B;
    }
    return false;
}

event NotifyOnAddToRouteCache(NavigationPoint Nav);

event MayFall(bool bFloor, Vector FloorNormal)
{
    AILog_Internal((((((("MayFall Event! bFloor: " $ string(bFloor)) $ " Phys: ") $ string(Pawn.Physics)) $ " MoveTarget: ") $ string(MoveTarget)) $ " Reachable: ") $ string(ActorReachable(Enemy)), 'Falling');
    if(!bPlannedJump)
    {
        Pawn.JumpZ = 100;        
    }
    else
    {
        Pawn.JumpZ = Pawn.default.JumpZ;
    }
    Pawn.bCanJump = true;
}

event JumpedOverWall(Vector WallHitNormal, optional Actor Wall)
{
    AILog_Internal((((string(GetFuncName()) @ " WallHitNormal: ") @ string(WallHitNormal)) @ " Wall: ") @ string(Wall));
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIWall(2104, self, Pawn.Location, Pawn.Rotation, Wall, "HN: " $ string(WallHitNormal));
    }
}

function Timer_EnableJumpOverWalls()
{
    MyKFPawn.bCanJumpOverWalls = true;
}

function Vector GetDropEdgeLeapVelocity()
{
    return DropEdgeLeapVelocity;
}

function RecordLeapToWall();

function RecordHitWall(Actor Wall);

function bool NotifyBaseChange(Actor NewBase, Vector NewFloor)
{
    if(CachedAICommandList != none)
    {
        if(CachedAICommandList.NotifyBaseChange(NewBase, NewFloor))
        {
            return true;
        }
    }
    return false;
}

event bool NotifyLanded(Vector HitNormal, Actor FloorActor)
{
    AILog_Internal((((string(GetFuncName()) $ " - HitNormal: ") $ string(HitNormal)) $ " - FloorActor: ") $ string(FloorActor), 'LandedEvent');
    if(MyKFPawn != none)
    {
        MyKFPawn.BaseEyeHeight = MyKFPawn.default.BaseEyeHeight;
        Pawn.JumpZ = Pawn.default.JumpZ;
        if(bPreparingMove)
        {
            Pawn.Acceleration = vect(0, 0, 0);
        }
    }
    bPlannedJump = false;
    bNotifyApex = default.bNotifyApex;
    if(CachedAICommandList != none)
    {
        return CachedAICommandList.NotifyLanded(HitNormal, FloorActor);
    }
    return super(Controller).NotifyLanded(HitNormal, FloorActor);
}

event bool EnemyIsSurrounded()
{
    AILog_Internal(("EnemyIsSurrounded! (" $ string(Enemy)) $ ")", 'EnemyStatus');
    if(CachedAICommandList != none)
    {
        return CachedAICommandList.EnemyIsSurrounded();
    }
    return false;
}

function bool NotifyHuskSuicide(KFPawn_Monster Husk)
{
    return false;
    if(CachedAICommandList != none)
    {
        if(CachedAICommandList.NotifyHuskSuicide(Husk))
        {
            return true;
        }
    }
    if(!IgnoreNotifies())
    {
    }
    return false;
}

final function EnableNotifyHitWall()
{
    AILog_Internal(string(GetFuncName()) $ "() Enabling NotifyHitWall event", 'HitWall');
    Enable('NotifyHitWall');
}

final function DisableNotifyHitWall(optional float DisabledTime)
{
    DisabledTime = 0.2;
    Disable('NotifyHitWall');
    if(DisabledTime > 0)
    {
        SetTimer(DisabledTime, false, 'EnableNotifyHitWall');
    }
}

event bool NotifyHitWall(Vector HitNormal, Actor Wall)
{
    LastWallHitNormal = HitNormal;
    LastHitWall = Wall;
    LastNotifyHitWallTime = WorldInfo.TimeSeconds;
    AILog_Internal((((string(GetFuncName()) @ " Wall: ") @ string(Wall)) @ " HitNormal: ") @ string(HitNormal));
    if((MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove(11))
    {
        DisableNotifyHitWall(0.5);
        return true;
    }
    if(CachedAICommandList != none)
    {
        return CachedAICommandList.NotifyHitWall(HitNormal, Wall);        
    }
    else
    {
        DisableNotifyHitWall(0.2);
    }
    return super(Controller).NotifyHitWall(HitNormal, Wall);
}

event NotifyFallingHitWall(Vector HitNormal, Actor Wall)
{
    if(CachedAICommandList != none)
    {
        AILog_Internal(((("NotifyFallingHitWall: " $ string(Wall)) $ " - while I'm moving to goal, notifying ") $ string(CommandList)) $ " and letting it handle this event", 'HitWall');
        CachedAICommandList.NotifyFallingHitWall(HitNormal, Wall);
    }
}

final event EnableSeePlayer()
{
    AILog_Internal(string(GetFuncName()) $ "() Enabling SeePlayer event", 'SeePlayer');
    if(!bHasDebugCommand)
    {
        Enable('SeePlayer');
    }
}

final event DisableSeePlayer(optional float DisabledTime)
{
    AILog_Internal(((string(GetFuncName()) $ "() disabling SeePlayer polling for ") $ string(DisabledTime)) $ " seconds", 'SeePlayer');
    Disable('SeePlayer');
    if(DisabledTime > 0)
    {
        SetTimer(DisabledTime, false, 'EnableSeePlayer');
    }
}

final event EnableEnemyNotVisible()
{
    AILog_Internal(string(GetFuncName()) $ "() Enabling EnemyNotVisible event", 'EnemyNotVisible');
    Enable('EnemyNotVisible');
}

final event DisableEnemyNotVisible(optional float DisabledTime)
{
    DisabledTime = 2;
    AILog_Internal(((string(GetFuncName()) $ "() disabling EnemyNotVisible polling for ") $ string(DisabledTime)) $ " seconds", 'EnemyNotVisible');
    Disable('EnemyNotVisible');
    if(DisabledTime > 0)
    {
        SetTimer(DisabledTime, false, 'EnableEnemyNotVisible');
    }
}

function bool IsPawnVisibleViaTrace(Pawn PawnToCheck, optional bool bUsePawnRotation)
{
    local Vector TestLocation;
    local Rotator Rot;

    Rot = Pawn.Rotation;
    TestLocation = PawnToCheck.GetPawnViewLocation();
    if(!bUsePawnRotation)
    {
        Rot = rotator(PawnToCheck.Location - Pawn.Location);
    }
    return CanSeeByPoints(Pawn.Location, TestLocation, Rot);
}

final event EnableHearNoise()
{
    Enable('HearNoise');
    AILog_Internal(string(GetFuncName()) $ "() Enabled HearNoise event", 'HearNoise');
}

final event DisableHearNoise(optional float DisabledTime)
{
    DisabledTime = 1;
    if(DisabledTime <= 0)
    {
        DisabledTime = 1 + FRand();
    }
    AILog_Internal(((string(GetFuncName()) $ "() disabling noise hearing for ") $ string(DisabledTime)) $ " seconds", 'HearNoise');
    Disable('HearNoise');
    SetTimer(DisabledTime, false, 'EnableHearNoise');
}

function RecordBump(Actor Other)
{
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIBump(2101, self, Pawn.Location, Pawn.Rotation, Other, "SSpeed: " $ string(MyKFPawn.IsUsingSuperSpeed()));
    }
}

final event EnableBump()
{
    AILog_Internal(string(GetFuncName()) $ " Enabling Bump Events", 'BumpEvent');
    Enable('NotifyBump');
}

final event DisableBump(optional float DisabledTime)
{
    DisabledTime = 0.5;
    DisabledTime = FMax(0.1, DisabledTime);
    AILog_Internal(((string(GetFuncName()) $ "() disabling Bump polling for ") $ string(DisabledTime)) $ " seconds", 'BumpEvent');
    Disable('NotifyBump');
    if(DisabledTime > 0)
    {
        SetTimer(DisabledTime, false, 'EnableBump');
    }
}

simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    AILog_Internal((((((((string(GetFuncName()) $ " - Other: ") $ string(Other)) $ " OtherComp") $ string(OtherComp)) $ " - HitLocation: ") $ string(HitLocation)) $ " - HitNormal: ") $ string(HitNormal), 'TouchEvent');
    if(CachedAICommandList != none)
    {
        CachedAICommandList.NotifyTouch(Other, OtherComp, HitLocation, HitNormal);
    }
    if(KfMovementPlugin != none)
    {
    }
    super(Actor).Touch(Other, OtherComp, HitLocation, HitNormal);
}

simulated function Tick(float DeltaTime)
{
    super(Actor).Tick(DeltaTime);
    if((((bSpecialBumpHandling && Role == ROLE_Authority) && MyKFPawn != none) && MyKFPawn.Health >= 0) && !MyKFPawn.IsDoingSpecialMove())
    {
        SpecialBumpHandling(DeltaTime);
    }
    if((((Role == ROLE_Authority) && MyKFPawn != none) && MyKFPawn.Health > 0) && (((WorldInfo.TimeSeconds - LastStuckCheckTime) > StuckCheckInterval) && !MyKFPawn.IsDoingSpecialMove()) || (MyKFPawn.Physics == 2) && MyKFPawn.Velocity.Z == float(0))
    {
        EvaluateStuckPossibility(DeltaTime);
    }
    if((((((((bCanTeleportCloser && PendingDoor == none) && Role == ROLE_Authority) && MyKFPawn != none) && MyKFGameInfo.MyKFGRI != none) && MyKFPawn.Health > 0) && (WorldInfo.TimeSeconds - LastTeleportCheckTime) > TeleportCheckInterval) && !MyKFPawn.IsDoingSpecialMove()) && MyKFGameInfo.MyKFGRI.AIRemaining > FrustrationThreshold)
    {
        EvaluateTeleportPossibility(DeltaTime);
    }
}

function EvaluateTeleportPossibility(float DeltaTime)
{
    LastTeleportCheckTime = WorldInfo.TimeSeconds;
    if(((Enemy != none) && MyKFPawn != none) && MyKFPawn.IsUsingSuperSpeed())
    {
        if((((WorldInfo.TimeSeconds - MyKFPawn.LastLOSOrRelevantTime) > HiddenRelocateTeleportThreshold) && (WorldInfo.TimeSeconds - LastTeleportTime) > TeleportCooldown) && (WorldInfo.TimeSeconds - MyKFPawn.SpawnTime) > PostSpawnRelocateTeleportCooldown)
        {
            RelocateTeleport();
        }
    }
}

function EvaluateStuckPossibility(float DeltaTime)
{
    local float DistToEnemySquared;
    local Vector OldStuckCheckLocation;
    local bool bSeenRecently;
    local int I;

    LastStuckCheckTime = WorldInfo.TimeSeconds;
    OldStuckCheckLocation = LastStuckCheckLocation;
    LastStuckCheckLocation = Pawn.Location;
    if((MyKFPawn.Physics == 2) && MyKFPawn.Velocity.Z == float(0))
    {
        FallingStuckNoZVelocityTime += DeltaTime;
        MyKFPawn.Velocity = MyKFPawn.GroundSpeed * Normal(GetDestinationPosition() - MyKFPawn.Location);
        MyKFPawn.Acceleration = MyKFPawn.AccelRate * Normal(GetDestinationPosition() - MyKFPawn.Location);
        if(FallingStuckNoZVelocityTime < StuckCheckInterval)
        {
            return;
        }        
    }
    else
    {
        FallingStuckNoZVelocityTime = 0;
    }
    if((GetIsInZedVictoryState()) || (WorldInfo.GRI != none) && !WorldInfo.GRI.bMatchHasBegun)
    {
        StuckPossiblity = 0;
        bTryingToGetUnstuck = false;
        return;
    }
    if((WorldInfo.TimeSeconds - LastAttackTime_Melee) < 5)
    {
        StuckPossiblity = 0;
        bTryingToGetUnstuck = false;
        return;
    }
    if((WorldInfo.TimeSeconds - LastTeleportTime) < 5)
    {
        StuckPossiblity = 0;
        bTryingToGetUnstuck = false;
        return;
    }
    if((WorldInfo.TimeSeconds - LastSpecialMoveEndTime) < 5)
    {
        StuckPossiblity = 0;
        bTryingToGetUnstuck = false;
        return;
    }
    bSeenRecently = !MyKFPawn.IsUsingSuperSpeed();
    if(Enemy != none)
    {
        DistToEnemySquared = VSizeSq(Enemy.Location - Pawn.Location);
        if(DistToEnemySquared < StuckCheckEnemyDistThreshholdSquared)
        {
            if((MyKFGameInfo.MyKFGRI.AIRemaining > 5) || TotalStuckCheckCloseRangeTime < 5)
            {
                if(LastStuckCheckCloseRangeTime > 0)
                {
                    TotalStuckCheckCloseRangeTime += (WorldInfo.TimeSeconds - LastStuckCheckCloseRangeTime);
                }
                LastStuckCheckCloseRangeTime = WorldInfo.TimeSeconds;
                StuckPossiblity = 0;
                bTryingToGetUnstuck = false;
                return;
            }            
        }
        else
        {
            TotalStuckCheckCloseRangeTime = 0;
            LastStuckCheckCloseRangeTime = 0;
        }
    }
    if(((Enemy != none) && MoveTarget == Enemy) && RouteCache.Length <= 0)
    {
        StuckPossiblity = 0;
        bTryingToGetUnstuck = false;
        return;
    }
    I = 0;
    J0x551:

    if(I < RouteCache.Length)
    {
        if(RouteCache[I] != none)
        {
            if(((KFDoorMarker(RouteCache[I]) != none) && KFDoorMarker(RouteCache[I]).MyKFDoor.WeldedShut()) && VSizeSq2D(RouteCache[I].Location - Pawn.Location) < float(1000000))
            {
                StuckPossiblity = 0;
                bTryingToGetUnstuck = false;
                return;
            }
        }
        ++ I;
        goto J0x551;
    }
    if((MyKFPawn.Physics != 2) && VSizeSq2D(MyKFPawn.Velocity) < StuckVelocityThreshholdSquared)
    {
        if(!IsZero(OldStuckCheckLocation))
        {
            if(VSizeSq2D(Pawn.Location - OldStuckCheckLocation) > XYMoveStuckThresholdSquared)
            {
                StuckPossiblity = 0;
                bTryingToGetUnstuck = false;
                return;
            }            
        }
        else
        {
            StuckPossiblity = 0;
            bTryingToGetUnstuck = false;
            return;
        }
        StuckPossiblity += 0.5;
        if(StuckPossiblity > StuckPossiblityThreshhold)
        {
            StuckPossiblity = 0;
            HandleStuck();
            DumpCommandStack();
            DumpCommandHistory();            
        }        
    }
    else
    {
        if(MyKFPawn.Physics == 2)
        {
            if(MyKFPawn.Velocity.Z != float(0))
            {
                if(!IsZero(OldStuckCheckLocation))
                {
                    if(VSizeSq2D(Pawn.Location - OldStuckCheckLocation) < XYMoveStuckThresholdSquared)
                    {
                        if(bSeenRecently)
                        {
                            StuckPossiblity += 1;                            
                        }
                        else
                        {
                            StuckPossiblity += 0.5;
                        }
                        if(StuckPossiblity > StuckPossiblityThreshhold)
                        {
                            StuckPossiblity = 0;
                            HandleStuck();                            
                        }
                    }                    
                }
                else
                {
                    StuckPossiblity = 0;
                    bTryingToGetUnstuck = false;
                    return;
                }                
            }
            else
            {
                if(bSeenRecently)
                {
                    StuckPossiblity += 2;                    
                }
                else
                {
                    StuckPossiblity += 1;
                }
                if(StuckPossiblity > StuckPossiblityThreshhold)
                {
                    StuckPossiblity = 0;
                    HandleStuck();                    
                }
            }            
        }
        else
        {
            StuckPossiblity = 0;
            bTryingToGetUnstuck = false;
        }
    }
}

function HandleStuck()
{
    local bool bSeenRecently;

    if(!bTryingToGetUnstuck)
    {
        LastStuckTime = WorldInfo.TimeSeconds;
        bTryingToGetUnstuck = true;
    }
    DumpCommandStack();
    DumpCommandHistory();
    bSeenRecently = !MyKFPawn.IsUsingSuperSpeed();
    if(bSeenRecently)
    {
        if(AmIAllowedToSuicideWhenStuck())
        {
            StuckSuicide();            
        }
        else
        {
            if(StuckTeleportToPathNode())
            {                
            }
            else
            {
                if(StuckTeleportToSpawnVolume())
                {                    
                }
            }
        }        
    }
    else
    {
        if(StuckTeleportToSpawnVolume())
        {            
        }
        else
        {
            if(StuckTeleportToPathNode())
            {                
            }
            else
            {
                if(AmIAllowedToSuicideWhenStuck())
                {
                    StuckSuicide();                    
                }
            }
        }
    }
}

function StuckSuicide()
{
    if((MyKFGameInfo != none) && MyKFGameInfo.SpawnManager != none)
    {
        MyKFGameInfo.NumAISpawnsQueued -= 1;
        ++ MyKFGameInfo.MyKFGRI.AIRemaining;
        MyKFGameInfo.SpawnManager.LeftoverSpawnSquad[MyKFGameInfo.SpawnManager.LeftoverSpawnSquad.Length] = class<KFPawn_Monster>(Pawn.Class);
    }
    Pawn.Died(self, Class'DmgType_Suicided', Pawn.Location);
}

function bool StuckTeleportToSpawnVolume()
{
    local array< class<KFPawn_Monster> > AIToTeleport;
    local KFSpawnVolume KFSV;
    local KFAISpawnManager SpawnManager;
    local Vector TeleportLocation;

    AIToTeleport[AIToTeleport.Length] = MyKFPawn.Class;
    SpawnManager = MyKFGameInfo.SpawnManager;
    if(SpawnManager != none)
    {
        SpawnManager.DesiredSquadType = MyKFPawn.default.MinSpawnSquadSizeType;
        if((Enemy != none) && Enemy.Controller != none)
        {
            KFSV = SpawnManager.GetBestSpawnVolume(AIToTeleport, Enemy.Controller,, true);            
        }
        else
        {
            KFSV = SpawnManager.GetBestSpawnVolume(AIToTeleport,,, true);
        }
        if(KFSV != none)
        {
            TeleportLocation = KFSV.FindTeleportLocation(MyKFPawn.Class);
            if(!IsZero(TeleportLocation))
            {
                if(TeleportToLocation(TeleportLocation, Pawn.Rotation, false))
                {
                    KFSV.HandleTeleportedTo();
                    return true;
                }
            }
        }
    }
    return false;
}

function bool StuckTeleportToPathNode(optional float CheckRadius)
{
    local NavigationPoint ResNav;

    CheckRadius = 512;
    AILog_Internal(string(GetFuncName()));
    ResNav = Class'KFPathnode'.static.GetNearestValidFloorNavWithinRadiusToPawn(Pawn, CheckRadius);
    if((ResNav != none) && TeleportToLocation(ResNav.Location, Pawn.Rotation))
    {
        return true;
    }
    return false;
}

function RelocateTeleport()
{
    local array< class<KFPawn_Monster> > AIToTeleport;
    local KFSpawnVolume KFSV;
    local KFAISpawnManager SpawnManager;
    local Vector TeleportLocation;
    local float DistToEnemySquared;

    AIToTeleport[AIToTeleport.Length] = MyKFPawn.Class;
    SpawnManager = MyKFGameInfo.SpawnManager;
    if(SpawnManager != none)
    {
        SpawnManager.DesiredSquadType = MyKFPawn.default.MinSpawnSquadSizeType;
        if((Enemy != none) && Enemy.Controller != none)
        {
            DistToEnemySquared = VSizeSq(Pawn.Location - Enemy.Location);
            KFSV = SpawnManager.GetBestSpawnVolume(AIToTeleport, Enemy.Controller,, true, DistToEnemySquared);
        }
        if(KFSV != none)
        {
            TeleportLocation = KFSV.FindTeleportLocation(MyKFPawn.Class);
            if(!IsZero(TeleportLocation))
            {
                if(TeleportToLocation(TeleportLocation, Pawn.Rotation, false))
                {
                    KFSV.HandleTeleportedTo();
                    LastTeleportTime = WorldInfo.TimeSeconds;
                    return;
                }
            }
        }
    }
}

function bool ShouldReduceZedOnZedCollisionOnBumpForNavigating()
{
    local float DistToEnemySquared;

    if(Enemy != none)
    {
        DistToEnemySquared = VSizeSq(Enemy.Location - Pawn.Location);
        if(bEnemyIsVisible || LineOfSightTo(Enemy))
        {
            if(DistToEnemySquared < NavigationBumpTeamCollisionThreshholdSquared)
            {
                return false;
            }
        }
    }
    if(MyKFPawn != none)
    {
        if(MyKFPawn.IsUsingSuperSpeed())
        {
            return true;
        }
        if(StuckPossiblity > (StuckPossiblityThreshhold * 0.5))
        {
            return true;
        }
    }
    return false;
}

simulated function SpecialBumpHandling(float DeltaTime)
{
    local float Delta;
    local Vector upvect;

    if((MyKFPawn.CurrentChokePointTrigger == none) && !ShouldReduceZedOnZedCollisionOnBumpForNavigating())
    {
        if(MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive)
        {
            AILog_Internal(string(GetFuncName()) @ " does not have a CurrentChokePointTrigger so turning turn collision on", 'SpecialBumpHandling');
            RestoreCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy();
        }        
    }
    else
    {
        if(bBumpedThisFrame)
        {
            Delta = FMax(0.7, Abs(BumpThreshold - CurBumpVal));
            CurBumpVal = FInterpTo(CurBumpVal, BumpThreshold * 5.01, DeltaTime, BumpGrowthRate / Delta);
            if(CurBumpVal > 0.3)
            {
                AILog_Internal((((string(GetFuncName()) @ " CurBumpVal: ") @ string(CurBumpVal)) @ " Has Gotten High enough to turn collision off - lastbumper: ") @ string(LastBumper), 'SpecialBumpHandling');
                if((MyKFPawn.CurrentChokePointTrigger != none) && MyKFPawn.CurrentChokePointTrigger.PartialReduceTeammateCollision())
                {
                    ReduceCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy(true);                    
                }
                else
                {
                    ReduceCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy();
                }
            }
            bBumpedThisFrame = false;            
        }
        else
        {
            if(CurBumpVal > 0.01)
            {
                CurBumpVal = FInterpTo(CurBumpVal, 0, DeltaTime, BumpDecayRate / FMax(CurBumpVal, 0.1));                
            }
            else
            {
                if(MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive)
                {
                    AILog_Internal((((string(GetFuncName()) @ " CurBumpVal: ") @ string(CurBumpVal)) @ " Has Gotten low enough to turn collision on - LastBumper: ") @ string(LastBumper), 'SpecialBumpHandling');
                    RestoreCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy();
                }
            }
        }
    }
    if(bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState && MyKFPawn != none)
    {
        upvect.X = 0;
        upvect.Y = 0;
        upvect.Z = MyKFPawn.CylinderComponent.CollisionHeight;
        if(MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive)
        {
            DrawDebugCylinder(MyKFPawn.Location + upvect, MyKFPawn.Location - upvect, MyKFPawn.CylinderComponent.CollisionRadius * MyKFPawn.TeammateCollisionRadiusPercent, 10, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn.R, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn.G, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn.B, false);            
        }
        else
        {
            DrawDebugCylinder(MyKFPawn.Location + upvect, MyKFPawn.Location - upvect, MyKFPawn.CylinderComponent.CollisionRadius * MyKFPawn.TeammateCollisionRadiusPercent, 10, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff.R, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff.G, ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff.B, false);
        }
    }
}

function ReduceCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy(optional bool bPartialReduction)
{
    if((MyKFPawn != none) && MyKFPawn.Health > 0)
    {
        if(!MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive)
        {
            if(bPartialReduction)
            {
                MyKFPawn.TeammateCollisionRadiusPercent = 0.4;                
            }
            else
            {
                MyKFPawn.TeammateCollisionRadiusPercent = MyKFPawn.TeammateCollisionRadiusPercent / MyKFPawn.CylinderComponent.CollisionRadius;
            }
            AILog_Internal((((string(GetFuncName()) @ " - CollisionRadiusBeforeReducedZedOnZedPinchPointCollisionState: ") @ string(MyKFPawn.default.TeammateCollisionRadiusPercent)) @ " - CollisionCylinderReducedPercentForSameTeamCollision: ") @ string(MyKFPawn.TeammateCollisionRadiusPercent), 'CollisionToggle');
            MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive = true;
        }
    }
}

function RestoreCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy()
{
    if((MyKFPawn != none) && MyKFPawn.Health > 0)
    {
        MyKFPawn.TeammateCollisionRadiusPercent = MyKFPawn.default.TeammateCollisionRadiusPercent;
        MyKFPawn.bReducedZedOnZedPinchPointCollisionStateActive = false;
        AILog_Internal((((string(GetFuncName()) @ " - CollisionRadiusBeforeReducedZedOnZedPinchPointCollisionState: ") @ string(MyKFPawn.default.TeammateCollisionRadiusPercent)) @ " - CollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy: ") @ string(MyKFPawn.TeammateCollisionRadiusPercent), 'CollisionToggle');        
    }
    else
    {
        AILog_Internal(string(GetFuncName()) @ " MyKFPawn == None || MyKFPawn.Health <= 0 ", 'CollisionToggle');
    }
}

function int GetMostRecentDamageHistoryIndexFor(Pawn CheckKFP)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < DamageHistory.Length)
    {
        if(DamageHistory[I].DamagerController != none)
        {
            if(DamageHistory[I].DamagerController == CheckKFP.Controller)
            {
                return I;
            }
        }
        ++ I;
        goto J0x0B;
    }
    return -1;
}

function int RecentDamageFrom(Pawn CheckKFP, optional out int DamageAmount)
{
    local int I;

    I = 0;
    J0x0C:

    if(I < DamageHistory.Length)
    {
        if(DamageHistory[I].DamagerController != none)
        {
            if(DamageHistory[I].DamagerController == CheckKFP.Controller)
            {
                DamageAmount += int(DamageHistory[I].Damage);
            }
        }
        ++ I;
        goto J0x0C;
    }
    return DamageAmount;
}

event SeePlayer(Pawn Seen)
{
    local float DistToEnemy, DistToSeen;

    if(TimeFirstSawPlayer == float(0))
    {
        TimeFirstSawPlayer = WorldInfo.TimeSeconds;
    }
    if(MyKFPawn != none)
    {
        if(!MyKFPawn.IsAliveAndWell())
        {
            DisableSeePlayer(0);            
        }
        else
        {
            if(MyKFPawn.IsDoingSpecialMove(11))
            {
                DisableSeePlayer(0);
                return;
            }
        }
    }
    if(Enemy == Seen)
    {
        CachedVisibleEnemy = Enemy;
        EnemyVisibilityTime = WorldInfo.TimeSeconds;
        bEnemyIsVisible = true;
        EnableEnemyNotVisible();
        if((MyKFPawn != none) && MyKFPawn.IsAliveAndWell())
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.CheckSpotMonsterDialog(Enemy, MyKFPawn);
            }
            if(Enemy == Seen)
            {
                if((LastEnemySightedTime == float(0)) || (WorldInfo.TimeSeconds - LastEnemySightedTime) > RepeatWalkingTauntTime)
                {
                    if(MyKFPawn.CanDoSpecialMove(14))
                    {
                        MyKFPawn.DoSpecialMove(14);
                    }
                }
                LastEnemySightedTime = WorldInfo.TimeSeconds;
            }
        }
        return;
    }
    if((Enemy != none) && Enemy != Seen)
    {
        if((((KFPawn(Seen) != none) && KFPawn(Seen).IsDoingSpecialMove(28)) && (NumberOfZedsTargetingPawn(Seen)) <= 3) && !bEnemyIsVisible)
        {
            SetEnemy(Seen);            
        }
        else
        {
            if(LineOfSightTo(Seen) && !bEnemyIsVisible)
            {
                SetEnemy(Seen);                
            }
            else
            {
                if(CanSee(Seen))
                {
                    DistToEnemy = VSize(Enemy.Location - Pawn.Location);
                    DistToSeen = VSize(Seen.Location - Pawn.Location);
                    if((DistToEnemy > (StrikeRange * 1.5)) && DistToEnemy > (1.7 * DistToSeen))
                    {
                        SetEnemy(Seen);
                    }
                }
            }
        }        
    }
    else
    {
        SetEnemy(Seen);
    }
    if(Enemy == Seen)
    {
        LastEnemySightedTime = WorldInfo.TimeSeconds;
    }
    if(CachedAICommandList != none)
    {
        AILog_Internal(((("SeePlayer: " $ string(Seen)) $ " - while I'm moving to goal, notifying ") $ string(CommandList)) $ " and letting it handle this event", 'SeePlayer');
        CachedAICommandList.NotifyPlayerBecameVisible(Seen);
    }
}

event EnemyNotVisible()
{
    if(CommandList != none)
    {
        AILog_Internal(((string(GetFuncName()) $ "() - notifying ") $ string(CommandList)) $ " and letting it handle this event", 'EnemyNotVisible');
        AICommand(CommandList).NotifyEnemyNotVisible();
    }
    if((Enemy != none) && MyKFPawn != none)
    {
        MyKFPawn.ClearHeadTrackTarget(Enemy);
    }
    if(bEnemyIsVisible)
    {
        FindNewEnemy();
    }
    bEnemyIsVisible = false;
    DisableEnemyNotVisible();
    EnableSeePlayer();
    bWasVisibleToEnemy = bIsVisibleToEnemy;
    bIsVisibleToEnemy = false;
}

event HearNoise(float Loudness, Actor NoiseMaker, optional name NoiseType)
{
    return;
    DisableHearNoise();
    if(CachedAICommandList != none)
    {
        if(CachedAICommandList.NotifyHearNoise(Loudness, NoiseMaker, NoiseType))
        {
            return;
        }
    }
    AILog_Internal(((((((((string(self) $ " HearNoise event, Loudness: ") $ string(Loudness)) $ " NoiseMaker: ") $ string(NoiseMaker)) $ " Type: ") $ string(NoiseType)) $ " Dist: ") $ string(VSize(NoiseMaker.Location - Pawn.Location))) $ "... Disabling HearNoise", 'HearNoise');
    DisableHearNoise();
}

event bool NotifyBump(Actor Other, Vector HitNormal)
{
    local AICommand_HeadlessWander HeadlessWander;
    local KFPawn_Monster KFPM;
    local bool bInPartialCollisionReductionTrigger;
    local Actor HitActor;
    local Vector HitLocation, MyHitNormal;

    if((MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove(11))
    {
        DisableBump(0.25);
        return true;
    }
    KFPM = KFPawn_Monster(Other);
    if(bSpecialBumpHandling)
    {
        if(((((((MyKFPawn != none) && KFPM != none) && KFPM.Health > 0) && !KFPM.IsDoingSpecialMove(1)) && KFPM.MyKFAIC != none) && KFPM.MyKFAIC.DoorEnemy == none) && !IsZero(KFPM.Acceleration))
        {
            bInPartialCollisionReductionTrigger = (MyKFPawn.CurrentChokePointTrigger != none) && MyKFPawn.CurrentChokePointTrigger.PartialReduceTeammateCollision();
            if((MyKFPawn.CurrentChokePointTrigger != none) && (MyKFPawn.CurrentChokePointTrigger.CanReduceTeammateCollision() || bInPartialCollisionReductionTrigger) || ShouldReduceZedOnZedCollisionOnBumpForNavigating())
            {
                if(bInPartialCollisionReductionTrigger && Enemy != none)
                {
                    HitActor = Trace(HitLocation, MyHitNormal, Enemy.Location + (vect(0, 0, 1) * Enemy.BaseEyeHeight), MyKFPawn.Location + (vect(0, 0, 1) * MyKFPawn.BaseEyeHeight), true);
                }
                if(!IsWithinAttackRange() || bInPartialCollisionReductionTrigger && (HitActor == none) || HitActor != Enemy)
                {
                    bBumpedThisFrame = true;
                    LastBumper = KFPM;
                    return true;                    
                }
                else
                {
                    AILog_Internal(((string(GetFuncName()) @ " Bumped: ") @ string(KFPM)) @ " but IsWithinAttackRange so not going to care about SpecialBumpHandling right now!!!", 'SpecialBumpHandling');
                }                
            }
            else
            {
                AILog_Internal(((string(GetFuncName()) @ " Bumped: ") @ string(KFPM)) @ " but not in a door trigger so not going to care about SpecialBumpHandling right now!!!", 'SpecialBumpHandling');
            }
        }
    }
    DisableBump(0.25);
    if((MyKFPawn != none) && MyKFPawn.Physics == 2)
    {
        return false;
    }
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIBump(2101, self, Pawn.Location, Pawn.Rotation, Other, "SSpeed: " $ string(((MyKFPawn != none) ? MyKFPawn.IsUsingSuperSpeed() : false)));
    }
    AILog_Internal((((("NotifyBump() into " $ string(Other)) $ " HitNormal: ") $ string(HitNormal)) $ " MoveTarget: ") $ ((MoveTarget != none) ? string(MoveTarget) : "none"), 'BumpEvent');
    DisableBump(0.25);
    LastBumpedPawn = Pawn(Other);
    if((((MyKFPawn != none) && MyKFPawn.bPlayShambling) && LastBumpedPawn != none) && LastBumpedPawn.IsAliveAndWell())
    {
        HeadlessWander = AICommand_HeadlessWander(GetActiveCommand());
        DisableBump(0.3);
        if(((HeadlessWander != none) && !MyKFPawn.IsDoingSpecialMove()) && (WorldInfo.TimeSeconds - HeadlessWander.LastHeadlessAttackTime) > 2.5)
        {
            UpdatePendingStrike();
            DoStrike();
        }
    }
    if(CachedAICommandList != none)
    {
        AILog_Internal(((("Bump: " $ string(Other)) $ " - notifying ") $ string(CommandList)) $ " and letting it handle this event", 'BumpEvent');
        if(CachedAICommandList.NotifyBump(Other, HitNormal))
        {
            return true;
        }
    }
    if(KfMovementPlugin != none)
    {
    }
    if((Role == ROLE_Authority) && bCanDoHeavyBump)
    {
        DoHeavyZedBump(Other, HitNormal);
    }
    if((((LastBumpedPawn == none) || Pawn.IsSameTeam(LastBumpedPawn)) || !LastBumpedPawn.IsAliveAndWell()) || (Enemy != none) && Enemy == Other)
    {
        return false;
    }
    if(SetEnemy(LastBumpedPawn))
    {
        return false;
    }
    return false;
}

function DrawFireAttackDebug()
{
    DirectProjectileFireBehavior.DrawFireAttackDebug();
    LeapBehavior.DrawFireAttackDebug();
}

function NotifyMeleeDamageDealt();

function SpecialMoveTimeout();

function NotifySpecialMoveEnded(KFSpecialMove SM)
{
    local LatentActionObserver ObserverInterface;

    AILog_Internal(string(SM) @ "finished", 'SpecialMove');
    ObserverInterface = LatentActionObserver(SM.AISpecialOwner);
    if(NotEqual_InterfaceInterface(ObserverInterface, (none)))
    {
        ObserverInterface.OnLatentFinished(self, SM, 3);
    }
    LastSpecialMoveEndTime = WorldInfo.TimeSeconds;
}

simulated function StartSteering()
{
    if(Steering != none)
    {
        AILog_Internal(string(GetFuncName()) $ "() turning on separation steering, separating from class KFPawn_Monster", 'AISteering');
        Steering.SeparationOn(Class'KFPawn_Monster');
    }
}

// Export UKFAIController::execDumpCommandHistory(FFrame&, void* const)
native function DumpCommandHistory();

// Export UKFAIController::execDrawDebugText(FFrame&, void* const)
native static function DrawDebugText(HUD HUD, string Text, optional Color TextColor);

function DrawDebugTextToHud(HUD HUD, string Text, optional Color TextColor)
{
    DrawDebugText(HUD, Text, TextColor);
}

function SetupDebug()
{
    local KFAIDirector Director;

    if(MyKFGameInfo != none)
    {
        Director = MyKFGameInfo.GetAIDirector();
        if(Director != none)
        {
            bDebug_PostRenderInfo = (((bDebug_DrawOverheadInfo || Director.bShowAINames) || bDebug_DrawAttackAnimInfo) || bDebug_DrawAIDebug) || (MyKFPawn != none) && MyKFPawn.bDebug_DrawSprintingOverheadInfo;
            if(Director.bShowAINames)
            {
                bDebug_DrawOverheadInfo = true;
                MyKFPawn.SetDebugTextRendering(true);
            }
        }
    }
    if(!IsTimerActive('Debug_CheckRecentMoveTime'))
    {
        SetTimer(20 + FRand(), true, 'Debug_CheckRecentMoveTime');
    }
}

function bool IsInDebugMode()
{
    local GameAICommand Cmd;
    local AICommand_Debug DebugCommand;

    Cmd = CommandList;
    J0x13:

    if(Cmd != none)
    {
        DebugCommand = AICommand_Debug(Cmd);
        if(DebugCommand != none)
        {
            return true;
        }
        Cmd = Cmd.ChildCommand;
        goto J0x13;
    }
    return false;
}

event SetRecentActionInfo(string Info)
{
    RecentActionInfo = ((("[" $ string(GetStateName())) $ "][") $ Info) $ "]";
}

simulated function OnDestroy(SeqAct_Destroy Action)
{
    if(Pawn != none)
    {
        Pawn.OnDestroy(Action);
    }
    super(Actor).OnDestroy(Action);
}

event msg(string MsgTxt, optional bool bOutputToLog, optional name MessageType, optional float MessageDuration)
{
    bOutputToLog = true;        
    if(MyKFPawn != none)
    {
        MyKFPawn.KFMessagePlayer(MsgTxt, MessageType, MessageDuration);
        if(bOutputToLog)
        {
            AILog_Internal(MsgTxt, 'msg');
        }
    }
}

event AILog_Internal(coerce string LogText, optional name LogCategory, optional bool bForce, optional bool BugIt, optional bool bSkipExtraInfo);

function AIBugItStringCreator(const out Vector ViewLocation, const out Rotator ViewRotation, out string GoString, out string LocString)
{
    GoString = (((((((((("BugItGo " $ string(ViewLocation.X)) $ " ") $ string(ViewLocation.Y)) $ " ") $ string(ViewLocation.Z)) $ " ") $ string(ViewRotation.Pitch)) $ " ") $ string(ViewRotation.Yaw)) $ " ") $ string(ViewRotation.Roll);
    LocString = (("?BugLoc=" $ string(ViewLocation)) $ "?BugRot=") $ string(ViewRotation);
}

event PauseAndShowMsg(optional string MsgTxt, optional Vector TeleportToLocation)
{
    local PlayerController PC;
    local DebugCameraController DCC;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        PC.ClientMessage(MsgTxt);
        if(!WorldInfo.bPlayersOnly && !WorldInfo.bPlayersOnlyPending)
        {
            PC.CheatManager.PlayersOnly();
            break;
        }        
    }    
    if(TeleportToLocation != vect(0, 0, 0))
    {
        foreach WorldInfo.AllControllers(Class'DebugCameraController', DCC)
        {
            DCC.SetLocation(TeleportToLocation);            
        }        
    }
}

function ScreenMessagePlayer(coerce string msg)
{
    local PlayerController PC;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        PC.ClientMessage(msg);        
    }    
}

function KFDebugLines GetDebugLines()
{
    return Class'KFDebugLines'.static.GetDebugLines();
}

function KFDebug_ClearLines(optional int Id)
{
    Class'KFDebugLines'.static.KFDebug_ClearLines(Name, Id);
}

function KFDebug_ClearSpheres(optional int Id)
{
    Class'KFDebugLines'.static.KFDebug_ClearSpheres(Name, Id);
}

function KFDebug_ClearDebugText(optional int Id)
{
    Class'KFDebugLines'.static.KFDebug_ClearText(Name, Id);
}

function KFDebug_DrawPath(optional int Id)
{
    local KFDebugLines KFDL;

    return;
    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.AddDebugLineFromOwner(Name, MoveTarget.Location, 0, 255, 0, false, 20, Id);
        KFDL.AddDebugSphere(MoveTarget.Location, 16, 8, 0, 100, 100, false, 20, Name, Id);
    }
}

function KFDebug_DrawMyPath()
{
    local KFDebugLines KFDL;
    local int I;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.RemoveOwnedDebugLines(Name);
        KFDL.RemoveOwnedDebugSpheres(Name);
        KFDL.RemoveOwnedDebugText3D(Name);
        I = 0;
        J0xA9:

        if(I < RouteCache.Length)
        {
            if(I < (RouteCache.Length - 1))
            {
                KFDL.AddDebugLine(RouteCache[I].Location, RouteCache[I + 1].Location, 113, 167, 207, false, 20, Name, I);
            }
            KFDL.AddDebugSphere(RouteCache[I].Location, 24, 8, 113, 167, 207, true,, Name, I);
            KFDL.AddDebugText3D(RouteCache[I].Location + vect(0, 0, 32), string(RouteCache[I]), true, 113, 167, 207, true,,,, Name, I);
            ++ I;
            goto J0xA9;
        }
    }
}

function KFDebug_DrawPathTo(Actor A, optional int Id, optional int SecondaryID, optional int TextID)
{
    local KFDebugLines KFDL;

    if(bDebug_DrawPath)
    {
        KFDL = GetDebugLines();
        if(KFDL != none)
        {
            KFDL.AddDebugLineFromOwner(Name, A.Location, 113, 167, 207, false, 45, Id);
            KFDL.AddDebugSphere(A.Location, 16, 8, 113, 167, 207, false, 45, Name, Id);
            KFDL.AddDebugLineFromOwner(Name, MoveGoal.Location, 126, 250, 85, false, 45, SecondaryID);
            KFDL.AddDebugSphere(MoveGoal.Location, 16, 8, 125, 250, 85, false, 45, Name, SecondaryID);
            KFDL.AddDebugText3D(A.Location + vect(0, 0, 32), string(A), true, 113, 167, 207, false, 45, A,, Name, Id);
        }
    }
}

function KFDebug_DrawPathGoal(optional int Id)
{
    local KFDebugLines KFDL;

    return;
    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.AddDebugLineFromOwner(Name, MoveGoal.Location, 0, 255, 0, false, 45, Id);
        KFDL.AddDebugSphere(MoveGoal.Location, 16, 8, 0, 100, 100, false, 45, Name, Id);
    }
}

// Export UKFAIController::execLogToProfiler(FFrame&, void* const)
native function LogToProfiler(string Text, name Category);

function ShowStuckNpcsToggle()
{
    if(IsTimerActive('Debug_CheckStuckTimer'))
    {
        ClearTimer('Debug_CheckStuckTimer');        
    }
    else
    {
        LocationAtStartOfStuckCheck = MyKFPawn.Location;
        LocationAtLastStuckCheck = MyKFPawn.Location;
        SetTimer(1, true, 'Debug_CheckStuckTimer');
    }
}

function Debug_CheckStuckTimer()
{
    local Vector displacementFromStartOfCheck;
    local float distanceFromStartOfCheck;
    local Vector displacementFromLastStuckUpdate;
    local float distanceFromLastStuckUpdate;

    displacementFromStartOfCheck = MyKFPawn.Location - LocationAtStartOfStuckCheck;
    distanceFromStartOfCheck = VSize(displacementFromStartOfCheck);
    displacementFromLastStuckUpdate = MyKFPawn.Location - LocationAtLastStuckCheck;
    distanceFromLastStuckUpdate = VSize(displacementFromLastStuckUpdate);
    LocationAtLastStuckCheck = MyKFPawn.Location;
    if(distanceFromStartOfCheck < 1)
    {
        DrawDebugLine(MyKFPawn.Location, Enemy.Location, 255, 0, 0, true);        
    }
    else
    {
        if(distanceFromLastStuckUpdate < 1)
        {
            DrawDebugLine(MyKFPawn.Location, Enemy.Location, 255, 255, 0, true);
        }
    }
}

function float GetMaxTimeAllowedToStayStuckBasedOnStuckType(KFAiBehaviorTypes.MOVE_FAILURE_TYPE TypeOfFailure)
{
    local float maxTime;

    if(TypeOfMovementStuckOn == 1)
    {
        maxTime = NoNavMeshPathMaxTimeAllowedToStayStuckBeforeSuicide;        
    }
    else
    {
        if(TypeOfMovementStuckOn == 2)
        {
            maxTime = SameIntermediatePointToManyTimesMaxTimeAllowedToStayStuckBeforeSuicide;            
        }
        else
        {
            if(TypeOfMovementStuckOn == 3)
            {
                maxTime = TargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTooMaxTimeAllowedToStayStuckBeforeSuicide;                
            }
            else
            {
                maxTime = DefaultMaxTimeAllowedToStayStuckBeforeSuicide;
            }
        }
    }
    return maxTime;
}

function ToggleHardCoreStuckNpcs(AICommand CmdTriggering, AITickablePlugin PlugInTriggering)
{
    local float timeToTrip;

    if(IsTimerActive('HardCoreCheckStuckTimer'))
    {
        ClearTimer('HardCoreCheckStuckTimer');
        CmdTriggeringHardCoreStuckChecking = none;
        PlugInTriggeringTriggeringHardCoreStuckChecking = none;        
    }
    else
    {
        if(MyKFPawn != none)
        {
            LocationAtStartOfStuckCheck = MyKFPawn.Location;
            LocationAtLastStuckCheck = MyKFPawn.Location;
            CmdTriggeringHardCoreStuckChecking = CmdTriggering;
            PlugInTriggeringTriggeringHardCoreStuckChecking = PlugInTriggering;
            timeToTrip = GetMaxTimeAllowedToStayStuckBasedOnStuckType(TypeOfMovementStuckOn);
            SetTimer(timeToTrip, true, 'HardCoreCheckStuckTimer');
        }
    }
}

function float GetMinDistaceToHaveToMoveToBeConcideredStuckByStuckType(KFAiBehaviorTypes.MOVE_FAILURE_TYPE TypeOfFailure)
{
    local float MinDistance;

    if(TypeOfMovementStuckOn == 1)
    {
        MinDistance = NoNavMeshPathMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;        
    }
    else
    {
        if(TypeOfMovementStuckOn == 2)
        {
            MinDistance = SameIntermediatePointToManyTimesMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;            
        }
        else
        {
            MinDistance = DefaultMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;
        }
    }
    return MinDistance;
}

function HardCoreCheckStuckTimer()
{
    local Vector displacementFromStartOfCheck;
    local float distanceFromStartOfCheck;
    local Vector displacementFromLastStuckUpdate;
    local float distanceFromLastStuckUpdate;
    local Color stuckLineColor;
    local float minDistanceToMove;

    displacementFromStartOfCheck = MyKFPawn.Location - LocationAtStartOfStuckCheck;
    distanceFromStartOfCheck = VSize(displacementFromStartOfCheck);
    displacementFromLastStuckUpdate = MyKFPawn.Location - LocationAtLastStuckCheck;
    distanceFromLastStuckUpdate = VSize(displacementFromLastStuckUpdate);
    LocationAtLastStuckCheck = MyKFPawn.Location;
    minDistanceToMove = GetMinDistaceToHaveToMoveToBeConcideredStuckByStuckType(TypeOfMovementStuckOn);
    if(distanceFromStartOfCheck <= minDistanceToMove)
    {
        if(bShowVisualStuckZedDebugInfo)
        {
            if(TypeOfMovementStuckOn == 1)
            {
                stuckLineColor = Move_failure_type_no_nav_mesh_path_color;                
            }
            else
            {
                if(TypeOfMovementStuckOn == 2)
                {
                    stuckLineColor = Move_failure_type_same_intermediate_point_too_many_times_color;                    
                }
                else
                {
                    if(TypeOfMovementStuckOn == 3)
                    {
                        stuckLineColor = MoveFailureTypeTargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTo;                        
                    }
                    else
                    {
                        stuckLineColor = Move_failure_type_none_color;
                    }
                }
            }
            DrawDebugLine(MyKFPawn.Location, Enemy.Location, stuckLineColor.R, stuckLineColor.G, stuckLineColor.B, true);
        }
        if(CmdTriggeringHardCoreStuckChecking != none)
        {
            CmdTriggeringHardCoreStuckChecking.NotifyNpcTerminallyStuck();            
        }
        else
        {
            if(PlugInTriggeringTriggeringHardCoreStuckChecking != none)
            {
                PlugInTriggeringTriggeringHardCoreStuckChecking.NotifyNpcTerminallyStuck();
            }
        }        
    }
    else
    {
        if(distanceFromLastStuckUpdate <= minDistanceToMove)
        {
            if(bShowVisualStuckZedDebugInfo)
            {
                DrawDebugLine(MyKFPawn.Location, Enemy.Location, 255, 255, 0, true);
            }
            if(CmdTriggeringHardCoreStuckChecking != none)
            {
                CmdTriggeringHardCoreStuckChecking.NotifyNpcInGrannyMode();                
            }
            else
            {
                if(PlugInTriggeringTriggeringHardCoreStuckChecking != none)
                {
                    PlugInTriggeringTriggeringHardCoreStuckChecking.NotifyNpcInGrannyMode();
                }
            }
        }
    }
}

function bool AmIAllowedToSuicideWhenStuck()
{
    return true;
}

function bool AmIAllowedToStillUsePathNodes()
{
    return false;
}

function Debug_CheckRecentMoveTime();

event Debug_AIPaused(bool bNewPause)
{
    if(bNewPause)
    {
        AbortMovementCommands();
        AbortMovementPlugIns();
        Pawn.ZeroMovementVariables();
        StopAllLatentMovement();
    }
}

function DumpStack()
{
    DumpCommandStack();
}

function SetPostRendering(bool bOn)
{
    local PlayerController KFPC;
    local KFHUDBase KFHud;

    foreach LocalPlayerControllers(Class'PlayerController', KFPC)
    {
        KFHud = KFHUDBase(KFPC.myHUD);
        if(KFHud != none)
        {
            if(bOn)
            {
                bPostRenderIfNotVisible = true;
                KFHud.SetShowOverlays(true);
                KFHud.AddPostRenderedActor(self);
                continue;
            }
            bPostRenderIfNotVisible = default.bPostRenderIfNotVisible;
            KFHud.RemovePostRenderedActor(self);
        }        
    }    
}

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir)
{
    if(MyKFPawn != none)
    {
        MyKFPawn.PostRenderFor(PC, Canvas, CameraPosition, CameraDir);
    }
}

function DrawAttackInfo(KFHUDBase HUD)
{
    local Canvas C;
    local int I, X;
    local string DisplayString;
    local KFPawnAnimInfo KFPAG;
    local name CurrentSeq, InRangeTag;

    if(((!bDebug_DrawAttackAnimInfo || MyKFPawn == none) || MyKFPawn.PawnAnimInfo == none) || Enemy == none)
    {
        return;
    }
    if(MyKFPawn.PawnAnimInfo == none)
    {
        return;
    }
    C = HUD.Canvas;
    C.Font = Class'Engine'.static.GetTinyFont();
    C.SetDrawColor(255, 255, 255);
    C.SetPos(float(C.SizeX) * 0.05, float(C.SizeY) * 0.22);
    DrawDebugText(HUD, ((("ATTACK ANIMATION INFO FOR " $ string(Pawn.Name)) $ " (Controller: ") $ string(self)) $ ")");
    C.SetDrawColor(0, 0, 255, 255);
    DrawDebugText(HUD, "--------------------------------------------------------------------------");
    DrawDebugText(HUD, " ");
    KFPAG = MyKFPawn.PawnAnimInfo;
    if(MyKFPawn.InAnyAttackTagRange(Enemy.Location, InRangeTag))
    {
        C.SetDrawColor(255, 25, 0, 255);
        DrawDebugText(HUD, ("Distance From Enemy: " $ string(VSize(Pawn.Location - Enemy.Location))) $ "uu [WITHIN ATTACK RANGE]");
        C.SetDrawColor(0, 255, 50, 255);        
    }
    else
    {
        C.SetDrawColor(0, 255, 50, 255);
        DrawDebugText(HUD, ("Distance From Enemy: " $ string(VSize(Pawn.Location - Enemy.Location))) $ "uu");
    }
    if(MyKFPawn.IsDoingSpecialMove())
    {
        C.SetDrawColor(255, 25, 50, 255);
        DrawDebugText(HUD, ("[Doing Special Move: " $ string(MyKFPawn.SpecialMove)) $ "]");
    }
    C.SetDrawColor(0, 255, 50, 255);
    if(GetActiveCommand() != none)
    {
        DisplayString = ("[Active Command: " $ string(GetActiveCommand())) $ "]";
    }
    if(CommandList != none)
    {
        DisplayString = ((DisplayString $ " [CommandList: ") $ string(CommandList)) $ "]";
        if(CommandList.ChildCommand != none)
        {
            DisplayString = ((DisplayString $ " [ChildCommand: ") $ string(CommandList.ChildCommand)) $ "]";
            if(CommandList.ChildStatus != 'None')
            {
                DisplayString = ((DisplayString $ " [ChildStatus: ") $ string(CommandList.ChildStatus)) $ "]";
            }
        }
    }
    if(DisplayString != "")
    {
        DrawDebugText(HUD, DisplayString);
        DisplayString = "";
    }
    CurrentSeq = MyKFPawn.BodyStanceNodes[0].GetPlayedAnimation();
    if(CurrentSeq != 'None')
    {
        I = 0;
        J0x73E:

        if(I < KFPAG.Attacks.Length)
        {
            X = 0;
            J0x776:

            if(X < KFPAG.Attacks[I].Anims.Length)
            {
                if(CurrentSeq == KFPAG.Attacks[I].Anims[X])
                {
                    DisplayString = ((((((("[FULLBODY] Playing " $ string(CurrentSeq)) $ " [Tag ") $ string(KFPAG.Attacks[I].Tag)) $ "] [Min: ") $ string(KFPAG.Attacks[I].MinDistance)) $ "uu Max: ") $ string(KFPAG.Attacks[I].MaxDistance)) $ "uu]";
                    goto J0x949;
                }
                if(DisplayString != "")
                {
                    goto J0x949;
                }
                ++ X;
                goto J0x776;
            }
            J0x949:

            ++ I;
            goto J0x73E;
        }
        if(DisplayString != "")
        {
            DrawDebugText(HUD, DisplayString);
            DisplayString = "";
        }
    }
}

function bool IsDebugTextCategoryEnabled(name CategoryName)
{
    return (EnabledDebugTextCategories.Find('All' != -1) || EnabledDebugTextCategories.Find(CategoryName != -1;
}

simulated function DrawDebug(KFHUDBase HUD, name Category)
{
    local int CmdCnt;
    local Canvas C;
    local GameAICommand Cmd;
    local AICmdHistoryItem Item;
    local bool bDrawDebugCommandStack, bDrawDebugCommandHistory, bDrawDebugAllPlugins, bDrawDebugPlugInHistory;
    local string AddTxt, NullTxt;
    local AICommand AC;

    bDrawDebugCommandStack = false;
    bDrawDebugCommandHistory = false;
    bDrawDebugAllPlugins = false;
    if(((Category == 'Default') || Category == 'All') || Category == 'PlugIns')
    {
        bDrawDebugAllPlugins = true;
        bDrawDebugPlugInHistory = true;
    }
    NullTxt = "None";
    if((Pawn != none) && Category == 'All')
    {
        C = HUD.Canvas;
        C.SetOrigin(0, 0);
        C.Font = Class'Engine'.static.GetSmallFont();
        C.SetPos(float(C.SizeX) * 0.05, float(C.SizeY) * 0.25);
        if(bEnemyIsVisible)
        {
            DrawDebugText(HUD, "bEnemyIsVisible: " $ string(bEnemyIsVisible), MakeColor(0, 255, 0, 255));            
        }
        else
        {
            DrawDebugText(HUD, "bEnemyIsVisible: " $ string(bEnemyIsVisible));
        }
        if(bDrawDebugCommandStack)
        {
            C.SetDrawColor(255, 255, 255, 255);
            DrawDebugText(HUD, "************************************************************");
            C.SetDrawColor(0, 0, 255, 255);
            DrawDebugText(HUD, "COMMAND STACK");
            foreach AllCommands(Class'GameAICommand', Cmd)
            {
                if(Cmd.ChildCommand == none)
                {
                    C.SetDrawColor(225, 0, 0, 255);                    
                }
                else
                {
                    C.SetDrawColor(0, 255, 0, 255);
                }
                DrawDebugText(HUD, (string(Cmd.Name) @ ":") @ string(Cmd.GetStateName()));
                ++ CmdCnt;                
            }            
            if(CmdCnt == 0)
            {
                DrawDebugText(HUD, "NO COMMANDS ACTIVE");
            }
        }
        if(bDrawDebugCommandHistory)
        {
            DrawDebugText(HUD, "************************************************************");
            DrawDebugText(HUD, ("COMMAND HISTORY (Count:" @ string(CommandHistoryNum)) $ ")");
            CmdCnt = 0;
            foreach CommandHistory(Item,)
            {
                ++ CmdCnt;
                DrawDebugText(HUD, (((("Cmd" @ string(CmdCnt)) $ ":") @ string(Item.CmdClass)) @ "Time:") @ string(Item.TimeStamp));
                if(Len(Item.VerboseString) > 0)
                {
                    DrawDebugText(HUD, ".............." @ Item.VerboseString);
                }                
            }            
        }
        C.Font = Class'Engine'.static.GetSmallFont();
        if(MyKFPawn != none)
        {
            DrawDebugText(HUD, string(Pawn));
            AddTxt = "ActiveCommand: ";
            if(CachedAICommandList != none)
            {
                AC = CachedAICommandList;
                if(AC != none)
                {
                    AddTxt = AddTxt @ string(AC);
                    if(AC.CachedChildCommand != none)
                    {
                        AddTxt = (AddTxt @ "Child1: ") $ string(AC.CachedChildCommand);
                        if(AC.CachedChildCommand.CachedChildCommand != none)
                        {
                            AddTxt = (AddTxt @ "Child2: ") $ string(AC.CachedChildCommand.CachedChildCommand);
                        }
                    }
                }                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            DrawDebugText(HUD, AddTxt);
            if(IsDoingLatentMove())
            {
                DrawDebugText(HUD, "Latent Action: MOVE", MakeColor(200, 0, 0));                
            }
            else
            {
                DrawDebugText(HUD, "Latent Action: None");
            }
            DrawDebugText(HUD, AddTxt);
            DrawDebugText(HUD, (((((("Floor: " $ string(Pawn.Floor)) $ " DesiredRot: ") $ string(Pawn.DesiredRotation)) $ " PawnRot: ") $ string(Pawn.Rotation)) $ " KFAIC Rot: ") $ string(Rotation));
            DrawDebugText(HUD, (((("Velocity: " $ string(VSize(Pawn.Velocity))) $ " Accel: ") $ string(VSize(Pawn.Acceleration))) $ " Physics: ") $ Pawn.GetPhysicsName());
            DrawDebugText(HUD, (((("Direct Path: " $ string(bDirectMoveToGoal)) $ " bPreparingMove: ") $ string(bPreparingMove)) $ " GroundSpeed: ") $ string(Pawn.GroundSpeed));
            DrawDebugText(HUD, (((("bPreciseDest: " $ string(bPreciseDestination)) $ " bForceMaxAccel: ") $ string(MyKFPawn.bForceMaxAccel)) $ " MoveOffset: ") $ string(MoveOffset));
            AddTxt = "Anchor:";
            if(Pawn.Anchor != none)
            {
                AddTxt = AddTxt @ string(MyKFPawn.Anchor);                
            }
            else
            {
                AddTxt = AddTxt @ "None";
            }
            if(RouteCache.Length > 0)
            {
                AddTxt = (AddTxt @ " RouteCache[0]:") $ string(RouteCache[0]);
            }
            AddTxt = "SpecialMove:";
            if(MyKFPawn.IsDoingSpecialMove())
            {
                AddTxt = AddTxt @ string(MyKFPawn.SpecialMoves[MyKFPawn.SpecialMove]);                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            AddTxt = AddTxt @ "MoveTarget:";
            if(MoveTarget != none)
            {
                AddTxt = AddTxt @ string(MoveTarget);                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            AddTxt = AddTxt @ "Enemy:";
            if(Enemy != none)
            {
                AddTxt = AddTxt @ string(Enemy);                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            DrawDebugText(HUD, AddTxt);
            AddTxt = ((("Sprinting: " $ string(MyKFPawn.bIsSprinting)) $ " FocalPoint: ") $ string(GetFocalPoint())) $ " Focus:";
            if(Focus != none)
            {
                AddTxt = AddTxt @ string(Focus);                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            AddTxt = AddTxt @ ":";
            if(MyKFPawn.bIsHeadTrackingActive && MyKFPawn.MyLookAtInfo.LookAtTarget != none)
            {
                AddTxt = AddTxt @ string(MyKFPawn.MyLookAtInfo.LookAtTarget);                
            }
            else
            {
                AddTxt = AddTxt @ NullTxt;
            }
            DrawDebugText(HUD, AddTxt);
            if(Enemy != none)
            {
                DrawDebugText(HUD, (((("EnemyDist: " $ string(VSize(Enemy.Location - Pawn.Location))) $ " RouteCache: ") $ string(RouteCache.Length)) $ " DestinationOffset: ") $ string(Pawn.DestinationOffset));
                DrawDebugText(HUD, ((("MeleeEvents Enabled: " $ string(bIsProbingMeleeRangeEvents)) $ " Within Melee Range [") $ string(StrikeRange)) $ "]");
                DrawDebugText(HUD, "DotToEnemy: " $ string(Normal(MyKFPawn.Location - Enemy.Location) Dot vector(Enemy.Rotation)));
            }
            if(Pawn.IsDesiredRotationInUse())
            {
                DrawDebugText(HUD, "DesiredRotation In Use: TRUE", MakeColor(255, 0, 0, 255));
            }
            if(Pawn.IsDesiredRotationLocked())
            {
                DrawDebugText(HUD, "DesiredRotation is locked", MakeColor(255, 0, 0, 255));
            }
            if(bHasDebugCommand)
            {
                FindCommandOfClass(Class'AICommand_Debug').DrawDebug(HUD, Category);
            }
        }
    }
    if(bDrawDebugAllPlugins)
    {
        if(KfMovementPlugin != none)
        {
            KfMovementPlugin.DrawDebugToHud(HUD, Category);
        }
        if(KfLeapPlugin != none)
        {
            KfLeapPlugin.DrawDebugToHud(HUD, Category);
        }
        if(KfMovementPlugin != none)
        {
            KfStuckFixPlugin.DrawDebugToHud(HUD, Category);
        }
    }
    if(bDrawDebugPlugInHistory)
    {
        MyAiPlugInHistory.DrawDebugToHud(HUD, Category);
    }
}

function BeginDebugCommand()
{
    AbortCommand(none, Class'AICommand');
    Class'AICommand_Debug'.static.Debug(self);
}

function DoDebugTurnInPlace(KFPlayerController KFPC, optional bool bAllowMelee)
{
    bAllowMelee = false;
    AbortCommand(none, Class'AICommand');
    Class'AICommand_DebugTurn'.static.DebugTurnInPlace(self, bAllowMelee, KFPC);
}

function AddTakenDamage(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType)
{
    UpdateDamageHistory(DamagerController, Damage, DamageCauser, DamageType);
}

function UpdateDamageHistory(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType)
{
    local DamageInfo Info;
    local Pawn BlockerPawn;
    local bool bChangedEnemies;
    local int HistoryIndex;
    local float DamageThreshold;

    if(!GetDamageHistory(DamagerController, Info, HistoryIndex))
    {
        DamageHistory.Insert(0, 1;
    }
    if(DamagerController.bIsPlayer)
    {
        DamageThreshold = float(Pawn.HealthMax) * AggroPlayerHealthPercentage;
        UpdateDamageHistoryValues(DamagerController, Damage, DamageCauser, AggroPlayerResetTime, Info, DamageType);
        if((WorldInfo.TimeSeconds - DamageHistory[CurrentEnemysHistoryIndex].LastTimeDamaged) > float(10))
        {
            DamageHistory[CurrentEnemysHistoryIndex].Damage = 0;
        }
        if((((IsAggroEnemySwitchAllowed()) && DamagerController.Pawn != Enemy) && Info.Damage >= DamageThreshold) && Info.Damage > DamageHistory[CurrentEnemysHistoryIndex].Damage)
        {
            BlockerPawn = GetPawnBlockingPathTo(DamagerController.Pawn, true);
            if(BlockerPawn == none)
            {
                bChangedEnemies = SetEnemy(DamagerController.Pawn);                
            }
            else
            {
                bChangedEnemies = SetEnemy(BlockerPawn);
            }
        }        
    }
    else
    {
        DamageThreshold = float(Pawn.HealthMax) * AggroZedHealthPercentage;
        UpdateDamageHistoryValues(DamagerController, Damage, DamageCauser, AggroZedResetTime, Info, DamageType);
        if(((IsAggroEnemySwitchAllowed()) && DamagerController.Pawn != Enemy) && Info.Damage >= DamageThreshold)
        {
            BlockerPawn = GetPawnBlockingPathTo(DamagerController.Pawn);
            if(BlockerPawn == none)
            {
                bChangedEnemies = SetEnemyToZed(DamagerController.Pawn);
            }
        }
    }
    DamageHistory[HistoryIndex] = Info;
    if(bChangedEnemies)
    {
        CurrentEnemysHistoryIndex = byte(HistoryIndex);
    }
}

function bool IsAggroEnemySwitchAllowed()
{
    return true;
}

function bool GetDamageHistory(Controller DamagerController, out DamageInfo InInfo, out int InHistoryIndex)
{
    InHistoryIndex = DamageHistory.Find('DamagerController', DamagerController;
    if(InHistoryIndex != -1)
    {
        InInfo = DamageHistory[InHistoryIndex];
        return true;
    }
    InHistoryIndex = 0;
    return false;
}

function UpdateDamageHistoryValues(Controller DamagerController, int Damage, Actor DamageCauser, float DamageResetTime, out DamageInfo InInfo, class<KFDamageType> DamageType)
{
    local class<KFPerk> WeaponPerk;

    InInfo.DamagerController = DamagerController;
    if((WorldInfo.TimeSeconds - InInfo.LastTimeDamaged) > DamageResetTime)
    {
        InInfo.Damage = 0;
    }
    InInfo.Damage += float(Damage);
    InInfo.TotalDamage += float(Damage);
    if(DamagerController.PlayerReplicationInfo != none)
    {
        InInfo.DamagerPRI = DamagerController.PlayerReplicationInfo;
    }
    WeaponPerk = GetUsedWeaponPerk(DamagerController, DamageCauser, DamageType);
    if((WeaponPerk != none) && InInfo.DamagePerks.Find(WeaponPerk == -1)
    {
        InInfo.DamagePerks.AddItem(WeaponPerk;
    }
}

function class<KFPerk> GetUsedWeaponPerk(Controller DamagerController, Actor DamageCauser, class<KFDamageType> DamageType)
{
    local class<KFPerk> WeaponPerk;
    local KFPlayerController KFPC;
    local KFWeapon KFW;

    KFPC = KFPlayerController(DamagerController);
    if(KFPC == none)
    {
        return none;
    }
    WeaponPerk = Class'KFPerk'.static.GetPerkFromDamageCauser(DamageCauser);
    if(WeaponPerk == none)
    {
        KFW = KFWeapon(DamageCauser);
        if(((KFW == none) && DamageType != none) && DamageType.static.IsNotPerkBound())
        {
            KFW = KFWeapon(KFPC.Pawn.Weapon);
            if(KFW != none)
            {
                WeaponPerk = Class'KFPerk'.static.GetPerkFromDamageCauser(KFW);
            }
        }
        if(((WeaponPerk == none) && KFW != none) && Class'KFPerk'.static.IsBackupWeapon(KFW))
        {
            WeaponPerk = KFPC.GetPerk().GetPerkClass();
        }
    }
    return WeaponPerk;
}

function DrawDebugOverheadMovementPhaseData(KFHUDBase HUD, out Vector2D ScreenPos)
{
    local Texture2D Icon;
    local PlayerController PC;
    local Canvas Canvas;
    local Vector CameraLoc, ScreenLoc;
    local Rotator CameraRot;
    local float X, Y, Dot;

    if((MyKFPawn == none) || MyKFPawn.Health <= 0)
    {
        return;
    }
    if(HUD.ShouldDisplayDebug('AIPathing') || HUD.ShouldDisplayDebug('AllVerbose'))
    {
        HUD.DrawRoute(MyKFPawn);
    }
    Canvas = HUD.Canvas;
    ScreenLoc = Canvas.Project(Pawn.Location + ((vect(0, 0, 1) * Pawn.GetCollisionHeight()) * 1.5));
    if(((ScreenLoc.X < float(0)) || ScreenLoc.X >= HUD.Canvas.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    PC = HUD.PlayerOwner;
    Canvas.SetDrawColor(255, 255, 255);
    PC.GetPlayerViewPoint(CameraLoc, CameraRot);
    Dot = vector(CameraRot) Dot (Pawn.Location - CameraLoc);
    if(Dot < 0.5)
    {
        return;
    }
    if(CurrentMovementPhase == 2)
    {
        Icon = MovementPhaseTypePathNodeNormalMoveToIcon;        
    }
    else
    {
        if(CurrentMovementPhase == 4)
        {
            Icon = MovementPhaseTypePathNodeDelayMoveIcon;            
        }
        else
        {
            if(CurrentMovementPhase == 3)
            {
                Icon = MovementPhaseTypePathNodeMoveToPointIcon;                
            }
            else
            {
                if(CurrentMovementPhase == 5)
                {
                    Icon = MovementPhaseTypePathNodeRotateToFocusIcon;                    
                }
                else
                {
                    if(CurrentMovementPhase == 6)
                    {
                        Icon = MovementPhaseTypePathNodeMoveFailedIcon;                        
                    }
                    else
                    {
                        if(CurrentMovementPhase == 1)
                        {
                            Icon = MovementPhaseTypeNavMeshNormalMoveToIcon;                            
                        }
                        else
                        {
                            if(CurrentMovementPhase == 7)
                            {
                                Icon = MovementPhaseTypeFinalDestMoveTowardsIcon;                                
                            }
                            else
                            {
                                if(CurrentMovementPhase == 8)
                                {
                                    Icon = MovementPhaseTypeEMT_LOS_MoveTowardsIcon;                                    
                                }
                                else
                                {
                                    if(CurrentMovementPhase == 9)
                                    {
                                        Icon = MovementPhaseTypeMovingToNavMeshUsingPathNodesIcon;                                        
                                    }
                                    else
                                    {
                                        if(CurrentMovementPhase == 10)
                                        {
                                            Icon = MovementPhaseTypeFALLBACK_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;                                            
                                        }
                                        else
                                        {
                                            if(CurrentMovementPhase == 11)
                                            {
                                                Icon = MovementPhaseTypeFALLBACK_REFUSED_TO_BE_EXPLOTIED_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;                                                
                                            }
                                            else
                                            {
                                                if(CurrentMovementPhase == 12)
                                                {
                                                    if(TypeOfMovementStuckOn == 1)
                                                    {
                                                        Icon = TypeOfMovementStuckOnMOVE_FAILURE_TYPE_NO_NAV_MESH_PATHIcon;                                                        
                                                    }
                                                    else
                                                    {
                                                        if(TypeOfMovementStuckOn == 2)
                                                        {
                                                            Icon = TypeOfMovementStuckOnMOVE_FAILURE_TYPE_SAME_INTERMEDIATE_POINT_TOO_MANY_TIMESIcon;                                                            
                                                        }
                                                        else
                                                        {
                                                            if(TypeOfMovementStuckOn == 3)
                                                            {
                                                                Icon = TypeOfMovementStuckOnMOVE_FAILURE_TYPE_TARGET_OFF_NAV_MESH_AND_CAN_NOT_FIND_LOCAITON_NEAR_THEM_I_CAN_MOVE_TOIcon;                                                                
                                                            }
                                                            else
                                                            {
                                                                if(TypeOfMovementStuckOn == 4)
                                                                {
                                                                    Icon = TypeOfMovementStuckOnLookingForBetterIntermediateLoc;                                                                    
                                                                }
                                                                else
                                                                {
                                                                    if(TypeOfMovementStuckOn == 5)
                                                                    {
                                                                        Icon = TypeOfMovementStuckOnMoveToBetterIntermediate;                                                                        
                                                                    }
                                                                    else
                                                                    {
                                                                        Icon = TypeOfMovementStuckOnUnknownWhyIcon;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }                                                    
                                                }
                                                else
                                                {
                                                    Icon = MovementPhaseTypeUnknownIcon;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if(Icon != none)
    {
        Canvas.SetPos(ScreenLoc.X - float(Icon.SizeX / 2), ScreenLoc.Y - float(Icon.SizeY / 2), ScreenLoc.Z);
        Canvas.DrawTexture(Icon, 1);
        X = (ScreenLoc.X + float(Icon.SizeX / 2)) + float(5);
        Y = ScreenLoc.Y - float(Icon.SizeY / 2);        
    }
    else
    {
        X = ScreenLoc.X;
        Y = ScreenLoc.Y;
    }
    Canvas.SetPos(X, Y);
    ScreenPos.X = Canvas.CurX;
    ScreenPos.Y = Canvas.CurY;
    Canvas.Font = Class'Engine'.static.GetSmallFont();
    if(KfMovementPlugin != none)
    {
        KfMovementPlugin.DrawDebugToHud(HUD, 'Recast');
    }
    if(KfStuckFixPlugin != none)
    {
        KfStuckFixPlugin.DrawDebugToHud(HUD, 'Recast');
    }
    if(KfLeapPlugin != none)
    {
        KfLeapPlugin.DrawDebugToHud(HUD, 'Recast');
    }
}

simulated function DrawBehaviorTreeIconOverhead(KFHUDBase HUD);

function ReceiveLocationalWarning(Vector DangerPoint)
{
    local byte BestDir;

    if(MyKFPawn != none)
    {
        BestDir = GetBestEvadeDir(DangerPoint,, false);
        if(BestDir != 8)
        {
            DoEvade(BestDir,, FRand() * 0.2, true);
        }
    }
}

function ReceiveProjectileWarning(Projectile Proj)
{
    local KFAIController OtherKFAIC;

    if(((MyKFPawn == none) || MyKFPawn.Health <= 0) || !MyKFPawn.CanDoSpecialMove(15) && !MyKFPawn.CanDoSpecialMove(16))
    {
        return;
    }
    HandleProjectileWarning(Proj);
    foreach WorldInfo.AllControllers(Class'KFAIController', OtherKFAIC)
    {
        if((((OtherKFAIC != self) && OtherKFAIC.Pawn != none) && OtherKFAIC.Pawn.Health > 0) && OtherKFAIC.PendingEvadeProjectile == none)
        {
            if(VSizeSq(OtherKFAIC.Pawn.Location - Proj.Location) < 810000)
            {
                OtherKFAIC.HandleProjectileWarning(Proj);
            }
        }        
    }    
}

function HandleProjectileWarning(Projectile Proj)
{
    if(((MyKFPawn == none) || MyKFPawn.Health <= 0) || !MyKFPawn.CanDoSpecialMove(15) && !MyKFPawn.CanDoSpecialMove(16))
    {
        return;
    }
    if((CanEvadeGrenade()) && Proj.IsA('KFProj_Grenade'))
    {
        if(!IsTimerActive('Timer_DoProjectileEvade') && (vector(Pawn.Rotation) Dot Normal(Proj.Instigator.Location - Pawn.Location)) > 0.7)
        {
            PendingEvadeProjectile = Proj;
            MyKFPawn.SetHeadTrackTarget(PendingEvadeProjectile,, 1);
            SetTimer(0.265 + (FRand() * 0.12), false, 'Timer_DoProjectileEvade');
        }
    }
}

function bool CanEvadeGrenade()
{
    return FRand() < EvadeGrenadeChance;
}

final function Timer_DoProjectileEvade()
{
    local byte BestDir;

    MyKFPawn.SetHeadTrackTarget(none);
    if((((((MyKFPawn != none) && MyKFPawn.CanDoSpecialMove(15) || MyKFPawn.CanDoSpecialMove(16)) && PendingEvadeProjectile != none) && !PendingEvadeProjectile.bDeleteMe) && !IsZero(PendingEvadeProjectile.Velocity)) && CanEvade())
    {
        BestDir = GetBestEvadeDir(PendingEvadeProjectile.Location, PendingEvadeProjectile.Instigator);
        if(BestDir != 8)
        {
            DoEvade(BestDir, PendingEvadeProjectile, 0.1 + (FRand() * 0.2), true);
        }
    }
    PendingEvadeProjectile = none;
}

function bool CanEvade()
{
    if(((((MyKFPawn == none) || MyKFPawn.Health <= 0) || MyKFPawn.Physics != 1) || MyKFPawn.IsDoingSpecialMove()) || MyKFPawn.IsImpaired())
    {
        return false;
    }
    return true;
}

final function byte GetBestEvadeDir(Vector DangerPoint, optional Pawn ThreatPawn, optional bool bUseFastTrace, optional bool bCross)
{
    local Vector X, Y, Z, VectToDanger, Offset, EvadeLocation,
	    Extent;

    local bool bLeftOpen, bRightOpen, bFrontOpen, bBackOpen;
    local float DotX, CheckHeight;
    local KFPawn.EPawnOctant EvadeDir;

    bUseFastTrace = true;    
    if(bCross)
    {
        EvadeDir = Class'KFPawn'.static.CalcOctagonRegion(MyKFPawn.GetViewRotation(), Normal(ThreatPawn.Location - Pawn.Location) Cross vect(0, 0, 1));
        return EvadeDir;
    }
    EvadeDir = Class'KFPawn'.static.CalcOctagonRegion(MyKFPawn.GetViewRotation(), Normal(MyKFPawn.Location - DangerPoint));
    GetAxes(Pawn.Rotation, X, Y, Z);
    switch(EvadeDir)
    {
        case 4:
            return 4;
        case 5:
            return 5;
        case 6:
            return 6;
        case 7:
            return 7;
        case 0:
            if(!bUseFastTrace || FastActorTrace(Pawn.Location + (256 * X), Pawn.Location, Pawn.GetCollisionExtent() * 0.5))
            {
                return 0;
            }
            break;
        case 1:
            if(!bUseFastTrace || FastActorTrace(Pawn.Location - (256 * X), Pawn.Location, Pawn.GetCollisionExtent() * 0.5))
            {
                return 1;
            }
            break;
        case 2:
            if(!bUseFastTrace || FastActorTrace(Pawn.Location - (256 * Y), Pawn.Location, Pawn.GetCollisionExtent() * 0.5))
            {
                return 2;
            }
            break;
        case 3:
            if(!bUseFastTrace || FastActorTrace(Pawn.Location + (256 * Y), Pawn.Location, Pawn.GetCollisionExtent() * 0.5))
            {
                return 3;
            }
            break;
        default:
            break;
    }
    if((EvadeDir == 8) && ThreatPawn != none)
    {
        CheckHeight = (MyKFPawn.GetCollisionHeight() * 0.5) + MyKFPawn.MaxStepHeight;
        GetAxes(MyKFPawn.Rotation, X, Y, Z);
        VectToDanger = Normal(DangerPoint - Pawn.Location);
        DotX = X Dot VectToDanger;
        Extent = Pawn.GetCollisionExtent() * 0.5;
        if((DotX >= 0.7071) || DotX <= -0.7071)
        {
            Offset = X * 300;
            EvadeLocation = Pawn.Location - Offset;
            bBackOpen = CanReachEvadeLocation(EvadeLocation, CheckHeight, Extent);
            if(bBackOpen && DotX >= 0.7071)
            {
                return 1;
            }
            EvadeLocation = Pawn.Location + Offset;
            bFrontOpen = CanReachEvadeLocation(EvadeLocation, CheckHeight, Extent);
            if(bFrontOpen && DotX <= -0.7071)
            {
                return 0;
            }            
        }
        else
        {
            Offset = Y * 300;
            EvadeLocation = Pawn.Location + Offset;
            bRightOpen = CanReachEvadeLocation(EvadeLocation, CheckHeight, Extent);
            if(bRightOpen)
            {
                return 3;
            }
            EvadeLocation = Pawn.Location - Offset;
            bLeftOpen = CanReachEvadeLocation(EvadeLocation, CheckHeight, Extent);
            if(bLeftOpen)
            {
                return 2;
            }
        }
    }
    return 8;
}

function bool CanReachEvadeLocation(Vector EvadeLocation, float CheckHeight, Vector Extent)
{
    if(FastTrace(EvadeLocation, Pawn.Location) && !FastTrace(EvadeLocation + (vect(0, 0, -1) * CheckHeight), EvadeLocation, Extent))
    {
        if(!IsPawnBlockingLine(Pawn.Location, EvadeLocation))
        {
            return true;
        }
    }
    return false;
}

event WaitForDoor(KFDoorActor door)
{
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIDoor(2105, self, Pawn.Location, door, "Waiting at " $ string(WorldInfo.TimeSeconds));
    }
    AILog_Internal(((string(GetFuncName()) $ "() Waiting for door ") $ string(door)) $ " to open or be destroyed", 'Doors');
    SetTimer(5, true, 'Timer_WaitingForDoor');
    PendingDoor = door;
    door.bMonitorDoor = true;
    bPreparingMove = true;
    StopAllLatentMovement();
    Pawn.Acceleration = vect(0, 0, 0);
}

function Timer_WaitingForDoor()
{
    AILog_Internal(((((((("** WARNING ** [" $ string(GetFuncName())) $ "] I've been waiting for at least 10 seconds for door ") $ string(PendingDoor)) $ " bPreparingMove: ") $ string(bPreparingMove)) $ " (Command: ") $ string(CachedAICommandList)) $ ")", 'Doors');
    DoorFinished();
}

function bool DoorFinished()
{
    AILog_Internal(string(GetFuncName()) $ "() door has finished opening or is destroyed!", 'Doors');
    if(((Pawn == none) || PendingDoor.MyMarker == none) || PendingDoor.MyMarker.ProceedWithMove(Pawn))
    {
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIDoor(2106, self, Pawn.Location, PendingDoor, "Waiting at " $ string(WorldInfo.TimeSeconds));
        }
        AILog_Internal(string(GetFuncName()) $ "() setting pending door to none, bPreparingMove to false. Proceeding with move.", 'Doors');
        PendingDoor = none;
        if(CachedAICommandList != none)
        {
            CachedAICommandList.NotifyDoorOpened();
        }
        ClearTimer('Timer_WaitingForDoor');
        return true;
    }
    AILog_Internal((string(GetFuncName()) $ "() *** WARNING *** I received DoorFinished event but returned false! ") $ string(CachedAICommandList), 'Doors');
    return false;
}

function NotifyAttackDoor(KFDoorActor door)
{
    local byte SMFlags;

    AILog_Internal((((string(GetFuncName()) $ "() initializing AICommand_Attack_Melee, MoveTarget: ") $ string(MoveTarget)) $ " Dist: ") $ string(VSize(door.MyMarker.Location - Pawn.Location)), 'Doors');
    PendingDoor = door;
    DoorEnemy = door;
    door.bMonitorDoor = true;
    bPreparingMove = true;
    StopAllLatentMovement();
    AIZeroMovementVariables();
    Focus = door;
    SMFlags = 255;
    SMFlags = Class'KFSM_DoorMeleeAttack'.static.PackSMFlags(MyKFPawn);
    if(SMFlags != 255)
    {
        Class'AICommand_Attack_Melee'.static.Melee(self, door, SMFlags);        
    }
    else
    {
        Class'AICommand_Attack_Melee'.static.Melee(self, door);
    }
}

function NotifyAttackActor(Actor A)
{
    if(!MyKFPawn.IsDoingSpecialMove())
    {
        ActorEnemy = A;
        StopAllLatentMovement();
        AIZeroMovementVariables();
        bPreparingMove = true;
        Focus = A;
        Class'AICommand_Attack_Melee'.static.Melee(self, A);
    }
}

final function DebugLogRoute();

function float GetMinDistanceToAnyPlayer()
{
    local PlayerController PC;
    local float MinRange, CurRange;

    MinRange = -1;
    if(Pawn == none)
    {
        return -1;
    }
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if((PC != none) && PC.ViewTarget != none)
        {
            CurRange = VSizeSq(PC.ViewTarget.Location - Pawn.Location);
            if((CurRange < MinRange) || MinRange < 0)
            {
                MinRange = CurRange;
            }
        }        
    }    
    return Sqrt(MinRange);
}

function NotifyEnRaged(bool bEnraged);

function ResetKFAIC()
{
    if((MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove())
    {
        MyKFPawn.EndSpecialMove();
        SetTimer(0.1, false, 'ResetKFAIC', self);
        return;
    }
    AIZeroMovementVariables();
    StopLatentExecution();
    StopAllLatentMovement();
    Enemy = none;
    DoorEnemy = none;
    CachedVisibleEnemy = none;
    MeleeTarget = none;
    MoveTarget = none;
    MoveGoal = none;
    LastHitWall = none;
    PendingDoor = none;
    RouteGoal = none;
    MoveFailureCount = 0;
    FailedMoveToEnemyCount = 0;
    HitWallCount = 0;
    RouteCache.Length = 0;
    LastTauntTime = 0;
    LastNotifyHitWallTime = 0;
    LastBumpTime = 0;
    LastObstructionTime = 0;
    MoveTimer = -1;
    bHasDebugCommand = false;
    bPreparingMove = false;
    bAdjusting = false;
    bReevaluatePath = false;
    IsRotationLocked = false;
    bEnemyIsVisible = false;
    bReachedLatentMoveGoal = false;
    LockedRotation = rot(0, 0, 0);
    SetTimer(RandRange(1, 3), false, 'StartSteering');
    BeginCombatCommand(none, "Reset");
}

function bool GetIsInZedVictoryState()
{
    return false;
}

function EnterZedVictoryState()
{
    ClearMovementInfo();
    if(CommandList != none)
    {
        AbortCommand(CommandList);
    }
    DisableMeleeRangeEventProbing();
    ChangeEnemy(none);
    MyKFPawn.SetSprinting(false);
    GotoState('ZedVictory', 'Begin');
}

simulated event GetPlayerViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    GetActorEyesViewPoint(out_Location, out_Rotation);
}

event float EvaluateThreatFrom(Pawn CheckPawn, optional float EarlyOutScore)
{
    local KFPawn Threat;
    local float DistToThreat, ThreatScore;
    local int RecentDamageFromThreat;
    local string outmsg;
    local float modscore, Dot;
    local Vector Loc;
    local Rotator Rot;
    local float DistScore, ClosestDist, Time;

    Threat = KFPawn(CheckPawn);
    RecentDamageFromThreat = RecentDamageFrom(Threat);
    DistToThreat = VSize(Threat.Location - Pawn.Location);
    if(CheckPawn.IsHumanControlled() && CheckPawn.PlayerReplicationInfo != none)
    {
        outmsg = ("[" $ CheckPawn.PlayerReplicationInfo.PlayerName) $ "] THREATSCORE";        
    }
    else
    {
        outmsg = ("[" $ string(CheckPawn)) $ "] THREATSCORE";
    }
    if(DistToThreat < 2500)
    {
        ThreatScore += ((2500 - DistToThreat) / 2500);
        DistScore = ThreatScore;
    }
    if(MyKFPawn.IsPawnMovingTowardMe(Threat, 300))
    {
        modscore = 0.12 * DistScore;
        outmsg = ((outmsg $ " [MOVING TOWARD ME SCORE: ") $ string(modscore)) $ "]";
        ThreatScore += (0.12 * DistScore);
        GetClosestTimeAndDistToPawn(Threat, Time, ClosestDist);
        if(((Time > 0) && Time < 2.5) && ClosestDist < 250)
        {
            modscore = (2.5 - Time) / 2.5;
            ThreatScore += modscore;
            outmsg = ((((outmsg $ " [TIME TO ENEMY: ") $ string(modscore)) $ " TIME: ") $ string(Time)) $ "]";
        }        
    }
    else
    {
        if(MyKFPawn.IsPawnMovingAwayFromMe(Threat, 300))
        {
            modscore = -0.15 * (float(1) / DistScore);
            outmsg = ((outmsg $ " [MOVING AWAY SCORE: ") $ string(modscore)) $ "]";
            ThreatScore -= (0.15 * (float(1) / DistScore));
        }
    }
    if(Threat.Controller.CanSee(Pawn))
    {
        Threat.Controller.GetPlayerViewPoint(Loc, Rot);
        Dot = Normal(Pawn.Location - Loc) Dot vector(Rot);
        if(Dot > 0.7)
        {
            modscore += (Dot * DistScore);
            ThreatScore += (Dot * DistScore);            
        }
        else
        {
            modscore = 0.1;
            ThreatScore -= 0.1;
        }
        outmsg = ((((outmsg $ " [DOT: ") $ string(Dot)) $ " AIMING AT SCORE: ") $ string(modscore)) $ "]";        
    }
    else
    {
        ThreatScore -= (0.12 * (float(1) / DistScore));
        modscore = 0.12 * (float(1) / DistScore);
        outmsg = ((((outmsg $ " [CANT SEE YOU PENALTY:") $ string(modscore)) $ " DIST SCORE WAS ") $ string(DistScore)) $ "]";
    }
    if(RecentDamageFromThreat > 0)
    {
        modscore = float(RecentDamageFromThreat) / float(MyKFPawn.HealthMax);
        outmsg = ((((outmsg $ " [RECENT DAMAGE:") $ string(RecentDamageFromThreat)) $ " SCORE: ") $ string(modscore)) $ "]";
        ThreatScore += (float(RecentDamageFromThreat) / float(MyKFPawn.HealthMax));
    }
    outmsg = (("FINAL SCORE: " $ string(ThreatScore)) $ "...") $ outmsg;
    msg((Threat.PlayerReplicationInfo.PlayerName $ ": ") $ outmsg);
    return ThreatScore;
}

event DrawStrikeRanges()
{
    local KFPawnAnimInfo KFPAI;
    local byte I;

    if((MyKFPawn != none) && MyKFPawn.PawnAnimInfo != none)
    {
        KFPAI = MyKFPawn.PawnAnimInfo;
        I = 0;
        J0x69:

        if(I < MyKFPawn.PawnAnimInfo.Attacks.Length)
        {
            if((I != PendingAnimStrikeIndex) && bDebug_ShowAllStrikeRange || KFPAI.AllowAttackByDifficulty(I) && KFPAI.AllowAttackByMovement(I, MyKFPawn))
            {
                DrawStrikeRange(I, KFPAI, MakeColor(byte(255 - (I * 20)), 0, byte(I * 20), 255));
            }
            ++ I;
            goto J0x69;
        }
        if(PendingAnimStrikeIndex != 255)
        {
            DrawStrikeRange(PendingAnimStrikeIndex, KFPAI, MakeColor(255, 255, 0, 255));
        }
        DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 1.57, 0, StrikeRange, MakeColor(0, 0, 0, 255));
        DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 0, 1.57, StrikeRange, MakeColor(0, 0, 0, 255));
        if((MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove(1))
        {
            DrawStrikeRange(DebugCurrentStrikeIndex, KFPAI, MakeColor(0, 255, 0, 255));
        }
        DrawMaxHitRange(MakeColor(0, 255, 0, 255));
    }
}

function DrawStrikeRange(byte Index, KFPawnAnimInfo KFPAI, Color ZoneColor)
{
    local float MinDistance, MaxDistance, AverageDistance, CollisionRadius;
    local string TagString;

    CollisionRadius = MyKFPawn.CylinderComponent.CollisionRadius;
    MinDistance = ((KFPAI.Attacks[Index].MinDistance < CollisionRadius) ? CollisionRadius : KFPAI.Attacks[Index].MinDistance);
    MaxDistance = KFPAI.Attacks[Index].MaxDistance;
    AverageDistance = KFPAI.GetMedianStrikeRange(Index, 0.5, CollisionRadius);
    TagString = string(KFPAI.Attacks[Index].Tag);
    DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 1.57, 0, MaxDistance, ZoneColor);
    DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 1.57, 0, MinDistance, ZoneColor);
    DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 0, 1.57, MaxDistance, ZoneColor);
    DrawStrikeRangeLines(MyKFPawn.Location, MyKFPawn.Rotation, 0, 1.57, MinDistance, ZoneColor);
    DrawAttackRangeText(Index, 40960, 2048, AverageDistance, TagString, ZoneColor);
}

event DrawStrikeRangeLines(Vector OrginOfStrikeZone, Rotator RotOrginOfZone, float StartAngleInRads, float EndAngleInRads, float RangeOfZone, Color ZoneColor)
{
    local Vector arcRightInnerLineEnd, arcMidRightLineEnd, arcFarRightLineEnd, arcLeftInnerLineEnd, arcMidLeftLineEnd, arcFarLeftLineEnd;

    local Rotator arcRightInnerEdge, arcMidRightEdge, arcFarRightEdge, arcLeftInnerEdge, arcMidLeftEdge, arcFarLeftEdge;

    local int innerHorArcInUU, farHorArcInUU, midHorArcInUU;
    local float verticalShiftForZoneLines;

    verticalShiftForZoneLines = MyKFPawn.CylinderComponent.CollisionHeight;
    OrginOfStrikeZone.Z = OrginOfStrikeZone.Z - verticalShiftForZoneLines;
    innerHorArcInUU = int(StartAngleInRads * 10430.22);
    farHorArcInUU = int(EndAngleInRads * 10430.22);
    midHorArcInUU = int((float(farHorArcInUU - innerHorArcInUU) * 0.5) + float(innerHorArcInUU));
    arcRightInnerEdge = MakeRotator(0, RotOrginOfZone.Yaw + innerHorArcInUU, 0);
    arcRightInnerLineEnd = OrginOfStrikeZone + (vector(arcRightInnerEdge) * RangeOfZone);
    if(farHorArcInUU > 0)
    {
        arcFarRightEdge = MakeRotator(0, RotOrginOfZone.Yaw + farHorArcInUU, 0);
        arcFarRightLineEnd = OrginOfStrikeZone + (vector(arcFarRightEdge) * RangeOfZone);        
    }
    else
    {
        midHorArcInUU = int((float(32767 - innerHorArcInUU) * 0.5) + float(innerHorArcInUU));
        arcFarRightEdge = MakeRotator(0, RotOrginOfZone.Yaw + 32767, 0);
        arcFarRightLineEnd = OrginOfStrikeZone + (vector(arcFarRightEdge) * RangeOfZone);
    }
    arcMidRightEdge = MakeRotator(0, RotOrginOfZone.Yaw + midHorArcInUU, 0);
    arcMidRightLineEnd = OrginOfStrikeZone + (vector(arcMidRightEdge) * RangeOfZone);
    arcLeftInnerEdge = MakeRotator(0, RotOrginOfZone.Yaw - innerHorArcInUU, 0);
    arcLeftInnerLineEnd = OrginOfStrikeZone + (vector(arcLeftInnerEdge) * RangeOfZone);
    if(farHorArcInUU > 0)
    {
        arcFarLeftEdge = MakeRotator(0, RotOrginOfZone.Yaw - farHorArcInUU, 0);
        arcFarLeftLineEnd = OrginOfStrikeZone + (vector(arcFarLeftEdge) * RangeOfZone);        
    }
    else
    {
        arcFarLeftEdge = MakeRotator(0, RotOrginOfZone.Yaw - 32767, 0);
        arcFarLeftLineEnd = OrginOfStrikeZone + (vector(arcFarLeftEdge) * RangeOfZone);
    }
    arcMidLeftEdge = MakeRotator(0, RotOrginOfZone.Yaw - midHorArcInUU, 0);
    arcMidLeftLineEnd = OrginOfStrikeZone + (vector(arcMidLeftEdge) * RangeOfZone);
    MyKFPawn.DrawDebugLine(arcFarRightLineEnd, arcMidRightLineEnd, ZoneColor.R, ZoneColor.G, ZoneColor.B);
    MyKFPawn.DrawDebugLine(arcRightInnerLineEnd, arcMidRightLineEnd, ZoneColor.R, ZoneColor.G, ZoneColor.B);
    MyKFPawn.DrawDebugLine(arcFarLeftLineEnd, arcMidLeftLineEnd, ZoneColor.R, ZoneColor.G, ZoneColor.B);
    MyKFPawn.DrawDebugLine(arcLeftInnerLineEnd, arcMidLeftLineEnd, ZoneColor.R, ZoneColor.G, ZoneColor.B);
}

function DrawAttackRangeText(byte Index, float StartingAngle, float RotationInterval, float MedianMeleeRange, string Text, Color TextColor)
{
    local Vector TextLocation;
    local Rotator DrawDirection;
    local int RotationOffset;

    RotationOffset = int(RotationInterval * float(Index));
    StartingAngle = (float(MyKFPawn.Rotation.Yaw) - StartingAngle) + float(RotationOffset);
    DrawDirection = MakeRotator(0, int(StartingAngle), 0);
    TextLocation = MyKFPawn.Location + (vector(DrawDirection) * MedianMeleeRange);
    TextLocation.Z -= MyKFPawn.CylinderComponent.CollisionHeight;
    GetALocalPlayerController().AddDebugText(Text, WorldInfo, 0.02 * WorldInfo.TimeDilation, TextLocation, TextLocation, TextColor, true, true);
}

function DrawMaxHitRange(Color LineColor)
{
    local Rotator ZedRotation;
    local Vector LineStart, LineEnd;

    ZedRotation = MakeRotator(0, MyKFPawn.Rotation.Yaw, 0);
    LineStart = MyKFPawn.Location;
    LineStart.Z -= MyKFPawn.CylinderComponent.CollisionHeight;
    LineEnd = LineStart + (vector(ZedRotation) * MyKFPawn.MeleeAttackHelper.GetMeleeRange());
    MyKFPawn.DrawDebugLine(LineStart, LineEnd, LineColor.R, LineColor.G, LineColor.B);
}

function GetCommandStack(HUD HUD, out array<string> OverheadTexts, out array<Color> OverheadColors)
{
    local int CmdCnt;
    local GameAICommand Cmd;
    local string CommandText;
    local bool bShowCommands, bShowMovement;
    local int I;
    local string T;
    local AICommand_Wander WanderCommand;

    if(HUD.ShouldDisplayDebug('AllVerbose'))
    {
        bShowCommands = true;
        bShowMovement = true;
    }
    if(HUD.ShouldDisplayDebug('All'))
    {
        bShowCommands = true;
        bShowMovement = true;
    }
    if(HUD.ShouldDisplayDebug('AICommands'))
    {
        bShowCommands = true;
    }
    if(HUD.ShouldDisplayDebug('AIMovement') || HUD.ShouldDisplayDebug('AIPathing'))
    {
        bShowMovement = true;
    }
    if(MyKFPawn == none)
    {
        return;
    }
    if((bShowMovement || HUD.ShouldDisplayDebug('AI')) || HUD.ShouldDisplayDebug('AIMovementVerbose'))
    {
        CommandText = "---------- AI General ----------
";
        if(Enemy != none)
        {
            CommandText = ((((CommandText @ "STATE: ") $ string(GetStateName())) $ " Enemy ") $ Enemy.GetHumanReadableName()) $ "
";            
        }
        else
        {
            CommandText = (((CommandText @ "STATE: ") $ string(GetStateName())) $ " NO Enemy ") $ "
";
        }
        if(HUD.ShouldDisplayDebug('AI') || HUD.ShouldDisplayDebug('AIMovementVerbose'))
        {
            CommandText = ((((((CommandText @ "Anchor: ") $ string(Pawn.Anchor)) $ " Serpentine Dist: ") $ string(Pawn.SerpentineDist)) $ " Time: ") $ string(Pawn.SerpentineTime)) $ "
";
            if(((Pawn != none) && MoveTarget != none) && Pawn.ReachedDestination(MoveTarget))
            {
                CommandText = ((((((CommandText @ "Skill: ") $ string(Skill)) $ " NAVIGATION MoveTarget: ") $ (GetItemName(string(MoveTarget)))) $ "(REACHED) MoveTimer: ") $ string(MoveTimer)) $ "
";                
            }
            else
            {
                CommandText = ((((((CommandText @ "Skill: ") $ string(Skill)) $ " NAVIGATION MoveTarget: ") $ (GetItemName(string(MoveTarget)))) $ " MoveTimer: ") $ string(MoveTimer)) $ "
";
            }
            CommandText = ((((((CommandText @ "Destination: ") $ string(GetDestinationPosition())) $ " Focus: ") $ (GetItemName(string(Focus)))) $ " Preparing Move: ") $ string(bPreparingMove)) $ "
";
            CommandText = ((((CommandText @ "RouteGoal: ") $ (GetItemName(string(RouteGoal)))) $ " RouteDist: ") $ string(RouteDist)) $ "
";
            I = 0;
            J0x5A5:

            if(I < RouteCache.Length)
            {
                if(RouteCache[I] == none)
                {
                    if(I > 5)
                    {
                        T = (T $ "--") $ (GetItemName(string(RouteCache[I - 1])));
                    }
                    goto J0x680;                    
                }
                else
                {
                    if(I < 5)
                    {
                        T = (T $ (GetItemName(string(RouteCache[I])))) $ "-";
                    }
                }
                ++ I;
                goto J0x5A5;
            }
            J0x680:

            CommandText = ((CommandText @ "RouteCache: ") $ T) $ "
";
        }
        OverheadTexts[OverheadTexts.Length] = CommandText;
        OverheadColors[OverheadTexts.Length - 1] = MakeColor(0, 200, 50);
        CommandText = "";
    }
    if(bShowMovement)
    {
        CommandText = "---------- AI MOVEMENT ----------
";
        if(IntermediateMoveGoal != none)
        {
            CommandText = ((CommandText @ "IntermediateMoveGoal:") $ string(IntermediateMoveGoal)) $ "
";
        }
        if(MoveTarget != none)
        {
            CommandText = ((CommandText @ "MoveTarget:") $ string(MoveTarget)) $ "
";
        }
        WanderCommand = FindCommandOfClass(Class'AICommand_Wander');
        if(WanderCommand != none)
        {
            CommandText = ((CommandText @ "AIC Wander Timer:") $ string(GetRemainingTimeForTimer('Timer_WanderDurationExpired', WanderCommand))) $ "
";
        }
        OverheadTexts[OverheadTexts.Length] = CommandText;
    }
    if(bShowCommands)
    {
        CommandText = "---------- AI Commands ----------
";
        if(AIActionStatus != "")
        {
            CommandText = ((CommandText @ "Status:") $ AIActionStatus) $ "
";
        }
    }
    if(bShowMovement || bShowCommands)
    {
        if(MyKFPawn.SpecialMove != 0)
        {
            CommandText = ((CommandText @ "SpecialMove:") $ string(MyKFPawn.SpecialMove)) $ "
";            
        }
        else
        {
            CommandText = CommandText @ "SpecialMove: NONE 
";
        }
    }
    OverheadTexts[OverheadTexts.Length] = CommandText;
    OverheadColors[OverheadTexts.Length - 1] = MakeColor(0, 200, 50);
    if(bShowCommands)
    {
        CommandText = "-- AICommand History --";
        OverheadTexts[OverheadTexts.Length] = CommandText;
        OverheadColors[OverheadTexts.Length - 1] = MakeColor(0, 255, 0);
        foreach AllCommands(Class'GameAICommand', Cmd)
        {
            if(Cmd.ChildCommand == none)
            {
                CommandText = (string(Cmd.Name) @ ":") @ string(Cmd.GetStateName());
                OverheadTexts[OverheadTexts.Length] = CommandText;
                OverheadColors[OverheadTexts.Length - 1] = MakeColor(0, 255, 0);                
            }
            else
            {
                CommandText = (string(Cmd.Name) @ ":") @ string(Cmd.GetStateName());
                OverheadTexts[OverheadTexts.Length] = CommandText;
                OverheadColors[OverheadTexts.Length - 1] = MakeColor(255, 128, 0);
            }
            ++ CmdCnt;            
        }        
        if(CmdCnt == 0)
        {
            CommandText = "No Active Command";
            OverheadTexts[OverheadTexts.Length] = CommandText;
            OverheadColors[OverheadTexts.Length - 1] = MakeColor(0, 200, 50);
        }
    }
}

state Dead
{
    ignores SeePlayer, HearNoise, KilledBy;

    function BeginState(name PreviousStateName)
    {
        AILog_Internal("DEAD", 'Damage');
        super(Object).BeginState(PreviousStateName);
    }
    stop;    
}

state DebugState
{
    function BeginState(name PreviousStateName)
    {
        AILog_Internal("BEGINSTATE" @ string(PreviousStateName), 'State');
    }

    function EndState(name NextStateName)
    {
        AILog_Internal("ENDSTATE" @ string(NextStateName), 'State');
    }

    function PushedState()
    {
        AILog_Internal("PUSHED", 'State');
    }

    function PoppedState()
    {
        AILog_Internal("POPPED", 'State');
    }

    function ContinuedState()
    {
        AILog_Internal("CONTINUED", 'State');
    }

    function PausedState()
    {
        AILog_Internal("PAUSED", 'State');
    }
    stop;    
}

state Action_Idle extends DebugState
{
    event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        Enable('SeePlayer');
        AILog_Internal("Entering Action_Idle() state, previous state was " $ string(PreviousStateName), 'Action_Idle');
        if(Pawn != none)
        {
            AILog_Internal("Action_Idle BeginState() calling Pawn.ZeroMovementVariables()", 'Action_Idle');
            AIZeroMovementVariables();
        }
    }

    function ContinuedState()
    {
        super.ContinuedState();
        if(Pawn != none)
        {
            AILog_Internal("Action_Idle ContinuedState() calling Pawn.ZeroMovementVariables()", 'Action_Idle');
            AIZeroMovementVariables();
        }
    }

    event EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        AILog_Internal("Ending Action_Idle state and going to " $ string(NextStateName), 'Action_Idle');
    }
Begin:

    Sleep(0);
    if(((MyKFPawn == none) || MyKFPawn.Health <= 0) || MyKFPawn.IsDoingSpecialMove())
    {
        Sleep(0.1);
        goto 'Begin';
    }
    AILog_Internal(string(self) $ " -- Begin Label", 'Action_Idle');
    if((Pawn != none) && Pawn.Physics == 2)
    {
        AIActionStatus = "Falling";
        WaitForLanding();
    }
    if(!MyKFPawn.bCrawler || !bSpawnedByEmergeSpecialMove)
    {
        Pawn.SetPhysics(1);
    }
    if(bForceDebugCommand)
    {
        BeginDebugCommand();
        stop;
    }
    goto 'IdleMoveToNearestEnemy';
IdleMoveToNearestEnemy:


    if(bIdleMoveToNearestEnemy)
    {
        if(Physics == 2)
        {
            WaitForLanding();
        }
        if(!FindNewEnemy())
        {
            SetEnemy(GetClosestEnemy());
        }
        if(Enemy != none)
        {
            AILog_Internal((string(self) $ " -- GetClosestEnemy() returned ") $ string(Enemy), 'Action_Idle');
            AIActionStatus = "Starting to hunt";
            BeginCombatCommand(GetDefaultCommand(), "Initial aggressive move");
            stop;            
        }
        else
        {
            AILog_Internal(string(self) $ " Pausing and going back to begin label - haven't found an enemy yet.", 'Action_Idle');
            AIActionStatus = "Can't find an enemy!";
            Sleep(0.5 + (FRand() * 1.5));
        }        
    }
    else
    {
        AILog_Internal(string(self) $ " Not moving yet because bIdleMoveToNearestEnemy is false", 'Action_Idle');
        Sleep(0.25 + (FRand() * 0.5));
    }
    goto 'Begin';
    stop;        
}

state ZedVictory
{
    function bool GetIsInZedVictoryState()
    {
        return true;
    }

    function bool CanDoStrike()
    {
        return false;
    }

    event bool CanGrabAttack()
    {
        return false;
    }
Begin:

    DisableMeleeRangeEventProbing();
    if(FRand() <= 0.6)
    {
        if(FRand() <= 0.5)
        {
            Class'AICommand_TauntEnemy'.static.Taunt(self, none, 1);            
        }
        else
        {
            Class'AICommand_TauntEnemy'.static.Taunt(self, none, 0);
        }        
    }
    else
    {
        DoWander(Pawn,, true);
    }
    Sleep(0);
    if(((MyKFPawn == none) || MyKFPawn.Health <= 0) || MyKFPawn.IsDoingSpecialMove())
    {
        Sleep(0.1);
        goto 'Begin';
    }
    if((Pawn != none) && Pawn.Physics == 2)
    {
        AIActionStatus = "Falling";
        WaitForLanding();
    }
    goto 'Begin';
    stop;            
}

defaultproperties
{
    bIdleMoveToNearestEnemy=true
    bAlwaysAcceptPartialPaths=true
    bSpecialBumpHandling=true
    bCanTeleportCloser=true
    bIgnoreStepAside=true
    bUseDesiredRotationForMelee=true
    bAllowCombatTransitions=true
    bUseUniqueAILogFile=true
    MeleeCommandClass=Class'AICommand_Base_Zed'
    DirectPathCheckFrequency_Min=0.1
    DirectPathCheckFrequency_Max=0.3
    DirectPathExtentModifier=1
    RotationRateMultiplier=1
    MinTimeBetweenLOSChecks=4
    MaxBlockedPathDuration=30
    PathNodeShowRouteCacheColor=(B=255,G=25,R=210,A=255)
    PathNodeShowRouteCacheCrossOffset=(X=0,Y=0,Z=25)
    PathNodeShowRouteCacheCrossSize=25
    PathNodeShowRouteCacheNumberLabelOffset=(X=0,Y=0,Z=30)
    PathNodeShowRouteCacheNumberLabelDuration=60
    PendingAnimStrikeIndex=255
    FrustrationThreshold=5
    Move_failure_type_none_color=(B=205,G=250,R=255,A=255)
    Move_failure_type_no_nav_mesh_path_color=(B=226,G=43,R=138,A=255)
    Move_failure_type_same_intermediate_point_too_many_times_color=(B=0,G=215,R=255,A=255)
    MoveFailureTypeTargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTo=(B=170,G=178,R=32,A=255)
    DefaultMaxTimeAllowedToStayStuckBeforeSuicide=5
    NoNavMeshPathMaxTimeAllowedToStayStuckBeforeSuicide=1
    SameIntermediatePointToManyTimesMaxTimeAllowedToStayStuckBeforeSuicide=5
    TargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTooMaxTimeAllowedToStayStuckBeforeSuicide=5
    SameIntermediatePointToManyTimesDurationAfterStartedMovingAgaintToStopStuckCheck=10
    DefaultMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide=5
    NoNavMeshPathMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide=1
    SameIntermediatePointToManyTimesMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide=200
    MovementPhaseTypePathNodeNormalMoveToIcon=Texture2D'AI_Debug_Helpers.MapIcon_PathNodeMoveTo'
    MovementPhaseTypePathNodeMoveFailedIcon=Texture2D'AI_Debug_Helpers.MapIcon_FailedMove'
    MovementPhaseTypePathNodeMoveToPointIcon=Texture2D'AI_Debug_Helpers.MapIcon_MoveToAPoint'
    MovementPhaseTypePathNodeRotateToFocusIcon=Texture2D'AI_Debug_Helpers.MapIcon_RotateToFocus'
    MovementPhaseTypePathNodeDelayMoveIcon=Texture2D'AI_Debug_Helpers.MapIcon_AIDelay'
    MovementPhaseTypeUnknownIcon=Texture2D'AI_Debug_Helpers.UnknownMovementPhase'
    MovementPhaseTypeNavMeshNormalMoveToIcon=Texture2D'AI_Debug_Helpers.NavMeshMoveTo'
    MovementPhaseTypeFinalDestMoveTowardsIcon=Texture2D'AI_Debug_Helpers.FinalDestMoveTowards'
    MovementPhaseTypeEMT_LOS_MoveTowardsIcon=Texture2D'AI_Debug_Helpers.LOS_MoveTowards'
    MovementPhaseTypeMovingToNavMeshUsingPathNodesIcon=Texture2D'AI_Debug_Helpers.WallToNavMesh'
    MovementPhaseTypeFALLBACK_REFUSED_TO_BE_EXPLOTIED_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon=Texture2D'AI_Debug_Helpers.FindNearbyMeshPointRefusedToBeExplotied'
    MovementPhaseTypeFALLBACK_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon=Texture2D'AI_Debug_Helpers.FindNearbyMeshPoint'
    TypeOfMovementStuckOnUnknownWhyIcon=Texture2D'AI_Debug_Helpers.StuckUnknown'
    TypeOfMovementStuckOnMOVE_FAILURE_TYPE_NO_NAV_MESH_PATHIcon=Texture2D'AI_Debug_Helpers.NoNavStuck'
    TypeOfMovementStuckOnMOVE_FAILURE_TYPE_SAME_INTERMEDIATE_POINT_TOO_MANY_TIMESIcon=Texture2D'AI_Debug_Helpers.TriskelionStuck'
    TypeOfMovementStuckOnMOVE_FAILURE_TYPE_TARGET_OFF_NAV_MESH_AND_CAN_NOT_FIND_LOCAITON_NEAR_THEM_I_CAN_MOVE_TOIcon=Texture2D'AI_Debug_Helpers.EnemyOffNavMeshAndCanDoNothing'
    TypeOfMovementStuckOnLookingForBetterIntermediateLoc=Texture2D'AI_Debug_Helpers.LookingForBetterInter'
    TypeOfMovementStuckOnMoveToBetterIntermediate=Texture2D'AI_Debug_Helpers.MoveToBetterIntermediate'
    ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff=(B=0,G=215,R=0,A=255)
    ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn=(B=0,G=251,R=255,A=255)
    DistanceToCheckForClearPathOnNavMeshLocWhenOffNavMesh=512
    DistanceToCheckForNonExploitedOnNavMeshLocWhenOffNavMesh=2056
    DistanceToCheckForNonExploitedOnNavMeshLocWhenOnDeadEndOfNavMesh=512
    DefaultColorOfValidLocationWhenLookingForLocationsOnNavMesh=(B=0,G=255,R=255,A=255)
    DefaultColorOfSearchSphereWhenNoValidLocationsFoundWhenLookingForLocationsOnNavMesh=(B=0,G=255,R=255,A=255)
    ColorOfValidLocationFoundFor1stTryLookingForLocationsOnNavMesh=(B=0,G=255,R=0,A=255)
    ColorOfSearchSphereWhenNoValidLocationsFoundFor1stTryLookingForLocationsOnNavMesh=(B=0,G=255,R=255,A=255)
    ColorOfValidLocationFoundFor2ndTryLookingForLocationsOnNavMesh=(B=255,G=255,R=0,A=255)
    ColorOfSearchSphereWhenNoValidLocationsFoundFor2ndTryLookingForLocationsOnNavMesh=(B=0,G=0,R=255,A=255)
    ColorOfValidLocationFoundFor3rdTryLookingForLocationsOnNavMesh=(B=0,G=0,R=0,A=255)
    ColorOfSearchSphereWhenNoValidLocationsFoundFor3rdTryLookingForLocationsOnNavMesh=(B=0,G=0,R=0,A=255)
    ColorOfValidLocationFoundForLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh=(B=237,G=149,R=100,A=255)
    ColorOfSearchSphereWhenNoValidLocationsFoundForTryLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh=(B=255,G=245,R=0,A=255)
    DistanceToCheckForClearPathOnNavMeshLocWhenEnemyIsOffNavMesh=200
    DistanceToCheckForNonExploitedOnNavMeshLocWhenEnemyIsOffNavMesh=500
    GeneralGoalDistanceForMovingToDoor=256
    RecastEnemyRepathDistance=512
    DropEdgeLeapVelocity=(X=400,Y=0,Z=400)
    MaxRangeToDropEdgeAllowedToLeadFrom=100
    DistanceDownRangeToFocusForDropEdgeLeap=1000
    TimeToShowEdgeTypeForNavMeshPathting=20
    BumpThreshold=10
    BumpDecayRate=0.5
    BumpGrowthRate=10
    StuckCheckInterval=0.5
    StuckVelocityThreshholdSquared=625
    StuckPossiblityThreshhold=5
    TeleportCheckInterval=1
    TeleportCooldown=7
    HiddenRelocateTeleportThreshold=5
    PostSpawnRelocateTeleportCooldown=10
    XYMoveStuckThresholdSquared=625
    StuckCheckEnemyDistThreshholdSquared=1000000
    NavigationBumpTeamCollisionThreshholdSquared=1000000
    MaxStepAsideDist=128
    StrikeRangePercentage=0.85
    DoorMeleeDistance=200
    MaxMeleeHeightAngle=0.64
    MinTimeBetweenEnemyChanges=5
    EvadeGrenadeChance=1
    MaxGetStrikeTime=0.25
    FrustrationDelay=2.5
    LowIntensityAttackCooldown=2
    BaseShapeOfProjectileForCalc=(X=1,Y=1,Z=1)
    ZedBumpEffectThreshold=270
    ZedBumpObliterationEffectChance=0.4
    AggroPlayerHealthPercentage=0.1
    AggroPlayerResetTime=10
    MinDistanceToAggroZed=1500
    AggroZedResetTime=30
    AggroZedHealthPercentage=0.15
    RepeatWalkingTauntTime=15
    bAlwaysAssignEnemy=false
    PlugInHistoryNum=25
    CommandHistoryNum=25
    AILogFilter=/* Array type was not detected. */
    bIsPlayer=true
    bSkipExtraLOSChecks=true
    bNotifyFallingHitWall=true
    NavigationHandleClass=none
    InUseNodeCostMultiplier=3
    RotationRate=(Pitch=50000,Yaw=50000,Roll=50000)
}