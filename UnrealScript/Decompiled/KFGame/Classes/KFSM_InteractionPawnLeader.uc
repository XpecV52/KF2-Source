/*******************************************************************************
 * KFSM_InteractionPawnLeader generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_InteractionPawnLeader extends KFSpecialMove
    abstract
    native(SpecialMoves);

var protected transient CameraAnimInst ExecutionCameraAnimInst_Leader;
var protected transient CameraAnimInst ExecutionCameraAnimInst_Follower;
var KFPawn Follower;
var KFPawn.ESpecialMove FollowerSpecialMove;
var float InteractionStartTimeOut;
var bool bAlignPawns;
var bool bAlignLeaderLocation;
var bool bAlignFollowerZ;
var bool bAlignFollowerLookSameDirAsMe;
var bool bAlignLeaderRotation;
var bool bAlignFollowerRotation;
var bool bStopAlignFollowerRotationAtGoal;
var bool bAlignHumanFollowerControllerRotation;
var bool bRetryCollisionCheck;
var float AlignDistance;
var float AlignDistanceThreshold;
var float AlignFollowerInterpSpeed;
var int LeaderRelativeYawOffset;
var float AlignSpeedModifier;

// Export UKFSM_InteractionPawnLeader::execGetClipSafeMeshTranslation(FFrame&, void* const)
native function Vector GetClipSafeMeshTranslation(out Vector TargetRelativeOffset);

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    super.SpecialMoveStarted(bForced, PrevMove);
    Follower = none;
    bAlignFollowerLookSameDirAsMe = default.bAlignFollowerLookSameDirAsMe;
    bAlignPawns = default.bAlignPawns;
    bAlignFollowerRotation = default.bAlignFollowerRotation;
    PawnOwner.SetTimer(InteractionStartTimeOut, false, 'InteractionStartTimedOut', self);
    CheckReadyToStartInteraction();
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    PawnOwner.ClearTimer('CheckReadyToStartInteraction', self);
    PawnOwner.ClearTimer('InteractionStartTimedOut', self);
    PawnOwner.ClearTimer('RetryCollisionTimer', self);
    if(bAlignPawns)
    {
        PawnOwner.ZeroMovementVariables();
        if(Follower != none)
        {
            Follower.ZeroMovementVariables();
        }
    }
    Follower = none;
    if(ExecutionCameraAnimInst_Leader != none)
    {
        if(PCOwner != none)
        {
            PCOwner.PlayerCamera.StopCameraAnim(ExecutionCameraAnimInst_Leader);
        }
        ExecutionCameraAnimInst_Leader = none;
    }
    if(ExecutionCameraAnimInst_Follower != none)
    {
        if(PCOwner != none)
        {
            PCOwner.PlayerCamera.StopCameraAnim(ExecutionCameraAnimInst_Follower);
        }
        ExecutionCameraAnimInst_Follower = none;
    }
    super.SpecialMoveEnded(PrevMove, NextMove);
}

function InteractionStartTimedOut()
{
    local KFPawn KFP;

    KFP = KFPawn(PawnOwner);
    if(KFP.SpecialMoves[KFP.SpecialMove] == self)
    {
        WarnInternal((((((string(KFP.WorldInfo.TimeSeconds) @ string(KFP)) @ string(Class)) @ string(GetFuncName())) @ "InteractionStartTimeOut hit!! Aborting move.") @ string(Follower)) @ string(Follower.SpecialMove));
        KFP.EndSpecialMove(,, true);
    }
}

final function CheckReadyToStartInteraction()
{
    local KFSM_InteractionPawnFollower FollowerSM;

    if(KFPOwner.InteractionPawn != none)
    {
        Follower = KFPOwner.InteractionPawn;
        if(PawnOwner.WorldInfo.NetMode != NM_Client)
        {
            if((Follower != none) && Follower.Health > 0)
            {
                if(!Follower.IsDoingSpecialMove(FollowerSpecialMove))
                {
                    Follower.DoSpecialMove(FollowerSpecialMove, true, PawnOwner);
                }                
            }
            else
            {
                if(KFPOwner.bLogSpecialMove)
                {
                    WarnInternal((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Follower not gameplay relevant, Interaction cannot be started!!!") @ string(Follower)) @ string(Follower.SpecialMove));
                }
                KFPOwner.EndSpecialMove(KFPOwner.SpecialMove);
                return;
            }
        }
    }
    if(!IsReadyToStartInteraction())
    {
        if(Follower == none)
        {
            if(KFPOwner.bLogSpecialMove)
            {
                LogInternal(((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Not ready to StartInteraction, delay... Follower:") @ string(Follower), 'SpecialMoves');
            }            
        }
        else
        {
            if(KFPOwner.bLogSpecialMove)
            {
                LogInternal(((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Not ready to StartInteraction, delay... Follower:") @ string(Follower)) @ "Follower.SpecialMove:") @ string(Follower.SpecialMove), 'SpecialMoves');
            }
        }
        PawnOwner.SetTimer(PawnOwner.WorldInfo.DeltaSeconds, false, 'CheckReadyToStartInteraction', self);        
    }
    else
    {
        if(KFPOwner.bLogSpecialMove)
        {
            LogInternal(((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "StartInteraction. Follower:") @ string(Follower)) @ "Follower.SpecialMove:") @ string(Follower.SpecialMove), 'SpecialMoves');
        }
        PawnOwner.ClearTimer('CheckReadyToStartInteraction', self);
        PawnOwner.ClearTimer('InteractionStartTimedOut', self);
        FollowerSM = KFSM_InteractionPawnFollower(Follower.SpecialMoves[FollowerSpecialMove]);
        FollowerSM.InteractionStarted();
        StartInteraction();
    }
}

function bool IsReadyToStartInteraction()
{
    return (Follower != none) && Follower.IsDoingSpecialMove(FollowerSpecialMove);
}

function StartInteraction()
{
    if(bRetryCollisionCheck && PawnOwner.Role == ROLE_Authority)
    {
        PawnOwner.SetTimer(0.5, true, 'RetryCollisionTimer', self);
    }
}

function RetryCollisionTimer()
{
    LogInternal("zdist:" @ string(Abs(Follower.Location.Z - PawnOwner.Location.Z)));
    if((Abs(Follower.Location.Z - PawnOwner.Location.Z) > (PawnOwner.CylinderComponent.CollisionHeight * 1.5)) || !IsFollowerReachable())
    {
        KFPOwner.EndSpecialMove();
    }
}

function bool IsFollowerReachable()
{
    local Vector HitLocation, HitNormal;
    local Actor HitActor;

    HitActor = PawnOwner.WorldInfo.Trace(HitLocation, HitNormal, Follower.Location, PawnOwner.Location, false);
    if((HitActor != none) && HitActor != Follower)
    {
        return false;
    }
    return true;
}

function bool MessageEvent(name EventName, Object Sender)
{
    if(EventName == 'FollowerLeavingSpecialMove')
    {
        OnFollowerLeavingSpecialMove();
        return true;
    }
    return super(GameSpecialMove).MessageEvent(EventName, Sender);
}

function OnFollowerLeavingSpecialMove();

function DebugSocketRelativeLocation(name InSocketName)
{
    local Vector MarkerLoc;
    local Rotator MarkerRot;

    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(InSocketName, MarkerLoc, MarkerRot);
    PawnOwner.DrawDebugSphere(MarkerLoc, 4, 8, 255, 0, 255, true);
}

function bool PlayExecutionCameraAnim(const out array<CameraAnim> InCameraAnims, optional out CameraAnimInst LeaderAnimInst, optional float BlendInTime, optional float BlendOutTime)
{
    local KFPlayerController FollowerPC;
    local int AnimIdx;
    local CameraAnimInst FollowerAnimInst;
    local ViewTargetTransitionParams TransitionParams;

    BlendInTime = 0.25;
    BlendOutTime = 0.25;
    FollowerPC = KFPlayerController(Follower.Controller);
    if(PCOwner != none)
    {
        AnimIdx = FollowerPC.ChooseRandomCameraAnim(InCameraAnims);
    }
    if(PawnOwner.IsLocallyControlled() && AnimIdx != -1)
    {
        LeaderAnimInst = PlayCameraAnim(PawnOwner, InCameraAnims[AnimIdx],,, BlendInTime, BlendOutTime);
        ExecutionCameraAnimInst_Leader = LeaderAnimInst;
    }
    if((FollowerPC != none) && Follower.IsHumanControlled())
    {
        if(FollowerPC.GetViewTarget() != PawnOwner)
        {
            TransitionParams.BlendTime = 0;
            FollowerPC.SetViewTarget(PawnOwner, TransitionParams);
        }
        AnimIdx = FollowerPC.ChooseRandomCameraAnim(InCameraAnims);
        if(Follower.IsLocallyControlled())
        {
            FollowerAnimInst = PlayCameraAnim(Follower, InCameraAnims[AnimIdx],,, BlendInTime, BlendOutTime);
            ExecutionCameraAnimInst_Follower = FollowerAnimInst;
        }
    }
    return (FollowerAnimInst != none) || LeaderAnimInst != none;
}

function AttachFollowerToLeader(name SocketName, optional Vector AttachLocation, optional Rotator AttachRotation)
{
    local SkeletalMeshSocket Socket;

    Follower.bForceNetUpdate = true;
    Follower.SetBase(none);
    Follower.SetPhysics(0);
    Follower.SetHardAttach(true);
    Follower.SetCollision(true, false);
    Follower.bCollideWorld = false;
    Socket = PawnOwner.Mesh.GetSocketByName(SocketName);
    if(Socket != none)
    {
        Follower.SetBase(PawnOwner,, PawnOwner.Mesh, Socket.BoneName);
        Follower.SetRelativeLocation(Socket.RelativeLocation - Follower.default.Mesh.Translation);        
    }
    else
    {
        if(PawnOwner.Mesh.MatchRefBone(SocketName) != -1)
        {
            Follower.SetBase(PawnOwner,, PawnOwner.Mesh, SocketName);
            Follower.SetRelativeLocation(AttachLocation);
            Follower.SetRelativeRotation(AttachRotation);            
        }
        else
        {
            WarnInternal(((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(Class)) @ string(GetFuncName())) @ "Leader") @ string(PawnOwner.Class)) @ "Has no attachment socket") @ string(SocketName)) @ "!!!!");
            if(AttachRotation != rot(0, 0, 0))
            {
                Follower.SetRotation(AttachRotation);                
            }
            else
            {
                Follower.SetRotation(PawnOwner.Rotation);
            }
            if(AttachLocation != vect(0, 0, 0))
            {
                Follower.SetLocation(AttachLocation);                
            }
            else
            {
                Follower.SetLocation(PawnOwner.Location);
            }
            Follower.SetBase(PawnOwner);
        }
    }
    Follower.SetPhysics(0);
    if(KFPOwner.bLogSpecialMove)
    {
        LogInternal(((((((((((((((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Attached Follower:") @ string(Follower)) @ "BaseSkelComponent:") @ string(Follower.BaseSkelComponent)) @ "SocketName:") @ string(SocketName)) @ "BaseBoneName:") @ string(Follower.BaseBoneName)) @ "RelativeLocation:") @ string(Follower.RelativeLocation)) @ "RelativeRotation:") @ string(Follower.RelativeRotation)) @ "bHardAttach:") @ string(Follower.bHardAttach)) @ "bIgnoreBaseRotation:") @ string(Follower.bIgnoreBaseRotation), 'SpecialMoves');
    }
}

function DetachPawn(Pawn aPawn)
{
    DetachPawnHelper(aPawn);
}

static function DetachPawnHelper(Pawn aPawn)
{
    aPawn.SetBase(none);
    aPawn.SetHardAttach(false);
    aPawn.SetPhysics(2);
    if(!aPawn.bTearOff)
    {
        aPawn.SetCollision(true, true);
    }
    aPawn.bCollideWorld = true;
    aPawn.Mesh.SetShadowParent(none);
}

function bool CanInteractWithPawn(KFPawn OtherPawn)
{
    return true;
}

defaultproperties
{
    InteractionStartTimeOut=4
    bAlignLeaderLocation=true
    bAlignLeaderRotation=true
    bAlignFollowerRotation=true
    bRetryCollisionCheck=true
    AlignDistanceThreshold=0.3
    AlignFollowerInterpSpeed=8
    AlignSpeedModifier=0.5
}