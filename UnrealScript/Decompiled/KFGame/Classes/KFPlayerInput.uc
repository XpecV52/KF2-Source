/*******************************************************************************
 * KFPlayerInput generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPlayerInput extends MobilePlayerInput within KFPlayerController
    transient
    native(Controller)
    config(Input)
    hidecategories(Object,UIRoot);

var config bool bRequiresPushToTalk;
var config bool bQuickWeaponSelect;
var transient bool bIronsightsHeld;
var bool bGamepadWeaponSelectOpen;
var bool bShowGamepadWeaponSelectHint;
var config bool bInvertController;
var config bool bUseGamepadLastWeapon;
var transient bool bExtendedSprinting;
/** Toggles for all aim assists (friction, adhesion, lock-on) */
var(AimAssistGlobal) config bool bAimAssistEnabled;
/** Whether to use turn smoothing / blending or not */
var(ViewSmoothing) bool bViewSmoothingEnabled;
/** Whether ViewAcceleration is enabled or not */
var(ViewAcceleration) config bool bViewAccelerationEnabled;
var protected config bool bDebugViewAcceleration;
/** Whether TargetFriction is enabled or not */
var(Friction) config bool bTargetFrictionEnabled;
var protected config bool bDebugTargetFriction;
/** Whether TargetAdhesion is enabled or not */
var(Adhesion) config bool bTargetAdhesionEnabled;
/** Whether TargetAdhesion is enabled or not */
var(AutoTarget) config bool bAutoTargetEnabled;
/** @name  Force Feedback */
var(ForceFeedback) config bool bForceFeedbackEnabled;
var bool bVersusInput;
var transient float PressedJumpTime;
var transient float RawJoyMagnitude;
var transient float RawJoyLookMagnitude;
var config float GamepadButtonHoldTime;
var config float SprintAnalogThreshold;
var transient float GamepadSprintAnalogStart;
var config int CurrentLayoutIndex;
/** Interp curve that allows for piece wise functions for the TargetFrictionDistance amount at different ranges */
var(Sensitivity) InterpCurveFloat LookSensitivityScaleCurve;
var(Sensitivity) InterpCurveFloat MoveSensitivityScaleCurve;
/** Unified global scalar for joystick sensitivity */
var(Sensitivity) config float GamepadSensitivityScale;
/** Multiplier used to scale look sensitivity while sprinting. */
var(Sensitivity) float SprintingSensitivityScale;
/** Used to scale the sensitivity of the mouse based on how zoomed the player is. */
var(Sensitivity) config float ZoomedSensitivityScale;
/** Used to scale the sensitivity of the joystick based on how zoomed the player is. */
var(Sensitivity) config float GamepadZoomedSensitivityScale;
/** Max acceleration units per second (since the joystick max value is 1, setting to 1 means take 1 second to get to max turn speed if starting at 0) */
var(ViewSmoothing) float ViewSmoothing_MaxAccel;
/** Similar to MaxAccel. Should be larger then accel. */
var(ViewSmoothing) float ViewSmoothing_MaxDecel;
var transient float PrevTurn;
var transient float PrevLookUp;
var transient float CurrTurn;
var transient float CurrLookUp;
/** Joystick vector must be greater than this to trigger view acceleration (magnitude range is 0 to 1, regardless of direction) */
var(ViewAcceleration) float ViewAccel_JoyMagThreshold;
/** Joystick Y-value must be less than this to trigger view acceleration (Y-value range is from -1 to 1) */
var(ViewAcceleration) float ViewAccel_JoyPitchThreshold;
/** Max turn speed */
var(ViewAcceleration) float ViewAccel_MaxTurnSpeed;
/** How long to blend to max turn speed */
var(ViewAcceleration) float ViewAccel_BlendTime;
var transient float ViewAccel_BlendTimer;
var float RemainingaTurn;
var float RemainingaLookUp;
/** How much friction reduces rotation */
var(Friction) float FrictionScale;
var private Pawn LastFrictionTarget;
var private float LastFrictionTargetTime;
var private float LastaTurn;
var private float LastaLookUp;
var private float LastaForward;
var private float LastaStrafe;
/** Interp curve to scale Friction angle for different ranges */
var(Friction) InterpCurveFloat FrictionAngleCurve;
/** How much to scale friction when view acceleration (turn assist) is being applied */
var(Friction) float ViewAccelerationFrictionScale;
/** Interp curve to scale Adhesion angle for different ranges */
var(Adhesion) InterpCurveFloat AdhesionAngleCurve;
/** How strongly adhesion affects player view */
var(Adhesion) float AdhesionFactor;
var private Pawn LastAdhesionTarget;
var transient Vector AdhesionTargetLastLoc;
var transient Vector AdhesionPawnLastLoc;
/** How long to auto target for when going to iron sights */
var(AutoTarget) float AutoTargetTimeLeft;
var Vector AutoTargetInitialLocation;
var Pawn CurrentAutoTarget;
var name CurrentAutoTargetBone;
/** How fast to rotate towards autotarget location */
var(AutoTarget) float AutoTargetRotationRate;
/** Interp curve to scale autotarget angle for different ranges */
var(AutoTarget) InterpCurveFloat AutoTargetAngleCurve;
var(AutoTarget) InterpCurveFloat AutoTargetWeakspotCurve;
/** Disallow auto-target spamming */
var(AutoTarget) float AutoTargetCooldown;
var transient float LastAutoTargetTime;
/** Force rotation to within this angle when using the ForceLookAtPawn functionality */
var(AutoTarget) float ForceLookAtPawnMinAngle;
/** How fast to rotate towards ForceLookAtPawn location */
var(AutoTarget) float ForceLookAtPawnRotationRate;
/** How fast to rotate towards ForceLookAtPawn location dampened for closer rotation */
var(AutoTarget) float ForceLookAtPawnDampenedRotationRate;
var const float DoubleTapDelay;

// Export UKFPlayerInput::execGetKeyBindFromCommand(FFrame&, void* const)
native function GetKeyBindFromCommand(out KeyBind MyKeyBind, string bindCommand, optional bool bAlt);

// Export UKFPlayerInput::execSwapBind(FFrame&, void* const)
native function SwapBind(out KeyBind MainKeyBind, out KeyBind AltKeyBind);

// Export UKFPlayerInput::execSetKeyBind(FFrame&, void* const)
native function SetKeyBind(out KeyBind MyKeyBind, string Command, bool overwritePrevCommand);

// Export UKFPlayerInput::execRemoveCommandFromBind(FFrame&, void* const)
native function RemoveCommandFromBind(out KeyBind MyKeyBind, string CommandToRemove);

// Export UKFPlayerInput::execGetBindingsIndex(FFrame&, void* const)
native function int GetBindingsIndex(out KeyBind MyKeyBind);

// Export UKFPlayerInput::execResetKeysToDefault(FFrame&, void* const)
native static function ResetKeysToDefault();

// Export UKFPlayerInput::execSetGamepadLayout(FFrame&, void* const)
native exec function SetGamepadLayout(int layoutIndex);

// Export UKFPlayerInput::execGetBindDisplayName(FFrame&, void* const)
native function string GetBindDisplayName(out KeyBind MyKeyBind);

// Export UKFPlayerInput::execGetGameBindableAction(FFrame&, void* const)
native function string GetGameBindableAction(const out name Key);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    if(HUD.ShouldDisplayDebug('Input'))
    {
        HUD.Canvas.SetDrawColor(0, 255, 0);
        HUD.Canvas.DrawText((("AXIS: ATurn: " $ string(LastaTurn)) $ " aLookUp: ") $ string(LastaLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Raw: RawJoyLookRight: " $ string(RawJoyLookRight)) $ " RawJoyLookUp: ") $ string(RawJoyLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Remaining: RemainingaTurn: " $ string(RemainingaTurn)) $ " RemainingaLookUp: ") $ string(RemainingaLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("AXIS: aForward: " $ string(LastaForward)) $ " aStrafe: ") $ string(LastaStrafe));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Raw: RawJoyRight: " $ string(RawJoyRight)) $ " RawJoyUp: ") $ string(RawJoyUp));
        out_YPos += out_YL;
        HUD.Canvas.DrawText("Raw: TotalRawStrafe: " $ string(Abs(RawJoyRight) + Abs(RawJoyUp)));
        out_YPos += out_YL;
    }
}

function ClientInitInputSystem()
{
    super.ClientInitInputSystem();
    if(bRequiresPushToTalk)
    {
        Outer.ClientStopNetworkedVoice();        
    }
    else
    {
        Outer.ClientStartNetworkedVoice();
    }
}

function UpdatePushToTalk(bool bValue)
{
    if(bValue != bRequiresPushToTalk)
    {
        if(bValue)
        {
            Outer.ClientStopNetworkedVoice();            
        }
        else
        {
            Outer.ClientStartNetworkedVoice();
        }
        bRequiresPushToTalk = bValue;
        SaveConfig();
    }
}

exec function SetSensitivity(float F)
{
    MouseSensitivity = F;
}

exec function SetZoomedSensitivity(float F)
{
    ZoomedSensitivityScale = F;
}

function Engine.Actor.EDoubleClickDir CheckForDoubleClickMove(float DeltaTime)
{
    local int MappedOutput;
    local float MinCurveOut, MaxCurveOut, CurveOut, CurvePct;

    if(!bUsingGamepad || Outer.bRun > 0)
    {
        return 0;
    }
    CurveOut = EvalInterpCurveFloat(MoveSensitivityScaleCurve, RawJoyMagnitude);
    MinCurveOut = MoveSensitivityScaleCurve.Points[0].OutVal;
    MaxCurveOut = MoveSensitivityScaleCurve.Points[MoveSensitivityScaleCurve.Points.Length - 1].OutVal;
    CurvePct = (CurveOut - MinCurveOut) / (MaxCurveOut - MinCurveOut);
    MappedOutput = int(float(Outer.4) - (CurvePct * float(Outer.4)));
    return byte(MappedOutput);
}

event PlayerInput(float DeltaTime)
{
    local float FOVScale, TimeScale;
    local Vector RawJoyVector;

    RawJoyUp = aBaseY;
    RawJoyRight = aStrafe;
    RawJoyLookRight = aTurn;
    RawJoyLookUp = aLookUp;
    RawJoyVector.X = RawJoyRight;
    RawJoyVector.Y = RawJoyUp;
    RawJoyMagnitude = VSize2D(RawJoyVector);
    RawJoyVector.X = RawJoyLookRight;
    RawJoyVector.Y = RawJoyLookUp;
    RawJoyLookMagnitude = VSize2D(RawJoyVector);
    DeltaTime /= Outer.WorldInfo.TimeDilation;
    if(Outer.bDemoOwner && Outer.WorldInfo.NetMode == NM_Client)
    {
        DeltaTime /= Outer.WorldInfo.DemoPlayTimeDilation;
    }
    PreProcessInput(DeltaTime);
    TimeScale = 100 * DeltaTime;
    aBaseY *= (TimeScale * MoveForwardSpeed);
    aStrafe *= (TimeScale * MoveStrafeSpeed);
    aUp *= (TimeScale * MoveStrafeSpeed);
    aTurn *= (TimeScale * LookRightScale);
    aLookUp *= (TimeScale * LookUpScale);
    PostProcessInput(DeltaTime);
    ProcessInputMatching(DeltaTime);
    CatchDoubleClickInput();
    FOVScale = 1;
    AdjustMouseSensitivity(FOVScale);
    if(bEnableMouseSmoothing)
    {
        aMouseX = SmoothMouse(aMouseX, DeltaTime, bXAxis, 0);
        aMouseY = SmoothMouse(aMouseY, DeltaTime, bYAxis, 1);
    }
    aLookUp *= FOVScale;
    aTurn *= FOVScale;
    if(bStrafe > 0)
    {
        aStrafe += (aBaseX + aMouseX);        
    }
    else
    {
        aTurn += (aBaseX + aMouseX);
    }
    aLookUp += aMouseY;
    if((!GetUsingGamepad(Outer) && bInvertMouse) || bInvertController && GetUsingGamepad(Outer))
    {
        aLookUp *= -1;
    }
    if(bInvertTurn)
    {
        aTurn *= -1;
    }
    aForward += aBaseY;
    Outer.HandleWalking();
    if(bLockTurnUntilRelease)
    {
        if(RawJoyLookRight != float(0))
        {
            aTurn = 0;
            if(AutoUnlockTurnTime > 0)
            {
                AutoUnlockTurnTime -= DeltaTime;
                if(AutoUnlockTurnTime < 0)
                {
                    bLockTurnUntilRelease = false;
                }
            }            
        }
        else
        {
            bLockTurnUntilRelease = false;
        }
    }
    if(Abs((aTurn % float(1)) + RemainingaTurn) >= 1)
    {
        aTurn += RemainingaTurn;
        RemainingaTurn = 0;
    }
    if(Abs((aLookUp % float(1)) + RemainingaLookUp) >= 1)
    {
        aLookUp += RemainingaLookUp;
        RemainingaLookUp = 0;
    }
    if(Outer.IsMoveInputIgnored())
    {
        aForward = 0;
        aStrafe = 0;
        aUp = 0;
    }
    if(Outer.IsLookInputIgnored())
    {
        aTurn = 0;
        aLookUp = 0;
    }
    LastaTurn = aTurn;
    LastaLookUp = aLookUp;
    LastaForward = aForward;
    LastaStrafe = aStrafe;
    if(aTurn != float(0))
    {
        RemainingaTurn += (aTurn % float(1));        
    }
    else
    {
        RemainingaTurn = 0;
    }
    if(aLookUp != float(0))
    {
        RemainingaLookUp += (aLookUp % float(1));        
    }
    else
    {
        RemainingaLookUp = 0;
    }
}

function AdjustMouseSensitivity(float FOVScale)
{
    local float UsedFOVAngle;
    local bool bUsingSights;

    if(bEnableFOVScaling)
    {
        if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
        {
            bUsingSights = Outer.Pawn.bIsWalking;
            UsedFOVAngle = Outer.Pawn.Weapon.GetModifiedFOVAngle();            
        }
        else
        {
            UsedFOVAngle = Outer.GetFOVAngle();
        }
        if((UsedFOVAngle != Outer.DefaultFOV) && bUsingSights)
        {
            FOVScale = (UsedFOVAngle * 0.01333) * ZoomedSensitivityScale;            
        }
        else
        {
            FOVScale = 1;
        }
    }
    super(PlayerInput).AdjustMouseSensitivity(FOVScale);
}

function BindKey(KeyBind NewKeyBind, string bindCommand, bool bIsAlt)
{
    local KeyBind CurrentKeyBind;

    GetKeyBindFromCommand(CurrentKeyBind, bindCommand, bIsAlt);
    if(CurrentKeyBind.Name != 'None')
    {
        RemoveCommandFromBind(CurrentKeyBind, bindCommand);
        if(NewKeyBind.Name == 'Delete')
        {
            return;
        }
    }
    SetKeyBind(NewKeyBind, bindCommand, false);
    SaveConfig();
    SwapPositions(NewKeyBind, bindCommand, bIsAlt);
}

function SwapPositions(KeyBind MyKeyBind, string bindCommand, bool bIsAlt)
{
    local KeyBind NewKeyBind;

    GetKeyBindFromCommand(NewKeyBind, bindCommand, false);
    if(bIsAlt && MyKeyBind.Name == NewKeyBind.Name)
    {
        GetKeyBindFromCommand(NewKeyBind, bindCommand, true);
        SwapBind(MyKeyBind, NewKeyBind);        
    }
    else
    {
        if(!bIsAlt && MyKeyBind.Name != NewKeyBind.Name)
        {
            SwapBind(MyKeyBind, NewKeyBind);
        }
    }
}

static function bool GetUsingGamepad(PlayerController PC)
{
    if((PC == none) || PC.PlayerInput == none)
    {
        return false;
    }
    return PC.PlayerInput.bUsingGamepad;
}

exec function GamepadSprint()
{
    Outer.bRun = 0;
    bExtendedSprinting = false;
    GamepadSprintAnalogStart = GetLeftAnalogDistance();
    GamepadSprintTimer();
    if(Outer.bRun == 0)
    {
        Outer.SetTimer(0.05, true, 'GamepadSprintTimer', self);
    }
}

function GamepadSprintTimer()
{
    if(ShouldActivateGamepadSprint())
    {
        Outer.bRun = 1;
        Outer.ClearTimer('GamepadSprintTimer', self);
    }
}

exec function GamepadSprintRelease()
{
    if(ShouldActivateGamepadSprint())
    {
        bExtendedSprinting = true;        
    }
    else
    {
        if(Outer.bRun == 0)
        {
            ToggleCrouch();
        }
    }
    Outer.bRun = 0;
    Outer.ClearTimer('GamepadSprintTimer', self);
}

function float GetLeftAnalogDistance()
{
    local Vector vAnalog;

    vAnalog.X = RawJoyRight;
    vAnalog.Y = RawJoyUp;
    return VSize2D(vAnalog);
}

function bool ShouldActivateGamepadSprint()
{
    local float Distance, Bias, Delta;

    Distance = GetLeftAnalogDistance();
    Delta = Distance - GamepadSprintAnalogStart;
    if(Delta > 0.2)
    {
        Bias = 0.3;
    }
    return (Distance + Bias) > SprintAnalogThreshold;
}

exec function Jump()
{
    if(bVersusInput)
    {
        JumpVersus();
        return;
    }
    Outer.bDuck = 0;
    PressedJumpTime = Outer.WorldInfo.TimeSeconds;
    super(PlayerInput).Jump();
}

exec function StartCrouch()
{
    if((Outer.Pawn != none) && Outer.Pawn.bCanCrouch)
    {
        Outer.bDuck = 1;
    }
}

exec function StopCrouch()
{
    if(Outer.bDuck == 1)
    {
        Outer.bDuck = 0;
    }
}

exec function ToggleCrouch()
{
    if((Outer.Pawn != none) && Outer.Pawn.bCanCrouch)
    {
        Outer.bDuck = ((Outer.bDuck == 0) ? 1 : 0);
    }
}

exec function GamepadCrouch()
{
    ToggleCrouch();
    if(Outer.bDuck == 1)
    {
        Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadCrouchTimer', self);
    }
}

exec function GamepadCrouchRelease()
{
    local bool bWasButtonHeld;

    bWasButtonHeld = !Outer.IsTimerActive('GamepadCrouchTimer', self);
    if(bWasButtonHeld)
    {
        StopCrouch();
    }
}

function GamepadCrouchTimer();

exec function GamepadJump()
{
    Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadJumpTimer', self);
}

exec function GamepadJumpRelease()
{
    if(Outer.IsTimerActive('GamepadJumpTimer', self))
    {
        Jump();
        Outer.ClearTimer('GamepadJumpTimer', self);
    }
}

function GamepadJumpTimer()
{
    ToggleCrouch();
}

simulated exec function IronSights(optional bool bHoldButtonMode)
{
    local KFWeapon KFW;

    if(bVersusInput && IronSightsVersus(bHoldButtonMode))
    {
        return;
    }
    if(bHoldButtonMode)
    {
        bIronsightsHeld = true;
    }
    if(bExtendedSprinting)
    {
        Outer.bRun = 0;
        bExtendedSprinting = false;
    }
    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.SetIronSights(((bHoldButtonMode) ? true : !KFW.bUsingSights));
        }
    }
}

simulated exec function IronSightsRelease(optional bool bHoldButtonMode)
{
    local KFWeapon KFW;

    if(bVersusInput && IronSightsReleaseVersus(bHoldButtonMode))
    {
        return;
    }
    if(bHoldButtonMode)
    {
        bIronsightsHeld = false;
    }
    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            if(!KFW.bHasIronSights || bHoldButtonMode)
            {
                KFW.SetIronSights(false);
            }
        }
    }
}

simulated exec function ToggleFlashlight()
{
    local KFPawn_Human KFP;
    local bool bPerkHasNightVision;

    if(((Outer.Pawn == none) || Outer.Pawn.InvManager == none) || bGamepadWeaponSelectOpen)
    {
        return;
    }
    bPerkHasNightVision = Outer.GetPerk().HasNightVision();
    KFP = KFPawn_Human(Outer.Pawn);
    if((KFP != none) && KFP.MyKFWeapon != none)
    {
        if(Outer.bNightVisionActive)
        {
            InternalToggleNightVision();            
        }
        else
        {
            if(bPerkHasNightVision)
            {
                Outer.SetTimer(GamepadButtonHoldTime, false, 'FlashlightTimer', self);                
            }
            else
            {
                InternalToggleFlashlight();
            }
        }
    }
}

exec function FlashlightRelease()
{
    if(Outer.IsTimerActive('FlashlightTimer', self))
    {
        Outer.ClearTimer('FlashlightTimer', self);
        InternalToggleFlashlight();
    }
}

function FlashlightTimer()
{
    InternalToggleNightVision();
}

function InternalToggleFlashlight()
{
    local KFPawn_Human KFP;

    KFP = KFPawn_Human(Outer.Pawn);
    if(KFP != none)
    {
        if(Outer.bNightVisionActive)
        {
            Outer.SetNightVision(false);
            KFP.PlaySoundBase(Outer.NightVisionOffEvent);
        }
        KFP.ToggleEquipment();
        KFP.PlaySoundBase(((KFP.bFlashlightOn) ? Outer.FlashlightOnEvent : Outer.FlashlightOffEvent));
    }
}

function InternalToggleNightVision()
{
    local KFPawn_Human KFP;

    KFP = KFPawn_Human(Outer.Pawn);
    if(KFP != none)
    {
        if(KFP.bFlashlightOn)
        {
            InternalToggleFlashlight();
        }
        Outer.SetNightVision(!Outer.bNightVisionActive);
        KFP.PlaySoundBase(((Outer.bNightVisionActive) ? Outer.NightVisionOnEvent : Outer.NightVisionOffEvent));
    }
}

exec function StartTertiaryFire()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StartFire(3);
    }
}

exec function StopTertiaryFire()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StopFire(3);
    }
}

exec function Reload()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StartFire(2);
    }
}

exec function ReloadRelease()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StopFire(2);
    }
}

exec function GamepadReload()
{
    Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadReloadTimer', self);
}

function GamepadReloadTimer()
{
    QuickHeal();
}

exec function GamepadReloadRelease()
{
    if(Outer.IsTimerActive('GamepadReloadTimer', self))
    {
        if(Outer.Pawn != none)
        {
            Outer.Pawn.StartFire(2);
            Outer.Pawn.StopFire(2);
        }
        Outer.ClearTimer('GamepadReloadTimer', self);
    }
}

exec function Grenade()
{
    if(Outer.Pawn != none)
    {
        if(bVersusInput && GrenadeVersus())
        {
            return;
        }
        Outer.Pawn.StartFire(4);
    }
}

exec function GrenadeRelease()
{
    if(Outer.Pawn != none)
    {
        if((Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
        {
            Outer.Pawn.StopFire(6);
            return;
        }
        Outer.Pawn.StopFire(4);
    }
}

exec function GamepadGrenade()
{
    local Weapon W;

    if(Outer.Pawn != none)
    {
        if(bGamepadWeaponSelectOpen)
        {
            if(Outer.MyGFxHUD.WeaponSelectWidget != none)
            {
                W = Outer.MyGFxHUD.WeaponSelectWidget.GetSelectedWeapon();
                if(W != none)
                {
                    Outer.ServerThrowOtherWeapon(W);
                }
            }            
        }
        else
        {
            Grenade();
        }
    }
}

exec function SwitchFire()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        if(bVersusInput && SwitchFireVersus())
        {
            return;
        }
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.AltFireMode();
        }
    }
}

exec function SwitchFireRelease()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        if(bVersusInput && SwitchFireReleaseVersus())
        {
            return;
        }
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.AltFireModeRelease();
        }
    }
}

exec function SelectNextWeapon()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(bQuickWeaponSelect)
        {
            Outer.NextWeapon();            
        }
        else
        {
            KFIM.HighlightNextWeapon();
        }
        KFIM.ShowAllHUDGroups();
    }
}

exec function SelectPrevWeapon()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(bQuickWeaponSelect)
        {
            Outer.PrevWeapon();            
        }
        else
        {
            KFIM.HighlightPrevWeapon();
        }
        KFIM.ShowAllHUDGroups();
    }
}

exec function SelectLastWeapon()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(KFIM != none)
        {
            KFIM.SwitchToLastWeapon();
            KFIM.ShowAllHUDGroups();
        }
    }
}

exec function GamepadWeaponSelect()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadWeaponMenuTimer', self);
    }
}

exec function ReleaseGamepadWeaponSelect()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(bGamepadWeaponSelectOpen && Outer.MyGFxHUD.WeaponSelectWidget != none)
    {
        Outer.MyGFxHUD.WeaponSelectWidget.SetWeaponSwitchStayOpen(false);
        bGamepadWeaponSelectOpen = false;
    }
    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW == none) || KFW.CanSwitchWeapons())
        {
            KFIM = KFInventoryManager(Outer.Pawn.InvManager);
            if(Outer.IsTimerActive('GamepadWeaponMenuTimer', self))
            {
                Outer.ClearTimer('GamepadWeaponMenuTimer', self);
                if(bShowGamepadWeaponSelectHint)
                {
                    Outer.ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 7);
                }
                if(bUseGamepadLastWeapon)
                {
                    KFIM.SwitchToLastWeapon();                    
                }
                else
                {
                    KFIM.GamepadNextWeapon();
                }                
            }
            else
            {
                KFIM.SetCurrentWeapon(KFIM.PendingWeapon);
            }
        }
        bShowGamepadWeaponSelectHint = false;
    }
}

function GamepadWeaponMenuTimer()
{
    local KFWeapon KFW;

    if(((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none) && Outer.MyGFxHUD.VoiceCommsWidget.bActive)
    {
        return;
    }
    if((Outer.Pawn != none) && bUsingGamepad)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        if(Outer.MyGFxHUD.WeaponSelectWidget != none)
        {
            bGamepadWeaponSelectOpen = true;
            Outer.MyGFxHUD.WeaponSelectWidget.SetWeaponSwitchStayOpen(true);
            KFInventoryManager(Outer.Pawn.InvManager).HighlightWeapon(Outer.Pawn.Weapon);
        }
    }
}

exec function SwitchWeaponGroup(byte GroupID)
{
    local KFInventoryManager KFIM;
    local KFWeapon NextGroupedWeapon, KFW;

    if((Outer.Pawn == none) || Outer.Pawn.InvManager == none)
    {
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return;
    }
    if(((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none) && Outer.MyGFxHUD.VoiceCommsWidget.bActive)
    {
        return;
    }
    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        NextGroupedWeapon = KFIM.GetNextGroupedWeapon(GroupID);
        if(bUsingGamepad)
        {
            if(bGamepadWeaponSelectOpen)
            {
                KFIM.HighlightWeapon(NextGroupedWeapon);                
            }
            else
            {
                KFIM.SetCurrentWeapon(NextGroupedWeapon);
            }            
        }
        else
        {
            KFIM.SetCurrentWeapon(NextGroupedWeapon);
        }
        KFIM.ShowOnlyHUDGroup(GroupID);
    }
}

exec function QuickHeal()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    if(bVersusInput && QuickHealVersus())
    {
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return;
    }
    KFInventoryManager(Outer.Pawn.InvManager).AttemptQuickHeal();
}

exec function TossMoney()
{
    local KFInventoryManager KFIM;

    if((Outer.Pawn != none) && Outer.Pawn.InvManager != none)
    {
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(KFIM != none)
        {
            KFIM.ThrowMoney();
        }
    }
}

exec function GamepadDpadLeft()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerViewPrevPlayer();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(0);            
        }
        else
        {
            ShowVoiceComms();
        }
    }
}

exec function GamepadDpadDown()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerNextSpectateMode();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(2);            
        }
        else
        {
            ToggleFlashlight();
        }
    }
}

exec function GamepadDpadRight()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerViewNextPlayer();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(1);            
        }
        else
        {
            TossMoney();
        }
    }
}

exec function GamepadDpadUp()
{
    if(bGamepadWeaponSelectOpen)
    {
        SwitchWeaponGroup(3);        
    }
    else
    {
        if(((Outer.Pawn != none) && Outer.Pawn.Weapon != none) && Outer.Pawn.Weapon.IsA('KFWeap_HealerBase'))
        {
            KFInventoryManager(Outer.Pawn.InvManager).SwitchToLastWeapon();            
        }
        else
        {
            SwitchWeaponGroup(3);
        }
    }
}

exec function ShowVoiceComms()
{
    if(bVersusInput && Outer.PlayerReplicationInfo.GetTeamNum() == 255)
    {
        return;
    }
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none)
    {
        Outer.MyGFxHUD.ShowVoiceComms(true);
    }
}

exec function HideVoiceComms()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none)
    {
        Outer.MyGFxHUD.ShowVoiceComms(false);
    }
}

exec function OnVoteYesPressed()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnYesPressed();
    }
}

exec function OnVoteYesRelease()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnYesReleased();
    }
}

exec function OnVoteNoPressed()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnNoPressed();
    }
}

exec function OnVoteNoRelease()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnNoReleased();
    }
}

exec function Interact()
{
    Outer.SetTimer(GamepadButtonHoldTime, false, 'InteractTimer', self);
}

exec function InteractRelease()
{
    local bool bButtonWasHeld;

    bButtonWasHeld = !Outer.IsTimerActive('InteractTimer', self);
    if(!bButtonWasHeld)
    {
        Outer.Use();
        Outer.ClearTimer('InteractTimer', self);
    }
}

exec function InteractTimer()
{
    local KFInventoryManager KFIM;

    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        KFIM.QuickWeld();
    }
}

exec function StartVoiceChat(optional bool bPublicChat)
{
    LogInternal("VOICE CHAT!");
    if(bRequiresPushToTalk)
    {
        if(bPublicChat)
        {
            Outer.CurrentVoiceChannel = 0;            
        }
        else
        {
            Outer.CurrentVoiceChannel = 1;
        }
        Outer.ClearTimer('ClientStopNetworkedVoice');
        Outer.ClientStartNetworkedVoice();
    }
}

exec function StopVoiceChat()
{
    if(bRequiresPushToTalk)
    {
        Outer.SetTimer(0.25, false, 'ClientStopNetworkedVoice');
    }
}

function PreProcessInput(float DeltaTime)
{
    super(PlayerInput).PreProcessInput(DeltaTime);
    if((Outer.Pawn != none) && bUsingGamepad)
    {
        PreProcessGamepadInput(DeltaTime);
    }
}

function PreProcessGamepadInput(float DeltaTime)
{
    local KFWeapon KFW;
    local float FOVScale, ScaledJoyMagnitude;

    if(bExtendedSprinting)
    {
        UpdateExtendedSprint(DeltaTime);
    }
    CurrTurn = 0;
    CurrLookUp = 0;
    if(RawJoyLookMagnitude > 0)
    {
        ScaledJoyMagnitude = EvalInterpCurveFloat(LookSensitivityScaleCurve, Abs(RawJoyLookMagnitude));
        CurrTurn = ScaledJoyMagnitude * (RawJoyLookRight / RawJoyLookMagnitude);
        CurrLookUp = ScaledJoyMagnitude * (RawJoyLookUp / RawJoyLookMagnitude);
    }
    if(CanApplyViewAcceleration())
    {
        ApplyViewAcceleration(DeltaTime);        
    }
    else
    {
        ViewAccel_BlendTimer = 0;
    }
    if(Outer.Pawn.Weapon != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((IsAimAssistFrictionEnabled()) && KFW != none)
        {
            ApplyTargetFriction(DeltaTime, KFW);
        }
    }
    FOVScale = GetFOVAdjustedControllerSensitivity();
    CurrTurn *= FOVScale;
    CurrLookUp *= FOVScale;
    CurrTurn *= GamepadSensitivityScale;
    CurrLookUp *= GamepadSensitivityScale;
    if((KFPawn(Outer.Pawn) != none) && KFPawn(Outer.Pawn).bIsSprinting)
    {
        CurrTurn *= SprintingSensitivityScale;
        CurrLookUp *= SprintingSensitivityScale;
    }
    if(bViewSmoothingEnabled)
    {
        ApplyViewSmoothing(DeltaTime);
    }
    aTurn = CurrTurn;
    aLookUp = CurrLookUp;
    PrevTurn = aTurn;
    PrevLookUp = aLookUp;
}

function UpdateExtendedSprint(float DeltaTime)
{
    if(((Outer.bRun == 0) && Outer.Pawn.Weapon != none) && Outer.Pawn.Weapon.ShouldOwnerWalk())
    {
        Outer.bRun = 0;
        bExtendedSprinting = false;        
    }
    else
    {
        if(IsDirectingJoyStick(SprintAnalogThreshold))
        {
            Outer.bRun = 1;            
        }
        else
        {
            Outer.bRun = 0;
            bExtendedSprinting = false;
        }
    }
}

function bool IsDirectingJoyStick(float Threshold)
{
    local Vector vAnalog;

    vAnalog.X = RawJoyRight;
    vAnalog.Y = RawJoyUp;
    if(VSize2D(vAnalog) > Threshold)
    {
        return true;
    }
    return false;
}

function ApplyViewAcceleration(float DeltaTime)
{
    ViewAccel_BlendTimer += DeltaTime;
    if(ViewAccel_BlendTimer >= ViewAccel_BlendTime)
    {
        ViewAccel_BlendTimer = ViewAccel_BlendTime;
    }
    if(CurrTurn > float(0))
    {
        CurrTurn = Lerp(CurrTurn, ViewAccel_MaxTurnSpeed, ViewAccel_BlendTimer / ViewAccel_BlendTime);        
    }
    else
    {
        CurrTurn = Lerp(CurrTurn, -ViewAccel_MaxTurnSpeed, ViewAccel_BlendTimer / ViewAccel_BlendTime);
    }
}

function bool CanApplyViewAcceleration()
{
    if(!bViewAccelerationEnabled)
    {
        return false;
    }
    if(((Outer.Pawn == none) || KFWeapon(Outer.Pawn.Weapon) == none) || KFWeapon(Outer.Pawn.Weapon).bUsingSights)
    {
        return false;
    }
    if((RawJoyLookMagnitude < ViewAccel_JoyMagThreshold) || Abs(RawJoyLookUp) > ViewAccel_JoyPitchThreshold)
    {
        return false;
    }
    return true;
}

function bool ApplyingViewAcceleration()
{
    return ViewAccel_BlendTimer > float(0);
}

function ApplyViewSmoothing(float DeltaTime)
{
    local float MaxAccel, MaxDecel;

    if(PrevTurn <= LookSensitivityScaleCurve.Points[LookSensitivityScaleCurve.Points.Length - 1].OutVal)
    {
        MaxAccel = ViewSmoothing_MaxAccel * DeltaTime;
        MaxDecel = ViewSmoothing_MaxDecel * DeltaTime;
        if(((CurrTurn >= float(0)) && PrevTurn < float(0)) || (CurrTurn <= float(0)) && PrevTurn > float(0))
        {
            CurrTurn = PrevTurn + FClamp(CurrTurn - PrevTurn, -MaxDecel, MaxDecel);            
        }
        else
        {
            CurrTurn = PrevTurn + FClamp(CurrTurn - PrevTurn, -MaxAccel, MaxAccel);
        }
        if(((CurrLookUp >= float(0)) && PrevLookUp < float(0)) || (CurrLookUp <= float(0)) && PrevLookUp > float(0))
        {
            CurrLookUp = PrevLookUp + FClamp(CurrLookUp - PrevLookUp, -MaxDecel, MaxDecel);            
        }
        else
        {
            CurrLookUp = PrevLookUp + FClamp(CurrLookUp - PrevLookUp, -MaxAccel, MaxAccel);
        }
    }
}

function InitAutoTarget()
{
    local Vector CamLoc, X;
    local Rotator CamRot;
    local float UsedTargetAngle, MaxDistance;

    if((!bUsingGamepad || Outer.Pawn == none) || Outer.Pawn.Weapon == none)
    {
        return;
    }
    if(!IsAimAssistAutoTargetEnabled())
    {
        return;
    }
    if((Outer.WorldInfo.RealTimeSeconds - LastAutoTargetTime) < AutoTargetCooldown)
    {
        return;
    }
    if(KFWeapon(Outer.Pawn.Weapon) == none)
    {
        return;
    }
    AutoTargetTimeLeft = KFWeapon(Outer.Pawn.Weapon).default.ZoomInTime * 0.85;
    LastAutoTargetTime = Outer.WorldInfo.RealTimeSeconds;
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    MaxDistance = AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].InVal;
    CurrentAutoTarget = Outer.GetTargetAdhesionFrictionTarget(MaxDistance, CamLoc, CamRot, AutoTargetAngleCurve);
    if(CurrentAutoTarget != none)
    {
        CurrentAutoTargetBone = 'None';
        AutoTargetInitialLocation = GetBestAutoTargetLocation(CurrentAutoTarget, CurrentAutoTargetBone);
    }
    if(Outer.bDebugAutoTarget)
    {
        Outer.FlushPersistentDebugLines();
        X = vector(CamRot);
        UsedTargetAngle = EvalInterpCurveFloat(AutoTargetAngleCurve, VSize(CamLoc - AutoTargetInitialLocation));
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 500, Acos(UsedTargetAngle), Acos(UsedTargetAngle), 16, MakeColor(255, 0, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 250, Acos(AutoTargetAngleCurve.Points[0].OutVal), Acos(AutoTargetAngleCurve.Points[0].OutVal), 16, MakeColor(0, 255, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].InVal, Acos(AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].OutVal), Acos(AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].OutVal), 16, MakeColor(0, 255, 0, 255), true);
        UsedTargetAngle = EvalInterpCurveFloat(AutoTargetWeakspotCurve, VSize(CamLoc - AutoTargetInitialLocation));
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 500, Acos(UsedTargetAngle), Acos(UsedTargetAngle), 16, MakeColor(255, 0, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 250, Acos(AutoTargetWeakspotCurve.Points[0].OutVal), Acos(AutoTargetWeakspotCurve.Points[0].OutVal), 16, MakeColor(255, 255, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, AutoTargetWeakspotCurve.Points[AutoTargetWeakspotCurve.Points.Length - 1].InVal, Acos(AutoTargetWeakspotCurve.Points[AutoTargetWeakspotCurve.Points.Length - 1].OutVal), Acos(AutoTargetWeakspotCurve.Points[AutoTargetWeakspotCurve.Points.Length - 1].OutVal), 16, MakeColor(255, 255, 0, 255), true);
    }
}

function Vector GetBestAutoTargetLocation(Pawn CheckTarget, out name OutBoneName)
{
    local KFPawn KFP;
    local array<name> WeakBones, NormalBones;
    local Vector TestLoc, CamLoc, CamDir, HitLoc, HitNorm;

    local Rotator CamRot;
    local Actor HitActor;
    local TraceHitInfo HitInfo;
    local int I;

    if(CheckTarget == none)
    {
        return vect(0, 0, 0);
    }
    KFP = KFPawn(CheckTarget);
    if(KFP != none)
    {
        KFP.GetAutoTargetBones(WeakBones, NormalBones);
        Outer.GetPlayerViewPoint(CamLoc, CamRot);
        CamRot += Outer.WeaponBufferRotation;
        CamDir = vector(CamRot);
        I = 0;
        J0xF4:

        if(I < WeakBones.Length)
        {
            TestLoc = KFP.Mesh.GetBoneLocation(WeakBones[I]);
            if(!IsAutoTargetWithinCone(TestLoc, CamLoc, CamDir, AutoTargetWeakspotCurve))
            {                
            }
            else
            {
                HitActor = Outer.Pawn.Trace(HitLoc, HitNorm, TestLoc, CamLoc, true, vect(0, 0, 0), HitInfo, Outer.1);
                if((HitActor == none) || HitActor == CheckTarget)
                {
                    if(Outer.bDebugAutoTarget)
                    {
                        LogInternal((("Targeting P=" $ string(CheckTarget)) @ "Bone=") $ string(WeakBones[I]));
                    }
                    OutBoneName = WeakBones[I];
                    return TestLoc;
                }
            }
            ++ I;
            goto J0xF4;
        }
        I = 0;
        J0x2E4:

        if(I < NormalBones.Length)
        {
            TestLoc = KFP.Mesh.GetBoneLocation(NormalBones[I]);
            HitActor = Outer.Pawn.Trace(HitLoc, HitNorm, TestLoc, CamLoc, true, vect(0, 0, 0), HitInfo, Outer.1);
            if((HitActor == none) || HitActor == CheckTarget)
            {
                if(Outer.bDebugAutoTarget)
                {
                    LogInternal((("Targeting P=" $ string(CheckTarget)) @ "Bone=") $ string(NormalBones[I]));
                }
                OutBoneName = NormalBones[I];
                return TestLoc;
            }
            ++ I;
            goto J0x2E4;
        }
    }
    OutBoneName = 'None';
    return CheckTarget.Location + (CheckTarget.BaseEyeHeight * vect(0, 0, 0.5));
}

function bool IsAutoTargetWithinCone(Vector TargetLoc, Vector CamLoc, Vector CamDir, const out InterpCurveFloat Curve)
{
    local float DistToTarget, TargetRadius, TargetHeight, DotDiffToTarget, UsedTargetAngle;

    local Vector CamToTarget;

    CamToTarget = TargetLoc - CamLoc;
    if(VSizeSq(CamToTarget) > Square(Curve.Points[Curve.Points.Length - 1].InVal))
    {
        if(Outer.bDebugAutoTarget)
        {
            LogInternal("Auto-target Cone Distance Exceeded Dist=" $ string(VSize(CamToTarget)));
        }
        return false;
    }
    DistToTarget = VSize(CamToTarget);
    DotDiffToTarget = Normal(TargetLoc - CamLoc) Dot CamDir;
    UsedTargetAngle = EvalInterpCurveFloat(Curve, DistToTarget);
    if(Outer.bDebugAutoTarget)
    {
        CurrentAutoTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
        Outer.DrawDebugCylinder(AutoTargetInitialLocation + vect(0, 0, 5), AutoTargetInitialLocation - vect(0, 0, 5), 10, 12, 255, 0, 0);
        Outer.DrawDebugCylinder(CurrentAutoTarget.Location + (vect(0, 0, 1) * TargetHeight), CurrentAutoTarget.Location - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 0, 255, 0);
    }
    if(UsedTargetAngle > DotDiffToTarget)
    {
        if(Outer.bDebugAutoTarget)
        {
            LogInternal("Auto-target Cone Angle Exceeded by " $ string(UsedTargetAngle - DotDiffToTarget));
        }
        return false;
    }
    return true;
}

function ApplyAutoTarget(float DeltaTime, KFWeapon W, out int out_YawRot, out int out_PitchRot)
{
    local Vector RealTargetLoc, CamLoc, CamDir;
    local Rotator CamRot, DeltaRot, RotToTarget;
    local int AdjustY, AdjustZ;
    local float BlendTimeToGo;

    BlendTimeToGo = AutoTargetTimeLeft;
    AutoTargetTimeLeft -= DeltaTime;
    if((!bUsingGamepad || CurrentAutoTarget == none) || AutoTargetTimeLeft <= float(0))
    {
        return;
    }
    if(((CurrentAutoTarget != none) && CurrentAutoTarget.Health > 0) && (KFPawn_Monster(CurrentAutoTarget) == none) || !KFPawn_Monster(CurrentAutoTarget).bIsHeadless)
    {
        RealTargetLoc = AutoTargetInitialLocation;
        if(CurrentAutoTargetBone != 'None')
        {
            RealTargetLoc = CurrentAutoTarget.Mesh.GetBoneLocation(CurrentAutoTargetBone);
        }
        Outer.GetPlayerViewPoint(CamLoc, CamRot);
        CamRot += Outer.WeaponBufferRotation;
        CamDir = vector(CamRot);
        if(!IsAutoTargetWithinCone(RealTargetLoc, CamLoc, CamDir, AutoTargetAngleCurve))
        {
            if(Outer.bDebugAutoTarget)
            {
                LogInternal("ApplyAutoTarget target lost" @ string(CurrentAutoTarget));
            }
            return;
        }
        RotToTarget = rotator(RealTargetLoc - CamLoc);
        DeltaRot.Yaw = RotToTarget.Yaw - CamRot.Yaw;
        DeltaRot.Pitch = RotToTarget.Pitch - CamRot.Pitch;
        DeltaRot = Normalize(DeltaRot);
        if(DeltaRot.Yaw != 0)
        {
            if(BlendTimeToGo > DeltaTime)
            {
                AdjustY = int((float(DeltaRot.Yaw) / BlendTimeToGo) * DeltaTime);                
            }
            else
            {
                AdjustY = DeltaRot.Yaw;
            }
            out_YawRot += AdjustY;
        }
        if(DeltaRot.Pitch != 0)
        {
            if(BlendTimeToGo > DeltaTime)
            {
                AdjustZ = int((float(DeltaRot.Pitch) / BlendTimeToGo) * DeltaTime);                
            }
            else
            {
                AdjustZ = DeltaRot.Pitch;
            }
            out_PitchRot += AdjustZ;
        }
    }
}

function ApplyForceLookAtPawn(float DeltaTime, out int out_YawRot, out int out_PitchRot)
{
    local Vector RealTargetLoc, CamLoc, X, Y, Z;

    local Rotator CamRot, DeltaRot, CamRotWithFreeAim;
    local float AdhesionAmtY, AdhesionAmtZ, TargetRadius, TargetHeight;
    local int AdjustY, AdjustZ;
    local float DotDiffToTarget, UsedRotationRate;

    if(Outer.ForceLookAtPawn == none)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    CamRotWithFreeAim = CamRot + Outer.WeaponBufferRotation;
    GetAxes(CamRotWithFreeAim, X, Y, Z);
    if((Outer.ForceLookAtPawn != none) && Outer.ForceLookAtPawn.Health > 0)
    {
        RealTargetLoc = Outer.ForceLookAtPawn.GetAutoLookAtLocation(CamLoc, Outer.Pawn);
        if(Outer.bDebugAutoTarget)
        {
            Outer.ForceLookAtPawn.GetBoundingCylinder(TargetRadius, TargetHeight);
            Outer.DrawDebugCylinder(RealTargetLoc + vect(0, 0, 5), RealTargetLoc - vect(0, 0, 5), 10, 12, 255, 0, 0);
            Outer.DrawDebugCylinder(Outer.ForceLookAtPawn.Location + (vect(0, 0, 1) * TargetHeight), Outer.ForceLookAtPawn.Location - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 0, 255, 0);
        }
        DotDiffToTarget = Normal(RealTargetLoc - CamLoc) Dot Normal(vector(CamRotWithFreeAim));
        if(DotDiffToTarget < ForceLookAtPawnMinAngle)
        {
            UsedRotationRate = ForceLookAtPawnRotationRate;            
        }
        else
        {
            UsedRotationRate = ForceLookAtPawnDampenedRotationRate;
        }
        DeltaRot.Yaw = rotator(RealTargetLoc - CamLoc).Yaw - CamRotWithFreeAim.Yaw;
        DeltaRot.Pitch = rotator(RealTargetLoc - CamLoc).Pitch - CamRotWithFreeAim.Pitch;
        DeltaRot = Normalize(DeltaRot);
        if(DeltaRot.Yaw != 0)
        {
            AdhesionAmtY = UsedRotationRate;
            AdjustY = int(float(DeltaRot.Yaw) * (AdhesionAmtY * DeltaTime));
            out_YawRot += AdjustY;
        }
        if(DeltaRot.Pitch != 0)
        {
            AdhesionAmtZ = UsedRotationRate;
            AdjustZ = int(float(DeltaRot.Pitch) * (AdhesionAmtZ * DeltaTime));
            out_PitchRot += AdjustZ;
        }
    }
}

function bool IsPawnSprinting()
{
    if(Outer.Pawn == none)
    {
        return false;
    }
    return (Outer.bRun > 0) && KFPawn(Outer.Pawn).bIsSprinting;
}

function ApplyTargetAdhesion(float DeltaTime, KFWeapon W, out int out_YawRot, out int out_PitchRot)
{
    local Vector CamLoc, X, Y, Z;
    local Rotator CamRot;
    local float DistToTarget, TargetRadius, TargetHeight, AdhesionScale;
    local Pawn AdhesionTarget;
    local Vector AdhesionTargetVel, AdhesionPawnVel, AdhesionTargetRelVel, AdhesionViewOffset;

    if(!bUsingGamepad)
    {
        return;
    }
    if((W == none) || !W.bTargetAdhesionEnabled)
    {
        return;
    }
    if(IsPawnSprinting())
    {
        AdhesionPawnLastLoc = Outer.Pawn.Location;
        LastAdhesionTarget = none;
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    GetAxes(CamRot, X, Y, Z);
    AdhesionTarget = LastFrictionTarget;
    if(AdhesionTarget == none)
    {
        AdhesionTarget = Outer.GetTargetAdhesionFrictionTarget(W.TargetAdhesionDistanceMax, CamLoc, CamRot, AdhesionAngleCurve);
    }
    if(AdhesionTarget == none)
    {
        AdhesionPawnLastLoc = Outer.Pawn.Location;
        LastAdhesionTarget = none;
        return;
    }
    if(((AdhesionTarget.Health > 0) && KFPawn_Monster(AdhesionTarget) != none) && !KFPawn_Monster(AdhesionTarget).bIsHeadless)
    {
        GetAimAssistViewOffsetFromTarget(CamLoc, CamRot, AdhesionTarget, AdhesionViewOffset, DistToTarget);
        AdhesionTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
        if((AdhesionViewOffset.Y <= TargetRadius) && AdhesionViewOffset.Z <= TargetHeight)
        {
            AdhesionTargetVel = ((AdhesionTarget != LastAdhesionTarget) ? vect(0, 0, 0) : (AdhesionTarget.Location - AdhesionTargetLastLoc) / DeltaTime);
            AdhesionPawnVel = ((IsZero(AdhesionPawnLastLoc)) ? vect(0, 0, 0) : (Outer.Pawn.Location - AdhesionPawnLastLoc) / DeltaTime);
            if((Outer.Pawn != none) && Outer.Pawn.bIsWalking)
            {
                AdhesionPawnVel.X = Lerp(AdhesionPawnVel.X, AdhesionPawnVel.X / Outer.Pawn.WalkingPct, 0.2);
                AdhesionPawnVel.Y = Lerp(AdhesionPawnVel.Y, AdhesionPawnVel.Y / Outer.Pawn.WalkingPct, 0.2);
            }
            AdhesionTargetRelVel = (AdhesionTargetVel - AdhesionPawnVel) * EvalInterpCurveFloat(W.TargetAdhesionDistanceScaleCurve, DistToTarget / W.TargetAdhesionDistanceMax);
            AdhesionScale = AdhesionFactor * DeltaTime;
            out_YawRot += int(((AdhesionTargetRelVel Dot Y) * AdhesionScale) * EvalInterpCurveFloat(W.TargetAdhesionOffsetScaleCurve, AdhesionViewOffset.Y / TargetRadius));
            out_PitchRot += int(((AdhesionTargetRelVel Dot Z) * AdhesionScale) * EvalInterpCurveFloat(W.TargetAdhesionOffsetScaleCurve, AdhesionViewOffset.Z / TargetHeight));
        }
    }
    AdhesionTargetLastLoc = AdhesionTarget.Location;
    AdhesionPawnLastLoc = Outer.Pawn.Location;
    LastAdhesionTarget = AdhesionTarget;
}

function ApplyTargetFriction(float DeltaTime, KFWeapon W)
{
    local Pawn FrictionTarget;
    local Vector CamLoc, X, Y, Z, FrictionViewOffset;

    local Rotator CamRot;
    local float DistToTarget, TargetRadius, TargetHeight, FrictionMultiplier;

    if(((Outer.Pawn == none) || !W.bTargetFrictionEnabled) || IsPawnSprinting())
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    GetAxes(CamRot, X, Y, Z);
    FrictionTarget = Outer.GetTargetAdhesionFrictionTarget(W.TargetFrictionDistanceMax, CamLoc, CamRot, FrictionAngleCurve);
    if(FrictionTarget != none)
    {
        GetAimAssistViewOffsetFromTarget(CamLoc, CamRot, FrictionTarget, FrictionViewOffset, DistToTarget);
        FrictionTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
        if((FrictionViewOffset.Y <= TargetRadius) && FrictionViewOffset.Z <= TargetHeight)
        {
            FrictionMultiplier = FrictionScale;
            FrictionMultiplier *= EvalInterpCurveFloat(W.TargetFrictionDistanceScaleCurve, DistToTarget / W.TargetFrictionDistanceMax);
            FrictionMultiplier *= EvalInterpCurveFloat(W.TargetFrictionOffsetScaleCurve, FrictionViewOffset.Y / TargetRadius);
            if(ApplyingViewAcceleration())
            {
                FrictionMultiplier *= ViewAccelerationFrictionScale;
            }
            CurrTurn *= (1 - FrictionMultiplier);
            CurrLookUp *= (1 - FrictionMultiplier);
            LastFrictionTargetTime = Outer.WorldInfo.TimeSeconds;
            LastFrictionTarget = FrictionTarget;
        }
    }
}

function GetAimAssistViewOffsetFromTarget(Vector ViewLoc, Rotator ViewRot, Actor Target, out Vector Offset, optional out float Distance)
{
    local Vector TargetLoc, CamToTarget, AimLoc;

    CamToTarget = Target.Location - ViewLoc;
    Distance = VSize(CamToTarget);
    AimLoc = ViewLoc + (vector(ViewRot) * Distance);
    TargetLoc = Target.Location;
    TargetLoc.Z = AimLoc.Z;
    Offset.Y = PointDistToLine(AimLoc, TargetLoc - ViewLoc, ViewLoc);
    TargetLoc = Target.Location;
    TargetLoc.X = AimLoc.X;
    TargetLoc.Y = AimLoc.Y;
    Offset.Z = PointDistToLine(AimLoc, TargetLoc - ViewLoc, ViewLoc);
}

function float GetFOVAdjustedControllerSensitivity()
{
    local float FOVScale, UsedFOVAngle;
    local bool bUsingSights;

    FOVScale = 1;
    if(bEnableFOVScaling)
    {
        if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
        {
            bUsingSights = Outer.Pawn.bIsWalking;
            UsedFOVAngle = Outer.Pawn.Weapon.GetModifiedFOVAngle();            
        }
        else
        {
            UsedFOVAngle = Outer.GetFOVAngle();
        }
        if((UsedFOVAngle != Outer.DefaultFOV) && bUsingSights)
        {
            FOVScale = (UsedFOVAngle * 0.01333) * GamepadZoomedSensitivityScale;            
        }
        else
        {
            FOVScale = 1;
        }
    }
    return FOVScale;
}

exec function DebugViewAcceleration()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        bDebugViewAcceleration = !bDebugViewAcceleration;
        Outer.ClientMessage("bDebugViewAcceleration is now: " $ string(bDebugViewAcceleration));
    }
}

exec function DebugTargetAdhesion()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        Outer.bDebugTargetAdhesion = !Outer.bDebugTargetAdhesion;
        Outer.ClientMessage("bDebugTargetAdhesion is now: " $ string(Outer.bDebugTargetAdhesion));
    }
}

exec function DebugAutoTarget()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        Outer.bDebugAutoTarget = !Outer.bDebugAutoTarget;
        Outer.ClientMessage("bDebugAutoTarget is now: " $ string(Outer.bDebugAutoTarget));
    }
}

exec function DebugTargetFriction()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        bDebugTargetFriction = !bDebugTargetFriction;
        Outer.ClientMessage("bDebugTargetFriction is now: " $ string(bDebugTargetFriction));
    }
}

function bool IsAimAssistFrictionEnabled()
{
    return bAimAssistEnabled && bTargetFrictionEnabled;
}

function bool IsAimAssistAdhesionEnabled()
{
    return bAimAssistEnabled && bTargetAdhesionEnabled;
}

function bool IsAimAssistAutoTargetEnabled()
{
    return bAimAssistEnabled && bAutoTargetEnabled;
}

function JumpVersus()
{
    local KFPawn_Monster KFPM;

    if(Outer.WorldInfo.Pauser == Outer.PlayerReplicationInfo)
    {
        Outer.SetPause(false);        
    }
    else
    {
        if(Outer.Pawn != none)
        {
            KFPM = KFPawn_Monster(Outer.Pawn);
            if(KFPM != none)
            {
                if(KFPM.GetSpecialMoveCooldownTimeRemainingByHandle(12) > 0)
                {
                    return;
                }
            }
        }
        Outer.bPressedJump = true;
    }
}

simulated function bool IronSightsVersus(optional bool bHoldButtonMode)
{
    if((Outer.Pawn != none) && (Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StartFire(1);
        return true;
    }
    return false;
}

function bool IronSightsReleaseVersus(optional bool bHoldButtonMode)
{
    if((Outer.Pawn != none) && (Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StopFire(1);
        return true;
    }
    return false;
}

function bool GrenadeVersus()
{
    if(((Outer.Pawn != none) && Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StartFire(6);
        return true;
    }
    return false;
}

function bool SwitchFireVersus()
{
    if(((Outer.Pawn != none) && Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StartFire(4);
        return true;
    }
    return false;
}

function bool SwitchFireReleaseVersus()
{
    if(((Outer.Pawn != none) && Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StopFire(4);
        return true;
    }
    return false;
}

function bool QuickHealVersus()
{
    if((Outer.Pawn.Weapon == none) || Outer.Pawn.Weapon.ShouldWeaponIgnoreStartFire())
    {
        Outer.Pawn.StartFire(5);
        return true;
    }
    return false;
}

exec function SuppressTakeDamage(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogTakeDamage false");
}

exec function UnsuppressTakeDamage(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogTakeDamage true");
}

exec function SuppressPhysicsBodyImpact(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogPhysicsBodyImpact false");
}

exec function UnsuppressPhysicsBodyImpact(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogPhysicsBodyImpact true");
}

exec function SuppressSpecialMove(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogSpecialMove false");
}

exec function UnsuppressSpecialMove(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogSpecialMove true");
}

exec function SuppressPawnAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogCustomAnim false");
}

exec function UnsuppressPawnAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogCustomAnim true");
}

exec function SuppressWeaponAttach(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFWeaponAttachment bDebug false");
}

exec function UnsuppressWeaponAttach(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFWeaponAttachment bDebug true");
}

exec function SuppressAffliction(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFAfflictionBase bDebug false");
}

exec function UnsuppressAffliction(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFAfflictionBase bDebug true");
}

exec function SuppressWeaponAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFWeapon');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogAnimation false");
}

exec function UnsuppressWeaponAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFWeapon');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogAnimation true");
}

exec function SuppressMelee()
{
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bLogMelee false");
}

exec function UnsuppressMelee()
{
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bLogMelee true");
}

exec function SuppressPerk()
{
    Outer.ConsoleCommand("SETNOPEC KFPerk bLogPerk false");
}

exec function UnsuppressPerk()
{
    Outer.ConsoleCommand("SETNOPEC KFPerk bLogPerk true");
}

exec function SuppressAISpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogAISpawning false");
}

exec function UnsuppressAISpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogAISpawning true");
}

exec function SuppressWaveSpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogWaveSpawnTiming false");
}

exec function UnsuppressWaveSpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogWaveSpawnTiming true");
}

exec function SuppressScoring()
{
    Outer.ConsoleCommand("SETNOPEC KFGameInfo bLogScoring false");
}

exec function UnsuppressScoring()
{
    Outer.ConsoleCommand("SETNOPEC KFGameInfo bLogScoring true");
}

defaultproperties
{
    bRequiresPushToTalk=true
    bQuickWeaponSelect=true
    bShowGamepadWeaponSelectHint=true
    bAimAssistEnabled=true
    bViewSmoothingEnabled=true
    bViewAccelerationEnabled=true
    bTargetFrictionEnabled=true
    bTargetAdhesionEnabled=true
    bAutoTargetEnabled=true
    bForceFeedbackEnabled=true
    GamepadButtonHoldTime=0.25
    SprintAnalogThreshold=0.6
    LookSensitivityScaleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0.5,LeaveTangent=0.5,InterpMode=EInterpCurveMode.CIM_CurveAuto)
    MoveSensitivityScaleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.3,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Constant)
    GamepadSensitivityScale=1
    SprintingSensitivityScale=0.675
    ZoomedSensitivityScale=0.35
    GamepadZoomedSensitivityScale=0.65
    ViewSmoothing_MaxAccel=25
    ViewSmoothing_MaxDecel=50
    ViewAccel_JoyMagThreshold=0.97
    ViewAccel_JoyPitchThreshold=0.4
    ViewAccel_MaxTurnSpeed=2.4
    ViewAccel_BlendTime=0.25
    FrictionScale=0.5
    FrictionAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    ViewAccelerationFrictionScale=0.85
    AdhesionAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.95,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    AdhesionFactor=16
    AutoTargetTimeLeft=0.1
    AutoTargetAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.9397,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    AutoTargetWeakspotCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.9962,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    AutoTargetCooldown=0.5
    ForceLookAtPawnMinAngle=0.9
    ForceLookAtPawnRotationRate=22
    ForceLookAtPawnDampenedRotationRate=8
    DoubleTapDelay=0.25
    bEnableFOVScaling=true
}