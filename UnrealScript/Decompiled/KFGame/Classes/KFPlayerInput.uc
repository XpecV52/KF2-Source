/*******************************************************************************
 * KFPlayerInput generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPlayerInput extends MobilePlayerInput within KFPlayerController
    transient
    native(Controller)
    config(Input)
    hidecategories(Object,UIRoot);

var config bool bRequiresPushToTalk;
var config bool bQuickWeaponSelect;
var bool bGamepadWeaponSelectOpen;
var config bool bInvertController;
var transient bool bExtendedSprinting;
/** Whether ViewAcceleration is enabled or not */
var() config bool bViewAccelerationEnabled;
var protected config bool bDebugViewAcceleration;
/** Whether TargetFriction is enabled or not */
var() config bool bTargetFrictionEnabled;
var protected config bool bDebugTargetFriction;
var protected bool bAppliedTargetFriction;
var bool bAimTriggerPulled;
var config float ZoomedSensitivityScalar;
var transient float PressedJumpTime;
var config float GamepadButtonHoldTime;
var config float SprintAnalogThreshold;
var config float TimeBelowThresholdToStopSprint;
var transient float SprintTimeBelowThreshold;
var transient float GamepadSprintPressTime;
/** Store previous remainder of aTurn for smoothing slow rotations. */
var() float RemainingaTurn;
/** Store previous remainder of aLookUp for smoothing slow rotations. */
var() float RemainingaLookUp;
/** Multiplier used to scale the sensitivity of turning. */
var() config float HorizontalSensitivityScale;
/** Multiplier used to scale the sensitivity of looking up and down. */
var() config float VerticalSensitivityScale;
/** Threshold above when Yaw Acceleration kicks in */
var() float ViewAccel_YawThreshold;
var() float ViewAccel_DiagonalThreshold;
/** How fast to start accelerating when the stick is slammed to the edge. It goes to a max of 2.0 over time */
var() private float ViewAccel_CurrMutliplier;
/** how long you need to hold at edge before the fast acceleration kicks in */
var() float ViewAccel_TimeToHoldBeforeFastAcceleration;
var private float ViewAccel_TimeHeld;
var private Pawn LastFrictionTarget;
var private float LastFrictionTargetTime;
var private float LastaTurn;
var private float LastaLookUp;
var private float LastaForward;
var private float LastaStrafe;
/** How fast you ramp up to the max speed */
var() float ViewAccel_RampSpeed;
/** Max turn speed */
var() float ViewAccel_MaxTurnSpeed;
/** Interp curve that allows for piece wise functions for the TargetFrictionDistance amount at different ranges */
var() InterpCurveFloat SensitivityScaleCurve;
var Vector AutoTargetInitialLocation;
var Pawn CurrentAutoTarget;
/** How fast to rotate towards autotarget location */
var() float AutoTargetRotationRate;
/** Interp curve to scale autotarget angle for different ranges */
var() InterpCurveFloat AutoTargetAngleCurve;
/** Interp curve to scale Friction angle for different ranges */
var() InterpCurveFloat FrictionAngleCurve;
/** Interp curve to scale Adhesion angle for different ranges */
var() InterpCurveFloat AdhesionAngleCurve;
/** Force rotation to within this angle when using the ForceLookAtPawn functionality */
var() float ForceLookAtPawnMinAngle;
/** How fast to rotate towards ForceLookAtPawn location */
var() float ForceLookAtPawnRotationRate;
/** How fast to rotate towards ForceLookAtPawn location dampened for closer rotation */
var() float ForceLookAtPawnDampenedRotationRate;
var const float DoubleTapDelay;
var float LastLogPerkTime;

// Export UKFPlayerInput::execGetKeyBindFromCommand(FFrame&, void* const)
native function GetKeyBindFromCommand(out KeyBind MyKeyBind, string BindCommand, optional bool bAlt);

// Export UKFPlayerInput::execSwapBind(FFrame&, void* const)
native function SwapBind(out KeyBind MainKeyBind, out KeyBind AltKeyBind);

// Export UKFPlayerInput::execSetKeyBind(FFrame&, void* const)
native function SetKeyBind(out KeyBind MyKeyBind, string Command);

// Export UKFPlayerInput::execRemoveCommandFromBind(FFrame&, void* const)
native function RemoveCommandFromBind(out KeyBind MyKeyBind, string CommandToRemove);

// Export UKFPlayerInput::execGetBindingsIndex(FFrame&, void* const)
native function int GetBindingsIndex(out KeyBind MyKeyBind);

// Export UKFPlayerInput::execResetKeysToDefault(FFrame&, void* const)
native static function ResetKeysToDefault();

// Export UKFPlayerInput::execGetBindDisplayName(FFrame&, void* const)
native function string GetBindDisplayName(out KeyBind MyKeyBind);

// Export UKFPlayerInput::execGetGameBindableAction(FFrame&, void* const)
native function string GetGameBindableAction(const out name Key);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    if(HUD.ShouldDisplayDebug('Input'))
    {
        HUD.Canvas.SetDrawColor(0, 255, 0);
        HUD.Canvas.DrawText((("AXIS: ATurn: " $ string(LastaTurn)) $ " aLookUp: ") $ string(LastaLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Raw: RawJoyLookRight: " $ string(RawJoyLookRight)) $ " RawJoyLookUp: ") $ string(RawJoyLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Remaining: RemainingaTurn: " $ string(RemainingaTurn)) $ " RemainingaLookUp: ") $ string(RemainingaLookUp));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("AXIS: aForward: " $ string(LastaForward)) $ " aStrafe: ") $ string(LastaStrafe));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText((("Raw: RawJoyRight: " $ string(RawJoyRight)) $ " RawJoyUp: ") $ string(RawJoyUp));
        out_YPos += out_YL;
        HUD.Canvas.DrawText("Raw: TotalRawStrafe: " $ string(Abs(RawJoyRight) + Abs(RawJoyUp)));
        out_YPos += out_YL;
    }
    if(HUD.ShouldDisplayDebug('Accel'))
    {
        HUD.Canvas.SetDrawColor(0, 255, 0);
        HUD.Canvas.DrawText((("ACCEL: ViewAccel_CurrMutliplier: " $ string(ViewAccel_CurrMutliplier)) $ " ViewAccel_TimeHeld: ") $ string(ViewAccel_TimeHeld));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
    }
}

function ClientInitInputSystem()
{
    super.ClientInitInputSystem();
    if(bRequiresPushToTalk)
    {
        Outer.ClientStopNetworkedVoice();        
    }
    else
    {
        Outer.ClientStartNetworkedVoice();
    }
}

function UpdatePushToTalk(bool bValue)
{
    if(bValue != bRequiresPushToTalk)
    {
        if(bValue)
        {
            Outer.ClientStopNetworkedVoice();            
        }
        else
        {
            Outer.ClientStartNetworkedVoice();
        }
        bRequiresPushToTalk = bValue;
        SaveConfig();
    }
}

exec function SetSensitivity(float F)
{
    MouseSensitivity = F;
    SaveConfig();
}

exec function SetZoomedSensitivity(float F)
{
    ZoomedSensitivityScalar = F;
    SaveConfig();
}

event PlayerInput(float DeltaTime)
{
    local float FOVScale, TimeScale;

    RawJoyUp = aBaseY;
    RawJoyRight = aStrafe;
    RawJoyLookRight = aTurn;
    RawJoyLookUp = aLookUp;
    DeltaTime /= Outer.WorldInfo.TimeDilation;
    if(Outer.bDemoOwner && Outer.WorldInfo.NetMode == NM_Client)
    {
        DeltaTime /= Outer.WorldInfo.DemoPlayTimeDilation;
    }
    PreProcessInput(DeltaTime);
    TimeScale = 100 * DeltaTime;
    aBaseY *= (TimeScale * MoveForwardSpeed);
    aStrafe *= (TimeScale * MoveStrafeSpeed);
    aUp *= (TimeScale * MoveStrafeSpeed);
    aTurn *= (TimeScale * LookRightScale);
    aLookUp *= (TimeScale * LookUpScale);
    PostProcessInput(DeltaTime);
    ProcessInputMatching(DeltaTime);
    CatchDoubleClickInput();
    FOVScale = 1;
    AdjustMouseSensitivity(FOVScale);
    if(bEnableMouseSmoothing)
    {
        aMouseX = SmoothMouse(aMouseX, DeltaTime, bXAxis, 0);
        aMouseY = SmoothMouse(aMouseY, DeltaTime, bYAxis, 1);
    }
    aLookUp *= FOVScale;
    aTurn *= FOVScale;
    if(bStrafe > 0)
    {
        aStrafe += (aBaseX + aMouseX);        
    }
    else
    {
        aTurn += (aBaseX + aMouseX);
    }
    aLookUp += aMouseY;
    if((!GetUsingGamepad(Outer) && bInvertMouse) || bInvertController && GetUsingGamepad(Outer))
    {
        aLookUp *= -1;
    }
    if(bInvertTurn)
    {
        aTurn *= -1;
    }
    aForward += aBaseY;
    Outer.HandleWalking();
    if(bLockTurnUntilRelease)
    {
        if(RawJoyLookRight != float(0))
        {
            aTurn = 0;
            if(AutoUnlockTurnTime > 0)
            {
                AutoUnlockTurnTime -= DeltaTime;
                if(AutoUnlockTurnTime < 0)
                {
                    bLockTurnUntilRelease = false;
                }
            }            
        }
        else
        {
            bLockTurnUntilRelease = false;
        }
    }
    if(Abs((aTurn % float(1)) + RemainingaTurn) >= 1)
    {
        aTurn += RemainingaTurn;
        RemainingaTurn = 0;
    }
    if(Abs((aLookUp % float(1)) + RemainingaLookUp) >= 1)
    {
        aLookUp += RemainingaLookUp;
        RemainingaLookUp = 0;
    }
    if(Outer.IsMoveInputIgnored())
    {
        aForward = 0;
        aStrafe = 0;
        aUp = 0;
    }
    if(Outer.IsLookInputIgnored())
    {
        aTurn = 0;
        aLookUp = 0;
    }
    LastaTurn = aTurn;
    LastaLookUp = aLookUp;
    LastaForward = aForward;
    LastaStrafe = aStrafe;
    if(aTurn != float(0))
    {
        RemainingaTurn += (aTurn % float(1));        
    }
    else
    {
        RemainingaTurn = 0;
    }
    if(aLookUp != float(0))
    {
        RemainingaLookUp += (aLookUp % float(1));        
    }
    else
    {
        RemainingaLookUp = 0;
    }
}

function AdjustMouseSensitivity(float FOVScale)
{
    local float UsedFOVAngle;
    local bool bUsingSights;

    if(bEnableFOVScaling)
    {
        if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
        {
            bUsingSights = Outer.Pawn.bIsWalking;
            UsedFOVAngle = Outer.Pawn.Weapon.GetModifiedFOVAngle();            
        }
        else
        {
            UsedFOVAngle = Outer.GetFOVAngle();
        }
        if((UsedFOVAngle != Outer.DefaultFOV) && bUsingSights)
        {
            FOVScale = (UsedFOVAngle * 0.01333) * ZoomedSensitivityScalar;            
        }
        else
        {
            FOVScale = 1;
        }
    }
    super(PlayerInput).AdjustMouseSensitivity(FOVScale);
}

function BindKey(KeyBind NewKeyBind, string BindCommand, bool bIsAlt)
{
    local KeyBind CurrentKeyBind;

    GetKeyBindFromCommand(CurrentKeyBind, BindCommand, bIsAlt);
    if(CurrentKeyBind.Name != 'None')
    {
        RemoveCommandFromBind(CurrentKeyBind, BindCommand);
        if(NewKeyBind.Name == 'Delete')
        {
            return;
        }
    }
    SetKeyBind(NewKeyBind, BindCommand);
    SwapPositions(NewKeyBind, BindCommand, bIsAlt);
}

function SwapPositions(KeyBind MyKeyBind, string BindCommand, bool bIsAlt)
{
    local KeyBind NewKeyBind;

    GetKeyBindFromCommand(NewKeyBind, BindCommand, false);
    if(bIsAlt && MyKeyBind.Name == NewKeyBind.Name)
    {
        GetKeyBindFromCommand(NewKeyBind, BindCommand, true);
        SwapBind(MyKeyBind, NewKeyBind);        
    }
    else
    {
        if(!bIsAlt && MyKeyBind.Name != NewKeyBind.Name)
        {
            SwapBind(MyKeyBind, NewKeyBind);
        }
    }
}

static function bool GetUsingGamepad(PlayerController PC)
{
    if((PC == none) || PC.PlayerInput == none)
    {
        return false;
    }
    return PC.PlayerInput.bUsingGamepad;
}

exec function GamepadSprint()
{
    Outer.bRun = 0;
    bExtendedSprinting = false;
    GamepadSprintPressTime = Outer.WorldInfo.TimeSeconds;
    GamepadSprintTimer();
    if(Outer.bRun == 0)
    {
        Outer.SetTimer(0.05, true, 'GamepadSprintTimer', self);
    }
}

function GamepadSprintTimer()
{
    if(IsDirectingJoyStick(0.3))
    {
        Outer.bRun = 1;
        Outer.ClearTimer('GamepadSprintTimer', self);
    }
}

exec function GamepadSprintRelease()
{
    if(IsDirectingJoyStick(0.3))
    {
        bExtendedSprinting = true;
        SprintTimeBelowThreshold = 0;        
    }
    else
    {
        if((Outer.bRun == 0) && (Outer.WorldInfo.TimeSeconds - GamepadSprintPressTime) < GamepadButtonHoldTime)
        {
            ToggleCrouch();
        }
    }
    Outer.bRun = 0;
    Outer.ClearTimer('GamepadSprintTimer', self);
}

exec function Jump()
{
    Outer.bDuck = 0;
    PressedJumpTime = Outer.WorldInfo.TimeSeconds;
    super(PlayerInput).Jump();
}

exec function StartCrouch()
{
    if((Outer.Pawn != none) && Outer.Pawn.bCanCrouch)
    {
        Outer.bDuck = 1;
    }
}

exec function StopCrouch()
{
    if(Outer.bDuck == 1)
    {
        Outer.bDuck = 0;
    }
}

exec function ToggleCrouch()
{
    if((Outer.Pawn != none) && Outer.Pawn.bCanCrouch)
    {
        Outer.bDuck = ((Outer.bDuck == 0) ? 1 : 0);
    }
}

exec function GamepadCrouch()
{
    ToggleCrouch();
    if(Outer.bDuck == 1)
    {
        Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadCrouchTimer', self);
    }
}

exec function GamepadCrouchRelease()
{
    local bool bWasButtonHeld;

    bWasButtonHeld = !Outer.IsTimerActive('GamepadCrouchTimer', self);
    if(bWasButtonHeld)
    {
        StopCrouch();
    }
}

function GamepadCrouchTimer();

simulated exec function IronSights(optional bool bHoldButtonMode)
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.SetIronSights(((bHoldButtonMode) ? true : !KFW.bUsingSights));
        }
    }
}

simulated exec function IronSightsRelease(optional bool bHoldButtonMode)
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            if(!KFW.bHasIronSights || bHoldButtonMode)
            {
                KFW.SetIronSights(false);
            }
        }
    }
}

simulated exec function ToggleFlashlight()
{
    local KFPawn_Human KFP;
    local bool bPerkHasNightVision;

    if(((Outer.Pawn == none) || Outer.Pawn.InvManager == none) || bGamepadWeaponSelectOpen)
    {
        return;
    }
    bPerkHasNightVision = Outer.GetPerk().HasNightVision();
    KFP = KFPawn_Human(Outer.Pawn);
    if((KFP != none) && KFP.MyKFWeapon != none)
    {
        if(bPerkHasNightVision)
        {
            ToggleNightVIsion(KFP);
            return;
        }
        ToggleActualFlashLight(KFP);
    }
    if(KFP != none)
    {
        PlayFlashlightNVSounds(KFP, bPerkHasNightVision);
    }
}

simulated function ToggleNightVIsion(KFPawn_Human KFP)
{
    if(!Outer.bNightVisionActive && !KFP.bFlashlightOn)
    {
        if(Outer.IsTimerActive('NightVisionTimer', self))
        {
            Outer.ClearTimer('NightVisionTimer', self);
            ToggleActualFlashLight(KFP);            
        }
        else
        {
            Outer.SetTimer(DoubleTapDelay, false, 'NightVisionTimer', self);
        }        
    }
    else
    {
        if(Outer.bNightVisionActive)
        {
            if(Outer.IsTimerActive('NightVisionTimer', self))
            {
                Outer.ClearTimer('NightVisionTimer', self);
                Outer.SetNightVision(!Outer.bNightVisionActive);
                ToggleActualFlashLight(KFP);                
            }
            else
            {
                Outer.SetTimer(DoubleTapDelay, false, 'NightVisionTimer', self);
            }            
        }
        else
        {
            if(KFP.bFlashlightOn)
            {
                ToggleActualFlashLight(KFP);
            }
        }
    }
}

simulated function ToggleActualFlashLight(KFPawn_Human KFP)
{
    ((KFP.MyKFWeapon.bHasFlashlight) ? KFP.ToggleFlashlight() : KFInventoryManager(Outer.Pawn.InvManager).SwitchToPrimaryFlashLightWeapon());
}

simulated function NightVisionTimer()
{
    Outer.SetNightVision(!Outer.bNightVisionActive);
}

simulated function PlayFlashlightNVSounds(KFPawn_Human KFP, bool bPerkHasNightVision)
{
    if(bPerkHasNightVision && !KFP.bFlashlightOn)
    {
        ((Outer.bNightVisionActive) ? KFP.PlaySoundBase(Outer.NightVisionOnEvent) : KFP.PlaySoundBase(Outer.NightVisionOffEvent));        
    }
    else
    {
        ((KFP.bFlashlightOn) ? KFP.PlaySoundBase(Outer.FlashlightOnEvent) : KFP.PlaySoundBase(Outer.FlashlightOffEvent));
    }
}

simulated function NighVisionTapDelayTimer();

exec function StartTertiaryFire()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StartFire(3);
    }
}

exec function StopTertiaryFire()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StopFire(3);
    }
}

exec function Reload()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StartFire(2);
    }
}

exec function ReloadRelease()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StopFire(2);
    }
}

exec function Grenade()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StartFire(4);
    }
}

exec function GrenadeRelease()
{
    if(Outer.Pawn != none)
    {
        Outer.Pawn.StopFire(4);
    }
}

exec function SwitchFire()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.AltFireMode();
        }
    }
}

exec function SwitchFireRelease()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if(KFW != none)
        {
            KFW.AltFireModeRelease();
        }
    }
}

exec function SelectNextWeapon()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(bQuickWeaponSelect)
        {
            Outer.NextWeapon();            
        }
        else
        {
            KFIM.HighlightNextWeapon();
        }
        KFIM.ShowAllHUDGroups();
    }
}

exec function SelectPrevWeapon()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(bQuickWeaponSelect)
        {
            Outer.PrevWeapon();            
        }
        else
        {
            KFIM.HighlightPrevWeapon();
        }
        KFIM.ShowAllHUDGroups();
    }
}

exec function GamepadWeaponSelect()
{
    local KFWeapon KFW;

    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadWeaponMenuTimer', self);
    }
}

exec function ReleaseGamepadWeaponSelect()
{
    local KFInventoryManager KFIM;
    local KFWeapon KFW;

    if(bGamepadWeaponSelectOpen)
    {
        Outer.MyGFxHUD.WeaponSelectWidget.SetWeaponSwitchStayOpen(false);
        bGamepadWeaponSelectOpen = false;
    }
    if(Outer.Pawn != none)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW == none) || KFW.CanSwitchWeapons())
        {
            if(Outer.IsTimerActive('GamepadWeaponMenuTimer', self))
            {
                Outer.NextWeapon();
                Outer.ClearTimer('GamepadWeaponMenuTimer', self);                
            }
            else
            {
                KFIM = KFInventoryManager(Outer.Pawn.InvManager);
                KFIM.SetCurrentWeapon(KFIM.PendingWeapon);
            }
        }
    }
}

function GamepadWeaponMenuTimer()
{
    local KFWeapon KFW;

    if(((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none) && Outer.MyGFxHUD.VoiceCommsWidget.bActive)
    {
        return;
    }
    if((Outer.Pawn != none) && bUsingGamepad)
    {
        KFW = KFWeapon(Outer.Pawn.Weapon);
        if((KFW != none) && !KFW.CanSwitchWeapons())
        {
            return;
        }
        bGamepadWeaponSelectOpen = true;
        Outer.MyGFxHUD.WeaponSelectWidget.SetWeaponSwitchStayOpen(true);
        KFInventoryManager(Outer.Pawn.InvManager).HighlightWeapon(Outer.Pawn.Weapon);
    }
}

exec function SwitchWeaponGroup(byte GroupID)
{
    local KFInventoryManager KFIM;
    local KFWeapon NextGroupedWeapon, KFW;

    if((Outer.Pawn == none) || Outer.Pawn.InvManager == none)
    {
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return;
    }
    if(((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none) && Outer.MyGFxHUD.VoiceCommsWidget.bActive)
    {
        return;
    }
    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        NextGroupedWeapon = KFIM.GetNextGroupedWeapon(GroupID);
        if(bUsingGamepad)
        {
            if(bGamepadWeaponSelectOpen)
            {
                KFIM.HighlightWeapon(NextGroupedWeapon);
            }            
        }
        else
        {
            KFIM.SetCurrentWeapon(NextGroupedWeapon);
        }
        KFIM.ShowOnlyHUDGroup(GroupID);
    }
}

exec function QuickHeal()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return;
    }
    KFInventoryManager(Outer.Pawn.InvManager).AttemptQuickHeal();
}

exec function TossMoney()
{
    local KFInventoryManager KFIM;

    if((Outer.Pawn != none) && Outer.Pawn.InvManager != none)
    {
        KFIM = KFInventoryManager(Outer.Pawn.InvManager);
        if(KFIM != none)
        {
            KFIM.ThrowMoney();
        }
    }
}

exec function GamepadDpadLeft()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerViewPrevPlayer();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(0);            
        }
        else
        {
            ToggleFlashlight();
        }
    }
}

exec function GamepadDpadDown()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerNextSpectateMode();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(2);            
        }
        else
        {
            QuickHeal();
        }
    }
}

exec function GamepadDpadRight()
{
    if(Outer.IsSpectating())
    {
        Outer.ServerViewNextPlayer();        
    }
    else
    {
        if(bGamepadWeaponSelectOpen)
        {
            SwitchWeaponGroup(1);            
        }
        else
        {
            ShowVoiceComms();
        }
    }
}

exec function GamepadDpadRightRelease()
{
    if(!bGamepadWeaponSelectOpen)
    {
        HideVoiceComms();
    }
}

exec function ShowVoiceComms()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none)
    {
        Outer.MyGFxHUD.ShowVoiceComms(true);
    }
}

exec function HideVoiceComms()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.VoiceCommsWidget != none)
    {
        Outer.SetCinematicMode(false, false, false, false, true, false);
        Outer.MyGFxHUD.ShowVoiceComms(false);
    }
}

exec function GamepadDpadUp()
{
    if(bGamepadWeaponSelectOpen)
    {
        SwitchWeaponGroup(3);        
    }
    else
    {
        Outer.SetTimer(GamepadButtonHoldTime, false, 'GamepadDpadUpTimer', self);
    }
}

exec function GamepadDpadUpRelease()
{
    local bool bButtonWasHeld;

    if(!bGamepadWeaponSelectOpen)
    {
        bButtonWasHeld = !Outer.IsTimerActive('GamepadDpadUpTimer', self);
        if(!bButtonWasHeld)
        {
            TossMoney();
            Outer.ClearTimer('GamepadDpadUpTimer', self);
        }
    }
}

function GamepadDpadUpTimer()
{
    Outer.ThrowWeapon();
}

exec function OnVoteYesPressed()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnYesPressed();
    }
}

exec function OnVoteYesRelease()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnYesReleased();
    }
}

exec function OnVoteNoPressed()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnNoPressed();
    }
}

exec function OnVoteNoRelease()
{
    if((Outer.MyGFxHUD != none) && Outer.MyGFxHUD.KickVoteWidget != none)
    {
        Outer.MyGFxHUD.KickVoteWidget.OnNoReleased();
    }
}

exec function Interact()
{
    Outer.SetTimer(GamepadButtonHoldTime, false, 'InteractTimer', self);
}

exec function InteractRelease()
{
    local bool bButtonWasHeld;

    bButtonWasHeld = !Outer.IsTimerActive('InteractTimer', self);
    if(!bButtonWasHeld)
    {
        Outer.Use();
        Outer.ClearTimer('InteractTimer', self);
    }
}

exec function InteractTimer()
{
    local KFInventoryManager KFIM;

    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        KFIM.QuickWeld();
    }
}

exec function StartVoiceChat()
{
    if(bRequiresPushToTalk)
    {
        Outer.ClearTimer('ClientStopNetworkedVoice');
        Outer.ClientStartNetworkedVoice();
    }
}

exec function StopVoiceChat()
{
    if(bRequiresPushToTalk)
    {
        Outer.SetTimer(0.25, false, 'ClientStopNetworkedVoice');
    }
}

simulated event PostBeginPlay()
{
    ViewAccel_CurrMutliplier = 1;
}

function PreProcessInput(float DeltaTime)
{
    local KFWeapon KFW;
    local float FOVScale;

    super(PlayerInput).PreProcessInput(DeltaTime);
    if(Outer.Pawn == none)
    {
        return;
    }
    if(!bUsingGamepad)
    {
        return;
    }
    if((Outer.Pawn == none) || Outer.Pawn.Weapon == none)
    {
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(!bAimTriggerPulled && aLeftAnalogTrigger > 0.99)
    {
        bAimTriggerPulled = true;
        Outer.NewAutoTarget();        
    }
    else
    {
        if(bAimTriggerPulled && aLeftAnalogTrigger <= 0.9)
        {
            bAimTriggerPulled = false;
        }
    }
    if(KFW.ShouldOwnerWalk())
    {
        Outer.bRun = 0;
        bExtendedSprinting = false;        
    }
    else
    {
        if(bExtendedSprinting)
        {
            UpdateExtendedSprint(DeltaTime);
        }
    }
    if(bViewAccelerationEnabled)
    {
        ApplyViewAcceleration(DeltaTime);
    }
    if(bTargetFrictionEnabled)
    {
        if(KFW != none)
        {
            bAppliedTargetFriction = false;
            ApplyTargetFriction(DeltaTime, KFW);
        }
    }
    FOVScale = GetFOVAdjustedControllerSensitivity();
    aTurn *= FOVScale;
    aLookUp *= FOVScale;
    aTurn *= HorizontalSensitivityScale;
    aLookUp *= VerticalSensitivityScale;
    aTurn *= EvalInterpCurveFloat(SensitivityScaleCurve, Abs(RawJoyLookRight));
    aLookUp *= EvalInterpCurveFloat(SensitivityScaleCurve, Abs(RawJoyLookUp));
}

function UpdateExtendedSprint(float DeltaTime)
{
    if(IsDirectingJoyStick(SprintAnalogThreshold))
    {
        Outer.bRun = 1;
        SprintTimeBelowThreshold = 0;        
    }
    else
    {
        if(Outer.bRun > 0)
        {
            if(SprintTimeBelowThreshold > TimeBelowThresholdToStopSprint)
            {
                Outer.bRun = 0;
                bExtendedSprinting = false;                
            }
            else
            {
                SprintTimeBelowThreshold += DeltaTime;
            }            
        }
        else
        {
            bExtendedSprinting = false;
        }
    }
}

function bool IsDirectingJoyStick(float Threshold)
{
    if((Abs(RawJoyUp) + Abs(RawJoyRight)) > Threshold)
    {
        return true;
    }
    return false;
}

function ApplyViewAcceleration(float DeltaTime)
{
    if((Abs(aTurn) > ViewAccel_YawThreshold) || Square(Abs(RawJoyLookRight) + Square(Abs(RawJoyLookUp / 0.75))) > ViewAccel_DiagonalThreshold)
    {
        if((ViewAccel_TimeHeld > ViewAccel_TimeToHoldBeforeFastAcceleration) && !bAppliedTargetFriction)
        {
            ViewAccel_CurrMutliplier += ViewAccel_RampSpeed;
            aTurn *= FMin(ViewAccel_CurrMutliplier, ViewAccel_MaxTurnSpeed);            
        }
        else
        {
            ViewAccel_CurrMutliplier = Abs(aTurn);
            ViewAccel_TimeHeld += DeltaTime;
        }        
    }
    else
    {
        ViewAccel_CurrMutliplier = 1;
        ViewAccel_TimeHeld = 0;
    }
}

function InitAutoTarget()
{
    local Vector CamLoc;
    local Rotator CamRot;
    local Vector X, Y, Z;
    local float UsedTargetAngle;

    if(!bUsingGamepad)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    GetAxes(CamRot, X, Y, Z);
    CurrentAutoTarget = Outer.GetTargetAdhesionFrictionTarget(50000, CamLoc, CamRot, AutoTargetAngleCurve);
    AutoTargetInitialLocation = GetAutoTargetLocation(CurrentAutoTarget, CamLoc);
    if(Outer.bDebugAutoTarget)
    {
        Outer.FlushPersistentDebugLines();
        UsedTargetAngle = EvalInterpCurveFloat(AutoTargetAngleCurve, VSize(CamLoc - AutoTargetInitialLocation));
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 500, Acos(UsedTargetAngle), Acos(UsedTargetAngle), 16, MakeColor(255, 0, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 250, Acos(AutoTargetAngleCurve.Points[0].OutVal), Acos(AutoTargetAngleCurve.Points[0].OutVal), 16, MakeColor(0, 255, 0, 255), true);
        Outer.DrawDebugCone(CamLoc + (X * float(5)), X, 1000, Acos(AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].OutVal), Acos(AutoTargetAngleCurve.Points[AutoTargetAngleCurve.Points.Length - 1].OutVal), 16, MakeColor(255, 255, 0, 255), true);
    }
}

function Vector GetAutoTargetLocation(Pawn CheckTarget, Vector CamLoc)
{
    local KFWeapon KFW;

    if(CheckTarget == none)
    {
        return vect(0, 0, 0);
    }
    if(KFPawn(CheckTarget) != none)
    {
        return KFPawn(CheckTarget).GetAutoTargetLocation(CamLoc, Outer.Pawn);
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        return CheckTarget.Location + KFW.TargetFrictionOffset;        
    }
    else
    {
        return CheckTarget.Location + vect(0, 0, 32);
    }
}

function ApplyAutoTarget(float DeltaTime, KFWeapon W, out int out_YawRot, out int out_PitchRot)
{
    local Vector RealTargetLoc, CamToTarget, CamLoc, X, Y, Z;

    local Rotator CamRot, DeltaRot, CamRotWithFreeAim;
    local float DistToTarget, AdhesionAmtY, AdhesionAmtZ, TargetRadius, TargetHeight;

    local int AdjustY, AdjustZ;
    local float DotDiffToTarget, UsedTargetAngle;

    if(!bUsingGamepad)
    {
        return;
    }
    if((W == none) || CurrentAutoTarget == none)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    CamRotWithFreeAim = CamRot + Outer.WeaponBufferRotation;
    GetAxes(CamRotWithFreeAim, X, Y, Z);
    if(((CurrentAutoTarget != none) && CurrentAutoTarget.Health > 0) && (KFPawn_Monster(CurrentAutoTarget) == none) || !KFPawn_Monster(CurrentAutoTarget).bIsHeadless)
    {
        RealTargetLoc = AutoTargetInitialLocation;
        if(Outer.bDebugAutoTarget)
        {
            CurrentAutoTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
            Outer.DrawDebugCylinder(AutoTargetInitialLocation + vect(0, 0, 5), AutoTargetInitialLocation - vect(0, 0, 5), 10, 12, 255, 0, 0);
            Outer.DrawDebugCylinder(CurrentAutoTarget.Location + (vect(0, 0, 1) * TargetHeight), CurrentAutoTarget.Location - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 0, 255, 0);
        }
        CamToTarget = RealTargetLoc - CamLoc;
        DotDiffToTarget = Normal(RealTargetLoc - CamLoc) Dot Normal(vector(CamRotWithFreeAim));
        DistToTarget = VSize(CamToTarget);
        UsedTargetAngle = EvalInterpCurveFloat(AutoTargetAngleCurve, DistToTarget);
        if(Outer.bDebugAutoTarget)
        {
            LogInternal((((string(GetFuncName()) @ "DotDiffToTarget = ") $ string(DotDiffToTarget)) $ "  AutoTargetAngle = ") $ string(UsedTargetAngle));
        }
        if((DotDiffToTarget > UsedTargetAngle) && DistToTarget <= 50000)
        {
            DeltaRot.Yaw = rotator(RealTargetLoc - CamLoc).Yaw - CamRotWithFreeAim.Yaw;
            DeltaRot.Pitch = rotator(RealTargetLoc - CamLoc).Pitch - CamRotWithFreeAim.Pitch;
            DeltaRot = Normalize(DeltaRot);
            if(DeltaRot.Yaw != 0)
            {
                AdhesionAmtY = AutoTargetRotationRate;
                AdjustY = int(float(DeltaRot.Yaw) * (AdhesionAmtY * DeltaTime));
                out_YawRot += AdjustY;
            }
            if(DeltaRot.Pitch != 0)
            {
                AdhesionAmtZ = AutoTargetRotationRate;
                AdjustZ = int(float(DeltaRot.Pitch) * (AdhesionAmtZ * DeltaTime));
                out_PitchRot += AdjustZ;
            }
        }
    }
}

function ApplyForceLookAtPawn(float DeltaTime, out int out_YawRot, out int out_PitchRot)
{
    local Vector RealTargetLoc, CamLoc, X, Y, Z;

    local Rotator CamRot, DeltaRot, CamRotWithFreeAim;
    local float AdhesionAmtY, AdhesionAmtZ, TargetRadius, TargetHeight;
    local int AdjustY, AdjustZ;
    local float DotDiffToTarget, UsedRotationRate;

    if(Outer.ForceLookAtPawn == none)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    CamRotWithFreeAim = CamRot + Outer.WeaponBufferRotation;
    GetAxes(CamRotWithFreeAim, X, Y, Z);
    if((Outer.ForceLookAtPawn != none) && Outer.ForceLookAtPawn.Health > 0)
    {
        RealTargetLoc = GetAutoTargetLocation(Outer.ForceLookAtPawn, CamLoc);
        if(Outer.bDebugAutoTarget)
        {
            Outer.ForceLookAtPawn.GetBoundingCylinder(TargetRadius, TargetHeight);
            Outer.DrawDebugCylinder(RealTargetLoc + vect(0, 0, 5), RealTargetLoc - vect(0, 0, 5), 10, 12, 255, 0, 0);
            Outer.DrawDebugCylinder(Outer.ForceLookAtPawn.Location + (vect(0, 0, 1) * TargetHeight), Outer.ForceLookAtPawn.Location - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 0, 255, 0);
        }
        DotDiffToTarget = Normal(RealTargetLoc - CamLoc) Dot Normal(vector(CamRotWithFreeAim));
        if(DotDiffToTarget < ForceLookAtPawnMinAngle)
        {
            UsedRotationRate = ForceLookAtPawnRotationRate;            
        }
        else
        {
            UsedRotationRate = ForceLookAtPawnDampenedRotationRate;
        }
        DeltaRot.Yaw = rotator(RealTargetLoc - CamLoc).Yaw - CamRotWithFreeAim.Yaw;
        DeltaRot.Pitch = rotator(RealTargetLoc - CamLoc).Pitch - CamRotWithFreeAim.Pitch;
        DeltaRot = Normalize(DeltaRot);
        if(DeltaRot.Yaw != 0)
        {
            AdhesionAmtY = UsedRotationRate;
            AdjustY = int(float(DeltaRot.Yaw) * (AdhesionAmtY * DeltaTime));
            out_YawRot += AdjustY;
        }
        if(DeltaRot.Pitch != 0)
        {
            AdhesionAmtZ = UsedRotationRate;
            AdjustZ = int(float(DeltaRot.Pitch) * (AdhesionAmtZ * DeltaTime));
            out_PitchRot += AdjustZ;
        }
    }
}

function ApplyTargetAdhesion(float DeltaTime, KFWeapon W, out int out_YawRot, out int out_PitchRot)
{
    local Vector RealTargetLoc, TargetLoc, CamToTarget, AimLoc, CamLoc, ClosestY,
	    ClosestZ, X, Y, Z;

    local Rotator CamRot, DeltaRot;
    local float DistToTarget, DistFromAimZ, DistFromAimY, AdhesionAmtY, AdhesionAmtZ, TargetRadius,
	    TargetHeight, Pct;

    local int AdjustY, AdjustZ;
    local Pawn AdhesionTarget;

    if(!bUsingGamepad)
    {
        return;
    }
    if((W == none) || !W.bTargetAdhesionEnabled)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    GetAxes(CamRot, X, Y, Z);
    AdhesionTarget = LastFrictionTarget;
    if((AdhesionTarget == none) || (Outer.WorldInfo.TimeSeconds - LastFrictionTargetTime) > W.TargetAdhesionTimeMax)
    {
        AdhesionTarget = Outer.GetTargetAdhesionFrictionTarget(W.TargetAdhesionDistanceMax, CamLoc, CamRot, AdhesionAngleCurve);
    }
    if(((AdhesionTarget != none) && AdhesionTarget.Health > 0) && (KFPawn_Monster(AdhesionTarget) == none) || !KFPawn_Monster(AdhesionTarget).bIsHeadless)
    {
        AdhesionTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
        TargetRadius *= 0.65;
        TargetHeight *= 0.65;
        RealTargetLoc = AdhesionTarget.Location + (W.TargetFrictionOffset >> CamRot);
        if(Outer.bDebugTargetAdhesion)
        {
            Outer.DrawDebugCylinder(RealTargetLoc + (vect(0, 0, 1) * TargetHeight), RealTargetLoc - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 0, 255, 0);
        }
        if((((W.TargetAdhesionTargetVelocityMin == 0) || VSize(AdhesionTarget.Velocity) > W.TargetAdhesionTargetVelocityMin) && (W.TargetAdhesionPlayerVelocityMin == 0) || VSize(Outer.Pawn.Velocity) > W.TargetAdhesionPlayerVelocityMin) && ((RealTargetLoc - CamLoc) Dot vector(CamRot)) > 0)
        {
            CamToTarget = RealTargetLoc - CamLoc;
            DistToTarget = VSize(CamToTarget);
            AimLoc = CamLoc + (X * DistToTarget);
            TargetLoc = RealTargetLoc;
            TargetLoc.Z = AimLoc.Z;
            DistFromAimY = PointDistToLine(AimLoc, TargetLoc - CamLoc, CamLoc, ClosestY);
            ClosestY = TargetLoc + (Normal(ClosestY - TargetLoc) * TargetRadius);
            TargetLoc = RealTargetLoc;
            TargetLoc.X = AimLoc.X;
            TargetLoc.Y = AimLoc.Y;
            DistFromAimZ = PointDistToLine(AimLoc, TargetLoc - CamLoc, CamLoc, ClosestZ);
            ClosestZ = TargetLoc + (Normal(ClosestZ - TargetLoc) * TargetRadius);
            DeltaRot.Yaw = rotator(ClosestY - CamLoc).Yaw - CamRot.Yaw;
            DeltaRot.Pitch = rotator(ClosestZ - CamLoc).Pitch - CamRot.Pitch;
            DeltaRot = Normalize(DeltaRot);
            if(((DistToTarget <= W.TargetAdhesionDistanceMax) && (DistFromAimY > TargetRadius) || DistFromAimZ > TargetHeight) && Outer.LineOfSightTo(AdhesionTarget, CamLoc))
            {
                if(DistFromAimY > TargetRadius)
                {
                    Pct = 1 - ((DistFromAimY - TargetRadius) / W.TargetAdhesionAimDistY);
                    if(Pct > 0)
                    {
                        Pct = FMin(Pct, 0.8);
                        AdhesionAmtY = GetRangeValueByPct(W.TargetAdhesionScaleRange, Pct);
                        AdjustY = int(float(DeltaRot.Yaw) * (AdhesionAmtY * DeltaTime));
                        out_YawRot += AdjustY;
                    }
                }
                if(DistFromAimZ > TargetHeight)
                {
                    Pct = 1 - ((DistFromAimZ - TargetHeight) / W.TargetAdhesionAimDistZ);
                    if(Pct > 0)
                    {
                        Pct = FMin(Pct, 0.8);
                        AdhesionAmtZ = GetRangeValueByPct(W.TargetAdhesionScaleRange, Pct);
                        AdjustZ = int(float(DeltaRot.Pitch) * (AdhesionAmtZ * DeltaTime));
                        out_PitchRot += AdjustZ;
                    }
                }
            }
        }
    }
}

function ApplyTargetFriction(float DeltaTime, KFWeapon W)
{
    local Pawn FrictionTarget;
    local Vector CamLoc, X, Y, Z, CamToTarget, AimLoc,
	    TargetLoc, RealTargetLoc;

    local Rotator CamRot;
    local float DistToTarget, DistMultiplier, DistFromAimZ, DistFromAimY, TargetRadius, TargetHeight,
	    FrictionMultiplier;

    if((Outer.Pawn == none) || !W.bTargetFrictionEnabled)
    {
        return;
    }
    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    GetAxes(CamRot, X, Y, Z);
    FrictionTarget = Outer.GetTargetAdhesionFrictionTarget(W.TargetFrictionDistanceMax, CamLoc, CamRot, FrictionAngleCurve);
    if(FrictionTarget != none)
    {
        RealTargetLoc = FrictionTarget.Location + (W.TargetFrictionOffset >> CamRot);
        CamToTarget = RealTargetLoc - CamLoc;
        DistToTarget = VSize(CamToTarget);
        AimLoc = CamLoc + (X * DistToTarget);
        FrictionTarget.GetBoundingCylinder(TargetRadius, TargetHeight);
        TargetLoc = RealTargetLoc;
        TargetLoc.Z = AimLoc.Z;
        DistFromAimY = PointDistToLine(AimLoc, TargetLoc - CamLoc, CamLoc);
        TargetLoc = RealTargetLoc;
        TargetLoc.X = AimLoc.X;
        TargetLoc.Y = AimLoc.Y;
        DistFromAimZ = PointDistToLine(AimLoc, TargetLoc - CamLoc, CamLoc);
        DistMultiplier = 0;
        if((DistToTarget >= W.TargetFrictionDistanceMin) && DistToTarget <= W.TargetFrictionDistanceMax)
        {
            if(DistToTarget <= W.TargetFrictionDistancePeak)
            {
                DistMultiplier = FClamp((DistToTarget - W.TargetFrictionDistanceMin) / (W.TargetFrictionDistancePeak - W.TargetFrictionDistanceMin), 0, 1);                
            }
            else
            {
                DistMultiplier = FClamp(1 - ((DistToTarget - W.TargetFrictionDistancePeak) / (W.TargetFrictionDistanceMax - W.TargetFrictionDistancePeak)), 0, 1);
            }
            if(bDebugTargetFriction)
            {
                LogInternal((string(GetFuncName()) @ "DistMultiplier: ") $ string(DistMultiplier));
            }
            TargetRadius *= (1 + (W.TargetFrictionPeakRadiusScale * DistMultiplier));
            TargetHeight *= (1 + (W.TargetFrictionPeakHeightScale * DistMultiplier));
        }
        if(bDebugTargetFriction)
        {
            Outer.DrawDebugCylinder(FrictionTarget.Location + (vect(0, 0, 1) * TargetHeight), FrictionTarget.Location - (vect(0, 0, 1) * TargetHeight), TargetRadius, 12, 255, 0, 0);
        }
        if((DistFromAimY < TargetRadius) && DistFromAimZ < TargetHeight)
        {
            FrictionMultiplier = GetRangeValueByPct(W.TargetFrictionMultiplierRange, 1 - (DistFromAimY / TargetRadius));
            if(FrictionMultiplier > 0)
            {
                bAppliedTargetFriction = true;
                aTurn *= (1 - FrictionMultiplier);
                aLookUp *= (1 - FrictionMultiplier);
                LastFrictionTargetTime = Outer.WorldInfo.TimeSeconds;
                LastFrictionTarget = FrictionTarget;
            }
        }
    }
}

function float GetFOVAdjustedControllerSensitivity()
{
    local float FOVScale, UsedFOVAngle;
    local bool bUsingSights;

    FOVScale = 1;
    if(bEnableFOVScaling)
    {
        if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
        {
            bUsingSights = Outer.Pawn.bIsWalking;
            UsedFOVAngle = Outer.Pawn.Weapon.GetModifiedFOVAngle();            
        }
        else
        {
            UsedFOVAngle = Outer.GetFOVAngle();
        }
        if((UsedFOVAngle != Outer.DefaultFOV) && bUsingSights)
        {
            FOVScale = (UsedFOVAngle * 0.01333) * ZoomedSensitivityScalar;            
        }
        else
        {
            FOVScale = 1;
        }
    }
    return FOVScale;
}

exec function DebugViewAcceleration()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        bDebugViewAcceleration = !bDebugViewAcceleration;
        Outer.ClientMessage("bDebugViewAcceleration is now: " $ string(bDebugViewAcceleration));
    }
}

exec function DebugTargetAdhesion()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        Outer.bDebugTargetAdhesion = !Outer.bDebugTargetAdhesion;
        Outer.ClientMessage("bDebugTargetAdhesion is now: " $ string(Outer.bDebugTargetAdhesion));
    }
}

exec function DebugAutoTarget()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        Outer.bDebugAutoTarget = !Outer.bDebugAutoTarget;
        Outer.ClientMessage("bDebugAutoTarget is now: " $ string(Outer.bDebugAutoTarget));
    }
}

exec function DebugTargetFriction()
{
    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        bDebugTargetFriction = !bDebugTargetFriction;
        Outer.ClientMessage("bDebugTargetFriction is now: " $ string(bDebugTargetFriction));
    }
}

exec function SuppressTakeDamage(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogTakeDamage false");
}

exec function UnsuppressTakeDamage(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogTakeDamage true");
}

exec function SuppressPhysicsBodyImpact(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogPhysicsBodyImpact false");
}

exec function UnsuppressPhysicsBodyImpact(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogPhysicsBodyImpact true");
}

exec function SuppressSpecialMove(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogSpecialMove false");
}

exec function UnsuppressSpecialMove(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogSpecialMove true");
}

exec function SuppressPawnAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogCustomAnim false");
}

exec function UnsuppressPawnAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFPawn');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogCustomAnim true");
}

exec function SuppressWeaponAttach(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFWeaponAttachment bDebug false");
}

exec function UnsuppressWeaponAttach(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFWeaponAttachment bDebug true");
}

exec function SuppressIncapacitation(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAfflictions bLog false");
}

exec function UnsuppressIncapacitation(optional name ClassName)
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAfflictions bLog true");
}

exec function SuppressWeaponAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFWeapon');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogAnimation false");
}

exec function UnsuppressWeaponAnim(optional name ClassName)
{
    ClassName = ((ClassName != 'None') ? ClassName : 'KFWeapon');    
    Outer.ConsoleCommand(("SETNOPEC" @ string(ClassName)) @ "bLogAnimation true");
}

exec function SuppressMelee()
{
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bLogMelee false");
}

exec function UnsuppressMelee()
{
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bLogMelee true");
}

exec function SuppressPerk()
{
    Outer.ConsoleCommand("SETNOPEC KFPerk bLogPerk false");
}

exec function UnsuppressPerk()
{
    Outer.ConsoleCommand("SETNOPEC KFPerk bLogPerk true");
}

exec function SuppressAISpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogAISpawning false");
}

exec function UnsuppressAISpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogAISpawning true");
}

exec function SuppressWaveSpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogWaveSpawnTiming false");
}

exec function UnsuppressWaveSpawnLogging()
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager bLogWaveSpawnTiming true");
}

exec function SuppressScoring()
{
    Outer.ConsoleCommand("SETNOPEC KFGameInfo bLogScoring false");
}

exec function UnsuppressScoring()
{
    Outer.ConsoleCommand("SETNOPEC KFGameInfo bLogScoring true");
}

defaultproperties
{
    bRequiresPushToTalk=true
    bQuickWeaponSelect=true
    bViewAccelerationEnabled=true
    bTargetFrictionEnabled=true
    ZoomedSensitivityScalar=0.35
    GamepadButtonHoldTime=0.25
    SprintAnalogThreshold=0.9
    TimeBelowThresholdToStopSprint=0.05
    HorizontalSensitivityScale=1
    VerticalSensitivityScale=0.9
    ViewAccel_YawThreshold=0.99
    ViewAccel_DiagonalThreshold=0.99
    ViewAccel_TimeToHoldBeforeFastAcceleration=0.0625
    ViewAccel_RampSpeed=0.0075
    ViewAccel_MaxTurnSpeed=1.1
    SensitivityScaleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    AutoTargetRotationRate=35
    AutoTargetAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.8,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    FrictionAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    AdhesionAngleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.95,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    ForceLookAtPawnMinAngle=0.9
    ForceLookAtPawnRotationRate=22
    ForceLookAtPawnDampenedRotationRate=8
    DoubleTapDelay=0.25
    bEnableFOVScaling=true
}