/*******************************************************************************
 * KFSM_GrappleCombined generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_GrappleCombined extends KFSM_InteractionPawnLeader
    native(SpecialMoves);

enum EGrappleState
{
    EGS_GrabAttempt,
    EGS_GrabSuccess,
    EGS_GrabMiss,
    EGS_MAX
};

var array<name> GrappleAnims;
var bool bStopFullBodyWhenMoveEnds;
var bool bCanBeBlocked;
var bool bCanBeInterrupted;
var bool bUseRootMotion;
var byte LastVariant;
var float MaxGrabDistance;
var float MaxVictimZOffset;
var name GrabStartAnimName;
var float GrabCheckTime;
var float MinPlayerGrabTime;

protected function bool InternalCanDoSpecialMove()
{
    if(PawnOwner.IsHumanControlled() && PawnOwner.Physics == 2)
    {
        return false;
    }
    if(KFPOwner.IsHeadless())
    {
        return false;
    }
    return super(KFSpecialMove).InternalCanDoSpecialMove();
}

function bool CanOverrideMoveWith(name NewMove)
{
    if(KFPOwner.SpecialMoveFlags == 0)
    {
        if((NewMove == 'KFSM_Stunned') || NewMove == 'KFSM_Stumble')
        {
            return true;
        }
    }
    return false;
}

static function byte PackFlagsBase(KFPawn P)
{
    return 0;
}

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    super(KFSpecialMove).SpecialMoveStarted(bForced, PrevMove);
    Follower = none;
    bAlignFollowerLookSameDirAsMe = default.bAlignFollowerLookSameDirAsMe;
    bAlignPawns = default.bAlignPawns;
    bAlignFollowerRotation = default.bAlignFollowerRotation;
    bPendingStopFire = false;
    PlayGrabAnim();
}

function PlayGrabAnim()
{
    GrabCheckTime = KFSkeletalMeshComponent(PawnOwner.Mesh).GetAnimInterruptTime(GrabStartAnimName);
    if(PawnOwner.Role == ROLE_Authority)
    {
        if(GrabCheckTime <= float(0))
        {
            WarnInternal((((("Failed to play" @ string(GrabStartAnimName)) @ "on special move") @ string(self)) @ "on Pawn") @ string(PawnOwner));
            PawnOwner.SetTimer(0.25, false, 'AbortSpecialMove', self);
            return;
        }
        PawnOwner.SetTimer(GrabCheckTime, false, 'CheckGrapple', self);
    }
    PlaySpecialMoveAnim(GrabStartAnimName, 0);
    if(bUseRootMotion)
    {
        KFPOwner.BodyStanceNodes[0].SetRootBoneAxisOption(2, 2, 2);
        KFPOwner.Mesh.RootMotionMode = 3;
    }
}

function CheckGrapple()
{
    local Vector ToEnemy, Extent, HitLocation, HitNormal;
    local Actor HitActor;
    local KFPawn Victim;

    if(KFPOwner.IsHumanControlled())
    {
        Victim = KFPawn(FindPlayerGrabTarget());        
    }
    else
    {
        if(AIOwner != none)
        {
            Victim = KFPawn(AIOwner.Enemy);
        }
    }
    if(((Victim != none) && Victim.IsAliveAndWell()) && Victim.GetTeamNum() != KFPOwner.GetTeamNum())
    {
        if(((Victim != none) && (bCanBeBlocked && Victim.MyKFWeapon != none) && Victim.MyKFWeapon.IsGrappleBlocked(PawnOwner)) || !Victim.CanBeGrabbed(KFPOwner, true))
        {
            return;
        }
        if(Abs(PawnOwner.Location.Z - Victim.Location.Z) > MaxVictimZOffset)
        {
            return;
        }
        ToEnemy = PawnOwner.Location - Victim.Location;
        if(VSizeSq(ToEnemy) > Square(MaxGrabDistance))
        {
            return;
        }
        if(!KFPOwner.IsHumanControlled())
        {
            Extent.X = PawnOwner.GetCollisionRadius() * 0.5;
            Extent.Y = Extent.X;
            Extent.Z = PawnOwner.GetCollisionHeight() * 0.5;
            HitActor = PawnOwner.Trace(HitLocation, HitNormal, Victim.Location, PawnOwner.Location, true, Extent);
            if((HitActor != none) && HitActor != Victim)
            {
                return;
            }
        }
        BeginGrapple(Victim);
        PlayGrappleLoopAnim();
    }
}

function Pawn FindPlayerGrabTarget()
{
    local KFPawn_Monster KFPM;
    local Vector StartLoc, EndLoc;

    KFPM = KFPawn_Monster(PawnOwner);
    if(KFPM != none)
    {
        StartLoc = PawnOwner.Location;
        EndLoc = StartLoc + (Normal(vector(PawnOwner.Rotation)) * MaxGrabDistance);
        return KFPM.MeleeAttackHelper.FindVictimByFOV(StartLoc, EndLoc, MaxGrabDistance);
    }
}

function bool CanInteractWithPawn(KFPawn OtherPawn)
{
    return (((OtherPawn.IsAliveAndWell() && !KFPOwner.IsSameTeam(OtherPawn)) && OtherPawn.Physics != 2) && !OtherPawn.IsDoingSpecialMove()) && super.CanInteractWithPawn(OtherPawn);
}

function BeginGrapple(optional KFPawn Victim)
{
    if(PawnOwner.Role == ROLE_Authority)
    {
        bAlignPawns = default.bAlignPawns;
        KFPOwner.InteractionPawn = Victim;
        KFPOwner.ReplicatedSpecialMove.InteractionPawn = Victim;
        KFPOwner.SpecialMoveFlags = 1;
        KFPOwner.ReplicatedSpecialMove.Flags = KFPOwner.SpecialMoveFlags;
    }
    if(PawnOwner.IsHumanControlled() && PawnOwner.IsLocallyControlled())
    {
        PawnOwner.SetTimer(MinPlayerGrabTime, false, 'CheckIfPlayerReleasedGrapple', self);
    }
    if(bUseRootMotion && PawnOwner.Mesh.RootMotionMode == 3)
    {
        PawnOwner.Mesh.RootMotionMode = PawnOwner.Mesh.default.RootMotionMode;
        KFPOwner.BodyStanceNodes[0].SetRootBoneAxisOption(1, 1, 1);
    }
    PawnOwner.SetTimer(InteractionStartTimeOut, false, 'InteractionStartTimedOut', self);
    CheckReadyToStartInteraction();
}

function StartInteraction()
{
    local KFAIDirector AIDirector;

    super.StartInteraction();
    if((Follower != none) && KFPOwner != none)
    {
        if(KFWeapon(Follower.Weapon) != none)
        {
            KFWeapon(Follower.Weapon).ZedGrabGrenadeTossCooldown = Follower.WorldInfo.TimeSeconds + 0.35;
        }
        if((Follower.Controller != none) && KFPlayerController(Follower.Controller) != none)
        {
            KFPlayerController(Follower.Controller).ForceLookAtPawn = KFPOwner;
            KFPlayerController(Follower.Controller).bLockToForceLookAtPawn = true;
        }
        if(KFPOwner.MyKFAIC != none)
        {
            AIDirector = KFPOwner.MyKFAIC.MyAIDirector;
            if(KFAIController_Monster(KFPOwner.MyKFAIC) != none)
            {
                KFAIController_Monster(KFPOwner.MyKFAIC).bCompletedInitialGrabAttack = true;
            }            
        }
        else
        {
            if(KFPOwner.WorldInfo.Game != none)
            {
                AIDirector = KFGameInfo(KFPOwner.WorldInfo.Game).GetAIDirector();
                if(AIDirector != none)
                {
                    AIDirector.NotifyPawnGrabbed(Follower, KFPOwner);
                }
            }
        }
    }
}

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    if((KFPOwner != none) && KFPOwner.Role == ROLE_Authority)
    {
        if(KFPOwner.SpecialMoveFlags == 0)
        {
            KFPOwner.EndSpecialMove();            
        }
        else
        {
            PlayGrappleLoopAnim();
        }
    }
}

function SpecialMoveFlagsUpdated()
{
    if(KFPOwner.SpecialMoveFlags >= 1)
    {
        if(Follower == none)
        {
            BeginGrapple();
        }
        PlayGrappleLoopAnim();
    }
}

function PlayGrappleLoopAnim()
{
    local byte Variant;

    if((KFPOwner != none) && KFPOwner.Role == ROLE_Authority)
    {
        Variant = byte(Rand(default.GrappleAnims.Length));
        J0x52:

        if(Variant == LastVariant)
        {
            Variant = byte(Rand(default.GrappleAnims.Length));
            goto J0x52;
        }
        LastVariant = Variant;
        KFPOwner.SpecialMoveFlags = byte((Variant << 4) + 1);
        KFPOwner.ReplicatedSpecialMove.Flags = KFPOwner.SpecialMoveFlags;
    }
    PlaySpecialMoveAnim(GrappleAnims[KFPOwner.SpecialMoveFlags >> 4], 0);
}

function OnFollowerLeavingSpecialMove()
{
    KFPOwner.EndSpecialMove();
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    PawnOwner.ClearTimer('CheckGrapple', self);
    if(bUseRootMotion && PawnOwner.Mesh.RootMotionMode == 3)
    {
        PawnOwner.Mesh.RootMotionMode = PawnOwner.Mesh.default.RootMotionMode;
        KFPOwner.BodyStanceNodes[0].SetRootBoneAxisOption(1, 1, 1);
    }
    if(bStopFullBodyWhenMoveEnds)
    {
        KFPOwner.StopBodyAnim(0, 0.2);
    }
    super.SpecialMoveEnded(PrevMove, NextMove);
}

function NotifyOwnerTakeHit(class<KFDamageType> DamageType, Vector HitLoc, Vector HitDir, Controller InstigatedBy)
{
    if(((InstigatedBy != none) && KFPOwner != none) && InstigatedBy.GetTeamNum() == KFPOwner.GetTeamNum())
    {
        return;
    }
    if(!KFPOwner.IsHumanControlled())
    {
        KFPOwner.EndSpecialMove();
        if(KFPOwner.CanDoSpecialMove(4) && DamageType.default.StumblePower > float(0))
        {
            KFPOwner.DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(KFPOwner, HitDir));
        }
    }
}

function NotifyHitReactionInterrupt()
{
    local Vector HitDir;

    if(KFPOwner.SpecialMoveFlags == 0)
    {
        if(bCanBeInterrupted)
        {
            if(KFPOwner.CanDoSpecialMove(4))
            {
                HitDir = Normal(KFPOwner.HitFxInfo.EncodedHitDirection);
                KFPOwner.DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(KFPOwner, HitDir));
            }
        }
    }
}

function SpecialMoveButtonRetriggered()
{
    bPendingStopFire = false;
}

function SpecialMoveButtonReleased()
{
    bPendingStopFire = true;
    if((Follower == none) || KFPOwner.IsTimerActive('CheckIfPlayerReleasedGrapple', self))
    {
        return;
    }
    KFPOwner.EndSpecialMove();
    if((KFPOwner.Role < ROLE_Authority) && KFPOwner.IsLocallyControlled())
    {
        KFPOwner.ServerDoSpecialMove(0, true);
    }
}

function CheckIfPlayerReleasedGrapple()
{
    if(bPendingStopFire)
    {
        KFPOwner.EndSpecialMove();
        if((KFPOwner.Role < ROLE_Authority) && KFPOwner.IsLocallyControlled())
        {
            KFPOwner.ServerDoSpecialMove(0, true);
        }
    }
}

defaultproperties
{
    GrappleAnims(0)=Grab_Attack_V1
    GrappleAnims(1)=Grab_Attack_V2
    GrappleAnims(2)=Grab_Attack_V3
    bStopFullBodyWhenMoveEnds=true
    bCanBeBlocked=true
    bCanBeInterrupted=true
    MaxGrabDistance=210
    MaxVictimZOffset=128
    GrabStartAnimName=Grab
    MinPlayerGrabTime=3
    FollowerSpecialMove=ESpecialMove.SM_GrappleVictim
    bAlignPawns=true
    bStopAlignFollowerRotationAtGoal=true
    AlignDistance=92
    AlignFollowerInterpSpeed=22
    bDisableMovement=true
    bServerOnlyPhysics=true
    Handle=SM_GrappleAttack
}