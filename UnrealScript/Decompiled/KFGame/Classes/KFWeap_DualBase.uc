/*******************************************************************************
 * KFWeap_DualBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_DualBase extends KFWeapon
    native
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const ReloadEmptyHalfAnim = 'Reload_Empty_Half';
const ReloadEmptyHalfEliteAnim = 'Reload_Empty_Half_Elite';

/** Animations to play when the weapon is fired */
var(Animations) const editconst name LeftFireAnim;
/** Animation to play when the weapon is fired */
var(Animations) const editconst array<editconst name> LeftFireSightedAnims;
var KFMuzzleFlash LeftMuzzleFlash;
/** A reference to the left muzzle flash template */
var(Attachments) const KFMuzzleFlash LeftMuzzleFlashTemplate;
/** Holds an offest for spawning protectile effects for left weapon */
var() Vector LeftFireOffset;
var transient bool bFireFromRightWeapon;
var class<KFWeapon> SingleClass;
var AnimNodeBlendPerBone EmptyMagBlendNode_L;
var(Animations) const editconst name IdleToIronSightAnim;
var(Animations) const editconst name IronSightToIdleAnim;

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    EmptyMagBlendNode_L = AnimNodeBlendPerBone(SkelComp.FindAnimNode('EmptyMagBlend_L'));
}

simulated function AttachMuzzleFlash()
{
    super.AttachMuzzleFlash();
    if(MySkelMesh != none)
    {
        if(MuzzleFlashTemplate != none)
        {
            LeftMuzzleFlash = new (self) Class'KFMuzzleFlash' (LeftMuzzleFlashTemplate);
            LeftMuzzleFlash.AttachMuzzleFlash(MySkelMesh);
        }
    }
}

simulated function name GetReloadAnimName(bool bTacticalReload)
{
    if(AmmoCount[0] == 1)
    {
        return ((bTacticalReload) ? 'Reload_Empty_Half_Elite' : 'Reload_Empty_Half');        
    }
    else
    {
        return super.GetReloadAnimName(bTacticalReload);
    }
}

simulated function IncrementFlashCount()
{
    if(Instigator != none)
    {
        if((Instigator.FlashCount > 0) || bFireFromRightWeapon)
        {
            Instigator.FlashCount += 1;            
        }
        else
        {
            Instigator.FlashCount += 2;
        }
        Instigator.SetFiringMode(self, CurrentFireMode);
        Instigator.FlashCountUpdated(self, Instigator.FlashCount, false);
    }
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    if(bFireFromRightWeapon)
    {
        return super.GetWeaponFireAnim(FireModeNum);        
    }
    else
    {
        return GetLeftWeaponFireAnim(FireModeNum);
    }
}

simulated function name GetLeftWeaponFireAnim(byte FireModeNum)
{
    if(bUsingSights)
    {
        return LeftFireSightedAnims[Rand(LeftFireSightedAnims.Length)];        
    }
    else
    {
        return LeftFireAnim;
    }
}

simulated event Vector GetMuzzleLoc()
{
    if(bFireFromRightWeapon)
    {
        return super.GetMuzzleLoc();        
    }
    else
    {
        return GetLeftMuzzleLoc();
    }
}

simulated event Vector GetLeftMuzzleLoc()
{
    local Rotator ViewRotation;

    if(Instigator != none)
    {
        ViewRotation = Instigator.GetViewRotation();
        if(KFPlayerController(Instigator.Controller) != none)
        {
            ViewRotation += KFPlayerController(Instigator.Controller).WeaponBufferRotation;
        }
        if(bUsingSights)
        {
            return Instigator.GetWeaponStartTraceLocation() + (LeftFireOffset >> ViewRotation);            
        }
        else
        {
            return Instigator.GetPawnViewLocation() + (LeftFireOffset >> ViewRotation);
        }
    }
    return Location;
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if((MuzzleFlash == none) || LeftMuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(bFireFromRightWeapon)
    {
        if(MuzzleFlash != none)
        {
            MuzzleFlash.CauseMuzzleFlash(FireModeNum);
            if(MuzzleFlash.bAutoActivateShellEject)
            {
                MuzzleFlash.CauseShellEject();
            }
        }        
    }
    else
    {
        if(LeftMuzzleFlash != none)
        {
            LeftMuzzleFlash.CauseMuzzleFlash(FireModeNum);
            if(LeftMuzzleFlash.bAutoActivateShellEject)
            {
                LeftMuzzleFlash.CauseShellEject();
            }
        }
    }
}

simulated function DetachMuzzleFlash()
{
    super.DetachMuzzleFlash();
    if((MySkelMesh != none) && LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.DetachMuzzleFlash(MySkelMesh);
        LeftMuzzleFlash = none;
    }
}

simulated event SetFOV(float NewFOV)
{
    super.SetFOV(NewFOV);
    if(LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.SetFOV(NewFOV);
    }
}

simulated function StopFireEffects(byte FireModeNum)
{
    super.StopFireEffects(FireModeNum);
    if(LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.StopMuzzleFlash();
    }
}

simulated function byte GetCurrentMuzzleID()
{
    return ((bFireFromRightWeapon) ? 0 : 1);
}

function SetupDroppedPickup(out DroppedPickup P, Vector StartVelocity)
{
    local KFWeapon NewSingle;

    super.SetupDroppedPickup(P, StartVelocity);
    if((Instigator != none) && Instigator.InvManager != none)
    {
        NewSingle = KFWeapon(Instigator.InvManager.CreateInventory(SingleClass, true));
    }
    if(NewSingle != none)
    {
        NewSingle.AmmoCount[0] = byte((((AmmoCount[0] & 1) == 0) ? AmmoCount[0] / 2 : (AmmoCount[0] / 2) + 1));
        AmmoCount[0] /= 2;
        NewSingle.SpareAmmoCount[0] = (((SpareAmmoCount[0] & 1) == 0) ? SpareAmmoCount[0] / 2 : (SpareAmmoCount[0] / 2) + 1);
        SpareAmmoCount[0] /= float(2);
        NewSingle.ClientForceAmmoUpdate(NewSingle.AmmoCount[0], NewSingle.SpareAmmoCount[0]);
        NewSingle.ClientForceSecondaryAmmoUpdate(NewSingle.AmmoCount[1]);
        Instigator.InvManager.SetCurrentWeapon(NewSingle);
    }
    P.InventoryClass = SingleClass;
}

simulated function ZoomOut(bool bAnimateTransition, float ZoomTimeToGo)
{
    ZoomTimeToGo = MySkelMesh.GetAnimLength(IronSightToIdleAnim);
    super.ZoomOut(bAnimateTransition, ZoomTimeToGo);
    if(bAnimateTransition)
    {
        PlayAnimation(IronSightToIdleAnim, ZoomTime, false);
    }
}

simulated function ANIMNOTIFY_LockBolt()
{
    UpdateOutOfAmmoEffects(0);
}

simulated function ANIMNOTIFY_UnLockBolt()
{
    super.ANIMNOTIFY_UnLockBolt();
    EmptyMagBlendNode_L.SetBlendTarget(0, 0);
}

simulated function UpdateOutOfAmmoEffects(float BlendTime)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EmptyMagBlendNode != none)
    {
        if(bAllowClientAmmoTracking && AmmoCount[0] <= 1)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
            if(AmmoCount[0] == 0)
            {
                EmptyMagBlendNode_L.SetBlendTarget(1, 0);
            }
        }
    }
}

static simulated function float CalculateTraderWeaponStatRange()
{
    return float(default.SingleClass.default.EffectiveRange);
}

simulated state Active
{
    simulated function ZoomIn(bool bAnimateTransition, float ZoomTimeToGo)
    {
        GotoState('ActiveIronSights');
    }
    stop;    
}

simulated state ActiveIronSights extends Active
{
    simulated function ZoomOut(bool bAnimateTransition, float ZoomTimeToGo)
    {
        ZoomTimeToGo = MySkelMesh.GetAnimLength(IronSightToIdleAnim);
        global.ZoomOut(true, ZoomTimeToGo);
        PlayAnimation(IronSightToIdleAnim, ZoomTime, false);
        GotoState('Active');
    }

    simulated function BeginState(name PreviousStateName)
    {
        local float ZoomTimeToGo;

        ZoomTimeToGo = MySkelMesh.GetAnimLength(IdleToIronSightAnim);
        global.ZoomIn(true, ZoomTimeToGo);
        PlayAnimation(IdleToIronSightAnim, ZoomTime, false);
    }
    stop;    
}

simulated state WeaponSingleFiring
{
    simulated function FireAmmunition()
    {
        bFireFromRightWeapon = !bFireFromRightWeapon;
        super.FireAmmunition();
    }
    stop;    
}

simulated state Reloading
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        bFireFromRightWeapon = false;
    }
    stop;    
}

defaultproperties
{
    LeftFireAnim=Shoot_LW
    LeftFireSightedAnims(0)=Shoot_Iron_LW
    IdleToIronSightAnim=Idle_To_Iron
    IronSightToIdleAnim=Iron_To_Idle
    bSkipZoomInRotation=true
    FireAnim=Shoot_RW
    FireSightedAnims(0)=Shoot_Iron_RW
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_DualBase.MeleeHelper'
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        AnimTreeTemplate=AnimTree'CHR_1P_Arms_ARCH.WEP_1stP_Dual_Animtree_Master'
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_DualBase.FirstPersonMesh'
    Mesh=FirstPersonMesh
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_DualBase.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_DualBase.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}