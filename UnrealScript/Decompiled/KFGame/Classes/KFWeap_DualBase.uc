/*******************************************************************************
 * KFWeap_DualBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_DualBase extends KFWeap_PistolBase
    native
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const ReloadOneEmptyAnim = 'Reload_Empty_Half';
const ReloadOneEmptyEliteAnim = 'Reload_Empty_Half_Elite';

/** Animations to play when the weapon is fired */
var(Animations) const editconst name LeftFireAnim;
/** Animation to play when the weapon is fired */
var(Animations) const editconst array<editconst name> LeftFireSightedAnims;
var KFMuzzleFlash LeftMuzzleFlash;
/** Holds an offest for spawning protectile effects for left weapon */
var() Vector LeftFireOffset;
var transient bool bFireFromRightWeapon;
var class<KFWeapon> SingleClass;
var AnimNodeBlendPerBone EmptyMagBlendNode_L;
var array<name> BonesToLockOnEmpty_L;
/** Anims for ironsight and alternate ironsight mode */
var(Animations) const editconst name IdleToIronSightAnim;
var(Animations) const editconst name IdleToIronSightAnim_Alt;
var(Animations) const editconst name IronSightToIdleAnim;
var(Animations) const editconst name IronSightToIdleAnim_Alt;
var(Animations) const editconst array<editconst name> IdleSightedAnims_Alt;
var(Animations) const editconst name FireSightedAnim_Alt;
var(Animations) const editconst name LeftFireSightedAnim_Alt;
var(Animations) const editconst name EquipAnimIS;
var(Animations) const editconst name EquipAnimISAlt;
var(Animations) const editconst name LeftFireLastAnim;
var(Animations) const editconst name LeftFireLastSightedAnim;
var(Animations) const editconst name FireLastSightedAnim_Alt;
var(Animations) const editconst name LeftFireLastSightedAnim_Alt;
var CylinderRotationInfo CylinderRotInfo_L;

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    local KFGameEngine KFGEngine;

    super.PostInitAnimTree(SkelComp);
    EmptyMagBlendNode_L = AnimNodeBlendPerBone(SkelComp.FindAnimNode('EmptyMagBlend_L'));
    if((EmptyMagBlendNode_L != none) && BonesToLockOnEmpty_L.Length > 0)
    {
        BuildEmptyMagNodeWeightList(EmptyMagBlendNode_L, BonesToLockOnEmpty_L);
    }
    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        bUseAltFireMode = KFGEngine.bUseAltAimOnDual;
    }
    if(!bRevolver)
    {
        return;
    }
    CylinderRotInfo_L.Control = SkelControlSingleBone(SkelComp.FindSkelControl('CylinderControl_L'));
    if(CylinderRotInfo_L.Control != none)
    {
        CylinderRotInfo_L.Control.SetSkelControlActive(true);
    }
}

simulated function AttachMuzzleFlash()
{
    super(KFWeapon).AttachMuzzleFlash();
    if(MySkelMesh != none)
    {
        if(MuzzleFlashTemplate != none)
        {
            LeftMuzzleFlash = new (self) Class'KFMuzzleFlash' (MuzzleFlashTemplate);
            LeftMuzzleFlash.AttachMuzzleFlash(MySkelMesh, 'MuzzleFlash_L', 'ShellEject_L');
        }
    }
}

simulated function name GetEquipAnimName()
{
    if(bIronSightOnBringUp)
    {
        return ((bUseAltFireMode) ? EquipAnimISAlt : EquipAnimIS);        
    }
    else
    {
        return EquipAnim;
    }
}

simulated function name GetIdleToIronAnim()
{
    return ((bUseAltFireMode) ? IdleToIronSightAnim_Alt : IdleToIronSightAnim);
}

simulated function name GetIronToIdleAnim()
{
    return ((bUseAltFireMode) ? IronSightToIdleAnim_Alt : IronSightToIdleAnim);
}

simulated function name GetReloadAnimName(bool bTacticalReload)
{
    if(AmmoCount[0] == 1)
    {
        return ((bTacticalReload) ? 'Reload_Empty_Half_Elite' : 'Reload_Empty_Half');        
    }
    else
    {
        return super(KFWeapon).GetReloadAnimName(bTacticalReload);
    }
}

simulated function IncrementFlashCount()
{
    if(Instigator != none)
    {
        if((Instigator.FlashCount > 0) || bFireFromRightWeapon)
        {
            Instigator.FlashCount += 1;            
        }
        else
        {
            Instigator.FlashCount += 2;
        }
        Instigator.SetFiringMode(self, CurrentFireMode);
        Instigator.FlashCountUpdated(self, Instigator.FlashCount, false);
    }
}

simulated function bool ShouldPlayFireLast(byte FireModeNum)
{
    if(bHasFireLastAnims)
    {
        if(bFireFromRightWeapon)
        {
            if(((!bAllowClientAmmoTracking && Role < ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] <= 2) || (bAllowClientAmmoTracking || Role == ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] == 1)
            {
                return true;
            }            
        }
        else
        {
            if(((!bAllowClientAmmoTracking && Role < ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] <= 1) || (bAllowClientAmmoTracking || Role == ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] == 0)
            {
                return true;
            }
        }
    }
    return false;
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    local bool bPlayFireLast;

    bPlayFireLast = ShouldPlayFireLast(FireModeNum);
    if(bFireFromRightWeapon)
    {
        if(bUsingSights)
        {
            if(bPlayFireLast)
            {
                return ((bUseAltFireMode) ? FireLastSightedAnim_Alt : FireLastSightedAnim);                
            }
            else
            {
                return ((bUseAltFireMode) ? FireSightedAnim_Alt : FireSightedAnims[Rand(LeftFireSightedAnims.Length)]);
            }            
        }
        else
        {
            if(bPlayFireLast)
            {
                return FireLastAnim;                
            }
            else
            {
                return FireAnim;
            }
        }        
    }
    else
    {
        return GetLeftWeaponFireAnim(FireModeNum, bPlayFireLast);
    }
}

simulated function name GetLeftWeaponFireAnim(byte FireModeNum, bool bPlayFireLast)
{
    if(bUsingSights)
    {
        if(bPlayFireLast)
        {
            return ((bUseAltFireMode) ? LeftFireLastSightedAnim_Alt : LeftFireLastSightedAnim);            
        }
        else
        {
            return ((bUseAltFireMode) ? LeftFireSightedAnim_Alt : LeftFireSightedAnims[Rand(LeftFireSightedAnims.Length)]);
        }        
    }
    else
    {
        if(bPlayFireLast)
        {
            return LeftFireLastAnim;            
        }
        else
        {
            return LeftFireAnim;
        }
    }
}

simulated event Vector GetMuzzleLoc()
{
    if(bFireFromRightWeapon)
    {
        return super(KFWeapon).GetMuzzleLoc();        
    }
    else
    {
        return GetLeftMuzzleLoc();
    }
}

simulated event Vector GetLeftMuzzleLoc()
{
    local Rotator ViewRotation;

    if(Instigator != none)
    {
        ViewRotation = Instigator.GetViewRotation();
        if(KFPlayerController(Instigator.Controller) != none)
        {
            ViewRotation += KFPlayerController(Instigator.Controller).WeaponBufferRotation;
        }
        if(bUsingSights)
        {
            return Instigator.GetWeaponStartTraceLocation() + (LeftFireOffset >> ViewRotation);            
        }
        else
        {
            return Instigator.GetPawnViewLocation() + (LeftFireOffset >> ViewRotation);
        }
    }
    return Location;
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if((MuzzleFlash == none) || LeftMuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(bFireFromRightWeapon)
    {
        if(MuzzleFlash != none)
        {
            MuzzleFlash.CauseMuzzleFlash(FireModeNum);
            if(MuzzleFlash.bAutoActivateShellEject)
            {
                MuzzleFlash.CauseShellEject();
            }
        }        
    }
    else
    {
        if(LeftMuzzleFlash != none)
        {
            LeftMuzzleFlash.CauseMuzzleFlash(FireModeNum);
            if(LeftMuzzleFlash.bAutoActivateShellEject)
            {
                LeftMuzzleFlash.CauseShellEject();
            }
        }
    }
}

simulated function DetachMuzzleFlash()
{
    super(KFWeapon).DetachMuzzleFlash();
    if((MySkelMesh != none) && LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.DetachMuzzleFlash(MySkelMesh);
        LeftMuzzleFlash = none;
    }
}

simulated event SetFOV(float NewFOV)
{
    super.SetFOV(NewFOV);
    if(LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.SetFOV(NewFOV);
    }
}

simulated function StopFireEffects(byte FireModeNum)
{
    super(KFWeapon).StopFireEffects(FireModeNum);
    if(LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.StopMuzzleFlash();
    }
}

simulated function byte GetCurrentMuzzleID()
{
    return ((bFireFromRightWeapon) ? 0 : 1);
}

function SetupDroppedPickup(out DroppedPickup P, Vector StartVelocity)
{
    local KFWeapon NewSingle;
    local KFInventoryManager KFIM;
    local Vector X, Y, Z;
    local int NewSingleUpgradeIndex, SingleSpareAmmoCount;

    NewSingleUpgradeIndex = CurrentWeaponUpgradeIndex;
    SetWeaponUpgradeLevel(0);
    super(KFWeapon).SetupDroppedPickup(P, StartVelocity);
    if((Instigator != none) && Instigator.InvManager != none)
    {
        KFIM = KFInventoryManager(Instigator.InvManager);
        KFIM.bSuppressPickupMessages = true;
        KFIM.bInfiniteWeight = true;
        NewSingle = KFWeapon(KFIM.CreateInventory(SingleClass, true));
        KFIM.bInfiniteWeight = false;
        KFIM.bSuppressPickupMessages = false;
    }
    if(NewSingle != none)
    {
        NewSingle.AmmoCount[0] = (((AmmoCount[0] & 1) == 0) ? AmmoCount[0] / 2 : (AmmoCount[0] / 2) + 1);
        AmmoCount[0] /= float(2);
        SingleSpareAmmoCount = Min(SpareAmmoCount[0], NewSingle.SpareAmmoCapacity[0]);
        NewSingle.SpareAmmoCount[0] = SingleSpareAmmoCount;
        SpareAmmoCount[0] -= SingleSpareAmmoCount;
        NewSingle.ClientForceAmmoUpdate(byte(NewSingle.AmmoCount[0]), NewSingle.SpareAmmoCount[0]);
        NewSingle.ClientForceSecondaryAmmoUpdate(byte(NewSingle.AmmoCount[1]));
        NewSingle.SetWeaponUpgradeLevel(NewSingleUpgradeIndex);
        if(NewSingleUpgradeIndex > 0)
        {
            KFInventoryManager(InvManager).AddCurrentCarryBlocks(NewSingle.GetUpgradeWeight(NewSingleUpgradeIndex));
            KFPawn(Instigator).NotifyInventoryWeightChanged();
        }
        NewSingle.bGivenAtStart = bGivenAtStart;
        if(Instigator.bPlayedDeath || Instigator.Health <= 0)
        {
            GetAxes(Instigator.Rotation, X, Y, Z);
            NewSingle.DropFrom(P.Location + (Y * float(20)), StartVelocity * (1 + (FRand() * 0.1)));            
        }
        else
        {
            Instigator.InvManager.SetCurrentWeapon(NewSingle);
        }
    }
    P.InventoryClass = SingleClass;
}

simulated function PerformReload(optional byte FireModeNum)
{
    super(KFWeapon).PerformReload(FireModeNum);
    if(!bRevolver)
    {
        return;
    }
    CylinderRotInfo_L.PrevDegrees = 0;
    CylinderRotInfo_L.NextDegrees = 0;
}

simulated function ANIMNOTIFY_LockBolt()
{
    UpdateOutOfAmmoEffects(0);
}

simulated function ANIMNOTIFY_UnLockBolt()
{
    super(KFWeapon).ANIMNOTIFY_UnLockBolt();
    EmptyMagBlendNode_L.SetBlendTarget(0, 0);
}

simulated function UpdateOutOfAmmoEffects(float BlendTime)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EmptyMagBlendNode != none)
    {
        if(bAllowClientAmmoTracking && AmmoCount[0] <= 1)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
            if(AmmoCount[0] == 0)
            {
                EmptyMagBlendNode_L.SetBlendTarget(1, 0);
            }
        }
    }
}

simulated event PostInitAnimTreeRevolver(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTreeRevolver(SkelComp);
    CylinderRotInfo_L.Control = SkelControlSingleBone(SkelComp.FindSkelControl('CylinderControl'));
    if(CylinderRotInfo_L.Control != none)
    {
        CylinderRotInfo_L.Control.SetSkelControlActive(true);
    }
}

simulated function ConsumeAmmoRevolver()
{
    if(bFireFromRightWeapon)
    {
        CheckCylinderRotation(CylinderRotInfo_L);
        CylinderRotInfo.State = 1;        
    }
    else
    {
        CheckCylinderRotation(CylinderRotInfo);
        CylinderRotInfo_L.State = 1;
    }
}

simulated function ANIMNOTIFY_RotateCylinder()
{
    if(bFireFromRightWeapon)
    {
        super.ANIMNOTIFY_RotateCylinder();
        return;
    }
    RotateCylinder(CylinderRotInfo_L);
}

simulated function InitializeReload()
{
    super(KFWeapon).InitializeReload();
    CheckCylinderRotation(CylinderRotInfo_L, true);
}

simulated function ANIMNOTIFY_ResetBulletMeshesLeft()
{
    ResetBulletMeshesLeft();
}

simulated function ResetCylinder()
{
    local int UsedStartIdx, UsedEndIdx, UsedBullets;

    SetCylinderRotation(CylinderRotInfo, 0);
    ResetCylinderInfo(CylinderRotInfo);
    if(AmmoCount[0] <= 1)
    {
        return;
    }
    UsedStartIdx = BulletMeshComponents.Length - 2;
    UsedBullets = FCeil(float(MagazineCapacity[0] - AmmoCount[0]) / 2);
    UsedEndIdx = UsedStartIdx - (UsedBullets * 2);
    RepositionUsedBullets(0, UsedStartIdx, UsedEndIdx);
}

simulated function ResetCylinderLeft()
{
    local int UsedStartIdx, UsedEndIdx, UsedBullets;

    SetCylinderRotation(CylinderRotInfo_L, 0);
    ResetCylinderInfo(CylinderRotInfo_L);
    if(AmmoCount[0] <= 0)
    {
        return;
    }
    UsedStartIdx = BulletMeshComponents.Length - 1;
    UsedBullets = FFloor(float(MagazineCapacity[0] - AmmoCount[0]) / 2);
    UsedEndIdx = UsedStartIdx - (UsedBullets * 2);
    RepositionUsedBullets(1, UsedStartIdx, UsedEndIdx);
}

simulated function RepositionUsedBullets(int FirstIndex, int UsedStartIdx, int UsedEndIdx)
{
    local int I;

    if(BulletMeshComponents.Length == 0)
    {
        return;
    }
    if((FirstIndex >= 0) && FirstIndex < BulletMeshComponents.Length)
    {
        BulletMeshComponents[FirstIndex].SetSkeletalMesh(UnusedBulletMeshTemplate);        
    }
    else
    {
        WarnInternal((((((string(self) @ "-") @ string(GetFuncName())) @ "- First Index is out of bounds - FirstIndex:") @ string(FirstIndex)) @ "BulletMeshComponents.Length:") @ string(BulletMeshComponents.Length));
    }
    I = UsedStartIdx;
    J0x107:

    if(I > UsedEndIdx)
    {
        if((I >= 0) && I < BulletMeshComponents.Length)
        {
            BulletMeshComponents[I].SetSkeletalMesh(UsedBulletMeshTemplate);
        }
        I -= 2;
        goto J0x107;
    }
    I = UsedEndIdx;
    J0x19D:

    if(I > FirstIndex)
    {
        if((I >= 0) && I < BulletMeshComponents.Length)
        {
            BulletMeshComponents[I].SetSkeletalMesh(UnusedBulletMeshTemplate);
        }
        I -= 2;
        goto J0x19D;
    }
}

simulated function ResetBulletMeshes()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < BulletMeshComponents.Length)
    {
        BulletMeshComponents[I].SetSkeletalMesh(UnusedBulletMeshTemplate);
        I += 2;
        goto J0x0B;
    }
}

simulated function ResetBulletMeshesLeft()
{
    local int I;

    I = 1;
    J0x0B:

    if(I < BulletMeshComponents.Length)
    {
        BulletMeshComponents[I].SetSkeletalMesh(UnusedBulletMeshTemplate);
        I += 2;
        goto J0x0B;
    }
}

// Export UKFWeap_DualBase::execAddAmmoToSingleOnSell(FFrame&, void* const)
native simulated function AddAmmoToSingleOnSell(KFInventoryManager KFIM, int DefaultSingleAmmo, int TraderItemIndex);

simulated function bool ShouldAutoReload(byte FireModeNum)
{
    return ShouldAutoReloadGunslinger(FireModeNum);
}

simulated function AltFireMode()
{
    super(KFWeapon).AltFireMode();
    PlayIdleAnim();
}

simulated function StartFire(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        AltFireMode();
        return;
    }
    super(KFWeapon).StartFire(FireModeNum);
}

simulated state Active
{
    simulated function ZoomIn(bool bAnimateTransition, float ZoomTimeToGo)
    {
        GotoState('ActiveIronSights');
    }

    simulated function PlayIdleAnim()
    {
        local int IdleIndex;

        if(Instigator.IsFirstPerson())
        {
            if(bUsingSights && IdleSightedAnims.Length > 0)
            {
                if(bUseAltFireMode)
                {
                    IdleIndex = Rand(IdleSightedAnims_Alt.Length);
                    PlayAnimation(IdleSightedAnims_Alt[IdleIndex], 0, true, 0.1);                    
                }
                else
                {
                    IdleIndex = Rand(IdleSightedAnims.Length);
                    PlayAnimation(IdleSightedAnims[IdleIndex], 0, true, 0.1);
                }                
            }
            else
            {
                if(IdleAnims.Length > 0)
                {
                    IdleIndex = Rand(IdleAnims.Length);
                    PlayAnimation(IdleAnims[IdleIndex], 0, true, 0.2);
                }
            }
            StartIdleFidgetTimer();
            ToggleAdditiveBobAnim(!bUsingSights);
        }
    }

    simulated function bool CanPlayIdleFidget(optional bool bOnReload)
    {
        if(AmmoCount[0] < 2)
        {
            return false;
        }
        return super.CanPlayIdleFidget(bOnReload);
    }
    stop;    
}

simulated state ActiveIronSights extends Active
{
    simulated function ZoomOut(bool bAnimateTransition, float ZoomTimeToGo)
    {
        local name IronToIdleAnimName;

        IronToIdleAnimName = GetIronToIdleAnim();
        ZoomTimeToGo = MySkelMesh.GetAnimLength(IronToIdleAnimName);
        global.ZoomOut(true, ZoomTimeToGo);
        PlayAnimation(IronToIdleAnimName, ZoomTime, false);
        GotoState('Active');
    }

    simulated function BeginState(name PreviousStateName)
    {
        local float ZoomTimeToGo;
        local name IdleToIronAnimName;

        IdleToIronAnimName = GetIdleToIronAnim();
        ZoomTimeToGo = MySkelMesh.GetAnimLength(IdleToIronAnimName);
        global.ZoomIn(true, ZoomTimeToGo);
        PlayAnimation(IdleToIronAnimName, ZoomTime, false);
    }
    stop;    
}

simulated state WeaponSingleFiring
{
    simulated function FireAmmunition()
    {
        bFireFromRightWeapon = !bFireFromRightWeapon;
        super.FireAmmunition();
    }
    stop;    
}

simulated state Reloading
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        bFireFromRightWeapon = false;
        if(bRevolver)
        {
            ResetCylinderLeft();
        }
    }

    simulated function byte GetWeaponStateId()
    {
        local KFPerk Perk;
        local bool bTacticalReload;

        Perk = GetPerk();
        bTacticalReload = (Perk != none) && Perk.GetUsingTactialReload(self);
        if(AmmoCount[0] == 1)
        {
            return byte(((bTacticalReload) ? 12 : 11));
        }
        return super.GetWeaponStateId();
    }
    stop;    
}

simulated state WeaponPuttingDown
{
    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        CheckCylinderRotation(CylinderRotInfo_L, true);
    }
    stop;    
}

defaultproperties
{
    LeftFireAnim=Shoot_LW
    LeftFireSightedAnims(0)=Shoot_IronOG_LW
    BonesToLockOnEmpty_L(0)=LW_Bolt
    IdleToIronSightAnim=Idle_To_IronOG
    IdleToIronSightAnim_Alt=Idle_To_Iron
    IronSightToIdleAnim=IronOG_To_Idle
    IronSightToIdleAnim_Alt=Iron_To_Idle
    IdleSightedAnims_Alt(0)=Idle_Iron
    FireSightedAnim_Alt=Shoot_Iron_RW
    LeftFireSightedAnim_Alt=Shoot_Iron_LW
    EquipAnimIS=Equip_IronOG
    EquipAnimISAlt=Equip_Iron
    LeftFireLastAnim=Shoot_LW_Last
    LeftFireLastSightedAnim=Shoot_IronOG_LW_Last
    FireLastSightedAnim_Alt=Shoot_Iron_RW_Last
    LeftFireLastSightedAnim_Alt=Shoot_Iron_LW_Last
    bSkipZoomInRotation=true
    FireModeIconPaths(0)=Texture2D'ui_firemodes_tex.UI_FireModeSelect_BulletSingle'
    FireModeIconPaths(1)=Texture2D'ui_firemodes_tex.UI_FireModeSelect_BulletSingle'
    InventoryGroup=EInventoryGroup.IG_Primary
    FireAnim=Shoot_RW
    FireLastAnim=Shoot_RW_Last
    FireSightedAnims(0)=Shoot_IronOG_RW
    FireLastSightedAnim=Shoot_IronOG_RW_Last
    IdleSightedAnims(0)=Idle_IronOG
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_DualBase.MeleeHelper'
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        AnimTreeTemplate=AnimTree'CHR_1P_Arms_ARCH.WEP_1stP_Dual_Animtree_Master'
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_DualBase.FirstPersonMesh'
    Mesh=FirstPersonMesh
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_DualBase.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_DualBase.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}