/*******************************************************************************
 * KFObjective generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFObjective extends ReplicationInfo
    abstract
    native
    nativereplication
    config(Game)
    hidecategories(Navigation,Movement,Collision);

enum EObjectiveState
{
    OS_None,
    OS_Alert,
    OS_PreStart,
    OS_Active,
    OS_Won,
    OS_Failed,
    OS_MAX
};

enum EObjFailIndex
{
    OF_TimeLimit,
    OF_WipedOut,
    OF_TargetDied,
    OF_WaveEnded,
    OF_Ended,
    OF_NoDoshReceivers,
    OF_NeededPlayers,
    OF_MAX
};

var KFObjectiveVolume StartVolume;
var repnotify byte ObjectiveState;
var repnotify byte ObjectiveFailReason;
var repnotify byte ObjectiveDifficulty;
var byte ObjectiveProgress;
var repnotify int TimeLimit;
var float SpawnCurveIntensity;
var int DoshReward;
var int PerkReward;
var const localized string ObjectiveDifficulties[3];
var const localized string ObjectiveFailReasons[7];
var const localized string ObjectiveStartTitle;
var const localized string ObjectiveWaitingString;
var const localized string ObjectiveWonString;
var const localized string ObjectiveFailedString;
var const localized string ObjectiveEndedString;
var const localized string ObjectiveTimeString;
var const localized string ObjectiveTypeString;
var const localized string ObjectiveTargetTitle;
var const localized string ObjectiveStatusTitle;
var const localized string ObjectiveXPString;
var const localized string ObjectiveTimeLimitString;
var const localized string ObjectiveTimeUnit;
var const localized string ObjectiveStatusString;
var float RealObjectiveProgress;
/** Duration the alert is shown */
var() float ObjectiveAlertDelay;
/** Time between the objective alert and the time it actually starts */
var() float ObjectiveStartDelay;
var protected float ObjectiveStartTime;
var protected float ObjectiveEndTime;
var KFGameReplicationInfo MyKFGRI;
var array<PlayerReplicationInfo> ActiveObjectivePlayers;
var float CurPlayerCount;
var bool bIsCoopObjective;
var bool bHasAccepted;
var bool bObjectiveDenied;
var bool bNoLocalObjective;
var config bool bShowObjectivePath;
var config bool bLogObjective;
var float NumPlayersDenied;
var AkEvent ObjectiveTriggeredSFX;
var AkEvent ObjectiveCompletedSFX;
var AkEvent ObjectiveFailedSFX;
var AkEvent ObjectiveCrossOffSFX;
var Texture2D ObjSquareTex;
var Texture2D ObjRectangleTex;
var Texture2D ObjWorldTex;
var Texture2D ObjAlertTex;
var Texture2D ObjAlertAlphaTex;
var Texture2D ObjWhiteTex;
var Texture2D DoshTex;
var int CurAlpha;
var int AlphaDelta;
var Font ObjectiveFont;

replication
{
     if(bNetInitial)
        DoshReward, ObjectiveDifficulty, 
        PerkReward, StartVolume, 
        TimeLimit;

     if(bNetDirty)
        ObjectiveFailReason, ObjectiveProgress, 
        ObjectiveState;
}

simulated event ReplicatedEvent(name VarName)
{
    if(bLogObjective)
    {
        LogInternal((("[OBJECTIVE]" @ string(GetFuncName())) @ "Replicated variable:") @ string(VarName));
    }
    if(VarName == 'TimeLimit')
    {
        Initialize();        
    }
    else
    {
        super(Actor).ReplicatedEvent(VarName);
    }
}

simulated event Initialize()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    InitializeTimer();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
        {
            KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayObjectiveDialog(GetALocalPlayerController(), GetTraderDialogStartIndex());
        }
    }
}

function NotifySpawnManager(bool bUpdateSpawnCurveIntensity)
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && KFGI.SpawnManager != none)
    {
        if(bUpdateSpawnCurveIntensity)
        {
            if(bLogObjective)
            {
                LogInternal(("[OBJECTIVE]" @ string(GetFuncName())) @ "Setting SpawnCurve intensity!");
            }
            KFGI.SpawnManager.UpdateSpawnCurveIntensity(SpawnCurveIntensity);            
        }
        else
        {
            if(bLogObjective)
            {
                LogInternal(("[OBJECTIVE]" @ string(GetFuncName())) @ "Resetting SpawnCurve intensity!");
            }
            KFGI.SpawnManager.ResetSpawnCurveIntensity();
        }
    }
}

simulated function NotifyGRI()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    if(WorldInfo.GRI != none)
    {
        MyKFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        MyKFGRI.CurrentObjective = self;
        CurPlayerCount = float(MyKFGRI.GetNumPlayersAlive());
    }
}

simulated function InitializeTimer()
{
    SetTimer(1, true, 'UpdateObjective');
}

function UpdateObjective()
{
    switch(ObjectiveState)
    {
        case 0:
            break;
        case 1:
            UpdateObj_Alert();
            break;
        case 2:
            UpdateObj_Prestart();
            break;
        case 3:
            UpdateObj_Active();
            break;
        case 4:
            break;
        case 5:
            break;
        default:
            break;
    }
}

function UpdateObj_Alert();

function UpdateObj_Prestart()
{
    if(WorldInfo.TimeSeconds >= ObjectiveStartTime)
    {
        if((StartVolume != none) && (GetNumPlayersAccepted()) > 0)
        {
            if(bLogObjective)
            {
                LogInternal(("[OBJECTIVE]" @ string(GetFuncName())) @ "GetNumPlayersAccepted() > 0");
            }
            StartObjective();            
        }
        else
        {
            if(bLogObjective)
            {
                LogInternal(("[OBJECTIVE]" @ string(GetFuncName())) @ "Not enough players");
            }
            FailObjective(6);
        }        
    }
    else
    {
        if((StartVolume != none) && float(GetNumPlayersAccepted()) >= CurPlayerCount)
        {
            if(bLogObjective)
            {
                LogInternal(("[OBJECTIVE]" @ string(GetFuncName())) @ "GetNumPlayersAccepted() >= CurPlayerCount");
            }
            StartObjective();
        }
    }
}

function UpdateObj_Active()
{
    if(ObjectiveEndTime <= WorldInfo.TimeSeconds)
    {
        if(ObjectiveComplete())
        {
            WinObjective();            
        }
        else
        {
            FailObjective(0);
        }        
    }
    else
    {
        if(ObjectiveComplete())
        {
            WinObjective();
        }
    }
}

function bool ObjectiveComplete()
{
    return false;
}

simulated function AlertObjective();

simulated function PreStartObjective()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        DoObjPreStartNotify();
    }
}

simulated function StartObjective()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    if(Role == ROLE_Authority)
    {
        ObjectiveState = 3;
    }
    ObjectiveEndTime = WorldInfo.TimeSeconds + float(TimeLimit);
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        DoObjStartNotify();
    }
}

simulated function FailObjective(KFObjective.EObjFailIndex FailReason)
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    ObjectiveFailReason = FailReason;
    ObjectiveState = 5;
    DoObjFailNotify();
    HideObj();
    SetTimer(4, false, 'EndObjective');
}

function WinObjective()
{
    ObjectiveState = 4;
    DoObjWinNotify();
    HideObj();
    SetTimer(4, false, 'EndObjective');
}

simulated function AcceptObj()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    bHasAccepted = true;
}

simulated function HideObj()
{
    StartVolume.Hide();
}

simulated function EndObjective()
{
    ObjectiveState = 0;
    ClearTimer('UpdateObjective');
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        HideObjHUD();
    }
    ResetObjectivePlayers();
    MyKFGRI.CurrentObjective = none;
    Destroy();
}

simulated function bool ShouldShowObjPath()
{
    return ((ObjectiveState < 3) && bShowObjectivePath) && !bIsCoopObjective;
}

function AddObjectivePlayer(PlayerReplicationInfo PRI)
{
    ActiveObjectivePlayers.AddItem(PRI;
    if(ActiveObjectivePlayers.Length >= MyKFGRI.GetNumPlayersAlive())
    {
        StartObjective();
    }
}

function ResetObjectivePlayers()
{
    local KFPawn_Human KFPH;

    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    foreach WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
    {
        KFPH.bObjectivePlayer = false;        
    }    
    ActiveObjectivePlayers.Remove(0, ActiveObjectivePlayers.Length;
}

function bool IsObjectivePlayer(KFPlayerReplicationInfo KFPRI)
{
    return ActiveObjectivePlayers.Find(KFPRI > -1;
}

function int GetNumPlayersAccepted()
{
    return ActiveObjectivePlayers.Length;
}

simulated function DoObjAlertNotify()
{
    if(bNoLocalObjective)
    {
        return;
    }
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    ShowObjAlert();
    PlayObjAlertSFX();
}

simulated function DoObjPreStartNotify()
{
    local KFPlayerController KFPC;

    if(bNoLocalObjective)
    {
        return;
    }
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.PlayerReplicationInfo != none)
        {
            KFPC.PlaySoundBase(ObjectiveCrossOffSFX);
        }        
    }    
    if(bShowObjectivePath)
    {
        ShowObjPath();
    }
    ShowObjTracker();
}

simulated function DoObjStartNotify()
{
    if(bNoLocalObjective)
    {
        return;
    }
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    ShowObjStartMessage();
    ShowObjTracker();
}

simulated function DoObjFailNotify()
{
    if(bNoLocalObjective)
    {
        return;
    }
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    ShowObjFailMessage();
    PlayObjFailSFX();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
        {
            KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayObjectiveDialog(GetALocalPlayerController(), (GetTraderDialogStartIndex()) + 3);
        }
    }
}

simulated function DoObjWinNotify()
{
    if(bNoLocalObjective)
    {
        return;
    }
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    ShowObjWinMessage();
    PlayObjWinSFX();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
        {
            KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayObjectiveDialog(GetALocalPlayerController(), (GetTraderDialogStartIndex()) + 1);
        }
    }
}

simulated function ShowObjAlert();

simulated function ShowObjVoteMenu()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
}

simulated function ShowObjPath()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    StartVolume.ShowObjectivePath();
}

simulated function ShowObjStartMessage();

simulated function ShowObjTracker();

simulated function ShowObjWinMessage();

simulated function ShowObjFailMessage();

simulated function HideObjHUD();

simulated function PlayObjAlertSFX()
{
    local KFPlayerController KFPC;

    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.PlayerReplicationInfo != none)
        {
            KFPC.PlaySoundBase(ObjectiveTriggeredSFX);
        }        
    }    
}

simulated function PlayObjWinSFX()
{
    local KFPlayerController KFPC;

    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.PlayerReplicationInfo != none)
        {
            KFPC.PlaySoundBase(ObjectiveCompletedSFX);
        }        
    }    
}

simulated function PlayObjFailSFX()
{
    local KFPlayerController KFPC;

    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC.PlayerReplicationInfo != none)
        {
            KFPC.PlaySoundBase(ObjectiveFailedSFX);
        }        
    }    
}

function SetLowHealthPawn(KFPawn_Human LowHealthPawn);

function NewHealer(PlayerReplicationInfo Healer);

function PawnDied(Pawn KilledPawn);

function SetLowDoshPawns(array<KFPawn_Human> LowHealthPawns);

function int GetPayDayBonusDosh(int DoshSpend)
{
    return 0;
}

function CheckForPayDayPawn(Pawn P);

function bool InfiniteZedsEnabled()
{
    return false;
}

simulated function DrawObjectiveHUD(Canvas C);

simulated function DrawTrackerHUD(Canvas C);

simulated function DrawObjAlertHUD(Canvas C);

simulated function DrawObjPrestartHUD(Canvas C);

simulated function DrawObjEndHUD(Canvas C);

simulated function DrawObjectiveWorldPosition(Canvas C)
{
    local Vector ScreenPos;
    local string Distance;
    local KFPawn_Human MyKFPH;
    local KFPlayerController KFPC;
    local float Dim, StringSizeX, StringSizeY;

    CurAlpha += AlphaDelta;
    if((CurAlpha >= 255) || CurAlpha <= 0)
    {
        CurAlpha = ((CurAlpha >= 255) ? 255 : 0);
        AlphaDelta = -AlphaDelta;
    }
    Dim = 48;
    C.SetDrawColor(0, 230, 255, byte(CurAlpha));
    C.bCenter = false;
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        MyKFPH = KFPawn_Human(KFPC.Pawn);
        if(MyKFPH != none)
        {
            break;
        }        
    }    
    ScreenPos = C.Project(StartVolume.Location);
    if(ScreenPos.Z > float(0))
    {
        if(ScreenPos.X >= C.ClipX)
        {
            ScreenPos.X = C.ClipX - (Dim / float(2));            
        }
        else
        {
            if(ScreenPos.X <= float(0))
            {
                ScreenPos.X = Dim / float(2);
            }
        }
        if(ScreenPos.Y >= C.ClipY)
        {
            ScreenPos.Y = C.ClipY - (Dim / float(2));            
        }
        else
        {
            if(ScreenPos.Y <= float(0))
            {
                ScreenPos.Y = Dim / float(2);
            }
        }        
    }
    else
    {
        if(ScreenPos.X >= float(C.SizeX / 2))
        {
            ScreenPos.X = Dim / float(2);            
        }
        else
        {
            ScreenPos.X = C.ClipX - (Dim / float(2));
        }
        ScreenPos.Y = C.ClipY - (ScreenPos.Y % C.ClipY);
    }
    Distance = string(Round(VSize(StartVolume.Location - MyKFPH.Location) / float(100))) $ "m";
    C.StrLen(Distance, StringSizeX, StringSizeY);
    C.SetPos(ScreenPos.X - (Dim / float(2)), ScreenPos.Y - (Dim / float(2)));
    C.DrawTile(ObjWorldTex, Dim, Dim, 0, 0, 256, 256);
    C.SetPos(ScreenPos.X - (StringSizeX / float(2)), ScreenPos.Y + (Dim / float(2)));
    C.DrawText(Distance, false);
    C.Reset();
}

simulated function int GetTraderDialogStartIndex()
{
    return 49;
}

defaultproperties
{
    ObjectiveDifficulties[0]="EASY"
    ObjectiveDifficulties[1]="MEDIUM"
    ObjectiveDifficulties[2]="HARD"
    ObjectiveFailReasons[0]="TIME LIMIT EXHAUSTED!"
    ObjectiveFailReasons[1]="TEAM WIPED OUT"
    ObjectiveFailReasons[2]="LOW HEALTH PLAYER DIED"
    ObjectiveFailReasons[3]="WAVE ENDED"
    ObjectiveFailReasons[4]="OBJECTIVE ENDED"
    ObjectiveFailReasons[5]="NO LOW DOSH PLAYERS LEFT"
    ObjectiveFailReasons[6]="NOT ENOUGH PLAYERS!"
    ObjectiveStartTitle="Follow the trail to the start location"
    ObjectiveWaitingString="WAITING FOR MORE PLAYERS!"
    ObjectiveWonString="COMPLETE!"
    ObjectiveFailedString="FAILED!"
    ObjectiveEndedString="ENDED!"
    ObjectiveXPString="XP:"
    ObjectiveTimeLimitString="TIME LIMIT:"
    ObjectiveTimeUnit="s"
    ObjectiveStatusString="OBJECTIVE STATUS"
    ObjectiveAlertDelay=3
    ObjectiveStartDelay=60
    bShowObjectivePath=true
    ObjectiveTriggeredSFX=AkEvent'WW_UI_Objectives.Play_UI_NewObjective'
    ObjectiveCompletedSFX=AkEvent'WW_UI_Objectives.Play_UI_ObjectiveComplete'
    ObjectiveFailedSFX=AkEvent'WW_UI_Objectives.Play_UI_Objective_Fail'
    ObjectiveCrossOffSFX=AkEvent'WW_UI_Objectives.Play_UI_Objective_CrossOff'
    AlphaDelta=10
    ObjectiveFont=Font'UI_Canvas_Fonts.Font_General'
    TickGroup=ETickingGroup.TG_DuringAsyncWork
}