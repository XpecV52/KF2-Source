/*******************************************************************************
 * KFInventoryManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFInventoryManager extends InventoryManager
    native
    hidecategories(Navigation);

struct native TransactionItem
{
    var string DLOString;
    var name ClassName;
    var int AddedAmmo[2];

    structdefaultproperties
    {
        DLOString=""
        ClassName=None
        AddedAmmo[0]=0
        AddedAmmo[1]=0
    }
};

var transient Weapon PreviousEquippedWeapon;
var transient KFWeap_HealerBase HealerWeapon;
var byte GrenadeCount;
var byte CurrentCarryBlocks;
var byte MaxCarryBlocks;
var byte SelectedGroup;
var byte SelectedIndex;
var bool bInfiniteWeight;
var bool bServerTraderMenuOpen;
var bool bPendingFlashlight;
var bool bToggleFlashlightOnEquip;
var bool bAutoswitchWeapon;
/** Sound to play when we receive ammo from an already owned weapon */
var() AkEvent AmmoPickupSound;
/** Sound to play when a new weapon is picked up */
var() AkEvent ItemPickupSound;
/** Sound to play when we pick up armor */
var() AkEvent ArmorPickupSound;
var AkEvent SwitchFireModeEvent;
var float LastCreatedWeaponTime;
var array<GFxMoviePlayer> OpticsUIMovies;
var const float StartedWithWeaponPriceModifier;
var const float SellPriceModifier;
var array<TransactionItem> TransactionItems;

replication
{
     if(bNetDirty && bNetOwner)
        CurrentCarryBlocks, GrenadeCount, 
        MaxCarryBlocks;

     if((bNetDirty && bNetOwner) && bNetInitial)
        HealerWeapon;
}

// Export UKFInventoryManager::execAddWeaponToGroup(FFrame&, void* const)
native function bool AddWeaponToGroup(out KFWeapon AddedWeapon);

simulated function GFxMoviePlayer GetOpticsUIMovie(class<GFxMoviePlayer> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            return OpticsUIMovies[OpticsIndex];
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
    OpticsUIMovies.AddItem(new (self) OpticsClass;
    OpticsIndex = byte(OpticsUIMovies.Length - 1);
    OpticsUIMovies[OpticsIndex].Init();
    OpticsUIMovies[OpticsIndex].Start();
    return OpticsUIMovies[OpticsIndex];
}

simulated function RemoveOpticsUIMovie(class<KFGFxWorld_MedicOptics> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            OpticsUIMovies[OpticsIndex].Close();
            OpticsUIMovies.Remove(OpticsIndex, 1;
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
}

simulated function InitFOV(float SizeX, float SizeY, float DefaultPlayerFOV)
{
    local KFWeapon KFWP;

    if(InventoryChain == none)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFWP)
    {
        KFWP.InitFOV(SizeX, SizeY, DefaultPlayerFOV);        
    }    
}

simulated function bool AddInventory(Inventory NewItem, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    KFW = KFWeapon(NewItem);
    if(KFW != none)
    {
        if(Role == ROLE_Authority)
        {
            AddWeaponToGroup(KFW);
        }
        NewItem.SetOwner(Instigator);
        NewItem.Instigator = Instigator;
        NewItem.InvManager = self;
        NewItem.GivenTo(Instigator, bDoNotActivate);
        CombineWeaponsOnAdd(KFW);
        Instigator.TriggerEventClass(Class'SeqEvent_GetInventory', NewItem);
        return true;        
    }
    else
    {
        return super.AddInventory(NewItem, bDoNotActivate);
    }
}

simulated function Inventory CreateInventoryArchetype(Inventory NewInventoryTemplate, optional bool bDoNotActivate)
{
    local Inventory Inv;

    if(NewInventoryTemplate != none)
    {
        Inv = Spawn(NewInventoryTemplate.Class, Owner,,,, NewInventoryTemplate);
        if(Inv != none)
        {
            if(!AddInventory(Inv, bDoNotActivate))
            {
                WarnInternal("InventoryManager::CreateInventory - Couldn't Add newly created inventory" @ string(Inv));
                Inv.Destroy();
                Inv = none;
            }            
        }
        else
        {
            WarnInternal("InventoryManager::CreateInventory - Couldn't spawn inventory" @ string(NewInventoryTemplate));
        }
    }
    return Inv;
}

simulated function Inventory CreateInventory(class<Inventory> NewInventoryItemClass, optional bool bDoNotActivate)
{
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWeapClass;

    KFWeapClass = class<KFWeapon>(NewInventoryItemClass);
    if(KFWeapClass != none)
    {
        if(CanCarryWeapon(KFWeapClass))
        {
            KFWeap = KFWeapon(super.CreateInventory(NewInventoryItemClass, bDoNotActivate));
            UpdateHUD();
            if((WorldInfo.TimeSeconds - CreationTime) > float(1))
            {
                PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 11,,, KFWeap);
                if((WorldInfo.TimeSeconds - LastCreatedWeaponTime) > float(1))
                {
                    PlayGiveInventorySound(ItemPickupSound);
                    LastCreatedWeaponTime = WorldInfo.TimeSeconds;
                }
            }
            return KFWeap;            
        }
        else
        {
            PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 12);
            return none;
        }
    }
    return super.CreateInventory(NewInventoryItemClass, bDoNotActivate);
}

simulated function RemoveFromInventory(Inventory ItemToRemove)
{
    local Inventory Item;
    local bool bFound;

    if(ItemToRemove == none)
    {
        return;
    }
    if(PreviousEquippedWeapon == ItemToRemove)
    {
        PreviousEquippedWeapon = none;
    }
    if(PendingWeapon == ItemToRemove)
    {
        PendingWeapon = none;
    }
    if(Instigator.Weapon == ItemToRemove)
    {
        Instigator.Weapon = none;
    }
    if(InventoryChain == ItemToRemove)
    {
        bFound = true;
        InventoryChain = ItemToRemove.Inventory;        
    }
    else
    {
        Item = InventoryChain;
        J0x102:

        if(Item != none)
        {
            if(Item.Inventory == ItemToRemove)
            {
                bFound = true;
                Item.Inventory = ItemToRemove.Inventory;
                goto J0x1B4;
            }
            Item = Item.Inventory;
            goto J0x102;
        }
    }
    J0x1B4:

    if(bFound)
    {
        ItemToRemove.ItemRemovedFromInvManager();
        ItemToRemove.SetOwner(none);
        ItemToRemove.Inventory = none;
    }
    if((Instigator.Health > 0) && Instigator.Controller != none)
    {
        if((WorldInfo.NetMode == NM_DedicatedServer) || (WorldInfo.NetMode == NM_ListenServer) && !Instigator.IsLocallyControlled())
        {
            ClientRemoveFromInventory(ItemToRemove);            
        }
        else
        {
            if(Instigator.Weapon == none)
            {
                if((PendingWeapon != none) && PendingWeapon != ItemToRemove)
                {
                    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Removed current weapon while changing weapons, call ChangedWeapon", 'Inventory');
                    ChangedWeapon();                    
                }
                else
                {
                    if(Instigator.Controller != none)
                    {
                        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Calling SwitchToBestWeapon to make sure a weapon is brought up", 'Inventory');
                        Instigator.Controller.SwitchToBestWeapon(true);
                    }
                }
            }
        }
    }
}

reliable server final function ServerRemoveFromInventory(Inventory ItemToRemove)
{
    if(Role == ROLE_Authority)
    {
        RemoveFromInventory(ItemToRemove);
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogTraderTransactions(1403, Instigator.Controller, ItemToRemove.Class);
        }
        if(Class'KFGameInfo'.static.AllowBalanceLogging())
        {
            WorldInfo.LogGameBalance((((string('Sell') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(ItemToRemove.Class));
        }
    }
}

reliable client simulated function ClientRemoveFromInventory(Inventory ItemToRemove)
{
    RemoveFromInventory(ItemToRemove);
}

function bool ItemIsInInventory(Inventory Item)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv == Item)
        {
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

function bool ClassIsInInventory(class<Inventory> ItemClass)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv.Class == ItemClass)
        {
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

simulated function AutoSwitchLastWeapon()
{
    local Weapon CurrentWeapon;

    if(PreviousEquippedWeapon == none)
    {
        return;
    }
    CurrentWeapon = ((PendingWeapon != none) ? PendingWeapon : Instigator.Weapon);
    bAutoswitchWeapon = true;
    SetCurrentWeapon(PreviousEquippedWeapon);
    PreviousEquippedWeapon = CurrentWeapon;
    bPendingFlashlight = bToggleFlashlightOnEquip;
    bToggleFlashlightOnEquip = false;
    bAutoswitchWeapon = false;
}

simulated function SwitchToPrimaryFlashLightWeapon()
{
    local KFWeapon NewWeapon, PriorityWeapon, EmptyPriorityWeapon;
    local float HighestPriority;

    foreach InventoryActors(Class'KFWeapon', NewWeapon)
    {
        if(NewWeapon.bHasFlashlight)
        {
            bPendingFlashlight = true;
            if(NewWeapon.HasAnyAmmo())
            {
                PriorityWeapon = NewWeapon;
                break;                
            }
            else
            {
                if(NewWeapon.GroupPriority >= HighestPriority)
                {
                    EmptyPriorityWeapon = NewWeapon;
                }
            }
            HighestPriority = NewWeapon.GroupPriority;
        }        
    }    
    if(PriorityWeapon != none)
    {
        SetCurrentWeapon(PriorityWeapon);        
    }
    else
    {
        if(EmptyPriorityWeapon != none)
        {
            SetCurrentWeapon(EmptyPriorityWeapon);
        }
    }
}

simulated function ChangedWeapon()
{
    super.ChangedWeapon();
    if(bPendingFlashlight)
    {
        KFPawn_Human(Instigator).ToggleFlashlight();
        bPendingFlashlight = false;
    }
}

simulated function KFWeapon GetNextGroupedWeapon(byte GroupID, optional bool bGetFirstWeapon)
{
    local KFWeapon EquippedWeapon, NewWeapon;
    local bool bFoundCurrentWeapon;

    if(Instigator == none)
    {
        return none;
    }
    if(PendingWeapon != none)
    {
        EquippedWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        EquippedWeapon = KFWeapon(Instigator.Weapon);
    }
    if((EquippedWeapon == none) || EquippedWeapon.InventoryGroup != GroupID)
    {
        bGetFirstWeapon = true;
    }
    foreach InventoryActors(Class'KFWeapon', NewWeapon)
    {
        if(bGetFirstWeapon || bFoundCurrentWeapon)
        {
            if(GroupID == NewWeapon.InventoryGroup)
            {                
                return NewWeapon;
            }
        }
        if(EquippedWeapon == NewWeapon)
        {
            bFoundCurrentWeapon = true;
            continue;            
        }        
    }    
    if(!bGetFirstWeapon)
    {
        return GetNextGroupedWeapon(GroupID, true);
    }
    return none;
}

simulated function HighlightPrevWeapon()
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        CandidateWeapon = W;        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            CandidateWeapon = W;            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function HighlightNextWeapon()
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            CandidateWeapon = W;
            break;
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            CandidateWeapon = W;
            break;            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function HighlightWeapon(Weapon CandidateWeapon)
{
    SetPendingWeapon(CandidateWeapon);
    ShowAllHUDGroups();
    UpdateHUD();
}

reliable server function ServerSetCurrentWeapon(Weapon DesiredWeapon)
{
    if(!ItemIsInInventory(DesiredWeapon))
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ string(DesiredWeapon)) $ " is not in inventory!", 'Inventory');
        return;
    }
    super.ServerSetCurrentWeapon(DesiredWeapon);
}

reliable client simulated function SetCurrentWeapon(Weapon DesiredWeapon)
{
    local Weapon CurrentWeapon;
    local bool bCurrentWeaponUsingSights;
    local KFWeapon DesiredKFW;

    CurrentWeapon = Instigator.Weapon;
    if(KFWeapon(CurrentWeapon) != none)
    {
        bCurrentWeaponUsingSights = KFWeapon(CurrentWeapon).bUsingSights;
    }
    DesiredKFW = KFWeapon(DesiredWeapon);
    if((DesiredKFW != none) && (DesiredKFW != Instigator.Weapon) || Instigator.Weapon.IsInState('WeaponPuttingDown'))
    {
        if(DesiredKFW.bHasIronSights)
        {
            DesiredKFW.bIronSightOnBringUp = bCurrentWeaponUsingSights;
        }
        if(!bAutoswitchWeapon)
        {
        }
        PreviousEquippedWeapon = CurrentWeapon;
        super.SetCurrentWeapon(DesiredWeapon);
        UpdateHUD();
    }
}

simulated function ClientWeaponSet(Weapon NewWeapon, bool bOptionalSet, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    super.ClientWeaponSet(NewWeapon, bOptionalSet, bDoNotActivate);
    KFW = KFWeapon(NewWeapon);
    if(Role != ROLE_Authority)
    {
        AddWeaponToGroup(KFW);
        UpdateHUD();
    }
}

simulated event ShowOnlyHUDGroup(byte GroupIndex)
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        KFGFxHUD.WeaponSelectWidget.ShowOnlyHUDGroup(GroupIndex);
    }
}

simulated function ShowAllHUDGroups()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    if((Instigator != none) && Instigator.Controller != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
        if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
        {
            KFGFxHUD.WeaponSelectWidget.ShowAllHUDGroups();
        }
    }
}

simulated function UpdateHUD()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;
    local KFWeapon KFW, KFPendingWeapon;
    local byte WeaponIndex;

    WeaponIndex = 0;
    if(PendingWeapon != none)
    {
        KFPendingWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        KFPendingWeapon = KFWeapon(Instigator.Weapon);
    }
    if(KFPendingWeapon == none)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == KFPendingWeapon.InventoryGroup)
        {
            if(KFW == KFPendingWeapon)
            {
                break;
            }
            ++ WeaponIndex;
        }        
    }    
    if(KFPlayerController(Instigator.Controller) != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
    }
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        if(!bAutoswitchWeapon && !(KFPendingWeapon == HealerWeapon) && HealerWeapon.bQuickHealMode)
        {
            KFGFxHUD.WeaponSelectWidget.SetSelectedWeapon(KFPendingWeapon.InventoryGroup, WeaponIndex);
            KFGFxHUD.WeaponSelectWidget.RefreshWeaponSelect();
        }
    }
}

function SelectCurrentWeapon(byte GroupIndex, byte WeaponIndex)
{
    local KFWeapon KFW;
    local byte CurrentWeaponIndex;

    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == GroupIndex)
        {
            if(CurrentWeaponIndex == WeaponIndex)
            {
                break;
            }
            ++ CurrentWeaponIndex;
        }        
    }    
    if(KFW != none)
    {
        SetCurrentWeapon(KFW);
    }
}

simulated function AttemptQuickHeal()
{
    local KFWeap_HealerBase W;
    local KFWeapon InstigatorKFWeapon;

    if(Instigator.Health >= Instigator.HealthMax)
    {
        return;
    }
    if((KFWeap_HealerBase(Instigator.Weapon) != none) && !Instigator.Weapon.IsFiring())
    {
        Instigator.Weapon.StartFire(1);
        return;
    }
    InstigatorKFWeapon = KFWeapon(Instigator.Weapon);
    foreach InventoryActors(Class'KFWeap_HealerBase', W)
    {
        if((W != Instigator.Weapon) && W.HasAmmo(1))
        {
            bToggleFlashlightOnEquip = ((InstigatorKFWeapon != none) && InstigatorKFWeapon.FlashLight != none) && InstigatorKFWeapon.FlashLight.bEnabled;
            PreviousEquippedWeapon = Instigator.Weapon;
            W.bQuickHealMode = true;
            SetCurrentWeapon(W);
        }        
    }    
}

simulated function QuickWeld()
{
    local KFWeapon KFW;
    local KFInterface_Usable UsableTrigger;
    local KFDoorTrigger DoorTrigger;
    local KFPlayerController KFPC;

    if((Instigator == none) || Instigator.Owner == none)
    {
        return;
    }
    KFW = KFWeapon(Instigator.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return;
    }
    KFPC = KFPlayerController(Instigator.Owner);
    if(KFPC != none)
    {
        UsableTrigger = KFPC.GetCurrentUsableActor(Instigator);
        if(NotEqual_InterfaceInterface(UsableTrigger, (none)))
        {
            DoorTrigger = KFDoorTrigger(bool(UsableTrigger));
            if((DoorTrigger != none) && DoorTrigger.DoorActor != none)
            {
                if(DoorTrigger.DoorActor.bIsDoorOpen && !DoorTrigger.DoorActor.bIsDestroyed)
                {
                    KFPC.Use();
                }
                if((Instigator.Weapon == none) || !Instigator.Weapon.IsA('KFWeap_Welder'))
                {
                    foreach InventoryActors(Class'KFWeapon', KFW)
                    {
                        if(KFW.IsA('KFWeap_Welder'))
                        {
                            SetCurrentWeapon(KFW);
                            break;
                        }                        
                    }                    
                }
            }
        }
    }
}

function bool GiveInitialGrenadeCount()
{
    local byte OriginalGrenadeCount;

    OriginalGrenadeCount = GrenadeCount;
    if(KFPawn(Instigator) != none)
    {
        GrenadeCount = byte(KFPawn(Instigator).GetPerk().InitialGrenadeCount);
    }
    return GrenadeCount > OriginalGrenadeCount;
}

function AddGrenades(int AmountToAdd)
{
    if(KFPawn(Instigator) != none)
    {
        GrenadeCount = byte(Min(KFPawn(Instigator).GetPerk().MaxGrenadeCount, GrenadeCount + AmountToAdd));
    }
}

function bool ConsumeGrenades(optional int AmountToSubtract)
{
    local byte OriginalGrenadeCount;

    AmountToSubtract = 1;
    OriginalGrenadeCount = GrenadeCount;
    GrenadeCount = byte(Max(0, GrenadeCount - AmountToSubtract));
    return GrenadeCount < OriginalGrenadeCount;
}

simulated event bool HasGrenadeAmmo(optional int Amount)
{
    Amount = 1;
    if(Amount == 0)
    {
        Amount = 1;
    }
    return (GrenadeCount - Amount) >= 0;
}

simulated function ThrowMoney()
{
    ServerThrowMoney();
}

reliable server function ServerThrowMoney()
{
    local Inventory Inv;
    local KFGameReplicationInfo MyKFGRI;

    if(Instigator != none)
    {
        MyKFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        foreach InventoryActors(Class'Inventory', Inv)
        {
            if(Inv.DroppedPickupClass == Class'KFDroppedPickup_Cash')
            {
                if((MyKFGRI != none) && MyKFGRI.CurrentObjective != none)
                {
                    MyKFGRI.CurrentObjective.CheckForPayDayPawn(Instigator);
                }
                Instigator.TossInventory(Inv);                
                return;
            }            
        }        
    }
}

simulated function bool CanCarryWeapon(class<KFWeapon> WeaponClass)
{
    if(bServerTraderMenuOpen && IsTransactionWeapon(WeaponClass))
    {
        return false;
    }
    if((WeaponClass.default.DualClass != none) && ClassIsInInventory(WeaponClass))
    {
        if((((CurrentCarryBlocks - WeaponClass.default.InventorySize) + WeaponClass.default.DualClass.default.InventorySize) <= MaxCarryBlocks) || bInfiniteWeight)
        {
            return true;            
        }
        else
        {
            return false;
        }
    }
    if(((WeaponClass.default.InventorySize <= 0) || (CurrentCarryBlocks + WeaponClass.default.InventorySize) <= MaxCarryBlocks) || bInfiniteWeight)
    {
        return true;
    }
    return false;
}

simulated function bool IsTransactionWeapon(class<KFWeapon> WeaponClass)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == WeaponClass.Name)
        {
            return true;
        }
        -- I;
        goto J0x17;
    }
    return false;
}

simulated function RemoveItemFromTransaction(name ClassName)
{
    local int Idx;

    Idx = GetTransactionItemIndex(ClassName);
    if(Idx != -1)
    {
        TransactionItems.Remove(Idx, 1;
    }
}

function bool AddAmmoFromPickup(KFWeapon KFW, optional Inventory Pickup)
{
    if(GiveWeaponAmmo(KFW))
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 9,,, KFW.Class);
        PlayGiveInventorySound(AmmoPickupSound);
        return true;
    }
    return false;
}

function bool GiveWeaponAmmo(KFWeapon KFW)
{
    local bool bAddedAmmo;

    if(KFW.AddAmmo(Max(int(KFW.AmmoPickupScale[0] * float(KFW.MagazineCapacity[0])), 1)) > 0)
    {
        bAddedAmmo = true;
    }
    if(KFW.CanRefillSecondaryAmmo())
    {
        if(KFW.AddSecondaryAmmo(Max(int(KFW.AmmoPickupScale[1] * float(KFW.MagazineCapacity[1])), 1)) > 0)
        {
            bAddedAmmo = true;
        }
    }
    return bAddedAmmo;
}

function bool GiveWeaponsAmmo(bool bIncludeGrenades)
{
    local KFWeapon W;
    local bool bAddedAmmo;

    foreach InventoryActors(Class'KFWeapon', W)
    {
        if(!W.bInfiniteSpareAmmo && GiveWeaponAmmo(W))
        {
            bAddedAmmo = true;
        }        
    }    
    if(bIncludeGrenades)
    {
        AddGrenades(1);
    }
    PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 8);
    PlayGiveInventorySound(AmmoPickupSound);
    return bAddedAmmo;
}

function bool AddArmorFromPickup()
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(Instigator);
    if(KFPH.Armor != KFPH.GetMaxArmor())
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 6);
        PlayGiveInventorySound(ArmorPickupSound);
        KFPH.GiveMaxArmor();
        return true;        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 7);
        return false;
    }
}

function PlayGiveInventorySound(AkEvent SoundEvent)
{
    Instigator.PlaySoundBase(SoundEvent);
}

simulated function float GetEncumbranceSpeedMod()
{
    local float CarryPercent;

    CarryPercent = FMin(float(CurrentCarryBlocks) / float(MaxCarryBlocks), 1);
    return Lerp(1, 0.92, CarryPercent);
}

function CombineWeaponsOnAdd(KFWeapon AddedWeapon)
{
    local KFWeapon InvWeap;
    local KFWeap_DualBase AddedDual, NewDual;
    local int ExtraAmmo;
    local bool bEquipNewDual;

    AddedDual = KFWeap_DualBase(AddedWeapon);
    if(AddedDual != none)
    {
        foreach InventoryActors(Class'KFWeapon', InvWeap)
        {
            if(InvWeap.Class == AddedDual.SingleClass)
            {
                RemoveFromInventory(InvWeap);
                AddedDual.AmmoCount[0] += InvWeap.AmmoCount[0];
                ExtraAmmo = Max(AddedDual.AmmoCount[0] - AddedDual.default.MagazineCapacity[0], 0);
                AddedDual.AmmoCount[0] -= byte(ExtraAmmo);
                AddedDual.AmmoCount[1] += InvWeap.AmmoCount[1];
                AddedDual.SpareAmmoCount[0] += (InvWeap.SpareAmmoCount[0] + ExtraAmmo);
                AddedDual.SpareAmmoCount[0] = Min(AddedDual.SpareAmmoCount[0], AddedDual.default.MaxSpareAmmo[0]);
                AddedDual.ClientForceAmmoUpdate(AddedDual.AmmoCount[0], AddedDual.SpareAmmoCount[0]);
                AddedDual.ClientForceSecondaryAmmoUpdate(AddedDual.AmmoCount[1]);
                break;
            }            
        }                
    }
    else
    {
        if(AddedWeapon.DualClass != none)
        {
            foreach InventoryActors(Class'KFWeapon', InvWeap)
            {
                if((InvWeap != AddedWeapon) && InvWeap.Class == AddedWeapon.Class)
                {
                    bEquipNewDual = Instigator.Weapon == InvWeap;
                    RemoveFromInventory(InvWeap);
                    RemoveFromInventory(AddedWeapon);
                    NewDual = KFWeap_DualBase(CreateInventory(AddedWeapon.DualClass, true));
                    if(NewDual != none)
                    {
                        NewDual.AmmoCount[0] = byte(InvWeap.AmmoCount[0] + AddedWeapon.AmmoCount[0]);
                        ExtraAmmo = Max(NewDual.AmmoCount[0] - NewDual.default.MagazineCapacity[0], 0);
                        NewDual.AmmoCount[0] -= byte(ExtraAmmo);
                        NewDual.AmmoCount[1] = byte(InvWeap.AmmoCount[1] + AddedWeapon.AmmoCount[1]);
                        NewDual.SpareAmmoCount[0] = Min((InvWeap.SpareAmmoCount[0] + AddedWeapon.SpareAmmoCount[0]) + ExtraAmmo, NewDual.default.MaxSpareAmmo[0]);
                        NewDual.ClientForceAmmoUpdate(NewDual.AmmoCount[0], NewDual.SpareAmmoCount[0]);
                        NewDual.ClientForceSecondaryAmmoUpdate(NewDual.AmmoCount[1]);
                        if(bEquipNewDual)
                        {
                            SetCurrentWeapon(NewDual);
                        }
                    }
                    break;
                }                
            }            
        }
    }
}

reliable server function ServerCloseTraderMenu()
{
    local int I;
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWClass;

    bServerTraderMenuOpen = false;
    I = TransactionItems.Length - 1;
    J0x23:

    if(I >= 0)
    {
        KFWClass = class<KFWeapon>(DynamicLoadObject(TransactionItems[I].DLOString, Class'Class'));
        if(KFWClass != none)
        {
            CurrentCarryBlocks -= KFWClass.default.InventorySize;
            KFWeap = KFWeapon(CreateInventory(KFWClass));
            if(KFWeap != none)
            {
                KFWeap.AddAmmo(TransactionItems[I].AddedAmmo[0]);
                KFWeap.AddSecondaryAmmo(TransactionItems[I].AddedAmmo[1]);
            }
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogTraderTransactions(1400, Instigator.Controller, KFWClass);
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(KFWClass));
            }
        }
        TransactionItems.Remove(I, 1;
        -- I;
        goto J0x23;
    }
}

final simulated function BuyAmmo(int AmountPurchased, KFGFxMenu_Trader.EItemType ItemType, optional byte ListIndex, optional byte ItemIndex, optional bool bSecondaryAmmo)
{
    if(ItemType == 0)
    {
        ServerBuyAmmo(AmountPurchased, ListIndex, ItemIndex, bSecondaryAmmo);        
    }
    else
    {
        if(ItemType == 1)
        {
            ServerBuyArmor(AmountPurchased);            
        }
        else
        {
            if(ItemType == 3)
            {
                ServerBuyGrenade(AmountPurchased);
            }
        }
    }
}

private reliable server final function ServerBuyAmmo(int AmountPurchased, byte ListIndex, byte ItemIndex, bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local byte AmmoTypeIndex, TransactionIndex;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ListIndex, ItemIndex))
        {
            if(!ProcessAmmoDosh(WeaponItem, AmountPurchased, bSecondaryAmmo))
            {
                return;
            }
            GetWeaponFromClass(KFW, WeaponItem.ClassName);
            if(KFW != none)
            {
                if(bSecondaryAmmo)
                {
                    KFW.AddSecondaryAmmo(AmountPurchased);
                    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                    {
                        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogTraderTransactions(1401, Instigator.Controller, KFW.Class, AmountPurchased, bSecondaryAmmo);
                    }
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }                    
                }
                else
                {
                    KFW.AddAmmo(AmountPurchased);
                    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                    {
                        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogTraderTransactions(1401, Instigator.Controller, KFW.Class, AmountPurchased, bSecondaryAmmo);
                    }
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "S.Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }
                }                
            }
            else
            {
                ItemIndex = byte(GetTransactionItemIndex(WeaponItem.ClassName));
                if(ItemIndex != -1)
                {
                    TransactionIndex = byte(GetTransactionItemIndex(WeaponItem.ClassName));
                    if(TransactionIndex != -1)
                    {
                        AmmoTypeIndex = byte(bSecondaryAmmo);
                        TransactionItems[TransactionIndex].AddedAmmo[AmmoTypeIndex] += AmountPurchased;
                    }
                }
            }
        }
    }
}

private reliable server final function ServerBuyArmor(int PercentPurchased)
{
    local KFPawn_Human KFP;
    local int AmountPurchased;
    local float MaxArmor;

    KFP = KFPawn_Human(Instigator);
    if(((Role == ROLE_Authority) && KFP != none) && bServerTraderMenuOpen)
    {
        if(ProcessArmorDosh(PercentPurchased))
        {
            MaxArmor = float(KFP.GetMaxArmor());
            AmountPurchased = FCeil(MaxArmor * (float(PercentPurchased) / 100));
            KFP.AddArmor(AmountPurchased);
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogArmorPurchase(1402, Instigator.Controller, AmountPurchased);
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Armor,") @ string(PercentPurchased));
            }
        }
    }
}

private reliable server final function ServerBuyGrenade(int AmountPurchased)
{
    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(ProcessGrenadeDosh(AmountPurchased))
        {
            AddGrenades(AmountPurchased);
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogTraderTransactions(1400, Instigator.Controller, KFPlayerController(Instigator.Controller).GetPerk().GetGrenadeClass(), AmountPurchased);
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Grenades(s),") $ ",") @ string(AmountPurchased));
            }
        }
    }
}

reliable server final function ServerBuyWeapon(byte ListIndex, byte ItemIndex)
{
    local STraderItem PurchasedItem;
    local TransactionItem NewTransactionItem;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(PurchasedItem, ListIndex, ItemIndex))
        {
            if((CurrentCarryBlocks > (CurrentCarryBlocks + PurchasedItem.BlocksRequired)) || !ProcessWeaponDosh(PurchasedItem))
            {
                return;
            }
            NewTransactionItem.ClassName = PurchasedItem.ClassName;
            NewTransactionItem.DLOString = string(PurchasedItem.PathName);
            NewTransactionItem.AddedAmmo[0] = 0;
            NewTransactionItem.AddedAmmo[1] = 0;
            TransactionItems.AddItem(NewTransactionItem;
            CurrentCarryBlocks += PurchasedItem.BlocksRequired;
        }
    }
}

reliable server final function ServerSellWeapon(byte ListIndex, byte ItemIndex)
{
    local STraderItem SoldItem;
    local int SellPrice, TransactionIndex;
    local KFWeapon KFW;
    local KFPlayerReplicationInfo KFPRI;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
        if((KFPRI != none) && GetTraderItemFromWeaponLists(SoldItem, ListIndex, ItemIndex))
        {
            GetWeaponFromClass(KFW, SoldItem.ClassName);
            if(KFW != none)
            {
                SellPrice = GetAdjustedSellPriceFor(SoldItem, KFW);
                KFPRI.AddDosh(SellPrice);
                ServerRemoveFromInventory(KFW);                
            }
            else
            {
                TransactionIndex = GetTransactionItemIndex(SoldItem.ClassName);
                if(TransactionIndex != -1)
                {
                    SellPrice = GetAdjustedSellPriceFor(SoldItem);
                    KFPRI.AddDosh(SellPrice);
                    CurrentCarryBlocks -= SoldItem.BlocksRequired;
                    TransactionItems.Remove(TransactionIndex, 1;
                }
            }
        }
    }
}

final function int GetTransactionItemIndex(name ClassName)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            return I;
        }
        -- I;
        goto J0x17;
    }
    return -1;
}

final function GetWeaponFromClass(out KFWeapon KFW, name ClassName)
{
    local Inventory Item;

    Item = InventoryChain;
    J0x13:

    if(Item != none)
    {
        if(Item.Class.Name == ClassName)
        {
            KFW = KFWeapon(Item);
        }
        Item = Item.Inventory;
        goto J0x13;
    }
}

private final function bool ProcessWeaponDosh(out STraderItem PurchasedItem)
{
    local int BuyPrice;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        BuyPrice = GetAdjustedBuyPriceFor(PurchasedItem);
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to process " @ string(PurchasedItem.ClassName));
    return false;
}

private final function bool ProcessAmmoDosh(out STraderItem PurchasedItem, int AdditionalAmmo, optional bool bSecondaryAmmo)
{
    local int BuyPrice;
    local float PricePerMag, MagSize;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        if(bSecondaryAmmo)
        {
            PricePerMag = float(PurchasedItem.SecondaryAmmoMagPrice);
            MagSize = float(PurchasedItem.SecondaryAmmoMagSize);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));            
        }
        else
        {
            PricePerMag = float(PurchasedItem.AmmoPricePerMagazine);
            MagSize = float(PurchasedItem.MagazineCapacity);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));
        }
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal(("Server failed to process " @ string(PurchasedItem.ClassName)) @ "Ammo");
    return false;
}

private final function bool ProcessGrenadeDosh(int AmountPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo KFPRI;

    KFPC = KFPlayerController(Instigator.Owner);
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if((KFPC != none) && KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        BuyPrice = TraderItems.GetGrenadeByPerk(KFPC.CurrentPerk.Class).AmmoPricePerMagazine * AmountPurchased;
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy grenades");
    return false;
}

private final function bool ProcessArmorDosh(int PercentPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPerk CurrentPerk;
    local float ArmorPricePerPercent;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        ArmorPricePerPercent = float(TraderItems.ArmorItem.AmmoPricePerMagazine);
        KFPC = KFPlayerController(Instigator.Owner);
        if(KFPC != none)
        {
            CurrentPerk = KFPC.GetPerk();
            if(CurrentPerk != none)
            {
                ArmorPricePerPercent *= CurrentPerk.GetArmorDiscountMod();
            }
        }
        BuyPrice = FCeil(ArmorPricePerPercent * float(PercentPurchased));
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy armor");
    return false;
}

private final function bool GetTraderItemFromWeaponLists(out STraderItem TraderItem, byte ListIndex, byte ItemIndex)
{
    local KFGFxObject_TraderItems TraderItemsObject;

    TraderItemsObject = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
    if(ListIndex < TraderItemsObject.TraderItemList.Length)
    {
        TraderItem = TraderItemsObject.TraderItemList[ListIndex].ItemList[ItemIndex];
        return true;        
    }
    else
    {
        TraderItem = TraderItemsObject.OffPerkItems[ItemIndex];
        return true;
    }
    return false;
}

simulated function int GetAdjustedBuyPriceFor(const out STraderItem ShopItem)
{
    local int AdjustedBuyPrice;

    AdjustedBuyPrice = ShopItem.BuyPrice;
    if((ShopItem.SingleClassName != 'None') && GetIsOwned(ShopItem.SingleClassName))
    {
        AdjustedBuyPrice *= 0.5;
    }
    return AdjustedBuyPrice;
}

simulated function int GetAdjustedSellPriceFor(const out STraderItem OwnedItem, optional KFWeapon OwnedWeapon)
{
    local int AdjustedSellPrice;

    if((OwnedWeapon != none) && OwnedWeapon.bGivenAtStart)
    {
        AdjustedSellPrice = int(float(OwnedItem.BuyPrice) * StartedWithWeaponPriceModifier);        
    }
    else
    {
        AdjustedSellPrice = int(float(OwnedItem.BuyPrice) * SellPriceModifier);
    }
    if(OwnedItem.SingleClassName != 'None')
    {
        AdjustedSellPrice *= 0.5;
    }
    return AdjustedSellPrice;
}

simulated function bool GetIsOwned(name ClassName)
{
    local int I;
    local Inventory Inv;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Inv.Class.Name == ClassName)
        {            
            return true;
        }        
    }    
    I = 0;
    J0x70:

    if(I < TransactionItems.Length)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            return true;
        }
        ++ I;
        goto J0x70;
    }
    return false;
}

simulated event DiscardInventory()
{
    local Inventory Inv;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Instigator.Weapon != Inv)
        {
            Inv.bDropOnDeath = false;
        }        
    }    
    super.DiscardInventory();
}

defaultproperties
{
    MaxCarryBlocks=15
    AmmoPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Ammo'
    ItemPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Weapon'
    ArmorPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Armor'
    SwitchFireModeEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_ModeSwitch'
    StartedWithWeaponPriceModifier=0.5
    SellPriceModifier=0.75
    bMustHoldWeapon=true
    PendingFire=/* Array type was not detected. */
}