/*******************************************************************************
 * KFInventoryManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFInventoryManager extends InventoryManager
    native
    hidecategories(Navigation);

struct native TransactionItem
{
    var string DLOString;
    var name ClassName;
    var int AddedAmmo[2];

    structdefaultproperties
    {
        DLOString=""
        ClassName=None
        AddedAmmo[0]=0
        AddedAmmo[1]=0
    }
};

var transient Weapon PreviousEquippedWeapons[2];
var transient KFWeap_HealerBase HealerWeapon;
var const localized string FullHealthMsg;
var byte GrenadeCount;
var byte CurrentCarryBlocks;
var byte MaxCarryBlocks;
var byte SelectedGroup;
var byte SelectedIndex;
var bool bInfiniteWeight;
var bool bSuppressPickupMessages;
var bool bServerTraderMenuOpen;
var bool bAutoswitchWeapon;
var bool bLogInventory;
/** Sound to play when we receive ammo from an already owned weapon */
var() AkEvent AmmoPickupSound;
/** Sound to play when a new weapon is picked up */
var() AkEvent ItemPickupSound;
/** Sound to play when we pick up armor */
var() AkEvent ArmorPickupSound;
var AkEvent SwitchFireModeEvent;
var float LastCreatedWeaponTime;
var array<GFxMoviePlayer> OpticsUIMovies;
var const float StartedWithWeaponPriceModifier;
var const float SellPriceModifier;
var array<TransactionItem> TransactionItems;
var int SelectedGroupIndicies[4];

replication
{
     if(bNetDirty && bNetOwner)
        CurrentCarryBlocks, GrenadeCount, 
        MaxCarryBlocks;

     if((bNetDirty && bNetOwner) && bNetInitial)
        HealerWeapon;
}

// Export UKFInventoryManager::execAddWeaponToGroup(FFrame&, void* const)
native function bool AddWeaponToGroup(out KFWeapon AddedWeapon);

simulated function string DumpInventory()
{
    local Inventory InventoryItem;
    local KFWeapon Weapon;
    local string InventoryLabel;

    InventoryItem = InventoryChain;
    J0x13:

    if(InventoryItem != none)
    {
        Weapon = KFWeapon(InventoryItem);
        if(Weapon != none)
        {            
            InventoryLabel $= (((string(Weapon.Class.Name) $ ":") $ string(Weapon.GetTotalAmmoAmount(0))) $ ",");
        }
        InventoryItem = InventoryItem.Inventory;
        goto J0x13;
    }
    if(Len(InventoryLabel) > 0)
    {
        InventoryLabel = Left(InventoryLabel, Len(InventoryLabel) - 1);
    }
    return InventoryLabel;
}

simulated function float GetPrimaryAmmoPercentage()
{
    local Inventory InventoryItem;
    local KFWeapon Weapon;
    local float TotalAmmo, MaxAmmo;

    InventoryItem = InventoryChain;
    J0x13:

    if(InventoryItem != none)
    {
        Weapon = KFWeapon(InventoryItem);
        if((((Weapon != none) && !Weapon.bIsBackupWeapon) && Weapon.InventoryGroup != 4) && Weapon.InventoryGroup != 3)
        {
            if(Weapon.GetMaxAmmoAmount(0) == 0)
            {
                TotalAmmo += 1;
                MaxAmmo += 1;                
            }
            else
            {
                TotalAmmo += float(Weapon.GetTotalAmmoAmount(0));
                MaxAmmo += float(Weapon.GetMaxAmmoAmount(0));
            }
        }
        InventoryItem = InventoryItem.Inventory;
        goto J0x13;
    }
    if(MaxAmmo > float(0))
    {
        return TotalAmmo / MaxAmmo;        
    }
    else
    {
        return 0;
    }
}

simulated function GFxMoviePlayer GetOpticsUIMovie(class<GFxMoviePlayer> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            return OpticsUIMovies[OpticsIndex];
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
    OpticsUIMovies.AddItem(new (self) OpticsClass;
    OpticsIndex = byte(OpticsUIMovies.Length - 1);
    OpticsUIMovies[OpticsIndex].Init();
    OpticsUIMovies[OpticsIndex].Start();
    return OpticsUIMovies[OpticsIndex];
}

simulated function RemoveOpticsUIMovie(class<KFGFxWorld_MedicOptics> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            OpticsUIMovies[OpticsIndex].Close();
            OpticsUIMovies.Remove(OpticsIndex, 1;
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
}

simulated function InitFOV(float SizeX, float SizeY, float DefaultPlayerFOV)
{
    local KFWeapon KFWP;

    if(InventoryChain == none)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFWP)
    {
        KFWP.InitFOV(SizeX, SizeY, DefaultPlayerFOV);        
    }    
}

simulated function bool AddInventory(Inventory NewItem, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    KFW = KFWeapon(NewItem);
    if(KFW != none)
    {
        if(Role == ROLE_Authority)
        {
            AddWeaponToGroup(KFW);
        }
        NewItem.SetOwner(Instigator);
        NewItem.Instigator = Instigator;
        NewItem.InvManager = self;
        NewItem.GivenTo(Instigator, bDoNotActivate);
        Instigator.TriggerEventClass(Class'SeqEvent_GetInventory', NewItem);
        return true;        
    }
    else
    {
        return super.AddInventory(NewItem, bDoNotActivate);
    }
}

simulated function Inventory CreateInventoryArchetype(Inventory NewInventoryTemplate, optional bool bDoNotActivate)
{
    local Inventory Inv;

    if(NewInventoryTemplate != none)
    {
        Inv = Spawn(NewInventoryTemplate.Class, Owner,,,, NewInventoryTemplate);
        if(Inv != none)
        {
            if(!AddInventory(Inv, bDoNotActivate))
            {
                WarnInternal("InventoryManager::CreateInventory - Couldn't Add newly created inventory" @ string(Inv));
                Inv.Destroy();
                Inv = none;
            }            
        }
        else
        {
            WarnInternal("InventoryManager::CreateInventory - Couldn't spawn inventory" @ string(NewInventoryTemplate));
        }
    }
    return Inv;
}

simulated function Inventory CreateInventory(class<Inventory> NewInventoryItemClass, optional bool bDoNotActivate)
{
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWeapClass;

    if(bPendingDelete)
    {
        return none;
    }
    KFWeapClass = class<KFWeapon>(NewInventoryItemClass);
    if(KFWeapClass != none)
    {
        if(CanCarryWeapon(KFWeapClass))
        {
            KFWeap = KFWeapon(super.CreateInventory(NewInventoryItemClass, bDoNotActivate));
            UpdateHUD();
            if(!bSuppressPickupMessages && (WorldInfo.TimeSeconds - CreationTime) > float(1))
            {
                PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 17,,, KFWeap);
                if((WorldInfo.TimeSeconds - LastCreatedWeaponTime) > float(1))
                {
                    PlayGiveInventorySound(ItemPickupSound);
                    LastCreatedWeaponTime = WorldInfo.TimeSeconds;
                }
            }
            return KFWeap;            
        }
        else
        {
            if(!bSuppressPickupMessages)
            {
                PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 18);
            }
            return none;
        }
    }
    return super.CreateInventory(NewInventoryItemClass, bDoNotActivate);
}

simulated function RemoveFromInventory(Inventory ItemToRemove)
{
    local Inventory Item;
    local bool bFound;
    local KFPlayerController KFPC;

    if(ItemToRemove == none)
    {
        return;
    }
    if(PreviousEquippedWeapons[0] == ItemToRemove)
    {
        PreviousEquippedWeapons[0] = none;
    }
    if(PreviousEquippedWeapons[1] == ItemToRemove)
    {
        PreviousEquippedWeapons[1] = none;
    }
    if(PendingWeapon == ItemToRemove)
    {
        PendingWeapon = none;
    }
    if((Instigator != none) && Instigator.Weapon == ItemToRemove)
    {
        Instigator.Weapon = none;
    }
    if(InventoryChain == ItemToRemove)
    {
        bFound = true;
        InventoryChain = ItemToRemove.Inventory;        
    }
    else
    {
        Item = InventoryChain;
        J0x13D:

        if(Item != none)
        {
            if(Item.Inventory == ItemToRemove)
            {
                bFound = true;
                Item.Inventory = ItemToRemove.Inventory;
                goto J0x1EF;
            }
            Item = Item.Inventory;
            goto J0x13D;
        }
    }
    J0x1EF:

    if(bFound)
    {
        ItemToRemove.ItemRemovedFromInvManager();
        ItemToRemove.SetOwner(none);
        ItemToRemove.Inventory = none;
    }
    if(((Instigator != none) && Instigator.Health > 0) && Instigator.Controller != none)
    {
        if((WorldInfo.NetMode == NM_DedicatedServer) || (WorldInfo.NetMode == NM_ListenServer) && !Instigator.IsLocallyControlled())
        {
            ClientRemoveFromInventory(ItemToRemove);            
        }
        else
        {
            if(Instigator.Weapon == none)
            {
                if((PendingWeapon != none) && PendingWeapon != ItemToRemove)
                {
                    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Removed current weapon while changing weapons, call ChangedWeapon", 'Inventory');
                    if(Role < ROLE_Authority)
                    {
                        SetCurrentWeapon(PendingWeapon);                        
                    }
                    else
                    {
                        ChangedWeapon();
                    }                    
                }
                else
                {
                    if(Instigator.Controller != none)
                    {
                        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Calling SwitchToBestWeapon to make sure a weapon is brought up", 'Inventory');
                        Instigator.Controller.SwitchToBestWeapon(true);
                    }
                }
            }
        }
    }
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        KFPC = KFPlayerController(Instigator.Controller);
        if((((KFPC != none) && KFPC.MyGFxHUD != none) && KFPC.MyGFxHUD.WeaponSelectWidget != none) && KFPC.IsTimerActive('RefreshTimer', KFPC.MyGFxHUD.WeaponSelectWidget))
        {
            KFPC.MyGFxHUD.WeaponSelectWidget.RefreshTimer();
        }
    }
}

reliable server final function ServerRemoveFromInventory(Inventory ItemToRemove)
{
    if(Role == ROLE_Authority)
    {
        RemoveFromInventory(ItemToRemove);
        if(Class'KFGameInfo'.static.AllowBalanceLogging())
        {
            WorldInfo.LogGameBalance((((string('Sell') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(ItemToRemove.Class));
        }
        if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
        {
            WorldInfo.TWLogEvent("sell", Instigator.PlayerReplicationInfo, string(ItemToRemove.Class));
        }
    }
}

reliable client simulated function ClientRemoveFromInventory(Inventory ItemToRemove)
{
    RemoveFromInventory(ItemToRemove);
}

function bool ItemIsInInventory(Inventory Item)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv == Item)
        {
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

function bool ClassIsInInventory(class<Inventory> ItemClass)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv.Class == ItemClass)
        {
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

simulated function SwitchToLastWeapon()
{
    local Weapon CurrentWeapon, DesiredWeapon;

    CurrentWeapon = ((PendingWeapon != none) ? PendingWeapon : Instigator.Weapon);
    if((PreviousEquippedWeapons[0] != none) && PreviousEquippedWeapons[0] != CurrentWeapon)
    {
        DesiredWeapon = PreviousEquippedWeapons[0];        
    }
    else
    {
        if((PreviousEquippedWeapons[1] != none) && PreviousEquippedWeapons[1] != CurrentWeapon)
        {
            DesiredWeapon = PreviousEquippedWeapons[1];            
        }
        else
        {
            return;
        }
    }
    bAutoswitchWeapon = true;
    SetCurrentWeapon(DesiredWeapon);
    bAutoswitchWeapon = false;
}

simulated function KFWeapon GetBestPerkWeaponWithAmmo(class<KFPerk> PerkClass, optional bool bBackupIfEmpty)
{
    local KFWeapon PerkWeapon, NextWeapon, BackupWeapon;

    bBackupIfEmpty = false;
    if(InventoryChain == none)
    {
        return none;
    }
    foreach InventoryActors(Class'KFWeapon', NextWeapon)
    {
        if(((NextWeapon.GetWeaponPerkClass(PerkClass) == PerkClass) && NextWeapon.HasAmmo(0)) && !NextWeapon.IsMeleeWeapon())
        {
            PerkWeapon = NextWeapon;
            break;
            continue;
        }
        if((NextWeapon.bIsBackupWeapon && !NextWeapon.IsMeleeWeapon()) && NextWeapon.HasAmmo(0))
        {
            BackupWeapon = NextWeapon;
        }        
    }    
    return ((PerkWeapon != none) ? PerkWeapon : BackupWeapon);
}

simulated function KFWeapon GetNextGroupedWeapon(byte GroupID, optional bool bGetFirstWeapon, optional bool bGamePadWeaponSelectOpen)
{
    local KFWeapon EquippedWeapon, NewWeapon;
    local int WeaponIndex;

    WeaponIndex = 0;
    if(Instigator == none)
    {
        return none;
    }
    if(PendingWeapon != none)
    {
        EquippedWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        EquippedWeapon = KFWeapon(Instigator.Weapon);
    }
    if(((EquippedWeapon != none) && EquippedWeapon.InventoryGroup == GroupID) && !bGetFirstWeapon)
    {
        SelectedGroupIndicies[GroupID] += 1;
    }
    if(((EquippedWeapon == none) || EquippedWeapon.InventoryGroup != GroupID) && !bGamePadWeaponSelectOpen)
    {
        bGetFirstWeapon = true;
    }
    foreach InventoryActors(Class'KFWeapon', NewWeapon)
    {
        if(GroupID == NewWeapon.InventoryGroup)
        {
            if((SelectedGroupIndicies[GroupID] == WeaponIndex) || bGetFirstWeapon)
            {                
                return NewWeapon;
            }
            ++ WeaponIndex;
        }        
    }    
    if(!bGetFirstWeapon)
    {
        SelectedGroupIndicies[GroupID] = 0;
        return GetNextGroupedWeapon(GroupID, true, bGamePadWeaponSelectOpen);
    }
    return none;
}

simulated function HighlightPrevWeapon()
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        if(!ShouldSkipCycleWeapon(W, false))
        {
            CandidateWeapon = W;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function PrevWeapon()
{
    InternalPrevWeapon(false);
}

simulated function NextWeapon()
{
    InternalNextWeapon(false);
}

simulated function GamepadNextWeapon()
{
    InternalNextWeapon(true);
}

simulated function InternalPrevWeapon(bool bGamepad)
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        if(!ShouldSkipCycleWeapon(W, bGamepad))
        {
            CandidateWeapon = W;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
            }            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

simulated function InternalNextWeapon(bool bGamepad)
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
                break;
            }
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
                break;
            }            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

simulated function bool ShouldSkipCycleWeapon(Weapon CandidateWeapon, bool bGamepad)
{
    local KFWeapon KFW;

    KFW = KFWeapon(CandidateWeapon);
    if(KFW != none)
    {
        if(KFW.InventoryGroup == 4)
        {
            return true;
        }
        if(bGamepad)
        {
            if(KFW.InventoryGroup == 3)
            {
                return true;
            }
            if((KFW.InventoryGroup == 2) && KFW.bIsBackupWeapon)
            {
                return true;
            }
            if(!KFW.HasAnyAmmo())
            {
                return true;
            }
        }
    }
    return false;
}

simulated function HighlightNextWeapon()
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }
            break;
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }
            break;            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function HighlightWeapon(Weapon CandidateWeapon)
{
    SetPendingWeapon(CandidateWeapon);
    UpdateHUD();
}

reliable server function ServerSetCurrentWeapon(Weapon DesiredWeapon)
{
    if(!ItemIsInInventory(DesiredWeapon))
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ string(DesiredWeapon)) $ " is not in inventory!", 'Inventory');
        return;
    }
    super.ServerSetCurrentWeapon(DesiredWeapon);
}

reliable client simulated function SetCurrentWeapon(Weapon DesiredWeapon)
{
    local KFWeapon CurrentKFW;
    local bool bCurrentWeaponUsingSights;
    local KFWeapon DesiredKFW;

    CurrentKFW = KFWeapon(Instigator.Weapon);
    if(CurrentKFW != none)
    {
        bCurrentWeaponUsingSights = CurrentKFW.bUsingSights;
    }
    DesiredKFW = KFWeapon(DesiredWeapon);
    if((DesiredKFW != none) && (DesiredKFW != Instigator.Weapon) || Instigator.Weapon.IsInState('WeaponPuttingDown'))
    {
        if(DesiredKFW.bHasIronSights)
        {
            if(bCurrentWeaponUsingSights && !IsUsingIronsightHoldKey())
            {
                DesiredKFW.bIronSightOnBringUp = true;                
            }
            else
            {
                DesiredKFW.bIronSightOnBringUp = false;
            }
        }
        if(((CurrentKFW != none) && CurrentKFW.InventoryGroup < 3) && CurrentKFW != PreviousEquippedWeapons[0])
        {
            PreviousEquippedWeapons[1] = PreviousEquippedWeapons[0];
            PreviousEquippedWeapons[0] = CurrentKFW;
        }
        super.SetCurrentWeapon(DesiredWeapon);
        UpdateHUD();
    }
}

simulated function bool IsUsingIronsightHoldKey()
{
    local PlayerController PC;

    if(Instigator.IsLocallyControlled())
    {
        PC = PlayerController(Instigator.Controller);
        if((PC != none) && PC.PlayerInput != none)
        {
            if(KFPlayerInput(PC.PlayerInput).bIronsightsHeld)
            {
                return true;
            }
        }
    }
    return false;
}

simulated function ClientWeaponSet(Weapon NewWeapon, bool bOptionalSet, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    super.ClientWeaponSet(NewWeapon, bOptionalSet, bDoNotActivate);
    KFW = KFWeapon(NewWeapon);
    if(Role != ROLE_Authority)
    {
        AddWeaponToGroup(KFW);
        UpdateHUD();
    }
}

simulated event ShowOnlyHUDGroup(byte GroupIndex)
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        KFGFxHUD.WeaponSelectWidget.ShowOnlyHUDGroup(GroupIndex);
    }
}

simulated function ShowAllHUDGroups()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    if((Instigator != none) && Instigator.Controller != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
        if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
        {
            KFGFxHUD.WeaponSelectWidget.ShowAllHUDGroups();
        }
    }
}

simulated function UpdateHUD()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;
    local KFWeapon KFW, KFPendingWeapon;
    local byte WeaponIndex;

    WeaponIndex = 0;
    if(((PendingWeapon != none) && !PendingWeapon.bDeleteMe) && PendingWeapon.Instigator == Instigator)
    {
        KFPendingWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        KFPendingWeapon = KFWeapon(Instigator.Weapon);
    }
    if((KFPendingWeapon == none) || KFPendingWeapon.InventoryGroup == 4)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == KFPendingWeapon.InventoryGroup)
        {
            if(KFW == KFPendingWeapon)
            {
                break;
            }
            ++ WeaponIndex;
        }        
    }    
    if(KFPlayerController(Instigator.Controller) != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).MyGFxHUD;
    }
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        if(!bAutoswitchWeapon && !(KFPendingWeapon == HealerWeapon) && HealerWeapon.bQuickHealMode)
        {
            KFGFxHUD.WeaponSelectWidget.SetSelectedWeapon(KFPendingWeapon.InventoryGroup, WeaponIndex);
            KFGFxHUD.WeaponSelectWidget.RefreshWeaponSelect();
            SelectedGroupIndicies[KFPendingWeapon.InventoryGroup] = WeaponIndex;
        }
    }
}

function SelectCurrentWeapon(byte GroupIndex, byte WeaponIndex)
{
    local KFWeapon KFW;
    local byte CurrentWeaponIndex;

    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == GroupIndex)
        {
            if(CurrentWeaponIndex == WeaponIndex)
            {
                break;
            }
            ++ CurrentWeaponIndex;
        }        
    }    
    if(KFW != none)
    {
        SetCurrentWeapon(KFW);
    }
}

simulated function AttemptQuickHeal()
{
    local KFWeap_HealerBase W;
    local KFPlayerController KFPC;

    if(Instigator.Health >= Instigator.HealthMax)
    {
        KFPC = KFPlayerController(Instigator.Owner);
        if((KFPC != none) && KFPC.MyGFxHUD != none)
        {
            KFPC.MyGFxHUD.ShowNonCriticalMessage(FullHealthMsg);
        }
        return;
    }
    if((KFWeap_HealerBase(Instigator.Weapon) != none) && !Instigator.Weapon.IsFiring())
    {
        Instigator.Weapon.StartFire(1);
        return;
    }
    foreach InventoryActors(Class'KFWeap_HealerBase', W)
    {
        if((W != Instigator.Weapon) && W.HasAmmo(1))
        {
            W.bQuickHealMode = true;
            SetCurrentWeapon(W);
        }        
    }    
}

simulated function bool QuickWeld()
{
    local KFWeapon KFW;
    local KFInterface_Usable UsableTrigger;
    local KFDoorTrigger DoorTrigger;
    local KFPlayerController KFPC;

    if((Instigator == none) || Instigator.Owner == none)
    {
        return false;
    }
    KFW = KFWeapon(Instigator.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return false;
    }
    KFPC = KFPlayerController(Instigator.Owner);
    if(KFPC != none)
    {
        UsableTrigger = KFPC.GetCurrentUsableActor(Instigator);
        if(NotEqual_InterfaceInterface(UsableTrigger, (none)))
        {
            DoorTrigger = KFDoorTrigger(bool(UsableTrigger));
            if((DoorTrigger != none) && DoorTrigger.DoorActor != none)
            {
                if(DoorTrigger.DoorActor.bIsDoorOpen && !DoorTrigger.DoorActor.bIsDestroyed)
                {
                    KFPC.Use();
                }
                if((Instigator.Weapon != none) && Instigator.Weapon.IsA('KFWeap_Welder'))
                {
                    return true;
                }
                foreach InventoryActors(Class'KFWeapon', KFW)
                {
                    if(KFW.IsA('KFWeap_Welder'))
                    {
                        SetCurrentWeapon(KFW);
                        ShowAllHUDGroups();                        
                        return true;
                    }                    
                }                
            }
        }
    }
    return false;
}

function bool GiveInitialGrenadeCount()
{
    local byte OriginalGrenadeCount;

    OriginalGrenadeCount = GrenadeCount;
    if(KFPawn(Instigator) != none)
    {
        GrenadeCount = byte(KFPawn(Instigator).GetPerk().InitialGrenadeCount);
    }
    if(KFGameInfo(WorldInfo.Game) != none)
    {
        GrenadeCount = byte(KFGameInfo(WorldInfo.Game).AdjustStartingGrenadeCount(GrenadeCount));
    }
    return GrenadeCount > OriginalGrenadeCount;
}

function bool AddGrenades(int AmountToAdd)
{
    if(KFPawn(Instigator) != none)
    {
        if(GrenadeCount < KFPawn(Instigator).GetPerk().MaxGrenadeCount)
        {
            GrenadeCount = byte(Min(KFPawn(Instigator).GetPerk().MaxGrenadeCount, GrenadeCount + AmountToAdd));
            return true;
        }
    }
    return false;
}

function bool ConsumeGrenades(optional int AmountToSubtract)
{
    local byte OriginalGrenadeCount;

    AmountToSubtract = 1;
    OriginalGrenadeCount = GrenadeCount;
    GrenadeCount = byte(Max(0, GrenadeCount - AmountToSubtract));
    return GrenadeCount < OriginalGrenadeCount;
}

simulated event bool HasGrenadeAmmo(optional int Amount)
{
    Amount = 1;
    if(Amount == 0)
    {
        Amount = 1;
    }
    return (GrenadeCount - Amount) >= 0;
}

simulated function ThrowMoney()
{
    ServerThrowMoney();
}

reliable server function ServerThrowMoney()
{
    local Inventory Inv;
    local KFGameReplicationInfo MyKFGRI;

    if(Instigator != none)
    {
        MyKFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        foreach InventoryActors(Class'Inventory', Inv)
        {
            if(Inv.DroppedPickupClass == Class'KFDroppedPickup_Cash')
            {
                if((MyKFGRI != none) && MyKFGRI.CurrentObjective != none)
                {
                    MyKFGRI.CurrentObjective.CheckForPayDayPawn(Instigator);
                }
                Instigator.TossInventory(Inv);                
                return;
            }            
        }        
    }
}

simulated function bool CanCarryWeapon(class<KFWeapon> WeaponClass)
{
    local class<KFWeap_DualBase> DualWeaponClass;

    if(bServerTraderMenuOpen && IsTransactionWeapon(WeaponClass.Name))
    {
        return false;
    }
    if((WeaponClass.default.DualClass != none) && ClassIsInInventory(WeaponClass))
    {
        if((((CurrentCarryBlocks + WeaponClass.default.DualClass.default.InventorySize) - WeaponClass.default.InventorySize) <= MaxCarryBlocks) || bInfiniteWeight)
        {
            return true;            
        }
        else
        {
            return false;
        }
    }
    DualWeaponClass = class<KFWeap_DualBase>(WeaponClass);
    if(((DualWeaponClass != none) && DualWeaponClass.default.SingleClass != none) && ClassIsInInventory(DualWeaponClass.default.SingleClass))
    {
        if((((CurrentCarryBlocks + DualWeaponClass.default.InventorySize) - DualWeaponClass.default.SingleClass.default.InventorySize) <= MaxCarryBlocks) || bInfiniteWeight)
        {
            return true;            
        }
        else
        {
            return false;
        }
    }
    if(((WeaponClass.default.InventorySize <= 0) || (CurrentCarryBlocks + WeaponClass.default.InventorySize) <= MaxCarryBlocks) || bInfiniteWeight)
    {
        return true;
    }
    return false;
}

simulated function bool IsTransactionWeapon(name WeaponClassName)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == WeaponClassName)
        {
            return true;
        }
        -- I;
        goto J0x17;
    }
    return false;
}

function bool AddAmmoFromPickup(KFWeapon KFW, optional Inventory Pickup)
{
    if(GiveWeaponAmmo(KFW))
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 13,,, KFW.Class);
        PlayGiveInventorySound(AmmoPickupSound);
        return true;
    }
    return false;
}

function bool GiveWeaponAmmo(KFWeapon KFW)
{
    local bool bAddedAmmo;

    if(KFW.AddAmmo(Max(int(KFW.AmmoPickupScale[0] * float(KFW.MagazineCapacity[0])), 1)) > 0)
    {
        bAddedAmmo = true;
    }
    if(KFW.CanRefillSecondaryAmmo())
    {
        if(KFW.AddSecondaryAmmo(Max(int(KFW.AmmoPickupScale[1] * float(KFW.MagazineCapacity[1])), 1)) > 0)
        {
            bAddedAmmo = true;
        }
    }
    return bAddedAmmo;
}

function bool GiveWeaponsAmmo(bool bIncludeGrenades)
{
    local KFWeapon W;
    local bool bAddedAmmo;

    foreach InventoryActors(Class'KFWeapon', W)
    {
        if(!W.bInfiniteSpareAmmo && GiveWeaponAmmo(W))
        {
            bAddedAmmo = true;
        }        
    }    
    if(bIncludeGrenades)
    {
        if(AddGrenades(1))
        {
            bAddedAmmo = true;
        }
    }
    if(bAddedAmmo)
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 12);
        PlayGiveInventorySound(AmmoPickupSound);        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 14);
    }
    return bAddedAmmo;
}

function bool AddArmorFromPickup()
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(Instigator);
    if(KFPH.Armor != KFPH.GetMaxArmor())
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 10);
        PlayGiveInventorySound(ArmorPickupSound);
        KFPH.GiveMaxArmor();
        return true;        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 11);
        return false;
    }
}

function PlayGiveInventorySound(AkEvent SoundEvent)
{
    Instigator.PlaySoundBase(SoundEvent);
}

simulated function float GetEncumbranceSpeedMod()
{
    local float CarryPercent;

    CarryPercent = FMin(float(CurrentCarryBlocks) / float(MaxCarryBlocks), 1);
    return Lerp(1, 0.92, CarryPercent);
}

function KFWeapon CombineWeaponsOnPickup(KFWeapon AddedWeapon)
{
    local KFWeapon InvWeap;
    local KFWeap_DualBase AddedDual, NewDual;
    local int ExtraAmmo;
    local bool bEquipNewDual;

    AddedDual = KFWeap_DualBase(AddedWeapon);
    if(AddedDual != none)
    {
        foreach InventoryActors(Class'KFWeapon', InvWeap)
        {
            if(InvWeap.Class == AddedDual.SingleClass)
            {
                RemoveFromInventory(InvWeap);
                AddedDual.AmmoCount[0] += InvWeap.AmmoCount[0];
                ExtraAmmo = Max(AddedDual.AmmoCount[0] - AddedDual.default.MagazineCapacity[0], 0);
                AddedDual.AmmoCount[0] -= byte(ExtraAmmo);
                AddedDual.AmmoCount[1] += InvWeap.AmmoCount[1];
                AddedDual.SpareAmmoCount[0] += (InvWeap.SpareAmmoCount[0] + ExtraAmmo);
                AddedDual.SpareAmmoCount[0] = Min(AddedDual.SpareAmmoCount[0], AddedDual.default.SpareAmmoCapacity[0]);
                AddedDual.ClientForceAmmoUpdate(AddedDual.AmmoCount[0], AddedDual.SpareAmmoCount[0]);
                AddedDual.ClientForceSecondaryAmmoUpdate(AddedDual.AmmoCount[1]);
                break;
            }            
        }                
    }
    else
    {
        if(AddedWeapon.DualClass != none)
        {
            foreach InventoryActors(Class'KFWeapon', InvWeap)
            {
                if((InvWeap != AddedWeapon) && InvWeap.Class == AddedWeapon.Class)
                {
                    bEquipNewDual = Instigator.Weapon == InvWeap;
                    RemoveFromInventory(InvWeap);
                    RemoveFromInventory(AddedWeapon);
                    NewDual = KFWeap_DualBase(CreateInventory(AddedWeapon.DualClass, true));
                    if(NewDual != none)
                    {
                        NewDual.AmmoCount[0] = byte(InvWeap.AmmoCount[0] + AddedWeapon.AmmoCount[0]);
                        ExtraAmmo = Max(NewDual.AmmoCount[0] - NewDual.default.MagazineCapacity[0], 0);
                        NewDual.AmmoCount[0] -= byte(ExtraAmmo);
                        NewDual.AmmoCount[1] = byte(InvWeap.AmmoCount[1] + AddedWeapon.AmmoCount[1]);
                        NewDual.SpareAmmoCount[0] = Min((InvWeap.SpareAmmoCount[0] + AddedWeapon.SpareAmmoCount[0]) + ExtraAmmo, NewDual.default.SpareAmmoCapacity[0]);
                        NewDual.ClientForceAmmoUpdate(NewDual.AmmoCount[0], NewDual.SpareAmmoCount[0]);
                        NewDual.ClientForceSecondaryAmmoUpdate(NewDual.AmmoCount[1]);
                        if(bEquipNewDual)
                        {
                            SetCurrentWeapon(NewDual);
                        }
                        AddedWeapon = NewDual;
                    }
                    break;
                }                
            }            
        }
    }
    return AddedWeapon;
}

reliable server function ServerCloseTraderMenu()
{
    local int I;
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWClass;

    bServerTraderMenuOpen = false;
    bSuppressPickupMessages = true;
    I = TransactionItems.Length - 1;
    J0x2F:

    if(I >= 0)
    {
        KFWClass = class<KFWeapon>(DynamicLoadObject(TransactionItems[I].DLOString, Class'Class'));
        if(KFWClass != none)
        {
            AddCurrentCarryBlocks(-KFWClass.default.InventorySize);
            KFWeap = KFWeapon(CreateInventory(KFWClass));
            if(KFWeap != none)
            {
                KFWeap.AddTransactionAmmo(TransactionItems[I].AddedAmmo[0], TransactionItems[I].AddedAmmo[1]);
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(KFWClass));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, string(KFWClass));
            }
        }
        TransactionItems.Remove(I, 1;
        -- I;
        goto J0x2F;
    }
    bSuppressPickupMessages = false;
}

final simulated function BuyAmmo(int AmountPurchased, KFGFxMenu_Trader.EItemType ItemType, optional byte ItemIndex, optional bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local byte MagAmmoCount;

    MagAmmoCount = 255;
    if(ItemType == 0)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            if(GetWeaponFromClass(KFW, WeaponItem.ClassName))
            {
                MagAmmoCount = ((bSecondaryAmmo) ? KFW.AmmoCount[1] : KFW.AmmoCount[0]);
            }
        }
        ServerBuyAmmo(AmountPurchased, MagAmmoCount, ItemIndex, bSecondaryAmmo);        
    }
    else
    {
        if(ItemType == 1)
        {
            ServerBuyArmor(AmountPurchased);            
        }
        else
        {
            if(ItemType == 3)
            {
                ServerBuyGrenade(AmountPurchased);
            }
        }
    }
}

private reliable server final function ServerBuyAmmo(int AmountPurchased, byte ClientAmmoCount, byte ItemIndex, bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local byte ClientMaxMagCapacity;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            if(!ProcessAmmoDosh(WeaponItem, AmountPurchased, bSecondaryAmmo))
            {
                return;
            }
            if(GetWeaponFromClass(KFW, WeaponItem.ClassName))
            {
                if(bSecondaryAmmo)
                {
                    KFW.AddSecondaryAmmo(AmountPurchased);
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "S.Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "S.ammo", string(KFW.Class), "#" $ string(AmountPurchased));
                    }                    
                }
                else
                {
                    if(ClientAmmoCount != 255)
                    {
                        ClientMaxMagCapacity = KFW.default.MagazineCapacity[0];
                        if(KFW.GetPerk() != none)
                        {
                            KFW.GetPerk().ModifyMagSizeAndNumber(KFW, ClientMaxMagCapacity);
                        }
                        KFW.AmmoCount[0] = byte(Clamp(ClientAmmoCount, 0, ClientMaxMagCapacity));
                    }
                    KFW.AddAmmo(AmountPurchased);
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "ammo", string(KFW.Class), "#" $ string(AmountPurchased));
                    }
                }                
            }
            else
            {
                ServerAddTransactionAmmo(AmountPurchased, ItemIndex, bSecondaryAmmo);
            }
        }
    }
}

private reliable server final event ServerAddTransactionAmmo(int AmountAdded, byte ItemIndex, bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local byte AmmoTypeIndex;
    local int TransactionIndex;

    if(bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            TransactionIndex = GetTransactionItemIndex(WeaponItem.ClassName);
            if(TransactionIndex != -1)
            {
                AmmoTypeIndex = byte(bSecondaryAmmo);
                TransactionItems[TransactionIndex].AddedAmmo[AmmoTypeIndex] += AmountAdded;
                if(bSecondaryAmmo)
                {
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "S.Ammo,") @ string(WeaponItem.ClassName)) $ ",") @ string(AmountAdded));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "S.ammo", string(WeaponItem.ClassName), "#" $ string(AmountAdded));
                    }                    
                }
                else
                {
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Ammo,") @ string(WeaponItem.ClassName)) $ ",") @ string(AmountAdded));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "ammo", string(WeaponItem.ClassName), "#" $ string(AmountAdded));
                    }
                }
            }
        }
    }
}

private reliable server final function ServerBuyArmor(int PercentPurchased)
{
    local KFPawn_Human KFP;
    local int AmountPurchased;
    local float MaxArmor;

    KFP = KFPawn_Human(Instigator);
    if(((Role == ROLE_Authority) && KFP != none) && bServerTraderMenuOpen)
    {
        if(ProcessArmorDosh(PercentPurchased))
        {
            MaxArmor = float(KFP.GetMaxArmor());
            AmountPurchased = FCeil(MaxArmor * (float(PercentPurchased) / 100));
            KFP.AddArmor(AmountPurchased);
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Armor,") @ string(PercentPurchased));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "armor", "#" $ string(PercentPurchased));
            }
        }
    }
}

private reliable server final function ServerBuyGrenade(int AmountPurchased)
{
    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(ProcessGrenadeDosh(AmountPurchased))
        {
            AddGrenades(AmountPurchased);
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Grenades(s),") $ ",") @ string(AmountPurchased));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "grenades", "#" $ string(AmountPurchased));
            }
        }
    }
}

reliable server final function ServerBuyWeapon(byte ItemIndex)
{
    local STraderItem PurchasedItem;
    local int BlocksRequired;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(PurchasedItem, ItemIndex))
        {
            BlocksRequired = GetDisplayedBlocksRequiredFor(PurchasedItem);
            if((CurrentCarryBlocks > (CurrentCarryBlocks + BlocksRequired)) || !ProcessWeaponDosh(PurchasedItem))
            {
                return;
            }
            if(bLogInventory)
            {
                LogInternal("ServerBuyWeapon: Adding transaction item" @ string(PurchasedItem.ClassName));
            }
            AddTransactionItem(PurchasedItem);
        }
    }
}

function AddCurrentCarryBlocks(int AddAmount)
{
    CurrentCarryBlocks += byte(AddAmount);
}

final function AddTransactionItem(const out STraderItem ItemToAdd)
{
    local TransactionItem NewTransactionItem;

    if((Role < ROLE_Authority) || !bServerTraderMenuOpen)
    {
        return;
    }
    NewTransactionItem.ClassName = ItemToAdd.ClassName;
    NewTransactionItem.DLOString = ItemToAdd.WeaponDef.default.WeaponClassPath;
    NewTransactionItem.AddedAmmo[0] = 0;
    NewTransactionItem.AddedAmmo[1] = 0;
    TransactionItems.AddItem(NewTransactionItem;
    AddCurrentCarryBlocks(ItemToAdd.BlocksRequired);
}

reliable server final function ServerAddTransactionItem(byte ItemIndex)
{
    local STraderItem PurchasedItem;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(PurchasedItem, ItemIndex))
        {
            AddTransactionItem(PurchasedItem);
        }
    }
}

reliable server final function ServerSellWeapon(byte ItemIndex)
{
    local STraderItem SoldItem;
    local int SellPrice, TransactionIndex;
    local KFWeapon KFW;
    local KFPlayerReplicationInfo KFPRI;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
        if((KFPRI != none) && GetTraderItemFromWeaponLists(SoldItem, ItemIndex))
        {
            if(GetWeaponFromClass(KFW, SoldItem.ClassName))
            {
                if(bLogInventory)
                {
                    LogInternal("ServerSellWeapon: Calling ServerRemoveFromInventory on" @ string(SoldItem.ClassName));
                }
                SellPrice = GetAdjustedSellPriceFor(SoldItem, KFW);
                KFPRI.AddDosh(SellPrice);
                ServerRemoveFromInventory(KFW);
                KFW.Destroy();                
            }
            else
            {
                TransactionIndex = GetTransactionItemIndex(SoldItem.ClassName);
                if(bLogInventory)
                {
                    LogInternal((("ServerSellWeapon: SoldItem=" $ string(SoldItem.ClassName)) @ "TransactionIndex=") $ string(TransactionIndex));
                }
                if(TransactionIndex != -1)
                {
                    SellPrice = GetAdjustedSellPriceFor(SoldItem);
                    KFPRI.AddDosh(SellPrice);
                    if(bLogInventory)
                    {
                        LogInternal("ServerSellWeapon: Calling RemoveTransactionItem on" @ string(SoldItem.ClassName));
                    }
                    RemoveTransactionItem(SoldItem);
                }
            }
        }
    }
}

final function RemoveTransactionItem(const out STraderItem ItemToRemove)
{
    local int TransactionIndex, I;

    if(bLogInventory)
    {
        LogInternal("RemoveTransactionItem: ItemToRemove=" $ string(ItemToRemove.ClassName));
    }
    if((Role < ROLE_Authority) || !bServerTraderMenuOpen)
    {
        return;
    }
    TransactionIndex = GetTransactionItemIndex(ItemToRemove.ClassName);
    if(bLogInventory)
    {
        LogInternal("RemoveTransactionItem: TransactionIndex=" $ string(TransactionIndex));
    }
    if(bLogInventory)
    {
        I = 0;
        J0x10C:

        if(I < TransactionItems.Length)
        {
            if(bLogInventory)
            {
                LogInternal((("RemoveTransactionItem: TransactionItems[" $ string(I)) $ "]=") $ string(TransactionItems[I].ClassName));
            }
            ++ I;
            goto J0x10C;
        }
    }
    if(TransactionIndex != -1)
    {
        AddCurrentCarryBlocks(-ItemToRemove.BlocksRequired);
        TransactionItems.Remove(TransactionIndex, 1;
    }
    if(bLogInventory)
    {
        I = 0;
        J0x213:

        if(I < TransactionItems.Length)
        {
            if(bLogInventory)
            {
                LogInternal((("RemoveTransactionItem: TransactionItems[" $ string(I)) $ "]=") $ string(TransactionItems[I].ClassName));
            }
            ++ I;
            goto J0x213;
        }
    }
}

reliable server final function ServerRemoveTransactionItem(int ItemIndex)
{
    local STraderItem ItemToRemove;
    local KFWeapon InvWeap;

    if(bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(ItemToRemove, byte(ItemIndex)))
        {
            RemoveTransactionItem(ItemToRemove);
            if(GetWeaponFromClass(InvWeap, ItemToRemove.ClassName))
            {
                RemoveFromInventory(InvWeap);
            }
        }
    }
}

final function int GetTransactionItemIndex(name ClassName)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            return I;
        }
        -- I;
        goto J0x17;
    }
    return -1;
}

final simulated function bool GetWeaponFromClass(out KFWeapon KFW, name ClassName)
{
    local Inventory Item;

    Item = InventoryChain;
    J0x13:

    if(Item != none)
    {
        if(Item.Class.Name == ClassName)
        {
            KFW = KFWeapon(Item);
            return KFW != none;
        }
        Item = Item.Inventory;
        goto J0x13;
    }
    return false;
}

private final function bool ProcessWeaponDosh(out STraderItem PurchasedItem)
{
    local int BuyPrice;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        BuyPrice = GetAdjustedBuyPriceFor(PurchasedItem);
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    if(bLogInventory)
    {
        LogInternal("Server failed to process " @ string(PurchasedItem.ClassName));
    }
    return false;
}

private final function bool ProcessAmmoDosh(out STraderItem PurchasedItem, int AdditionalAmmo, optional bool bSecondaryAmmo)
{
    local int BuyPrice;
    local float PricePerMag, MagSize, AmmoCostScale;
    local KFPlayerReplicationInfo KFPRI;
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFGRI != none)
    {
        AmmoCostScale = KFGRI.GameAmmoCostScale;        
    }
    else
    {
        AmmoCostScale = 1;
    }
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        if(bSecondaryAmmo)
        {
            PricePerMag = AmmoCostScale * float(PurchasedItem.WeaponDef.default.SecondaryAmmoMagPrice);
            MagSize = float(PurchasedItem.WeaponDef.default.SecondaryAmmoMagSize);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));            
        }
        else
        {
            PricePerMag = AmmoCostScale * float(PurchasedItem.WeaponDef.default.AmmoPricePerMag);
            MagSize = float(PurchasedItem.MagazineCapacity);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));
        }
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    if(bLogInventory)
    {
        LogInternal(("Server failed to process " @ string(PurchasedItem.ClassName)) @ "Ammo");
    }
    return false;
}

private final function bool ProcessGrenadeDosh(int AmountPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo KFPRI;

    KFPC = KFPlayerController(Instigator.Owner);
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if((KFPC != none) && KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        BuyPrice = TraderItems.GrenadePrice * AmountPurchased;
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy grenades");
    return false;
}

private final function bool ProcessArmorDosh(int PercentPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPerk CurrentPerk;
    local int ArmorPricePerPercent;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        ArmorPricePerPercent = TraderItems.ArmorPrice;
        KFPC = KFPlayerController(Instigator.Owner);
        if(KFPC != none)
        {
            CurrentPerk = KFPC.GetPerk();
            if(CurrentPerk != none)
            {
                ArmorPricePerPercent *= CurrentPerk.GetArmorDiscountMod();
            }
        }
        BuyPrice = FCeil(float(ArmorPricePerPercent * PercentPurchased));
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy armor");
    return false;
}

private final simulated function bool GetTraderItemFromWeaponLists(out STraderItem TraderItem, byte ItemIndex)
{
    local KFGFxObject_TraderItems TraderItemsObject;

    TraderItemsObject = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
    if(ItemIndex < TraderItemsObject.SaleItems.Length)
    {
        TraderItem = TraderItemsObject.SaleItems[ItemIndex];
        return true;
    }
    return false;
}

simulated function int GetAdjustedBuyPriceFor(const out STraderItem ShopItem, const optional array<SItemInformation> TraderOwnedItems)
{
    local int AdjustedBuyPrice, I;

    AdjustedBuyPrice = ShopItem.WeaponDef.default.BuyPrice;
    if(ShopItem.SingleClassName != 'None')
    {
        if(GetIsOwned(ShopItem.SingleClassName))
        {
            AdjustedBuyPrice *= 0.5;            
        }
        else
        {
            if(TraderOwnedItems.Length > 0)
            {
                I = 0;
                J0xBD:

                if(I < TraderOwnedItems.Length)
                {
                    if(TraderOwnedItems[I].DefaultItem.ClassName == ShopItem.SingleClassName)
                    {
                        AdjustedBuyPrice *= 0.5;
                        goto J0x150;
                    }
                    ++ I;
                    goto J0xBD;
                }
            }
        }
    }
    J0x150:

    return AdjustedBuyPrice;
}

simulated function int GetAdjustedSellPriceFor(const out STraderItem OwnedItem, optional KFWeapon OwnedWeapon)
{
    local int AdjustedSellPrice;

    if((OwnedWeapon != none) && OwnedWeapon.bGivenAtStart)
    {
        AdjustedSellPrice = int(float(OwnedItem.WeaponDef.default.BuyPrice) * StartedWithWeaponPriceModifier);        
    }
    else
    {
        AdjustedSellPrice = int(float(OwnedItem.WeaponDef.default.BuyPrice) * SellPriceModifier);
    }
    if(OwnedItem.SingleClassName != 'None')
    {
        AdjustedSellPrice *= 0.5;
    }
    return AdjustedSellPrice;
}

simulated function int GetDisplayedBlocksRequiredFor(const out STraderItem ShopItem)
{
    if((ShopItem.SingleClassName == 'None') || ShopItem.SingleClassName == 'KFWeap_Pistol_9mm')
    {
        return ShopItem.BlocksRequired;
    }
    if(GetIsOwned(ShopItem.SingleClassName))
    {
        return ShopItem.BlocksRequired / 2;
    }
    return ShopItem.BlocksRequired;
}

simulated function bool GetIsOwned(name ClassName)
{
    local int I;
    local Inventory Inv;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Inv.Class.Name == ClassName)
        {
            if(bLogInventory)
            {
                LogInternal(("GetIsOwned: ClassName=" $ string(ClassName)) @ "InventoryActors true");
            }            
            return true;
        }        
    }    
    I = 0;
    J0xBD:

    if(I < TransactionItems.Length)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            if(bLogInventory)
            {
                LogInternal(((("GetIsOwned: i=" $ string(I)) @ "ClassName=") $ string(ClassName)) @ "TransactionItems true");
            }
            return true;
        }
        ++ I;
        goto J0xBD;
    }
    if(bLogInventory)
    {
        LogInternal(("GetIsOwned: ClassName=" $ string(ClassName)) @ "false");
    }
    return false;
}

simulated event DiscardInventory()
{
    local Inventory Inv;
    local KFPawn KFP;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Instigator.Weapon != Inv)
        {
            Inv.bDropOnDeath = false;
        }        
    }    
    super.DiscardInventory();
    KFP = KFPawn(Instigator);
    if(KFP != none)
    {
        KFP.MyKFWeapon = none;
    }
}

defaultproperties
{
    FullHealthMsg="Health Full"
    MaxCarryBlocks=15
    AmmoPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Ammo'
    ItemPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Weapon'
    ArmorPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Armor'
    SwitchFireModeEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_ModeSwitch'
    StartedWithWeaponPriceModifier=0.5
    SellPriceModifier=0.75
    bMustHoldWeapon=true
    PendingFire=/* Array type was not detected. */
}