/*******************************************************************************
 * KFInventoryManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFInventoryManager extends InventoryManager
    native
    hidecategories(Navigation);

struct native TransactionItem
{
    var string DLOString;
    var name ClassName;
    var int AddedAmmo[2];
    var int AddedWeight;
    var int WeaponUpgradeLevel;

    structdefaultproperties
    {
        DLOString=""
        ClassName=None
        AddedAmmo[0]=0
        AddedAmmo[1]=0
        AddedWeight=0
        WeaponUpgradeLevel=0
    }
};

var transient Weapon PreviousEquippedWeapons[2];
var transient KFWeap_HealerBase HealerWeapon;
var const localized string FullHealthMsg;
var const localized string CannotHealthMsg;
var byte GrenadeCount;
var byte CurrentCarryBlocks;
var byte MaxCarryBlocks;
var byte SelectedGroup;
var byte SelectedIndex;
var bool bInfiniteWeight;
var bool bSuppressPickupMessages;
var bool bServerTraderMenuOpen;
var bool bAutoswitchWeapon;
var bool bLogInventory;
/** Sound to play when we receive ammo from an already owned weapon */
var() AkEvent AmmoPickupSound;
/** Sound to play when a new weapon is picked up */
var() AkEvent ItemPickupSound;
/** Sound to play when we pick up armor */
var() AkEvent ArmorPickupSound;
var AkEvent SwitchFireModeEvent;
var float LastCreatedWeaponTime;
var array<GFxMoviePlayer> OpticsUIMovies;
var const float StartedWithWeaponPriceModifier;
var const float SellPriceModifier;
var const float DoshinegunSellModifier;
var float OffPerkCostScale;
var array<TransactionItem> TransactionItems;
var int SelectedGroupIndicies[4];

replication
{
     if(bNetDirty && bNetOwner)
        CurrentCarryBlocks, GrenadeCount, 
        MaxCarryBlocks, OffPerkCostScale;

     if((bNetDirty && bNetOwner) && bNetInitial)
        HealerWeapon;
}

// Export UKFInventoryManager::execAddWeaponToGroup(FFrame&, void* const)
native function bool AddWeaponToGroup(out KFWeapon AddedWeapon);

simulated function string DumpInventory()
{
    local Inventory InventoryItem;
    local KFWeapon Weapon;
    local string InventoryLabel;

    InventoryItem = InventoryChain;
    J0x13:

    if(InventoryItem != none)
    {
        Weapon = KFWeapon(InventoryItem);
        if(Weapon != none)
        {            
            InventoryLabel $= (((string(Weapon.Class.Name) $ ":") $ string(Weapon.GetTotalAmmoAmount(0))) $ ",");
        }
        InventoryItem = InventoryItem.Inventory;
        goto J0x13;
    }
    if(Len(InventoryLabel) > 0)
    {
        InventoryLabel = Left(InventoryLabel, Len(InventoryLabel) - 1);
    }
    return InventoryLabel;
}

simulated function float GetPrimaryAmmoPercentage()
{
    local Inventory InventoryItem;
    local KFWeapon Weapon;
    local float TotalAmmo, MaxAmmo;

    InventoryItem = InventoryChain;
    J0x13:

    if(InventoryItem != none)
    {
        Weapon = KFWeapon(InventoryItem);
        if((((Weapon != none) && !Weapon.bIsBackupWeapon) && Weapon.InventoryGroup != 4) && Weapon.InventoryGroup != 3)
        {
            if(Weapon.GetMaxAmmoAmount(0) == 0)
            {
                TotalAmmo += 1;
                MaxAmmo += 1;                
            }
            else
            {
                TotalAmmo += float(Weapon.GetTotalAmmoAmount(0));
                MaxAmmo += float(Weapon.GetMaxAmmoAmount(0));
            }
        }
        InventoryItem = InventoryItem.Inventory;
        goto J0x13;
    }
    if(MaxAmmo > float(0))
    {
        return TotalAmmo / MaxAmmo;        
    }
    else
    {
        return 0;
    }
}

simulated function GFxMoviePlayer GetOpticsUIMovie(class<GFxMoviePlayer> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            return OpticsUIMovies[OpticsIndex];
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
    OpticsUIMovies.AddItem(new (self) OpticsClass;
    OpticsIndex = byte(OpticsUIMovies.Length - 1);
    OpticsUIMovies[OpticsIndex].Init();
    OpticsUIMovies[OpticsIndex].Start();
    return OpticsUIMovies[OpticsIndex];
}

simulated function RemoveOpticsUIMovie(class<KFGFxWorld_MedicOptics> OpticsClass)
{
    local byte OpticsIndex;

    OpticsIndex = 0;
    J0x0C:

    if(OpticsIndex < OpticsUIMovies.Length)
    {
        if(OpticsUIMovies[OpticsIndex].Class == OpticsClass)
        {
            OpticsUIMovies[OpticsIndex].Close();
            OpticsUIMovies.Remove(OpticsIndex, 1;
        }
        ++ OpticsIndex;
        goto J0x0C;
    }
}

simulated function InitFOV(float SizeX, float SizeY, float DefaultPlayerFOV)
{
    local KFWeapon KFWP;

    if(InventoryChain == none)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFWP)
    {
        KFWP.InitFOV(SizeX, SizeY, DefaultPlayerFOV);        
    }    
}

simulated function bool AddInventory(Inventory NewItem, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    KFW = KFWeapon(NewItem);
    if(KFW != none)
    {
        if(Role == ROLE_Authority)
        {
            AddWeaponToGroup(KFW);
        }
        NewItem.SetOwner(Instigator);
        NewItem.Instigator = Instigator;
        NewItem.InvManager = self;
        NewItem.GivenTo(Instigator, bDoNotActivate);
        Instigator.TriggerEventClass(Class'SeqEvent_GetInventory', NewItem);
        return true;        
    }
    else
    {
        return super.AddInventory(NewItem, bDoNotActivate);
    }
}

simulated function Inventory CreateInventoryArchetype(Inventory NewInventoryTemplate, optional bool bDoNotActivate)
{
    local Inventory Inv;

    if(NewInventoryTemplate != none)
    {
        Inv = Spawn(NewInventoryTemplate.Class, Owner,,,, NewInventoryTemplate);
        if(Inv != none)
        {
            if(!AddInventory(Inv, bDoNotActivate))
            {
                WarnInternal("InventoryManager::CreateInventory - Couldn't Add newly created inventory" @ string(Inv));
                Inv.Destroy();
                Inv = none;
            }            
        }
        else
        {
            WarnInternal("InventoryManager::CreateInventory - Couldn't spawn inventory" @ string(NewInventoryTemplate));
        }
    }
    return Inv;
}

simulated function Inventory CreateInventory(class<Inventory> NewInventoryItemClass, optional bool bDoNotActivate)
{
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWeapClass;

    if(bPendingDelete)
    {
        return none;
    }
    KFWeapClass = class<KFWeapon>(NewInventoryItemClass);
    if(KFWeapClass != none)
    {
        if(CanCarryWeapon(KFWeapClass))
        {
            KFWeap = KFWeapon(super.CreateInventory(NewInventoryItemClass, bDoNotActivate));
            UpdateHUD();
            if(!bSuppressPickupMessages && (WorldInfo.TimeSeconds - CreationTime) > float(1))
            {
                PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 17,,, KFWeap);
                if((WorldInfo.TimeSeconds - LastCreatedWeaponTime) > float(1))
                {
                    PlayGiveInventorySound(ItemPickupSound);
                    LastCreatedWeaponTime = WorldInfo.TimeSeconds;
                }
            }
            if(KFWeap != none)
            {
                CheckForExcessRemoval(KFWeap);
            }
            return KFWeap;            
        }
        else
        {
            if(!bSuppressPickupMessages)
            {
                PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 18);
            }
            return none;
        }
    }
    return super.CreateInventory(NewInventoryItemClass, bDoNotActivate);
}

simulated function RemoveFromInventory(Inventory ItemToRemove)
{
    local Inventory Item;
    local bool bFound;
    local KFPlayerController KFPC;

    if(ItemToRemove == none)
    {
        return;
    }
    if(PreviousEquippedWeapons[0] == ItemToRemove)
    {
        PreviousEquippedWeapons[0] = none;
    }
    if(PreviousEquippedWeapons[1] == ItemToRemove)
    {
        PreviousEquippedWeapons[1] = none;
    }
    if(PendingWeapon == ItemToRemove)
    {
        PendingWeapon = none;
    }
    if((Instigator != none) && Instigator.Weapon == ItemToRemove)
    {
        Instigator.Weapon = none;
    }
    if(InventoryChain == ItemToRemove)
    {
        bFound = true;
        InventoryChain = ItemToRemove.Inventory;        
    }
    else
    {
        Item = InventoryChain;
        J0x13D:

        if(Item != none)
        {
            if(Item.Inventory == ItemToRemove)
            {
                bFound = true;
                Item.Inventory = ItemToRemove.Inventory;
                goto J0x1EF;
            }
            Item = Item.Inventory;
            goto J0x13D;
        }
    }
    J0x1EF:

    if(bFound)
    {
        ItemToRemove.ItemRemovedFromInvManager();
        ItemToRemove.SetOwner(none);
        ItemToRemove.Inventory = none;
    }
    if(((Instigator != none) && Instigator.Health > 0) && Instigator.Controller != none)
    {
        if((WorldInfo.NetMode == NM_DedicatedServer) || (WorldInfo.NetMode == NM_ListenServer) && !Instigator.IsLocallyControlled())
        {
            ClientRemoveFromInventory(ItemToRemove);            
        }
        else
        {
            if(Instigator.Weapon == none)
            {
                if((PendingWeapon != none) && PendingWeapon != ItemToRemove)
                {
                    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Removed current weapon while changing weapons, call ChangedWeapon", 'Inventory');
                    if(Role < ROLE_Authority)
                    {
                        SetCurrentWeapon(PendingWeapon);                        
                    }
                    else
                    {
                        ChangedWeapon();
                    }                    
                }
                else
                {
                    if(Instigator.Controller != none)
                    {
                        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Calling SwitchToBestWeapon to make sure a weapon is brought up", 'Inventory');
                        Instigator.Controller.SwitchToBestWeapon(true);
                    }
                }
            }
        }
    }
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        KFPC = KFPlayerController(Instigator.Controller);
        if((((KFPC != none) && KFPC.myGfxHUD != none) && KFPC.myGfxHUD.WeaponSelectWidget != none) && KFPC.IsTimerActive('RefreshTimer', KFPC.myGfxHUD.WeaponSelectWidget))
        {
            KFPC.myGfxHUD.WeaponSelectWidget.RefreshTimer();
        }
    }
}

reliable server final function ServerRemoveFromInventory(Inventory ItemToRemove)
{
    if(Role == ROLE_Authority)
    {
        RemoveFromInventory(ItemToRemove);
        if(Class'KFGameInfo'.static.AllowBalanceLogging())
        {
            WorldInfo.LogGameBalance((((string('Sell') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(ItemToRemove.Class));
        }
        if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
        {
            WorldInfo.TWLogEvent("sell", Instigator.PlayerReplicationInfo, string(ItemToRemove.Class));
        }
    }
}

reliable client simulated function ClientRemoveFromInventory(Inventory ItemToRemove)
{
    RemoveFromInventory(ItemToRemove);
}

function bool ItemIsInInventory(Inventory Item)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv == Item)
        {
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

function bool ClassIsInInventory(class<Inventory> ItemClass, out Inventory out_Inventory)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv.Class == ItemClass)
        {
            out_Inventory = Inv;
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

function bool ClassNameIsInInventory(name ItemClassName, out Inventory out_Inventory)
{
    local Inventory Inv;

    Inv = InventoryChain;
    J0x13:

    if(Inv != none)
    {
        if(Inv.Class.Name == ItemClassName)
        {
            out_Inventory = Inv;
            return true;
        }
        Inv = Inv.Inventory;
        goto J0x13;
    }
    return false;
}

simulated function Weapon GetBestWeapon(optional bool bForceADifferentWeapon, optional bool allow9mm)
{
    local KFWeapon W, BestWeapon, BackupGun;
    local float Rating, BestRating;

    foreach InventoryActors(Class'KFWeapon', W)
    {
        if(W.HasAnyAmmo())
        {
            if(bForceADifferentWeapon && W == Instigator.Weapon)
            {
                continue;                
            }
            Rating = W.GetWeaponRating();
            if((BestWeapon == none) || Rating > BestRating)
            {
                if(allow9mm == false)
                {
                    if(W.bIsBackupWeapon && !W.IsMeleeWeapon())
                    {
                        BackupGun = W;
                        continue;                        
                    }
                }
                BestWeapon = W;
                BestRating = Rating;
            }
        }        
    }    
    if((BestWeapon == none) && allow9mm == false)
    {
        foreach InventoryActors(Class'KFWeapon', W)
        {
            if(W.HasAnyAmmo())
            {
                if(bForceADifferentWeapon && W == Instigator.Weapon)
                {
                    continue;                    
                }
                Rating = W.GetWeaponRating();
                if((BestWeapon == none) || Rating > BestRating)
                {
                    BestWeapon = W;
                    BestRating = Rating;
                }
            }            
        }        
    }
    if((((BestWeapon != none) && BestWeapon.bIsBackupWeapon) && BestWeapon.IsMeleeWeapon()) && BackupGun != none)
    {
        BestWeapon = BackupGun;
    }
    return BestWeapon;
}

simulated function SwitchToBestWeapon(optional bool bForceADifferentWeapon, optional bool check_9mm_logic)
{
    local Weapon BestWeapon;
    local PlayerController PC;
    local KFPlayerInput KFPI;
    local bool bCanSwapTo9mm;

    check_9mm_logic = false;
    if(check_9mm_logic)
    {
        bCanSwapTo9mm = false;
        PC = PlayerController(Instigator.Controller);
        if(PC != none)
        {
            KFPI = KFPlayerInput(PC.PlayerInput);
            if(KFPI != none)
            {
                bCanSwapTo9mm = KFPI.bAllowSwapTo9mm;
            }
        }        
    }
    else
    {
        bCanSwapTo9mm = true;
    }
    LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "bForceADifferentWeapon:") @ string(bForceADifferentWeapon), 'Inventory');
    if((bForceADifferentWeapon || PendingWeapon == none) || AIController(Instigator.Controller) != none)
    {
        BestWeapon = GetBestWeapon(bForceADifferentWeapon, bCanSwapTo9mm);
        if(BestWeapon == none)
        {
            return;
        }
        if(BestWeapon == Instigator.Weapon)
        {
            BestWeapon = none;
            PendingWeapon = none;
            Instigator.Weapon.Activate();
        }
    }
    Instigator.Controller.StopFiring();
    SetCurrentWeapon(BestWeapon);
}

simulated function SwitchToLastWeapon()
{
    local Weapon CurrentWeapon, DesiredWeapon;
    local KFWeapon CheckedWeapon, DesiredKFWeapon;
    local int WeaponIndex;

    CurrentWeapon = ((PendingWeapon != none) ? PendingWeapon : Instigator.Weapon);
    if((PreviousEquippedWeapons[0] != none) && PreviousEquippedWeapons[0] != CurrentWeapon)
    {
        DesiredWeapon = PreviousEquippedWeapons[0];        
    }
    else
    {
        if((PreviousEquippedWeapons[1] != none) && PreviousEquippedWeapons[1] != CurrentWeapon)
        {
            DesiredWeapon = PreviousEquippedWeapons[1];            
        }
        else
        {
            return;
        }
    }
    bAutoswitchWeapon = true;
    SetCurrentWeapon(DesiredWeapon);
    bAutoswitchWeapon = false;
    DesiredKFWeapon = KFWeapon(DesiredWeapon);
    WeaponIndex = 0;
    if(DesiredKFWeapon != none)
    {
        foreach InventoryActors(Class'KFWeapon', CheckedWeapon)
        {
            if(CheckedWeapon.InventoryGroup == DesiredKFWeapon.InventoryGroup)
            {
                if(CheckedWeapon == DesiredKFWeapon)
                {
                    SelectedGroupIndicies[CheckedWeapon.InventoryGroup] = WeaponIndex;
                }
                ++ WeaponIndex;
            }            
        }        
    }
}

simulated function KFWeapon GetBestPerkWeaponWithAmmo(class<KFPerk> PerkClass, optional bool bBackupIfEmpty)
{
    local KFWeapon PerkWeapon, NextWeapon, BackupWeapon;

    bBackupIfEmpty = false;
    if(InventoryChain == none)
    {
        return none;
    }
    foreach InventoryActors(Class'KFWeapon', NextWeapon)
    {
        if(((NextWeapon.GetWeaponPerkClass(PerkClass) == PerkClass) && NextWeapon.HasAmmo(0)) && !NextWeapon.IsMeleeWeapon())
        {
            PerkWeapon = NextWeapon;
            break;
            continue;
        }
        if((NextWeapon.bIsBackupWeapon && !NextWeapon.IsMeleeWeapon()) && NextWeapon.HasAmmo(0))
        {
            BackupWeapon = NextWeapon;
        }        
    }    
    return ((PerkWeapon != none) ? PerkWeapon : BackupWeapon);
}

simulated function KFWeapon GetNextGroupedWeapon(byte GroupID, optional bool bGetFirstWeapon, optional bool bGamePadWeaponSelectOpen)
{
    local KFWeapon EquippedWeapon, NewWeapon;
    local int WeaponIndex;

    WeaponIndex = 0;
    if(Instigator == none)
    {
        return none;
    }
    if(PendingWeapon != none)
    {
        EquippedWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        EquippedWeapon = KFWeapon(Instigator.Weapon);
    }
    if(((EquippedWeapon != none) && EquippedWeapon.InventoryGroup == GroupID) && !bGetFirstWeapon)
    {
        SelectedGroupIndicies[GroupID] += 1;
    }
    if(((EquippedWeapon == none) || EquippedWeapon.InventoryGroup != GroupID) && !bGamePadWeaponSelectOpen)
    {
        bGetFirstWeapon = true;
    }
    foreach InventoryActors(Class'KFWeapon', NewWeapon)
    {
        if(GroupID == NewWeapon.InventoryGroup)
        {
            if((SelectedGroupIndicies[GroupID] == WeaponIndex) || bGetFirstWeapon)
            {                
                return NewWeapon;
            }
            ++ WeaponIndex;
        }        
    }    
    if(!bGetFirstWeapon)
    {
        SelectedGroupIndicies[GroupID] = 0;
        return GetNextGroupedWeapon(GroupID, true, bGamePadWeaponSelectOpen);
    }
    return none;
}

simulated function HighlightPrevWeapon()
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        if(!ShouldSkipCycleWeapon(W, false))
        {
            CandidateWeapon = W;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function PrevWeapon()
{
    InternalPrevWeapon(false);
}

simulated function NextWeapon()
{
    InternalNextWeapon(false);
}

simulated function GamepadNextWeapon()
{
    InternalNextWeapon(true);
}

simulated function InternalPrevWeapon(bool bGamepad)
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        if(!ShouldSkipCycleWeapon(W, bGamepad))
        {
            CandidateWeapon = W;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
            }            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

simulated function InternalNextWeapon(bool bGamepad)
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
                break;
            }
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, bGamepad))
            {
                CandidateWeapon = W;
                break;
            }            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

simulated function bool ShouldSkipCycleWeapon(Weapon CandidateWeapon, bool bGamepad)
{
    local KFWeapon KFW;
    local PlayerController PC;
    local KFPlayerInput KFPI;
    local bool bCanSwapTo9mm;

    bCanSwapTo9mm = false;
    PC = PlayerController(Instigator.Controller);
    if(PC != none)
    {
        KFPI = KFPlayerInput(PC.PlayerInput);
        if(KFPI != none)
        {
            bCanSwapTo9mm = KFPI.bAllowSwapTo9mm;
        }
    }
    KFW = KFWeapon(CandidateWeapon);
    if(KFW != none)
    {
        if(KFW.InventoryGroup == 4)
        {
            return true;
        }
        if(bGamepad)
        {
            if(KFW.InventoryGroup == 3)
            {
                return true;
            }
            if(KFW.bIsBackupWeapon && !bCanSwapTo9mm || KFW.IsMeleeWeapon())
            {
                return true;
            }
            if(!KFW.HasAnyAmmo())
            {
                return true;
            }
        }
    }
    return false;
}

simulated function HighlightNextWeapon()
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }
            break;
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            if(!ShouldSkipCycleWeapon(W, false))
            {
                CandidateWeapon = W;
            }
            break;            
        }        
    }
    HighlightWeapon(CandidateWeapon);
}

simulated function HighlightWeapon(Weapon CandidateWeapon)
{
    SetPendingWeapon(CandidateWeapon);
    UpdateHUD();
}

reliable server function ServerSetCurrentWeapon(Weapon DesiredWeapon)
{
    local KFWeapon PendingKFW;

    if(!ItemIsInInventory(DesiredWeapon))
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ string(DesiredWeapon)) $ " is not in inventory!", 'Inventory');
        return;
    }
    if((PendingWeapon != none) && DesiredWeapon != PendingWeapon)
    {
        PendingKFW = KFWeapon(PendingWeapon);
        if(PendingKFW != none)
        {
            PendingKFW.NotifyRemovedPending();
        }
    }
    super.ServerSetCurrentWeapon(DesiredWeapon);
}

reliable client simulated function SetCurrentWeapon(Weapon DesiredWeapon)
{
    local KFWeapon CurrentKFW;
    local bool bCurrentWeaponUsingSights;
    local KFWeapon DesiredKFW, PendingKFW;

    CurrentKFW = ((Instigator != none) ? KFWeapon(Instigator.Weapon) : none);
    if(CurrentKFW != none)
    {
        bCurrentWeaponUsingSights = CurrentKFW.bUsingSights;
    }
    if((PendingWeapon != none) && DesiredWeapon != PendingWeapon)
    {
        PendingKFW = KFWeapon(PendingWeapon);
        if(PendingKFW != none)
        {
            PendingKFW.NotifyRemovedPending();
        }
    }
    DesiredKFW = KFWeapon(DesiredWeapon);
    if(((DesiredKFW != none) && Instigator != none) && (DesiredKFW != Instigator.Weapon) || Instigator.Weapon.IsInState('WeaponPuttingDown'))
    {
        if(DesiredKFW.bHasIronSights)
        {
            if(bCurrentWeaponUsingSights && !IsUsingIronsightHoldKey())
            {
                DesiredKFW.bIronSightOnBringUp = true;                
            }
            else
            {
                DesiredKFW.bIronSightOnBringUp = false;
            }
        }
        if(((CurrentKFW != none) && (CurrentKFW.InventoryGroup < 3) || CurrentKFW.bStorePreviouslyEquipped) && CurrentKFW != PreviousEquippedWeapons[0])
        {
            PreviousEquippedWeapons[1] = PreviousEquippedWeapons[0];
            PreviousEquippedWeapons[0] = CurrentKFW;
        }
        super.SetCurrentWeapon(DesiredWeapon);
        UpdateHUD();
    }
}

simulated function bool IsUsingIronsightHoldKey()
{
    local PlayerController PC;

    if(Instigator.IsLocallyControlled())
    {
        PC = PlayerController(Instigator.Controller);
        if((PC != none) && PC.PlayerInput != none)
        {
            if(KFPlayerInput(PC.PlayerInput).bIronsightsHeld)
            {
                return true;
            }
        }
    }
    return false;
}

simulated function ClientWeaponSet(Weapon NewWeapon, bool bOptionalSet, optional bool bDoNotActivate)
{
    local KFWeapon KFW;

    super.ClientWeaponSet(NewWeapon, bOptionalSet, bDoNotActivate);
    KFW = KFWeapon(NewWeapon);
    if(Role != ROLE_Authority)
    {
        AddWeaponToGroup(KFW);
        UpdateHUD();
    }
}

simulated event ShowOnlyHUDGroup(byte GroupIndex)
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    KFGFxHUD = KFPlayerController(Instigator.Controller).myGfxHUD;
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        KFGFxHUD.WeaponSelectWidget.ShowOnlyHUDGroup(GroupIndex);
    }
}

simulated function ShowAllHUDGroups()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;

    if((Instigator != none) && Instigator.Controller != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).myGfxHUD;
        if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
        {
            KFGFxHUD.WeaponSelectWidget.ShowAllHUDGroups();
        }
    }
}

simulated function UpdateHUD()
{
    local KFGFxMoviePlayer_HUD KFGFxHUD;
    local KFWeapon KFW, KFPendingWeapon;
    local byte WeaponIndex;

    WeaponIndex = 0;
    if(((PendingWeapon != none) && !PendingWeapon.bDeleteMe) && PendingWeapon.Instigator == Instigator)
    {
        KFPendingWeapon = KFWeapon(PendingWeapon);        
    }
    else
    {
        KFPendingWeapon = KFWeapon(Instigator.Weapon);
    }
    if((KFPendingWeapon == none) || KFPendingWeapon.InventoryGroup == 4)
    {
        return;
    }
    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == KFPendingWeapon.InventoryGroup)
        {
            if(KFW == KFPendingWeapon)
            {
                break;
            }
            ++ WeaponIndex;
        }        
    }    
    if(KFPlayerController(Instigator.Controller) != none)
    {
        KFGFxHUD = KFPlayerController(Instigator.Controller).myGfxHUD;
    }
    if((KFGFxHUD != none) && KFGFxHUD.WeaponSelectWidget != none)
    {
        if(!bAutoswitchWeapon && !(KFPendingWeapon == HealerWeapon) && HealerWeapon.bQuickHealMode)
        {
            KFGFxHUD.WeaponSelectWidget.SetSelectedWeapon(KFPendingWeapon.InventoryGroup, WeaponIndex);
            KFGFxHUD.WeaponSelectWidget.RefreshWeaponSelect();
            SelectedGroupIndicies[KFPendingWeapon.InventoryGroup] = WeaponIndex;
        }
    }
}

function SelectCurrentWeapon(byte GroupIndex, byte WeaponIndex)
{
    local KFWeapon KFW;
    local byte CurrentWeaponIndex;

    foreach InventoryActors(Class'KFWeapon', KFW)
    {
        if(KFW.InventoryGroup == GroupIndex)
        {
            if(CurrentWeaponIndex == WeaponIndex)
            {
                break;
            }
            ++ CurrentWeaponIndex;
        }        
    }    
    if(KFW != none)
    {
        SetCurrentWeapon(KFW);
    }
}

simulated function AttemptQuickHeal()
{
    local KFWeap_HealerBase W;
    local KFPlayerController KFPC;
    local KFPlayerController_WeeklySurvival KFPCWS;
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    KFPCWS = KFPlayerController_WeeklySurvival(Instigator.Owner);
    if(((KFGRI != none) && KFGRI.VIPRepPlayer != none) && KFGRI.VIPRepPlayer == KFPlayerReplicationInfo(KFPCWS.PlayerReplicationInfo))
    {
        KFPCWS.myGfxHUD.ShowNonCriticalMessage(CannotHealthMsg);
        return;
    }
    if(Instigator.Health >= Instigator.HealthMax)
    {
        KFPC = KFPlayerController(Instigator.Owner);
        if((KFPC != none) && KFPC.myGfxHUD != none)
        {
            KFPC.myGfxHUD.ShowNonCriticalMessage(FullHealthMsg);
        }
        return;
    }
    KFPC = KFPlayerController(Instigator.Owner);
    if(KFPC != none)
    {
        if(!KFPC.CanUseHealObject())
        {
            return;
        }
    }
    if((KFWeap_HealerBase(Instigator.Weapon) != none) && !Instigator.Weapon.IsFiring())
    {
        Instigator.Weapon.StartFire(1);
        return;
    }
    foreach InventoryActors(Class'KFWeap_HealerBase', W)
    {
        if((W != Instigator.Weapon) && W.HasAmmo(1))
        {
            W.bQuickHealMode = true;
            SetCurrentWeapon(W);
        }        
    }    
}

simulated function bool QuickWeld()
{
    local KFWeapon KFW;
    local KFInterface_Usable UsableTrigger;
    local KFDoorTrigger DoorTrigger;
    local KFRepairableActorTrigger RepairableTrigger;
    local KFWeldableTrigger WeldableTrigger;
    local KFPlayerController KFPC;

    if((Instigator == none) || Instigator.Owner == none)
    {
        return false;
    }
    KFW = KFWeapon(Instigator.Weapon);
    if((KFW != none) && !KFW.CanSwitchWeapons())
    {
        return false;
    }
    KFPC = KFPlayerController(Instigator.Owner);
    if(KFPC != none)
    {
        UsableTrigger = KFPC.GetCurrentUsableActor(Instigator);
        if(NotEqual_InterfaceInterface(UsableTrigger, (none)))
        {
            if(CanUseWelder(UsableTrigger, DoorTrigger, RepairableTrigger, WeldableTrigger))
            {
                if(((DoorTrigger != none) && DoorTrigger.DoorActor.bIsDoorOpen) && !DoorTrigger.DoorActor.bIsDestroyed)
                {
                    KFPC.Use();
                }
                if((Instigator.Weapon != none) && Instigator.Weapon.IsA('KFWeap_Welder'))
                {
                    return true;
                }
                foreach InventoryActors(Class'KFWeapon', KFW)
                {
                    if(KFW.IsA('KFWeap_Welder'))
                    {
                        SetCurrentWeapon(KFW);
                        ShowAllHUDGroups();                        
                        return true;
                    }                    
                }                
            }
        }
    }
    return false;
}

simulated function bool CanUseWelder(KFInterface_Usable BaseTrigger, out KFDoorTrigger out_DoorTrigger, out KFRepairableActorTrigger out_RepairableTrigger, out KFWeldableTrigger out_WeldableTrigger)
{
    out_DoorTrigger = KFDoorTrigger(bool(BaseTrigger));
    out_RepairableTrigger = KFRepairableActorTrigger(bool(BaseTrigger));
    out_WeldableTrigger = KFWeldableTrigger(bool(BaseTrigger));
    return (((out_DoorTrigger != none) && out_DoorTrigger.DoorActor != none) || (out_RepairableTrigger != none) && out_RepairableTrigger.RepairableActor != none) || (out_WeldableTrigger != none) && out_WeldableTrigger.WeldableComponent != none;
}

simulated function bool DoshActivate()
{
    local KFInterface_Usable UsableTrigger;
    local KFTrigger_DoshActivated DoshActivatedTrigger;
    local KFPlayerController KFPC;

    if((Instigator == none) || Instigator.Owner == none)
    {
        return false;
    }
    KFPC = KFPlayerController(Instigator.Owner);
    if(KFPC != none)
    {
        UsableTrigger = KFPC.GetCurrentUsableActor(Instigator);
        if(NotEqual_InterfaceInterface(UsableTrigger, (none)))
        {
            DoshActivatedTrigger = KFTrigger_DoshActivated(bool(UsableTrigger));
            if(DoshActivatedTrigger != none)
            {
                KFPC.Use();
            }
        }
    }
    return false;
}

function bool GiveInitialGrenadeCount()
{
    local byte OriginalGrenadeCount;

    OriginalGrenadeCount = GrenadeCount;
    if(KFPawn(Instigator) != none)
    {
        GrenadeCount = byte(KFPawn(Instigator).GetPerk().InitialGrenadeCount);
    }
    if(KFGameInfo(WorldInfo.Game) != none)
    {
        GrenadeCount = byte(KFGameInfo(WorldInfo.Game).AdjustStartingGrenadeCount(GrenadeCount));
    }
    return GrenadeCount > OriginalGrenadeCount;
}

function bool AddGrenades(int AmountToAdd)
{
    if(KFPawn(Instigator) != none)
    {
        if(GrenadeCount < KFPawn(Instigator).GetPerk().MaxGrenadeCount)
        {
            GrenadeCount = byte(Min(KFPawn(Instigator).GetPerk().MaxGrenadeCount, GrenadeCount + AmountToAdd));
            return true;
        }
    }
    return false;
}

function bool ConsumeGrenades(optional int AmountToSubtract)
{
    local byte OriginalGrenadeCount;

    AmountToSubtract = 1;
    OriginalGrenadeCount = GrenadeCount;
    GrenadeCount = byte(Max(0, GrenadeCount - AmountToSubtract));
    return GrenadeCount < OriginalGrenadeCount;
}

simulated event bool HasGrenadeAmmo(optional int Amount)
{
    Amount = 1;
    if(Amount == 0)
    {
        Amount = 1;
    }
    return (GrenadeCount - Amount) >= 0;
}

simulated function ThrowMoney()
{
    ServerThrowMoney();
}

reliable server function ServerThrowMoney()
{
    local Inventory Inv;

    if(Instigator != none)
    {
        foreach InventoryActors(Class'Inventory', Inv)
        {
            if(Inv.DroppedPickupClass == Class'KFDroppedPickup_Cash')
            {
                Instigator.TossInventory(Inv);                
                return;
            }            
        }        
    }
}

simulated function bool CanCarryWeapon(class<KFWeapon> WeaponClass, optional int WeaponUpgradeIndex)
{
    local class<KFWeap_DualBase> DualWeaponClass;
    local int DualAdjustedWeight, SingleAdjustedWeight, AdjustedWeight;
    local Inventory InventoryItem;
    local TransactionItem TransactionWeapon;
    local KFWeapon WeaponItemSingle;

    if(bServerTraderMenuOpen && IsTransactionWeapon(WeaponClass.Name, TransactionWeapon))
    {
        return false;
    }
    WeaponUpgradeIndex = Clamp(WeaponUpgradeIndex, 0, WeaponClass.default.WeaponUpgrades.Length - 1);
    if((WeaponClass.default.DualClass != none) && ClassIsInInventory(WeaponClass, InventoryItem))
    {
        WeaponItemSingle = KFWeapon(InventoryItem);
        WeaponUpgradeIndex = Max(WeaponUpgradeIndex, WeaponItemSingle.CurrentWeaponUpgradeIndex);
        DualAdjustedWeight = WeaponClass.default.DualClass.GetDefaultModifiedWeightValue(WeaponUpgradeIndex);
        SingleAdjustedWeight = WeaponItemSingle.GetModifiedWeightValue();
        if((((CurrentCarryBlocks + DualAdjustedWeight) - SingleAdjustedWeight) <= MaxCarryBlocks) || bInfiniteWeight)
        {
            return true;            
        }
        else
        {
            return false;
        }
    }
    DualWeaponClass = class<KFWeap_DualBase>(WeaponClass);
    if(((DualWeaponClass != none) && DualWeaponClass.default.SingleClass != none) && ClassIsInInventory(DualWeaponClass.default.SingleClass, InventoryItem))
    {
        WeaponItemSingle = KFWeapon(InventoryItem);
        WeaponUpgradeIndex = Max(WeaponUpgradeIndex, WeaponItemSingle.CurrentWeaponUpgradeIndex);
        DualAdjustedWeight = WeaponItemSingle.default.DualClass.static.GetDefaultModifiedWeightValue(WeaponUpgradeIndex);
        SingleAdjustedWeight = WeaponItemSingle.GetModifiedWeightValue();
        if(bLogInventory)
        {
            LogInternal((((((((((((string(self) @ "-") @ string(GetFuncName())) @ "- CurrentCarryBlocks:") @ string(CurrentCarryBlocks)) @ "DualWeaponClass:") @ string(DualWeaponClass)) @ "SingleClass:") @ string(DualWeaponClass.default.SingleClass)) @ "DualInventorySize:") @ string(DualAdjustedWeight)) @ "SingleInventorySize:") @ string(SingleAdjustedWeight));
        }
        if((((CurrentCarryBlocks + DualAdjustedWeight) - SingleAdjustedWeight) <= MaxCarryBlocks) || bInfiniteWeight)
        {
            return true;            
        }
        else
        {
            return false;
        }
    }
    AdjustedWeight = WeaponClass.static.GetDefaultModifiedWeightValue(WeaponUpgradeIndex);
    if(((WeaponClass.default.InventorySize <= 0) || (CurrentCarryBlocks + AdjustedWeight) <= MaxCarryBlocks) || bInfiniteWeight)
    {
        return true;
    }
    return false;
}

simulated function CheckForExcessRemoval(KFWeapon NewWeap)
{
    local KFWeap_DualBase DualWeap;
    local Inventory RemoveInv, Inv;

    DualWeap = KFWeap_DualBase(NewWeap);
    if(DualWeap != none)
    {
        Inv = InventoryChain;
        J0x3E:

        if(Inv != none)
        {
            if(Inv.Class == DualWeap.default.SingleClass)
            {
                RemoveInv = Inv;
                Inv = Inv.Inventory;
                RemoveFromInventory(RemoveInv);
            }
            Inv = Inv.Inventory;
            goto J0x3E;
        }
    }
}

simulated function bool IsTransactionWeapon(name WeaponClassName, out TransactionItem TransactionWeapon)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == WeaponClassName)
        {
            TransactionWeapon = TransactionItems[I];
            return true;
        }
        -- I;
        goto J0x17;
    }
    return false;
}

function bool AddAmmoFromPickup(KFWeapon KFW, optional Inventory Pickup)
{
    if(GiveWeaponAmmo(KFW))
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 13,,, KFW.Class);
        PlayGiveInventorySound(AmmoPickupSound);
        return true;
    }
    return false;
}

function bool GiveWeaponAmmo(KFWeapon KFW)
{
    local bool bAddedAmmo;

    if(KFW.AddAmmo(Max(int(KFW.AmmoPickupScale[0] * float(KFW.MagazineCapacity[0])), 1)) > 0)
    {
        bAddedAmmo = true;
    }
    if(KFW.CanRefillSecondaryAmmo())
    {
        if(KFW.AddSecondaryAmmo(Max(int(KFW.AmmoPickupScale[1] * float(KFW.MagazineCapacity[1])), 1)) > 0)
        {
            bAddedAmmo = true;
        }
    }
    return bAddedAmmo;
}

function bool GiveWeaponsAmmo(bool bIncludeGrenades)
{
    local KFWeapon W;
    local bool bAddedAmmo;

    foreach InventoryActors(Class'KFWeapon', W)
    {
        if(!W.bInfiniteSpareAmmo && GiveWeaponAmmo(W))
        {
            bAddedAmmo = true;
        }        
    }    
    if(bIncludeGrenades)
    {
        if(AddGrenades(1))
        {
            bAddedAmmo = true;
        }
    }
    if(bAddedAmmo)
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 12);
        PlayGiveInventorySound(AmmoPickupSound);        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 14);
    }
    return bAddedAmmo;
}

function bool AddArmorFromPickup()
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(Instigator);
    if(KFPH.Armor != KFPH.GetMaxArmor())
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 10);
        PlayGiveInventorySound(ArmorPickupSound);
        KFPH.GiveMaxArmor();
        return true;        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 11);
        return false;
    }
}

function bool AddArmor(int Amount)
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(Instigator);
    if(KFPH.Armor != KFPH.GetMaxArmor())
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 10);
        PlayGiveInventorySound(ArmorPickupSound);
        KFPH.AddArmor(Amount);
        return true;        
    }
    else
    {
        PlayerController(Instigator.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 11);
        return false;
    }
}

function PlayGiveInventorySound(AkEvent SoundEvent)
{
    Instigator.PlaySoundBase(SoundEvent);
}

simulated function float GetEncumbranceSpeedMod()
{
    local float CarryPercent;

    CarryPercent = FMin(float(CurrentCarryBlocks) / float(MaxCarryBlocks), 1);
    return Lerp(1, 0.92, CarryPercent);
}

function KFWeapon CombineWeaponsOnPickup(KFWeapon AddedWeapon)
{
    local KFWeapon InvWeap;
    local KFWeap_DualBase AddedDual, NewDual;
    local int ExtraAmmo;
    local bool bEquipNewDual;
    local int CurrentUpgrade, NewDualUpgradeIndex;

    AddedDual = KFWeap_DualBase(AddedWeapon);
    if(AddedDual != none)
    {
        foreach InventoryActors(Class'KFWeapon', InvWeap)
        {
            if(InvWeap.Class == AddedDual.SingleClass)
            {
                CurrentUpgrade = InvWeap.CurrentWeaponUpgradeIndex;
                RemoveFromInventory(InvWeap);
                AddedDual.SetWeaponUpgradeLevel(CurrentUpgrade);
                AddedDual.AmmoCount[0] += InvWeap.AmmoCount[0];
                ExtraAmmo = Max(AddedDual.AmmoCount[0] - AddedDual.default.MagazineCapacity[0], 0);
                AddedDual.AmmoCount[0] -= ExtraAmmo;
                AddedDual.AmmoCount[1] += InvWeap.AmmoCount[1];
                AddedDual.SpareAmmoCount[0] += (InvWeap.SpareAmmoCount[0] + ExtraAmmo);
                AddedDual.SpareAmmoCount[0] = Min(AddedDual.SpareAmmoCount[0], AddedDual.default.SpareAmmoCapacity[0]);
                AddedDual.ClientForceAmmoUpdate(byte(AddedDual.AmmoCount[0]), AddedDual.SpareAmmoCount[0]);
                AddedDual.ClientForceSecondaryAmmoUpdate(byte(AddedDual.AmmoCount[1]));
                AddedDual.bGivenAtStart = AddedWeapon.bGivenAtStart;
                break;
            }            
        }                
    }
    else
    {
        if(AddedWeapon.DualClass != none)
        {
            foreach InventoryActors(Class'KFWeapon', InvWeap)
            {
                if((InvWeap != AddedWeapon) && InvWeap.Class == AddedWeapon.Class)
                {
                    bEquipNewDual = Instigator.Weapon == InvWeap;
                    RemoveFromInventory(InvWeap);
                    RemoveFromInventory(AddedWeapon);
                    NewDual = KFWeap_DualBase(CreateInventory(AddedWeapon.DualClass, true));
                    if(NewDual != none)
                    {
                        NewDual.AmmoCount[0] = InvWeap.AmmoCount[0] + AddedWeapon.AmmoCount[0];
                        ExtraAmmo = Max(NewDual.AmmoCount[0] - NewDual.default.MagazineCapacity[0], 0);
                        NewDual.AmmoCount[0] -= ExtraAmmo;
                        NewDual.AmmoCount[1] = InvWeap.AmmoCount[1] + AddedWeapon.AmmoCount[1];
                        NewDual.SpareAmmoCount[0] = Min((InvWeap.SpareAmmoCount[0] + AddedWeapon.SpareAmmoCount[0]) + ExtraAmmo, NewDual.SpareAmmoCapacity[0]);
                        NewDual.bGivenAtStart = AddedWeapon.bGivenAtStart;
                        NewDual.ClientForceAmmoUpdate(byte(NewDual.AmmoCount[0]), NewDual.SpareAmmoCount[0]);
                        NewDual.ClientForceSecondaryAmmoUpdate(byte(NewDual.AmmoCount[1]));
                        NewDualUpgradeIndex = Max(InvWeap.CurrentWeaponUpgradeIndex, AddedWeapon.CurrentWeaponUpgradeIndex);
                        NewDual.SetWeaponUpgradeLevel(NewDualUpgradeIndex);
                        if(NewDual.CurrentWeaponUpgradeIndex > 0)
                        {
                            AddCurrentCarryBlocks(NewDual.GetUpgradeWeight(NewDual.CurrentWeaponUpgradeIndex));
                            KFPawn(NewDual.Instigator).NotifyInventoryWeightChanged();
                        }
                        if(bEquipNewDual)
                        {
                            SetCurrentWeapon(NewDual);
                        }
                        AddedWeapon = NewDual;
                    }
                    break;
                }                
            }            
        }
    }
    return AddedWeapon;
}

reliable server function ServerCloseTraderMenu()
{
    local int I;
    local KFWeapon KFWeap;
    local class<KFWeapon> KFWClass;

    bServerTraderMenuOpen = false;
    bSuppressPickupMessages = true;
    I = TransactionItems.Length - 1;
    J0x2F:

    if(I >= 0)
    {
        KFWClass = class<KFWeapon>(DynamicLoadObject(TransactionItems[I].DLOString, Class'Class'));
        if(KFWClass != none)
        {
            AddCurrentCarryBlocks(-1 * (KFWClass.default.InventorySize + TransactionItems[I].AddedWeight));
            KFWeap = KFWeapon(CreateInventory(KFWClass));
            if(KFWeap != none)
            {
                AddCurrentCarryBlocks(TransactionItems[I].AddedWeight);
                KFWeap.AddTransactionAmmo(TransactionItems[I].AddedAmmo[0], TransactionItems[I].AddedAmmo[1]);
                KFWeap.SetWeaponUpgradeLevel(TransactionItems[I].WeaponUpgradeLevel);
            }
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ string(KFWClass));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, string(KFWClass));
            }
        }
        TransactionItems.Remove(I, 1;
        -- I;
        goto J0x2F;
    }
    bSuppressPickupMessages = false;
}

final simulated function BuyAmmo(float AmountPurchased, KFGFxMenu_Trader.EItemType ItemType, optional byte ItemIndex, optional bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local byte MagAmmoCount;

    MagAmmoCount = 255;
    if(ItemType == 0)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            if(GetWeaponFromClass(KFW, WeaponItem.ClassName))
            {
                MagAmmoCount = byte(((bSecondaryAmmo) ? KFW.AmmoCount[1] : KFW.AmmoCount[0]));
            }
        }
        ServerBuyAmmo(int(AmountPurchased), MagAmmoCount, ItemIndex, bSecondaryAmmo);        
    }
    else
    {
        if(ItemType == 1)
        {
            ServerBuyArmor(AmountPurchased);            
        }
        else
        {
            if(ItemType == 3)
            {
                ServerBuyGrenade(int(AmountPurchased));
            }
        }
    }
}

private reliable server final function ServerBuyAmmo(int AmountPurchased, byte ClientAmmoCount, byte ItemIndex, bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local int ClientMaxMagCapacity;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            if(!ProcessAmmoDosh(WeaponItem, AmountPurchased, bSecondaryAmmo))
            {
                return;
            }
            if(GetWeaponFromClass(KFW, WeaponItem.ClassName))
            {
                if(bSecondaryAmmo)
                {
                    KFW.AddSecondaryAmmo(AmountPurchased);
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "S.Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "S.ammo", string(KFW.Class), "#" $ string(AmountPurchased));
                    }                    
                }
                else
                {
                    if(ClientAmmoCount != 255)
                    {
                        ClientMaxMagCapacity = KFW.default.MagazineCapacity[0];
                        if(KFW.GetPerk() != none)
                        {
                            KFW.GetPerk().ModifyMagSizeAndNumber(KFW, ClientMaxMagCapacity);
                        }
                        KFW.AmmoCount[0] = Clamp(ClientAmmoCount, 0, ClientMaxMagCapacity);
                    }
                    KFW.AddAmmo(AmountPurchased);
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Ammo,") @ string(KFW.Class)) $ ",") @ string(AmountPurchased));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "ammo", string(KFW.Class), "#" $ string(AmountPurchased));
                    }
                }                
            }
            else
            {
                ServerAddTransactionAmmo(AmountPurchased, ItemIndex, bSecondaryAmmo);
            }
        }
    }
}

private reliable server final event ServerAddTransactionAmmo(int AmountAdded, byte ItemIndex, bool bSecondaryAmmo)
{
    local STraderItem WeaponItem;
    local byte AmmoTypeIndex;
    local int TransactionIndex;

    if(bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            TransactionIndex = GetTransactionItemIndex(WeaponItem.ClassName);
            if(TransactionIndex != -1)
            {
                AmmoTypeIndex = byte(bSecondaryAmmo);
                TransactionItems[TransactionIndex].AddedAmmo[AmmoTypeIndex] += AmountAdded;
                if(bSecondaryAmmo)
                {
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "S.Ammo,") @ string(WeaponItem.ClassName)) $ ",") @ string(AmountAdded));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "S.ammo", string(WeaponItem.ClassName), "#" $ string(AmountAdded));
                    }                    
                }
                else
                {
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Ammo,") @ string(WeaponItem.ClassName)) $ ",") @ string(AmountAdded));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "ammo", string(WeaponItem.ClassName), "#" $ string(AmountAdded));
                    }
                }
            }
        }
    }
}

final simulated function BuyUpgrade(byte ItemIndex, int CurrentUpgradeLevel)
{
    local STraderItem WeaponItem;
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Instigator.Owner);
    if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
    {
        KFPC.GetPurchaseHelper().AddDosh(-WeaponItem.WeaponDef.static.GetUpgradePrice(CurrentUpgradeLevel));
        KFPC.GetPurchaseHelper().AddBlocks(-GetDisplayedBlocksRequiredFor(WeaponItem));
        KFPC.GetPurchaseHelper().AddBlocks(GetDisplayedBlocksRequiredFor(WeaponItem, CurrentUpgradeLevel + 1));
        ServerBuyUpgrade(ItemIndex, CurrentUpgradeLevel);
    }
}

private reliable server final function ServerBuyUpgrade(byte ItemIndex, int CurrentUpgradeLevel)
{
    local STraderItem WeaponItem;
    local KFWeapon KFW;
    local int NewUpgradeLevel;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(WeaponItem, ItemIndex))
        {
            if(!ProcessUpgradeDosh(WeaponItem, CurrentUpgradeLevel))
            {
                return;
            }
            NewUpgradeLevel = CurrentUpgradeLevel + 1;
            if(GetWeaponFromClass(KFW, WeaponItem.ClassName))
            {
                if(KFW != none)
                {
                    KFW.SetWeaponUpgradeLevel(NewUpgradeLevel);
                    if(CurrentUpgradeLevel > 0)
                    {
                        AddCurrentCarryBlocks(-KFW.GetUpgradeStatAdd(0, CurrentUpgradeLevel));
                    }
                    AddCurrentCarryBlocks(KFW.GetUpgradeStatAdd(0, NewUpgradeLevel));
                    if(Class'KFGameInfo'.static.AllowBalanceLogging())
                    {
                        WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Upgrade,") @ string(KFW.Class)) $ ",") @ string(NewUpgradeLevel));
                    }
                    if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
                    {
                        WorldInfo.TWLogEvent("upgrade", Instigator.PlayerReplicationInfo, "upgrade", string(KFW.Class), "#" $ string(NewUpgradeLevel));
                    }
                }                
            }
            else
            {
                ServerAddTransactionUpgrade(ItemIndex, NewUpgradeLevel);
            }
        }
    }
}

private reliable server final event ServerAddTransactionUpgrade(int ItemIndex, int NewUpgradeLevel)
{
    if(bServerTraderMenuOpen)
    {
        AddTransactionUpgrade(ItemIndex, NewUpgradeLevel);
    }
}

final function AddTransactionUpgrade(int ItemIndex, int NewUpgradeLevel)
{
    local STraderItem WeaponItem;
    local int TransactionIndex;

    if((Role < ROLE_Authority) || !bServerTraderMenuOpen)
    {
        return;
    }
    if(GetTraderItemFromWeaponLists(WeaponItem, byte(ItemIndex)))
    {
        TransactionIndex = GetTransactionItemIndex(WeaponItem.ClassName);
        if(TransactionIndex != -1)
        {
            TransactionItems[TransactionIndex].WeaponUpgradeLevel = NewUpgradeLevel;
            TransactionItems[TransactionIndex].AddedWeight = WeaponItem.WeaponUpgradeWeight[NewUpgradeLevel];
            if(NewUpgradeLevel > 0)
            {
                AddCurrentCarryBlocks(-WeaponItem.WeaponUpgradeWeight[NewUpgradeLevel - 1]);
            }
            AddCurrentCarryBlocks(WeaponItem.WeaponUpgradeWeight[NewUpgradeLevel]);
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Upgrade,") @ string(WeaponItem.ClassName)) $ ",") @ string(NewUpgradeLevel));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("upgrade", Instigator.PlayerReplicationInfo, "upgrade", string(WeaponItem.ClassName), "#" $ string(NewUpgradeLevel));
            }
        }
    }
}

private reliable server final function ServerBuyArmor(float PercentPurchased)
{
    local KFPawn_Human KFP;
    local int AmountPurchased;
    local float MaxArmor;

    KFP = KFPawn_Human(Instigator);
    if(((Role == ROLE_Authority) && KFP != none) && bServerTraderMenuOpen)
    {
        if(ProcessArmorDosh(PercentPurchased))
        {
            MaxArmor = float(KFP.GetMaxArmor());
            AmountPurchased = FCeil(MaxArmor * (PercentPurchased / 100));
            KFP.AddArmor(AmountPurchased);
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance(((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Armor,") @ string(PercentPurchased));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "armor", "#" $ string(PercentPurchased));
            }
        }
    }
}

private reliable server final function ServerBuyGrenade(int AmountPurchased)
{
    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(ProcessGrenadeDosh(AmountPurchased))
        {
            AddGrenades(AmountPurchased);
            if(Class'KFGameInfo'.static.AllowBalanceLogging())
            {
                WorldInfo.LogGameBalance((((((string('Buy') $ ",") $ Instigator.PlayerReplicationInfo.PlayerName) $ ",") $ "Grenades(s),") $ ",") @ string(AmountPurchased));
            }
            if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
            {
                WorldInfo.TWLogEvent("buy", Instigator.PlayerReplicationInfo, "grenades", "#" $ string(AmountPurchased));
            }
        }
    }
}

reliable server final function ServerBuyWeapon(byte ItemIndex, optional byte WeaponUpgrade)
{
    local STraderItem PurchasedItem;
    local int BlocksRequired;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(PurchasedItem, ItemIndex))
        {
            BlocksRequired = GetWeaponBlocks(PurchasedItem, WeaponUpgrade);
            if((CurrentCarryBlocks > (CurrentCarryBlocks + BlocksRequired)) || !ProcessWeaponDosh(PurchasedItem))
            {
                return;
            }
            if(bLogInventory)
            {
                LogInternal("ServerBuyWeapon: Adding transaction item" @ string(PurchasedItem.ClassName));
            }
            AddTransactionItem(PurchasedItem, WeaponUpgrade);
        }
    }
}

function AddCurrentCarryBlocks(int AddAmount)
{
    CurrentCarryBlocks += byte(AddAmount);
}

final function AddTransactionItem(const out STraderItem ItemToAdd, optional byte WeaponUpgrade)
{
    local TransactionItem NewTransactionItem;

    if((Role < ROLE_Authority) || !bServerTraderMenuOpen)
    {
        return;
    }
    NewTransactionItem.ClassName = ItemToAdd.ClassName;
    NewTransactionItem.DLOString = ItemToAdd.WeaponDef.default.WeaponClassPath;
    NewTransactionItem.AddedAmmo[0] = 0;
    NewTransactionItem.AddedAmmo[1] = 0;
    NewTransactionItem.WeaponUpgradeLevel = WeaponUpgrade;
    TransactionItems.AddItem(NewTransactionItem;
    AddCurrentCarryBlocks(GetWeaponBlocks(ItemToAdd, WeaponUpgrade));
}

reliable server final function ServerAddTransactionItem(byte ItemIndex, optional byte WeaponUpgrade)
{
    local STraderItem PurchasedItem;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(PurchasedItem, ItemIndex))
        {
            AddTransactionItem(PurchasedItem, WeaponUpgrade);
        }
    }
}

reliable server final function ServerSellWeapon(byte ItemIndex)
{
    local STraderItem SoldItem;
    local int SellPrice, TransactionIndex;
    local KFWeapon KFW;
    local KFPlayerReplicationInfo KFPRI;

    if((Role == ROLE_Authority) && bServerTraderMenuOpen)
    {
        KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
        if((KFPRI != none) && GetTraderItemFromWeaponLists(SoldItem, ItemIndex))
        {
            if(GetWeaponFromClass(KFW, SoldItem.ClassName))
            {
                if(bLogInventory)
                {
                    LogInternal("ServerSellWeapon: Calling ServerRemoveFromInventory on" @ string(SoldItem.ClassName));
                }
                SellPrice = GetAdjustedSellPriceFor(SoldItem);
                KFPRI.AddDosh(SellPrice);
                ServerRemoveFromInventory(KFW);
                KFW.Destroy();                
            }
            else
            {
                TransactionIndex = GetTransactionItemIndex(SoldItem.ClassName);
                if(bLogInventory)
                {
                    LogInternal((("ServerSellWeapon: SoldItem=" $ string(SoldItem.ClassName)) @ "TransactionIndex=") $ string(TransactionIndex));
                }
                if(TransactionIndex != -1)
                {
                    SellPrice = GetAdjustedSellPriceFor(SoldItem);
                    KFPRI.AddDosh(SellPrice);
                    if(bLogInventory)
                    {
                        LogInternal("ServerSellWeapon: Calling RemoveTransactionItem on" @ string(SoldItem.ClassName));
                    }
                    RemoveTransactionItem(SoldItem);
                }
            }
        }
    }
}

final function RemoveTransactionItem(const out STraderItem ItemToRemove)
{
    local int TransactionIndex, I;

    if(bLogInventory)
    {
        LogInternal("RemoveTransactionItem: ItemToRemove=" $ string(ItemToRemove.ClassName));
    }
    if((Role < ROLE_Authority) || !bServerTraderMenuOpen)
    {
        return;
    }
    TransactionIndex = GetTransactionItemIndex(ItemToRemove.ClassName);
    if(bLogInventory)
    {
        LogInternal("RemoveTransactionItem: TransactionIndex=" $ string(TransactionIndex));
    }
    if(bLogInventory)
    {
        I = 0;
        J0x10C:

        if(I < TransactionItems.Length)
        {
            if(bLogInventory)
            {
                LogInternal((("RemoveTransactionItem: TransactionItems[" $ string(I)) $ "]=") $ string(TransactionItems[I].ClassName));
            }
            ++ I;
            goto J0x10C;
        }
    }
    if(TransactionIndex != -1)
    {
        AddCurrentCarryBlocks(-GetDisplayedBlocksRequiredFor(ItemToRemove, TransactionItems[TransactionIndex].WeaponUpgradeLevel));
        TransactionItems.Remove(TransactionIndex, 1;
    }
    if(bLogInventory)
    {
        I = 0;
        J0x22E:

        if(I < TransactionItems.Length)
        {
            if(bLogInventory)
            {
                LogInternal((("RemoveTransactionItem: TransactionItems[" $ string(I)) $ "]=") $ string(TransactionItems[I].ClassName));
            }
            ++ I;
            goto J0x22E;
        }
    }
}

reliable server final function ServerRemoveTransactionItem(int ItemIndex)
{
    local STraderItem ItemToRemove;
    local KFWeapon InvWeap;

    if(bServerTraderMenuOpen)
    {
        if(GetTraderItemFromWeaponLists(ItemToRemove, byte(ItemIndex)))
        {
            RemoveTransactionItem(ItemToRemove);
            if(GetWeaponFromClass(InvWeap, ItemToRemove.ClassName))
            {
                RemoveFromInventory(InvWeap);
            }
        }
    }
}

final function int GetTransactionItemIndex(name ClassName)
{
    local int I;

    I = TransactionItems.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            return I;
        }
        -- I;
        goto J0x17;
    }
    return -1;
}

final simulated function bool GetWeaponFromClass(out KFWeapon KFW, name ClassName)
{
    local Inventory Item;

    Item = InventoryChain;
    J0x13:

    if(Item != none)
    {
        if(Item.Class.Name == ClassName)
        {
            KFW = KFWeapon(Item);
            return KFW != none;
        }
        Item = Item.Inventory;
        goto J0x13;
    }
    return false;
}

private final function bool ProcessWeaponDosh(out STraderItem PurchasedItem)
{
    local int BuyPrice;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        BuyPrice = GetAdjustedBuyPriceFor(PurchasedItem);
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    if(bLogInventory)
    {
        LogInternal("Server failed to process " @ string(PurchasedItem.ClassName));
    }
    return false;
}

private final function bool ProcessAmmoDosh(out STraderItem PurchasedItem, int AdditionalAmmo, optional bool bSecondaryAmmo)
{
    local int BuyPrice;
    local float PricePerMag, MagSize, AmmoCostScale;
    local KFPlayerReplicationInfo KFPRI;
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFGRI != none)
    {
        AmmoCostScale = KFGRI.GameAmmoCostScale;        
    }
    else
    {
        AmmoCostScale = 1;
    }
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        if(bSecondaryAmmo)
        {
            PricePerMag = AmmoCostScale * float(PurchasedItem.WeaponDef.default.SecondaryAmmoMagPrice);
            MagSize = float(PurchasedItem.WeaponDef.default.SecondaryAmmoMagSize);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));            
        }
        else
        {
            PricePerMag = AmmoCostScale * float(PurchasedItem.WeaponDef.default.AmmoPricePerMag);
            MagSize = float(PurchasedItem.MagazineCapacity);
            BuyPrice = FCeil((PricePerMag / MagSize) * float(AdditionalAmmo));
        }
        if((KFPRI.Score - float(BuyPrice)) >= float(0))
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    if(bLogInventory)
    {
        LogInternal(("Server failed to process " @ string(PurchasedItem.ClassName)) @ "Ammo");
    }
    return false;
}

private final function bool ProcessUpgradeDosh(const out STraderItem PurchasedItem, int NewUpgradeLevel)
{
    local int BuyPrice;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo KFPRI;

    KFPC = KFPlayerController(Instigator.Owner);
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if((KFPC != none) && KFPRI != none)
    {
        BuyPrice = PurchasedItem.WeaponDef.static.GetUpgradePrice(NewUpgradeLevel);
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    return false;
}

private final function bool ProcessGrenadeDosh(int AmountPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo KFPRI;

    KFPC = KFPlayerController(Instigator.Owner);
    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if((KFPC != none) && KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        BuyPrice = TraderItems.GrenadePrice * AmountPurchased;
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy grenades");
    return false;
}

private final function bool ProcessArmorDosh(float PercentPurchased)
{
    local int BuyPrice;
    local KFGFxObject_TraderItems TraderItems;
    local KFPlayerController KFPC;
    local KFPerk CurrentPerk;
    local int ArmorPricePerPercent;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        TraderItems = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
        ArmorPricePerPercent = TraderItems.ArmorPrice;
        KFPC = KFPlayerController(Instigator.Owner);
        if(KFPC != none)
        {
            CurrentPerk = KFPC.GetPerk();
            if(CurrentPerk != none)
            {
                ArmorPricePerPercent *= CurrentPerk.GetArmorDiscountMod();
            }
        }
        BuyPrice = FCeil(float(ArmorPricePerPercent) * PercentPurchased);
        if(float(BuyPrice) <= KFPRI.Score)
        {
            KFPRI.AddDosh(-BuyPrice);
            return true;
        }
    }
    LogInternal("Server failed to buy armor");
    return false;
}

private final simulated function int GetWeaponUpgradeLevelFromTransactionItems(const out STraderItem TraderItem)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < TransactionItems.Length)
    {
        if(TransactionItems[I].ClassName == TraderItem.ClassName)
        {
            return TransactionItems[I].WeaponUpgradeLevel;
        }
        ++ I;
        goto J0x0B;
    }
    return 0;
}

private final simulated function bool GetTraderItemFromWeaponLists(out STraderItem TraderItem, byte ItemIndex)
{
    local KFGFxObject_TraderItems TraderItemsObject;

    TraderItemsObject = KFGameReplicationInfo(WorldInfo.GRI).TraderItems;
    if(ItemIndex < TraderItemsObject.SaleItems.Length)
    {
        TraderItem = TraderItemsObject.SaleItems[ItemIndex];
        return true;
    }
    return false;
}

simulated function int GetAdjustedBuyPriceFor(const out STraderItem ShopItem, const optional array<SItemInformation> TraderOwnedItems)
{
    local int AdjustedBuyPrice, I;
    local KFPlayerController KFPC;
    local KFPerk CurrentPerk;
    local KFPlayerReplicationInfo KFPRI;

    AdjustedBuyPrice = ShopItem.WeaponDef.default.BuyPrice;
    if(ShopItem.SingleClassName != 'None')
    {
        if(GetIsOwned(ShopItem.SingleClassName))
        {
            AdjustedBuyPrice *= 0.5;            
        }
        else
        {
            if(TraderOwnedItems.Length > 0)
            {
                I = 0;
                J0xBD:

                if(I < TraderOwnedItems.Length)
                {
                    if(TraderOwnedItems[I].DefaultItem.ClassName == ShopItem.SingleClassName)
                    {
                        AdjustedBuyPrice *= 0.5;
                        goto J0x150;
                    }
                    ++ I;
                    goto J0xBD;
                }
            }
        }
    }
    J0x150:

    KFPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPC = KFPlayerController(Instigator.Owner);
        if(KFPC != none)
        {
            CurrentPerk = KFPC.GetPerk();
            if(CurrentPerk != none)
            {
                if(ShopItem.AssociatedPerkClasses.Find(CurrentPerk.Class == -1)
                {
                    AdjustedBuyPrice *= OffPerkCostScale;
                }
            }
        }
    }
    return AdjustedBuyPrice;
}

simulated function int GetAdjustedSellPriceFor(const out STraderItem OwnedItem, const optional array<SItemInformation> TraderOwnedItems)
{
    local int AdjustedSellPrice;
    local KFWeapon OwnedWeapon;
    local TransactionItem TransactionWeapon;
    local int OwnedItemIdx, ItemUpgradeLevel;
    local float OverridenSellPriceModifier;

    if(OwnedItem.WeaponDef == Class'KFWeapDef_9mm')
    {
        return 0;
    }
    OverridenSellPriceModifier = ((OwnedItem.WeaponDef == Class'KFWeapDef_Doshinegun') ? DoshinegunSellModifier : SellPriceModifier);
    GetWeaponFromClass(OwnedWeapon, OwnedItem.ClassName);
    if((OwnedWeapon != none) && OwnedWeapon.bGivenAtStart)
    {
        AdjustedSellPrice = int(float(OwnedItem.WeaponDef.default.BuyPrice) * StartedWithWeaponPriceModifier);        
    }
    else
    {
        AdjustedSellPrice = int(float(OwnedItem.WeaponDef.default.BuyPrice) * OverridenSellPriceModifier);
    }
    OwnedItemIdx = TraderOwnedItems.Find('DefaultItem', OwnedItem;
    if(OwnedItemIdx != -1)
    {
        ItemUpgradeLevel = TraderOwnedItems[OwnedItemIdx].ItemUpgradeLevel;        
    }
    else
    {
        if(IsTransactionWeapon(OwnedItem.ClassName, TransactionWeapon))
        {
            ItemUpgradeLevel = TransactionWeapon.WeaponUpgradeLevel;            
        }
        else
        {
            if(OwnedWeapon != none)
            {
                ItemUpgradeLevel = OwnedWeapon.CurrentWeaponUpgradeIndex;
            }
        }
    }
    if(ItemUpgradeLevel > 0)
    {
        AdjustedSellPrice += OwnedItem.WeaponDef.static.GetUpgradeSellPrice(ItemUpgradeLevel - 1);
    }
    if(OwnedItem.SingleClassName == 'KFWeap_Pistol_9mm')
    {
        AdjustedSellPrice *= 0.5;
    }
    return AdjustedSellPrice;
}

simulated function int GetAdjustedUpgradePriceFor(const out STraderItem TraderItem, int UpgradeLevel)
{
    return TraderItem.WeaponDef.static.GetUpgradePrice(UpgradeLevel);
}

simulated function bool ItemEligableForUpgrade(const out STraderItem OwnedItem)
{
    local KFWeapon WeaponToUpgrade;

    if(GetWeaponFromClass(WeaponToUpgrade, OwnedItem.ClassName))
    {
        return WeaponToUpgrade.CanUpgradeWeapon();
    }
    return false;
}

simulated function int GetDisplayedBlocksRequiredFor(const out STraderItem ShopItem, optional int OverrideLevelValue)
{
    local int BlocksRequired;

    OverrideLevelValue = -1;
    BlocksRequired = GetWeaponBlocks(ShopItem, OverrideLevelValue);
    if(!(ShopItem.SingleClassName == 'None') || ShopItem.SingleClassName == 'KFWeap_Pistol_9mm' && GetIsOwned(ShopItem.SingleClassName))
    {
        BlocksRequired /= float(2);
    }
    return BlocksRequired;
}

simulated function int GetWeaponBlocks(const out STraderItem ShopItem, optional int OverrideLevelValue)
{
    local int ItemUpgradeLevel;
    local KFPlayerController KFPC;
    local Inventory InventoryItem;

    OverrideLevelValue = -1;
    KFPC = KFPlayerController(Instigator.Owner);
    if(((ShopItem.SingleClassName != 'None') && OverrideLevelValue == -1) && ClassNameIsInInventory(ShopItem.SingleClassName, InventoryItem))
    {
        ItemUpgradeLevel = KFWeapon(InventoryItem).CurrentWeaponUpgradeIndex;        
    }
    else
    {
        ItemUpgradeLevel = ((OverrideLevelValue != -1) ? OverrideLevelValue : KFPC.GetPurchaseHelper().GetItemUpgradeLevelByClassName(ShopItem.ClassName));
    }
    return ShopItem.BlocksRequired + ((ItemUpgradeLevel > -1) ? ShopItem.WeaponUpgradeWeight[ItemUpgradeLevel] : 0);
}

simulated function bool GetIsOwned(name ClassName)
{
    local int I;
    local Inventory Inv;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Inv.Class.Name == ClassName)
        {
            if(bLogInventory)
            {
                LogInternal(("GetIsOwned: ClassName=" $ string(ClassName)) @ "InventoryActors true");
            }            
            return true;
        }        
    }    
    I = 0;
    J0xBD:

    if(I < TransactionItems.Length)
    {
        if(TransactionItems[I].ClassName == ClassName)
        {
            if(bLogInventory)
            {
                LogInternal(((("GetIsOwned: i=" $ string(I)) @ "ClassName=") $ string(ClassName)) @ "TransactionItems true");
            }
            return true;
        }
        ++ I;
        goto J0xBD;
    }
    if(bLogInventory)
    {
        LogInternal(("GetIsOwned: ClassName=" $ string(ClassName)) @ "false");
    }
    return false;
}

simulated event DiscardInventory()
{
    local Inventory Inv;
    local KFPawn KFP;

    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Instigator.Weapon != Inv)
        {
            Inv.bDropOnDeath = false;
        }        
    }    
    super.DiscardInventory();
    KFP = KFPawn(Instigator);
    if(KFP != none)
    {
        KFP.MyKFWeapon = none;
    }
}

defaultproperties
{
    FullHealthMsg="Health Full"
    CannotHealthMsg="You can't heal yourself"
    MaxCarryBlocks=15
    AmmoPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Ammo'
    ItemPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Weapon'
    ArmorPickupSound=AkEvent'WW_UI_PlayerCharacter.Play_UI_Pickup_Armor'
    SwitchFireModeEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_ModeSwitch'
    StartedWithWeaponPriceModifier=0.5
    SellPriceModifier=0.75
    DoshinegunSellModifier=0.167
    OffPerkCostScale=1
    bMustHoldWeapon=true
    PendingFire=/* Array type was not detected. */
}