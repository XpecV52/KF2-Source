/*******************************************************************************
 * KFAfflictionManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAfflictionManager extends Object within KFPawn
    native(Pawn);

const STUN_GUARANTEED_POWER = 10000.f;

enum EHitZoneBodyPart
{
    BP_Torso,
    BP_Head,
    BP_LeftArm,
    BP_RightArm,
    BP_LeftLeg,
    BP_RightLeg,
    BP_Special,
    BP_MAX
};

enum EAfflictionVulnerabilityType
{
    AV_Default,
    AV_Head,
    AV_Legs,
    AV_Arms,
    AV_Special,
    AV_MAX
};

enum EAfflictionType
{
    AF_EMP,
    AF_FirePanic,
    AF_MeleeHit,
    AF_GunHit,
    AF_Stumble,
    AF_Stun,
    AF_Poison,
    AF_Snare,
    AF_Knockdown,
    AF_Freeze,
    AF_Microwave,
    AF_Bleed,
    AF_Custom1,
    AF_Custom2,
    AF_Custom3,
    EAfflictionType_Blank,
    EAfflictionType_MAX
};

struct native IncapSettingsInfo
{
    /** How long this incap lasts once triggered.  Only applies to non-specialmove entries */
    var() float Duration;
    /** How long this pawn is immune to additional incap of this type.  If > 0, resets strength to zero on activation */
    var() float Cooldown;
    /** How long this pawn is immune to additional incap of children of this type */
    var() float ChildAfflictionCooldown;
    /** Array mapped to EHitZoneBodyPart.  If out of bounds default to body (index 0) */
    var() array<float> Vulnerability;

    structdefaultproperties
    {
        Duration=5
        Cooldown=0
        ChildAfflictionCooldown=0
        Vulnerability=none
    }
};

var array< class<KFAfflictionBase> > AfflictionClasses;
var array<KFAfflictionBase> Afflictions;
var array<KFAfflictionBase> AfflictionTickArray;
var bool bDebugLog;
var float FireFullyCharredDuration;
var float FireCharPercentThreshhold;

function NotifyTakeHit(Controller DamageInstigator, Vector HitDir, class<KFDamageType> DamageType, Actor DamageCauser)
{
    local KFPerk InstigatorPerk;

    if(DamageType == none)
    {
        return;
    }
    if((DamageInstigator != none) && DamageInstigator.bIsPlayer)
    {
        InstigatorPerk = KFPlayerController(DamageInstigator).GetPerk();
    }
    if((Outer.GetTeamNum() > 254) && !Outer.bPlayedDeath)
    {
        ProcessSpecialMoveAfflictions(InstigatorPerk, HitDir, DamageType, DamageCauser);
        ProcessHitReactionAfflictions(InstigatorPerk, DamageType, DamageCauser);
    }
    ProcessEffectBasedAfflictions(InstigatorPerk, DamageType, DamageCauser);
}

function byte GetPredictedHitReaction(class<KFDamageType> DamageType, KFAfflictionManager.EHitZoneBodyPart BodyPart)
{
    if(DamageType.default.MeleeHitPower > float(0))
    {
        return 2;        
    }
    else
    {
        if(DamageType.default.GunHitPower > float(0))
        {
            return 1;
        }
    }
    return 0;
}

protected function ProcessSpecialMoveAfflictions(KFPerk InstigatorPerk, Vector HitDir, class<KFDamageType> DamageType, Actor DamageCauser)
{
    local KFAfflictionManager.EHitZoneBodyPart BodyPart;
    local byte HitZoneIdx;
    local float KnockdownPower, StumblePower, StunPower, SnarePower, FreezePower, KnockdownModifier,
	    StumbleModifier, StunModifier;

    local KFInterface_DamageCauser KFDmgCauser;
    local KFWeapon DamageWeapon;

    if(IsZero(HitDir))
    {
        return;
    }
    HitZoneIdx = Outer.HitFxInfo.HitBoneIndex;
    BodyPart = (((HitZoneIdx != 255) && HitZoneIdx < Outer.HitZones.Length) ? Outer.HitZones[HitZoneIdx].Limb : 0);
    DamageWeapon = Class'KFPerk'.static.GetWeaponFromDamageCauser(DamageCauser);
    if(DamageWeapon != none)
    {
        KnockdownPower = DamageWeapon.GetUpgradedAfflictionPower(8, DamageType.default.KnockdownPower);
        StumblePower = DamageWeapon.GetUpgradedAfflictionPower(4, DamageType.default.StumblePower);
        StunPower = DamageWeapon.GetUpgradedAfflictionPower(5, DamageType.default.StunPower);
        SnarePower = DamageWeapon.GetUpgradedAfflictionPower(7, DamageType.default.SnarePower);
        FreezePower = DamageWeapon.GetUpgradedAfflictionPower(9, DamageType.default.FreezePower);        
    }
    else
    {
        KnockdownPower = DamageType.default.KnockdownPower;
        StumblePower = DamageType.default.StumblePower;
        StunPower = DamageType.default.StunPower;
        SnarePower = DamageType.default.SnarePower;
        FreezePower = DamageType.default.FreezePower;
    }
    KFDmgCauser = KFInterface_DamageCauser(DamageCauser);
    if(NotEqual_InterfaceInterface(KFDmgCauser, (none)))
    {
        KnockdownPower *= KFDmgCauser.GetIncapMod();
        StumblePower *= KFDmgCauser.GetIncapMod();
        StunPower *= KFDmgCauser.GetIncapMod();
        SnarePower *= KFDmgCauser.GetIncapMod();
    }
    KnockdownModifier = 1;
    StumbleModifier = 1;
    StunModifier = 1;
    KnockdownModifier += (GetAfflictionKnockdownModifier());
    StumbleModifier += (GetAfflictionStumbleModifier());
    StunModifier += (GetAfflictionStunModifier());
    if(InstigatorPerk != none)
    {
        KnockdownModifier += InstigatorPerk.GetKnockdownPowerModifier(DamageType, BodyPart, Outer.bIsSprinting);
        StumbleModifier += InstigatorPerk.GetStumblePowerModifier(Outer, DamageType,, BodyPart);
        StunModifier += InstigatorPerk.GetStunPowerModifier(DamageType, HitZoneIdx);
        SnarePower += InstigatorPerk.GetSnarePowerModifier(DamageType, HitZoneIdx);
    }
    KnockdownPower *= KnockdownModifier;
    StumblePower *= StumbleModifier;
    StunPower *= StunModifier;
    if((InstigatorPerk != none) && InstigatorPerk.IsStunGuaranteed(DamageType, HitZoneIdx))
    {
        StunPower = 10000;
    }
    if((KnockdownPower > float(0)) && Outer.CanDoSpecialMove(6))
    {
        AccrueAffliction(8, KnockdownPower, BodyPart, InstigatorPerk);
    }
    if((StunPower > float(0)) && Outer.CanDoSpecialMove(8))
    {
        AccrueAffliction(5, StunPower, BodyPart, InstigatorPerk);
    }
    if((StumblePower > float(0)) && Outer.CanDoSpecialMove(4))
    {
        AccrueAffliction(4, StumblePower, BodyPart, InstigatorPerk);
    }
    if((FreezePower > float(0)) && Outer.CanDoSpecialMove(9))
    {
        AccrueAffliction(9, FreezePower, BodyPart, InstigatorPerk);
    }
    if(SnarePower > float(0))
    {
        AccrueAffliction(7, SnarePower, BodyPart, InstigatorPerk);
    }
}

protected function ProcessHitReactionAfflictions(KFPerk InstigatorPerk, class<KFDamageType> DamageType, Actor DamageCauser)
{
    local KFAfflictionManager.EHitZoneBodyPart BodyPart;
    local byte HitZoneIdx;
    local float ReactionModifier, MeleeHitPower, GunHitPower;
    local KFWeapon DamageWeapon;
    local KFInterface_DamageCauser KFDmgCauser;

    ReactionModifier = 1;
    if(InstigatorPerk != none)
    {
        ReactionModifier = InstigatorPerk.GetReactionModifier(DamageType);
    }
    if(Outer.MyKFAIC != none)
    {
        HitZoneIdx = Outer.HitFxInfo.HitBoneIndex;
        BodyPart = (((HitZoneIdx != 255) && HitZoneIdx < Outer.HitZones.Length) ? Outer.HitZones[HitZoneIdx].Limb : 0);
        DamageWeapon = Class'KFPerk'.static.GetWeaponFromDamageCauser(DamageCauser);
        if(DamageWeapon != none)
        {
            MeleeHitPower = DamageWeapon.GetUpgradedAfflictionPower(2, DamageType.default.MeleeHitPower);
            GunHitPower = DamageWeapon.GetUpgradedAfflictionPower(3, DamageType.default.GunHitPower);            
        }
        else
        {
            MeleeHitPower = DamageType.default.MeleeHitPower;
            GunHitPower = DamageType.default.GunHitPower;
        }
        KFDmgCauser = KFInterface_DamageCauser(DamageCauser);
        if(NotEqual_InterfaceInterface(KFDmgCauser, (none)))
        {
            MeleeHitPower *= KFDmgCauser.GetIncapMod();
            GunHitPower *= KFDmgCauser.GetIncapMod();
        }
        if(MeleeHitPower > float(0))
        {
            AccrueAffliction(2, MeleeHitPower * ReactionModifier, BodyPart, InstigatorPerk);
        }
        if(((HitZoneIdx == 0) && Outer.IsHeadless()) && Outer.GetTimerCount('BleedOutTimer', Outer) == 0)
        {
            AccrueAffliction(2, 100, BodyPart, InstigatorPerk);
        }
        if(GunHitPower > float(0))
        {
            AccrueAffliction(3, GunHitPower * ReactionModifier, BodyPart, InstigatorPerk);
        }
    }
}

protected function ProcessEffectBasedAfflictions(KFPerk InstigatorPerk, class<KFDamageType> DamageType, Actor DamageCauser)
{
    local KFWeapon DamageWeapon;
    local float BurnPower, EMPPower, PoisonPower, MicrowavePower, BleedPower;

    local KFInterface_DamageCauser KFDmgCauser;

    DamageWeapon = Class'KFPerk'.static.GetWeaponFromDamageCauser(DamageCauser);
    if(DamageWeapon != none)
    {
        BurnPower = DamageWeapon.GetUpgradedAfflictionPower(1, DamageType.default.BurnPower);
        EMPPower = DamageWeapon.GetUpgradedAfflictionPower(0, DamageType.default.EMPPower);
        PoisonPower = DamageWeapon.GetUpgradedAfflictionPower(6, DamageType.default.PoisonPower);
        MicrowavePower = DamageWeapon.GetUpgradedAfflictionPower(10, DamageType.default.MicrowavePower);
        BleedPower = DamageWeapon.GetUpgradedAfflictionPower(11, DamageType.default.BleedPower);        
    }
    else
    {
        BurnPower = DamageType.default.BurnPower;
        EMPPower = DamageType.default.EMPPower;
        PoisonPower = DamageType.default.PoisonPower;
        MicrowavePower = DamageType.default.MicrowavePower;
        BleedPower = DamageType.default.BleedPower;
    }
    KFDmgCauser = KFInterface_DamageCauser(DamageCauser);
    if(NotEqual_InterfaceInterface(KFDmgCauser, (none)))
    {
        BurnPower *= KFDmgCauser.GetIncapMod();
        EMPPower *= KFDmgCauser.GetIncapMod();
        PoisonPower *= KFDmgCauser.GetIncapMod();
        MicrowavePower *= KFDmgCauser.GetIncapMod();
        BleedPower *= KFDmgCauser.GetIncapMod();
    }
    if(Outer.bPlayedDeath && Outer.WorldInfo.TimeSeconds > Outer.TimeOfDeath)
    {
        if(BurnPower > float(0))
        {
            AccrueAffliction(1, BurnPower);
        }        
    }
    else
    {
        if(EMPPower > float(0))
        {
            AccrueAffliction(0, EMPPower);            
        }
        else
        {
            if((InstigatorPerk != none) && InstigatorPerk.ShouldGetDaZeD(DamageType))
            {
                AccrueAffliction(0, InstigatorPerk.GetDaZedEMPPower());
            }
        }
        if(BurnPower > float(0))
        {
            AccrueAffliction(1, BurnPower);
        }
        if((PoisonPower > float(0)) || DamageType.static.AlwaysPoisons())
        {
            AccrueAffliction(6, PoisonPower);
        }
        if(MicrowavePower > float(0))
        {
            AccrueAfflictionMicrowave(10, MicrowavePower, DamageType.default.bHasToSpawnMicrowaveFire);
        }
        if(BleedPower > float(0))
        {
            AccrueAffliction(11, BleedPower);
        }
    }
}

function AccrueAffliction(KFAfflictionManager.EAfflictionType Type, float InPower, optional KFAfflictionManager.EHitZoneBodyPart BodyPart, optional KFPerk InstigatorPerk)
{
    if((InPower <= float(0)) || Type >= Outer.IncapSettings.Length)
    {
        return;
    }
    if(!VerifyAfflictionInstance(Type, InstigatorPerk))
    {
        return;
    }
    if(Outer.HitFxInfo.bRadialDamage && Outer.HitFxRadialInfo.RadiusDamageScale != 255)
    {
        InPower *= ByteToFloat(Outer.HitFxRadialInfo.RadiusDamageScale);
        if(bDebugLog)
        {
            LogInternal((string(Type) @ "Applied damage falloff modifier of") @ string(ByteToFloat(Outer.HitFxRadialInfo.RadiusDamageScale)));
        }
    }
    if(Outer.IncapSettings[Type].Vulnerability.Length > 0)
    {
        InPower *= (GetAfflictionVulnerability(Type, BodyPart));
        if(bDebugLog)
        {
            LogInternal((((string(Type) @ "Applied hit zone vulnerability modifier of") @ string(GetAfflictionVulnerability(Type, BodyPart))) @ "for") @ string(BodyPart));
        }
    }
    Outer.AdjustAffliction(InPower);
    if(InPower > float(0))
    {
        Afflictions[Type].Accrue(InPower);
    }
}

function AccrueAfflictionMicrowave(KFAfflictionManager.EAfflictionType Type, float InPower, bool bHasToSpawnFire, optional KFAfflictionManager.EHitZoneBodyPart BodyPart, optional KFPerk InstigatorPerk)
{
    if((InPower <= float(0)) || Type >= Outer.IncapSettings.Length)
    {
        return;
    }
    if(!VerifyAfflictionInstance(Type, InstigatorPerk))
    {
        return;
    }
    if(Outer.HitFxInfo.bRadialDamage && Outer.HitFxRadialInfo.RadiusDamageScale != 255)
    {
        InPower *= ByteToFloat(Outer.HitFxRadialInfo.RadiusDamageScale);
        if(bDebugLog)
        {
            LogInternal((string(Type) @ "Applied damage falloff modifier of") @ string(ByteToFloat(Outer.HitFxRadialInfo.RadiusDamageScale)));
        }
    }
    if(Outer.IncapSettings[Type].Vulnerability.Length > 0)
    {
        InPower *= (GetAfflictionVulnerability(Type, BodyPart));
        if(bDebugLog)
        {
            LogInternal((((string(Type) @ "Applied hit zone vulnerability modifier of") @ string(GetAfflictionVulnerability(Type, BodyPart))) @ "for") @ string(BodyPart));
        }
    }
    Outer.AdjustAffliction(InPower);
    if(InPower > float(0))
    {
        KFAffliction_Microwave(Afflictions[Type]).bHasToSpawnFire = bHasToSpawnFire;
        Afflictions[Type].Accrue(InPower);
    }
}

simulated function float GetAfflictionVulnerability(KFAfflictionManager.EAfflictionType I, KFAfflictionManager.EHitZoneBodyPart BodyPart)
{
    local KFAfflictionManager.EAfflictionVulnerabilityType J;

    switch(BodyPart)
    {
        case 1:
            J = 1;
            break;
        case 2:
        case 3:
            J = 3;
            break;
        case 4:
        case 5:
            J = 2;
            break;
        case 6:
            J = 4;
            break;
        default:
            break;
    }
    if((J > 0) && J < Outer.IncapSettings[I].Vulnerability.Length)
    {
        return Outer.IncapSettings[I].Vulnerability[J];
    }
    return Outer.IncapSettings[I].Vulnerability[0];
}

simulated function bool VerifyAfflictionInstance(KFAfflictionManager.EAfflictionType Type, optional KFPerk InstigatorPerk)
{
    if((Type >= Afflictions.Length) || Afflictions[Type] == none)
    {
        if((Type < AfflictionClasses.Length) && AfflictionClasses[Type] != none)
        {
            Afflictions[Type] = new (Outer) AfflictionClasses[Type];
            Afflictions[Type].Init(Outer, Type, InstigatorPerk);            
        }
        else
        {
            LogInternal(((((string(GetFuncName()) @ "Failed with afflication:") @ string(Type)) @ "class:") @ string(AfflictionClasses[Type])) @ string(self));
            Afflictions[Type] = none;
            return false;
        }
    }
    return true;
}

function float GetAfflictionDuration(KFAfflictionManager.EAfflictionType Type)
{
    if(Type < Outer.IncapSettings.Length)
    {
        return Outer.IncapSettings[Type].Duration;
    }
}

function float GetAfflictionKnockdownModifier()
{
    local float KnockdownModifier;
    local int I;

    KnockdownModifier = 0;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            KnockdownModifier += Afflictions[I].GetKnockdownModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return KnockdownModifier;
}

function float GetAfflictionStumbleModifier()
{
    local float StumbleModifier;
    local int I;

    StumbleModifier = 0;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            StumbleModifier += Afflictions[I].GetStumbleModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return StumbleModifier;
}

function float GetAfflictionStunModifier()
{
    local float StunModifier;
    local int I;

    StunModifier = 0;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            StunModifier += Afflictions[I].GetStunModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return StunModifier;
}

function float GetAfflictionDamageModifier()
{
    local float DamageModifier;
    local int I;

    DamageModifier = 1;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            DamageModifier += Afflictions[I].GetDamageModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return DamageModifier;
}

function float GetAfflictionSpeedModifier()
{
    local float SpeedModifier;
    local int I;

    SpeedModifier = 1;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            SpeedModifier *= Afflictions[I].GetSpeedModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return SpeedModifier;
}

function float GetAfflictionAttackSpeedModifier()
{
    local float SpeedModifier;
    local int I;

    SpeedModifier = 1;
    I = 0;
    J0x1A:

    if(I < Afflictions.Length)
    {
        if(Afflictions[I] != none)
        {
            SpeedModifier *= Afflictions[I].GetAttackSpeedModifier();
        }
        ++ I;
        goto J0x1A;
    }
    return SpeedModifier;
}

simulated function ShutDown()
{
    local int I;

    I = Afflictions.Length - 1;
    J0x17:

    if(I >= 0)
    {
        if(Afflictions[I] != none)
        {
            Afflictions[I].ShutDown();
        }
        -- I;
        goto J0x17;
    }
}

function ToggleEffects(KFAfflictionManager.EAfflictionType Type, bool bPrimary, optional bool bSecondary)
{
    if(Outer.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(Outer.bPlayedDeath)
    {
        return;
    }
    if((Type >= Afflictions.Length) || Afflictions[Type] == none)
    {
        if((!bPrimary && !bSecondary) || !VerifyAfflictionInstance(Type))
        {
            return;
        }
    }
    Afflictions[Type].ToggleEffects(bPrimary, bSecondary);
}

function UpdateMaterialParameter(KFAfflictionManager.EAfflictionType Type, float Value)
{
    if(Outer.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if((Type >= Afflictions.Length) || Afflictions[Type] == none)
    {
        if((Value == float(0)) || !VerifyAfflictionInstance(Type))
        {
            return;
        }
    }
    Afflictions[Type].SetMaterialParameter(Value);
}

defaultproperties
{
    AfflictionClasses(0)=class'KFAffliction_EMP'
    AfflictionClasses(1)=class'KFAffliction_Fire'
    AfflictionClasses(2)=class'KFAffliction_HeavyRecovery'
    AfflictionClasses(3)=class'KFAffliction_MediumRecovery'
    AfflictionClasses(4)=class'KFAffliction_Stumble'
    AfflictionClasses(5)=class'KFAffliction_Stun'
    AfflictionClasses(6)=class'KFAffliction_Poison'
    AfflictionClasses(7)=class'KFAffliction_Snare'
    AfflictionClasses(8)=class'KFAffliction_Knockdown'
    AfflictionClasses(9)=class'KFAffliction_Freeze'
    AfflictionClasses(10)=class'KFAffliction_Microwave'
    AfflictionClasses(11)=class'KFAffliction_Bleed'
}