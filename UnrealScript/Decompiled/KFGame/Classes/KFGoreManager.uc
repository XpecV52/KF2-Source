/*******************************************************************************
 * KFGoreManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGoreManager extends Actor
    native(Effect)
    config(Game)
    notplaceable
    hidecategories(Navigation);

const KFID_QuickWeaponSelect = 100;
const KFID_CurrentLayoutIndex = 101;
const KFID_ForceFeedbackEnabled = 103;
const KFID_SavedPerkIndex = 105;
const KFID_AllowBloodSplatterDecals = 106;
const KFID_GoreLevel = 107;
const KFID_StoredCharIndex = 111;
const KFID_MasterVolumeMultiplier = 112;
const KFID_DialogVolumeMultiplier = 113;
const KFID_MusicVolumeMultiplier = 114;
const KFID_SFXVolumeMultiplier = 115;
const KFID_GammaMultiplier = 117;
const KFID_MusicVocalsEnabled = 118;
const KFID_MinimalChatter = 119;
const KFID_ShowCrossHair = 121;
const KFID_FOVOptionsPercentageValue = 122;
const KFID_ShowKillTicker = 123;
const KFID_FriendlyHudScale = 125;
const KFID_FavoriteWeapons = 127;
const KFID_GearLoadouts = 128;
const KFID_SetGamma = 129;
const KFID_RequiresPushToTalk = 130;
const KFID_InvertController = 131;
const KFID_AutoTargetEnabled = 132;
const KFID_GamepadSensitivityScale = 133;
const KFID_ZoomedSensitivityScale = 134;
const KFID_GamepadZoomedSensitivityScale = 135;
const KFID_EnableMouseSmoothing = 136;
const KFID_MouseSensitivity = 138;
const KFID_TargetAdhesionEnabled = 139;
const KFID_TargetFrictionEnabled = 140;
const KFID_InvertMouse = 142;
const KFID_DEPRECATED_143 = 143;
const KFID_SavedSoloModeIndex = 144;
const KFID_SavedSoloMapString = 145;
const KFID_SavedSoloDifficultyIndex = 146;
const KFID_SavedSoloLengthIndex = 147;
const KFID_SavedModeIndex = 148;
const KFID_SavedMapString = 149;
const KFID_SavedDifficultyIndex = 150;
const KFID_SavedLengthIndex = 151;
const KFID_SavedPrivacyIndex = 152;
const KFID_SavedServerTypeIndex = 153;
const KFID_SavedInProgressIndex = 154;
const KFID_ControllerSoundEnabled = 155;
const KFID_MatchmakingRegion = 156;
const KFID_UseAltAimOnDuals = 157;
const KFID_HideBossHealthBar = 158;
const KFID_AntiMotionSickness = 159;
const KFID_ShowWelderInInventory = 160;
const KFID_AutoTurnOff = 161;
const KFID_ReduceHightPitchSounds = 162;
const KFID_ShowConsoleCrossHair = 163;
const KFID_VOIPVolumeMultiplier = 164;
const KFID_WeaponSkinAssociations = 165;
const KFID_SavedEmoteId = 166;
const KFID_DisableAutoUpgrade = 167;
const KFID_SafeFrameScale = 168;
const KFID_Native4kResolution = 169;
const KFID_HideRemoteHeadshotEffects = 170;
const KFID_SavedHeadshotID = 171;
const KFID_ToggleToRun = 172;
const KFID_ClassicPlayerInfo = 173;

struct native PersistentSplatInfo
{
    var Vector Location;
    var Vector Normal;
    var float Scale;
    var bool bRandomize;
    var float TraceLength;

    structdefaultproperties
    {
        Location=(X=0,Y=0,Z=0)
        Normal=(X=0,Y=0,Z=0)
        Scale=0
        bRandomize=false
        TraceLength=0
    }
};

var transient int DesiredGoreLevel;
var globalconfig float GoreFXLifetimeMultiplier;
var globalconfig float BodyWoundDecalLifetime;
var globalconfig float BloodSplatterLifetime;
var globalconfig float BloodPoolLifetime;
var globalconfig float GibletLifetime;
var globalconfig float BloodSplatSize;
var globalconfig float BloodPoolSize;
var globalconfig int MaxBodyWoundDecals;
var globalconfig int MaxBloodSplatterDecals;
var globalconfig int MaxBloodPoolDecals;
var globalconfig bool bAllowBloodSplatterDecals;
var bool bShowPersistentBloodTraces;
var bool bLogGore;
var transient DecalManager BodyWoundDecalManager;
var transient DecalManager BloodSplatterDecalManager;
var transient DecalManager BloodPoolDecalManager;
var globalconfig int MaxBloodEffects;
var globalconfig int MaxGoreEffects;
var transient EmitterPool BloodFXEmitterPool;
var transient EmitterPool MiscGoreFXEmitterPool;
var array<KFPawn> CorpsePool;
var globalconfig int MaxDeadBodies;
var float MaxCorpseOffscreenTime;
var float MaxCorpseOffscreenDistance;
var globalconfig float PersistentSplatTraceLength;
var globalconfig int MaxPersistentSplatsPerFrame;
var transient array<PersistentSplatInfo> CurrentSplats;
var transient int CurrentSplatIdx;
var transient array<TWSplatterMapTexture2D> CachedSplattermaps;

event PostBeginPlay()
{
    local KFGameEngine KFGE;
    local KFProfileSettings KFPS;

    super.PostBeginPlay();
    if(!Class'WorldInfo'.static.IsConsoleBuild())
    {
        DesiredGoreLevel = Class'GameInfo'.default.GoreLevel;        
    }
    else
    {
        KFGE = KFGameEngine(Class'Engine'.static.GetEngine());
        KFPS = KFProfileSettings(KFGE.OnlineSubsystem.PlayerInterface.GetProfileSettings(byte(KFGE.GamePlayers[0].ControllerId)));
        DesiredGoreLevel = KFPS.GetProfileInt(107);
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        BodyWoundDecalManager = Spawn(Class'DecalManager', self,, vect(0, 0, 0), rot(0, 0, 0));
        BodyWoundDecalManager.MaxActiveDecals = MaxBodyWoundDecals;
        BloodSplatterDecalManager = Spawn(Class'DecalManager', self,, vect(0, 0, 0), rot(0, 0, 0));
        BloodSplatterDecalManager.MaxActiveDecals = MaxBloodSplatterDecals;
        BloodPoolDecalManager = Spawn(Class'DecalManager', self,, vect(0, 0, 0), rot(0, 0, 0));
        BloodPoolDecalManager.MaxActiveDecals = MaxBloodPoolDecals;
        BloodFXEmitterPool = Spawn(Class'EmitterPool', self,, vect(0, 0, 0), rot(0, 0, 0));
        BloodFXEmitterPool.MaxActiveEffects = MaxBloodEffects;
        MiscGoreFXEmitterPool = Spawn(Class'EmitterPool', self,, vect(0, 0, 0), rot(0, 0, 0));
        MiscGoreFXEmitterPool.MaxActiveEffects = MaxGoreEffects;
        MaxDeadBodies = Max(MaxDeadBodies, 4);
    }
}

simulated function LeaveABodyWoundDecal(KFPawn inPawn, Vector InHitLocation, Vector InHitDirection, name InHitZone, name InHitBone, class<KFDamageType> dmgType)
{
    local Vector HitDirection, DecalProjLocation;
    local Rotator DecalOrientation;
    local editinline DecalComponent WoundDecal;
    local MaterialInterface WoundMIC;
    local editinline SkeletalMeshComponent HitComponent;
    local float BodyWoundDecalWidth, BodyWoundDecalHeight;

    if((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.bDropDetail)
    {
        return;
    }
    if(DesiredGoreLevel <= 1)
    {
        if((dmgType != none) && dmgType.default.BodyWoundDecalMaterials.Length > 0)
        {
            WoundMIC = dmgType.default.BodyWoundDecalMaterials[Rand(dmgType.default.BodyWoundDecalMaterials.Length)];
            BodyWoundDecalWidth = dmgType.default.BodyWoundDecalWidth;
            BodyWoundDecalHeight = dmgType.default.BodyWoundDecalHeight;
        }
        if(WoundMIC != none)
        {
            HitDirection = Normal(InHitDirection);
            DecalProjLocation = InHitLocation - (float(10) * HitDirection);
            DecalOrientation = rotator(-HitDirection);
            if(((InHitZone == 'head') || InHitZone == 'neck') && inPawn.ThirdPersonHeadMeshComponent != none)
            {
                HitComponent = inPawn.ThirdPersonHeadMeshComponent;                
            }
            else
            {
                HitComponent = inPawn.Mesh;
            }
            WoundDecal = BodyWoundDecalManager.SpawnDecal(WoundMIC, DecalProjLocation, DecalOrientation, BodyWoundDecalWidth, BodyWoundDecalHeight, 50, false,, HitComponent, false, true, InHitBone,,, BodyWoundDecalLifetime * GoreFXLifetimeMultiplier);
            WoundDecal.bNoClip = true;
        }
    }
}

// Export UKFGoreManager::execLeaveAPersistentBloodSplat(FFrame&, void* const)
native final simulated function LeaveAPersistentBloodSplat(Vector HitLoc, Vector HitNorm, optional float BloodScale, optional bool bRandomizeBloodScale, optional bool bForceUpdate, optional float TraceLength)
{
    BloodScale = 1;
    bRandomizeBloodScale = true;
    bForceUpdate = false;
    TraceLength = PersistentSplatTraceLength;                                
}

// Export UKFGoreManager::execPerformTraceAndUpdateSplattermap(FFrame&, void* const)
native final simulated function PerformTraceAndUpdateSplattermap(const out PersistentSplatInfo InSplat);

// Export UKFGoreManager::execClearPersistentBloodSplats(FFrame&, void* const)
native final function ClearPersistentBloodSplats();

// Export UKFGoreManager::execCacheCurrentSplattermaps(FFrame&, void* const)
native final function CacheCurrentSplattermaps();

// Export UKFGoreManager::execFlushPersistentBloodSplats(FFrame&, void* const)
native final function FlushPersistentBloodSplats();

simulated function CausePersistentBlood(KFPawn_Monster inPawn, class<KFDamageType> InDmgType, Vector InHitLocation, Vector InHitDirection, int InHitZoneIndex, bool bIsDismeberingHit, bool bWasObliterated)
{
    local array<Vector> HitSpread;
    local float BloodScale;
    local int I;

    if(InHitZoneIndex > inPawn.HitZones.Length)
    {
        return;
    }
    HitSpread.Remove(0, HitSpread.Length;
    InDmgType.static.AddBloodSpread(inPawn, InHitDirection, HitSpread, bIsDismeberingHit, bWasObliterated);
    BloodScale = InDmgType.static.GetBloodScale(((InHitZoneIndex != 255) ? inPawn.HitZones[InHitZoneIndex].DmgScale : 1), bIsDismeberingHit, bWasObliterated);
    I = 0;
    J0x12D:

    if(I < HitSpread.Length)
    {
        LeaveAPersistentBloodSplat(InHitLocation, HitSpread[I], BloodScale);
        ++ I;
        goto J0x12D;
    }
}

simulated function LeaveABloodSplatterDecal(KFPawn inPawn, Vector HitLoc, Vector HitNorm)
{
    local Actor TraceActor;
    local Vector TraceHitLoc, TraceHitNorm, TraceDest, TraceStart, TraceExtent;

    local TraceHitInfo HitInfo;
    local int DecalScaler;

    if(((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.bDropDetail) || !bAllowBloodSplatterDecals)
    {
        return;
    }
    if(DesiredGoreLevel <= 1)
    {
        TraceStart = HitLoc;
        TraceDest = HitLoc + (Normal(HitNorm) * 500);
        TraceActor = Trace(TraceHitLoc, TraceHitNorm, TraceDest, TraceStart, false, TraceExtent, HitInfo, 2);
        if((TraceActor != none) && Pawn(TraceActor) == none)
        {
            DecalScaler = Rand(50);
            BloodSplatterDecalManager.SpawnDecal(inPawn.BloodSplatterDecalMaterials[Rand(inPawn.BloodSplatterDecalMaterials.Length)], TraceHitLoc, rotator(-TraceHitNorm), BloodSplatSize + float(DecalScaler), BloodSplatSize + float(DecalScaler), 50, false,,,,,,,, BloodSplatterLifetime * GoreFXLifetimeMultiplier);
        }
    }
}

simulated function float GetTimeBetweenGibBloodSplats()
{
    return 0.08;
}

simulated function LeaveABloodPoolDecal(KFPawn inPawn)
{
    local Actor TraceActor;
    local Vector TraceHitLocation, TraceHitNormal, TraceDest, TraceStart;
    local TraceHitInfo HitInfo;
    local MaterialInstanceTimeVarying MITV_Decal;
    local int DecalScaler;
    local name OriginBone;

    if(WorldInfo.bDropDetail)
    {
        return;
    }
    if(DesiredGoreLevel <= 1)
    {
        OriginBone = inPawn.CharacterArch.BloodPoolOriginBoneName;
        if((OriginBone != 'None') && inPawn.Mesh.MatchRefBone(OriginBone) != -1)
        {
            TraceStart = inPawn.Mesh.GetBoneLocation(OriginBone);            
        }
        else
        {
            TraceStart = inPawn.Mesh.GetBoneLocation(inPawn.Mesh.GetBoneName(0));
        }
        TraceDest = TraceStart + (250 * vect(0, 0, -1));
        TraceActor = Trace(TraceHitLocation, TraceHitNormal, TraceDest, TraceStart, false,, HitInfo, 2);
        if((TraceActor != none) && Pawn(TraceActor) == none)
        {
            MITV_Decal = new (Outer) Class'MaterialInstanceTimeVarying';
            MITV_Decal.SetParent(inPawn.BloodPoolDecalMaterials[Rand(inPawn.BloodPoolDecalMaterials.Length)]);
            MITV_Decal.SetDuration(BloodPoolLifetime * GoreFXLifetimeMultiplier);
            DecalScaler = Rand(25);
            BloodPoolDecalManager.SpawnDecal(MITV_Decal, TraceHitLocation, rotator(-TraceHitNormal), BloodPoolSize + float(DecalScaler), BloodPoolSize + float(DecalScaler), 32, false,,, true, false,,,, BloodPoolLifetime * GoreFXLifetimeMultiplier);
        }
    }
}

final simulated function bool AllowMutilation()
{
    return DesiredGoreLevel <= 0;
}

final simulated function bool AllowHeadless()
{
    return DesiredGoreLevel <= 2;
}

final simulated function AttachMutilationBloodEffects(KFPawn_Monster inPawn, name DismemberedBone, optional array<BloodJetSettings> BloodJets, optional array<BloodTrailSettings> BloodTrails, optional array<name> BloodMICParams)
{
    local name ParentBone;
    local int ParentBoneIndex, DismemberedBoneIndex, BloodParamIndex, BloodJetIndex, BloodTrailIndex, MICIndex;

    local editinline SkeletalMeshComponent SkelMesh;
    local Vector OffsetFromParentBone, TranslationFromParentBone, ParentBoneFaceDir;
    local bool bOppositeFacing;
    local KFCharacterInfo_Monster MonsterInfo;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if((inPawn != none) && inPawn.Mesh != none)
    {
        MICIndex = 0;
        if(inPawn.CharacterMICs.Length > inPawn.GetCharacterInfo().GoreFXMICIdx)
        {
            MICIndex = inPawn.GetCharacterInfo().GoreFXMICIdx;
        }
        BloodParamIndex = 0;
        J0x10F:

        if(BloodParamIndex < BloodMICParams.Length)
        {
            inPawn.CharacterMICs[MICIndex].SetScalarParameterValue(BloodMICParams[BloodParamIndex], 0);
            ++ BloodParamIndex;
            goto J0x10F;
        }
        if(WorldInfo.bDropDetail)
        {
            return;
        }
        SkelMesh = inPawn.Mesh;
        ParentBone = SkelMesh.GetParentBone(DismemberedBone);
        DismemberedBoneIndex = SkelMesh.MatchRefBone(DismemberedBone);
        ParentBoneIndex = SkelMesh.MatchRefBone(ParentBone);
        MonsterInfo = inPawn.GetCharacterMonsterInfo();
        if(((DismemberedBoneIndex != -1) && ParentBoneIndex != -1) && MonsterInfo != none)
        {
            OffsetFromParentBone = SkelMesh.LocalAtoms[DismemberedBoneIndex].Translation;
            TranslationFromParentBone = SkelMesh.SpaceBases[DismemberedBoneIndex].Translation - SkelMesh.SpaceBases[ParentBoneIndex].Translation;
            ParentBoneFaceDir = SkelMesh.GetBoneAxis(ParentBone, 1);
            bOppositeFacing = (((Normal(TranslationFromParentBone) Dot ParentBoneFaceDir) < 0) ? true : false);
            BloodJetIndex = 0;
            J0x404:

            if(BloodJetIndex < BloodJets.Length)
            {
                if(BloodJets[BloodJetIndex].bAttachToSocket)
                {
                    BloodFXEmitterPool.SpawnEmitterMeshAttachment(BloodJets[BloodJetIndex].ParticleSystemTemplate, SkelMesh, BloodJets[BloodJetIndex].SocketName, true);                    
                }
                else
                {
                    BloodFXEmitterPool.SpawnEmitterMeshAttachment(BloodJets[BloodJetIndex].ParticleSystemTemplate, SkelMesh, ParentBone, false, OffsetFromParentBone, ((bOppositeFacing) ? rot(0, 32768, 0) : rot(0, 0, 0)));
                }
                ++ BloodJetIndex;
                goto J0x404;
            }
            BloodTrailIndex = 0;
            J0x563:

            if(BloodTrailIndex < BloodTrails.Length)
            {
                if(BloodTrails[BloodTrailIndex].bAttachToSocket)
                {
                    BloodFXEmitterPool.SpawnEmitterMeshAttachment(BloodTrails[BloodTrailIndex].ParticleSystemTemplate, SkelMesh, BloodTrails[BloodTrailIndex].SocketName, true);                    
                }
                else
                {
                    BloodFXEmitterPool.SpawnEmitterMeshAttachment(BloodTrails[BloodTrailIndex].ParticleSystemTemplate, SkelMesh, DismemberedBone, false,, ((bOppositeFacing) ? rot(0, 0, 0) : rot(0, 32768, 0)));
                }
                ++ BloodTrailIndex;
                goto J0x563;
            }
        }
    }
}

final simulated function bool BreakConstraint(KFPawn_Monster inPawn, name InBoneName, optional class<KFDamageType> InDmgType, optional bool bToggleWeightsOnly)
{
    local int JointIndex, DependencyIdx, DependentBoneIdx;
    local DependentBreakSettings CurrentBreakDependency;
    local KFCharacterInfo_Monster MonsterInfo;
    local editinline ParticleSystemComponent PSC;

    bToggleWeightsOnly = false;
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return false;
    }
    if(inPawn.Mesh == none)
    {
        return false;
    }
    MonsterInfo = inPawn.GetCharacterMonsterInfo();
    if(((inPawn != none) && !inPawn.Mesh.IsBrokenConstraint(InBoneName)) && MonsterInfo != none)
    {
        inPawn.bHasBrokenConstraints = true;
        if(bToggleWeightsOnly)
        {
            inPawn.Mesh.ToggleAlternateBoneWeights(InBoneName);            
        }
        else
        {
            inPawn.Mesh.super(KFGoreManager).BreakConstraint(InBoneName);
        }
        inPawn.HandleGoreChunkAttachments(InBoneName);
        if(InDmgType != none)
        {
            JointIndex = 0;
            J0x1D1:

            if(JointIndex < MonsterInfo.GoreJointSettings.Length)
            {
                if(MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == InBoneName)
                {
                    DependencyIdx = 0;
                    J0x254:

                    if(DependencyIdx < MonsterInfo.GoreJointSettings[JointIndex].DependentBreakGore.Length)
                    {
                        CurrentBreakDependency = MonsterInfo.GoreJointSettings[JointIndex].DependentBreakGore[DependencyIdx];
                        if(((CurrentBreakDependency.ConstrainToDamageGroups.Length == 0) || CurrentBreakDependency.ConstrainToDamageGroups.Find(0 != -1) || CurrentBreakDependency.ConstrainToDamageGroups.Find(InDmgType.default.GoreDamageGroup != -1)
                        {
                            DependentBoneIdx = 0;
                            J0x397:

                            if(DependentBoneIdx < CurrentBreakDependency.DependentBones.Length)
                            {
                                inPawn.Mesh.super(KFGoreManager).BreakConstraint(CurrentBreakDependency.DependentBones[DependentBoneIdx].BoneName);
                                AttachMutilationBloodEffects(inPawn, CurrentBreakDependency.DependentBones[DependentBoneIdx].BoneName, CurrentBreakDependency.DependentBones[DependentBoneIdx].BloodJets, CurrentBreakDependency.DependentBones[DependentBoneIdx].BloodTrails, CurrentBreakDependency.DependentBones[DependentBoneIdx].BloodMICParamName);
                                if(CurrentBreakDependency.DependentBones[DependentBoneIdx].ParticleSystemTemplate != none)
                                {
                                    PSC = MiscGoreFXEmitterPool.SpawnEmitter(CurrentBreakDependency.DependentBones[DependentBoneIdx].ParticleSystemTemplate, inPawn.Mesh.GetBoneLocation(CurrentBreakDependency.DependentBones[DependentBoneIdx].BoneName));
                                    PSC.SetLightingChannels(inPawn.PawnLightingChannel);
                                }
                                inPawn.HandleGoreChunkAttachments(CurrentBreakDependency.DependentBones[DependentBoneIdx].BoneName);
                                ++ DependentBoneIdx;
                                goto J0x397;
                            }
                        }
                        ++ DependencyIdx;
                        goto J0x254;
                    }
                }
                ++ JointIndex;
                goto J0x1D1;
            }
        }
        return true;
    }
    return false;
}

simulated function CrushBone(KFPawn_Monster inPawn, name InHitBoneName)
{
    if(AllowMutilation())
    {
        ConditionalApplyPartialGore(inPawn, none, inPawn.Mesh.GetBoneLocation(InHitBoneName), vect(0, 0, 0), InHitBoneName, true);        
    }
    else
    {
        if(BreakConstraint(inPawn, InHitBoneName,, true))
        {
            inPawn.Mesh.HideBoneByName(InHitBoneName, 1);
        }
    }
}

simulated function bool ConditionalApplyPartialGore(KFPawn_Monster inPawn, class<KFDamageType> InDmgType, Vector InHitLocation, Vector InHitDirection, name InHitBoneName, optional bool bForceApply)
{
    local int I, JointIndex, PartialBreakIndex, ClosestBoneIndex;
    local name ClosestBone;
    local array<name> ClosestBoneList;
    local KFCharacterInfo_Monster MonsterInfo;
    local PartialBreakSettings CurrentPartialBreak;
    local array<name> SearchBoneList;
    local editinline ParticleSystemComponent PSC;

    MonsterInfo = inPawn.GetCharacterMonsterInfo();
    JointIndex = 0;
    J0x35:

    if(JointIndex < MonsterInfo.GoreJointSettings.Length)
    {
        if(MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == InHitBoneName)
        {
            PartialBreakIndex = 0;
            J0xB8:

            if(PartialBreakIndex < MonsterInfo.GoreJointSettings[JointIndex].BoneShrinkGore.Length)
            {
                CurrentPartialBreak = MonsterInfo.GoreJointSettings[JointIndex].BoneShrinkGore[PartialBreakIndex];
                if((bForceApply || ((CurrentPartialBreak.ConstrainToDamageGroups.Length == 0) || CurrentPartialBreak.ConstrainToDamageGroups.Find(0 != -1) || CurrentPartialBreak.ConstrainToDamageGroups.Find(InDmgType.default.GoreDamageGroup != -1) || (inPawn.TimeOfDeath == WorldInfo.TimeSeconds) && ((CurrentPartialBreak.KillingBlowDamageGroups.Length == 0) || CurrentPartialBreak.KillingBlowDamageGroups.Find(0 != -1) || CurrentPartialBreak.KillingBlowDamageGroups.Find(InDmgType.default.GoreDamageGroup != -1)
                {
                    I = 0;
                    J0x2EA:

                    if(I < CurrentPartialBreak.PartialBreakBones.Length)
                    {
                        if((InHitBoneName != 'head') || !inPawn.HeadBoneAlreadyBroken(CurrentPartialBreak.PartialBreakBones[I].BoneName) && inPawn.ShouldAllowHeadBoneToBreak(CurrentPartialBreak.PartialBreakBones[I].BoneName))
                        {
                            SearchBoneList.AddItem(CurrentPartialBreak.PartialBreakBones[I].BoneName;
                        }
                        ++ I;
                        goto J0x2EA;
                    }
                    inPawn.Mesh.FindClosestBones(InHitLocation, 1, ClosestBoneList, SearchBoneList, 0);
                    if(ClosestBoneList.Length > 0)
                    {
                        ClosestBone = ClosestBoneList[0];
                        ClosestBoneIndex = CurrentPartialBreak.PartialBreakBones.Find('BoneName', ClosestBone;
                        if(ClosestBoneIndex >= 0)
                        {
                            if((InHitBoneName == 'head') && !inPawn.ShouldAllowHeadBoneToBreak(ClosestBone))
                            {
                                return false;
                            }
                            if(BreakConstraint(inPawn, ClosestBone,, true))
                            {
                                inPawn.Mesh.HideBoneByName(ClosestBone, 1);
                                if(InHitBoneName == 'head')
                                {
                                    inPawn.AddBrokenHeadBone(ClosestBone);
                                }
                                AttachMutilationBloodEffects(inPawn, ClosestBone, CurrentPartialBreak.PartialBreakBones[ClosestBoneIndex].BloodJets,, CurrentPartialBreak.PartialBreakBones[ClosestBoneIndex].BloodMICParamName);
                                if((CurrentPartialBreak.PartialBreakBones[ClosestBoneIndex].ParticleSystemTemplate != none) && !WorldInfo.bDropDetail || bForceApply)
                                {
                                    PSC = MiscGoreFXEmitterPool.SpawnEmitter(CurrentPartialBreak.PartialBreakBones[ClosestBoneIndex].ParticleSystemTemplate, InHitLocation);
                                    PSC.SetLightingChannels(inPawn.PawnLightingChannel);
                                }
                            }                            
                        }
                        else
                        {
                            if(bLogGore)
                            {
                                LogInternal((((("ConditionalApplyPartialGore -- On Pawn: " $ string(inPawn)) @ " Trying to Work on a bone out of the array, ClosestBone: ") $ string(ClosestBone)) $ " - InHitBoneName: ") $ string(InHitBoneName));
                            }
                        }
                    }
                    return true;
                }
                ++ PartialBreakIndex;
                goto J0xB8;
            }
        }
        ++ JointIndex;
        goto J0x35;
    }
    return false;
}

simulated function CauseDismemberment(KFPawn_Monster inPawn, name InHitBoneName, class<KFDamageType> InDmgType)
{
    local int JointIndex, EffectIdx;
    local KFCharacterInfo_Monster MonsterInfo;
    local DismembermentEffect CurrentEffect;
    local editinline ParticleSystemComponent PSC;

    MonsterInfo = inPawn.GetCharacterMonsterInfo();
    JointIndex = 0;
    J0x34:

    if(JointIndex < MonsterInfo.GoreJointSettings.Length)
    {
        if((MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == InHitBoneName) && !MonsterInfo.GoreJointSettings[JointIndex].bNonBreakableJoint)
        {
            if(BreakConstraint(inPawn, InHitBoneName, InDmgType))
            {
                AttachMutilationBloodEffects(inPawn, InHitBoneName, MonsterInfo.GoreJointSettings[JointIndex].BloodJets, MonsterInfo.GoreJointSettings[JointIndex].BloodTrails, MonsterInfo.GoreJointSettings[JointIndex].BloodMICParamName);
                EffectIdx = 0;
                J0x1F8:

                if(EffectIdx < MonsterInfo.GoreJointSettings[JointIndex].DismembermentEffects.Length)
                {
                    CurrentEffect = MonsterInfo.GoreJointSettings[JointIndex].DismembermentEffects[EffectIdx];
                    if((((CurrentEffect.ConstrainToDamageGroups.Length == 0) || CurrentEffect.ConstrainToDamageGroups.Find(0 != -1) || CurrentEffect.ConstrainToDamageGroups.Find(InDmgType.default.GoreDamageGroup != -1) && !WorldInfo.bDropDetail)
                    {
                        PSC = MiscGoreFXEmitterPool.SpawnEmitter(CurrentEffect.ParticleSystemTemplate, inPawn.Mesh.GetBoneLocation(InHitBoneName));
                        PSC.SetLightingChannels(inPawn.PawnLightingChannel);
                    }
                    ++ EffectIdx;
                    goto J0x1F8;
                }
            }
        }
        ++ JointIndex;
        goto J0x34;
    }
}

simulated function CauseGibsAndApplyImpulse(KFPawn_Monster inPawn, class<KFDamageType> InDmgType, Vector InExplosionOrigin, array<name> InGibBoneList, ParticleSystem ExplosionEffect, Vector ExplosionEffectLocation, optional name HitBoneName)
{
    local Vector Impulse, BoneLocation;
    local int GibIdx, JointIndex, ExplosionBreakIdx, BoneIdx;
    local name GibBoneName;
    local bool bBrokenConstraint, bPlayedBloodEffects;
    local KFCharacterInfo_Monster MonsterInfo;
    local ExplosionBreakBone ExplosiveBreakBone;
    local name RBBoneName;
    local editinline ParticleSystemComponent PSC;
    local int NumGibs;
    local float ModifiedImpulseLerpValue, ModifiedImpulse, GibImpulseMin, GibImpulseMax;

    HitBoneName = 'None';
    MonsterInfo = inPawn.GetCharacterMonsterInfo();
    GibImpulseMax = InDmgType.default.GibImpulseScale;
    GibImpulseMin = GibImpulseMax / 2;
    NumGibs = InGibBoneList.Length;
    ModifiedImpulseLerpValue = 1 - float(NumGibs / MonsterInfo.GoreJointSettings.Length);
    ModifiedImpulse = Lerp(GibImpulseMin, GibImpulseMax, ModifiedImpulseLerpValue);
    GibIdx = 0;
    J0xFB:

    if(GibIdx < InGibBoneList.Length)
    {
        GibBoneName = InGibBoneList[GibIdx];
        BoneLocation = inPawn.Mesh.GetBoneLocation(GibBoneName);
        Impulse = InDmgType.default.RadialDamageImpulse * ((InDmgType.default.bPointImpulseTowardsOrigin) ? Normal((inPawn.Location - InExplosionOrigin) + (vect(0, 0, 1) * InDmgType.default.ImpulseOriginLift)) : Normal(BoneLocation - InExplosionOrigin));
        Impulse *= (MonsterInfo.ExplosionImpulseScale * ModifiedImpulse);
        JointIndex = 0;
        J0x275:

        if(JointIndex < MonsterInfo.GoreJointSettings.Length)
        {
            if((MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == GibBoneName) && !MonsterInfo.GoreJointSettings[JointIndex].bNonBreakableJoint)
            {
                if(BreakConstraint(inPawn, GibBoneName, InDmgType))
                {
                    bBrokenConstraint = true;
                    if((HitBoneName == 'None') || HitBoneName == 'None')
                    {
                        AttachMutilationBloodEffects(inPawn, GibBoneName, MonsterInfo.GoreJointSettings[JointIndex].BloodJets, MonsterInfo.GoreJointSettings[JointIndex].BloodTrails, MonsterInfo.GoreJointSettings[JointIndex].BloodMICParamName);                        
                    }
                    else
                    {
                        bPlayedBloodEffects = false;
                        JointIndex = 0;
                        J0x484:

                        if(!bPlayedBloodEffects && JointIndex < MonsterInfo.GoreJointSettings.Length)
                        {
                            if(MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == HitBoneName)
                            {
                                ExplosionBreakIdx = 0;
                                J0x518:

                                if(!bPlayedBloodEffects && ExplosionBreakIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore.Length)
                                {
                                    BoneIdx = 0;
                                    J0x580:

                                    if(BoneIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones.Length)
                                    {
                                        ExplosiveBreakBone = MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones[BoneIdx];
                                        if(ExplosiveBreakBone.BoneName == GibBoneName)
                                        {
                                            AttachMutilationBloodEffects(inPawn, GibBoneName, ExplosiveBreakBone.BloodJets, ExplosiveBreakBone.BloodTrails, ExplosiveBreakBone.BloodMICParamName);
                                            bPlayedBloodEffects = true;
                                            goto J0x70E;
                                        }
                                        ++ BoneIdx;
                                        goto J0x580;
                                    }
                                    J0x70E:

                                    ++ ExplosionBreakIdx;
                                    goto J0x518;
                                }
                            }
                            ++ JointIndex;
                            goto J0x484;
                        }
                    }
                }
            }
            ++ JointIndex;
            goto J0x275;
        }
        RBBoneName = inPawn.GetRBBoneFromBoneName(GibBoneName);
        inPawn.Mesh.AddImpulse(Impulse, BoneLocation, RBBoneName);
        ++ GibIdx;
        goto J0xFB;
    }
    if((bBrokenConstraint && !inPawn.bPlayedExplosionEffect) && ExplosionEffect != none)
    {
        PSC = MiscGoreFXEmitterPool.SpawnEmitter(ExplosionEffect, ExplosionEffectLocation);
        PSC.SetLightingChannels(inPawn.PawnLightingChannel);
        inPawn.bPlayedExplosionEffect = true;
    }
}

simulated function KFGiblet SpawnGiblet(Vector GibLocation, Rotator GibRotation, float MomentumScale, KFGibletInfo InGibInfo, Vector InDamageOrigin, optional class<KFDamageType> inDamageType)
{
    local KFGiblet Gib;
    local bool bSpinGib;
    local Vector ImpluseDir, ModifiedImpulseDir;

    if(((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.bDropDetail) || WorldInfo.GetDetailMode() == 0)
    {
        return none;
    }
    Gib = Spawn(Class'KFGiblet', self,, GibLocation, GibRotation);
    Gib.SetMesh(InGibInfo);
    if(Gib != none)
    {
        ImpluseDir = Normal(Gib.Location - InDamageOrigin);
        ModifiedImpulseDir = Normal(ImpluseDir + vect(0, 0, 1));
        if(inDamageType != none)
        {
            Gib.Velocity = ModifiedImpulseDir * FMin(inDamageType.default.RadialDamageImpulse, float(InGibInfo.GibletMaxSpeed));
        }
        Gib.Velocity = (Gib.Velocity + (Gib.Velocity * 0.2)) - ((FRand() * Gib.Velocity) * 0.2);
        Gib.Velocity *= MomentumScale;
        Gib.GibMeshComp.WakeRigidBody();
        Gib.GibMeshComp.SetRBLinearVelocity(Gib.Velocity, false);
        bSpinGib = FRand() > 0.5;
        if(bSpinGib)
        {
            Gib.GibMeshComp.SetRBAngularVelocity(VRand() * float(500), false);
        }
        Gib.SetTimer(GibletLifetime * GoreFXLifetimeMultiplier, false, 'LifespanTimer');
    }
    return Gib;
}

simulated function SpawnObliterationBloodEffect(KFPawn inPawn)
{
    local editinline ParticleSystemComponent PSC;
    local KFCharacterInfo_Monster MonsterInfo;
    local Vector ParticleLocation;

    inPawn.SoundGroupArch.PlayObliterationSound(inPawn);
    MonsterInfo = KFCharacterInfo_Monster(inPawn.GetCharacterInfo());
    ParticleLocation = inPawn.Mesh.GetBoneLocation('Spine');
    if(IsZero(ParticleLocation))
    {
        ParticleLocation = inPawn.Location;
    }
    PSC = MiscGoreFXEmitterPool.SpawnEmitter(MonsterInfo.ObliterationEffectTemplate, ParticleLocation);
    PSC.SetLightingChannels(inPawn.PawnLightingChannel);
}

simulated function CauseObliteration(KFPawn inPawn, Vector InDamageOrigin, class<KFDamageType> inDamageType, optional float MomentumScale)
{
    local KFCharacterInfo_Monster MonsterInfo;
    local int GibletIndex, BoneIndex;
    local Vector PawnLocation;
    local KFPawnSoundGroup PawnSoundGroup;
    local KFGiblet Gib;
    local Vector Loc;
    local Rotator Rot;
    local Quat BoneQuat;
    local bool bSpawnedAGibForThisIndex;

    MomentumScale = 1;
    PawnLocation = inPawn.Location;
    PawnSoundGroup = inPawn.SoundGroupArch;
    PawnSoundGroup.PlayObliterationSound(inPawn);
    inPawn.Mesh.SetHidden(true);
    RemoveAndDeleteCorpse(CorpsePool.Find(inPawn);
    MonsterInfo = KFCharacterInfo_Monster(inPawn.GetCharacterInfo());
    if(MonsterInfo != none)
    {
        SpawnObliterationBloodEffect(inPawn);
        GibletIndex = 0;
        J0x136:

        if(GibletIndex < MonsterInfo.GibletSettings.Length)
        {
            bSpawnedAGibForThisIndex = false;
            if(MonsterInfo.GibletSettings[GibletIndex].GibletBones.Length > 0)
            {
                BoneIndex = 0;
                J0x1BE:

                if(BoneIndex < MonsterInfo.GibletSettings[GibletIndex].GibletBones.Length)
                {
                    if((MonsterInfo.GibletSettings[GibletIndex].GibletBones.Length > 1) && (BoneIndex < (MonsterInfo.GibletSettings[GibletIndex].GibletBones.Length - 1)) || bSpawnedAGibForThisIndex)
                    {
                        if(FRand() < 0.35)
                        {
                            goto J0x492;
                        }
                    }
                    Loc = inPawn.Mesh.GetBoneLocation(MonsterInfo.GibletSettings[GibletIndex].GibletBones[BoneIndex]);
                    BoneQuat = inPawn.Mesh.GetBoneQuaternion(MonsterInfo.GibletSettings[GibletIndex].GibletBones[BoneIndex]);
                    Rot = QuatToRotator(BoneQuat);
                    Gib = SpawnGiblet(Loc, Rot, MomentumScale, MonsterInfo.GibletSettings[GibletIndex], InDamageOrigin, inDamageType);
                    bSpawnedAGibForThisIndex = true;
                    if(Gib != none)
                    {
                        Gib.SoundGroup = PawnSoundGroup;
                    }
                    J0x492:

                    ++ BoneIndex;
                    goto J0x1BE;
                }                
            }
            else
            {
                Loc = PawnLocation;
                Gib = SpawnGiblet(Loc, Rot, MomentumScale, MonsterInfo.GibletSettings[GibletIndex], InDamageOrigin, inDamageType);
                bSpawnedAGibForThisIndex = true;
                if(Gib != none)
                {
                    Gib.SoundGroup = PawnSoundGroup;
                }
            }
            ++ GibletIndex;
            goto J0x136;
        }
    }
}

// Export UKFGoreManager::execMakeRoomForCorpse(FFrame&, void* const)
native function bool MakeRoomForCorpse(KFPawn InCorpse);

// Export UKFGoreManager::execRateCorpse(FFrame&, void* const)
native function float RateCorpse(KFPawn InCorpse);

// Export UKFGoreManager::execRemoveAndDeleteCorpse(FFrame&, void* const)
native function bool RemoveAndDeleteCorpse(int PoolIdx);

// Export UKFGoreManager::execDeleteCorpse(FFrame&, void* const)
native function bool DeleteCorpse(KFPawn InCorpse);

simulated function AddCorpse(KFPawn NewCorpse)
{
    if(CorpsePool.Length >= MaxDeadBodies)
    {
        MakeRoomForCorpse(NewCorpse);
    }
    if(CorpsePool.Length < MaxDeadBodies)
    {
        NewCorpse.LifeSpan = 0;
        CorpsePool.AddItem(NewCorpse;        
    }
    else
    {
        DeleteCorpse(NewCorpse);
    }
}

function ResetPersistantGore(optional bool bOnRespawn)
{
    local int I;

    if(bOnRespawn)
    {
        I = CorpsePool.Length - 1;
        J0x25:

        if(I >= 0)
        {
            if(CorpsePool[I].IsA('KFPawn_Human'))
            {
                RemoveAndDeleteCorpse(I);
            }
            -- I;
            goto J0x25;
        }
    }
}

event Reset()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < CorpsePool.Length)
    {
        CorpsePool[I].Destroy();
        ++ I;
        goto J0x0B;
    }
    CorpsePool.Remove(0, CorpsePool.Length;
    ClearPersistentBloodSplats();
}

defaultproperties
{
    GoreFXLifetimeMultiplier=1
    BodyWoundDecalLifetime=30
    BloodSplatterLifetime=10
    BloodPoolLifetime=20
    GibletLifetime=10
    BloodSplatSize=100
    BloodPoolSize=125
    MaxBodyWoundDecals=5
    MaxBloodSplatterDecals=20
    MaxBloodPoolDecals=20
    MaxBloodEffects=25
    MaxGoreEffects=10
    MaxDeadBodies=12
    MaxCorpseOffscreenTime=60
    MaxCorpseOffscreenDistance=5000
    PersistentSplatTraceLength=1000
    MaxPersistentSplatsPerFrame=75
    CollisionType=ECollisionType.COLLIDE_CustomDefault
}