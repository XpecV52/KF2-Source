/*******************************************************************************
 * KFDoorActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDoorActor extends Actor
    native
    nativereplication
    placeable
    hidecategories(Navigation,Movement,Collision,Physics,Object,Mobile)
    implements(Interface_NavigationHandle);

const SkeletalMesh_Width = 256;
const KActorOffset = 25;
const HIT_DIRECTION_FLAG = 0x80;
const DoorWidth = 200;
const HumanPushDistance = 40;
const SlidingPushForce = 750;
const BashHingedAnim_F = 'DoorBash_A';
const BashHingedAnim_B = 'DoorBash_B';
const BashSlidingAnim_F = 'DoorBashSliding_A';
const BashSlidingAnim_B = 'DoorBashSliding_B';

enum EDoorMaterialType
{
    EDMT_Metal,
    EDMT_Wood,
    EDMT_MAX
};

enum EDoorMechanism
{
    EDM_Hinge,
    EDM_Slide,
    EDM_Lift,
    EDM_MAX
};

enum EDoorFastening
{
    EDF_ArcWelding,
    EDF_Rivets,
    EDF_MAX
};

struct native DoorMeshAttachment
{
    /** @name Meshes / Materials / Particles */
    var() export editinline StaticMeshComponent Component;
    /** Component which needs to be attached */
    var() name AttachTo;
    /** Bone or socket name to which the attachment should be attached */
    var() bool bSocketAttach;

    structdefaultproperties
    {
        Component=none
        AttachTo=None
        bSocketAttach=false
    }
};

var private native const noexport Pointer VfTable_IInterface_NavigationHandle;
var KFDoorTrigger DoorTrigger;
/** Information of all the mesh attachments for the vehicle */
var() array<DoorMeshAttachment> MeshAttachments;
/** Mesh for the weld that goes between the center of two doors or the end of the left door */
var() export editinline StaticMeshComponent CenterWeldComponent;
/** skeletal mesh used for open/close animations */
var() const editconst export editinline SkeletalMeshComponent SkeletalMeshComp;
var array<MaterialInstanceConstant> HealthMICs;
var MaterialInstanceConstant IntegrityMIC;
var() KFDoorActor.EDoorMaterialType DoorMaterial;
/** type of networking to use */
var(Opening) KFDoorActor.EDoorMechanism DoorMechanism;
var KFDoorActor.EDoorFastening FastenerType;
var repnotify transient byte HitCount;
/** The amount of time before a door can be used again */
var(Opening) float CoolDownTime;
/** The time it takes to open / close a door */
var(Opening) float OpenBlendTime;
/** ONLY FOR HINGED DOORS Defines how far we want to open our hinged doors in degrees */
var(Opening) int HingedRotation;
/** ONLY FOR SLIDING DOORS Defines how far we want sliding doors to move */
var(Opening) int SlideTranslation;
/** ONLY FOR LIFT DOORS Defines how far we want lift doors to raise */
var(Opening) int LiftTranslation;
/** If set, door opens and closes automatically */
var(Opening) const editconst bool bAutomaticDoor;
var transient bool bDoorMoveCompleted;
var repnotify transient bool bIsDoorOpen;
var transient bool bReverseHinge;
var repnotify transient bool bShouldExplode;
var repnotify transient bool bIsDestroyed;
var bool bMonitorDoor;
var transient float LastUsedTime;
/** Starting health for a door */
var() int MaxHealth;
var repnotify transient int Health;
/** Amount of damage a welded door can take */
var() int MaxWeldIntegrity;
var repnotify transient int WeldIntegrity;
var int DemoWeldRequired;
var repnotify transient int DemoWeld;
var transient KFPlayerController ExplosionInstigatorController;
var const float MinWeldScalar;
/** While the door is being attacked it takes longer to weld */
var() float CombatWeldModifier<ClampMin=0.0|ClampMax=1.0>;
var float CombatLength;
var transient float LastHitTime;
var transient float LastWeldTime;
var transient float LastUnweldTime;
var transient KFPawn WelderPawn;
var transient SkelControlSingleBone MovementControl;
var transient AnimNodeSlot BashSlot;
/** A scaler to fit a door into its proper frame. Double the frame size if we are only using one door for this actor */
var() float FrameSizeOfTwoDoors;
var NavigationPoint MyMarker;
/** The impulse to provide the doors when they are destroyed */
var() float BrokenDoorImpulse;
/** The maximum angular velocity applied to a broken hinged door */
var() float MaxAngularVelocity;
/** Adjusts the "push" plane of the door (the threshold for pushing forward or backward) along its X-axis */
var() float PushOriginOffset;
/** sound played when the mover is interpolated forward */
var(Sound) AkBaseSoundObject OpenSound;
/** looping sound while opening */
var(Sound) AkBaseSoundObject OpeningAmbientSound;
/** sound played when mover finished moving forward */
var(Sound) AkBaseSoundObject OpenedSound;
/** sound played when the mover is interpolated in reverse */
var(Sound) AkBaseSoundObject CloseSound;
/** looping sound while closing */
var(Sound) AkBaseSoundObject ClosingAmbientSound;
/** sound played when mover finished moving backward */
var(Sound) AkBaseSoundObject ClosedSound;
/** sound played when door is destroyed */
var(Sound) AkBaseSoundObject DestroyedSound;
var export editinline AkComponent AmbientSoundComponent;
var transient Vector SoundOrigin;
/** played when the melee attack hits world geometry */
var() DestroyedEffectParams DamageEmitter;
/** played when the melee attack hits world geometry and the door has no health */
var() array<DestroyedEffectParams> DestroyedEmitters;
var const localized string WeldIntegrityString;
var const localized string ExplosiveString;

replication
{
     if(bNetDirty)
        DemoWeld, Health, 
        HitCount, WeldIntegrity, 
        bIsDestroyed, bIsDoorOpen, 
        bShouldExplode;

     if(bNetDirty && DoorMechanism == 0)
        bReverseHinge;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'bIsDoorOpen')
    {
        if(bIsDoorOpen)
        {
            if(MovementControl.StrengthTarget == float(0))
            {
                OpenDoor(none);
            }            
        }
        else
        {
            CloseDoor();
        }        
    }
    else
    {
        if(VarName == 'bIsDestroyed')
        {
            if(bIsDestroyed)
            {
                PlayDestroyed();                
            }
            else
            {
                ResetDoor();
            }            
        }
        else
        {
            if(VarName == 'Health')
            {
                UpdateHealthMICs();
                if(Health <= 0)
                {
                    UpdateIntegrityMIC();
                }                
            }
            else
            {
                if((VarName == 'WeldIntegrity') || VarName == 'bShouldExplode')
                {
                    UpdateIntegrityMIC();                    
                }
                else
                {
                    if(VarName == 'HitCount')
                    {
                        PlayTakeHitEffects();
                    }
                }
            }
        }
    }
}

// Export UKFDoorActor::execInitBrokenAttachment(FFrame&, void* const)
native function InitBrokenAttachment(StaticMeshComponent Attachment, KFKActorSpawnable SpawnedKActor);

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    MovementControl = SkelControlSingleBone(SkelComp.FindSkelControl('MovementControl'));
    BashSlot = AnimNodeSlot(SkeletalMeshComp.FindAnimNode('Slot_Bash'));
    InitSkelControl();
}

simulated event PostBeginPlay()
{
    local int I, NumActualDoors;

    super.PostBeginPlay();
    Health = MaxHealth;
    LastUsedTime = WorldInfo.TimeSeconds - CoolDownTime;
    if((OpeningAmbientSound != none) || ClosingAmbientSound != none)
    {
        AmbientSoundComponent = new (self) Class'AkComponent';
        AttachComponent(AmbientSoundComponent);
    }
    InitializeDoorMIC();
    CenterWeldComponent.SetHidden(true);
    if(Class'KFAIController'.default.bUseNavMesh)
    {
    }
    I = 0;
    J0xF2:

    if(I < MeshAttachments.Length)
    {
        if(MeshAttachments[I].Component.StaticMesh != none)
        {
            SoundOrigin += MeshAttachments[I].Component.Bounds.Origin;
            ++ NumActualDoors;
        }
        ++ I;
        goto J0xF2;
    }
    if(NumActualDoors > 0)
    {
        SoundOrigin /= float(NumActualDoors);        
    }
    else
    {
        SoundOrigin = Location;
    }
}

simulated function InitializeDoorMIC()
{
    local MaterialInstanceConstant NewMIC;
    local byte I, MaterialIndex;

    if((HealthMICs.Length <= 0) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(MeshAttachments.Length > 0)
        {
            MaterialIndex = 0;
            J0x57:

            if(MaterialIndex < MeshAttachments[0].Component.GetNumElements())
            {
                if(MeshAttachments[0].Component.GetMaterial(MaterialIndex) != none)
                {
                    NewMIC = new Class'MaterialInstanceConstant';
                    NewMIC.SetParent(MeshAttachments[0].Component.GetMaterial(MaterialIndex));
                    HealthMICs.AddItem(NewMIC;
                    I = 0;
                    J0x178:

                    if(I < MeshAttachments.Length)
                    {
                        MeshAttachments[I].Component.SetMaterial(MaterialIndex, NewMIC);
                        ++ I;
                        goto J0x178;
                    }
                }
                ++ MaterialIndex;
                goto J0x57;
            }
        }
        if(CenterWeldComponent.GetMaterial(0) != none)
        {
            IntegrityMIC = CenterWeldComponent.CreateAndSetMaterialInstanceConstant(0);
            IntegrityMIC.SetScalarParameterValue('doorWeld', 0);
        }
    }
}

simulated function InitSkelControl()
{
    MovementControl.BlendInTime = OpenBlendTime;
    MovementControl.BlendOutTime = OpenBlendTime;
    switch(DoorMechanism)
    {
        case 0:
            MovementControl.bApplyTranslation = false;
            MovementControl.bApplyRotation = true;
            MovementControl.BoneRotation.Yaw = int(float(HingedRotation) * 182.0444);
            break;
        case 1:
            MovementControl.bApplyTranslation = true;
            MovementControl.bApplyRotation = false;
            MovementControl.BoneTranslation.Y = float(SlideTranslation);
            MovementControl.BoneTranslation.Z = 0;
            break;
        case 2:
            MovementControl.bApplyTranslation = true;
            MovementControl.bApplyRotation = false;
            MovementControl.BoneTranslation.Y = 0;
            MovementControl.BoneTranslation.Z = float(LiftTranslation);
            break;
        default:
            break;
    }
    MovementControl.SetSkelControlStrength(1, 0);
    bIsDoorOpen = true;
}

// Export UKFDoorActor::execIsCompletelyOpen(FFrame&, void* const)
native function bool IsCompletelyOpen();

simulated function OnToggle(SeqAct_Toggle Action)
{
    if(bAutomaticDoor)
    {
        return;
    }
    if(Action.InputLinks[0].bHasImpulse && WeldIntegrity <= 0)
    {
        OpenDoor(none);        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            CloseDoor();            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                UseDoor(none);
            }
        }
    }
}

function UseDoor(Pawn P)
{
    if((WorldInfo.TimeSeconds - LastUsedTime) < CoolDownTime)
    {
        return;
    }
    if(bAutomaticDoor)
    {
        return;
    }
    if(bIsDoorOpen)
    {
        CloseDoor();        
    }
    else
    {
        if(WeldIntegrity <= 0)
        {
            OpenDoor(P);
        }
    }
    LastUsedTime = WorldInfo.TimeSeconds;
}

event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local Pawn P;

    if((bAutomaticDoor && !bIsDoorOpen) && Role == ROLE_Authority)
    {
        P = Pawn(Other);
        if((P != none) && WeldIntegrity <= 0)
        {
            OpenDoor(P);
            SetTimer(3, false, 'CloseDoor');
        }
    }
    if((KFPawn(Other) != none) && !KFPawn(Other).IsHumanControlled())
    {
        if(KFPawn(Other).MyKFAIC != none)
        {
            KFPawn(Other).MyKFAIC.AILog_Internal((((string(GetFuncName()) $ " ") $ string(self)) $ " by ") $ string(KFPawn(Other).MyKFAIC), 'Doors');
        }
    }
}

protected simulated function OpenDoor(Pawn P)
{
    if(bIsDestroyed || WeldIntegrity > 0)
    {
        return;
    }
    bIsDoorOpen = true;
    bForceNetUpdate = true;
    bDoorMoveCompleted = false;
    if(DoorMechanism == 0)
    {
        OpenSwingingDoor(P);
    }
    SetTickIsDisabled(false);
    PlayMovingSound(false);
    MovementControl.SetSkelControlActive(true);
}

private final simulated function OpenSwingingDoor(Pawn P)
{
    local Vector X, Y, Z;
    local int DefaultYaw;

    if(Role == ROLE_Authority)
    {
        GetAxes(Rotation, X, Y, Z);
        if((P != none) && MovementControl.BlendTimeToGo <= float(0))
        {
            bReverseHinge = (((X Dot (P.Location - Location)) > 0) ? false : true);
        }
    }
    DefaultYaw = int(Abs(float(MovementControl.BoneRotation.Yaw)));
    MovementControl.BoneRotation.Yaw = ((bReverseHinge) ? -DefaultYaw : DefaultYaw);
}

private final simulated function CloseDoor()
{
    if(bIsDestroyed)
    {
        return;
    }
    bIsDoorOpen = false;
    bForceNetUpdate = true;
    bDoorMoveCompleted = false;
    SetTickIsDisabled(false);
    PlayMovingSound(true);
    MovementControl.SetSkelControlActive(false);
    if(DoorMechanism == 0)
    {
        SetTimer(OpenBlendTime * 0.65, false, 'TryPushPawns');        
    }
    else
    {
        SetTimer(OpenBlendTime * 0.5, false, 'TryPushPawns');
    }
}

event NotifyDoorMoveCompleted(bool bOpened)
{
    if(bOpened)
    {
        OnOpenFinish();        
    }
    else
    {
        OnCloseFinish();
    }
    SetRBCollideWithDeadPawn(!bOpened);
}

function OnOpenFinish()
{
    local DoorMarker DoorNav;

    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.StopEvents();
    }
    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        if(bMonitorDoor)
        {
            NotifyAIDoorOpened();
        }
        DoorNav.MoverOpened();
    }
    if(OpenedSound != none)
    {
        PlaySoundBase(OpenedSound,,,, SoundOrigin);
    }
}

function OnCloseFinish()
{
    local DoorMarker DoorNav;

    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.StopEvents();
    }
    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        DoorNav.MoverClosed();
    }
    if(ClosedSound != none)
    {
        PlaySoundBase(ClosedSound,,,, SoundOrigin);
    }
}

function Vector GetPushDirection(Vector PawnLocation)
{
    local bool bInFrontOfDoor;
    local Vector DoorX, DoorY, DoorZ, PushDir;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    bInFrontOfDoor = (DoorX Dot (PawnLocation - Location)) > 0;
    PushDir = float(750) * DoorX;
    PushDir *= float(((bInFrontOfDoor) ? 1 : -1));
    PushDir.Z = 50;
    return PushDir;
}

private final function TryPushPawns()
{
    local Pawn P;
    local bool bInFrontOfDoor;
    local Vector DoorX, DoorY, DoorZ, PushDir, OffsetLocation;

    local Rotator DoorYRot;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    DoorYRot = rotator(DoorY);
    OffsetLocation = Location + (DoorX * PushOriginOffset);
    foreach WorldInfo.AllPawns(Class'Pawn', P, Location, 200)
    {
        if(!P.IsAliveAndWell())
        {
            continue;            
        }
        if(!bIsDoorOpen && P.IsPlayerOwned())
        {
            if(PointDistToPlane(OffsetLocation, DoorYRot, P.Location) < float(40))
            {
                bInFrontOfDoor = (DoorX Dot (P.Location - OffsetLocation)) > 0;
                PushDir = float(750) * DoorX;
                if(DoorMechanism == 0)
                {
                    if(bReverseHinge)
                    {
                        PushDir *= float(-1);
                    }                    
                }
                else
                {
                    PushDir *= float(((bInFrontOfDoor) ? 1 : -1));
                }
                P.AddVelocity(PushDir, P.Location, Class'KFDT_Bludgeon');
            }
            continue;
        }
        if(!bIsDoorOpen)
        {
            if(PointDistToPlane(Location, DoorYRot, P.Location) < (0.85 * P.CylinderComponent.default.CollisionRadius))
            {
                OpenDoor(none);
            }
        }        
    }    
}

event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local KFPawn_Monster KFPM;
    local KFCharacterInfo_Monster MonsterInfo;

    if(Role < ROLE_Authority)
    {
        return;
    }
    super.TakeDamage(Damage, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if((bIsDestroyed || EventInstigator == none) || EventInstigator.bIsPlayer && class<KFDT_Explosive>(DamageType) == none)
    {
        return;
    }
    if(WeldIntegrity > 0)
    {
        KFPM = KFPawn_Monster(DamageCauser);
        if(KFPM != none)
        {
            MonsterInfo = KFPM.GetCharacterMonsterInfo();
            if(MonsterInfo != none)
            {
                PlaySoundBase(GetSoundEffectFromType(MonsterInfo),,,, SoundOrigin);
            }
        }
        if(Health > 0)
        {
            Health = Max(Health - Damage, 0);
            UpdateHealthMICs();
        }
        WeldIntegrity = Max(WeldIntegrity - Damage, 0);
        UpdateIntegrityMIC();
        if((WeldIntegrity <= 0) || Health <= 0)
        {
            WeldIntegrity = 0;
            DemoWeld = 0;
            Health = 0;
            UpdateIntegrityMIC();
            PlayDestroyed();
            if((MyMarker != none) && bMonitorDoor)
            {
                if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                {
                    KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIDestroyedDoor(KFAIController(EventInstigator), self, "Health:" $ string(Health));
                }
                NotifyAIDoorOpened();
            }
        }
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogDoorWeldEvent(Damage, MaxWeldIntegrity, WeldIntegrity, none, EventInstigator, self);
        }
        if(!bIsDestroyed)
        {
            IncrementHitCount(EventInstigator.Pawn);
            PlayTakeHitEffects();
        }
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayDoorTakeDamageDialog(self);
        }
        LastHitTime = WorldInfo.TimeSeconds;
        bForceNetUpdate = true;        
    }
    else
    {
        if(!bIsDoorOpen && class<KFDT_Ballistic>(DamageType) == none)
        {
            OpenDoor(EventInstigator.Pawn);
        }
    }
}

function FastenDoor(int Amount, optional KFPawn Welder)
{
    local KFPlayerController PC;
    local KFPerk WelderPerk;

    if(bIsDestroyed)
    {
        return;
    }
    if(Amount < 0)
    {
        if(WeldIntegrity > 0)
        {
            WeldIntegrity = Max(WeldIntegrity + Amount, 0);
            UpdateIntegrityMIC();
            bForceNetUpdate = true;
            if(!BeingWelded())
            {
                if(!BeingUnwelded())
                {
                    WelderPawn = Welder;
                }
            }
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayUnweldDialog(Welder, self, WelderPawn);
            }
            if(WelderPawn == Welder)
            {
                LastUnweldTime = WorldInfo.TimeSeconds;
            }
        }
        if(WeldIntegrity <= 0)
        {
            bShouldExplode = false;
            DemoWeld = 0;
            ExplosionInstigatorController = none;
        }        
    }
    else
    {
        if(!bIsDoorOpen && WeldIntegrity < MaxWeldIntegrity)
        {
            PC = KFPlayerController(Welder.Controller);
            if(PC != none)
            {
                PC.AddWeldPoints(Amount);
            }
            if(UnderAttack())
            {
                Amount *= CombatWeldModifier;
            }
            WelderPerk = PC.GetPerk();
            if((WelderPerk != none) && WelderPerk.CanExplosiveWeld())
            {
                AddExplosiveWeld(Amount, PC);
            }
            WeldIntegrity = Min(WeldIntegrity + Amount, MaxWeldIntegrity);
            UpdateIntegrityMIC();
            bForceNetUpdate = true;
            if(!BeingUnwelded())
            {
                if(!BeingWelded())
                {
                    WelderPawn = Welder;
                }
            }
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayWeldDialog(Welder, self, WelderPawn);
            }
            if(WelderPawn == Welder)
            {
                LastWeldTime = WorldInfo.TimeSeconds;
            }            
        }
        else
        {
            if(bIsDoorOpen)
            {
                CloseDoor();
            }
        }
    }
    if(!bIsDoorOpen)
    {
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogDoorWeldEvent(Amount, MaxWeldIntegrity, WeldIntegrity, Welder.Controller, none, self);
        }
    }
}

function AddExplosiveWeld(int Amount, KFPlayerController PC)
{
    DemoWeld = Min(DemoWeld + Amount, DemoWeldRequired);
    if((DemoWeld >= DemoWeldRequired) && !bShouldExplode)
    {
        ExplosionInstigatorController = PC;
        bShouldExplode = true;
    }
}

function IncrementHitCount(Pawn P)
{
    local Vector X, Y, Z;

    if(!bIsDoorOpen && P != none)
    {
        bForceNetUpdate = true;
        GetAxes(Rotation, X, Y, Z);
        ++ HitCount;
        if((X Dot (P.Location - Location)) > 0)
        {
            HitCount = byte(HitCount | 128);            
        }
        else
        {
            HitCount = byte(HitCount & byte(~128));
        }
    }
}

simulated function PlayTakeHitEffects()
{
    local name AnimName;
    local bool bReverseDir;

    if((bIsDestroyed || bIsDoorOpen) || WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    SetTickIsDisabled(false);
    if(((WorldInfo.TimeSeconds - CreationTime) > 1) && ActorEffectIsRelevant(Instigator, false))
    {
        bReverseDir = (HitCount & 128) > 0;
        AnimName = GetBashAnimName(bReverseDir);
        BashSlot.PlayCustomAnim(AnimName, 1);
        SpawnParticlesFromEffectParam(DamageEmitter, bReverseDir);
    }
}

simulated function name GetBashAnimName(bool bReverse)
{
    if(DoorMechanism == 0)
    {
        return ((bReverse) ? 'DoorBash_A' : 'DoorBash_B');
    }
    return ((bReverse) ? 'DoorBashSliding_A' : 'DoorBashSliding_B');
}

simulated function SpawnParticlesFromEffectParam(DestroyedEffectParams EffectParam, optional bool bReverseDir)
{
    local Vector Loc;
    local Rotator Rot;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EffectParam.ParticleEffect != none)
    {
        Loc = Location + EffectParam.RelativeOffset;
        Rot = Rotation + EffectParam.RelativeRotation;
        Rot.Yaw += ((bReverseDir) ? 32768 : 0);
        WorldInfo.MyEmitterPool.SpawnEmitter(EffectParam.ParticleEffect, Loc, Rot);
    }
}

simulated function PlayDestroyed()
{
    bForceNetUpdate = true;
    SetTickIsDisabled(false);
    bIsDestroyed = true;
    if(DestroyedSound != none)
    {
        PlaySoundBase(DestroyedSound,,,, SoundOrigin);
    }
    if(DoorMechanism == 0)
    {
        DestroyHingedDoor();        
    }
    else
    {
        DestroyNonPhysicsDoor();
    }
    if(bShouldExplode)
    {
        PlayExplosion();
        bShouldExplode = false;
    }
}

simulated function PlayExplosion()
{
    local KFExplosionActorReplicated ExploActor;
    local GameExplosion ExplosionTemplate;
    local KFPawn ExplosionInstigator;

    if(Role < ROLE_Authority)
    {
        return;
    }
    ExploActor = Spawn(Class'KFExplosionActorReplicated', self,, Location + vect(0, 0, 100),,, true);
    if(ExploActor != none)
    {
        ExploActor.InstigatorController = ExplosionInstigatorController;
        ExplosionInstigator = KFPawn(ExplosionInstigatorController.Pawn);
        if(ExplosionInstigator != none)
        {
            ExploActor.Instigator = ExplosionInstigator;
        }
        ExplosionTemplate = Class'KFPerk_Demolitionist'.static.GetDoorTrapsExplosionTemplate();
        ExplosionTemplate.MyDamageType = Class'KFPerk_Demolitionist'.static.GetDoorTrapsDamageTypeClass();
        ExploActor.Explode(ExplosionTemplate);
    }
}

simulated function DestroyNonPhysicsDoor()
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < DestroyedEmitters.Length)
    {
        SpawnParticlesFromEffectParam(DestroyedEmitters[I]);
        ++ I;
        goto J0x0C;
    }
    if(DoorMechanism == 1)
    {
        BashSlot.PlayCustomAnim('Door_Slide_broken', 1, 0.15, 0.2, true, true);
    }
}

simulated function ResetDoor()
{
    bIsDestroyed = false;
    bForceNetUpdate = true;
    SetTickIsDisabled(false);
    if(DoorMechanism == 0)
    {
        ResetHingedDoor();        
    }
    else
    {
        BashSlot.StopCustomAnim(0);
    }
    Health = MaxHealth;
    WeldIntegrity = 0;
    DemoWeld = 0;
    ExplosionInstigatorController = none;
    bShouldExplode = false;
    UpdateHealthMICs();
    UpdateHealthScalars('doorHealthA', 0);
    UpdateHealthScalars('doorHealthB', 0);
    UpdateHealthScalars('doorHealthC', 0);
    UpdateHealthScalars('doorHealthD', 0);
}

simulated function UpdateHealthMICs()
{
    local float HealthScaler;

    if(Health <= 0)
    {
        return;
    }
    if(HealthMICs.Length > 0)
    {
        HealthScaler = 1 - (float(Health) / float(MaxHealth));
        UpdateHealthScalars('doorHealthA', HealthScaler);
        if(HealthScaler >= 0.25)
        {
            UpdateHealthScalars('doorHealthB', (HealthScaler - 0.25) * 1.32);
        }
        if(HealthScaler >= 0.5)
        {
            UpdateHealthScalars('doorHealthC', (HealthScaler - 0.5) * 2);
        }
        if(HealthScaler >= 0.75)
        {
            UpdateHealthScalars('doorHealthD', (HealthScaler - 0.75) * 4);
        }
    }
}

simulated function UpdateHealthScalars(name ScalarName, float Value)
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < HealthMICs.Length)
    {
        HealthMICs[I].SetScalarParameterValue(ScalarName, Value);
        ++ I;
        goto J0x0C;
    }
}

simulated function UpdateIntegrityMIC()
{
    local float IntegrityScaler, ExplosiveScaler;

    if(IntegrityMIC != none)
    {
        if(WeldIntegrity > 0)
        {
            IntegrityScaler = FMax(float(WeldIntegrity) / float(MaxWeldIntegrity), MinWeldScalar);            
        }
        else
        {
            IntegrityScaler = 0;
        }
        IntegrityMIC.SetScalarParameterValue('doorWeld', IntegrityScaler);
        ExplosiveScaler = ((bShouldExplode) ? 1 : 0);
        IntegrityMIC.SetScalarParameterValue('scalar_explosive', ExplosiveScaler);
        if(CenterWeldComponent.HiddenGame && WeldIntegrity > 0)
        {
            CenterWeldComponent.SetHidden(false);            
        }
        else
        {
            if(!CenterWeldComponent.HiddenGame && WeldIntegrity <= 0)
            {
                CenterWeldComponent.SetHidden(true);
            }
        }
    }
}

simulated function SetRBCollideWithDeadPawn(bool bEnabled)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MeshAttachments.Length)
    {
        MeshAttachments[I].Component.SetRBCollidesWithChannel(16, bEnabled);
        ++ I;
        goto J0x0B;
    }
}

simulated function DestroyHingedDoor()
{
    local bool bReverseDir;
    local byte I;

    SkeletalMeshComp.bComponentUseFixedSkelBounds = false;
    if((WorldInfo.TimeSeconds - CreationTime) > 1)
    {
        bCallRigidBodyWakeEvents = true;
        bReverseDir = (HitCount & 128) > 0;
        I = 0;
        J0x89:

        if(I < DestroyedEmitters.Length)
        {
            SpawnParticlesFromEffectParam(DestroyedEmitters[I], bReverseDir);
            ++ I;
            goto J0x89;
        }
        SpawnBrokenDoors(bReverseDir);        
    }
    else
    {
        I = 0;
        J0xFD:

        if(I < MeshAttachments.Length)
        {
            MeshAttachments[I].Component.SetBlockRigidBody(false);
            MeshAttachments[I].Component.SetActorCollision(false, false);
            MeshAttachments[I].Component.SetHidden(true);
            ++ I;
            goto J0xFD;
        }
    }
}

simulated function SpawnBrokenDoors(bool bReverseDir)
{
    local KFKActorSpawnable_Door SpawnedKActor;
    local name BoneName;
    local Vector DoorX, DoorY, DoorZ, InitAngVel, AttachmentLocation;

    local Rotator AttachmentRotation;
    local byte I;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    DoorX *= float(((bReverseDir) ? -1 : 1));
    I = 0;
    J0x54:

    if(I < MeshAttachments.Length)
    {
        BoneName = MeshAttachments[I].AttachTo;
        AttachmentLocation = SkeletalMeshComp.GetBoneLocation(BoneName) + (DoorX * float(25));
        AttachmentRotation = QuatToRotator(SkeletalMeshComp.GetBoneQuaternion(BoneName)) + MeshAttachments[I].Component.Rotation;
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            SpawnedKActor = Spawn(Class'KFKActorSpawnable_Door', self,, AttachmentLocation, AttachmentRotation);
            if((SpawnedKActor != none) && MeshAttachments[I].Component != none)
            {
                InitBrokenAttachment(MeshAttachments[I].Component, SpawnedKActor);
                SpawnedKActor.StaticMeshComponent.SetRBLinearVelocity(DoorX * BrokenDoorImpulse);
                InitAngVel.X = MaxAngularVelocity * FRand();
                InitAngVel.Y = MaxAngularVelocity * FRand();
                InitAngVel.Z = MaxAngularVelocity * FRand();
                SpawnedKActor.StaticMeshComponent.SetRBAngularVelocity(InitAngVel);
                SpawnedKActor.StaticMeshComponent.WakeRigidBody();
            }
        }
        if(MeshAttachments[I].Component != none)
        {
            MeshAttachments[I].Component.SetHidden(true);
            MeshAttachments[I].Component.SetBlockRigidBody(false);
            MeshAttachments[I].Component.SetActorCollision(false, false);
        }
        ++ I;
        goto J0x54;
    }
}

simulated function ResetHingedDoor()
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < MeshAttachments.Length)
    {
        MeshAttachments[I].Component.SetBlockRigidBody(true);
        MeshAttachments[I].Component.SetActorCollision(true, true);
        MeshAttachments[I].Component.SetHidden(false);
        ++ I;
        goto J0x0C;
    }
    SkeletalMeshComp.bComponentUseFixedSkelBounds = true;
}

private final simulated function PlayMovingSound(bool bClosing)
{
    local AkBaseSoundObject SoundToPlay, AmbientToPlay;

    if(bClosing)
    {
        SoundToPlay = CloseSound;
        AmbientToPlay = OpeningAmbientSound;        
    }
    else
    {
        SoundToPlay = OpenSound;
        AmbientToPlay = ClosingAmbientSound;
    }
    if(SoundToPlay != none)
    {
        PlaySoundBase(SoundToPlay, true,,, SoundOrigin);
    }
    if(AkEvent(AmbientToPlay) != none)
    {
        AmbientSoundComponent.StopEvents();
        AmbientSoundComponent.PlayEvent(AkEvent(AmbientToPlay));
    }
}

function AkEvent GetSoundEffectFromType(KFCharacterInfo_Monster DamagingMonsterInfo)
{
    switch(DoorMaterial)
    {
        case 0:
            return DamagingMonsterInfo.DoorHitSound.Metal;
            break;
        case 1:
            return DamagingMonsterInfo.DoorHitSound.Wood;
            break;
        default:
            break;
    }
}

function bool UnderAttack()
{
    return (WorldInfo.TimeSeconds - LastHitTime) < CombatLength;
}

function bool BeingWelded()
{
    return (LastWeldTime > LastUnweldTime) && (WorldInfo.TimeSeconds - LastWeldTime) < 0.75;
}

function bool BeingUnwelded()
{
    return (LastUnweldTime > LastWeldTime) && (WorldInfo.TimeSeconds - LastUnweldTime) < 0.75;
}

event NotifyPathChanged();

function bool WeldedShut()
{
    return !IsCompletelyOpen() && WeldIntegrity > 0;
}

function NotifyAIDoorOpened()
{
    local DoorMarker DoorNav;
    local KFAIController KFAIC;

    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        if(bMonitorDoor)
        {
            foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
            {
                if(KFAIC.PendingDoor == self)
                {
                    KFAIC.DoorFinished();
                }                
            }            
        }
        DoorNav.MoverOpened();
    }
}

simulated event DrawTemporaryWeldIcon(HUD HUD, Canvas C)
{
    local PlayerController PC;
    local Canvas Canvas;
    local Vector CameraLoc, ScreenLoc;
    local Rotator CameraRot;
    local string Str;
    local float X, Y;
    local FontRenderInfo FRI;
    local float Dot;
    local Texture2D Icon;
    local float WeldPercentageFloat;
    local int WeldPercentage;
    local float FontScale;

    PC = HUD.PlayerOwner;
    Canvas = C;
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.Font = Class'KFGameEngine'.static.GetKFCanvasFont();
    PC.GetPlayerViewPoint(CameraLoc, CameraRot);
    Dot = vector(CameraRot) Dot (Location - CameraLoc);
    if(Dot < 0.5)
    {
        return;
    }
    ScreenLoc = Canvas.Project(Location + (vect(0, 0, 1) * 164));
    if(((ScreenLoc.X < float(0)) || ScreenLoc.X >= HUD.Canvas.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    Icon = Texture2D'welder_door_icon';
    Canvas.SetPos(ScreenLoc.X - float(Icon.SizeX / 2), ScreenLoc.Y - float(Icon.SizeY / 2), ScreenLoc.Z);
    Canvas.DrawTexture(Icon, 1);
    X = (ScreenLoc.X + float(Icon.SizeX / 2)) + float(5);
    Y = ScreenLoc.Y - float(Icon.SizeY / 2);
    Canvas.SetPos(X, Y);
    FontScale = Class'KFGameEngine'.static.GetKFFontScale();
    WeldPercentageFloat = (float(WeldIntegrity) / float(MaxWeldIntegrity)) * 100;
    if((WeldPercentageFloat < 1) && WeldPercentageFloat > 0)
    {
        WeldPercentageFloat = 1;        
    }
    else
    {
        if((WeldPercentageFloat > 99) && WeldPercentageFloat < 100)
        {
            WeldPercentageFloat = 99;
        }
    }
    WeldPercentage = int(WeldPercentageFloat);
    Str = (WeldIntegrityString @ string(WeldPercentage)) $ "%";
    Canvas.DrawText(Str, true, FontScale, FontScale, FRI);
    if((DemoWeld > 0) && !bShouldExplode)
    {
        Canvas.SetPos(X, Y + 20);
        WeldPercentage = int((float(DemoWeld) / float(DemoWeldRequired)) * 100);
        Str = (ExplosiveString @ string(WeldPercentage)) $ "%";
        Canvas.DrawText(Str, true, FontScale, FontScale, FRI);
    }
}

defaultproperties
{
    MeshAttachments(0)=(Component=StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent0',AttachTo=DoorLeft,bSocketAttach=false)
    MeshAttachments(1)=(Component=StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent1',AttachTo=DoorRight,bSocketAttach=false)
    begin object name=StaticMeshComponent2 class=StaticMeshComponent
        ReplacementPrimitive=none
        bAllowApproximateOcclusion=true
        bForceDirectLightMap=true
        bUsePrecomputedShadows=true
        CollideActors=false
        BlockRigidBody=false
        LightingChannels=(bInitialized=true,Indoor=true,Outdoor=true)
    object end
    // Reference: StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent2'
    CenterWeldComponent=StaticMeshComponent2
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    SkeletalMeshComp=SkeletalMeshComponent0
    CoolDownTime=0.5
    OpenBlendTime=0.5
    HingedRotation=90
    SlideTranslation=-100
    LiftTranslation=245
    bDoorMoveCompleted=true
    bIsDoorOpen=true
    MaxHealth=4000
    MaxWeldIntegrity=1500
    DemoWeldRequired=500
    MinWeldScalar=0.08
    CombatWeldModifier=0.6
    CombatLength=1.25
    FrameSizeOfTwoDoors=256
    BrokenDoorImpulse=750
    MaxAngularVelocity=2
    DamageEmitter=(ParticleEffect=none,RelativeOffset=(X=0,Y=0,Z=0),RelativeRotation=(Pitch=0,Yaw=0,Roll=0),MaxSpawnDist=4000,PSC=none)
    WeldIntegrityString="Weld Integrity:"
    ExplosiveString="Door Trap:"
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.door'
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
        Translation=(X=40,Y=0,Z=40)
    object end
    // Reference: SpriteComponent'Default__KFDoorActor.Sprite'
    Components(0)=Sprite
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    Components(1)=SkeletalMeshComponent0
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bNoDelete=true
    bTickIsDisabled=true
    bWorldGeometry=true
    bCanStepUpOn=false
    bAlwaysRelevant=true
    bSkipActorPropertyReplication=true
    bOnlyDirtyReplication=true
    bReplicateRigidBodyLocation=true
    bCanBeDamaged=true
    bCollideActors=true
    bBlockActors=true
    bProjTarget=true
    bNoEncroachCheck=true
    bEdShouldSnap=true
    bIgnoreNetRelevancyCollision=true
    NetUpdateFrequency=0.1
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    CollisionComponent=SkeletalMeshComponent0
}