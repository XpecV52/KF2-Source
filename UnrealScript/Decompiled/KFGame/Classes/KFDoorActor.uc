/*******************************************************************************
 * KFDoorActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDoorActor extends KFWeldableActor
    native
    nativereplication
    placeable
    hidecategories(Navigation,Movement,Collision,Physics,Object,Mobile);

const SkeletalMesh_Width = 256;
const KActorOffset = 25;
const HIT_DIRECTION_FLAG = 0x80;
const DoorWidth = 200;
const HumanPushDistance = 40;
const SlidingPushForce = 750;
const VerticalPushForce = 100;
const BashHingedAnim_F = 'DoorBash_A';
const BashHingedAnim_B = 'DoorBash_B';
const BashSlidingAnim_F = 'DoorBashSliding_A';
const BashSlidingAnim_B = 'DoorBashSliding_B';

enum EDoorMaterialType
{
    EDMT_Metal,
    EDMT_Wood,
    EDMT_MAX
};

enum EDoorMechanism
{
    EDM_Hinge,
    EDM_Slide,
    EDM_Lift,
    EDM_MAX
};

enum EDoorFastening
{
    EDF_ArcWelding,
    EDF_Rivets,
    EDF_MAX
};

struct native DoorMeshAttachment
{
    /** @name Meshes / Materials / Particles */
    var() export editinline StaticMeshComponent Component;
    /** Component which needs to be attached */
    var() name AttachTo;
    /** Bone or socket name to which the attachment should be attached */
    var() bool bSocketAttach;

    structdefaultproperties
    {
        Component=none
        AttachTo=DoorLeft
        bSocketAttach=false
    }
};

var KFDoorTrigger DoorTrigger;
var bool bIsInteractive;
/** If set, door opens and closes automatically */
var(Opening) const editconst bool bAutomaticDoor;
var transient bool bDoorMoveCompleted;
/** current state of the door if it hasn't been destroyed - note it's possible for bIsDoorOpen to be false and bIsDoorDestroyed to be true so check both */
var() bool bStartDoorOpen;
var repnotify transient bool bIsDoorOpen;
var transient bool bLocalIsDoorOpen;
var transient bool bReverseHinge;
var transient bool bCanCloseDoor;
var transient bool bHasBeenDirtied;
var repnotify transient bool bShouldExplode;
var bool bMonitorDoor;
/** Information of all the mesh attachments for the vehicle */
var() array<DoorMeshAttachment> MeshAttachments;
/** Mesh for the weld that goes between the center of two doors or the end of the left door */
var() export editinline StaticMeshComponent CenterWeldComponent;
/** skeletal mesh used for open/close animations */
var() const editconst export editinline SkeletalMeshComponent SkeletalMeshComp;
var array<MaterialInstanceConstant> HealthMICs;
var() KFDoorActor.EDoorMaterialType DoorMaterial;
/** type of networking to use */
var(Opening) KFDoorActor.EDoorMechanism DoorMechanism;
var KFDoorActor.EDoorFastening FastenerType;
var repnotify transient byte HitCount;
/** The amount of time before a door can be used again */
var(Opening) float CoolDownTime;
/** The time it takes to open / close a door */
var(Opening) float OpenBlendTime;
/** ONLY FOR HINGED DOORS Defines how far we want to open our hinged doors in degrees */
var(Opening) int HingedRotation;
/** ONLY FOR SLIDING DOORS Defines how far we want sliding doors to move */
var(Opening) int SlideTranslation;
/** ONLY FOR LIFT DOORS Defines how far we want lift doors to raise */
var(Opening) int LiftTranslation;
var transient float LastUsedTime;
/** Starting health for a door */
var() int MaxHealth;
var repnotify transient int Health;
var transient KFPlayerController ExplosionInstigatorController;
/** While the door is being attacked it takes longer to weld */
var() float CombatWeldModifier<ClampMin=0.0|ClampMax=1.0>;
var float CombatLength;
var transient float LastHitTime;
var transient SkelControlSingleBone MovementControl;
var transient AnimNodeSlot BashSlot;
/** A scaler to fit a door into its proper frame. Double the frame size if we are only using one door for this actor */
var() float FrameSizeOfTwoDoors;
var NavigationPoint MyMarker;
/** The impulse to provide the doors when they are destroyed */
var() float BrokenDoorImpulse;
/** The maximum angular velocity applied to a broken hinged door */
var() float MaxAngularVelocity;
var array<KActor> BrokenDoorPhysicsActors;
/** sound played when the mover is interpolated forward */
var(Sound) AkBaseSoundObject OpenSound;
/** looping sound while opening */
var(Sound) AkBaseSoundObject OpeningAmbientSound;
/** sound played when mover finished moving forward */
var(Sound) AkBaseSoundObject OpenedSound;
/** sound played when the mover is interpolated in reverse */
var(Sound) AkBaseSoundObject CloseSound;
/** looping sound while closing */
var(Sound) AkBaseSoundObject ClosingAmbientSound;
/** sound played when mover finished moving backward */
var(Sound) AkBaseSoundObject ClosedSound;
/** sound played when door is destroyed */
var(Sound) AkBaseSoundObject DestroyedSound;
var export editinline AkComponent AmbientSoundComponent;
var transient Vector SoundOrigin;
/** played when the melee attack hits world geometry */
var() DestroyedEffectParams DamageEmitter;
/** played when the melee attack hits world geometry and the door has no health */
var() array<DestroyedEffectParams> DestroyedEmitters;
var export editinline transient array<export editinline ParticleSystemComponent> BrokenDoorParticleEffects;
var() FXTemplate OnDoorOpenEmitterTemplate;
var export editinline ParticleSystemComponent OnDoorOpenEmitter;
var transient Vector VisualDoorLocation;
var const localized string ExplosiveString;

replication
{
     if(bNetDirty)
        Health, HitCount, 
        bIsDoorOpen, bIsInteractive, 
        bShouldExplode;

     if(bNetDirty && DoorMechanism == 0)
        bReverseHinge;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'bIsDoorOpen')
    {
        if(bIsDoorOpen)
        {
            if(MovementControl.StrengthTarget == float(0))
            {
                OpenDoor(none);
            }            
        }
        else
        {
            CloseDoor();
        }        
    }
    else
    {
        if(VarName == 'Health')
        {
            UpdateHealthMICs();
            if(Health <= 0)
            {
                UpdateIntegrityMIC();
            }            
        }
        else
        {
            if(VarName == 'bShouldExplode')
            {
                UpdateIntegrityMIC();                
            }
            else
            {
                if(VarName == 'HitCount')
                {
                    PlayTakeHitEffects();                    
                }
                else
                {
                    super.ReplicatedEvent(VarName);
                }
            }
        }
    }
}

// Export UKFDoorActor::execInitBrokenAttachment(FFrame&, void* const)
native function InitBrokenAttachment(StaticMeshComponent Attachment, KFKActorSpawnable SpawnedKActor);

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    MovementControl = SkelControlSingleBone(SkelComp.FindSkelControl('MovementControl'));
    BashSlot = AnimNodeSlot(SkeletalMeshComp.FindAnimNode('Slot_Bash'));
    InitSkelControl();
}

simulated event PostBeginPlay()
{
    local int I, NumActualDoors;
    local float MyRadius, MyHeight;
    local Vector X, Y, Z;

    super.PostBeginPlay();
    Health = MaxHealth;
    LastUsedTime = WorldInfo.TimeSeconds - CoolDownTime;
    if((OpeningAmbientSound != none) || ClosingAmbientSound != none)
    {
        AmbientSoundComponent = new (self) Class'AkComponent';
        AttachComponent(AmbientSoundComponent);
    }
    InitializeDoorMIC();
    if(CenterWeldComponent != none)
    {
        CenterWeldComponent.SetHidden(bStartDoorOpen);
    }
    if(Class'KFAIController'.default.bUseNavMesh)
    {
    }
    I = 0;
    J0x10A:

    if(I < MeshAttachments.Length)
    {
        if(MeshAttachments[I].Component.StaticMesh != none)
        {
            SoundOrigin += MeshAttachments[I].Component.Bounds.Origin;
            ++ NumActualDoors;
        }
        ++ I;
        goto J0x10A;
    }
    if(NumActualDoors > 0)
    {
        SoundOrigin /= float(NumActualDoors);        
    }
    else
    {
        SoundOrigin = Location;
    }
    if(NumActualDoors > 1)
    {
        VisualDoorLocation = WeldUILocation;        
    }
    else
    {
        GetAxes(Rotation, X, Y, Z);
        GetBoundingCylinder(MyRadius, MyHeight);
        VisualDoorLocation = WeldUILocation - ((MyRadius * 0.25) * Y);
    }
}

simulated function InitializeDoorMIC()
{
    local MaterialInstanceConstant NewMIC, AltMIC;
    local byte I, MaterialIndex;

    if((HealthMICs.Length <= 0) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(MeshAttachments.Length > 0)
        {
            MaterialIndex = 0;
            J0x57:

            if(MaterialIndex < MeshAttachments[0].Component.GetNumElements())
            {
                if(MeshAttachments[0].Component.GetMaterial(MaterialIndex) != none)
                {
                    NewMIC = new Class'MaterialInstanceConstant';
                    NewMIC.SetParent(MeshAttachments[0].Component.GetMaterial(MaterialIndex));
                    HealthMICs.AddItem(NewMIC;
                    I = 0;
                    J0x178:

                    if(I < MeshAttachments.Length)
                    {
                        if(MeshAttachments[I].Component.GetMaterial(MaterialIndex) == NewMIC.Parent)
                        {
                            MeshAttachments[I].Component.SetMaterial(MaterialIndex, NewMIC);                            
                        }
                        else
                        {
                            AltMIC = new Class'MaterialInstanceConstant';
                            AltMIC.SetParent(MeshAttachments[I].Component.GetMaterial(MaterialIndex));
                            HealthMICs.AddItem(AltMIC;
                            MeshAttachments[I].Component.SetMaterial(MaterialIndex, AltMIC);
                        }
                        ++ I;
                        goto J0x178;
                    }
                }
                ++ MaterialIndex;
                goto J0x57;
            }
        }
        if((CenterWeldComponent != none) && CenterWeldComponent.GetMaterial(0) != none)
        {
            IntegrityMIC = CenterWeldComponent.CreateAndSetMaterialInstanceConstant(0);
            IntegrityMIC.SetScalarParameterValue('doorWeld', 0);
            UpdateIntegrityMIC();
        }
    }
}

simulated function InitSkelControl()
{
    MovementControl.BlendInTime = OpenBlendTime;
    MovementControl.BlendOutTime = OpenBlendTime;
    switch(DoorMechanism)
    {
        case 0:
            MovementControl.bApplyTranslation = false;
            MovementControl.bApplyRotation = true;
            MovementControl.BoneRotation.Yaw = int(float(HingedRotation) * 182.0444);
            break;
        case 1:
            MovementControl.bApplyTranslation = true;
            MovementControl.bApplyRotation = false;
            MovementControl.BoneTranslation.Y = float(SlideTranslation);
            MovementControl.BoneTranslation.Z = 0;
            break;
        case 2:
            MovementControl.bApplyTranslation = true;
            MovementControl.bApplyRotation = false;
            MovementControl.BoneTranslation.Y = 0;
            MovementControl.BoneTranslation.Z = float(LiftTranslation);
            break;
        default:
            break;
    }
    if(Role == ROLE_Authority)
    {
        MovementControl.SetSkelControlStrength(((bStartDoorOpen) ? 1 : 0), 0);
        bIsDoorOpen = bStartDoorOpen;
        bLocalIsDoorOpen = bStartDoorOpen;
        WeldIntegrity = ((bStartWelded && !bStartDoorOpen) ? MaxWeldIntegrity : 0);
    }
}

// Export UKFDoorActor::execIsCompletelyOpen(FFrame&, void* const)
native function bool IsCompletelyOpen();

simulated function OnToggle(SeqAct_Toggle Action)
{
    if(bAutomaticDoor)
    {
        return;
    }
    if(Action.InputLinks[0].bHasImpulse && WeldIntegrity <= 0)
    {
        OpenDoor(none);        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            CloseDoor();            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                UseDoor(none);
            }
        }
    }
}

function UseDoor(Pawn P)
{
    if((WorldInfo.TimeSeconds - LastUsedTime) < CoolDownTime)
    {
        return;
    }
    if(bAutomaticDoor)
    {
        return;
    }
    if(bIsDoorOpen)
    {
        CloseDoor();        
    }
    else
    {
        if(WeldIntegrity <= 0)
        {
            OpenDoor(P);
        }
    }
    LastUsedTime = WorldInfo.TimeSeconds;
}

event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local Pawn P;

    if((bAutomaticDoor && !bIsDoorOpen) && Role == ROLE_Authority)
    {
        P = Pawn(Other);
        if((P != none) && WeldIntegrity <= 0)
        {
            OpenDoor(P);
            SetTimer(3, false, 'CloseDoor');
        }
    }
    if((KFPawn(Other) != none) && !KFPawn(Other).IsHumanControlled())
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging && KFPawn(Other).MyKFAIC != none)
        {
            KFPawn(Other).MyKFAIC.AILog_Internal((((string(GetFuncName()) $ " ") $ string(self)) $ " by ") $ string(KFPawn(Other).MyKFAIC), 'Doors');
        }
    }
}

protected simulated function OpenDoor(Pawn P)
{
    local Vector Loc;
    local Rotator Rot;

    if((bIsDestroyed || bLocalIsDoorOpen) || WeldIntegrity > 0)
    {
        return;
    }
    bIsDoorOpen = true;
    bForceNetUpdate = true;
    bDoorMoveCompleted = false;
    bLocalIsDoorOpen = true;
    if(DoorMechanism == 0)
    {
        OpenSwingingDoor(P);
    }
    SetTickIsDisabled(false);
    PlayMovingSound(false);
    MovementControl.SetSkelControlActive(true);
    if((OnDoorOpenEmitterTemplate.ParticleTemplate != none) && (OnDoorOpenEmitter == none) || !OnDoorOpenEmitter.bIsActive)
    {
        if(OnDoorOpenEmitter != none)
        {
            OnDoorOpenEmitter.DeactivateSystem();
        }
        Loc = Location + OnDoorOpenEmitterTemplate.RelativeOffset;
        Rot = Rotation + OnDoorOpenEmitterTemplate.RelativeRotation;
        OnDoorOpenEmitter = WorldInfo.MyEmitterPool.SpawnEmitter(OnDoorOpenEmitterTemplate.ParticleTemplate, Loc, Rot);
    }
}

private final simulated function OpenSwingingDoor(Pawn P)
{
    local Vector X, Y, Z;
    local int DefaultYaw;

    if(Role == ROLE_Authority)
    {
        GetAxes(Rotation, X, Y, Z);
        if((P != none) && MovementControl.BlendTimeToGo <= float(0))
        {
            bReverseHinge = (((X Dot (P.Location - Location)) > 0) ? false : true);
        }
    }
    DefaultYaw = int(Abs(float(MovementControl.BoneRotation.Yaw)));
    MovementControl.BoneRotation.Yaw = ((bReverseHinge) ? -DefaultYaw : DefaultYaw);
}

private final simulated function CloseDoor()
{
    if((bIsDestroyed || !bLocalIsDoorOpen) || !bCanCloseDoor)
    {
        return;
    }
    bHasBeenDirtied = true;
    bIsDoorOpen = false;
    bForceNetUpdate = true;
    bDoorMoveCompleted = false;
    bLocalIsDoorOpen = false;
    SetTickIsDisabled(false);
    PlayMovingSound(true);
    MovementControl.SetSkelControlActive(false);
    if(DoorMechanism == 0)
    {
        SetTimer(OpenBlendTime * 0.65, false, 'TryPushPawns');        
    }
    else
    {
        SetTimer(OpenBlendTime * 0.5, false, 'TryPushPawns');
    }
}

event NotifyDoorMoveCompleted(bool bOpened)
{
    if(bOpened)
    {
        OnOpenFinish();        
    }
    else
    {
        OnCloseFinish();
    }
    SetRBCollideWithDeadPawn(!bOpened);
}

function OnOpenFinish()
{
    local DoorMarker DoorNav;

    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.StopEvents();
    }
    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        if(bMonitorDoor)
        {
            NotifyAIDoorOpened();
        }
        DoorNav.MoverOpened();
    }
    if(OpenedSound != none)
    {
        PlaySoundBase(OpenedSound,,,, SoundOrigin);
    }
}

function OnCloseFinish()
{
    local DoorMarker DoorNav;

    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.StopEvents();
    }
    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        DoorNav.MoverClosed();
    }
    if(ClosedSound != none)
    {
        PlaySoundBase(ClosedSound,,,, SoundOrigin);
    }
}

function Vector GetPushDirection(Vector PawnLocation)
{
    local bool bInFrontOfDoor;
    local Vector DoorX, DoorY, DoorZ, PushDir;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    bInFrontOfDoor = (DoorX Dot (PawnLocation - Location)) > 0;
    PushDir = float(750) * DoorX;
    PushDir *= float(((bInFrontOfDoor) ? 1 : -1));
    PushDir.Z = 50;
    return PushDir;
}

private final function TryPushPawns()
{
    local Pawn P;
    local bool bInFrontOfDoor;
    local Vector DoorX, DoorY, DoorZ, PushDir, OffsetLocation;

    local Rotator DoorYRot;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    DoorYRot = rotator(DoorY);
    OffsetLocation = Location + DoorX;
    foreach WorldInfo.AllPawns(Class'Pawn', P, Location, 200)
    {
        if(!P.IsAliveAndWell())
        {
            continue;            
        }
        if(!bIsDoorOpen && P.IsPlayerOwned())
        {
            if(PointDistToPlane(OffsetLocation, DoorYRot, P.Location) < float(40))
            {
                bInFrontOfDoor = (DoorX Dot (P.Location - OffsetLocation)) > 0;
                PushDir = float(750) * DoorX;
                if(DoorMechanism == 0)
                {
                    if(bReverseHinge)
                    {
                        PushDir *= float(-1);
                    }                    
                }
                else
                {
                    PushDir *= float(((bInFrontOfDoor) ? 1 : -1));
                }
                PushDir.Z += float(100);
                P.AddVelocity(PushDir, P.Location, Class'KFDT_Bludgeon');
            }
            continue;
        }
        if(!bIsDoorOpen)
        {
            if(PointDistToPlane(Location, DoorYRot, P.Location) < (0.85 * P.CylinderComponent.default.CollisionRadius))
            {
                OpenDoor(none);
            }
        }        
    }    
}

simulated function InitializeWeldableComponent()
{
    WeldableComponent.SetOwner(self);
    WeldableComponent.WeldIntegrity = ((bStartWelded && !bStartDoorOpen) ? MaxWeldIntegrity : 0);
    WeldableComponent.MaxWeldIntegrity = MaxWeldIntegrity;
    WeldableComponent.DemoWeldRequired = DemoWeldRequired;
    WeldableComponent.bWeldable = true;
    WeldableComponent.bUnweldable = true;
    WeldableComponent.bRepairable = true;
    WeldableComponent.__Delegate_AdjustWeldAmount__Delegate = AdjustWeldCompWeldAmount;
    WeldableComponent.__Delegate_OnWeldIntegrityChanged__Delegate = OnWeldCompWeldIntegrityChanged;
    WeldableComponent.__Delegate_OnRepairProgressChanged__Delegate = OnWeldCompRepairProgressChanged;
    WeldableComponent.SetCollisionCylinderSize(200, 200);
}

function AdjustWeldCompWeldAmount(out int Amount)
{
    if(UnderAttack())
    {
        Amount *= CombatWeldModifier;
    }
}

simulated function OnWeldCompWeldIntegrityChanged(int Amount, KFPawn Welder)
{
    if(Role == ROLE_Authority)
    {
        FastenWeld(Amount, Welder);
        WeldableComponent.SetWeldIntegrity(WeldIntegrity);        
    }
    else
    {
        WeldIntegrity = WeldableComponent.WeldIntegrity;
        DemoWeld = WeldableComponent.DemoWeld;
        UpdateIntegrityMIC();
    }
}

simulated function OnWeldCompRepairProgressChanged(float Amount, KFPawn Welder)
{
    if(Role == ROLE_Authority)
    {
        Repair(Amount, Welder);        
    }
    else
    {
        RepairProgress = WeldableComponent.RepairProgress;
    }
}

event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local KFPawn_Monster KFPM;
    local KFCharacterInfo_Monster MonsterInfo;
    local class<KFDamageType> KFDT;

    if(Role < ROLE_Authority)
    {
        return;
    }
    if(!bIsInteractive)
    {
        return;
    }
    super(Actor).TakeDamage(Damage, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if(bIsDestroyed || !AllowDamageFrom(EventInstigator, DamageType))
    {
        return;
    }
    if(WeldIntegrity > 0)
    {
        KFPM = KFPawn_Monster(DamageCauser);
        if(KFPM != none)
        {
            MonsterInfo = KFPM.GetCharacterMonsterInfo();
            if(MonsterInfo != none)
            {
                PlaySoundBase(GetSoundEffectFromType(MonsterInfo),,,, SoundOrigin);
            }
        }
        if(Health > 0)
        {
            Health = Max(Health - Damage, 0);
            UpdateHealthMICs();
        }
        UpdateWeldIntegrity(-Damage);
        WeldableComponent.UpdateWeldIntegrity(-Damage);
        if((WeldIntegrity <= 0) || Health <= 0)
        {
            DestroyDoor(EventInstigator);
        }
        if(!bIsDestroyed)
        {
            IncrementHitCount(EventInstigator.Pawn);
            PlayTakeHitEffects();
        }
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayDoorTakeDamageDialog(self);
        }
        LastHitTime = WorldInfo.TimeSeconds;
        bForceNetUpdate = true;        
    }
    else
    {
        if(((!bIsDoorOpen && EventInstigator != none) && EventInstigator.Pawn != none) && EventInstigator.GetTeamNum() == 255)
        {
            KFDT = class<KFDamageType>(DamageType);
            if((KFDT != none) && KFDT.default.bAllowAIDoorDestruction)
            {
                IncrementHitCount(EventInstigator.Pawn);
                DestroyDoor(EventInstigator);                
            }
            else
            {
                if(class<KFDT_Ballistic>(DamageType) == none)
                {
                    OpenDoor(EventInstigator.Pawn);
                }
            }
        }
    }
}

function DestroyDoor(optional Controller DestructionInstigator)
{
    WeldIntegrity = 0;
    DemoWeld = 0;
    Health = 0;
    WeldableComponent.SetWeldIntegrity(0);
    WeldableComponent.SetDemoWeld(0);
    UpdateIntegrityMIC();
    PlayDestroyed();
    if((MyMarker != none) && bMonitorDoor)
    {
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogAIDestroyedDoor(KFAIController(DestructionInstigator), self, "Health:" $ string(Health));
        }
        NotifyAIDoorOpened();
    }
}

function bool AllowDamageFrom(Controller EventInstigator, class<DamageType> DamageType)
{
    if((EventInstigator == none) || (EventInstigator.GetTeamNum() == 0) && class<KFDT_Explosive>(DamageType) == none)
    {
        return false;
    }
    return true;
}

function FastenWeld(int Amount, optional KFPawn Welder)
{
    local KFPlayerController PC;
    local KFPerk WelderPerk;

    if(bIsDestroyed)
    {
        return;
    }
    if(Amount < 0)
    {
        if(WeldIntegrity > 0)
        {
            UpdateWeldIntegrity(Amount);
            if(!BeingWelded())
            {
                if(!BeingUnwelded())
                {
                    WelderPawn = Welder;
                }
            }
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayUnweldDialog(Welder, self, WelderPawn);
            }
            if(WelderPawn == Welder)
            {
                LastUnweldTime = WorldInfo.TimeSeconds;
            }
        }
        if(WeldIntegrity <= 0)
        {
            bShouldExplode = false;
            DemoWeld = 0;
            ExplosionInstigatorController = none;
            WeldableComponent.SetDemoWeld(0);
        }        
    }
    else
    {
        if(!bIsDoorOpen && WeldIntegrity < MaxWeldIntegrity)
        {
            PC = KFPlayerController(Welder.Controller);
            if(PC != none)
            {
                PC.AddWeldPoints(Amount);
            }
            if(UnderAttack())
            {
                Amount *= CombatWeldModifier;
            }
            WelderPerk = PC.GetPerk();
            if((WelderPerk != none) && WelderPerk.CanExplosiveWeld())
            {
                AddExplosiveWeld(Amount, PC);
            }
            bHasBeenDirtied = true;
            UpdateWeldIntegrity(Amount);
            if(WeldIntegrity == MaxWeldIntegrity)
            {
                PC.UnlockHoldOut();
            }
            if(!BeingUnwelded())
            {
                if(!BeingWelded())
                {
                    WelderPawn = Welder;
                }
            }
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayWeldDialog(Welder, self, WelderPawn);
            }
            if(WelderPawn == Welder)
            {
                LastWeldTime = WorldInfo.TimeSeconds;
            }            
        }
        else
        {
            if((!bIsDoorOpen && WeldIntegrity >= MaxWeldIntegrity) && DemoWeld < DemoWeldRequired)
            {
                PC = KFPlayerController(Welder.Controller);
                if(PC != none)
                {
                    WelderPerk = PC.GetPerk();
                    if((WelderPerk != none) && WelderPerk.CanExplosiveWeld())
                    {
                        AddExplosiveWeld(Amount, PC);
                        UpdateIntegrityMIC();
                        bForceNetUpdate = true;
                    }
                }                
            }
            else
            {
                if(bIsDoorOpen)
                {
                    CloseDoor();
                }
            }
        }
    }
}

simulated function CompleteRepair()
{
    ResetDoor(true);
}

function Repair(float Amount, optional KFPawn Welder)
{
    local byte ByteAmount;
    local KFPlayerController KFPC;

    if(bIsDestroyed)
    {
        ByteAmount = FloatToByte(Amount);
        if((RepairProgress + ByteAmount) >= 255)
        {
            CompleteRepair();
            if(WorldInfo.NetMode != NM_Standalone)
            {
                bWasRepaired = true;
                SetTimer(0.1, false, 'Timer_ResetRepairFlag');
            }
            if(Welder != none)
            {
                KFPC = KFPlayerController(Welder.Controller);
                if(KFPC != none)
                {
                    KFPC.DoorRepaired();
                }
            }            
        }
        else
        {
            RepairProgress += ByteAmount;
        }
        bForceNetUpdate = true;
    }
}

function Timer_ResetRepairFlag()
{
    bWasRepaired = false;
}

function AddExplosiveWeld(int Amount, KFPlayerController PC)
{
    super.AddExplosiveWeld(Amount, PC);
    if((DemoWeld >= DemoWeldRequired) && !bShouldExplode)
    {
        ExplosionInstigatorController = PC;
        bShouldExplode = true;
        bForceNetUpdate = true;
    }
}

function bool CanExplosiveWeld()
{
    return true;
}

function IncrementHitCount(Pawn P)
{
    local Vector X, Y, Z;

    if(!bIsDoorOpen && P != none)
    {
        bForceNetUpdate = true;
        GetAxes(Rotation, X, Y, Z);
        ++ HitCount;
        if((X Dot (P.Location - Location)) > 0)
        {
            HitCount = byte(HitCount | 128);            
        }
        else
        {
            HitCount = byte(HitCount & byte(~128));
        }
    }
}

simulated function PlayTakeHitEffects()
{
    local name AnimName;
    local bool bReverseDir;

    if((bIsDestroyed || bIsDoorOpen) || WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    SetTickIsDisabled(false);
    if(((WorldInfo.TimeSeconds - CreationTime) > 1) && ActorEffectIsRelevant(Instigator, false))
    {
        bReverseDir = (HitCount & 128) > 0;
        AnimName = GetBashAnimName(bReverseDir);
        BashSlot.PlayCustomAnim(AnimName, 1);
        SpawnParticlesFromEffectParam(DamageEmitter, bReverseDir);
    }
}

simulated function name GetBashAnimName(bool bReverse)
{
    if(DoorMechanism == 0)
    {
        return ((bReverse) ? 'DoorBash_A' : 'DoorBash_B');
    }
    return ((bReverse) ? 'DoorBashSliding_A' : 'DoorBashSliding_B');
}

simulated function SpawnParticlesFromEffectParam(DestroyedEffectParams EffectParam, optional bool bReverseDir)
{
    local Vector Loc;
    local Rotator Rot;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EffectParam.ParticleEffect != none)
    {
        Loc = Location + EffectParam.RelativeOffset;
        Rot = Rotation + EffectParam.RelativeRotation;
        Rot.Yaw += ((bReverseDir) ? 32768 : 0);
        BrokenDoorParticleEffects.AddItem(WorldInfo.MyEmitterPool.SpawnEmitter(EffectParam.ParticleEffect, Loc, Rot);
    }
}

simulated function PlayDestroyed()
{
    bForceNetUpdate = true;
    SetTickIsDisabled(false);
    bIsDestroyed = true;
    RepairProgress = 0;
    WeldIntegrity = 0;
    WeldableComponent.SetDestroyed(true);
    WeldableComponent.SetRepairProgress(0);
    WeldableComponent.SetWeldIntegrity(0);
    bHasBeenDirtied = true;
    if(DestroyedSound != none)
    {
        PlaySoundBase(DestroyedSound,,,, SoundOrigin);
    }
    if(DoorMechanism == 0)
    {
        DestroyHingedDoor();        
    }
    else
    {
        DestroyNonPhysicsDoor();
    }
    if(bShouldExplode)
    {
        PlayExplosion();
        bShouldExplode = false;
    }
    DoorTrigger.OnDestroyOrReset();
}

simulated function PlayExplosion()
{
    local KFExplosionActor ExploActor;
    local GameExplosion ExplosionTemplate;
    local KFPawn ExplosionInstigator;
    local KFPerk InstigatorPerk;
    local class<KFExplosionActor> KFEAR;

    if(Role < ROLE_Authority)
    {
        return;
    }
    ExplosionInstigator = KFPawn(ExplosionInstigatorController.Pawn);
    InstigatorPerk = ExplosionInstigator.GetPerk();
    if((ExplosionInstigator != none) && InstigatorPerk != none)
    {
        KFEAR = ((InstigatorPerk.DoorShouldNuke()) ? Class'KFPerk_Demolitionist'.static.GetNukeExplosionActorClass() : Class'KFExplosionActorReplicated');
        ExploActor = Spawn(KFEAR, self,, DoorTrigger.Location,,, true);
        if(ExploActor != none)
        {
            ExploActor.InstigatorController = ExplosionInstigatorController;
            ExploActor.Instigator = ExplosionInstigator;
            ExplosionTemplate = ((InstigatorPerk.DoorShouldNuke()) ? Class'KFPerk_Demolitionist'.static.GetNukeExplosionTemplate() : Class'KFPerk_Demolitionist'.static.GetDoorTrapsExplosionTemplate());
            ExplosionTemplate.Damage = Class'KFPerk_Demolitionist'.static.GetDoorTrapsExplosionTemplate().Damage;
            ExploActor.Explode(ExplosionTemplate);
        }
    }
}

simulated function DestroyNonPhysicsDoor()
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < DestroyedEmitters.Length)
    {
        SpawnParticlesFromEffectParam(DestroyedEmitters[I]);
        ++ I;
        goto J0x0C;
    }
    if(DoorMechanism == 1)
    {
        BashSlot.PlayCustomAnim('Door_Slide_broken', 1, 0.15, 0.2, true, true);
    }
}

simulated function ResetDoor(optional bool bRepaired)
{
    local int I;
    local DoorMarker DoorNav;

    if(Role == ROLE_Authority)
    {
        Health = MaxHealth;
        bIsDestroyed = false;
        bShouldExplode = false;
        WeldIntegrity = 0;
        DemoWeld = 0;
        WeldableComponent.SetDestroyed(false);
        WeldableComponent.SetWeldIntegrity(0);
        WeldableComponent.SetDemoWeld(0);
        if(bRepaired)
        {
            bIsDoorOpen = false;            
        }
        else
        {
            bIsDoorOpen = true;
        }
        bNetDirty = true;
        bForceNetUpdate = true;
    }
    ExplosionInstigatorController = none;
    bDoorMoveCompleted = true;
    bHasBeenDirtied = false;
    SetTickIsDisabled(true);
    if(DoorMechanism == 0)
    {
        ResetHingedDoor(bRepaired);        
    }
    else
    {
        BashSlot.StopCustomAnim(0);
    }
    if(bRepaired)
    {
        bLocalIsDoorOpen = false;
        SetRBCollideWithDeadPawn(true);
        MovementControl.SetSkelControlStrength(0, 0);
        TryPushPawns();        
    }
    else
    {
        bLocalIsDoorOpen = true;
        MovementControl.SetSkelControlStrength(1, 0);
        SetRBCollideWithDeadPawn(false);
    }
    SkeletalMeshComp.ForceSkelUpdate();
    if(bMonitorDoor && !bRepaired)
    {
        DoorNav = DoorMarker(MyMarker);
        if(DoorNav != none)
        {
            DoorNav.MoverOpened();
        }
        bMonitorDoor = false;        
    }
    else
    {
        if(bRepaired)
        {
            DoorNav = DoorMarker(MyMarker);
            if(DoorNav != none)
            {
                DoorNav.MoverClosed();
            }
        }
    }
    UpdateHealthScalars('doorHealthA', 0);
    UpdateHealthScalars('doorHealthB', 0);
    UpdateHealthScalars('doorHealthC', 0);
    UpdateHealthScalars('doorHealthD', 0);
    if((AmbientSoundComponent != none) && AmbientSoundComponent.IsPlaying())
    {
        AmbientSoundComponent.StopEvents();
    }
    I = 0;
    J0x3B8:

    if(I < BrokenDoorParticleEffects.Length)
    {
        if((BrokenDoorParticleEffects[I] != none) && BrokenDoorParticleEffects[I].bIsActive)
        {
            BrokenDoorParticleEffects[I].DeactivateSystem();
        }
        ++ I;
        goto J0x3B8;
    }
    BrokenDoorParticleEffects.Length = 0;
    I = 0;
    J0x465:

    if(I < BrokenDoorPhysicsActors.Length)
    {
        BrokenDoorPhysicsActors[I].Destroy();
        ++ I;
        goto J0x465;
    }
    BrokenDoorPhysicsActors.Length = 0;
    if((bRepaired && RepairFXTemplate.ParticleTemplate != none) && WorldInfo.MyEmitterPool != none)
    {
        WorldInfo.MyEmitterPool.SpawnEmitter(RepairFXTemplate.ParticleTemplate, VisualDoorLocation + RepairFXTemplate.RelativeOffset, rotator(vect(0, 0, 1)) + RepairFXTemplate.RelativeRotation, self);
        PlaySoundBase(RepairSound,,,, VisualDoorLocation);
    }
    DoorTrigger.OnDestroyOrReset();
}

simulated function UpdateHealthMICs()
{
    local float HealthScaler;

    if(Health <= 0)
    {
        return;
    }
    if(Health < MaxHealth)
    {
        bHasBeenDirtied = true;
    }
    if(HealthMICs.Length > 0)
    {
        HealthScaler = 1 - (float(Health) / float(MaxHealth));
        UpdateHealthScalars('doorHealthA', HealthScaler);
        if(HealthScaler >= 0.25)
        {
            UpdateHealthScalars('doorHealthB', (HealthScaler - 0.25) * 1.32);
        }
        if(HealthScaler >= 0.5)
        {
            UpdateHealthScalars('doorHealthC', (HealthScaler - 0.5) * 2);
        }
        if(HealthScaler >= 0.75)
        {
            UpdateHealthScalars('doorHealthD', (HealthScaler - 0.75) * 4);
        }
    }
}

simulated function UpdateHealthScalars(name ScalarName, float Value)
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < HealthMICs.Length)
    {
        HealthMICs[I].SetScalarParameterValue(ScalarName, Value);
        ++ I;
        goto J0x0C;
    }
}

simulated function UpdateIntegrityMIC()
{
    local float IntegrityScaler, ExplosiveScaler;
    local KFDoorMarker DoorMarker;
    local int AttackerCount, QueuedCount;

    if(IntegrityMIC != none)
    {
        if(WeldIntegrity > 0)
        {
            bHasBeenDirtied = true;
            IntegrityScaler = FMax(float(WeldIntegrity) / float(MaxWeldIntegrity), MinWeldScalar);            
        }
        else
        {
            IntegrityScaler = 0;
        }
        IntegrityMIC.SetScalarParameterValue('doorWeld', IntegrityScaler);
        ExplosiveScaler = ((bShouldExplode) ? 1 : 0);
        IntegrityMIC.SetScalarParameterValue('scalar_explosive', ExplosiveScaler);
        if(CenterWeldComponent != none)
        {
            if(CenterWeldComponent.HiddenGame && WeldIntegrity > 0)
            {
                CenterWeldComponent.SetHidden(false);                
            }
            else
            {
                if(!CenterWeldComponent.HiddenGame && WeldIntegrity <= 0)
                {
                    CenterWeldComponent.SetHidden(true);
                }
            }
        }
    }
    if(((WorldInfo.NetMode != NM_Client) && WeldIntegrity > 0) && MyMarker != none)
    {
        DoorMarker = KFDoorMarker(MyMarker);
        if(DoorMarker != none)
        {
            GetQueuedDoorAICounts(AttackerCount, QueuedCount);
            DoorMarker.UpdatePathingCost(AttackerCount, QueuedCount);
        }
    }
}

simulated function SetRBCollideWithDeadPawn(bool bEnabled)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MeshAttachments.Length)
    {
        MeshAttachments[I].Component.SetRBCollidesWithChannel(16, bEnabled);
        ++ I;
        goto J0x0B;
    }
}

simulated function DestroyHingedDoor()
{
    local bool bReverseDir;
    local byte I;

    SkeletalMeshComp.bComponentUseFixedSkelBounds = false;
    if((WorldInfo.TimeSeconds - CreationTime) > 1)
    {
        bCallRigidBodyWakeEvents = true;
        bReverseDir = (HitCount & 128) > 0;
        I = 0;
        J0x89:

        if(I < DestroyedEmitters.Length)
        {
            SpawnParticlesFromEffectParam(DestroyedEmitters[I], bReverseDir);
            ++ I;
            goto J0x89;
        }
        SpawnBrokenDoors(bReverseDir);        
    }
    else
    {
        I = 0;
        J0xFD:

        if(I < MeshAttachments.Length)
        {
            MeshAttachments[I].Component.SetBlockRigidBody(false);
            MeshAttachments[I].Component.SetActorCollision(false, false);
            MeshAttachments[I].Component.SetHidden(true);
            ++ I;
            goto J0xFD;
        }
    }
}

simulated function SpawnBrokenDoors(bool bReverseDir)
{
    local KFKActorSpawnable_Door SpawnedKActor;
    local name BoneName;
    local Vector DoorX, DoorY, DoorZ, InitAngVel, AttachmentLocation;

    local Rotator AttachmentRotation;
    local byte I;

    GetAxes(Rotation, DoorX, DoorY, DoorZ);
    DoorX *= float(((bReverseDir) ? -1 : 1));
    I = 0;
    J0x54:

    if(I < MeshAttachments.Length)
    {
        BoneName = MeshAttachments[I].AttachTo;
        AttachmentLocation = SkeletalMeshComp.GetBoneLocation(BoneName) + (DoorX * float(25));
        AttachmentRotation = QuatToRotator(SkeletalMeshComp.GetBoneQuaternion(BoneName)) + MeshAttachments[I].Component.Rotation;
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            SpawnedKActor = Spawn(Class'KFKActorSpawnable_Door', self,, AttachmentLocation, AttachmentRotation);
            if((SpawnedKActor != none) && MeshAttachments[I].Component != none)
            {
                InitBrokenAttachment(MeshAttachments[I].Component, SpawnedKActor);
                SpawnedKActor.StaticMeshComponent.SetRBLinearVelocity(DoorX * BrokenDoorImpulse);
                InitAngVel.X = MaxAngularVelocity * FRand();
                InitAngVel.Y = MaxAngularVelocity * FRand();
                InitAngVel.Z = MaxAngularVelocity * FRand();
                SpawnedKActor.StaticMeshComponent.SetRBAngularVelocity(InitAngVel);
                SpawnedKActor.StaticMeshComponent.WakeRigidBody();
                BrokenDoorPhysicsActors.AddItem(SpawnedKActor;
            }
        }
        if(MeshAttachments[I].Component != none)
        {
            MeshAttachments[I].Component.SetHidden(true);
            MeshAttachments[I].Component.SetBlockRigidBody(false);
            MeshAttachments[I].Component.SetActorCollision(false, false);
        }
        ++ I;
        goto J0x54;
    }
}

simulated function ResetHingedDoor(optional bool bRepaired)
{
    local byte I;

    I = 0;
    J0x0D:

    if(I < MeshAttachments.Length)
    {
        MeshAttachments[I].Component.SetBlockRigidBody(true);
        MeshAttachments[I].Component.SetActorCollision(true, true);
        MeshAttachments[I].Component.SetHidden(false);
        ++ I;
        goto J0x0D;
    }
    if(!bRepaired)
    {
        OpenSwingingDoor(none);
    }
    SkeletalMeshComp.bComponentUseFixedSkelBounds = true;
}

private final simulated function PlayMovingSound(bool bClosing)
{
    local AkBaseSoundObject SoundToPlay, AmbientToPlay;

    if(bClosing)
    {
        SoundToPlay = CloseSound;
        AmbientToPlay = OpeningAmbientSound;        
    }
    else
    {
        SoundToPlay = OpenSound;
        AmbientToPlay = ClosingAmbientSound;
    }
    if(SoundToPlay != none)
    {
        PlaySoundBase(SoundToPlay, true,,, SoundOrigin);
    }
    if(AkEvent(AmbientToPlay) != none)
    {
        AmbientSoundComponent.StopEvents();
        AmbientSoundComponent.PlayEvent(AkEvent(AmbientToPlay));
    }
}

function AkEvent GetSoundEffectFromType(KFCharacterInfo_Monster DamagingMonsterInfo)
{
    switch(DoorMaterial)
    {
        case 0:
            return DamagingMonsterInfo.DoorHitSound.Metal;
            break;
        case 1:
            return DamagingMonsterInfo.DoorHitSound.Wood;
            break;
        default:
            break;
    }
}

function bool UnderAttack()
{
    return (WorldInfo.TimeSeconds - LastHitTime) < CombatLength;
}

function bool WeldedShut()
{
    return !IsCompletelyOpen() && WeldIntegrity > 0;
}

function NotifyAIDoorOpened()
{
    local DoorMarker DoorNav;
    local KFAIController KFAIC;

    DoorNav = DoorMarker(MyMarker);
    if(DoorNav != none)
    {
        if(bMonitorDoor)
        {
            foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
            {
                if(KFAIC.PendingDoor == self)
                {
                    KFAIC.DoorFinished();
                }                
            }            
        }
        DoorNav.MoverOpened();
    }
}

simulated event DrawDoorHUD(HUD HUD, Canvas C)
{
    local PlayerController PC;
    local Vector CameraLoc, ScreenLoc;
    local Rotator CameraRot;
    local float X, Y, Dot;

    PC = HUD.PlayerOwner;
    C.SetDrawColor(255, 255, 255);
    C.Font = Class'KFGameEngine'.static.GetKFCanvasFont();
    PC.GetPlayerViewPoint(CameraLoc, CameraRot);
    Dot = vector(CameraRot) Dot (Location - CameraLoc);
    if(Dot < 0.5)
    {
        return;
    }
    ScreenLoc = C.Project(WeldUILocation);
    if(((ScreenLoc.X < float(0)) || (ScreenLoc.X + float(WelderIcon.SizeX * 3)) >= C.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= C.ClipY)
    {
        return;
    }
    C.SetPos(ScreenLoc.X - float(WelderIcon.SizeX / 2), ScreenLoc.Y - float(WelderIcon.SizeY / 2), ScreenLoc.Z);
    C.DrawTexture(WelderIcon, 1);
    X = (ScreenLoc.X + float(WelderIcon.SizeX / 2)) + float(5);
    Y = ScreenLoc.Y - float(WelderIcon.SizeY / 2);
    C.SetPos(X, Y);
    if(bIsDestroyed)
    {
        DrawRepairHUD(C, HUD);        
    }
    else
    {
        DrawWeldHUD(C, HUD, X, Y);
    }
}

simulated function DrawWeldHUD(Canvas C, HUD HUD, float PosX, float PosY)
{
    local float WeldPercentageFloat;
    local int WeldPercentage;
    local float FontScale;
    local FontRenderInfo FRI;
    local string Str;

    FRI.bClipText = true;
    FontScale = Class'KFGameEngine'.static.GetKFFontScale();
    WeldPercentageFloat = (float(WeldIntegrity) / float(MaxWeldIntegrity)) * 100;
    if((WeldPercentageFloat < 1) && WeldPercentageFloat > 0)
    {
        WeldPercentageFloat = 1;        
    }
    else
    {
        if((WeldPercentageFloat > 99) && WeldPercentageFloat < 100)
        {
            WeldPercentageFloat = 99;
        }
    }
    WeldPercentage = int(WeldPercentageFloat);
    Str = (WeldIntegrityString @ string(WeldPercentage)) $ "%";
    C.DrawText(Str, true, FontScale, FontScale, FRI);
    if((DemoWeld > 0) && !bShouldExplode)
    {
        C.SetPos(PosX, PosY + 20);
        WeldPercentage = int((float(DemoWeld) / float(DemoWeldRequired)) * 100);
        Str = (ExplosiveString @ string(WeldPercentage)) $ "%";
        C.DrawText(Str, true, FontScale, FontScale, FRI);
    }
}

simulated function DrawRepairHUD(Canvas C, HUD HUD)
{
    local float RepairPercentageFloat;
    local int RepairPercentage;
    local float FontScale;
    local FontRenderInfo FRI;
    local string Str;

    FRI.bClipText = true;
    FontScale = Class'KFGameEngine'.static.GetKFFontScale();
    RepairPercentageFloat = (float(RepairProgress) / 255) * 100;
    if((RepairPercentageFloat > 99) && RepairPercentageFloat < 100)
    {
        RepairPercentageFloat = 99;
    }
    RepairPercentage = int(RepairPercentageFloat);
    Str = (RepairProgressString @ string(RepairPercentage)) $ "%";
    C.DrawText(Str, true, FontScale, FontScale, FRI);
}

function GetQueuedDoorAICounts(out int DoorAttackers, out int DoorQueuers)
{
    local KFAIController KFAIC;

    foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if(KFAIC.DoorEnemy == self)
        {
            ++ DoorAttackers;
            continue;
        }
        if(KFAIC.PendingDoor == self)
        {
            ++ DoorQueuers;
        }        
    }    
}

function float GetAIDoorDamageScale()
{
    local int AttackerCount, QueuedCount;

    GetQueuedDoorAICounts(AttackerCount, QueuedCount);
    return 1 + FMin(float(AttackerCount) * 0.1, 1);
}

simulated function Reset()
{
    if(bHasBeenDirtied)
    {
        ResetDoor();
    }
}

simulated function SetInteractive(bool InInteractive)
{
    if(Role == ROLE_Authority)
    {
        bIsInteractive = InInteractive;
        DoorTrigger.SetCollision(InInteractive, DoorTrigger.bBlockActors);
    }
}

defaultproperties
{
    bIsInteractive=true
    bDoorMoveCompleted=true
    bStartDoorOpen=true
    bCanCloseDoor=true
    MeshAttachments(0)=(Component=StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent0',AttachTo=DoorLeft,bSocketAttach=false)
    MeshAttachments(1)=(Component=StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent1',AttachTo=DoorRight,bSocketAttach=false)
    begin object name=StaticMeshComponent2 class=StaticMeshComponent
        ReplacementPrimitive=none
        bAllowApproximateOcclusion=true
        bForceDirectLightMap=true
        bUsePrecomputedShadows=true
        CollideActors=false
        BlockRigidBody=false
    object end
    // Reference: StaticMeshComponent'Default__KFDoorActor.StaticMeshComponent2'
    CenterWeldComponent=StaticMeshComponent2
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    SkeletalMeshComp=SkeletalMeshComponent0
    CoolDownTime=0.5
    OpenBlendTime=0.5
    HingedRotation=90
    SlideTranslation=-100
    LiftTranslation=245
    MaxHealth=4000
    CombatWeldModifier=0.6
    CombatLength=1.25
    FrameSizeOfTwoDoors=256
    BrokenDoorImpulse=750
    MaxAngularVelocity=2
    DamageEmitter=(ParticleEffect=none,RelativeOffset=(X=0,Y=0,Z=0),RelativeRotation=(Pitch=0,Yaw=0,Roll=0),MaxSpawnDist=4000,PSC=none)
    ExplosiveString="Door Trap:"
    MaxWeldIntegrity=1500
    MinWeldScalar=0.08
    DemoWeldRequired=500
    RepairFXTemplate=(ParticleTemplate=ParticleSystem'FX_Gameplay_EMIT_TWO.FX_Door_Repair_Complete_01')
    RepairSound=AkEvent'WW_ENV_Destruction.Play_Door_Heal'
    WelderIcon=Texture2D'UI_World_TEX.welder_door_icon'
    WeldIntegrityString="Weld Integrity:"
    RepairProgressString="Repair Progress:"
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.door'
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
        Translation=(X=40,Y=0,Z=40)
    object end
    // Reference: SpriteComponent'Default__KFDoorActor.Sprite'
    Components(0)=Sprite
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    Components(1)=SkeletalMeshComponent0
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bNoDelete=true
    bTickIsDisabled=true
    bWorldGeometry=true
    bCanStepUpOn=false
    bAlwaysRelevant=true
    bSkipActorPropertyReplication=true
    bOnlyDirtyReplication=true
    bReplicateRigidBodyLocation=true
    bCanBeDamaged=true
    bCollideActors=true
    bBlockActors=true
    bProjTarget=true
    bEdShouldSnap=true
    bIgnoreNetRelevancyCollision=true
    NetUpdateFrequency=0.1
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        SkeletalMesh=SkeletalMesh'ENV_Doors_Mesh.ENV_Door_Base'
        AnimTreeTemplate=AnimTree'ENV_Doors_ANIM.ENV_Doors_AnimTree'
        AnimSets(0)=AnimSet'ENV_Doors_ANIM.Door_Base_Animation'
        bUseTickOptimization=false
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        CollideActors=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFDoorActor.SkeletalMeshComponent0'
    CollisionComponent=SkeletalMeshComponent0
}