/*******************************************************************************
 * KFPathnode generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPathnode extends PathNode
    native(Waypoint)
    hidecategories(Navigation,Lighting,LightColor,Force);

/** Used internally, set to true if this node is a jump destination for a KFJumpSpot node */
var() duplicatetransient editconst bool bIsJumpDest;
var() duplicatetransient editconst bool bIsDropDownDest;
var() duplicatetransient bool bDebugLogAnchorUsability;
var() duplicatetransient bool bAutoConnectToOtherFloors;
var() duplicatetransient bool bPauseWhenReached;
var() const editconst bool bHasDoorLOS;
/** If this node is on a wall and connected to a ceiling node, then auto adjust those node's height if too low */
var() bool bAutoAdjustZToCeiling;
var bool bAutoFlushPersistentDebugLines;
var() duplicatetransient editconst Vector JumpVelocity;
/** How long the jump should take.  Altering this value changes the JumpVelocity. */
var() duplicatetransient float JumpTime;
var() duplicatetransient float PauseDuration;
var class<ReachSpec> WallReachSpecClass;

// Export UKFPathnode::execComputeTrajectoryByTime(FFrame&, void* const)
native function Vector ComputeTrajectoryByTime(Vector StartPosition, Vector EndPosition, float EndTime);

// Export UKFPathnode::execGetUpVector(FFrame&, void* const)
native function Vector GetUpVector();

// Export UKFPathnode::execIsUsableAnchorFor(FFrame&, void* const)
native function bool IsUsableAnchorFor(Pawn P);

static final function NavigationPoint GetNearestFloorNavToActor(Actor ChkActor, optional class<NavigationPoint> RequiredClass, optional array<NavigationPoint> ExcludeList, optional float MinDist)
{
    local NavigationPoint Nav, BestNav;
    local float Dist, bestDist;

    if(ChkActor != none)
    {
        foreach ChkActor.WorldInfo.AllNavigationPoints(Class'NavigationPoint', Nav)
        {
            if(Nav.bWallNode)
            {
                continue;                
            }
            if(((RequiredClass == none) || Nav.Class == RequiredClass) && ExcludeList.Find(Nav == -1)
            {
                Dist = VSize(Nav.Location - ChkActor.Location);
                if(Dist > MinDist)
                {
                    if((BestNav == none) || Dist < bestDist)
                    {
                        BestNav = Nav;
                        bestDist = Dist;
                    }
                }
            }            
        }        
    }
    return BestNav;
}

static final function NavigationPoint GetNearestValidFloorNavWithinRadiusToPawn(Pawn ChkPawn, float MinDist, optional class<NavigationPoint> RequiredClass, optional array<NavigationPoint> ExcludeList)
{
    local NavigationPoint BestNav;
    local float Dist, bestDist;
    local array<NavigationPoint> ValidNavs;
    local Cylinder PawnCylinder;
    local int I;

    if(ChkPawn != none)
    {
        PawnCylinder.Radius = ChkPawn.GetCollisionRadius();
        PawnCylinder.Height = ChkPawn.GetCollisionHeight();
        GetAllNavInRadius(ChkPawn, ChkPawn.Location, MinDist, ValidNavs, true,, PawnCylinder);
        I = 0;
        J0xE2:

        if(I < ValidNavs.Length)
        {
            if(ValidNavs[I].bWallNode)
            {                
            }
            else
            {
                if(!ValidNavs[I].IsUsableAnchorFor(ChkPawn))
                {                    
                }
                else
                {
                    if(((RequiredClass == none) || ValidNavs[I].Class == RequiredClass) && ExcludeList.Find(ValidNavs[I] == -1)
                    {
                        Dist = VSize(ValidNavs[I].Location - ChkPawn.Location);
                        if(Dist > MinDist)
                        {
                            if((BestNav == none) || Dist < bestDist)
                            {
                                BestNav = ValidNavs[I];
                                bestDist = Dist;
                            }
                        }
                    }
                }
            }
            ++ I;
            goto J0xE2;
        }
    }
    return BestNav;
}

event NotifyReachedBy(Pawn P)
{
    if((P.Controller != none) && KFAIController(P.Controller) != none)
    {
        if(KFAIController(P.Controller) != none)
        {
            KFAIController(P.Controller).AILog_Internal((string(GetFuncName()) $ " by ") $ string(P), 'PathWarning');
        }
    }
}

simulated event string GetDebugAbbrev()
{
    return "KFPN";
}

simulated function DrawDebugInfo(HUD HUD)
{
    local KFDebugLines KFDL;
    local int I;

    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        I = 0;
        J0x43:

        if(I < PathList.Length)
        {
            KFDL.AddDebugLine(Location, PathList[I].GetEnd().Location, 0, 100, 150, true,, Name, I);
            KFDL.AddDebugText3D((Location + PathList[I].GetEnd().Location) * 0.5, string(PathList[I]), true, 50, 100, 150, true,,,, Name, I);
            ++ I;
            goto J0x43;
        }
    }
}

defaultproperties
{
    bAutoConnectToOtherFloors=true
    JumpTime=0.45
    WallReachSpecClass=Class'FloorToWallReachSpec'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPathnode.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPathnode.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPathnode.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPathnode.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPathnode.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPathnode.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPathnode.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__KFPathnode.PathRenderer'
    Components(4)=PathRenderer
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPathnode.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}