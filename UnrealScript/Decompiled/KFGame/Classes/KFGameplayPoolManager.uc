/*******************************************************************************
 * KFGameplayPoolManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGameplayPoolManager extends Object
    native;

enum eProjectilePoolType
{
    PPT_C4,
    PPT_PukeMine,
    PPT_MAX
};

struct native sProjectilePoolInfo
{
    var KFPlayerController ProjController;
    var array<KFProjectile> Projectiles;

    structdefaultproperties
    {
        ProjController=none
        Projectiles=none
    }
};

var protected byte MAX_ACTIVE_C4;
var protected byte MAX_C4_PER_PLAYER;
var protected byte MAX_ACTIVE_PUKE_MINES;
var protected transient array<sProjectilePoolInfo> ActiveC4Infos;
var protected transient array<sProjectilePoolInfo> ActivePukeMineInfos;

// Export UKFGameplayPoolManager::execGetPoolManager(FFrame&, void* const)
native static function KFGameplayPoolManager GetPoolManager();

function AddProjectileToPool(KFProjectile Proj, KFGameplayPoolManager.eProjectilePoolType PoolType)
{
    switch(PoolType)
    {
        case 0:
            AddProjectileToPool_Internal(ActiveC4Infos, Proj, MAX_ACTIVE_C4, MAX_C4_PER_PLAYER);
            break;
        case 1:
            AddProjectileToPool_Internal(ActivePukeMineInfos, Proj, MAX_ACTIVE_PUKE_MINES, byte(GetMaxPlayerPukeMineNum()));
            break;
        default:
            break;
    }
}

function RemoveProjectileFromPool(KFProjectile Proj, KFGameplayPoolManager.eProjectilePoolType PoolType)
{
    switch(PoolType)
    {
        case 0:
            RemoveProjectileFromPool_Internal(ActiveC4Infos, Proj);
            break;
        case 1:
            RemoveProjectileFromPool_Internal(ActivePukeMineInfos, Proj);
            break;
        default:
            break;
    }
}

private final function AddProjectileToPool_Internal(out array<sProjectilePoolInfo> PoolInfos, KFProjectile Proj, byte MaxActiveProjectiles, byte MaxProjectilesPerPlayer)
{
    local int TotalProjectiles, Idx, I, J;
    local KFProjectile OldestProj;
    local float OldestProjCreationTime;
    local int OldestProjInfoIdx;

    Idx = -1;
    I = 0;
    J0x1A:

    if(I < PoolInfos.Length)
    {
        if((PoolInfos[I].ProjController == none) || PoolInfos[I].ProjController.bDeleteMe)
        {
            J = 0;
            J0xAA:

            if(J < PoolInfos[I].Projectiles.Length)
            {
                PoolInfos[I].Projectiles[J].SetTimer((1 + float(Rand(5))) + FRand(), false, 'Timer_Explode');
                ++ J;
                goto J0xAA;
            }
            PoolInfos.Remove(I, 1;
            -- I;
            goto J0x2E8;            
        }
        else
        {
            if(PoolInfos[I].ProjController == Proj.InstigatorController)
            {
                Idx = I;
            }
        }
        TotalProjectiles += PoolInfos[I].Projectiles.Length;
        if((OldestProjCreationTime == 0) || PoolInfos[I].Projectiles[0].CreationTime < OldestProjCreationTime)
        {
            OldestProjCreationTime = PoolInfos[I].Projectiles[0].CreationTime;
            OldestProj = PoolInfos[I].Projectiles[0];
            OldestProjInfoIdx = I;
        }
        J0x2E8:

        ++ I;
        goto J0x1A;
    }
    if(Idx == -1)
    {
        Idx = PoolInfos.Length;
        PoolInfos.Insert(Idx, 1;
        PoolInfos[Idx].ProjController = KFPlayerController(Proj.InstigatorController);
    }
    if(TotalProjectiles >= MaxActiveProjectiles)
    {
        PoolInfos[OldestProjInfoIdx].Projectiles.Remove(0, 1;        
    }
    else
    {
        if(PoolInfos[Idx].Projectiles.Length >= MaxProjectilesPerPlayer)
        {
            OldestProj = PoolInfos[Idx].Projectiles[0];
            PoolInfos[Idx].Projectiles.Remove(0, 1;            
        }
        else
        {
            OldestProj = none;
        }
    }
    if(OldestProj != none)
    {
        OldestProj.Detonate();
    }
    PoolInfos[Idx].Projectiles.AddItem(Proj;
}

private final function RemoveProjectileFromPool_Internal(out array<sProjectilePoolInfo> PoolInfos, KFProjectile Proj)
{
    local int Idx, ProjIdx;

    Idx = PoolInfos.Find('ProjController', KFPlayerController(Proj.InstigatorController);
    if(Idx != -1)
    {
        ProjIdx = PoolInfos[Idx].Projectiles.Find(Proj;
        if(ProjIdx != -1)
        {
            PoolInfos[Idx].Projectiles.Remove(ProjIdx, 1;
        }
    }
}

protected function int GetMaxPlayerPukeMineNum()
{
    local KFPawn BloatPawn;
    local byte NumBloats;

    foreach Class'WorldInfo'.static.GetWorldInfo().AllPawns(Class'KFPawn', BloatPawn)
    {
        if(BloatPawn.IsAliveAndWell() && BloatPawn.IsA('KFPawn_ZedBloat_Versus'))
        {
            ++ NumBloats;
        }        
    }    
    return MAX_ACTIVE_PUKE_MINES / Max(NumBloats, 1);
}

event Reset()
{
    ActivePukeMineInfos.Remove(0, ActivePukeMineInfos.Length;
    ActiveC4Infos.Remove(0, ActiveC4Infos.Length;
}

defaultproperties
{
    MAX_ACTIVE_C4=40
    MAX_C4_PER_PLAYER=10
    MAX_ACTIVE_PUKE_MINES=30
}