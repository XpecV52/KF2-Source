/*******************************************************************************
 * KFReplicatedShowPathActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFReplicatedShowPathActor extends Actor
    notplaceable
    hidecategories(Navigation);

var byte PathTeamNum;
var byte VolumeCheckType;
var Volume CheckVolume;
var repnotify Actor Target;

replication
{
     if(bNetInitial)
        CheckVolume, PathTeamNum, 
        Target, VolumeCheckType;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'Target')
    {
        InitPath();        
    }
    else
    {
        super.ReplicatedEvent(VarName);
    }
}

function SetPathTarget(Actor NewTarget, optional Volume NewVolume, optional KFSeqAct_ShowPath.eVolumeCheckType NewVolumeCheckType, optional byte NewPathTeamNum)
{
    NewVolumeCheckType = 0;
    NewPathTeamNum = 0;
    Target = NewTarget;
    CheckVolume = NewVolume;
    VolumeCheckType = NewVolumeCheckType;
    PathTeamNum = NewPathTeamNum;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        InitPath();
    }
}

simulated function InitPath()
{
    ShowPath();
    SetTimer(2, true, 'Timer_ShowPath');
}

simulated function Timer_ShowPath()
{
    if(!bDeleteMe && Target != none)
    {
        ShowPath();
    }
}

simulated function ShowPath()
{
    local PlayerController PC;
    local bool bInsideVolume;
    local Engine.Pawn.EPathSearchType OldSearchType;
    local KFEmit_ScriptedPath Path;
    local Actor nodePathRoot;
    local bool bPathFound;

    foreach Target.WorldInfo.LocalPlayerControllers(Class'PlayerController', PC)
    {
        if(((PC.Pawn == none) || PC.GetTeamNum() != PathTeamNum) || !PC.Pawn.IsAliveAndWell())
        {
            continue;            
        }
        if((VolumeCheckType != 0) && CheckVolume != none)
        {
            bInsideVolume = CheckVolume.Encompasses(PC.Pawn);
            switch(VolumeCheckType)
            {
                case 1:
                    if(!bInsideVolume)
                    {                        
                        return;
                    }
                    break;
                case 2:
                    if(bInsideVolume)
                    {                        
                        return;
                    }
                    break;
                default:
                    break;
            }
        }
        else
        {
            OldSearchType = PC.Pawn.PathSearchType;
            PC.Pawn.PathSearchType = 3;
            Class'Path_ToTrader'.static.ToTrader(PC.Pawn);
            Class'Goal_AtActor'.static.AtActor(PC.Pawn, Target,, false);
            nodePathRoot = PC.FindPathToward(Target);
            if(nodePathRoot != none)
            {
                bPathFound = true;                
            }
            else
            {
                bPathFound = false;
            }
            if(bPathFound)
            {
                Path = Target.Spawn(Class'KFEmit_ScriptedPath', PC,, PC.Pawn.Location);
                Path.SetDestination(Target.Location + vect(0, 0, 50));                
            }
            else
            {
                LogInternal("ShowScriptedPath - No Path Found");
            }
            PC.Pawn.ClearConstraints();
            PC.Pawn.PathSearchType = OldSearchType;            
        }/* !MISMATCHING REMOVE, tried ForEach got Type:Else Position:0x191! */        
    }/* !MISMATCHING REMOVE, tried Else got Type:ForEach Position:0x000! */
}

defaultproperties
{
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bIgnoreEncroachers=true
    bPushedByEncroachers=false
    bAlwaysRelevant=true
    bReplicateMovement=false
    bSkipActorPropertyReplication=true
    bOnlyDirtyReplication=true
    bGameRelevant=true
    bIgnoreNetRelevancyCollision=true
    NetUpdateFrequency=0.1
}