/*******************************************************************************
 * AICommand_StepAside generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_StepAside extends AICommand within KFAIController;

var BasedPosition PreStepAsideLocation;
var BasedPosition StepAsideLocation;
var bool bDelayStep;
var bool bNoFocus;
var Vector OriginalFocalPoint;
var Actor OriginalFocus;

static function bool StepAside(KFAIController AI, Pawn NewStepAsideGoal, bool inbDelayStep, optional bool inNoFocus)
{
    local AICommand_StepAside Cmd;

    if(((AI != none) && AI.StepAsideGoal == none) && NewStepAsideGoal != none)
    {
        Cmd = new (AI) Class'AICommand_StepAside';
        if(Cmd != none)
        {
            AI.StepAsideGoal = NewStepAsideGoal;
            Cmd.bDelayStep = inbDelayStep;
            Cmd.bNoFocus = inNoFocus;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    Outer.MyKFPawn.SetSprinting(false);
    if(Outer.Steering != none)
    {
        Outer.Steering.EnableDefaultAcceleration();
    }
    super.Pushed();
    Outer.Vect2BP(PreStepAsideLocation, Outer.Pawn.Location);
    if(bDelayStep)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Going to Command_DelayStep state", 'Command_StepAside');
        }
        Outer.AIActionStatus = "Delaying StepAside";
        GotoState('Command_DelayStep');        
    }
    else
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Going to Command_StepAside state", 'Command_StepAside');
        }
        GotoState('Command_StepAside');
    }
}

function Popped()
{
    Outer.AIActionStatus = "Finished StepAside";
    if(Outer.Steering != none)
    {
        Outer.Steering.DisableDefaultAcceleration();
    }
    super.Popped();
    Outer.StepAsideGoal = none;
    if(!bNoFocus)
    {
        Outer.Focus = none;
    }
    if(Outer.Pawn != none)
    {
        Outer.Pawn.ZeroMovementVariables();
    }
    if(Outer.bReevaluatePath)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal((string(GetFuncName()) $ "() Calling NotifyNeedRepath on ") $ string(Outer), 'Command_StepAside');
        }
        Outer.NotifyNeedRepath();
    }
}

event string GetDumpString()
{
    return (super(GameAICommand).GetDumpString() @ "Goal:") @ string(Outer.StepAsideGoal);
}

simulated function DrawDebug(HUD HUD, name Category)
{
    super.DrawDebug(HUD, Category);
    if(Category == 'Pathing')
    {
        Outer.DrawDebugCoordinateSystem(Outer.Pawn.Location, Outer.Debug_StepRot, 64);
        Outer.DrawDebugLine(Outer.BP2Vect(Outer.Debug_StepLoc), Outer.Pawn.Location, 255, 255, 255);
        Outer.DrawDebugLine(Outer.GetDestinationPosition(), Outer.Pawn.Location, 64, 128, 255);
        Outer.DrawDebugBox(Outer.BP2Vect(PreStepAsideLocation), vect(5, 5, 5), 255, 0, 0);
    }
}

state Command_StepAside
{
    function bool IsValidMoveLocation(Vector ChkLoc)
    {
        return Outer.PointReachable(ChkLoc);
    }

    function bool GetStepAsideLocation()
    {
        local Vector X, Y, Z, HitLocation, HitNormal;

        local array<Vector> ChkLocs;
        local int Idx;
        local float StepDist;

        if(Outer.StepAsideGoal == Outer.Pawn)
        {
            X = VRand();            
        }
        else
        {
            if(VSizeSq(Outer.StepAsideGoal.Acceleration) > float(0))
            {
                X = Outer.StepAsideGoal.Acceleration;                
            }
            else
            {
                if(Outer.bMovingToGoal)
                {
                    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                    {
                        Outer.AILog_Internal((("- IS MOVING" @ string(Outer.MoveTarget)) @ string(Outer.MoveGoal)) @ string(Outer.BP2Vect(Outer.MovePosition)), 'Command_StepAside');
                    }
                    if(Outer.MoveTarget != none)
                    {
                        X = Outer.MoveTarget.Location - Outer.Pawn.Location;                        
                    }
                    else
                    {
                        if(Outer.MoveGoal != none)
                        {
                            X = Outer.MoveGoal.Location - Outer.Pawn.Location;                            
                        }
                        else
                        {
                            if(Outer.BP2Vect(Outer.MovePosition) != vect(0, 0, 0))
                            {
                                X = Outer.BP2Vect(Outer.MovePosition) - Outer.Pawn.Location;                                
                            }
                            else
                            {
                                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                                {
                                    Outer.AILog_Internal(string(self) $ " Moving but to where??", 'Command_StepAside');
                                }
                            }
                        }
                    }                    
                }
                else
                {
                    X = vector(Outer.Pawn.Rotation);
                }
            }
        }
        X.Z = 0;
        X = Normal(X);
        Z = vect(0, 0, 1);
        Y = Normal(X Cross Z);
        if((Normal(Outer.Pawn.Location - Outer.StepAsideGoal.Location) Dot Y) < 0)
        {
            Y = -Y;
        }
        StepDist = Outer.MaxStepAsideDist;
        ChkLocs[0] = (Outer.Pawn.Location + (Y * StepDist)) + ((X * StepDist) * 0.1);
        ChkLocs[1] = (Outer.Pawn.Location + ((X * StepDist) * 0.5)) + ((Y * StepDist) * 0.5);
        ChkLocs[2] = (Outer.Pawn.Location - (Y * StepDist)) + ((X * StepDist) * 0.1);
        ChkLocs[3] = (Outer.Pawn.Location + ((X * StepDist) * 0.5)) - ((Y * StepDist) * 0.5);
        ChkLocs[4] = Outer.Pawn.Location + (X * StepDist);
        ChkLocs[5] = (Outer.Pawn.Location + (Y * StepDist)) - ((X * StepDist) * 0.1);
        ChkLocs[6] = (Outer.Pawn.Location - (Y * StepDist)) - ((X * StepDist) * 0.1);
        ChkLocs[7] = (Outer.Pawn.Location + (Y * StepDist)) - ((X * StepDist) * 0.25);
        ChkLocs[8] = (Outer.Pawn.Location - (Y * StepDist)) - ((X * StepDist) * 0.25);
        Idx = 0;
        J0x9D9:

        if(Idx < ChkLocs.Length)
        {
            if((IsValidMoveLocation(ChkLocs[Idx])) && (Outer.Trace(HitLocation, HitNormal, ChkLocs[Idx], Outer.Pawn.Location, true) == none) || VSize(HitLocation - Outer.Pawn.Location) > (StepDist * 0.5))
            {
                Outer.Debug_StepRot = rotator(X);
                Outer.Vect2BP(Outer.Debug_StepLoc, ChkLocs[Idx]);
                Outer.Vect2BP(StepAsideLocation, ChkLocs[Idx]);
                return true;
            }
            ++ Idx;
            goto J0x9D9;
        }
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal(string(self) $ " FAILED TO FIND STEP ASIDE LOCATION... RESORT TO STANDING STILL", 'Command_StepAside');
        }
        Outer.LastFailedToFindStepAsideLocation = Outer.WorldInfo.TimeSeconds;
        return false;
    }

    function Actor StepAside_GetMoveFocus()
    {
        return Outer.StepAsideGoal;
        if(bNoFocus)
        {
            return none;
        }
        if(Outer.Enemy != none)
        {
            return Outer.Enemy;
        }
        if(Outer.bMovingToGoal)
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal((string(self) $ " bMovingToGoal || bMovingToCover, Focus is MoveTarget:") @ string(Outer.MoveTarget), 'Command_StepAside');
            }
            return Outer.MoveTarget;
        }
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal((string(self) $ " !HasAnyEnemies(), Focus is StepAsideGoal:") @ string(Outer.StepAsideGoal), 'Command_StepAside');
        }
        return Outer.StepAsideGoal;
    }
Begin:

    if(((Outer.StepAsideGoal != none) && !bIgnoreStepAside) && (Outer.WorldInfo.TimeSeconds - Outer.LastFailedToFindStepAsideLocation) > 1)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal(string(self) $ " Starting to step aside...", 'Command_StepAside');
        }
        Outer.bReevaluatePath = true;
        if(GetStepAsideLocation())
        {
            Outer.AIActionStatus = "Stepping Aside From  " $ string(Outer.StepAsideGoal);
            Outer.MoveTo(Outer.BP2Vect(StepAsideLocation), StepAside_GetMoveFocus(),, Outer.Pawn.bIsWalking);
            if(((Outer.StepAsideGoal != none) && Outer.StepAsideGoal != Outer.Pawn) && (Outer.Pawn.Touching.Find(Outer.StepAsideGoal != -1) || Outer.StepAsideGoal.ReachedPoint(Outer.BP2Vect(PreStepAsideLocation), none))
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal(((string(self) $ " Still touching, moving again") @ string(Outer.Pawn.Touching.Find(Outer.StepAsideGoal)) @ string(Outer.StepAsideGoal.ReachedPoint(Outer.BP2Vect(PreStepAsideLocation), none)), 'Command_StepAside');
                }
                Outer.Sleep(0.5 + (FRand() * 1));
                Outer.Vect2BP(PreStepAsideLocation, Outer.Pawn.Location);
                goto 'Begin';
            }
        }
        Outer.Sleep(0.1 + (FRand() * 0.5));        
    }
    else
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal(string(self) $ " No step aside goal?", 'Command_StepAside');
        }
        Outer.Sleep(0.5);
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal(string(self) $ " Finished stepping aside", 'Command_StepAside');
    }
    Status = 'Success';
    Outer.PopCommand(self);
    stop;            
}

state Command_DelayStep
{Begin:

    if(Outer.StepAsideGoal != none)
    {
        if(Outer.Pawn != none)
        {
            Outer.Pawn.ZeroMovementVariables();
        }
    }
    Outer.Sleep(0.3 + (FRand() * 0.5));
    Status = 'Success';
    Outer.PopCommand(self);
    stop;                    
}

defaultproperties
{
    bAllowedToAttack=false
    bReplaceActiveSameClassInstance=true
}