/*******************************************************************************
 * AICommand_HeadlessWander generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_HeadlessWander extends AICommand within KFAIController;

var Controller EventInstigator;
var float RandomMoveDist;
var float DotCheck;
var float LastHeadlessAttackTime;
var bool bDebugWander;
var Vector Dest;

static function bool HeadlessWander(KFAIController AI)
{
    local AICommand_HeadlessWander Cmd;

    if(AI != none)
    {
        Cmd = new (AI) Class'AICommand_HeadlessWander';
        if(Cmd != none)
        {
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    if(Outer.Steering != none)
    {
        Outer.Steering.EnableDefaultAcceleration();
    }
    Outer.MyKFPawn.SetSprinting(false);
    Outer.MyKFPawn.bCanJumpOverWalls = false;
    Outer.RotationRateMultiplier = 0.33;
    LastHeadlessAttackTime = Outer.WorldInfo.TimeSeconds;
    Outer.Focus = none;
    Outer.SetFocalPoint(vect(0, 0, 0));
    Outer.MyKFPawn.StopLookingAtPawn();
    Outer.bAllowCombatTransitions = true;
    Outer.DisableMeleeRangeEventProbing();
    Outer.StopAllLatentMovement();
    Outer.AIZeroMovementVariables();
    if(Outer.MyKFPawn.IsDoingSpecialMove())
    {
        Outer.MyKFPawn.EndSpecialMove();
    }
    if(((Outer.MyKFPawn != none) && Outer.MyKFPawn.bCanCloak) && Outer.MyKFPawn.bIsCloaking)
    {
        Outer.MyKFPawn.SetCloaked(false);
    }
    GotoState('RandomWander');
}

function Popped()
{
    if(Outer.Steering != none)
    {
        Outer.Steering.DisableDefaultAcceleration();
    }
    super.Popped();
}

function bool AllowTransitionTo(class<GameAICommand> AttemptCommand)
{
    return false;
}

function bool ShouldRunSomewhereElse()
{
    return FRand() < 0.4;
}

function Vector CalcTurnDirection(Rotator Direction, float Spread)
{
    local float Radius, ZDelta, YDelta;
    local Vector X, Y, Z, Offset;

    Radius = Tan(((Spread / 2) * 3.141593) / 180);
    ZDelta = Radius - ((float(2) * Radius) * FRand());
    YDelta = Radius - ((float(2) * Radius) * FRand());
    GetAxes(Direction, X, Y, Z);
    Offset = (ZDelta * Z) + (YDelta * Y);
    return vector(Direction) + Offset;
}

function bool NotifyHearNoise(float Loudness, Actor NoiseMaker, optional name NoiseType)
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((((("HearNoise: " $ string(Loudness)) $ " NoiseMaker: ") $ string(NoiseMaker)) $ " Type: ") $ string(NoiseType), 'HeadlessWander');
    }
    return false;
}

state RandomWander
{
    function Vector GetRandomMovePoint()
    {
        local float Dot;
        local Vector TryPt, RandTryPoint, TryDir;
        local int I;

        TryDir = CalcTurnDirection(Outer.Pawn.Rotation, 65);
        TryDir.Z = 0;
        TryDir = Normal(TryDir);
        TryPt = Outer.Pawn.Location + (TryDir * RandomMoveDist);
        if(bDebugWander)
        {
            Outer.PauseAndShowMsg("WAITING");
            LogInternal((("Initial TryDir:" $ string(TryDir)) $ " TryPt: ") $ string(TryPt));
            Outer.DrawDebugSphere(TryPt, 32, 8, 0, 255, 0, true);
        }
        I = 0;
        J0x187:

        if(I < 15)
        {
            if(bDebugWander)
            {
                Outer.PauseAndShowMsg("WAITING : " $ string(I));
            }
            TryDir = CalcTurnDirection(Outer.Pawn.Rotation, RandRange(60, 120));
            TryDir.Z = 0;
            TryDir = Normal(TryDir);
            RandTryPoint = Outer.Pawn.Location + (TryDir * RandomMoveDist);
            Dot = Normal(RandTryPoint - Outer.Pawn.Location) Dot vector(Outer.Pawn.Rotation);
            if(Dot < DotCheck)
            {
                if(bDebugWander)
                {
                    LogInternal(((((("Fail i: " $ string(I)) $ " FAILED DOT CHECK (Dot:") $ string(Dot)) $ " versus DotCheck:") $ string(DotCheck)) $ ")");
                    Outer.DrawDebugSphere(RandTryPoint, 24, 8, 255, 0, 0, true);
                }
                goto J0x5A0;                
            }
            else
            {
                if(bDebugWander)
                {
                    LogInternal((((((("Success i: " $ string(I)) $ " DOT: ") $ string(Dot)) $ " TryDir: ") $ string(TryDir)) $ " RandTryPoint: ") $ string(RandTryPoint));
                    Outer.DrawDebugSphere(RandTryPoint, 24, 8, 0, 0, 255, true);
                    Outer.DrawDebugLine(Outer.Pawn.Location, RandTryPoint, 0, 0, 255, true);
                }
            }
            TryPt = Outer.Pawn.Location + (TryDir * RandomMoveDist);
            if(Outer.PointReachable(TryPt))
            {
                return TryPt;
            }
            J0x5A0:

            ++ I;
            goto J0x187;
        }
        return TryPt;
    }
Begin:

    GetRandomMovePoint();
    if(bDebugWander)
    {
        Outer.Sleep(0);
        Outer.PauseAndShowMsg("WAITING");
        Outer.Sleep(0);
        goto 'Begin';
    }
    Outer.MoveTo(GetRandomMovePoint(), none);
    if(ShouldRunSomewhereElse())
    {
        GotoState('RunSomewhere');
    }
    goto 'Begin';
    stop;        
}

state RunSomewhere
{
    function bool RunToDest()
    {
        local Pawn CurEnemy;
        local float CurDistSq, BestDistSq;
        local Pawn BestEnemy;
        local bool bRunToPlayer;

        BestDistSq = 2.147484E+09;
        foreach Outer.WorldInfo.AllPawns(Class'Pawn', CurEnemy)
        {
            CurDistSq = VSizeSq(CurEnemy.Location - Outer.Pawn.Location);
            if((BestEnemy == none) || Outer.CanSee(CurEnemy))
            {
                if(CurDistSq < BestDistSq)
                {
                    BestEnemy = CurEnemy;
                    BestDistSq = CurDistSq;
                }
            }            
        }        
        bRunToPlayer = FRand() < 0.55;
        BestDistSq = 2.147484E+09;
        foreach Outer.WorldInfo.AllPawns(Class'Pawn', CurEnemy)
        {
            CurDistSq = VSizeSq(CurEnemy.Location - Outer.Pawn.Location);
            if((BestEnemy == none) || ((bRunToPlayer == Outer.Pawn.IsHumanControlled()) && CurDistSq < BestDistSq) && !Outer.bIsPlayer || Outer.CanSee(CurEnemy))
            {
                BestEnemy = CurEnemy;
                BestDistSq = CurDistSq;
            }            
        }        
        if(BestEnemy != none)
        {
            Dest = BestEnemy.Location;
            return true;
        }
        return false;
    }
Begin:

    if(RunToDest())
    {
        Outer.MoveTo(Dest);
        Dest = vect(0, 0, 0);
        GotoState('RandomWander');        
    }
    else
    {
        Outer.AbortCommand(self);
    }
    stop;        
}

defaultproperties
{
    RandomMoveDist=232
    DotCheck=0.86
    bIgnoreNotifies=true
    bIgnoreStepAside=true
}