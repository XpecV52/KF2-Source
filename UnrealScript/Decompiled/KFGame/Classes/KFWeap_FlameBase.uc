/*******************************************************************************
 * KFWeap_FlameBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_FlameBase extends KFWeapon
    abstract
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

struct PilotLight
{
    /** @name Optional dynamic pilot lights */
    var() export editinline PointLightComponent Light;
    /** @name Optional dynamic pilot lights */
    var() name LightAttachBone;
    /** @name Optional dynamic pilot lights */
    var() float FlickerIntensity;
    /** @name Optional dynamic pilot lights */
    var() float FlickerInterpSpeed;
    /** @name Optional dynamic pilot lights */
    var() float LastLightBrightness;

    structdefaultproperties
    {
        Light=none
        LightAttachBone=None
        FlickerIntensity=0
        FlickerInterpSpeed=0
        LastLightBrightness=0
    }
};

var protected transient bool bFireSpraying;
var protected bool bPilotLightOn;
/** Whether this weapon should warn AI when it fires */
var() const bool bWarnAIWhenFiring;
var globalconfig bool bArePilotLightsAllowed;
var protected transient int NextFlamePoolIdx;
var protected transient KFSprayActor FlamePool[2];
var protected transient KFSprayActor ActiveFlameSpray;
var protected const KFSprayActor FlameSprayArchetype;
var AkEvent PilotLightPlayEvent;
var AkEvent PilotLightStopEvent;
/** Effect for the pilot light. */
var() protected export editinline KFParticleSystemComponent PSC_PilotLight;
/** Socket to attach the pilot light to. */
var() name PilotLightSocketName;
var float BarrelHeat;
var float LastBarrelHeat;
var(PilotLights) array<PilotLight> PilotLights;
/** Emitter to play when firing stops. */
var() const export editinline KFParticleSystemComponent PSC_EndSpray;
/** The minimum amount of ammo that must be consumed before this weapon can stop firing */
var() protected byte MinAmmoConsumed;
var protected byte AmmoConsumed;

simulated function SetFlameComplex(bool bDoCollideComplex);

simulated function SetFlameDebugDamage(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision);

simulated function SetFlameDebugFX(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles);

simulated event Tick(float DeltaTime)
{
    local int I, Idx;
    local float FlameHeat;

    super.Tick(DeltaTime);
    if(((((WorldInfo.NetMode != NM_DedicatedServer) && WeaponMICs.Length > 0) && Instigator != none) && Instigator.IsLocallyControlled()) && Instigator.IsHumanControlled())
    {
        if(bFireSpraying && ActiveFlameSpray != none)
        {
            FlameHeat = GetRangeValueByPct(ActiveFlameSpray.MaterialHeatRange, FMin(ActiveFlameSpray.CurrentAge / ActiveFlameSpray.MaterialHeatRampTime, 1)) * 3.5;
            if(BarrelHeat < FlameHeat)
            {
                BarrelHeat += (DeltaTime * 2);                
            }
            else
            {
                BarrelHeat = FlameHeat;
            }            
        }
        else
        {
            if(BarrelHeat > float(0))
            {
                BarrelHeat -= (DeltaTime * 0.5);
                if(BarrelHeat < float(0))
                {
                    BarrelHeat = 0;
                }
            }
        }
        if(BarrelHeat != LastBarrelHeat)
        {
            I = 0;
            J0x1FD:

            if(I < WeaponMICs.Length)
            {
                if(WeaponMICs[I] != none)
                {
                    WeaponMICs[I].SetScalarParameterValue('Glow_Intensity', BarrelHeat);
                }
                ++ I;
                goto J0x1FD;
            }
        }
        LastBarrelHeat = BarrelHeat;
    }
    Idx = 0;
    J0x295:

    if(Idx < PilotLights.Length)
    {
        if(PilotLights[Idx].Light != none)
        {
            PilotLights[Idx].LastLightBrightness = FMax(0, GetFlickerVal(default.PilotLights[Idx].Light.Brightness, PilotLights[Idx].FlickerIntensity, PilotLights[Idx].LastLightBrightness, DeltaTime, PilotLights[Idx].FlickerInterpSpeed));
            PilotLights[Idx].Light.SetLightProperties(PilotLights[Idx].LastLightBrightness, PilotLights[Idx].Light.LightColor, PilotLights[Idx].Light.Function);
        }
        ++ Idx;
        goto J0x295;
    }
}

simulated function Destroyed()
{
    local int Idx;

    if(bFireSpraying)
    {
        TurnOffFireSpray();
    }
    Idx = 0;
    J0x22:

    if(Idx < 2)
    {
        if(FlamePool[Idx] != none)
        {
            FlamePool[Idx].Destroy();
            FlamePool[Idx] = none;
        }
        ++ Idx;
        goto J0x22;
    }
    super(Weapon).Destroyed();
}

protected simulated function TurnOnPilot()
{
    local Vector MuzzleLoc;
    local Rotator Aim;
    local float OwnerMeshFOV;
    local int Idx;

    if(bPilotLightOn)
    {
        return;
    }
    StartPilotSound();
    OwnerMeshFOV = MySkelMesh.FOV;
    if(PSC_PilotLight != none)
    {
        MySkelMesh.AttachComponentToSocket(PSC_PilotLight, PilotLightSocketName);
        PSC_PilotLight.ActivateSystem();
        PSC_PilotLight.SetFloatParameter('Pilotlow', 1);
        PSC_PilotLight.SetFloatParameter('Pilothigh', 0);
        PSC_PilotLight.SetFOV(OwnerMeshFOV);
    }
    if(bArePilotLightsAllowed)
    {
        Idx = 0;
        J0x13B:

        if(Idx < PilotLights.Length)
        {
            MySkelMesh.AttachComponentToSocket(PilotLights[Idx].Light, PilotLights[Idx].LightAttachBone);
            ++ Idx;
            goto J0x13B;
        }        
    }
    else
    {
        PilotLights.Remove(0, PilotLights.Length;
    }
    SetPilotDynamicLightEnabled(true);
    GetFlameSocketLocAndRot(MuzzleLoc, Aim);
    if(FlamePool[0] == none)
    {
        FlamePool[0] = Spawn(FlameSprayArchetype.Class, Instigator,, MuzzleLoc, Aim, FlameSprayArchetype, true);
    }
    if(FlamePool[1] == none)
    {
        FlamePool[1] = Spawn(FlameSprayArchetype.Class, Instigator,, MuzzleLoc, Aim, FlameSprayArchetype, true);
    }
    FlamePool[0].AttachToMesh(self, MySkelMesh, FlamePool[0].SpraySocketName);
    FlamePool[1].AttachToMesh(self, MySkelMesh, FlamePool[1].SpraySocketName);
    FlamePool[0].bDoFirstPersonFX = true;
    FlamePool[1].bDoFirstPersonFX = true;
    FlamePool[0].DamageInterval = FireInterval[0];
    FlamePool[1].DamageInterval = FireInterval[0];
    FlamePool[0].SetFOV(OwnerMeshFOV);
    FlamePool[1].SetFOV(OwnerMeshFOV);
    FlamePool[0].SkeletalSprayMesh.SetOnlyOwnerSee(true);
    FlamePool[1].SkeletalSprayMesh.SetOnlyOwnerSee(true);
    if(PSC_EndSpray != none)
    {
        PSC_EndSpray.SetTemplate(FlamePool[0].SprayEndEffect);
        MySkelMesh.AttachComponentToSocket(PSC_EndSpray, FlamePool[0].SpraySocketName);
    }
    bPilotLightOn = true;
}

simulated function GetFlameSocketLocAndRot(out Vector out_Loc, out Rotator out_Rot)
{
    if((MySkelMesh != none) && FlameSprayArchetype.Class.default.SpraySocketName != 'None')
    {
        MySkelMesh.GetSocketWorldLocationAndRotation(FlameSprayArchetype.Class.default.SpraySocketName, out_Loc, out_Rot);        
    }
    else
    {
        out_Loc = Instigator.Location;
        out_Rot = Instigator.Rotation;
    }
}

protected simulated function TurnOffPilot()
{
    StopPilotSound();
    if(PSC_PilotLight != none)
    {
        PSC_PilotLight.DeactivateSystem();
    }
    SetPilotDynamicLightEnabled(false);
    bPilotLightOn = false;
}

simulated function SetPilotDynamicLightEnabled(bool bLightEnabled)
{
    local int Idx;

    if(bLightEnabled && ((Instigator == none) || !Instigator.IsLocallyControlled()) || !Instigator.IsFirstPerson())
    {
        return;
    }
    Idx = 0;
    J0x77:

    if(Idx < PilotLights.Length)
    {
        PilotLights[Idx].Light.SetEnabled(bLightEnabled);
        ++ Idx;
        goto J0x77;
    }
}

simulated function StartPilotSound()
{
    if(((Instigator != none) && Instigator.IsLocallyControlled()) && Instigator.IsFirstPerson())
    {
        PostAkEventOnBone(PilotLightPlayEvent, PilotLightSocketName, false, false);
    }
}

simulated function StopPilotSound()
{
    PostAkEventOnBone(PilotLightStopEvent, PilotLightSocketName, false, false);
}

simulated function StartLoopingFireEffects(byte FireModeNum, optional bool bForceAnim)
{
    StopPilotSound();
    SetPilotDynamicLightEnabled(false);
    super.StartLoopingFireEffects(FireModeNum, bForceAnim);
}

simulated function StopLoopingFireEffects(byte FireModeNum)
{
    super.StopLoopingFireEffects(FireModeNum);
    StartPilotSound();
    SetPilotDynamicLightEnabled(true);
}

simulated function float GetFlickerVal(float BaseVal, float Intensity, float Last, float DeltaTime, float InterpSpeed)
{
    local float GoalVal;

    GoalVal = BaseVal + RandRange(-Intensity, Intensity);
    return FInterpTo(Last, GoalVal, DeltaTime, InterpSpeed);
}

protected simulated function KFSprayActor GetFlameSprayFromPool()
{
    local KFSprayActor Ret;

    Ret = FlamePool[NextFlamePoolIdx];
    ++ NextFlamePoolIdx;
    if(NextFlamePoolIdx >= 2)
    {
        NextFlamePoolIdx = 0;
    }
    return Ret;
}

protected simulated function TurnOnFireSpray()
{
    local KFSprayActor PrevFlameSpray;

    if(!bFireSpraying)
    {
        PrevFlameSpray = ActiveFlameSpray;
        ActiveFlameSpray = GetFlameSprayFromPool();
        if(ActiveFlameSpray != none)
        {
            if(Role == ROLE_Authority)
            {
                ActiveFlameSpray.bVisualOnly = false;
            }
            ActiveFlameSpray.BeginSpray();
            if(((Role == ROLE_Authority) && PrevFlameSpray != none) && PrevFlameSpray != ActiveFlameSpray)
            {
                PrevFlameSpray.bVisualOnly = true;
            }            
        }
        else
        {
            WarnInternal(string(GetFuncName()) @ "ActiveFlameSpray is NONE!!!");
        }
        bFireSpraying = true;
    }
}

protected simulated function TurnOffFireSpray()
{
    if(PSC_EndSpray != none)
    {
        PSC_EndSpray.ActivateSystem();
    }
    if(ActiveFlameSpray != none)
    {
        ActiveFlameSpray.DetachAndFinish();
    }
    bFireSpraying = false;
}

function Timer_CheckForAIWarning();

simulated function DetachWeapon()
{
    TurnOffPilot();
    super.DetachWeapon();
}

simulated function CustomFire()
{
    if(CurrentFireMode != 4)
    {
        IncrementFlashCount();
    }
    super(Weapon).CustomFire();
}

simulated function ChangeVisibility(bool bIsVisible)
{
    super.ChangeVisibility(bIsVisible);
    if(bIsVisible && !bFireSpraying)
    {
        FlamePool[0].SetHidden(true);
        FlamePool[1].SetHidden(true);
        FlamePool[0].SkeletalSprayMesh.SetHidden(true);
        FlamePool[1].SkeletalSprayMesh.SetHidden(true);        
    }
    else
    {
        FlamePool[0].SetHidden(!bIsVisible);
        FlamePool[1].SetHidden(!bIsVisible);
        FlamePool[0].SkeletalSprayMesh.SetHidden(!bIsVisible);
        FlamePool[1].SkeletalSprayMesh.SetHidden(!bIsVisible);
    }
}

simulated event SetFOV(float NewFOV)
{
    super.SetFOV(NewFOV);
    if(MySkelMesh != none)
    {
        if(FlamePool[0] != none)
        {
            FlamePool[0].SetFOV(MySkelMesh.FOV);
        }
        if(FlamePool[1] != none)
        {
            FlamePool[0].SetFOV(MySkelMesh.FOV);
        }
        if(PSC_PilotLight != none)
        {
            PSC_PilotLight.super(KFParticleSystemComponent).SetFOV(MySkelMesh.FOV);
        }
        if(PSC_EndSpray != none)
        {
            PSC_EndSpray.super(KFParticleSystemComponent).SetFOV(MySkelMesh.FOV);
        }
    }
}

static simulated function float CalculateTraderWeaponStatDamage()
{
    local float BaseDamage, DoTDamage;
    local class<KFDamageType> DamageType;

    BaseDamage = default.FlameSprayArchetype.SprayDamage.X;
    DamageType = default.FlameSprayArchetype.MyDamageType;
    if((DamageType != none) && DamageType.default.DoT_Type != 0)
    {
        DoTDamage = (DamageType.default.DoT_Duration / DamageType.default.DoT_Interval) * (BaseDamage * DamageType.default.DoT_DamageScale);
    }
    return BaseDamage + DoTDamage;
}

static simulated event KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter()
{
    return 4;
}

simulated state SprayingFire extends WeaponFiring
{
    simulated function BeginState(name PreviousStateName)
    {
        AmmoConsumed = 0;
        TurnOnFireSpray();
        if(bWarnAIWhenFiring)
        {
            Timer_CheckForAIWarning();
            SetTimer(0.5, true, 'Timer_CheckForAIWarning');
        }
        super.BeginState(PreviousStateName);
    }

    simulated function EndState(name NextStateName)
    {
        if(bFireSpraying)
        {
            TurnOffFireSpray();
        }
        ClearFlashLocation();
        ClearTimer('RefireCheckTimer');
        ClearPendingFire(0);
        if(bWarnAIWhenFiring)
        {
            ClearTimer('Timer_CheckForAIWarning');
        }
        super.EndState(NextStateName);
    }

    simulated function ConsumeAmmo(byte FireMode)
    {
        global.ConsumeAmmo(FireMode);
        ++ AmmoConsumed;
    }

    simulated function bool ShouldRefire()
    {
        if(!HasAmmo(CurrentFireMode))
        {
            return false;
        }
        return (StillFiring(CurrentFireMode)) || AmmoConsumed < MinAmmoConsumed;
    }

    function Timer_CheckForAIWarning()
    {
        local Vector Direction, DangerPoint, TraceStart, Projection;
        local Pawn P;
        local KFPawn_Monster HitMonster;

        TraceStart = Instigator.GetWeaponStartTraceLocation();
        Direction = vector(GetAdjustedAim(TraceStart));
        foreach WorldInfo.AllPawns(Class'Pawn', P)
        {
            if(((P.GetTeamNum() != Instigator.GetTeamNum()) && !P.IsHumanControlled()) && P.IsAliveAndWell())
            {
                Projection = P.Location - TraceStart;
                if(VSizeSq(Projection) < MaxAIWarningDistSQ)
                {
                    PointDistToLine(P.Location, Direction, TraceStart, DangerPoint);
                    if(VSizeSq(DangerPoint - P.Location) < MaxAIWarningDistFromPointSQ)
                    {
                        HitMonster = KFPawn_Monster(P);
                        if((HitMonster != none) && HitMonster.MyKFAIC != none)
                        {
                            HitMonster.MyKFAIC.ReceiveLocationalWarning(DangerPoint, TraceStart, self);
                        }
                    }
                }
            }            
        }        
    }

    simulated function bool IsFiring()
    {
        return true;
    }

    simulated function bool TryPutDown()
    {
        bWeaponPutDown = true;
        return false;
    }
    stop;    
}

simulated state WeaponEquipping
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        TurnOnPilot();
    }
    stop;    
}

simulated state WeaponPuttingDown
{
    simulated event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        TurnOffPilot();
    }
    stop;    
}

simulated state WeaponAbortEquip
{
    simulated event BeginState(name PreviousStateName)
    {
        super(WeaponPuttingDown).BeginState(PreviousStateName);
        TurnOffPilot();
    }
    stop;    
}

auto simulated state Inactive
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        TurnOffPilot();
    }
    stop;    
}

defaultproperties
{
    bArePilotLightsAllowed=true
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
        DepthPriorityGroup=ESceneDepthPriorityGroup.SDPG_Foreground
        TickGroup=ETickingGroup.TG_PostUpdateWork
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_FlameBase.PilotLight0'
    PSC_PilotLight=PilotLight0
    begin object name=FlameEndSpray0 class=KFParticleSystemComponent
        bAutoActivate=false
        ReplacementPrimitive=none
        TickGroup=ETickingGroup.TG_PostUpdateWork
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_FlameBase.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    bWeaponNeedsServerPosition=true
    MaxAIWarningDistSQ=1000000
    MaxAIWarningDistFromPointSQ=40000
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_FlameBase.MeleeHelper'
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_FlameBase.FirstPersonMesh'
    Mesh=FirstPersonMesh
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_FlameBase.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_FlameBase.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}