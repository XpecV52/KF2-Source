/*******************************************************************************
 * KFSpecialMoveHandler generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSpecialMoveHandler extends Object within KFPawn;

var array< class<KFSpecialMove> > SpecialMoveClasses;
var KFSpecialMoveStruct PendingSpecialMoveStruct;

simulated event DoSpecialMove(KFPawn.ESpecialMove NewMove, optional bool bForceMove, optional Pawn InInteractionPawn, optional int InSpecialMoveFlags, optional bool bSkipReplication, optional bool bIsPendingMove)
{
    local KFPawn.ESpecialMove PrevMove;

    if(Outer.bLogSpecialMove)
    {
        LogInternal((((("New special move requested:" @ string(NewMove)) @ string(InInteractionPawn)) @ string(InSpecialMoveFlags)) @ "bForceMove:") @ string(bForceMove));
    }
    if((NewMove != 0) && !VerifySpecialMoveInstance(NewMove))
    {
        WarnInternal((((string(Outer.WorldInfo.TimeSeconds) @ string(self)) @ string(GetFuncName())) @ "couldn't instance special move") @ string(NewMove));
        return;
    }
    if(bIsPendingMove)
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal("- PendingSpecialMove is being started.");
        }
        PendingSpecialMoveStruct.SpecialMove = 0;
        PendingSpecialMoveStruct.InteractionPawn = none;
        PendingSpecialMoveStruct.Flags = 0;
    }
    if(NewMove == Outer.SpecialMove)
    {
        ReassignSpecialMove(InInteractionPawn, InSpecialMoveFlags, bSkipReplication);
        return;
    }
    PrevMove = Outer.SpecialMove;
    if(!bIsPendingMove)
    {
        if((!bForceMove && Outer.SpecialMove != 0) && NewMove != 0)
        {
            if(!CanOverrideSpecialMove(NewMove, InInteractionPawn, InSpecialMoveFlags))
            {
                return;
            }
            bForceMove = true;
        }
        if(Outer.SpecialMove != 0)
        {
            if(Outer.bLogSpecialMove)
            {
                LogInternal("- leaving move:" @ string(Outer.SpecialMove));
            }
            Outer.SpecialMove = 0;
            SpecialMoveEnded(PrevMove, NewMove);
        }
        if((NewMove == 0) && PendingSpecialMoveStruct.SpecialMove != 0)
        {
            if(DoPendingSpecialMove(bForceMove))
            {
                return;
            }
        }
    }
    if(((NewMove != 0) && !bForceMove) && !CanDoSpecialMove(NewMove))
    {
        WarnInternal((((string(Outer.WorldInfo.TimeSeconds) @ string(self)) @ string(GetFuncName())) @ "cannot do requested special move") @ string(NewMove));
        return;
    }
    Outer.SpecialMove = NewMove;
    Outer.InteractionPawn = KFPawn(InInteractionPawn);
    Outer.SpecialMoveFlags = byte(InSpecialMoveFlags);
    if(!bSkipReplication && (((Outer.WorldInfo.NetMode != NM_Standalone) || Outer.WorldInfo.IsRecordingDemo()) && Outer.Role == ROLE_Authority) && (Outer.SpecialMove == 0) || Outer.SpecialMoves[Outer.SpecialMove].ShouldReplicate())
    {
        ReplicateSpecialMove(NewMove, InInteractionPawn, InSpecialMoveFlags);
    }
    if(Outer.SpecialMove != 0)
    {
        SpecialMoveStarted(Outer.SpecialMove, PrevMove, bForceMove);
        if(bForceMove)
        {
            PendingSpecialMoveStruct.SpecialMove = 0;
            PendingSpecialMoveStruct.InteractionPawn = none;
            PendingSpecialMoveStruct.Flags = 0;
        }
    }
}

private final simulated function bool CanOverrideSpecialMove(KFPawn.ESpecialMove NewMove, Pawn InInteractionPawn, int InSpecialMoveFlags)
{
    local name SpecialMoveName, NewMoveName;

    NewMoveName = Outer.SpecialMoves[NewMove].Handle;
    SpecialMoveName = Outer.SpecialMoves[Outer.SpecialMove].Handle;
    if(Outer.SpecialMoves[Outer.SpecialMove].CanOverrideMoveWith(NewMoveName) || Outer.SpecialMoves[NewMove].CanOverrideSpecialMove(SpecialMoveName))
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal(((((("- Overriding" @ string(Outer.SpecialMove)) @ "with") @ string(NewMove)) @ "(previous pending:") @ string(PendingSpecialMoveStruct.SpecialMove)) $ ")");
        }
        return true;        
    }
    else
    {
        if(Outer.SpecialMoves[Outer.SpecialMove].CanChainMove(NewMoveName))
        {
            if(Outer.bLogSpecialMove)
            {
                LogInternal(((((("- chaining" @ string(NewMove)) @ "after") @ string(Outer.SpecialMove)) @ "(previous pending:") @ string(PendingSpecialMoveStruct.SpecialMove)) $ ")");
            }
            PendingSpecialMoveStruct.SpecialMove = NewMove;
            PendingSpecialMoveStruct.InteractionPawn = InInteractionPawn;
            PendingSpecialMoveStruct.Flags = byte(InSpecialMoveFlags);            
        }
        else
        {
            WarnInternal((((((((string(Outer.WorldInfo.TimeSeconds) @ string(self)) @ string(GetFuncName())) @ "Cannot override, cannot chain.") @ string(NewMove)) @ "is lost! SpecialMove:") @ string(Outer.SpecialMove)) @ "Pending:") @ string(PendingSpecialMoveStruct.SpecialMove));
        }
        return false;
    }
}

private final simulated function bool DoPendingSpecialMove(bool bForceMove)
{
    local KFPawn.ESpecialMove NextMove;

    if(Outer.bLogSpecialMove)
    {
        LogInternal("- triggering pending special move:" @ string(PendingSpecialMoveStruct.SpecialMove));
    }
    NextMove = PendingSpecialMoveStruct.SpecialMove;
    DoSpecialMove(PendingSpecialMoveStruct.SpecialMove, bForceMove, PendingSpecialMoveStruct.InteractionPawn, PendingSpecialMoveStruct.Flags, false, true);
    if(Outer.SpecialMove == NextMove)
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal("- PendingSpecialMove trigger successful for" @ string(NextMove));
        }
        return true;        
    }
    else
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal(("- PendingSpecialMove trigger failed for" @ string(NextMove)) @ "Proceeding to clear SpecialMove");
        }
        return false;
    }
}

private final simulated function ReassignSpecialMove(Pawn InInteractionPawn, int InSpecialMoveFlags, bool bSkipReplication)
{
    if(InSpecialMoveFlags != Outer.SpecialMoveFlags)
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal("- updating special move flags");
        }
        Outer.SpecialMoveFlags = byte(InSpecialMoveFlags);
        if((Outer.Role == ROLE_Authority) && !bSkipReplication)
        {
            Outer.ReplicatedSpecialMove.Flags = Outer.SpecialMoveFlags;
            Outer.bForceNetUpdate = true;
        }
        if(Outer.SpecialMove != 0)
        {
            Outer.SpecialMoves[Outer.SpecialMove].SpecialMoveFlagsUpdated();
        }
    }
    if(InInteractionPawn != Outer.InteractionPawn)
    {
        if(Outer.bLogSpecialMove)
        {
            LogInternal("- updating interaction pawn");
        }
        Outer.InteractionPawn = KFPawn(InInteractionPawn);
    }
    if(Outer.bLogSpecialMove)
    {
        LogInternal("- ignoring redundant call");
    }
}

private final simulated function ReplicateSpecialMove(KFPawn.ESpecialMove NewMove, Pawn InInteractionPawn, int InSpecialMoveFlags)
{
    if(Outer.bLogSpecialMove)
    {
        LogInternal("- Replicating New SM" @ string(Outer.SpecialMove));
    }
    if(Outer.ReplicatedSpecialMove.SpecialMove == NewMove)
    {
        if(Outer.ReplicatedSpecialMove.SpecialMove == 0)
        {
            ++ Outer.ReplicatedSpecialMove.Flags;            
        }
        else
        {
            if((Outer.ReplicatedSpecialMove.InteractionPawn == InInteractionPawn) && Outer.ReplicatedSpecialMove.Flags == InSpecialMoveFlags)
            {
                WarnInternal("Special Move cannot be replicated properly!!!");
                ScriptTrace();                
            }
            else
            {
                Outer.ReplicatedSpecialMove.SpecialMove = NewMove;
                Outer.ReplicatedSpecialMove.InteractionPawn = InInteractionPawn;
                Outer.ReplicatedSpecialMove.Flags = byte(InSpecialMoveFlags);
            }
        }        
    }
    else
    {
        Outer.ReplicatedSpecialMove.SpecialMove = NewMove;
        Outer.ReplicatedSpecialMove.InteractionPawn = InInteractionPawn;
        Outer.ReplicatedSpecialMove.Flags = byte(InSpecialMoveFlags);
    }
    Outer.bForceNetUpdate = true;
}

final simulated event bool CanDoSpecialMove(KFPawn.ESpecialMove AMove, optional bool bForceCheck)
{
    if(AMove == 0)
    {
        return true;
    }
    if(((AMove != 0) && SpecialMoveClasses.Length > AMove) && SpecialMoveClasses[AMove] != none)
    {
        if(VerifySpecialMoveInstance(AMove))
        {
            return CanChainSpecialMove(AMove) && Outer.SpecialMoves[AMove].super(KFSpecialMoveHandler).CanDoSpecialMove(bForceCheck);
        }
        LogInternal(((((string(GetFuncName()) @ "Failed with special move:") @ string(AMove)) @ "class:") @ string(SpecialMoveClasses[AMove])) @ string(self));
    }
    return false;
}

private final simulated function bool CanChainSpecialMove(KFPawn.ESpecialMove NextMove)
{
    local name SpecialMoveName, NextMoveName;

    NextMoveName = Outer.SpecialMoves[NextMove].Handle;
    if(Outer.SpecialMove != 0)
    {
        SpecialMoveName = Outer.SpecialMoves[Outer.SpecialMove].Handle;
    }
    return (((Outer.SpecialMove == 0) || Outer.SpecialMoves[Outer.SpecialMove].CanChainMove(NextMoveName)) || Outer.SpecialMoves[Outer.SpecialMove].CanOverrideMoveWith(NextMoveName)) || Outer.SpecialMoves[NextMove].CanOverrideSpecialMove(SpecialMoveName);
}

private final simulated function SpecialMoveStarted(KFPawn.ESpecialMove NewMove, KFPawn.ESpecialMove PrevMove, bool bForced)
{
    local name PrevMoveName;

    if(Outer.bLogSpecialMove)
    {
        LogInternal((("NewMove:" @ string(NewMove)) @ "PrevMove:") @ string(PrevMove));
    }
    if(NewMove != 0)
    {
        if(Outer.SpecialMoves[NewMove] != none)
        {
            if(PrevMove != 0)
            {
                PrevMoveName = Outer.SpecialMoves[PrevMove].Handle;
            }
            Outer.SpecialMoves[NewMove].SpecialMoveStarted(bForced, PrevMoveName);
        }
    }
}

final simulated function SpecialMoveEnded(KFPawn.ESpecialMove PrevMove, KFPawn.ESpecialMove NextMove)
{
    local name NextMoveName;

    if(Outer.bLogSpecialMove)
    {
        LogInternal("PrevMove:" @ string(PrevMove));
    }
    if((PrevMove != 0) && Outer.SpecialMoves[PrevMove] != none)
    {
        if(NextMove != 0)
        {
            NextMoveName = Outer.SpecialMoves[NextMove].Handle;
        }
        Outer.SpecialMoves[PrevMove].SpecialMoveEnded(Outer.SpecialMoves[PrevMove].Handle, NextMoveName);
    }
}

simulated function bool VerifySpecialMoveInstance(KFPawn.ESpecialMove AMove)
{
    if(AMove != 0)
    {
        if((AMove >= Outer.SpecialMoves.Length) || Outer.SpecialMoves[AMove] == none)
        {
            if((AMove < SpecialMoveClasses.Length) && SpecialMoveClasses[AMove] != none)
            {
                Outer.SpecialMoves[AMove] = new (Outer) SpecialMoveClasses[AMove];
                Outer.SpecialMoves[AMove].InitSpecialMove(Outer, 'MoveName');                
            }
            else
            {
                LogInternal(((((string(GetFuncName()) @ "Failed with special move:") @ string(AMove)) @ "class:") @ string(SpecialMoveClasses[AMove])) @ string(self));
                Outer.SpecialMoves[AMove] = none;
                return false;
            }
        }
        return true;
    }
    return false;
}

simulated function ClearPendingSpecialMove()
{
    if(Outer.bLogSpecialMove)
    {
        LogInternal("- Clearing PendingSpecialMove:");
    }
    PendingSpecialMoveStruct.SpecialMove = 0;
    PendingSpecialMoveStruct.InteractionPawn = none;
    PendingSpecialMoveStruct.Flags = 0;
}

final simulated function EndSpecialMove(optional KFPawn.ESpecialMove SpecialMoveToEnd, optional bool bForceNetSync)
{
    if(Outer.bLogSpecialMove)
    {
        LogInternal("SpecialMoveToEnd:" @ string(SpecialMoveToEnd));
    }
    if(Outer.IsDoingSpecialMove())
    {
        if((SpecialMoveToEnd != 0) && PendingSpecialMoveStruct.SpecialMove == SpecialMoveToEnd)
        {
            ClearPendingSpecialMove();
        }
        if((SpecialMoveToEnd == 0) || Outer.IsDoingSpecialMove(SpecialMoveToEnd))
        {
            DoSpecialMove(0, true);
        }
    }
}
