/*******************************************************************************
 * KFSM_DeathAnim generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_DeathAnim extends KFSpecialMove;

var float NextDeathAnim_ActorTime;
var byte NumChainedDeathAnims;
var byte MaxChainedDeathAnims;
var bool bHasDeathMotorsActive;

static function byte PackSMFlags(KFPawn P, Vector HitDir)
{
    return 0;
}

protected function bool InternalCanDoSpecialMove()
{
    if(((PawnOwner.Physics == 10) && KFPOwner != none) && KFPOwner.PawnAnimInfo.bCanPlayDeathAnimations)
    {
        return true;
    }
    return false;
}

function bool PlayDeathAnimation(class<DamageType> DamageType, Vector HitDirection, optional name HitBoneName)
{
    local name DeathAnim;
    local float Duration;

    DeathAnim = KFPOwner.PawnAnimInfo.ChooseDeathAnimation(KFPOwner, DamageType, HitDirection, HitBoneName);
    if(DeathAnim != 'None')
    {
        Duration = PlaySpecialMoveAnim(DeathAnim, 0, 0.2, -1);
    }
    if(Duration <= 0)
    {
        KFPOwner.EndSpecialMove();
        return false;
    }
    if(true)
    {
        StartDeathAnimMotors();        
    }
    else
    {
        KFPOwner.EndSpecialMove();
    }
    if(KFPOwner.bLogCustomAnim)
    {
        LogInternal((("PlayDeathAnimation success DamageType:" $ string(DamageType)) @ "BoneName:") $ string(HitBoneName));
    }
    return true;
}

function bool GetDeathAnimation(class<DamageType> DamageType, Vector HitDirection, optional name HitBoneName);

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    StopDeathAnimMotors();
    KFPOwner.EndSpecialMove();
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    if(bHasDeathMotorsActive)
    {
        StopDeathAnimMotors();
    }
    KFPOwner.StopAllAnimations();
    if(KFPOwner.bLogCustomAnim)
    {
        LogInternal("DeathAnimation finished ChainCount:" $ string(NumChainedDeathAnims));
    }
}

function StartDeathAnimMotors()
{
    PawnOwner.Mesh.bIgnoreControllers = 1;
    PawnOwner.Mesh.bUpdateJointsFromAnimation = true;
    PawnOwner.Mesh.bUpdateKinematicBonesFromAnimation = true;
    if(PawnOwner.Mesh.PhysicsAssetInstance != none)
    {
        PawnOwner.Mesh.PhysicsAssetInstance.SetAllMotorsAngularDriveParams(KFPOwner.PawnAnimInfo.DeathPhysMotorStrength.X, KFPOwner.PawnAnimInfo.DeathPhysMotorStrength.Y, 0, PawnOwner.Mesh, true);
        PawnOwner.Mesh.PhysicsAssetInstance.SetAllMotorsAngularPositionDrive(true, true, PawnOwner.Mesh, true);
    }
    if(KFPOwner.bHasBrokenConstraints)
    {
        PawnOwner.Mesh.UpdateMeshForBrokenConstraints();
    }
    bHasDeathMotorsActive = true;
}

function StopDeathAnimMotors()
{
    PawnOwner.Mesh.bUpdateJointsFromAnimation = false;
    PawnOwner.Mesh.bUpdateKinematicBonesFromAnimation = false;
    if(PawnOwner.Mesh.PhysicsAssetInstance != none)
    {
        PawnOwner.Mesh.PhysicsAssetInstance.SetAllMotorsAngularPositionDrive(false, false, PawnOwner.Mesh, true);
    }
    bHasDeathMotorsActive = false;
}

final function SetSpringForBone(name InBoneName, bool bEnable)
{
    local int BoneIndex;
    local Matrix BoneMatrix;
    local RB_BodyInstance BoneBody;

    InBoneName = PawnOwner.Mesh.GetSocketBoneName(InBoneName);
    if(InBoneName == 'None')
    {
        WarnInternal((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Has non existing Bone or Socket named:") @ string(InBoneName)) @ "Unable to create HipBodyInstance!");
        return;
    }
    BoneIndex = PawnOwner.Mesh.MatchRefBone(InBoneName);
    if(BoneIndex != -1)
    {
        BoneMatrix = PawnOwner.Mesh.GetBoneMatrix(BoneIndex);
        BoneBody = PawnOwner.Mesh.FindBodyInstanceNamed(InBoneName);
        if(BoneBody != none)
        {
            BoneBody.EnableBoneSpring(bEnable, bEnable, BoneMatrix);
            if(bEnable)
            {
                BoneBody.OverextensionThreshold = 50;
                BoneBody.SetBoneSpringParams(10000, 500, 10000, 500);
                BoneBody.bDisableOnOverextension = true;
            }            
        }
        else
        {
            WarnInternal(((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "BodyInstance not found for BoneName:") @ string(InBoneName));
            ScriptTrace();
        }        
    }
    else
    {
        WarnInternal((((((string(PawnOwner.WorldInfo.TimeSeconds) @ string(PawnOwner)) @ string(Class)) @ string(GetFuncName())) @ "Has non existing Index for BoneName:") @ string(InBoneName)) @ "Unable to create BodyInstance!");
    }
}

function OnRigidBodySpringOverextension(RB_BodyInstance BodyInstance)
{
    local name PelvisBoneName;
    local RB_BodyInstance PelvisBodyInstance;

    PelvisBoneName = PawnOwner.Mesh.GetSocketBoneName(KFPOwner.PelvisBoneName);
    PelvisBodyInstance = PawnOwner.Mesh.FindBodyInstanceNamed(PelvisBoneName);
    if(PelvisBodyInstance == BodyInstance)
    {
        StopDeathAnimMotors();
    }
}

function NotifyOwnerTakeHit(class<KFDamageType> DamageType, Vector HitLoc, Vector HitDir, Controller InstigatedBy)
{
    local TraceHitInfo HitInfo;
    local name DeathAnim;

    if((NumChainedDeathAnims < MaxChainedDeathAnims) && PawnOwner.ActorTimeSince(NextDeathAnim_ActorTime) > float(0))
    {
        if((NumChainedDeathAnims == 0) && PawnOwner.WorldInfo.TimeSeconds == KFPOwner.TimeOfDeath)
        {
            return;
        }
        KFPOwner.CheckHitInfo(HitInfo, KFPOwner.Mesh, HitDir, HitLoc);
        DeathAnim = KFPOwner.PawnAnimInfo.ChooseDeathAnimation(KFPOwner, DamageType, HitDir, HitInfo.BoneName);
        if(DeathAnim != 'None')
        {
            PlaySpecialMoveAnim(DeathAnim, 0, 0.2, -1);
        }
        ++ NumChainedDeathAnims;
        NextDeathAnim_ActorTime = PawnOwner.GetActorTimeSeconds() + RandRange(0.15, 0.33);
    }
}

defaultproperties
{
    MaxChainedDeathAnims=5
    bDisablesWeaponFiring=true
}