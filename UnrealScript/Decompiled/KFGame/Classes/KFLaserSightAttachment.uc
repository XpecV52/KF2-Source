/*******************************************************************************
 * KFLaserSightAttachment generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFLaserSightAttachment extends Object
    native(Effect)
    hidecategories(Object);

/** Distance at which we should start scaling the dot size and depth bias (5m) */
var() float LaserDotLerpStartDistance;
/** Distance at which we should stop scaling the dot size and depth bias (60m) */
var() float LaserDotLerpEndDistance;
/** Max scale is clamped at 20x */
var() float LaserDotMaxScale;
/** How much to pull the laser dot back to make sure it doesn't clip through what it hit */
var() float LaserDotDepthBias;
/** Static Mesh */
var() StaticMesh LaserDotMesh;
var export editinline transient StaticMeshComponent LaserDotMeshComp;
/** Laser Sight Mesh */
var() SkeletalMesh LaserSightMesh;
var export editinline transient KFSkeletalMeshComponent LaserSightMeshComp;
/** Laser Mesh */
var() SkeletalMesh LaserBeamMesh;
var export editinline transient KFSkeletalMeshComponent LaserBeamMeshComp;
/** Socket to attach the LaserSight to */
var() name LaserSightSocketName;
var() float LaserSightRange;
var float AnimWeight;
/** Specifies blending rate between aim and animation */
var() float AnimBlendRate;
var transient float LaserSightAimStrength;
var transient float DesiredAimStrength;
var transient bool IsVisible;

function AttachLaserSight(SkeletalMeshComponent OwnerMesh, bool bFirstPerson, optional name SocketNameOverride)
{
    local editinline KFSkeletalMeshComponent KFMesh;

    if(OwnerMesh == none)
    {
        LogInternal("Invalid mesh for laser sight " @ string(self));
        return;
    }
    if(SocketNameOverride != 'None')
    {
        LaserSightSocketName = SocketNameOverride;
    }
    if((LaserDotMesh != none) && bFirstPerson)
    {
        LaserDotMeshComp.SetStaticMesh(LaserDotMesh);
        OwnerMesh.AttachComponentToSocket(LaserDotMeshComp, LaserSightSocketName);
    }
    if(LaserSightMesh != none)
    {
        LaserSightMeshComp.SetSkeletalMesh(LaserSightMesh);
        OwnerMesh.AttachComponentToSocket(LaserSightMeshComp, LaserSightSocketName);
        if(bFirstPerson)
        {
            LaserSightMeshComp.SetDepthPriorityGroup(2);
        }
    }
    if(LaserBeamMesh != none)
    {
        LaserBeamMeshComp.SetSkeletalMesh(LaserBeamMesh);
        OwnerMesh.AttachComponentToSocket(LaserBeamMeshComp, LaserSightSocketName);
        if(bFirstPerson)
        {
            LaserBeamMeshComp.SetDepthPriorityGroup(2);
        }
    }
    KFMesh = KFSkeletalMeshComponent(OwnerMesh);
    if((KFMesh != none) && KFMesh.FOV > float(0))
    {
        SetMeshFOV(KFMesh.FOV);
    }
}

simulated function SetMeshFOV(float NewFOV)
{
    if(LaserBeamMeshComp.SkeletalMesh != none)
    {
        LaserBeamMeshComp.SetFOV(NewFOV);
    }
    if(LaserSightMeshComp.SkeletalMesh != none)
    {
        LaserSightMeshComp.SetFOV(NewFOV);
    }
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    if(LaserSightMeshComp.SkeletalMesh != none)
    {
        LaserSightMeshComp.SetLightingChannels(NewLightingChannels);
    }
}

simulated event ChangeVisibility(bool bVisible)
{
    IsVisible = bVisible;
    LaserDotMeshComp.SetHidden(!bVisible);
    LaserSightMeshComp.SetHidden(!bVisible);
    LaserBeamMeshComp.SetHidden(!bVisible);
}

simulated function Update(float DeltaTime, KFWeapon OwningWeapon)
{
    local Vector TraceStart, TraceEnd, InstantTraceHitLocation, InstantTraceHitNormal, HitLocation, HitNormal,
	    TraceAimDir, SocketSpaceNewTraceDir, WorldSpaceNewTraceDir, SocketSpaceAimLocation, SocketSpaceAimDir;

    local Actor HitActor;
    local Rotator SocketRotation;
    local Matrix SocketToWorldTransform;
    local Vector DirA, DirB;
    local Quat Q;
    local TraceHitInfo HitInfo;

    if(IsVisible == false)
    {
        return;
    }
    if((((OwningWeapon != none) && OwningWeapon.Instigator != none) && OwningWeapon.Instigator.Weapon == OwningWeapon) && OwningWeapon.Instigator.IsFirstPerson())
    {
        UpdateFirstPersonAImStrength(DeltaTime, OwningWeapon);
        TraceStart = OwningWeapon.Instigator.GetWeaponStartTraceLocation();
        TraceAimDir = vector(OwningWeapon.Instigator.GetAdjustedAimFor(OwningWeapon, TraceStart));
        if(LaserSightAimStrength > 0)
        {
            TraceEnd = TraceStart + (TraceAimDir * LaserSightRange);
            HitActor = OwningWeapon.GetTraceOwner().Trace(InstantTraceHitLocation, InstantTraceHitNormal, TraceEnd, TraceStart, true, vect(0, 0, 0), HitInfo, OwningWeapon.1);
            if(HitActor != none)
            {
                if(LaserSightAimStrength < 1)
                {
                    if((OwningWeapon.MySkelMesh != none) && OwningWeapon.MySkelMesh.GetSocketWorldLocationAndRotation(LaserSightSocketName, TraceStart, SocketRotation))
                    {
                        SocketToWorldTransform = OwningWeapon.MySkelMesh.GetSocketMatrix(LaserSightSocketName);
                        SocketSpaceAimLocation = InverseTransformVector(SocketToWorldTransform, InstantTraceHitLocation);
                        SocketSpaceAimDir = Normal(SocketSpaceAimLocation);
                        DirB = vect(1, 0, 0);
                        DirA = SocketSpaceAimDir;
                        if((DirA Dot DirB) < 0.995)
                        {
                            Q = QuatFromAxisAndAngle(Normal(DirB Cross DirA), 0.1);
                            SocketSpaceAimDir = QuatRotateVector(Q, DirB);
                        }
                        SocketSpaceNewTraceDir = (LaserSightAimStrength * SocketSpaceAimDir) + ((1 - LaserSightAimStrength) * DirB);
                        WorldSpaceNewTraceDir = TransformVector(SocketToWorldTransform, SocketSpaceNewTraceDir) - TraceStart;
                        TraceEnd = TraceStart + (Normal(WorldSpaceNewTraceDir) * LaserSightRange);
                        HitActor = OwningWeapon.GetTraceOwner().Trace(HitLocation, HitNormal, TraceEnd, TraceStart, true, vect(0, 0, 0), HitInfo, OwningWeapon.1);
                        if(HitActor != none)
                        {
                            LaserDotMeshComp.SetHidden(false);
                            AimAt(HitLocation, HitNormal, OwningWeapon.MySkelMesh);                            
                        }
                        else
                        {
                            LaserDotMeshComp.SetHidden(true);
                        }
                    }                    
                }
                else
                {
                    LaserDotMeshComp.SetHidden(false);
                    AimAt(InstantTraceHitLocation, InstantTraceHitNormal, OwningWeapon.MySkelMesh);
                }                
            }
            else
            {
                LaserDotMeshComp.SetHidden(true);
            }            
        }
        else
        {
            if((OwningWeapon.MySkelMesh != none) && OwningWeapon.MySkelMesh.GetSocketWorldLocationAndRotation(LaserSightSocketName, TraceStart, SocketRotation))
            {
                DirA = vector(SocketRotation);
                DirB = TraceAimDir;
                if((DirA Dot DirB) < 0.94)
                {
                    LaserDotMeshComp.SetHidden(true);
                    return;
                }
                TraceEnd = TraceStart + (vector(SocketRotation) * LaserSightRange);
                HitActor = OwningWeapon.GetTraceOwner().Trace(HitLocation, HitNormal, TraceEnd, TraceStart, true, vect(0, 0, 0), HitInfo, OwningWeapon.1);
                if(HitActor != none)
                {
                    LaserDotMeshComp.SetHidden(false);
                    AimAt(HitLocation, HitNormal, OwningWeapon.MySkelMesh);                    
                }
                else
                {
                    LaserDotMeshComp.SetHidden(true);
                }
            }
        }
    }
}

function UpdateFirstPersonAImStrength(float DeltaTime, KFWeapon W)
{
    if((W.IsInState('Active') && W.IdleBobBlendNode != none) && W.IdleBobBlendNode.Child2WeightTarget == 1)
    {
        DesiredAimStrength = 1 - AnimWeight;        
    }
    else
    {
        DesiredAimStrength = 0;
    }
    if(LaserSightAimStrength < DesiredAimStrength)
    {
        LaserSightAimStrength = FMin(LaserSightAimStrength + (AnimBlendRate * DeltaTime), DesiredAimStrength);        
    }
    else
    {
        if(LaserSightAimStrength > DesiredAimStrength)
        {
            LaserSightAimStrength = FMax(LaserSightAimStrength - (AnimBlendRate * DeltaTime), DesiredAimStrength);
        }
    }
}

function AimAt(Vector HitLocation, Vector HitNormal, SkeletalMeshComponent ParentMesh)
{
    local Vector SocketSpaceAimLocation;
    local Matrix SocketToWorldTransform;
    local float LaserDotScale;
    local Vector SocketLocation, SocketToHit;

    ParentMesh.GetSocketWorldLocationAndRotation(LaserSightSocketName, SocketLocation);
    SocketToHit = (HitLocation - SocketLocation) * LaserDotDepthBias;
    HitLocation = SocketLocation + SocketToHit;
    SocketToWorldTransform = ParentMesh.GetSocketMatrix(LaserSightSocketName);
    SocketSpaceAimLocation = InverseTransformVector(SocketToWorldTransform, HitLocation);
    LaserDotMeshComp.SetTranslation(SocketSpaceAimLocation);
    LaserDotScale = 1 + ((LaserDotMaxScale - 1) * FMax((SocketSpaceAimLocation.X - LaserDotLerpStartDistance) / (LaserDotLerpEndDistance - LaserDotLerpStartDistance), 0));
    LaserDotMeshComp.SetScale(LaserDotScale);
}

// Export UKFLaserSightAttachment::execGetFOVAdjustedLaserSocket(FFrame&, void* const)
native function bool GetFOVAdjustedLaserSocket(KFSkeletalMeshComponent Mesh, name InSocketName, out Vector OutLocation, out Rotator OutRotation);

defaultproperties
{
    LaserDotLerpStartDistance=25
    LaserDotLerpEndDistance=6000
    LaserDotMaxScale=10
    LaserDotDepthBias=0.95
    begin object name=LaserDotStaticMeshComponent class=StaticMeshComponent
        ReplacementPrimitive=none
        DepthPriorityGroup=ESceneDepthPriorityGroup.SDPG_Foreground
        CastShadow=false
        CollideActors=false
        BlockActors=false
        BlockZeroExtent=false
        BlockNonZeroExtent=false
        BlockRigidBody=false
        TickGroup=ETickingGroup.TG_PostAsyncWork
    object end
    // Reference: StaticMeshComponent'Default__KFLaserSightAttachment.LaserDotStaticMeshComponent'
    LaserDotMeshComp=LaserDotStaticMeshComponent
    begin object name=LaserSightMeshComponent class=KFSkeletalMeshComponent
        bUpdateSkelWhenNotRendered=false
        bIgnoreControllersWhenNotRendered=true
        bOverrideAttachmentOwnerVisibility=true
        ReplacementPrimitive=none
        MaxDrawDistance=4000
        CachedMaxDrawDistance=4000
        bOwnerNoSee=true
        AlwaysLoadOnServer=false
        LightingChannels=(bInitialized=true,Outdoor=true)
        TickGroup=ETickingGroup.TG_PostAsyncWork
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFLaserSightAttachment.LaserSightMeshComponent'
    LaserSightMeshComp=LaserSightMeshComponent
    begin object name=LaserBeamMeshComp class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
        CastShadow=false
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFLaserSightAttachment.LaserBeamMeshComp'
    LaserBeamMeshComp=LaserBeamMeshComp
    LaserSightRange=20000
    AnimBlendRate=3
    IsVisible=true
}