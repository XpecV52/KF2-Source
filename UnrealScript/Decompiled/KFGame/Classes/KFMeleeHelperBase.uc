/*******************************************************************************
 * KFMeleeHelperBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFMeleeHelperBase extends Object within Actor
    native;

struct native MeleeHitboxInfo
{
    var Vector BoneOffset;
    var Vector LastLoc;

    structdefaultproperties
    {
        BoneOffset=(X=0,Y=0,Z=0)
        LastLoc=(X=0,Y=0,Z=0)
    }
};

/** The maximum range at which this attack can be used */
var() const float MaxHitRange;
/** Optional dot product check for melee hit detection */
var() const float DefaultFOVCosine;
var const array<MeleeHitboxInfo> HitboxChain;
var Vector HitboxExtent;
var float HitboxSpacing;
var name HitboxBoneName;
var Core.Object.EAxis HitboxBoneAxis;
var bool bHitboxCollideComplex;
var bool bOnlyUseHitboxExtentAtHead;
var bool bDoHitboxObstructionTrace;
var bool bHitboxPawnsOnly;
var bool bAllowMeleeToFracture;
var bool bHasAlreadyHit;
var bool bLogMelee;
var bool bDebugShowCollision;
var const array<Actor> ActorsCollidedWith;
/** This is the camera shake that we play when we hit a melee attack */
var() const CameraShake MeleeVictimCamShake;
/** This is the camera shake that we play when we hit a melee attack */
var() const CameraShake MeleeImpactCamShake;

simulated function Vector GetMeleeStartTraceLocation()
{
    return Outer.Instigator.Location + (vect(0, 0, 1) * Outer.Instigator.BaseEyeHeight);
}

simulated function Rotator GetMeleeAimRotation()
{
    local Rotator R;

    if(Outer.Instigator != none)
    {
        R = Outer.Instigator.GetBaseAimRotation();
    }
    return R;
}

simulated function float GetMeleeRange()
{
    return MaxHitRange;
}

function bool MeleeAttackDestructibles();

function DoWeaponInstantTrace(Vector StartTrace, Vector EndTrace, optional out ImpactInfo out_Impact)
{
    if((Outer.Instigator != none) && Outer.Instigator.Weapon != none)
    {
        out_Impact = Outer.Instigator.Weapon.CalcWeaponFire(StartTrace, EndTrace);
    }
}

// Export UKFMeleeHelperBase::execTraceNoPawns(FFrame&, void* const)
native function Actor TraceNoPawns(out Vector HitLocation, out Vector HitNormal, Vector TraceEnd, Vector TraceStart);

simulated function Pawn FindVictimByFOV(Vector StartTrace, Vector EndTrace, optional float Range, optional float FOVCosine)
{
    local Pawn P, BestVictim;
    local float NewRating, BestRating;

    Range = MaxHitRange;
    FOVCosine = DefaultFOVCosine;
    BestRating = 0;
    foreach Outer.WorldInfo.AllPawns(Class'Pawn', P, StartTrace, Range)
    {
        NewRating = RateMeleeVictim(P, StartTrace, EndTrace, Range, FOVCosine, BestRating);
        if(NewRating > BestRating)
        {
            BestVictim = P;
            BestRating = NewRating;
        }        
    }    
    if(bLogMelee)
    {
        Outer.DrawDebugCone(StartTrace, EndTrace - StartTrace, Range, Acos(FOVCosine), Acos(FOVCosine), 16, MakeColor(64, 64, 64, 255), true);
    }
    return BestVictim;
}

simulated function float RateMeleeVictim(Pawn Victim, Vector StartTrace, Vector EndTrace, float Range, float FOVCosine, optional float RatingToBeat)
{
    local float VictimRating;
    local Vector VictimLocation, DirToVictim, AimDir;

    if(((Victim == Outer.Instigator) || Victim.bDeleteMe) || Victim.bTearOff)
    {
        return -1;
    }
    if(bLogMelee)
    {
        LogInternal("Melee considering:" @ string(Victim));
    }
    VictimLocation = GetMeleeHitTestLocation(Victim);
    if(Abs(VictimLocation.Z - Outer.Instigator.Location.Z) > (Outer.Instigator.CylinderComponent.CollisionHeight * 1.5))
    {
        if(bLogMelee)
        {
            LogInternal("rejected within vertical melee range");
        }
        return -1;
    }
    Range += Victim.CylinderComponent.CollisionRadius;
    VictimRating = (Range * Range) - VSizeSq2D(VictimLocation - StartTrace);
    if(VictimRating < RatingToBeat)
    {
        if(bLogMelee)
        {
            LogInternal("rejected victim with lower rating");
        }
        return -1;
    }
    if(FOVCosine > 0)
    {
        AimDir = Normal(EndTrace - StartTrace);
        DirToVictim = Normal(VictimLocation - StartTrace);
        if((DirToVictim Dot AimDir) < FOVCosine)
        {
            if(bLogMelee)
            {
                LogInternal((("rejected:" @ string(Victim)) @ "dot:") @ string(DirToVictim Dot AimDir));
            }
            return -1;            
        }
        else
        {
            if(bLogMelee)
            {
                LogInternal((("accepted:" @ string(Victim)) @ "dot:") @ string(DirToVictim Dot AimDir));
            }
        }
    }
    if(!Outer.FastTrace(EndTrace, StartTrace))
    {
        if(bLogMelee)
        {
            LogInternal(("rejected:" @ string(Victim)) @ "melee obstruction: ");
        }
        return -1;
    }
    return VictimRating;
}

simulated function Vector GetMeleeHitTestLocation(Pawn P)
{
    return P.Location;
}

simulated function bool TraceMeleeAttackHitZones(Pawn P, Vector StartTrace, Vector EndTrace, optional out ImpactInfo out_Impact, optional name BoneName)
{
    local array<ImpactInfo> ImpactList;

    if(BoneName != 'None')
    {
        EndTrace = P.Mesh.GetBoneLocation(BoneName);
    }
    if(!Outer.TraceAllPhysicsAssetInteractions(P.Mesh, EndTrace, StartTrace, ImpactList, vect(0, 0, 0), true))
    {
        EndTrace = P.Mesh.GetBoneLocation(Class'KFPawn'.default.TorsoBoneName);
        if(IsZero(EndTrace))
        {
            EndTrace = P.Location;
        }
        Outer.TraceAllPhysicsAssetInteractions(P.Mesh, EndTrace, StartTrace, ImpactList, vect(0, 0, 0), true);
    }
    if(ImpactList.Length > 0)
    {
        out_Impact = ImpactList[0];
        return true;
    }
    return false;
}

// Export UKFMeleeHelperBase::execTickHitboxCollisionDetection(FFrame&, void* const)
native function TickHitboxCollisionDetection(SkeletalMeshComponent SkelComp, float DeltaTime);

// Export UKFMeleeHelperBase::execBeginHitboxCollisionDetection(FFrame&, void* const)
native function BeginHitboxCollisionDetection(SkeletalMeshComponent SkelComp);

// Export UKFMeleeHelperBase::execCreateHitboxChain(FFrame&, void* const)
native function CreateHitboxChain(SkeletalMeshComponent SkelComp);

// Export UKFMeleeHelperBase::execHasCollidedWithHitbox(FFrame&, void* const)
native function bool HasCollidedWithHitbox(Actor A);

event ProcessHitboxCollision(Actor HitActor, Vector StartTrace, Vector EndTrace, Vector HitLocation, Vector HitNormal, const out TraceHitInfo HitInfo, optional out ImpactInfo Impact)
{
    if(HitActor == none)
    {
        return;
    }
    Impact.HitActor = HitActor;
    Impact.HitLocation = HitLocation;
    Impact.HitNormal = HitNormal;
    Impact.RayDir = Normal(EndTrace - StartTrace);
    Impact.StartTrace = StartTrace;
    Impact.HitInfo = HitInfo;
    if(bLogMelee)
    {
        LogInternal(((string(GetFuncName()) @ string(HitActor)) @ string(HitInfo.Item)) @ string(HitInfo.BoneName));
    }
}

event InitWorldTraceForHitboxCollision();

simulated function PlayMeleeHitEffects(Actor Target, Vector HitLocation, Vector HitDirection, optional bool bShakeInstigatorCamera)
{
    local Pawn Victim;
    local PlayerController PC;

    bShakeInstigatorCamera = true;
    if(Target.IsA('Pawn'))
    {
        Victim = Pawn(Target);
        if((Victim != none) && Victim.Controller != none)
        {
            PC = PlayerController(Victim.Controller);
            if(PC != none)
            {
                PC.ClientPlayCameraShake(MeleeVictimCamShake, 1, true);
            }
        }
    }
}

defaultproperties
{
    MaxHitRange=150
    DefaultFOVCosine=0.6
    HitboxSpacing=30
    HitboxBoneName=RW_Damage
    HitboxBoneAxis=EAxis.AXIS_Z
    bDoHitboxObstructionTrace=true
    bAllowMeleeToFracture=true
    begin object name=MeleeImpactCamShake0 class=CameraShake
        OscillationDuration=0.35
        RotOscillation=(Pitch=(Amplitude=250,Frequency=60),Yaw=(Amplitude=150,Frequency=70),Roll=(Amplitude=150,Frequency=100))
    object end
    // Reference: CameraShake'Default__KFMeleeHelperBase.MeleeImpactCamShake0'
    MeleeVictimCamShake=MeleeImpactCamShake0
    MeleeImpactCamShake=KFCameraShake'FX_CameraShake_Arch.Melee.Default_Melee'
}