/*******************************************************************************
 * KFPowerUp generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPowerUp extends ReplicationInfo
    hidecategories(Navigation,Movement,Collision);

var const localized string PowerUpName;
var float PowerUpDuration;
var transient float RemainingDuration;
var bool bPowerUpActive;
var bool CanBeHealedWhilePowerUpIsActive;
var class<KFDamageType> SecondaryDamageType;
var int SecondaryDamage;
var KFPlayerController OwnerPC;
var KFPawn_Human OwnerPawn;
var name ScreenMaterialName;
var class<EmitterCameraLensEffectBase> CameraLensEffectTemplate;
var ParticleSystem PowerUpEffect;
var AkEvent AudioLoopFirstPerson;
var AkEvent AudioLoopThirdPerson;
var AkEvent AudioLoopThirdPersonStop;
var AkEvent AudioLoopFirstPersonStop;

function ActivatePowerUp()
{
    if(Role == ROLE_Authority)
    {
        RemainingDuration = PowerUpDuration;
        bPowerUpActive = true;
        OwnerPawn.UpdateGroundSpeed();
        OwnerPawn.SetPowerUpAmbientSound(AudioLoopThirdPerson, AudioLoopFirstPerson);
        SetTimer(0.05, false, 'PlayPowerUp');
    }
}

function ReactivatePowerUp()
{
    if(((Role == ROLE_Authority) && bPowerUpActive) && RemainingDuration > float(0))
    {
        RemainingDuration = PowerUpDuration;
        OwnerPawn.UpdateGroundSpeed();
        OwnerPawn.StopPowerUp(Class);
        SetTimer(0.05, false, 'PlayPowerUp');
    }
}

function PlayPowerUp()
{
    OwnerPawn.PlayPowerUp(Class);
}

function DeactivatePowerUp()
{
    if(Role == ROLE_Authority)
    {
        bPowerUpActive = false;
        RemainingDuration = 0;
        if(OwnerPC != none)
        {
            OwnerPawn.StopPowerUp(Class);
            OwnerPawn.SetPowerUpAmbientSound(none, none, AudioLoopThirdPersonStop, AudioLoopFirstPersonStop);
            OwnerPC.CurrentPowerUp = none;
            OwnerPC.CurrentPowerUpClass = none;
            OwnerPC.ClientUpdatePowerUp(none);
        }
        OwnerPawn.UpdateGroundSpeed();
        self.Destroy();
    }
}

simulated function ModifySpeed(out float Speed);

simulated function ModifySprintSpeed(out float Speed)
{
    ModifySpeed(Speed);
}

function FinalizeSpeedVariables();

function ModifyDamageGiven(out int InDamage, optional Actor DamageCauser, optional KFPawn_Monster MyKFPM, optional KFPlayerController DamageInstigator, optional class<KFDamageType> DamageType, optional int HitZoneIdx);

function ModifyDamageTaken(out int InDamage, optional class<DamageType> DamageType, optional Controller InstigatedBy);

function ApplySecondaryDamage(KFPawn Victim, int DamageTaken, optional Controller InstigatedBy);

function bool CanBeHealed()
{
    return CanBeHealedWhilePowerUpIsActive;
}

static function PlayEffects(KFPawn_Human P)
{
    local editinline ParticleSystemComponent ParticleEffect;

    if(default.PowerUpEffect != none)
    {
        ParticleEffect = P.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(default.PowerUpEffect, P.Mesh, 'hips', false);
        P.CurrentPowerUpEffect.PowerUpType = default.Class;
        P.CurrentPowerUpEffect.ParticleEffect = ParticleEffect;
    }
}

simulated event Tick(float DeltaTime)
{
    if(Role == ROLE_Authority)
    {
        if(bPowerUpActive)
        {
            RemainingDuration -= DeltaTime;
            if(RemainingDuration <= float(0))
            {
                DeactivatePowerUp();
            }
        }
    }
}

event Destroyed()
{
    if(bPowerUpActive)
    {
        DeactivatePowerUp();
    }
    super(Actor).Destroyed();
}

simulated function PlayerDied()
{
    DeactivatePowerUp();
}

defaultproperties
{
    PowerUpDuration=0.5
    CanBeHealedWhilePowerUpIsActive=true
    bOnlyRelevantToOwner=true
    NetUpdateFrequency=1
}