/*******************************************************************************
 * KFSpawner generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSpawner extends Actor
    native
    placeable
    hidecategories(Navigation);

enum EEmergeAnim
{
    EMERGE_Floor,
    EMERGE_Wall248UU,
    EMERGE_WallHigh,
    EMERGE_Ceiling,
    EMERGE_None,
    EMERGE_MAX
};

/**  
 *Set to true if we're activating this from kismet. Set this to false if it is acting as a child spawner.
 *       This way any variables that the spawn will inherit from the parent will be greyed out
 */
var() bool bIsTriggeredSpawner;
/** If set, yaw is randomized (useful for floor spawners) */
var() bool bRandomizeSpawnYawRot;
var transient bool bRequiredZedAmountTouching;
var bool bIsActive;
var bool bIsSpawning;
var bool bDebugSpawning;
var transient bool bIgnoreChildren;
/** Largest type of squad that fits in this spawner */
var() KFSpawnVolume.ESquadType LargestSquadType<EditCondition=bIsTriggeredSpawner>;
var transient byte LastAnimDirection;
/** Animation to play when exiting the spawner */
var() KFSpawner.EEmergeAnim EmergeAnim;
/** If > 0, automatically deactivate this spawner after some time */
var() float MaxStayActiveTime<EditCondition=bIsTriggeredSpawner>;
/** Minimum time before getting re-activated */
var() float CoolDownTime<EditCondition=bIsTriggeredSpawner>;
/** Time between individual spawns within a squad */
var() float SpawnInterval<EditCondition=bIsTriggeredSpawner>;
var transient int LastSpawnYawRot;
/** If set, this spawner will auto-deactivate if this actor (e.g. Trigger, TriggerVolume) is not touching any players */
var() Actor ActorToReacquirePlayerTouch<EditCondition=bIsTriggeredSpawner>;
/** If > 0, players must be touching the trigger for some amount of time before it can be used */
var() float MinReacquireTouchTime<EditCondition=bIsTriggeredSpawner>;
var transient float ReacquireTouchTimeLeft;
/** Number of zeds required to be touching the ActorToReacquirePlayerTouch for this spawning to be active */
var() int NumTouchingZedsRequired<EditCondition=bIsTriggeredSpawner>;
/** Additional spawn points for pending zeds when this spawner is active */
var() array<KFSpawner> ChildSpawners;
var transient array< class<KFPawn_Monster> > PendingSpawns;
var protected transient float LastActivationTime;
var protected transient float LastSpawnTime;
/** Reference to destructible object that we want to smash through */
var() KFDestructibleActor DestructibleToBreak;

function OnToggle(SeqAct_Toggle Action)
{
    if(Action.InputLinks[0].bHasImpulse || Action.InputLinks[2].bHasImpulse && !bIsActive)
    {
        ActivateSpawner();        
    }
    else
    {
        DeactivateSpawner();
    }
}

function ActivateSpawner()
{
    local KFGameInfo KFGI;

    if(!bIsActive)
    {
        if((MinReacquireTouchTime > float(0)) && ActorToReacquirePlayerTouch != none)
        {
            ReacquireTouchTimeLeft = MinReacquireTouchTime;
            SetTimer(1, true, 'ReacquirePlayerTouch');
        }
        if((NumTouchingZedsRequired > 0) && ActorToReacquirePlayerTouch != none)
        {
            SetTimer(1, true, 'ReacquireZedTouch');
        }
    }
    bIsActive = true;
    LastActivationTime = WorldInfo.TimeSeconds;
    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && KFGI.SpawnManager != none)
    {
        KFGI.SpawnManager.ActiveSpawner = self;
    }
}

function DeactivateSpawner()
{
    bIsActive = false;
    LastActivationTime = -1;
    ClearTimer('ReacquirePlayerTouch');
    ClearTimer('ReacquireZedTouch');
}

function bool CanSpawnHere(KFSpawnVolume.ESquadType DesiredSquadType)
{
    if(!bIsActive)
    {
        return false;
    }
    if(DesiredSquadType < LargestSquadType)
    {
        return false;
    }
    if((MaxStayActiveTime > float(0)) && (WorldInfo.TimeSeconds - LastActivationTime) > MaxStayActiveTime)
    {
        return false;
    }
    if(((CoolDownTime > float(0)) && LastSpawnTime > float(0)) && (WorldInfo.TimeSeconds - LastSpawnTime) < CoolDownTime)
    {
        return false;
    }
    if(ReacquireTouchTimeLeft > 0)
    {
        return false;
    }
    if(PendingSpawns.Length > 0)
    {
        return false;
    }
    if(((ActorToReacquirePlayerTouch != none) && NumTouchingZedsRequired > 0) && bRequiredZedAmountTouching == false)
    {
        return false;
    }
    return true;
}

function ReacquirePlayerTouch()
{
    local Pawn P;
    local bool bHasAlivePlayers;

    foreach ActorToReacquirePlayerTouch.TouchingActors(Class'Pawn', P)
    {
        if((P.Controller != none) && P.IsAliveAndWell())
        {
            if(P.GetTeamNum() == 0)
            {
                bHasAlivePlayers = true;
            }
        }        
    }    
    if(!bHasAlivePlayers)
    {
        if(bDebugSpawning)
        {
            LogInternal(string(self) @ "ReacquirePlayerTouch is auto-deactivating this spawner");
        }
        ClearTimer('ReacquirePlayerTouch');
        DeactivateSpawner();
    }
    ReacquireTouchTimeLeft -= 1;
    if(ReacquireTouchTimeLeft <= 0)
    {
        if(bDebugSpawning)
        {
            LogInternal(string(self) @ "ReacquirePlayerTouch completed successfully");
        }
        ClearTimer('ReacquirePlayerTouch');
    }
}

function ReacquireZedTouch()
{
    local Pawn P;
    local int NumAliveZedsTouching;

    if(!bIsActive)
    {
        return;
    }
    foreach ActorToReacquirePlayerTouch.TouchingActors(Class'Pawn', P)
    {
        if((P.Controller != none) && P.IsAliveAndWell())
        {
            if(P.GetTeamNum() != 0)
            {
                ++ NumAliveZedsTouching;
            }
        }        
    }    
    if(bDebugSpawning)
    {
        LogInternal("NumAliveZedsTouching = " $ string(NumAliveZedsTouching));
    }
    if(NumAliveZedsTouching >= NumTouchingZedsRequired)
    {
        bRequiredZedAmountTouching = true;        
    }
    else
    {
        bRequiredZedAmountTouching = false;
    }
}

function int SpawnSquad(out array< class<KFPawn_Monster> > SpawnList)
{
    if(SpawnList.Length == 0)
    {
        return 0;
    }
    AddPendingSpawns(SpawnList);
    LastSpawnTime = WorldInfo.TimeSeconds;
    bIsSpawning = PendingSpawns.Length > 0;
    return PendingSpawns.Length;
}

function AddPendingSpawns(out array< class<KFPawn_Monster> > SpawnList)
{
    local int I;
    local KFSpecialMoveHandler SMH;

    if((EmergeAnim == 4) && ChildSpawners.Length == 0)
    {
        PendingSpawns = SpawnList;
        SpawnList.Length = 0;
        return;
    }
    I = SpawnList.Length - 1;
    J0x5E:

    if(I >= 0)
    {
        SMH = SpawnList[I].default.SpecialMoveHandler;
        if((11 < SMH.SpecialMoveClasses.Length) && SMH.SpecialMoveClasses[11] != none)
        {
            PendingSpawns.AddItem(SpawnList[I];
            SpawnList.Remove(I, 1;
        }
        -- I;
        goto J0x5E;
    }
}

event HandleSpawn(KFPawn NewSpawn, int SlotIdx)
{
    local KFGameInfo KFGI;

    if((DestructibleToBreak != none) && !DestructibleToBreak.bShutDown)
    {
        DestructibleToBreak.TakeRadiusDamage(NewSpawn.Controller, 10000, 0, Class'DmgType_Crushed', 0, Location, true, self);
    }
    if(EmergeAnim != 4)
    {
        NewSpawn.DoSpecialMove(11,,, Class'KFSM_Emerge'.static.PackAnimFlag(EmergeAnim, LastAnimDirection));
        if(!NewSpawn.IsDoingSpecialMove(11))
        {
            WarnInternal("SM_Emerge failed for" @ string(NewSpawn));
            NewSpawn.Died(none, WorldInfo.KillZDamageType, Location);
            HandleFailedSpawn();
        }
    }
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.RefreshMonsterAliveCount();
    }
}

event HandleFailedSpawn()
{
    local KFGameInfo KFGI;

    WarnInternal((string(self) @ string(PendingSpawns.Length)) $ " zeds failed to spawn at this portal spawn!!!");
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        if(bDebugSpawning)
        {
            LogInternal(((((string(self) @ string(GetFuncName())) $ " removing ") $ string(PendingSpawns.Length)) $ " from NumAISpawnsQueued due to failed spawn. NumAISpawnsQueued: ") $ string(KFGI.NumAISpawnsQueued));
        }
        KFGI.NumAISpawnsQueued -= PendingSpawns.Length;
    }
    if(bDebugSpawning)
    {
        if((KFGI != none) && KFGI.SpawnManager != none)
        {
            KFGI.SpawnManager.ActiveSpawner = self;
            if(bDebugSpawning)
            {
                KFGI.SpawnManager.LogMonsterList(PendingSpawns, "Failed Pending Spawns For " $ string(self));
            }
        }
    }
    PendingSpawns.Length = 0;
}

function bool TestSpawn(class<KFPawn_Monster> SpawnClass, optional int NumSpawns, optional bool bImmediate)
{
    local array< class<KFPawn_Monster> > TestSpawnList;

    NumSpawns = 1;    
    J0x06:

    if(NumSpawns > 0)
    {
        TestSpawnList.AddItem(SpawnClass;
        -- NumSpawns;
        goto J0x06;
    }
    SpawnSquad(TestSpawnList);
    if(bImmediate)
    {
        LastSpawnTime -= SpawnInterval;
    }
    return bIsSpawning;
}

defaultproperties
{
    bIsTriggeredSpawner=true
    LargestSquadType=ESquadType.EST_Medium
    LastAnimDirection=255
    CoolDownTime=20
    SpawnInterval=0.5
    LastSpawnYawRot=-1
    begin object name=PreviewMesh class=StaticMeshComponent
        StaticMesh=StaticMesh'ZED_Clot_MESH.ZED_Clot'
        ReplacementPrimitive=none
        HiddenGame=true
        Rotation=(Pitch=0,Yaw=-16384,Roll=0)
    object end
    // Reference: StaticMeshComponent'Default__KFSpawner.PreviewMesh'
    Components(0)=PreviewMesh
    CollisionType=ECollisionType.COLLIDE_CustomDefault
}