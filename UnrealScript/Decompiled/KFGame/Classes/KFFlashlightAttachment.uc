/*******************************************************************************
 * KFFlashlightAttachment generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFFlashlightAttachment extends Object
    native(Effect)
    hidecategories(Object);

var export editinline transient SkeletalMeshComponent OwnerMesh;
var transient bool bEnabled;
var transient bool bLightInitialized;
/** Spot Light */
var() export editinline SpotLightComponent LightTemplate;
var export editinline transient SpotLightComponent Light;
/** Light Cone Mesh */
var() StaticMesh LightConeMesh;
var export editinline StaticMeshComponent LightConeMeshComp;
/** Mesh attachment (always visible) */
var() StaticMesh AttachmentMesh;
var export editinline transient StaticMeshComponent AttachmentMeshComp;
/** Socket name to attach the flashlight to */
var() name FlashlightSocketName;

function AttachFlashlight(SkeletalMeshComponent Mesh, optional name SocketNameOverride)
{
    if((OwnerMesh != none) && OwnerMesh != Mesh)
    {
        return;
    }
    OwnerMesh = Mesh;
    if(SocketNameOverride != 'None')
    {
        FlashlightSocketName = SocketNameOverride;
    }
    if(AttachmentMesh != none)
    {
        if(AttachmentMeshComp == none)
        {
            AttachmentMeshComp = new (self) Class'StaticMeshComponent';
            AttachmentMeshComp.CastShadow = false;
            AttachmentMeshComp.SetStaticMesh(AttachmentMesh);            
        }
        else
        {
            Mesh.DetachComponent(AttachmentMeshComp);
        }
        AttachFlashlightComponent(Mesh, AttachmentMeshComp);
        if(IsOwnerFirstPerson())
        {
            SetFirstPersonVisibility(true);
        }
    }
    SetLightingChannels(Mesh.LightingChannels);
}

function DetachFlashlight()
{
    if(Light != none)
    {
        Light.DetachFromAny();
    }
    if(LightConeMeshComp != none)
    {
        LightConeMeshComp.DetachFromAny();
    }
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.DetachFromAny();
    }
}

function SetEnabled(bool bNewEnabled)
{
    if(bNewEnabled && !bLightInitialized)
    {
        InitializeLight();
    }
    if(Light != none)
    {
        Light.super(KFFlashlightAttachment).SetEnabled(bNewEnabled);
    }
    if(LightConeMeshComp != none)
    {
        LightConeMeshComp.SetHidden(!bNewEnabled || IsOwnerFirstPerson());
    }
    bEnabled = bNewEnabled;
}

private final function InitializeLight()
{
    if(OwnerMesh == none)
    {
        LogInternal("Invalid mesh for flashlight" @ string(self));
        return;
    }
    if((Light == none) && LightTemplate != none)
    {
        Light = new (self) Class'SpotLightComponent' (LightTemplate);
        AttachFlashlightComponent(OwnerMesh, Light);
    }
    if(LightConeMesh != none)
    {
        LightConeMeshComp.SetStaticMesh(LightConeMesh);
        AttachFlashlightComponent(OwnerMesh, LightConeMeshComp);
    }
    bLightInitialized = true;
    if(IsOwnerFirstPerson())
    {
        SetFirstPersonVisibility(true);
    }
}

private final function AttachFlashlightComponent(SkeletalMeshComponent ParentMesh, ActorComponent Attachment)
{
    ParentMesh.AttachComponentToSocket(Attachment, FlashlightSocketName);
}

private final function bool IsOwnerFirstPerson()
{
    local Pawn P;

    P = Pawn(OwnerMesh.Outer);
    return ((P != none) ? P.IsFirstPerson() : false);
}

simulated function OwnerDied()
{
    if(bEnabled)
    {
        SetEnabled(false);
    }
    if(Light != none)
    {
        Light.DetachFromAny();
    }
}

simulated function SetFirstPersonVisibility(bool bFirstPerson)
{
    local KFPawn P;

    if(bLightInitialized)
    {
        P = KFPawn(OwnerMesh.Outer);
        if((Light != none) && P != none)
        {
            if(bFirstPerson)
            {
                if(((P.Controller != none) && PlayerController(P.Controller) != none) && PlayerController(P.Controller).PlayerCamera != none)
                {
                    PlayerController(P.Controller).PlayerCamera.AttachComponent(Light);
                }                
            }
            else
            {
                AttachFlashlightComponent(P.Mesh, Light);
            }
        }
        if(LightConeMeshComp != none)
        {
            LightConeMeshComp.SetHidden(!bEnabled || bFirstPerson);
        }
    }
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.SetHidden(bFirstPerson);
    }
}

simulated function SetLightingChannels(const out LightingChannelContainer NewLightingChannels)
{
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.super(KFFlashlightAttachment).SetLightingChannels(NewLightingChannels);
    }
}

defaultproperties
{
    begin object name=FlashLightTemplate class=SpotLightComponent
        InnerConeAngle=20
        OuterConeAngle=30
        Radius=3000
        Brightness=2
        Function=LightFunction'Default__KFFlashlightAttachment.FlashLightFunction'
        bEnabled=false
        CastStaticShadows=false
        ForceCastDynamicShadows=true
        bUpdateOwnerRenderTime=true
        LightingChannels=(Outdoor=true)
    object end
    // Reference: SpotLightComponent'Default__KFFlashlightAttachment.FlashLightTemplate'
    LightTemplate=FlashLightTemplate
    begin object name=LightConeComp class=StaticMeshComponent
        ReplacementPrimitive=none
        CastShadow=false
    object end
    // Reference: StaticMeshComponent'Default__KFFlashlightAttachment.LightConeComp'
    LightConeMeshComp=LightConeComp
    FlashlightSocketName=FlashLight
}