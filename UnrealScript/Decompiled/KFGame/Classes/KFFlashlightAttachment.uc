/*******************************************************************************
 * KFFlashlightAttachment generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFFlashlightAttachment extends Object
    native(Effect)
    hidecategories(Object);

var protected export editinline transient SkeletalMeshComponent OwnerMesh;
var protected transient bool bEnabled;
var protected transient bool bLightInitialized;
var bool bDebug;
/** Spot Light */
var() export editinline SpotLightComponent LightTemplate;
var() export editinline transient SpotLightComponent Light;
/** Light Cone Mesh */
var() StaticMesh LightConeMesh;
var export editinline StaticMeshComponent LightConeMeshComp;
/** Mesh attachment (always visible) */
var() StaticMesh AttachmentMesh;
var export editinline transient StaticMeshComponent AttachmentMeshComp;
/** Socket name to attach the flashlight to */
var() name FlashlightSocketName;
var float TeammateSwitchRadius;
var float TeammateSwitchTimer;
var protected const float MaxAIWarningDistSQ;
var protected const float MaxAIWarningDistFromPointSQ;

function AttachFlashlight(SkeletalMeshComponent Mesh, optional name SocketNameOverride)
{
    if((OwnerMesh != none) && OwnerMesh != Mesh)
    {
        return;
    }
    OwnerMesh = Mesh;
    if(SocketNameOverride != 'None')
    {
        FlashlightSocketName = SocketNameOverride;
    }
    if(AttachmentMesh != none)
    {
        if(AttachmentMeshComp == none)
        {
            AttachmentMeshComp = new (self) Class'StaticMeshComponent';
            AttachmentMeshComp.CastShadow = false;
            AttachmentMeshComp.SetStaticMesh(AttachmentMesh);            
        }
        else
        {
            Mesh.DetachComponent(AttachmentMeshComp);
        }
        AttachFlashlightComponent(Mesh, AttachmentMeshComp);
        if(IsOwnerFirstPerson())
        {
            SetFirstPersonVisibility(true);
        }
    }
    SetLightingChannels(Mesh.LightingChannels);
}

function Reattach()
{
    if((AttachmentMeshComp != none) && !AttachmentMeshComp.bAttached)
    {
        OwnerMesh.DetachComponent(AttachmentMeshComp);
        AttachFlashlightComponent(OwnerMesh, AttachmentMeshComp);
    }
}

function DetachFlashlight()
{
    if(Light != none)
    {
        Light.DetachFromAny();
    }
    if(LightConeMeshComp != none)
    {
        LightConeMeshComp.DetachFromAny();
    }
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.DetachFromAny();
    }
}

protected function SetEnabled(bool bNewEnabled)
{
    if(bNewEnabled && !bLightInitialized)
    {
        InitializeLight();
    }
    if(Light != none)
    {
        Light.super(KFFlashlightAttachment).SetEnabled(bNewEnabled);
    }
    if(LightConeMeshComp != none)
    {
        LightConeMeshComp.SetHidden(!bNewEnabled || IsOwnerFirstPerson());
    }
    bEnabled = bNewEnabled;
    if((OwnerMesh.Outer != none) && Class'WorldInfo'.static.GetWorldInfo().NetMode != NM_Client)
    {
        if(bEnabled)
        {
            Timer_WarnAI();
            Actor(OwnerMesh.Outer).SetTimer(1, true, 'Timer_WarnAI', self);            
        }
        else
        {
            Actor(OwnerMesh.Outer).ClearTimer('Timer_WarnAI', self);
        }
    }
    if(bDebug)
    {
        LogInternal((("Turning flashlight" @ string(bNewEnabled)) @ "for teammate:") @ string(OwnerMesh.Outer));
    }
}

function Timer_WarnAI()
{
    local Pawn Instigator, P;
    local KFWeapon OwnerWeapon;
    local KFPawn_Monster HitMonster;
    local Vector Direction, Projection, DangerPoint;

    Instigator = Pawn(OwnerMesh.Outer);
    if(Instigator == none)
    {
        return;
    }
    OwnerWeapon = KFWeapon(Instigator.Weapon);
    if((OwnerWeapon != none) && OwnerWeapon.IsWarningAI())
    {
        return;
    }
    Direction = vector(Instigator.GetBaseAimRotation());
    foreach Instigator.WorldInfo.AllPawns(Class'Pawn', P)
    {
        if(((P.GetTeamNum() != Instigator.GetTeamNum()) && !P.IsHumanControlled()) && P.IsAliveAndWell())
        {
            Projection = P.Location - Instigator.Location;
            if(VSizeSq(Projection) < MaxAIWarningDistSQ)
            {
                PointDistToLine(P.Location, Direction, Instigator.Location, DangerPoint);
                if(VSizeSq(DangerPoint - P.Location) < MaxAIWarningDistFromPointSQ)
                {
                    HitMonster = KFPawn_Monster(P);
                    if((HitMonster != none) && HitMonster.MyKFAIC != none)
                    {
                        HitMonster.MyKFAIC.ReceiveLocationalWarning(DangerPoint, Instigator.Location, self);
                    }
                }
            }
        }        
    }    
}

protected function InitializeLight()
{
    if(OwnerMesh == none)
    {
        LogInternal("Invalid mesh for flashlight" @ string(self));
        return;
    }
    if((Light == none) && LightTemplate != none)
    {
        Light = new (self) Class'SpotLightComponent' (LightTemplate);
        AttachFlashlightComponent(OwnerMesh, Light);
    }
    if(LightConeMesh != none)
    {
        LightConeMeshComp.SetStaticMesh(LightConeMesh);
        AttachFlashlightComponent(OwnerMesh, LightConeMeshComp);
    }
    bLightInitialized = true;
    if(IsOwnerFirstPerson())
    {
        SetFirstPersonVisibility(true);
    }
}

private final function AttachFlashlightComponent(SkeletalMeshComponent ParentMesh, ActorComponent Attachment)
{
    ParentMesh.AttachComponentToSocket(Attachment, FlashlightSocketName);
}

simulated function OwnerDied()
{
    if(bEnabled)
    {
        SetEnabled(false);
    }
    if(Light != none)
    {
        Light.DetachFromAny();
    }
}

simulated function SetLightingChannels(const out LightingChannelContainer NewLightingChannels)
{
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.super(KFFlashlightAttachment).SetLightingChannels(NewLightingChannels);
    }
}

private final function bool IsOwnerFirstPerson()
{
    local Pawn P;

    P = Pawn(OwnerMesh.Outer);
    return ((P != none) ? P.IsFirstPerson() : false);
}

simulated function SetFirstPersonVisibility(bool bFirstPerson)
{
    local KFPawn P;

    if(bLightInitialized)
    {
        P = KFPawn(OwnerMesh.Outer);
        if((Light != none) && P != none)
        {
            if(bFirstPerson)
            {
                if(((P.Controller != none) && PlayerController(P.Controller) != none) && PlayerController(P.Controller).PlayerCamera != none)
                {
                    PlayerController(P.Controller).PlayerCamera.AttachComponent(Light);
                }                
            }
            else
            {
                AttachFlashlightComponent(P.Mesh, Light);
            }
        }
        if(LightConeMeshComp != none)
        {
            LightConeMeshComp.SetHidden(!bEnabled || bFirstPerson);
        }
    }
    if(AttachmentMeshComp != none)
    {
        AttachmentMeshComp.SetHidden(bFirstPerson);
    }
}

simulated function UpdateFlashlightFor(KFPawn_Human inPawn)
{
    local PlayerController PC;
    local KFPawn_Human P;

    if(!inPawn.bFlashlightOn)
    {
        if(inPawn.FlashLight.bEnabled)
        {
            inPawn.FlashLight.SetEnabled(false);
            ChooseBestFlashlight();
        }        
    }
    else
    {
        PC = Class'WorldInfo'.static.GetWorldInfo().GetALocalPlayerController();
        if(PC == none)
        {
            return;
        }
        if(PC.ViewTarget == inPawn)
        {
            foreach PC.WorldInfo.AllPawns(Class'KFPawn_Human', P)
            {
                if(P.FlashLight.bEnabled)
                {
                    P.FlashLight.SetEnabled(false);
                }                
            }            
            inPawn.FlashLight.SetEnabled(true);            
        }
        else
        {
            if(!PC.IsTimerActive('ChooseBestFlashlightTimer', self))
            {
                ChooseBestFlashlight();
                PC.SetTimer(TeammateSwitchTimer, true, 'ChooseBestFlashlightTimer', self);                
            }
        }
    }
}

simulated function ChooseBestFlashlightTimer()
{
    ChooseBestFlashlight();
}

simulated function ChooseBestFlashlight()
{
    local PlayerController PC;
    local KFPawn_Human P, BestPawn;
    local array<KFPawn_Human> DisableList;
    local float BestDistSq, DistSq, TeammateSwitchRadiusSq;
    local int I;

    TeammateSwitchRadiusSq = Square(TeammateSwitchRadius);
    PC = Class'WorldInfo'.static.GetWorldInfo().GetALocalPlayerController();
    foreach PC.WorldInfo.AllPawns(Class'KFPawn_Human', P)
    {
        if(!P.bFlashlightOn || !P.IsAliveAndWell())
        {
            continue;            
        }
        DistSq = VSizeSq(P.Location - PC.ViewTarget.Location);
        if(P.FlashLight.bEnabled)
        {
            if(PC.ViewTarget == P)
            {
                if(bDebug)
                {
                    LogInternal("Flashlight staying on for view target");
                }                
                return;                
            }
            else
            {
                if(DistSq < TeammateSwitchRadiusSq)
                {
                    if(bDebug)
                    {
                        LogInternal("Flashlight staying on for" @ string(P));
                    }                    
                    return;
                }
            }
            DisableList.AddItem(P;
        }
        if((BestPawn == none) || DistSq < BestDistSq)
        {
            BestPawn = P;
            BestDistSq = DistSq;
        }        
    }    
    if(BestPawn == none)
    {
        PC.ClearTimer('ChooseBestFlashlightTimer', self);        
    }
    else
    {
        if((BestPawn != none) && !BestPawn.FlashLight.bEnabled)
        {
            BestPawn.FlashLight.SetEnabled(true);
            I = 0;
            J0x369:

            if(I < DisableList.Length)
            {
                DisableList[I].FlashLight.SetEnabled(false);
                ++ I;
                goto J0x369;
            }
        }
    }
}

defaultproperties
{
    begin object name=FlashLightTemplate class=SpotLightComponent
        InnerConeAngle=5
        OuterConeAngle=20
        Radius=3000
        Brightness=0.5
        Function=LightFunction'Default__KFFlashlightAttachment.FlashLightFunction'
        bEnabled=false
        CastShadows=false
        CastStaticShadows=false
        CastDynamicShadows=false
        bUpdateOwnerRenderTime=true
        LightingChannels=(Outdoor=true)
    object end
    // Reference: SpotLightComponent'Default__KFFlashlightAttachment.FlashLightTemplate'
    LightTemplate=FlashLightTemplate
    begin object name=LightConeComp class=StaticMeshComponent
        ReplacementPrimitive=none
        CastShadow=false
    object end
    // Reference: StaticMeshComponent'Default__KFFlashlightAttachment.LightConeComp'
    LightConeMeshComp=LightConeComp
    FlashlightSocketName=FlashLight
    TeammateSwitchRadius=1500
    TeammateSwitchTimer=10
    MaxAIWarningDistSQ=4000000
    MaxAIWarningDistFromPointSQ=16384
}