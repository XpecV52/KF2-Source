/*******************************************************************************
 * KFSpawnVolume generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSpawnVolume extends Volume
    native
    hidecategories(Navigation,Object,Movement,Display,Volume,Collision,Attachment,Physics,Mobile);

enum ESquadType
{
    EST_Boss,
    EST_Large,
    EST_Medium,
    EST_Small,
    EST_Crawler,
    EST_MAX
};

struct native SpawnMarkerInfo
{
    var float Radius;
    var float Height;
    var Vector Location;
    /** If true, will forcibly disable spawning for this spawn marker. It will still be visible, but will use a different icon */
    var() editconst bool bSpawnDisabled;
    var transient float LastUsedTime;
    var Color SpawnMarkerColor;

    structdefaultproperties
    {
        Radius=0
        Height=0
        Location=(X=0,Y=0,Z=0)
        bSpawnDisabled=false
        LastUsedTime=0
        SpawnMarkerColor=(B=50,G=205,R=50,A=255)
    }
};

struct native DoorListInfo
{
    /** Door actor to link to this volume. If all these doors are shut or welded this spawn volume is invalid */
    var() KFDoorActor DoorActor;
    /** If true, this door will only invalidate spawning if it is welded as opposed to just shut */
    var() bool bOnlyWhenWelded;

    structdefaultproperties
    {
        DoorActor=none
        bOnlyWhenWelded=true
    }
};

/** Spawn marker info created during the AI pathbuilding process and used in-game when determining AI spawn locations within this volume. */
var() editconst array<editconst SpawnMarkerInfo> SpawnMarkerInfoList;
/** maximum number of spawn markers that should be generated for this volume */
var() int MaxSpawnMarkers<ClampMin=1>;
/** Spawn marker info created during the AI pathbuilding process and used in-game when determining AI spawn locations within this volume. */
var() array<DoorListInfo> DoorList;
/** Rotation to use when spawning pawns from this volume */
var() Rotator SpawnRotation;
var Color DefaultSpawnMarkerColor;
var Color SpawnInteriorBoxColor;
var bool bNoCollisionFailForSpawn;
/** Whether this volume should more aggressively check its visibility against where the viewer is moving to */
var() bool bUsePredictiveVisibilityChecks;
var bool bDebugVisibilityChecks;
var bool bDebugRatingChecks;
var bool bMinimalDebugRatingChecks;
var bool bDebugSpawning;
/** If set, players cannot spawn here, only AI (Versus) */
var() bool bNoPlayers;
/** If true, no height-based rating penalty will be applied to this volume. This also overrides MaxHeightDifference. */
var() bool bNoZAxisDistPenalty;
/** If set, this volume never performs visibility checks */
var() bool bOutOfSight;
var deprecated bool bExclusiveBossVolumes;
/** Use for debugging to exclude this volume from being used */
var(Debug) bool bDisabled;
var BoxSphereBounds VisibilityBounds;
/** What percentage of the spawn volume's size will the inner spawn bounds be? */
var() Vector SpawnBoundsScale;
/** Largest type of squad that this volume is capable of spawning (checked vs SquadType in KFAISpawnSquad) */
var() KFSpawnVolume.ESquadType LargestSquadType;
/** Scales up (or reduces) base desireability to weight certain volumes differently if needed */
var() float DesirabilityMod<ClampMin=0.0|ClampMax=10.0>;
/** If height difference between volume and a player exceeds this value (UU), spawn rating will drop. */
var() float MaxHeightDiffToPlayers;
/** Volume will NOT be considered for spawning if, at wave-spawn time, any player is less than this many units away (from volume) */
var() float MinDistanceToPlayer;
/** Volume rating is partially scaled by its distance from players. Any player beyond this distance (UU) will receive no distance bonus at all, resulting in a lower volume rating. */
var() float MaxDistanceToPlayer;
/** How long this spawn volume is derated (gets a lower desireability) after it is spawned in */
var() float SpawnDerateTime;
var float TeleportDerateTime;
var protected transient float LastSpawnTime;
var protected transient float NextSpawnTime;
/** Time after a human pawn untouches it that it can be spawned in again */
var() float UnTouchCoolDownTime;
var protected transient float LastUnTouchTime;
var export editinline KFSpawnRenderingComponent DebugComponent;
var int VolumeChosenCount;

// Export UKFSpawnVolume::execSpawnWave(FFrame&, void* const)
native final function int SpawnWave(out array< class<KFPawn_Monster> > SpawnList, bool bAllOrNothing);

// Export UKFSpawnVolume::execFindTeleportLocation(FFrame&, void* const)
native final function Vector FindTeleportLocation(class<KFPawn_Monster> TeleportMonsterClass, optional int ForcedMarkerIdx)
{
    ForcedMarkerIdx = 0;                
}

// Export UKFSpawnVolume::execFindSpawnLocation(FFrame&, void* const)
native final function Vector FindSpawnLocation(class<KFPawn> SpawnPawnClass);

// Export UKFSpawnVolume::execScoreLocation(FFrame&, void* const)
native function float ScoreLocation(Controller ControllerToScoreAgainst, float BestRating, float BestPossibleRating);

// Export UKFSpawnVolume::execScoreDistanceFrom(FFrame&, void* const)
native function float ScoreDistanceFrom(Vector ViewLoc);

// Export UKFSpawnVolume::execIsVisibleFrom(FFrame&, void* const)
native function bool IsVisibleFrom(Vector ViewLoc);

// Export UKFSpawnVolume::execIsTouchingAlivePawn(FFrame&, void* const)
native function bool IsTouchingAlivePawn();

event UnTouch(Actor Other)
{
    local Pawn P;

    super(Actor).UnTouch(Other);
    if((Other != none) && !Other.bDeleteMe)
    {
        P = Pawn(Other);
        if((P != none) && P.IsHumanControlled())
        {
            LastUnTouchTime = WorldInfo.TimeSeconds;
        }
    }
}

function float RateVolume(KFSpawnVolume.ESquadType DesiredSquadType, Controller RateController, Controller OtherController, float BestRating, optional bool bTeleporting, optional float MinDistSquared)
{
    local float UsageRating, LocationRating, FinalRating;
    local string DebugText;
    local Vector TextOffset;
    local float BestPossibleRatingWithoutLocation;
    local int I;
    local float DistSquared;

    if(SpawnMarkerInfoList.Length == 0)
    {
        return -1;
    }
    if((bNoPlayers && OtherController != none) && OtherController.bIsPlayer)
    {
        return -1;
    }
    if((LastUnTouchTime > 0) && (WorldInfo.TimeSeconds - LastUnTouchTime) < UnTouchCoolDownTime)
    {
        if(bDebugRatingChecks)
        {
            LogInternal(((((("[" $ string(self)) $ "] rejected from spawning because LastUnTouchTime difference (") $ string(WorldInfo.TimeSeconds - LastUnTouchTime)) $ ") < UnTouchCoolDownTime (") $ string(UnTouchCoolDownTime)) $ "), returning a -1 rating");
        }
        return -1;
    }
    if(DesiredSquadType < LargestSquadType)
    {
        if(bDebugRatingChecks)
        {
            LogInternal(((((("[" $ string(self)) $ "] rejected from spawning because DesiredSquadType (") $ string(DesiredSquadType)) $ ") < LargestSquadType (") $ string(LargestSquadType)) $ "), returning a -1 rating");
        }
        return -1;
    }
    if(IsTouchingAlivePawn())
    {
        if(bDebugRatingChecks)
        {
            if(!bMinimalDebugRatingChecks)
            {
                DebugText = string(self) @ "FinalRating: -1 was touching a live pawn";
                GetALocalPlayerController().AddDebugText(DebugText, self, 20);
            }
        }
        return -1;
    }
    if(((MinDistSquared > float(0)) && RateController != none) && RateController.Pawn != none)
    {
        DistSquared = VSizeSq(Location - RateController.Pawn.Location);
        if(DistSquared > MinDistSquared)
        {
            if(bDebugRatingChecks)
            {
                LogInternal(((((("[" $ string(self)) $ "] rejected from spawning because DistSquared (") $ string(DistSquared)) $ ") > MinDistSquared (") $ string(MinDistSquared)) $ "), returning a -1 rating");
            }
            return -1;
        }
    }
    I = 0;
    J0x42E:

    if(I < DoorList.Length)
    {
        if((((DoorList[I].DoorActor != none) && !DoorList[I].DoorActor.bIsDoorOpen) && !DoorList[I].DoorActor.bIsDestroyed) && !DoorList[I].bOnlyWhenWelded || DoorList[I].DoorActor.WeldIntegrity > 0)
        {
            return -1;
        }
        ++ I;
        goto J0x42E;
    }
    UsageRating = 1;
    if((NextSpawnTime > 0) && NextSpawnTime > WorldInfo.TimeSeconds)
    {
        if(!bTeleporting)
        {
            UsageRating = FMin((SpawnDerateTime - (NextSpawnTime - WorldInfo.TimeSeconds)) / SpawnDerateTime, 1);
            if(bDebugRatingChecks && !bMinimalDebugRatingChecks || UsageRating < 1)
            {
                if(bDebugRatingChecks)
                {
                    LogInternal((((("[" $ string(self)) $ "] recently was spawned in ") $ string(SpawnDerateTime - (NextSpawnTime - WorldInfo.TimeSeconds))) $ " seconds ago, setting UsageRating to ") $ string(UsageRating));
                }
            }            
        }
        else
        {
            if((NextSpawnTime - WorldInfo.TimeSeconds) > TeleportDerateTime)
            {
                UsageRating = 1;
                if(bDebugRatingChecks && !bMinimalDebugRatingChecks)
                {
                    if(bDebugRatingChecks)
                    {
                        LogInternal((("[" $ string(self)) $ "] was not teleported in recently, setting UsageRating to ") $ string(UsageRating));
                    }
                }                
            }
            else
            {
                UsageRating = FMin((TeleportDerateTime - (NextSpawnTime - WorldInfo.TimeSeconds)) / TeleportDerateTime, 1);
                if(bDebugRatingChecks && !bMinimalDebugRatingChecks || UsageRating < 1)
                {
                    if(bDebugRatingChecks)
                    {
                        LogInternal((((("[" $ string(self)) $ "] recently was teleported in ") $ string(TeleportDerateTime - (NextSpawnTime - WorldInfo.TimeSeconds))) $ " seconds ago, setting UsageRating to ") $ string(UsageRating));
                    }
                }
            }
        }
    }
    BestPossibleRatingWithoutLocation = ((DesirabilityMod * 0.3) + (UsageRating * 0.3)) + (DesirabilityMod * 0.1);
    LocationRating = ScoreLocation(RateController, BestRating, BestPossibleRatingWithoutLocation);
    if(LocationRating < 0)
    {
        if(!bMinimalDebugRatingChecks)
        {
            if(bDebugRatingChecks)
            {
                LogInternal((((((string(self) $ " returning rating -1 --- Desirability:") $ string(DesirabilityMod)) $ ", LocationRating:") $ string(LocationRating)) $ ", UsageRating:") $ string(UsageRating));
            }
        }
        if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogSpawnVolumeRating(self, -1, UsageRating, LocationRating);
        }
        if(!bMinimalDebugRatingChecks)
        {
            DebugText = (((((string(self) @ "FinalRating: -1, DesirabilityMod:") $ string(DesirabilityMod)) $ ", LocationRating:") $ string(LocationRating)) $ ", UsageRating:") $ string(UsageRating);
            GetALocalPlayerController().AddDebugText(DebugText, self, 20);
        }
        return -1;
    }
    FinalRating = (((DesirabilityMod * 0.3) + (LocationRating * 0.3)) + (UsageRating * 0.3)) + (FRand() * (DesirabilityMod * 0.1));
    if(!bMinimalDebugRatingChecks || FinalRating > float(0))
    {
        if(bDebugRatingChecks)
        {
            LogInternal((((((((string(self) $ " returning rating ") $ string(FinalRating)) $ "--- Desirability:") $ string(DesirabilityMod)) $ ", LocationRating:") $ string(LocationRating)) $ ", UsageRating:") $ string(UsageRating));
        }
    }
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogSpawnVolumeRating(self, FinalRating, UsageRating, LocationRating);
    }
    if(bDebugRatingChecks)
    {
        if(!bMinimalDebugRatingChecks || (LocationRating > 0.25) && UsageRating > float(0))
        {
            DebugText = (((((((string(self) $ " FinalRating: ") $ string(FinalRating)) $ ", DesirabilityMod:") $ string(DesirabilityMod)) $ ", LocationRating:") $ string(LocationRating)) $ ", UsageRating:") $ string(UsageRating);
            TextOffset = (vect(0, 0, 1) * FRand()) * float(200);
            GetALocalPlayerController().AddDebugText(DebugText, self, 30, TextOffset);
        }
    }
    return FinalRating;
}

function SetLastSpawnTime(float NewSpawnTime)
{
    LastSpawnTime = NewSpawnTime;
    NextSpawnTime = WorldInfo.TimeSeconds + SpawnDerateTime;
}

function HandleTeleportedTo()
{
    LastSpawnTime = WorldInfo.TimeSeconds;
    NextSpawnTime = WorldInfo.TimeSeconds + TeleportDerateTime;
}

defaultproperties
{
    MaxSpawnMarkers=11
    DefaultSpawnMarkerColor=(B=50,G=205,R=50,A=255)
    SpawnInteriorBoxColor=(B=0,G=69,R=255,A=255)
    bMinimalDebugRatingChecks=true
    SpawnBoundsScale=(X=0.75,Y=0.75,Z=0.75)
    LargestSquadType=ESquadType.EST_Large
    DesirabilityMod=1
    MaxHeightDiffToPlayers=500
    MinDistanceToPlayer=1200
    MaxDistanceToPlayer=4000
    SpawnDerateTime=30
    TeleportDerateTime=10
    LastSpawnTime=-100
    UnTouchCoolDownTime=10
    begin object name=SpawnRenderer class=KFSpawnRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSpawnRenderingComponent'Default__KFSpawnVolume.SpawnRenderer'
    DebugComponent=SpawnRenderer
    bPawnsOnly=true
    BrushColor=(B=250,G=206,R=135,A=0)
    bColored=true
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__KFSpawnVolume.BrushComponent0'
    BrushComponent=BrushComponent0
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__KFSpawnVolume.BrushComponent0'
    Components(0)=BrushComponent0
    begin object name=SpawnRenderer class=KFSpawnRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSpawnRenderingComponent'Default__KFSpawnVolume.SpawnRenderer'
    Components(1)=SpawnRenderer
    bNoDelete=false
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__KFSpawnVolume.BrushComponent0'
    CollisionComponent=BrushComponent0
}