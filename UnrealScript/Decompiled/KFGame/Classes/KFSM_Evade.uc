/*******************************************************************************
 * KFSM_Evade generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_Evade extends KFSM_PlaySingleAnim;

enum EEvadeDir
{
    EVADE_None,
    EVADE_Forward,
    EVADE_Backward,
    EVADE_Left,
    EVADE_Right,
    EVADE_MAX
};

var array<AnimVariants> EvadeAnims;
var byte NumBodyVariants;

static function byte PackAnimFlag(byte EvadeDir)
{
    local byte Variant;

    Variant = byte(Rand(2));
    return byte(EvadeDir + (Variant << 4));
}

static function byte GetEvadeDirection(KFPawn CheckPawn, Vector EvadePoint, optional Pawn Attacker)
{
    local byte EvadeDir;
    local Vector X, Y, Z;

    EvadeDir = 255;
    if(((((Attacker != none) && Attacker.Health > 0) && CheckPawn.MyKFAIC != none) && CheckPawn.MyKFAIC.CanSee(Attacker)) && VSize(Attacker.Location - CheckPawn.Location) < 1024)
    {
        EvadeDir = Class'KFPawn'.static.CalcQuadRegion(CheckPawn.GetViewRotation(), CheckPawn.Location - Attacker.Location);
        if(((CheckPawn.MyKFAIC != none) && Attacker != none) && CheckPawn.MyKFAIC.PendingEvadeProjectile != none)
        {
            GetAxes(CheckPawn.Rotation, X, Y, Z);
            if((vector(Attacker.Rotation) Dot Y) > 0)
            {
                return 3;                
            }
            else
            {
                return 4;
            }
        }
    }
    switch(EvadeDir)
    {
        case 0:
            EvadeDir = 1;
            break;
        case 1:
            EvadeDir = 2;
            break;
        case 2:
            EvadeDir = 3;
            break;
        case 3:
            EvadeDir = 4;
            break;
        default:
            break;
    }
    return EvadeDir;
}

protected function bool InternalCanDoSpecialMove()
{
    return PawnOwner.Physics == 1;
}

function PlayAnimation()
{
    local byte Type, Variant;

    Type = byte(KFPOwner.SpecialMoveFlags & 15);
    Variant = byte(KFPOwner.SpecialMoveFlags >> 4);
    PlaySpecialMoveAnim(EvadeAnims[Type].Anims[Variant], 0, BlendInTime, BlendOutTime, 1);
    KFPOwner.SpecialMoveFlags = 255;
}

defaultproperties
{
    EvadeAnims(0)=(Anims=none)
    EvadeAnims(1)=(Anims=(Evade_F_V1,Evade_F_V2))
    EvadeAnims(2)=(Anims=(Evade_B_V1,Evade_B_V2))
    EvadeAnims(3)=(Anims=(Evade_L_V1,Evade_L_V2))
    EvadeAnims(4)=(Anims=(Evade_R_V1,Evade_R_V2))
    EvadeAnims(5)=(Anims=(Evade_FL_V1,Evade_FL_V2))
    EvadeAnims(6)=(Anims=(Evade_FR_V1,Evade_FR_V2))
    EvadeAnims(7)=(Anims=(Evade_BL_V1,Evade_BL_V2))
    EvadeAnims(8)=(Anims=(Evade_BR_V1,Evade_BR_V2))
    NumBodyVariants=2
    bUseRootMotion=true
    bDisablesWeaponFiring=true
    bPawnRotationLocked=true
    Handle=SM_Evade
}