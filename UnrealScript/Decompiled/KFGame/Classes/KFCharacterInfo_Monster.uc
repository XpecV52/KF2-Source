/*******************************************************************************
 * KFCharacterInfo_Monster generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFCharacterInfo_Monster extends KFCharacterInfoBase
    native(Pawn)
    hidecategories(Object);

struct native ZedColorMod
{
    var() LinearColor MainColor;
    var() LinearColor PatternColor;
    var() LinearColor TrimColor;

    structdefaultproperties
    {
        MainColor=(R=0,G=0,B=0,A=1)
        PatternColor=(R=0,G=0,B=0,A=1)
        TrimColor=(R=0,G=0,B=0,A=1)
    }
};

struct native StaticAttachments
{
    var() StaticMesh StaticAttachment;
    var() name AttachBoneName;
    var() Rotator RelativeRotation;

    structdefaultproperties
    {
        StaticAttachment=none
        AttachBoneName=None
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
    }
};

struct native DoorSoundFx
{
    var() AkEvent Metal;
    var() AkEvent Wood;

    structdefaultproperties
    {
        Metal=none
        Wood=none
    }
};

struct native MeleeSpecialDismembermentInfo
{
    /** Settings for special melee dismeberment such as being able to split a character in half */
    var() bool bAllowHorizontalSplit;
    /** Settings for special melee dismeberment such as being able to split a character in half */
    var() name SpineBoneName<EditCondition=bAllowHorizontalSplit>;
    /** Settings for special melee dismeberment such as being able to split a character in half */
    var() bool bAllowVerticalSplit;
    /** Settings for special melee dismeberment such as being able to split a character in half */
    var() name LeftShoulderBoneName<EditCondition=bAllowVerticalSplit>;
    /** Settings for special melee dismeberment such as being able to split a character in half */
    var() name RightShoulderBoneName<EditCondition=bAllowVerticalSplit>;

    structdefaultproperties
    {
        bAllowHorizontalSplit=false
        SpineBoneName=None
        bAllowVerticalSplit=false
        LeftShoulderBoneName=None
        RightShoulderBoneName=None
    }
};

/** Character mesh to use */
var(ThirdPerson) SkeletalMesh CharacterMesh<DisplayName=Body Mesh>;
/** Material overrides to use */
var(ThirdPerson) array<MaterialInterface> Skins;
/** Player-controlled material overrides to use */
var(ThirdPerson) array<MaterialInterface> PlayerControlledSkins;
/** Aggressively optimized mesh for the server with minimal bones */
var(Server) SkeletalMesh ServerMesh;
/** Additional material IDs that require MICs for gameplay material params */
var(Effects) array<int> ExtraMICIndices;
/** List of meshes to attach to the main body using the Parent Anim Component system */
var(ThirdPerson) array<SkeletalMesh> PACMeshList;
/** List of possible randomized colors to apply to zed */
var(ThirdPerson) array<ZedColorMod> RandomizedColors;
/** List of additional particle systems that require unique effects and logic per-event */
var(Effects) array<ExtraVFXInfo> ExtraVFX;
/** List of static mesh attachments that will be paired to specific bones */
var(ThirdPerson) array<StaticAttachments> StaticAttachList;
var(Effects) DoorSoundFx DoorHitSound;
var MaterialInstance BloodSplatterDecalMaterial;
/** Gore mesh with alternate bone weights */
var(Gore) SkeletalMesh GoreMesh;
/** Materials to override on the gore mesh */
var(Gore) array<MaterialInterface> GoreSkins;
/** Player-controlled materials to override on the gore mesh */
var(Gore) array<MaterialInterface> PlayerControlledGoreSkins;
/**  
 *Gore settings for bones that can be dismembered.
 *       ALL HITZONE BONES MUST BE INCLUDED EVEN IF THEY CANNOT BE DISMEMBERED
 */
var(Gore) editinline array<editinline KFGoreJointInfo> GoreJointSettings;
/** Gore chunk attachment settings for the mesh */
var(Gore) editinline array<editinline KFGoreChunkAttachmentInfo> GoreChunkAttachments;
/** Giblets to spawn on obliteration */
var(Gore) editinline array<editinline KFGibletInfo> GibletSettings;
/** Use for special melee dismeberment settings such as being able to split a character in half */
var(Gore) MeleeSpecialDismembermentInfo SpecialMeleeDismemberment;
/** Additional particle effect to be spawned for an explosion (if any) */
var(Gore) ParticleSystem ExplosionEffectTemplate<DisplayName=Gib Explosion Template>;
/** Particle effect to be spawned on obliteration */
var(Gore) ParticleSystem ObliterationEffectTemplate<DisplayName=Obliteration Effect Template>;
/** Particle effect to be spawned when knocked down, stunned, etc */
var(Effects) ParticleSystem DazedEffectTemplate<DisplayName=Stunned/Knocked Down Effect Template>;
/**  
 *Use to scale the number of gibs when the character explodes. Values greater than 1
 *       scale up, and values smaller than 0 scale down. Must be greater than 0. This is for
 *       actual grenade (or other explosive) based explosions. It has no effect on explosions
 *       triggered by Explosion Joints
 */
var(Gore) float ExplosionGibScale<DisplayName=Num Gibs Scale|UIMin=0|ClampMin=0|UIMax=10.0|ClampMax=10.0>;
/**  
 *Use to scale the impulse applied to gibs when the character explodes. Values greater than 1
 *       scale up, and values smaller than 0 scale down. Must be greater than 0. This affects both
 *       grenade based explosions and explosions triggered by Explosion Joints
 */
var(Gore) float ExplosionImpulseScale<DisplayName=Gib Impulse Scale|UIMin=0|ClampMin=0|UIMax=20.0|ClampMax=20.0>;

simulated function SetCharacterMeshFromArch(KFPawn KFP, optional KFPlayerReplicationInfo KFPRI)
{
    local int I, MaterialIndex;
    local editinline SkeletalMeshComponent PACAttachment;
    local editinline StaticMeshComponent StaticAttachment;
    local LinearColor AppliedColor;

    super.SetCharacterMeshFromArch(KFP, KFPRI);
    if((RandomizedColors.Length > 0) && KFPawn_Monster(KFP) != none)
    {
        KFPawn_Monster(KFP).RandomColorIdx = Rand(RandomizedColors.Length);
    }
    if(CharacterMesh != none)
    {
        KFP.DetachComponent(KFP.ThirdPersonHeadMeshComponent);
        I = 0;
        J0xD2:

        if(I < 3)
        {
            KFP.DetachComponent(KFP.ThirdPersonAttachments[I]);
            if(KFP.FirstPersonAttachments[I] != none)
            {
                KFP.DetachComponent(KFP.FirstPersonAttachments[I]);
            }
            ++ I;
            goto J0xD2;
        }
        if((KFP.WorldInfo.NetMode == NM_DedicatedServer) && ServerMesh != none)
        {
            KFP.Mesh.SetSkeletalMesh(ServerMesh);            
        }
        else
        {
            KFP.Mesh.SetSkeletalMesh(CharacterMesh);
        }
        KFP.Mesh.SetScale(DefaultMeshScale);
        KFP.PitchAudio(DefaultMeshScale);
        if(KFP.UsePlayerControlledZedSkin())
        {
            I = 0;
            J0x30C:

            if(I < PlayerControlledSkins.Length)
            {
                KFP.Mesh.SetMaterial(I, PlayerControlledSkins[I]);
                ++ I;
                goto J0x30C;
            }            
        }
        else
        {
            if(Skins.Length > 0)
            {
                I = 0;
                J0x3A0:

                if(I < Skins.Length)
                {
                    KFP.Mesh.SetMaterial(I, Skins[I]);
                    ++ I;
                    goto J0x3A0;
                }
            }
        }
        I = 0;
        J0x421:

        if((I < PACMeshList.Length) && I < 3)
        {
            PACAttachment = new (KFP) Class'SkeletalMeshComponent';
            if(PACAttachment != none)
            {
                KFP.ThirdPersonAttachments[I] = PACAttachment;
                PACAttachment.SetActorCollision(false, false);
                PACAttachment.SetSkeletalMesh(PACMeshList[I]);
                PACAttachment.SetParentAnimComponent(KFP.Mesh);
                PACAttachment.SetLODParent(KFP.Mesh);
                PACAttachment.SetShadowParent(KFP.Mesh);
                PACAttachment.SetLightingChannels(KFP.PawnLightingChannel);
                PACAttachment.CreateAndSetMaterialInstanceConstant(0);
                KFP.AttachComponent(PACAttachment);
            }
            ++ I;
            goto J0x421;
        }
        I = 0;
        J0x656:

        if(I < StaticAttachList.Length)
        {
            StaticAttachment = new (KFP) Class'StaticMeshComponent';
            if(StaticAttachment != none)
            {
                KFPawn_Monster(KFP).StaticAttachList.AddItem(StaticAttachment;
                StaticAttachment.SetActorCollision(false, false);
                StaticAttachment.SetStaticMesh(StaticAttachList[I].StaticAttachment);
                StaticAttachment.SetShadowParent(KFP.Mesh);
                StaticAttachment.SetLightingChannels(KFP.PawnLightingChannel);
                StaticAttachment.CreateAndSetMaterialInstanceConstant(0);
                KFP.AttachComponent(StaticAttachment);
                KFP.Mesh.AttachComponent(StaticAttachment, StaticAttachList[I].AttachBoneName,, StaticAttachList[I].RelativeRotation);
            }
            ++ I;
            goto J0x656;
        }
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFP.Mesh != none)
    {
        KFP.CharacterMICs.Length = 0;
        KFP.CharacterMICs[0] = KFP.Mesh.CreateAndSetMaterialInstanceConstant(0);
        foreach ExtraMICIndices(MaterialIndex,)
        {
            KFP.CharacterMICs.AddItem(KFP.Mesh.CreateAndSetMaterialInstanceConstant(MaterialIndex);            
        }        
    }
    if((KFP.WorldInfo.NetMode != NM_DedicatedServer) && KFPawn_Monster(KFP) != none)
    {
        I = 0;
        J0xA4A:

        if(I < KFP.CharacterMICs.Length)
        {
            if(KFPawn_Monster(KFP).RandomColorIdx >= 0)
            {
                AppliedColor = RandomizedColors[KFPawn_Monster(KFP).RandomColorIdx].MainColor;
                KFP.CharacterMICs[I].SetVectorParameterValue('vector_MainColor', AppliedColor);
                AppliedColor = RandomizedColors[KFPawn_Monster(KFP).RandomColorIdx].PatternColor;
                KFP.CharacterMICs[I].SetVectorParameterValue('vector_PatternColor', AppliedColor);
                AppliedColor = RandomizedColors[KFPawn_Monster(KFP).RandomColorIdx].TrimColor;
                KFP.CharacterMICs[I].SetVectorParameterValue('vector_TrimColor', AppliedColor);
            }
            ++ I;
            goto J0xA4A;
        }
    }
}

defaultproperties
{
    ExplosionGibScale=1
    ExplosionImpulseScale=1
}