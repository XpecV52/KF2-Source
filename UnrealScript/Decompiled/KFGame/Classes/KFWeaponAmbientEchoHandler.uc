/*******************************************************************************
 * KFWeaponAmbientEchoHandler generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeaponAmbientEchoHandler extends Object within KFPawn;

enum EEchoDirection
{
    EED_Front,
    EED_Right,
    EED_Left,
    EED_Rear,
    EED_Max
};

struct native EchoSet
{
    var export editinline AkComponent Components[4];
    var AkEvent Events[4];
    var float EchoStartTimes[4];
    var float EchoStopTimes[4];
    var byte Started[4];
    var byte Stopped[4];

    structdefaultproperties
    {
        Components[0]=none
        Components[1]=none
        Components[2]=none
        Components[3]=none
        Events[0]=none
        Events[1]=none
        Events[2]=none
        Events[3]=none
        EchoStartTimes[0]=0
        EchoStartTimes[1]=0
        EchoStartTimes[2]=0
        EchoStartTimes[3]=0
        EchoStopTimes[0]=0
        EchoStopTimes[1]=0
        EchoStopTimes[2]=0
        EchoStopTimes[3]=0
        Started[0]=0
        Started[1]=0
        Started[2]=0
        Started[3]=0
        Stopped[0]=0
        Stopped[1]=0
        Stopped[2]=0
        Stopped[3]=0
    }
};

var array<EchoSet> EchoSets;

simulated function HandleEchoes(AkEvent NewAmbientSound)
{
    if(Outer.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    StopAllEchoes();
    if(NewAmbientSound != none)
    {
        StartEchoSet(NewAmbientSound);
    }
}

simulated function StartEchoSet(AkEvent NewAmbientSound)
{
    local Vector FrontLocation, RightLocation, LeftLocation, RearLocation, ViewLocation;

    local float EchoDistance, EchoDelay, ViewDist;
    local PlayerController LocalPC;
    local Rotator ViewRotation;
    local ReverbVolume EchoVolume;
    local int EchoIdx;

    LocalPC = Outer.GetALocalPlayerController();
    if(LocalPC != none)
    {
        LocalPC.GetPlayerViewPoint(ViewLocation, ViewRotation);        
    }
    else
    {
        LogInternal(string(GetFuncName()) @ "called with no local PC!");
        return;
    }
    ViewDist = VSizeSq(ViewLocation - Outer.Location);
    Class'KFReverbVolume'.static.CalculateEchoVolumeAndDistance(Outer.WorldInfo, Outer.Location, EchoVolume, EchoDistance);
    EchoSets.Add(1;
    if((EchoDistance == float(0)) || ViewDist < (EchoDistance * EchoDistance))
    {
        if(EchoDistance < 1)
        {
            EchoDistance = 1;
        }
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(1, 0, 0) >> Outer.Rotation, EchoDistance, FrontLocation, EchoDelay);
        DelayedStartEcho(0, FrontLocation, NewAmbientSound.EchoFront, Outer.WorldInfo.TimeSeconds + EchoDelay);
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(0, -1, 0) >> Outer.Rotation, EchoDistance, LeftLocation, EchoDelay);
        DelayedStartEcho(2, LeftLocation, NewAmbientSound.EchoRight, Outer.WorldInfo.TimeSeconds + EchoDelay);
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(0, 1, 0) >> Outer.Rotation, EchoDistance, RightLocation, EchoDelay);
        DelayedStartEcho(1, RightLocation, NewAmbientSound.EchoLeft, Outer.WorldInfo.TimeSeconds + EchoDelay);
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(-1, 0, 0) >> Outer.Rotation, EchoDistance, RearLocation, EchoDelay);
        DelayedStartEcho(3, RearLocation, NewAmbientSound.EchoRear, Outer.WorldInfo.TimeSeconds + EchoDelay);        
    }
    else
    {
        DelayedStartEcho(0, Outer.Location, NewAmbientSound.EchoMono, Outer.WorldInfo.TimeSeconds + EchoDelay);
        EchoIdx = EchoSets.Length - 1;
        EchoSets[EchoIdx].Stopped[2] = 1;
        EchoSets[EchoIdx].Stopped[1] = 1;
        EchoSets[EchoIdx].Stopped[3] = 1;
    }
    if(EchoDelay == float(0))
    {
        TickEchoes();
    }
}

simulated function DelayedStartEcho(KFWeaponAmbientEchoHandler.EEchoDirection EDir, Vector EchoLocation, AkEvent EchoSound, float EchoStartTime)
{
    local int EchoSetIndex;
    local KFPlayerController LocalKFPC;

    LocalKFPC = KFPlayerController(Outer.GetALocalPlayerController());
    if(LocalKFPC != none)
    {
        EchoSetIndex = EchoSets.Length - 1;
        EchoSets[EchoSetIndex].Components[EDir] = LocalKFPC.GetPooledAkComponent();
        EchoSets[EchoSetIndex].Components[EDir].Location = EchoLocation;
        EchoSets[EchoSetIndex].Components[EDir].bStopWhenOwnerDestroyed = true;
        EchoSets[EchoSetIndex].Events[EDir] = EchoSound;
        EchoSets[EchoSetIndex].EchoStartTimes[EDir] = EchoStartTime;
    }
}

simulated function StopEchoSet(optional int EchoSetIndex, optional bool bStopImmediate)
{
    local float EchoDistance, EchoDelay;
    local ReverbVolume EchoVolume;
    local Vector EchoLocation;

    EchoSetIndex = -1;
    bStopImmediate = false;
    if(EchoSetIndex < 0)
    {
        EchoSetIndex = EchoSets.Length - 1;
    }
    if((EchoSetIndex < 0) || EchoSetIndex >= EchoSets.Length)
    {
        return;
    }
    if(bStopImmediate)
    {
        StopEcho(EchoSetIndex, 0);
        StopEcho(EchoSetIndex, 2);
        StopEcho(EchoSetIndex, 1);
        StopEcho(EchoSetIndex, 3);
        EchoSets.Remove(EchoSetIndex, 1;        
    }
    else
    {
        Class'KFReverbVolume'.static.CalculateEchoVolumeAndDistance(Outer.WorldInfo, Outer.Location, EchoVolume, EchoDistance);
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(1, 0, 0) >> Outer.Rotation, EchoDistance, EchoLocation, EchoDelay);
        EchoSets[EchoSetIndex].EchoStopTimes[0] = Outer.WorldInfo.TimeSeconds + EchoDelay;
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(0, -1, 0) >> Outer.Rotation, EchoDistance, EchoLocation, EchoDelay);
        EchoSets[EchoSetIndex].EchoStopTimes[2] = Outer.WorldInfo.TimeSeconds + EchoDelay;
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(0, 1, 0) >> Outer.Rotation, EchoDistance, EchoLocation, EchoDelay);
        EchoSets[EchoSetIndex].EchoStopTimes[1] = Outer.WorldInfo.TimeSeconds + EchoDelay;
        Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, Outer.Location, vect(-1, 0, 0) >> Outer.Rotation, EchoDistance, EchoLocation, EchoDelay);
        EchoSets[EchoSetIndex].EchoStopTimes[3] = Outer.WorldInfo.TimeSeconds + EchoDelay;
    }
}

simulated function StopAllEchoes(optional bool bImmediate)
{
    local int I;

    I = EchoSets.Length - 1;
    J0x18:

    if(I >= 0)
    {
        if(bImmediate || EchoSets[I].EchoStopTimes[0] == float(0))
        {
            StopEchoSet(I, bImmediate);
        }
        -- I;
        goto J0x18;
    }
}

simulated function TickEchoes()
{
    local int I, J, NumStoppedEchoes;
    local float WorldTimeSeconds;

    WorldTimeSeconds = Outer.WorldInfo.TimeSeconds;
    I = 0;
    J0x48:

    if(I < EchoSets.Length)
    {
        NumStoppedEchoes = 0;
        J = 0;
        J0x76:

        if(J < 4)
        {
            if(EchoSets[I].Stopped[J] == 0)
            {
                if(((EchoSets[I].Started[J] == 0) && EchoSets[I].EchoStartTimes[J] > float(0)) && WorldTimeSeconds > EchoSets[I].EchoStartTimes[J])
                {
                    StartEcho(I, J);                    
                }
                else
                {
                    if(((EchoSets[I].Started[J] > 0) && EchoSets[I].EchoStopTimes[J] > float(0)) && WorldTimeSeconds > EchoSets[I].EchoStopTimes[J])
                    {
                        StopEcho(I, J);
                        ++ NumStoppedEchoes;
                    }
                }                
            }
            else
            {
                ++ NumStoppedEchoes;
            }
            ++ J;
            goto J0x76;
        }
        if(NumStoppedEchoes == 4)
        {
            EchoSets.Remove(-- I, 1;
        }
        ++ I;
        goto J0x48;
    }
}

simulated function StartEcho(int EchoSetIndex, int EchoIndex)
{
    EchoSets[EchoSetIndex].Started[EchoIndex] = 1;
    EchoSets[EchoSetIndex].Components[EchoIndex].PlayEvent(EchoSets[EchoSetIndex].Events[EchoIndex]);
}

simulated function StopEcho(int EchoSetIndex, int EchoIndex)
{
    EchoSets[EchoSetIndex].Stopped[EchoIndex] = 1;
    EchoSets[EchoSetIndex].Components[EchoIndex].StopEvents();
}
