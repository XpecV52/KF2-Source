/*******************************************************************************
 * AICommand_Attack_Melee generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Attack_Melee extends AICommand_SM_Attack within KFAIController
    native(AI);

var bool bDebugShowAbortSequence;
var bool bNewEnemyPending;
var Vector StepAheadLocation;
var Vector CircleDistance;
var Vector CirclePoint;
var int CircleDir;

static function bool Melee(KFAIController AI, optional Actor InTarget, optional byte InSMFlags)
{
    local AICommand_Attack_Melee Cmd;

    if(AI != none)
    {
        Cmd = new (AI) default.Class;
        if(Cmd != none)
        {
            if(InTarget != none)
            {
                Cmd.AttackTarget = InTarget;                
            }
            else
            {
                Cmd.AttackTarget = AI.Enemy;
            }
            Cmd.SMFlags = InSMFlags;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    if(Outer.IsDoingLatentMove())
    {
        WarnInternal((string(Outer.MyKFPawn) @ "STILL DOING LATENT MOVE ") $ string(Outer.MoveTimer));
    }
    Outer.AIZeroMovementVariables();
    Outer.MeleeTarget = ((KFPawn(AttackTarget) != none) ? KFPawn(AttackTarget) : KFPawn(Outer.Enemy));
    bFinishRotationBeforeAttack = Outer.bUseDesiredRotationForMelee;
    Outer.AIActionStatus = "Attempting to attack " $ string(AttackTarget);
}

function Popped()
{
    Outer.AIActionStatus = "Finished melee attack";
    super.Popped();
    Outer.NotifyMeleeAttackFinished();
    Outer.MeleeTarget = none;
    Outer.AIActionStatus = "Finished attack " $ string(Outer.MeleeTarget);
    if(Outer.Pawn != none)
    {
        Outer.Pawn.ZeroMovementVariables();
    }
}

event bool NotifyBump(Actor Other, Vector HitNormal)
{
    Outer.AILog_Internal(string(GetFuncName()) $ " IN MELEE ATTACK", 'PathWarning');
    Outer.DisableBump(0.25);
    return true;
}

function Paused(GameAICommand NewCommand)
{
    Outer.AILog_Internal((string(self) $ " PAUSED BY ") $ string(NewCommand), 'Warning');
    super.Paused(NewCommand);
}

function Resumed(name OldCommandName)
{
    Outer.AILog_Internal((string(self) $ " Resumed, OldCommand: ") $ string(OldCommandName));
    super(AICommand_SpecialMove).Resumed(OldCommandName);
    if(OldCommandName == 'AICommand_Pause')
    {
        GotoState('DelayFailure');
    }
}

function bool CanChangeEnemy(Pawn NewEnemy)
{
    return false;
}

function bool NotifyPlayerBecameVisible(Pawn VisiblePlayer)
{
    if((VisiblePlayer.IsAliveAndWell() && AttackTarget != none) && !AttackTarget.IsA('Pawn'))
    {
        if(Outer.ActorReachable(VisiblePlayer) && Outer.SetEnemy(VisiblePlayer))
        {
            bNewEnemyPending = true;
            return false;
        }
    }
    return true;
}

event string GetDumpString()
{
    return (((((super(GameAICommand).GetDumpString() @ "AttackTarget:") @ string(AttackTarget)) $ " Enemy: ") $ string(Outer.Enemy)) $ " Dist: ") $ string(VSize(Outer.Enemy.Location - Outer.Pawn.Location));
}

function float GetAbortAttackDistanceSq()
{
    local Vector2D AttackRange;
    local int AttackIdx;

    if(((Outer.MyKFPawn != none) && Outer.MyKFPawn.PawnAnimInfo != none) && SMFlags != 255)
    {
        AttackIdx = SMFlags & 15;
        AttackRange = Outer.MyKFPawn.PawnAnimInfo.GetAttackRangeByName(Outer.MyKFPawn.PawnAnimInfo.Attacks[AttackIdx].Tag);
        return AttackRange.Y * AttackRange.Y;
    }
    return 57600;
}

function NotifyEnemyChanged(optional Pawn OldEnemy)
{
    bNewEnemyPending = true;
}

function CircleTimer();

function Vector GetStepAheadLocation()
{
    local Vector X;
    local float StepDist;
    local Vector CheckLocation, HitLocation, HitNormal;
    local float DistFromTarget, RangeToCheck;

    DistFromTarget = VSize(AttackTarget.Location - Outer.Pawn.Location);
    RangeToCheck = Outer.MyKFPawn.MeleeAttackHelper.GetMeleeRange();
    StepDist = DistFromTarget - RangeToCheck;
    X = AttackTarget.Location - Outer.Pawn.Location;
    X.Z = 0;
    X = Normal(X);
    CheckLocation = Outer.Pawn.Location + (X * StepDist);
    StepDist = Outer.MaxStepAsideDist;
    if(Outer.PointReachable(CheckLocation) && (Outer.Trace(HitLocation, HitNormal, CheckLocation, Outer.Pawn.Location, true) == none) || VSize(HitLocation - Outer.Pawn.Location) > (StepDist * 0.5))
    {
        return CheckLocation;
    }
    return vect(0, 0, 0);
}

state Command_SpecialMove
{
    function BeginState(name PreviousStateName)
    {
        if(((((KFDoorActor(AttackTarget) != none) && !KFDoorActor(AttackTarget).IsCompletelyOpen()) && Outer.MyKFPawn.CanDoSpecialMove(2)) && Outer.MyKFPawn.PawnAnimInfo != none) && Outer.MyKFPawn.PawnAnimInfo.DoorAttacks.Length > 0)
        {
            AttackSpecialMove = 2;
        }
        if(Outer.MyKFPawn.MeleeAttackHelper == none)
        {
            return;
        }
        if((AttackTarget != none) && !AttackTarget.IsA('Pawn'))
        {
            Outer.EnableSeePlayer();
        }
    }

    function ContinuedState()
    {
        GotoState(DefaultStartState,, true);
    }

    function bool ExecuteSpecialMove()
    {
        if(((((Outer.MyKFPawn == none) || !Outer.MyKFPawn.IsAliveAndWell()) || AttackTarget == none) || (Pawn(AttackTarget) != none) && !Pawn(AttackTarget).IsAliveAndWell()) || AttackTarget.IsA('KFDoorActor') && KFDoorActor(AttackTarget).IsCompletelyOpen())
        {
            Outer.AILog_Internal((string(self) $ " ExecuteSpecialMove() returning early ") $ string(AttackTarget), 'Command_Attack_Melee');
            return false;
        }
        Outer.AILog_Internal((string(self) $ " ExecuteSpecialMove() AttackTarget: ") $ string(AttackTarget), 'Command_Attack_Melee');
        if(((AttackTarget != none) && Outer.Pawn != none) && !Outer.Pawn.bCrawler)
        {
            Outer.SetDesiredRotation(rotator(AttackTarget.Location - Outer.Pawn.Location));
        }
        if((Outer.Pawn.bCrawler || Outer.Pawn.ReachedDesiredRotation()) && AttackTarget != none)
        {
            Outer.AILog_Internal(((string(self) $ " Target in melee range (Dist: ") $ string(VSize(AttackTarget.Location - Outer.Pawn.Location))) $ "... do attack", 'Command_Attack_Melee');
            Outer.MyKFPawn.DoSpecialMove(GetSpecialMove(), true,, SMFlags);
            return true;
        }
        Outer.AILog_Internal((string(self) $ " ExecuteSpecialMove returning false because ReachedDesiredRotation isn't done?  AttackTarget: ") $ string(AttackTarget), 'Command_Attack_Melee');
        return false;
    }

    function bool IsSpecialMoveComplete()
    {
        local bool bInvalidTarget;

        if(((((Outer.MyKFPawn == none) || AttackTarget == none) || AttackTarget.bDeleteMe) || (KFDoorActor(AttackTarget) != none) || (KFPawn(AttackTarget) != none) && !Outer.IsValidAttackTarget(Outer.MeleeTarget) || VSize(AttackTarget.Location - Outer.MyKFPawn.Location) > Outer.MyKFPawn.MeleeRange) || AttackTarget.IsA('KFDoorActor') && KFDoorActor(AttackTarget).IsCompletelyOpen())
        {
            bInvalidTarget = true;
        }
        if(Outer.MyKFPawn != none)
        {
            if(Outer.MyKFPawn.IsDoingMeleeAttack())
            {
                return false;
            }
            if(!Outer.MyKFPawn.IsDoingSpecialMove(GetSpecialMove()))
            {
                return true;
            }
        }
        if(bInvalidTarget)
        {
            return true;
        }
        return false;
    }

    event HandleAICommandSpecialAction()
    {
        if(((Outer.Pawn.Mesh.RootMotionMode != 3) && Outer.Enemy != none) && Outer.MyKFPawn != none)
        {
            if(Outer.bUseDesiredRotationForMelee && AttackTarget != none)
            {
                Outer.SetDesiredRotation(rotator(AttackTarget.Location - Outer.Pawn.Location));                
            }
            else
            {
                Outer.Focus = AttackTarget;
            }
            if(((bCanBeAborted && !bAttackAborted) && VSizeSq(Outer.Pawn.Location - AttackTarget.Location) > (GetAbortAttackDistanceSq())) && !AttackTarget.IsA('KFDoorActor'))
            {
                Outer.AILog_Internal((((((string(self) $ " 1 Aborting attack.. AttackTarget: ") $ string(AttackTarget)) $ " Dist: ") $ string(VSize(AttackTarget.Location - Outer.Pawn.Location))) $ " Speed: ") $ string(VSize(Outer.Pawn.Velocity)), 'Command_Attack_Melee');
                if(Outer.MyKFPawn.IsDoingSpecialMove(GetSpecialMove()))
                {
                    if(bDebugShowAbortSequence)
                    {
                        Outer.DrawDebugSphere(Outer.Pawn.Location, 32, 16, 255, 255, 0, false);
                    }
                    UpdateHistoryString("attack aborted (out of range)");
                    bAttackAborted = true;
                    KFSM_MeleeAttack(Outer.MyKFPawn.SpecialMoves[GetSpecialMove()]).AbortedByAICommand();
                }
            }
            if((bCanBeAborted && AttackTarget != none) && AttackTarget.IsA('KFDoorActor'))
            {
                if((KFDoorActor(AttackTarget).WeldIntegrity <= 0) || KFDoorActor(AttackTarget).IsCompletelyOpen())
                {
                    Outer.AILog_Internal((((((string(self) $ " 2 Aborting attack.. AttackTarget: ") $ string(AttackTarget)) $ " Dist: ") $ string(VSize(AttackTarget.Location - Outer.Pawn.Location))) $ " Speed: ") $ string(VSize(Outer.Pawn.Velocity)), 'Command_Attack_Melee');
                    if(Outer.MyKFPawn.IsDoingSpecialMove(GetSpecialMove()))
                    {
                        bAttackAborted = true;
                        KFSM_MeleeAttack(Outer.MyKFPawn.SpecialMoves[GetSpecialMove()]).AbortedByAICommand();
                    }
                }
            }
        }
    }

    function bool HandleSpecialMoveEnded()
    {
        return false;
    }

    function FinishedSpecialMove()
    {
        Outer.AILog_Internal(string(GetFuncName()), 'Command_Attack_Melee');
        Outer.UpdateLastMeleeTime(0);
        Status = 'Success';
        if(HandleSpecialMoveEnded())
        {
            return;
        }
        if(bSingleAttack)
        {
            Outer.EndOfMeleeAttackNotification();
        }
    }
TauntEnemy:

    if(Outer.IsTimerActive('SpecialMoveTimeout', self))
    {
        Outer.SetTimer(15, false, 'SpecialMoveTimeout', self);
    }
    bCanBeAborted = false;
    Outer.Pawn.ZeroMovementVariables();
    Outer.MoveTimer = -1;
    Outer.StopAllLatentMovement();
    Class'AICommand_TauntEnemy'.static.Taunt(Outer, KFPawn(Outer.Enemy), 0);
    Outer.RouteCache_Empty();
    Outer.Sleep(0.33);
    Status = 'Success';
    Outer.PopCommand(self);
    stop;                
}

state TestMove
{Begin:

    StepAheadLocation = GetStepAheadLocation();
    Outer.MoveTo(GetStepAheadLocation(), AttackTarget,, Outer.Pawn.bIsWalking);
    Outer.Sleep(0);
    PopState();
    stop;                
}

state Circle
{
    function PushedState()
    {
        Outer.MyKFPawn.bAllowAccelSmoothing = false;
        super(Object).PushedState();
    }

    function PoppedState()
    {
        super(Object).PoppedState();
        if(Outer.Pawn != none)
        {
            Outer.Pawn.ZeroMovementVariables();
        }
    }

    function bool GetCirclePoint()
    {
        local bool bResult;
        local Vector EnemyToPawn;
        local float Dist;

        EnemyToPawn = Outer.Pawn.Location - Outer.Enemy.Location;
        Dist = VSize(EnemyToPawn);
        if(Dist < CircleDistance.X)
        {
            EnemyToPawn *= (CircleDistance.X / Dist);
        }
        if(Dist > CircleDistance.Y)
        {
            EnemyToPawn *= (CircleDistance.Y / Dist);
        }
        CirclePoint = Outer.Enemy.Location + (EnemyToPawn >> (rot(0, 8192, 0) * float(CircleDir)));
        bResult = Outer.PointReachable(CirclePoint);
        Outer.AILog_Internal(((string(GetFuncName()) @ string(CirclePoint)) @ string(Dist)) @ string(bResult), 'Command_Attack_Melee');
        return bResult;
    }
Begin:

    Outer.AILog_Internal((string(self) $ " BEGIN TAG") @ string(GetStateName()), 'Command_Attack_Melee');
    Outer.SetTimer(1.25 + (FRand() * 1.25), false, 'CircleTimer', self);
    J0x76:

    if(Outer.IsTimerActive('CircleTimer', self))
    {
        if(GetCirclePoint())
        {
            Outer.SetFocalPoint(Outer.Enemy.Location, true);
            Outer.MoveTo(CirclePoint, Outer.Enemy,, false);            
        }
        else
        {
            goto J0x14C;
        }
        goto J0x76;
    }
    J0x14C:

    if((FRand() < 0.6) && (Normal(Outer.Pawn.Location - Outer.Enemy.Location) Dot vector(Outer.Enemy.Rotation)) < 0.94)
    {
        goto 'Begin';
    }
    Outer.PopCommand(self);
    stop;                    
}

defaultproperties
{
    CircleDistance=(X=128,Y=256,Z=0)
    bCanBeAborted=true
    bZeroPawnAccelWhenPopped=true
    PostSpecialMoveAbortedSleepTime=0.3
}