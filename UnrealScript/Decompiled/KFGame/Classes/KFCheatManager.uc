/*******************************************************************************
 * KFCheatManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFCheatManager extends GameCheatManager within GamePlayerController
    native
    config(Game);

var bool bDebugSceneEnabled;
var transient bool bUsingSplatterGun;
var transient bool bRequestedGlobalStats;
var KFSceneCaptureDebugCam DebugSceneCamera;
var KFAIController DebugKFAIC;
var KFPawn_Monster DebugTarget;
var name CheatType;

// Export UKFCheatManager::execSetPerkLevel(FFrame&, void* const)
native final exec function SetPerkLevel(int NewPerkLevel);

// Export UKFCheatManager::execResetPerkLevels(FFrame&, void* const)
native final exec function ResetPerkLevels();

// Export UKFCheatManager::execReadGlobalStat(FFrame&, void* const)
native exec function ReadGlobalStat(string StatId, optional int HistoryNumDays);

// Export UKFCheatManager::execFindTranslucencyInheritDominantShadowMaterials(FFrame&, void* const)
native final exec function FindTranslucencyInheritDominantShadowMaterials();

function Pawn GetMyPawn()
{
    return ((Outer.Pawn != none) ? Outer.Pawn : DebugCameraController(Outer).OriginalControllerRef.Pawn);
}

exec function AutoFire(float interval)
{
    Outer.StartFire();
    Outer.SetTimer(interval, true, 'FireAgain', self);
}

exec function StopAutoFire()
{
    Outer.StopFire();
    Outer.ClearTimer('FireAgain', self);
}

simulated function FireAgain()
{
    Outer.StopFire();
    Outer.StartFire();
}

exec function TestGrenade(optional string GrenadePath)
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    if(GrenadePath == "")
    {
        GrenadePath = "KFGameContent.KFProj_HEGrenade";
    }
    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject(GrenadePath, Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function TestConcussiveGrenade()
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject("KFGameContent.KFProj_DynamiteGrenade", Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.ExplosionTemplate.ExplosionEffects = SpawnedGrenade.default.AltExploEffects;
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function TestNukeGrenade()
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject("KFGameContent.KFProj_DynamiteGrenade", Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.ExplosionTemplate = Class'KFPerk_Demolitionist'.static.GetNukeExplosionTemplate();
        SpawnedGrenade.ExplosionActorClass = Class'KFPerk_Demolitionist'.static.GetNukeExplosionActorClass();
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function BurnFX()
{
    KFPawn(GetMyPawn()).AfflictionHandler.SetFirePanicked(true);
}

exec function StopBurnFX()
{
    KFPawn(GetMyPawn()).AfflictionHandler.SetFirePanicked(false);
}

exec function SetInflate(float InflateParam)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.AfflictionHandler.SetMicrowaveParameter(InflateParam);        
    }    
}

exec function SetChar(float CharParam)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.AfflictionHandler.SetBurnedParameter(CharParam);        
    }    
}

exec function ToggleZedsIgnoreMe()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if((KFAIC != none) && KFAIC.Enemy == (GetMyPawn()))
        {
            KFAIC.Enemy = none;
        }        
    }    
    Outer.ClientMessage((string(GetMyPawn()) @ "Zeds Ignore Me: ") $ string(KFPawn(GetMyPawn()).bAIZedsIgnoreMe), CheatType);
}

exec function ToggleFrustration(optional int enabledValue)
{
    enabledValue = 5;
    if(Class'KFAIController'.default.FrustrationThreshold == 0)
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController FrustrationThreshold" @ string(enabledValue));        
    }
    else
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController FrustrationThreshold" @ string(0));
    }
}

exec function ZedTeleport()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC != none)
        {
            KFAIC.RelocateTeleport();
        }        
    }    
    Outer.ClientMessage("Teleporting zeds for reorganization", CheatType);
}

exec function ZedStuck()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC != none)
        {
            KFAIC.HandleStuck();
        }        
    }    
    Outer.ClientMessage("Forcing HandleStuck For Zeds", CheatType);
}

exec function LogCurrentWave()
{
    local int I, J, K;
    local KFAISpawnManager SpawnManager;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        SpawnManager = KFGameInfo(Outer.WorldInfo.Game).SpawnManager;
        LogInternal("Current Loaded Wave Setup");
        I = 0;
        J0xC6:

        if(I < SpawnManager.AvailableSquads.Length)
        {
            J = 0;
            J0xFE:

            if(J < SpawnManager.AvailableSquads[I].MonsterList.Length)
            {
                LogInternal((((((((("AvailableSquads " $ string(I)) $ " MonsterList ") $ string(J)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.AvailableSquads[I].MonsterList[J].Type))) $ " Num: ") $ string(SpawnManager.AvailableSquads[I].MonsterList[J].Num)) $ " SquadName: ") $ string(SpawnManager.AvailableSquads[I]));
                ++ J;
                goto J0xFE;
            }
            ++ I;
            goto J0xC6;
        }
        LogInternal(((("Current Waves Info For Wave: " $ string(KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum)) $ " which is ") $ string(KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum - 1)) $ " in the wave array ");
        I = KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum - 1;
        J = 0;
        J0x46B:

        if(J < SpawnManager.Waves[I].Squads.Length)
        {
            K = 0;
            J0x4C2:

            if(K < SpawnManager.Waves[I].Squads[J].MonsterList.Length)
            {
                LogInternal((((((((("Wave " $ string(I)) $ " Squads ") $ string(J)) $ " MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.Waves[I].Squads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.Waves[I].Squads[J].MonsterList[K].Num));
                ++ K;
                goto J0x4C2;
            }
            ++ J;
            goto J0x46B;
        }
        if(SpawnManager.Waves[I].SpecialSquad != none)
        {
            K = 0;
            J0x706:

            if(K < SpawnManager.Waves[I].SpecialSquad.MonsterList.Length)
            {
                LogInternal((((((("Wave " $ string(I)) $ " Special Squad MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.Waves[I].SpecialSquad.MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.Waves[I].SpecialSquad.MonsterList[K].Num));
                ++ K;
                goto J0x706;
            }            
        }
        else
        {
            LogInternal(("Wave " $ string(I)) $ " No Special Squad ");
        }
    }
}

exec function LogAllWaves()
{
    local int I, J, K;
    local KFAISpawnManager SpawnManager;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        SpawnManager = KFGameInfo(Outer.WorldInfo.Game).SpawnManager;
        LogInternal("Current Loaded Wave Setup");
        I = 0;
        J0xC6:

        if(I < SpawnManager.AvailableSquads.Length)
        {
            J = 0;
            J0xFE:

            if(J < SpawnManager.AvailableSquads[I].MonsterList.Length)
            {
                LogInternal((((((((("AvailableSquads " $ string(I)) $ " MonsterList ") $ string(J)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.AvailableSquads[I].MonsterList[J].Type))) $ " Num: ") $ string(SpawnManager.AvailableSquads[I].MonsterList[J].Num)) $ " SquadName: ") $ string(SpawnManager.AvailableSquads[I]));
                ++ J;
                goto J0xFE;
            }
            ++ I;
            goto J0xC6;
        }
        LogInternal("All Waves Info");
        I = 0;
        J0x2E3:

        if(I < SpawnManager.Waves.Length)
        {
            J = 0;
            J0x31B:

            if(J < SpawnManager.Waves[I].Squads.Length)
            {
                K = 0;
                J0x372:

                if(K < SpawnManager.Waves[I].Squads[J].MonsterList.Length)
                {
                    LogInternal((((((((("Wave " $ string(I)) $ " Squads ") $ string(J)) $ " MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.Waves[I].Squads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.Waves[I].Squads[J].MonsterList[K].Num));
                    ++ K;
                    goto J0x372;
                }
                ++ J;
                goto J0x31B;
            }
            if(SpawnManager.Waves[I].SpecialSquad != none)
            {
                K = 0;
                J0x5B6:

                if(K < SpawnManager.Waves[I].SpecialSquad.MonsterList.Length)
                {
                    LogInternal((((((("Wave " $ string(I)) $ " Special Squad MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.Waves[I].SpecialSquad.MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.Waves[I].SpecialSquad.MonsterList[K].Num));
                    ++ K;
                    goto J0x5B6;
                }                
            }
            else
            {
                LogInternal(("Wave " $ string(I)) $ " No Special Squad ");
            }
            ++ I;
            goto J0x2E3;
        }
    }
}

exec function SpawnGunModel(string GunMeshString)
{
    local SkeletalMesh GunMesh;

    GunMesh = SkeletalMesh(DynamicLoadObject(GunMeshString, Class'SkeletalMesh'));
    KFPawn(Outer.Pawn).ArmsMesh.DetachFromAny();
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).SetSkeletalMesh(GunMesh);
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).SetAnimTreeTemplate(none);
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).AnimSets.Length = 0;
}

exec function HansGunsOut()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.DoSpecialMove(23, false, none, 1);        
    }    
}

exec function HansGunsAway()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.DoSpecialMove(23, false, none, 0);        
    }    
}

exec function WeapForceIdle()
{
    KFWeapon(Outer.Pawn.Weapon).PlayAnimation(KFWeapon(Outer.Pawn.Weapon).IdleAnims[0], 0, false, 0);
    Outer.SetTimer(0.001, false, 'FreezeWeapAnimUpdate', self);
}

simulated function FreezeWeapAnimUpdate()
{
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).bPauseAnims = true;
}

exec function TestWeaponAnim(name AnimName)
{
    KFWeapon(Outer.Pawn.Weapon).PlayAnimation(AnimName, 0, false, 0);
}

exec function SetPauseMonsterAnims(bool bPause)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.Mesh.bPauseAnims = bPause;        
    }    
}

exec function NoSpread()
{
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).Spread[0] = 0;
        KFWeapon(Outer.Pawn.Weapon).Spread[1] = 0;
        Outer.ClientMessage("Spread Disabled", CheatType);
    }
}

exec function GoSpread()
{
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).Spread[0] = KFWeapon(Outer.Pawn.Weapon).default.Spread[0];
        KFWeapon(Outer.Pawn.Weapon).Spread[1] = KFWeapon(Outer.Pawn.Weapon).default.Spread[1];
        Outer.ClientMessage("Spread Enabled", CheatType);
    }
}

exec function HideMenus()
{
    if(KFPlayerController(Outer).MyGFxManager != none)
    {
        KFPlayerController(Outer).MyGFxManager.SetMenuVisibility(false);        
    }
    else
    {
        LogInternal("MENU MANAGER NOT READY");
    }
}

exec function ToggleForceCrosshair()
{
    KFHUDBase(Outer.myHUD).bForceDrawCrosshair = !KFHUDBase(Outer.myHUD).bForceDrawCrosshair;
}

exec function ToggleCrosshair()
{
    KFHUDBase(Outer.myHUD).bDrawCrosshair = !KFHUDBase(Outer.myHUD).bDrawCrosshair;
}

exec function FlameSetComplex(bool bDoCollideComplex)
{
    if(KFWeap_FlameBase(Outer.Pawn.Weapon) != none)
    {
        KFWeap_FlameBase(Outer.Pawn.Weapon).SetFlameComplex(bDoCollideComplex);
    }
}

exec function FlameDebugDamage(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision)
{
    local KFWeap_FlameBase KWFB;

    KWFB = KFWeap_FlameBase(Outer.Pawn.Weapon);
    if(KWFB != none)
    {
        KWFB.SetFlameDebugDamage(bDebugDirectDamage, bDebugSplashDamage, bDebugShowSplashRadius, bDebugShowCollision);
    }
}

exec function FlameDebugFX(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles)
{
    local KFWeap_FlameBase KWFB;

    KWFB = KFWeap_FlameBase(Outer.Pawn.Weapon);
    if(KWFB != none)
    {
        KWFB.SetFlameDebugFX(bDebugShowSeeds, bDebugShowBones, bDebugForceNonPlayerParticles);
    }
}

exec function FlameDebugFX3P(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles)
{
    local KFWeapAttach_SprayBase KFSB;
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFSB = KFWeapAttach_SprayBase(KFP.WeaponAttachment);
        if(KFSB != none)
        {
            KFSB.SetFlameDebugFX(bDebugShowSeeds, bDebugShowBones, bDebugForceNonPlayerParticles);
        }
    }
}

exec function FlameDebugDamage3P(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision)
{
    local KFWeapAttach_SprayBase KFSB;
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFSB = KFWeapAttach_SprayBase(KFP.WeaponAttachment);
        if(KFSB != none)
        {
            KFSB.SetFlameDebugDamage(bDebugDirectDamage, bDebugSplashDamage, bDebugShowSplashRadius, bDebugShowCollision);
        }
    }
}

simulated exec function NextTrack()
{
    if(KFGameReplicationInfo(Outer.WorldInfo.GRI) != none)
    {
        KFGameReplicationInfo(Outer.WorldInfo.GRI).PlayNewMusicTrack();
    }
}

simulated exec function SetMusicVolume(float NewVolume)
{
    local float MusicVolumeMultiplier;

    MusicVolumeMultiplier = NewVolume;
    Outer.GetALocalPlayerController().SetAudioGroupVolume('Music', MusicVolumeMultiplier);
    Class'KFGameEngine'.default.MusicVolumeMultiplier = MusicVolumeMultiplier;
    Class'KFGameEngine'.static.StaticSaveConfig();
}

exec function Weapon GiveWeapon(string WeaponClassStr)
{
    local KFInventoryManager KFIM;
    local Weapon NewWeap;

    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        KFIM.bInfiniteWeight = true;
        NewWeap = super(CheatManager).GiveWeapon(WeaponClassStr);
        KFIM.bInfiniteWeight = false;
    }
    return NewWeap;
}

simulated exec function Shotty()
{
    GiveWeapon("KFGameContent.KFWeap_Shotgun_MB500");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_M4");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DoubleBarrel");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_AA12");
}

simulated exec function MKB()
{
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_DualMKb42_Hans");
}

simulated exec function Pistols()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
}

simulated exec function Dualies()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_Dual9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualDeagle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualColt1911");
    GiveWeapon("KFGameContent.KFWeap_Revolver_DualRem1858");
    GiveWeapon("KFGameContent.KFWeap_Revolver_DualSW500");
}

simulated exec function Singles()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Colt1911");
    GiveWeapon("KFGameContent.KFWeap_Revolver_Rem1858");
    GiveWeapon("KFGameContent.KFWeap_Revolver_SW500");
}

simulated exec function DummyWeapon()
{
    GiveWeapon("KFGameContent.KFWeap_AssetDummy");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Dummy");
}

simulated exec function Berserk()
{
    GiveWeapon("KFGameContent.KFWeap_Blunt_Crovel");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Nailgun");
    GiveWeapon("KFGameContent.KFWeap_Blunt_Pulverizer");
    GiveWeapon("KFGameContent.KFWeap_Eviscerator");
    GiveWeapon("KFGameContent.KFWeap_Edged_Zweihander");
}

simulated exec function Nails()
{
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Nailgun");
}

simulated exec function Melee()
{
    GiveWeapon("KFGameContent.KFWeap_Edged_Katana");
    GiveWeapon("KFGameContent.KFWeap_Knife_Berserker");
    GiveWeapon("KFGameContent.KFWeap_Knife_Commando");
    GiveWeapon("KFGameContent.KFWeap_Knife_Demolitionist");
    GiveWeapon("KFGameContent.KFWeap_Knife_Firebug");
    GiveWeapon("KFGameContent.KFWeap_Knife_Medic");
    GiveWeapon("KFGameContent.KFWeap_Knife_Support");
    GiveWeapon("KFGameContent.KFWeap_Edged_Zweihander");
}

simulated exec function Assault()
{
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Bullpup");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_AR15");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_SCAR");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_AK12");
}

simulated exec function Scope()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_M14EBR");
}

simulated exec function ScopeFOV(float NewFOV)
{
    if(KFWeap_ScopedBase(Outer.Pawn.Weapon) != none)
    {
        KFWeap_ScopedBase(Outer.Pawn.Weapon).SceneCapture.SetCaptureParameters(,, NewFOV);
    }
}

simulated exec function Demo()
{
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_HX25");
    GiveWeapon("KFGameContent.KFWeap_Thrown_C4");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_M79");
    GiveWeapon("KFGameContent.KFWeap_RocketLauncher_RPG7");
}

simulated exec function Medic()
{
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Medic");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Medic");
    GiveWeapon("KFGameContent.KFWeap_SMG_Medic");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Medic");
}

simulated exec function Flame()
{
    GiveWeapon("KFGameContent.KFWeap_Flame_CaulkBurn");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DragonsBreath");
    GiveWeapon("KFGameContent.KFWeap_Flame_Flamethrower");
    GiveWeapon("KFGameContent.KFWeap_Beam_Microwave");
}

simulated exec function Firebug()
{
    GiveWeapon("KFGameContent.KFWeap_Flame_CaulkBurn");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DragonsBreath");
    GiveWeapon("KFGameContent.KFWeap_Flame_Flamethrower");
    GiveWeapon("KFGameContent.KFWeap_Beam_Microwave");
}

simulated exec function Rifle()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_Winchester1894");
}

simulated exec function Sharpshooter()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_Winchester1894");
    GiveWeapon("KFGameContent.KFWeap_Bow_Crossbow");
    GiveWeapon("KFGameContent.KFWeap_Rifle_M14EBR");
}

simulated exec function SMG()
{
    GiveWeapon("KFGameContent.KFWeap_SMG_P90");
}

exec function AllWeapons()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
    Assault();
    Berserk();
    Demo();
    Firebug();
    Medic();
    Shotty();
}

simulated exec function KillRecoil()
{
    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).maxRecoilPitch = 0;
        KFWeapon(Outer.Pawn.Weapon).minRecoilPitch = 0;
        KFWeapon(Outer.Pawn.Weapon).maxRecoilYaw = 0;
        KFWeapon(Outer.Pawn.Weapon).minRecoilYaw = 0;
        Outer.ClientMessage("Recoil Disabled", CheatType);
    }
}

simulated exec function WeapFOV(float NewFOV, optional bool bScaleByAspectRatio)
{
    local float AdjustedFOV;

    bScaleByAspectRatio = true;
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        if(bScaleByAspectRatio)
        {
            AdjustedFOV = KFPlayerController(Outer).CalcFOVForAspectRatio(NewFOV, Outer.myHUD.SizeX, Outer.myHUD.SizeY);            
        }
        else
        {
            AdjustedFOV = NewFOV;
        }
        KFWeapon(Outer.Pawn.Weapon).SetFOV(AdjustedFOV);
    }
}

simulated exec function ToggleDoF()
{
    KFPlayerController(Outer).EnableDepthOfField(!KFPlayerController(Outer).bDOFEnabled);
}

simulated exec function ShowDownloadPopup()
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    KFPC.ShowConnectionProgressPopup(3, "Fake download", "Not actually downloading");
}

simulated exec function BackgroundBlur(bool bBlur)
{
    local KFPlayerController KFPC;
    local KFPawn KFP;

    KFPC = KFPlayerController(Outer);
    KFP = KFPawn(Outer.Pawn);
    if(bBlur)
    {
        KFPC.EnableBlur(true, 6, 1, 1);        
        KFPC.ConsoleCommand("PlayersOnly");
        KFPC.EnableReflections(false);
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(false);
            KFP.DetachComponent(KFP.ArmsMesh);
        }        
    }
    else
    {
        KFPC.EnableBlur(false, 0, 1, 1);        
        KFPC.ConsoleCommand("PlayersOnly");
        KFPC.EnableReflections(true);
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(true);
            KFP.AttachComponent(KFP.ArmsMesh);
        }
    }
}

exec function ShowHands(bool bShow)
{
    local KFPlayerController KFPC;
    local KFPawn KFP;

    KFPC = KFPlayerController(Outer);
    KFP = KFPawn(Outer.Pawn);
    if(!bShow)
    {
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(false);
            KFP.DetachComponent(KFP.ArmsMesh);
        }        
    }
    else
    {
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(true);
            KFP.AttachComponent(KFP.ArmsMesh);
        }
    }
}

simulated exec function ScaleShootCameraAnims(float NewScale)
{
    local int I;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastAnim, NewScale);
        I = 0;
        J0x19F:

        if(I < KFWeapon(Outer.Pawn.Weapon).FireSightedAnims.Length)
        {
            SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireSightedAnims[I], NewScale);
            ++ I;
            goto J0x19F;
        }
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireScopedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopScopedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastScopedAnim, NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst2', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst2_Iron', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst_Iron', NewScale);
    }
}

simulated exec function RestoreShootCameraAnims()
{
    local int I;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastAnim);
        I = 0;
        J0x184:

        if(I < KFWeapon(Outer.Pawn.Weapon).FireSightedAnims.Length)
        {
            RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireSightedAnims[I]);
            ++ I;
            goto J0x184;
        }
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireScopedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopScopedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastScopedAnim);
        RestoreWeaponCameraAnimScale('Shoot_Burst2');
        RestoreWeaponCameraAnimScale('Shoot_Burst');
        RestoreWeaponCameraAnimScale('Shoot_Burst2_Iron');
        RestoreWeaponCameraAnimScale('Shoot_Burst_Iron');
    }
}

simulated function SetWeaponCameraAnimScale(name CameraAnimName, float NewScale)
{
    local AnimSequence AnimSeq;
    local int I;
    local KFAnimNotify_CameraAnim CameraAnim;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        AnimSeq = KFWeapon(Outer.Pawn.Weapon).MySkelMesh.FindAnimSequence(CameraAnimName);
        if(AnimSeq != none)
        {
            I = 0;
            J0xFC:

            if(I < AnimSeq.Notifies.Length)
            {
                CameraAnim = KFAnimNotify_CameraAnim(AnimSeq.Notifies[I].Notify);
                if(CameraAnim != none)
                {
                    CameraAnim.CameraAnimScale = NewScale;
                }
                ++ I;
                goto J0xFC;
            }
        }
    }
}

simulated function RestoreWeaponCameraAnimScale(name CameraAnimName)
{
    local AnimSequence AnimSeq;
    local int I;
    local KFAnimNotify_CameraAnim CameraAnim;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        AnimSeq = KFWeapon(Outer.Pawn.Weapon).MySkelMesh.FindAnimSequence(CameraAnimName);
        if(AnimSeq != none)
        {
            I = 0;
            J0xFC:

            if(I < AnimSeq.Notifies.Length)
            {
                CameraAnim = KFAnimNotify_CameraAnim(AnimSeq.Notifies[I].Notify);
                if(CameraAnim != none)
                {
                    CameraAnim.CameraAnimScale = CameraAnim.default.CameraAnimScale;
                }
                ++ I;
                goto J0xFC;
            }
        }
    }
}

simulated exec function DramaEvent(float Chance, optional float Duration, optional bool bPartial)
{
    Duration = 3;    
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        Outer.ClientMessage((("DramaEvent Chance = " $ string(Chance)) $ " Duration = ") $ string(Duration), CheatType);
        KFPlayerController(Outer).bForcePartialZedTime = bPartial;
        KFGameInfo(Outer.WorldInfo.Game).DramaticEvent(Chance, Duration);
        KFPlayerController(Outer).bForcePartialZedTime = KFPlayerController(Outer).default.bForcePartialZedTime;
    }
}

exec function TestCheat()
{
    LogInternal("Cheat Manager works!");
}

exec function ImRich()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.AddDosh(1000000);
    }
}

exec function DoshMe(int NewDoshAmount)
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        NewDoshAmount = int(float(NewDoshAmount) - KFPRI.Score);
        KFPRI.AddDosh(NewDoshAmount);
    }
}

exec function HurtMe(optional int DamageAmount)
{
    DamageAmount = 50;
    if(Outer.Pawn != none)
    {
        Outer.Pawn.TakeDamage(DamageAmount, Outer.Pawn.Controller, vect(0, 0, 0), vect(0, 0, 0), none);
    }
}

exec function DoTMe(optional int DamageAmount)
{
    DamageAmount = 50;
    KFPawn(Outer.Pawn).ApplyDamageOverTime(DamageAmount, Outer.Pawn.Controller, Class'KFDT_Fire');
}

exec function HealMe(optional int HealAmount)
{
    HealAmount = 50;
    if(Outer.Pawn != none)
    {
        Outer.Pawn.HealDamage(HealAmount, Outer.Pawn.Controller, none);
    }
}

exec function ArmorMe(optional int ArmorAmount)
{
    ArmorAmount = 50;
    if((Outer.Pawn != none) && KFPawn_Human(Outer.Pawn) != none)
    {
        KFPawn_Human(Outer.Pawn).AddArmor(ArmorAmount);
    }
}

exec function PlayMuzzleFlash()
{
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFP.WeaponAttachment.MuzzleFlash.CauseMuzzleFlash();
    }
}

exec function PlayShellEject()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(KFW.MuzzleFlash != none)
        {
            KFW.MuzzleFlash.CauseShellEject();
        }
    }
}

exec function SpamShellEject(optional float LifeParam, optional float interval)
{
    local KFWeapon KFW;

    LifeParam = 0;
    interval = 0.05;
    if(Outer.IsTimerActive('PlayShellEject', self))
    {
        Outer.ClearTimer('PlayShellEject', self);
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(KFW.MuzzleFlash == none)
        {
            KFW.AttachMuzzleFlash();
        }
        if((KFW.MuzzleFlash != none) && LifeParam > 0)
        {
            KFW.MuzzleFlash.SetShellEjectLife(LifeParam);
        }
    }
    Outer.SetTimer(interval, true, 'PlayShellEject', self);
}

simulated exec function TestHitZones()
{
    local Actor TestActor;
    local Vector HitLocation, HitNormal, TraceStart, TraceEnd;
    local TraceHitInfo CurrentImpact;

    TraceStart = Outer.PlayerCamera.CameraCache.POV.Location;
    TraceEnd = Outer.PlayerCamera.CameraCache.POV.Location + (vector(Outer.PlayerCamera.CameraCache.POV.Rotation) * float(2000));
    foreach Outer.Pawn.TraceActors(Class'Actor', TestActor, HitLocation, HitNormal, TraceEnd, TraceStart,, CurrentImpact, Outer.1)
    {
        if(TestActor.bBlockActors || TestActor.bProjTarget)
        {
            LogInternal((((("Hit this: " $ string(TestActor)) $ " ") $ string(CurrentImpact.HitComponent)) $ " ") $ string(CurrentImpact.BoneName));
        }        
    }    
}

simulated exec function SpawnFlare(optional float NewBrightness, optional float NewRadius, optional byte R, optional byte G, optional byte B)
{
    local KFDebugFlare NewFlare;

    NewBrightness = 1;
    NewRadius = 512;
    R = 255;
    G = 255;
    B = 255;
    if((Outer.Pawn == none) || Outer.Pawn.Weapon == none)
    {
        return;
    }
    NewFlare = Outer.Pawn.Spawn(Class'KFDebugFlare',,, Outer.Pawn.Weapon.GetPhysicalFireStartLoc());
    if(NewFlare != none)
    {
        NewFlare.Velocity = (500 * vector(Outer.Pawn.Rotation)) + (vect(0, 0, 1) * 150);
        NewFlare.FlareLight.SetLightProperties(NewBrightness, MakeColor(R, G, B));
        NewFlare.FlareLight.Radius = NewRadius;
    }
}

exec function KillFlares()
{
    local KFDebugFlare Flare;

    foreach Outer.Pawn.DynamicActors(Class'KFDebugFlare', Flare)
    {
        Flare.Destroy();        
    }    
}

exec function AllAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.AmmoCount[0] = byte(KFW.MagazineCapacity[0]);
        KFW.AddAmmo(KFW.MaxSpareAmmo[0]);
        KFW.AddSecondaryAmmo(KFW.MagazineCapacity[1]);        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).AddGrenades(100);
    }
}

exec function UberAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.SpareAmmoCount[0] = KFW.MaxSpareAmmo[0] * 3;
        KFW.AmmoCount[0] = byte(KFW.MagazineCapacity[0]);
        KFW.AmmoCount[1] = byte(KFW.MagazineCapacity[1]);
        KFW.bInfiniteAmmo = true;        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).GrenadeCount = 255;
    }
}

exec function NoAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.SpareAmmoCount[0] = 0;
        KFW.AmmoCount[0] = 0;
        KFW.AmmoCount[1] = 0;
        KFW.bInfiniteAmmo = false;        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).GrenadeCount = 0;
    }
}

exec function ToggleWeapCanPause()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.bPauseWithPlayersOnly = !KFW.bPauseWithPlayersOnly;
    }
}

exec function SetDebugRecoil3d(bool bNewDebug)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.bDebugRecoilPosition = bNewDebug;
    }
}

exec function SetIronIdleAnims(bool bNewUseAnims)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(bNewUseAnims)
        {
            KFW.IdleSightedAnims[0] = 'None';            
        }
        else
        {
            KFW.IdleSightedAnims[0] = KFW.default.IdleSightedAnims[0];
        }
    }
}

exec function SetISMeshCompScale(float DebugScale)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.IronSightMeshFOVCompensationScale = DebugScale;
    }
}

exec function NoRecoil()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.maxRecoilPitch = 0;
        KFW.minRecoilPitch = 0;
        KFW.maxRecoilYaw = 0;
        KFW.minRecoilYaw = 0;
        Outer.ClientMessage("Recoil Disabled", CheatType);
    }
}

exec function GoRecoil()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.maxRecoilPitch = KFW.default.maxRecoilPitch;
        KFW.minRecoilPitch = KFW.default.minRecoilPitch;
        KFW.maxRecoilYaw = KFW.default.maxRecoilYaw;
        KFW.minRecoilYaw = KFW.default.minRecoilYaw;
        Outer.ClientMessage("Recoil Enabled", CheatType);
    }
}

exec function ShowTraderPath()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenedTrader.ShowTraderPath();
}

exec function HideTraderPath()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenedTrader.HideTraderPath();
}

exec function OpenTrader()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenTrader(300);
}

exec function OpenTraderNext()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenTraderNext(300);
}

exec function OpenTraderMenu()
{
    KFPlayerController(Outer).OpenTraderMenu();
}

exec function FPDL()
{
    Outer.FlushPersistentDebugLines();
}

exec function GoToActor(name actorName)
{
    local Actor A;

    foreach Outer.AllActors(Class'Actor', A)
    {
        if(A.Name == actorName)
        {
            Ghost();
            Outer.Pawn.SetLocation(A.Location);
        }        
    }    
}

exec function AIHelp()
{
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
    if(true)
    {
        LogInternal("AI Debug Commands");
    }
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
    if(true)
    {
        LogInternal("	AIDEBUG					Makes AI non-aggressive and ready to receive debug commands");
    }
    if(true)
    {
        LogInternal(" AISETCANATTACK True/False Sets whether the debug mode pawn should be capable of attacking you");
    }
    if(true)
    {
        LogInternal("	TOGGLEALLNPCDEBUG		Renders names, some vital info, and a health bar above NPC heads");
    }
    if(true)
    {
        LogInternal("	AISTEPASIDE				Forces StepAside AI Command");
    }
    if(true)
    {
        LogInternal("	AITOGGLEHEADTRACKING	Toggles AI HeadTracking");
    }
    if(true)
    {
        LogInternal("	AIDEBUGTURNINPLACE		Starts TurnInPlace debug command - AI will constantly turn to player");
    }
    if(true)
    {
        LogInternal("	AITAUNT					Forces AI to execute a taunt command");
    }
    if(true)
    {
        LogInternal("	AIPATHTO <name>			AI will attempt to move/path to KFPathnode with DebugTagName matching <name>");
    }
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
}

exec function AIHuskFlamethrower()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if((((KFAIC != none) && KFAIC.Pawn != none) && KFAIC.Pawn.Health > 0) && KFAIC.Pawn.IsA('KFPawn_ZedHusk'))
    {
        KFAIC.MovementPlugin.DisablePlugin();
        KFPawn(KFAIC.Pawn).DoSpecialMove(18, true, Outer.Pawn, 255);        
    }
    else
    {
        Outer.ClientMessage("You must be aiming toward a living Husk to execute this command.", CheatType);
    }
}

exec function DrawLineFromNPC(optional float Length)
{
    local KFDebugLines KFDL;
    local KFAIController KFAIC;

    Length = 500;
    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(KFAIC.Pawn.Location, 32, 8, 0, 255, 0, true);
        KFDL.AddDebugLine(KFAIC.Pawn.Location, KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * Length), 255, 0, 0, true);
        KFDL.AddDebugText3D(KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * (Length * 0.5)), string(Length) @ "Units", true, 0, 0, 255, true);
    }
}

exec function SlasherTaunt(optional bool bSlow)
{
    local KFPawn_Monster KFPM;
    local bool bFound;

    bSlow = true;
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(((KFPM.MyKFAIC != none) && KFPM.IsA('KFPawn_ZedClot_Slasher')) && KFPM.IsAliveAndWell())
        {
            Class'AICommand_TauntEnemy'.static.Taunt(KFPM.MyKFAIC, KFPawn(Outer.Pawn), 1);
            bFound = true;
        }        
    }    
    if(!bFound)
    {
        SpawnDebugAI("ClotS");
        foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
        {
            if(((KFPM.MyKFAIC != none) && KFPM.IsA('KFPawn_ZedClot_Slasher')) && KFPM.IsAliveAndWell())
            {
                Class'AICommand_TauntEnemy'.static.Taunt(KFPM.MyKFAIC, KFPawn(Outer.Pawn), 1);
                bFound = true;
            }            
        }        
    }
    if(bFound && bSlow)
    {
        Outer.SetTimer(2.5, false, 'SlasherTauntTimer', self);
    }
}

function SlasherTauntTimer()
{
    KFGameInfo(Outer.WorldInfo.Game).DramaticEvent(1, 13);
}

exec function AIShowAnchor()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        KFAIC.bDebug_DrawAnchor = !KFAIC.bDebug_DrawAnchor;
        if(KFAIC.bDebug_DrawAnchor)
        {
            Outer.ClientMessage(("Rendering line to " $ string(KFAIC.Pawn)) $ "'s anchor.", CheatType);
        }
    }
}

exec function AIDebugFloor()
{
    local KFAIController KFAIC;
    local Vector Start, End;

    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        Start = KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * 64);
        End = Start + (Outer.Pawn.Floor * 512);
        Outer.DrawDebugLine(Start, End, 0, 0, 255, true);
        Outer.DrawDebugSphere(End, 24, 8, 0, 0, 255, true);
    }
}

exec function Puke(optional int SeqNum, optional bool bLooping)
{
    local KFPawn_Monster KFPM;
    local name SeqName;

    bLooping = true;
    if(SeqNum == 1)
    {
        SeqName = 'Atk_Vomit_V3';        
    }
    else
    {
        if(SeqNum == 2)
        {
            SeqName = 'Atk_Vomit_Move_V1';            
        }
        else
        {
            SeqName = 'Atk_Vomit_V1';
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if((((KFPM.IsA('KFPawn_ZedBloat') && KFPM.IsAliveAndWell()) && KFPM.MyKFAIC != none) && KFPM.MyKFAIC.bHasDebugCommand) && KFPM.PawnAnimInfo != none)
        {
            KFPM.PlayBodyAnim(SeqName, 0,,,, bLooping);
        }        
    }    
}

exec function AIHeadlessWander()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            KFPM.Health = 15;
            KFPM.CauseHeadTrauma();
        }        
    }    
}

exec function ShowBlockedPaths(optional bool bSkipWalls, optional bool bRenderResult, optional bool bLogResult, optional float WithinPawnRadius)
{
    local KFPawn_Monster KFMP;
    local KFAIController KFAIC;
    local NavigationPoint N;
    local int SpecIdx, LocalBlockedSpecIdx, RouteCacheIdx, Cost, BlockedCount, Total;

    local bool bInBlockedPathList;
    local string BlockedStr;
    local float BlockedTimeRemaining;

    bSkipWalls = true;
    bRenderResult = true;
    bLogResult = true;
    WithinPawnRadius = 0;
    if(!bRenderResult && !bLogResult)
    {
        bRenderResult = true;
    }
    KFMP = GetKFMPFromAim();
    if((KFMP != none) && KFMP.MyKFAIC != none)
    {
        KFAIC = KFMP.MyKFAIC;
        if(bLogResult)
        {
            LogInternal("===============================================================================");
            LogInternal((((((((((("Blocked paths for " $ string(KFMP)) $ " <") $ string(KFMP.MyKFAIC)) $ "> at ") $ string(KFMP.Location)) $ " [NPC Radius: ") $ string(KFMP.GetCollisionRadius())) $ " Height: ") $ string(KFMP.GetCollisionHeight())) $ "] Time: ") $ string(Outer.WorldInfo.TimeSeconds));
            LogInternal(" ");
        }
        foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', N)
        {
            if((WithinPawnRadius > 0) && VSize(N.Location - KFMP.Location) > WithinPawnRadius)
            {
                continue;                
            }
            if(bLogResult)
            {
                LogInternal("   Checking " $ string(N));
                LogInternal((((("    bBlocked:" $ string(N.bBlocked)) $ " bOneWayPath:") $ string(N.bOneWayPath)) $ " ExtraCost: ") $ string(N.ExtraCost));
                if(N.AnchoredPawn != none)
                {
                    LogInternal((("    AnchoredPawn:" $ string(N.AnchoredPawn)) $ " LastAnchoredPawnTime:") $ string(N.LastAnchoredPawnTime));
                }
            }
            if(N.bBlocked && bRenderResult)
            {
                Outer.DrawDebugSphere(N.Location, 24, 6, 255, 0, 0, true);
            }
            SpecIdx = 0;
            J0x4D1:

            if(SpecIdx < N.PathList.Length)
            {
                bInBlockedPathList = false;
                BlockedTimeRemaining = 0;
                ++ Total;
                Cost = N.PathList[SpecIdx].GetCostFor(KFMP);
                LocalBlockedSpecIdx = 0;
                J0x580:

                if(LocalBlockedSpecIdx < KFAIC.BlockedPathList.Length)
                {
                    if(N.PathList[SpecIdx] == KFAIC.BlockedPathList[LocalBlockedSpecIdx].BlockedReachSpec)
                    {
                        bInBlockedPathList = true;
                        BlockedTimeRemaining = KFAIC.BlockedPathList[LocalBlockedSpecIdx].BlockedTime;
                        goto J0x677;
                    }
                    ++ LocalBlockedSpecIdx;
                    goto J0x580;
                }
                J0x677:

                if((bInBlockedPathList || N.bBlocked) || Cost >= N.PathList[SpecIdx].10000000)
                {
                    ++ BlockedCount;
                    if(bLogResult)
                    {
                        LogInternal(((((((((("  Found blocked path for " $ string(KFMP)) $ " in NavPoint ") $ string(N)) $ " [bBlocked:") $ string(N.bBlocked)) $ "][OneWay:") $ string(N.bOneWayPath)) $ "][ExtraCost:") $ string(N.ExtraCost)) $ "]");
                        if(N.AnchoredPawn != none)
                        {
                            LogInternal((("   " $ string(N)) $ "'s anchored pawn is ") $ string(N.AnchoredPawn));
                        }
                        BlockedStr = ((((((((((("		**** Path from " $ string(N)) $ " to ") $ string(N.PathList[SpecIdx].End.Actor)) $ " [Cost:") $ string(Cost)) $ " Start:") $ string(N.PathList[SpecIdx].Start)) $ " End:") $ string(N.PathList[SpecIdx].End.Actor)) $ " ReachFlags:") $ string(N.PathList[SpecIdx].reachFlags)) $ "] is blocked ";
                        if(bInBlockedPathList)
                        {
                            BlockedStr = ((((BlockedStr $ "(ReachSpec Found In ") $ string(KFAIC)) $ " BlockedPathList [TimeRemaining:") $ string(BlockedTimeRemaining)) $ " seconds]) ";
                        }
                        if(N.bBlocked)
                        {
                            BlockedStr = ((BlockedStr $ "(") $ string(N)) $ " bBlocked is TRUE) ";
                        }
                        LogInternal(BlockedStr);
                        LogInternal((((((("		  Max Radius:" $ string(N.PathList[SpecIdx].CollisionRadius)) $ " Max Height:") $ string(N.PathList[SpecIdx].CollisionHeight)) $ " MaxLandingVelocity:") $ string(N.PathList[SpecIdx].MaxLandingVelocity)) $ " bCanCutCorners:") $ string(N.PathList[SpecIdx].bCanCutCorners));
                        RouteCacheIdx = 0;
                        J0xC56:

                        if(RouteCacheIdx < KFAIC.RouteCache.Length)
                        {
                            if(KFAIC.RouteCache[RouteCacheIdx] == N)
                            {
                                LogInternal(((((("		  Found " $ string(N)) $ " in ") $ string(KFAIC)) $ "'s routecache [Slot ") $ string(RouteCacheIdx)) $ "]");
                                goto J0xD25;
                            }
                            ++ RouteCacheIdx;
                            goto J0xC56;
                        }
                    }
                    J0xD25:

                    if(bRenderResult)
                    {
                        Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 255, 0, 0, true);
                    }
                }
                ++ SpecIdx;
                goto J0x4D1;
            }
            if(bLogResult)
            {
                LogInternal("-------------------------------------------------------------------------------");
            }            
        }        
        if(bLogResult)
        {
            LogInternal(" ");
            LogInternal((((("	  Found " $ string(BlockedCount)) $ " blocked paths (out of ") $ string(Total)) $ " checked) for ") $ string(KFMP));
            LogInternal("===============================================================================");
        }
    }
}

exec function ShowReachSpecsFor(name ZedType, optional bool bShowBlocked)
{
    local NavigationPoint N;
    local int SpecIdx;
    local float Radius, Height;
    local KFPawn Spawned;
    local bool bShowWallPaths;

    bShowBlocked = true;
    switch(ZedType)
    {
        case 'FP':
            Spawned = SpawnZed("FP",, true);
            break;
        default:
            bShowWallPaths = true;
            Spawned = SpawnZed("CR",, true);
            break;
    }
    if(Spawned != none)
    {
        Radius = Spawned.GetCollisionRadius();
        Height = Spawned.GetCollisionHeight();
    }
    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', N)
    {
        if(!bShowWallPaths && KFWallPathNode(N) != none)
        {
            continue;            
        }
        SpecIdx = 0;
        J0x14E:

        if(SpecIdx < N.PathList.Length)
        {
            if((float(N.PathList[SpecIdx].CollisionRadius) >= Radius) && float(N.PathList[SpecIdx].CollisionHeight) >= Height)
            {
                Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 0, 255, 0, true);                
            }
            else
            {
                if(bShowBlocked)
                {
                    Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 255, 0, 0, true);
                }
            }
            ++ SpecIdx;
            goto J0x14E;
        }        
    }    
    if(Spawned != none)
    {
        Spawned.Destroy();
    }
}

exec function DumpDebugNodes()
{
    local KFPathnode KFPN;

    foreach Outer.WorldInfo.AllActors(Class'KFPathnode', KFPN)
    {
        if(KFPN.DebugTag != 'None')
        {
            LogInternal((((("Found " $ string(KFPN)) $ " with DebugTag ") $ string(KFPN.DebugTag)) $ " at ") $ string(KFPN.Location));
        }        
    }    
}

exec function GotoDebugNode(name TagName)
{
    local KFPathnode KFPN;

    foreach Outer.WorldInfo.AllActors(Class'KFPathnode', KFPN)
    {
        if((KFPN.DebugTag != 'None') && KFPN.DebugTag == TagName)
        {
            if(Outer.bCollideWorld)
            {
                Ghost();
            }
            if(!Outer.Pawn.SetLocation(KFPN.Location + vect(0, 0, 32)))
            {
                Outer.ClientMessage("Ghost mode is on, but I failed to set your location!", CheatType);
                continue;
            }
            Outer.ClientMessage(((("Teleported to " $ string(KFPN)) $ "'s location [") $ string(KFPN.Location)) $ "] - Ghost Mode is on", CheatType);
        }        
    }    
}

exec function ShowDebugNodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local float WidestRadius;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if((NP.DebugTag != 'None') && NP.DebugTag != NP.Class.Name)
            {
                if(bOn)
                {
                    I = 0;
                    J0x107:

                    if(I < NP.PathList.Length)
                    {
                        if((WidestRadius == 0) || float(NP.PathList[I].CollisionRadius) < WidestRadius)
                        {
                            WidestRadius = float(NP.PathList[I].CollisionRadius);
                        }
                        ++ I;
                        goto J0x107;
                    }
                    KFDL.AddDebugSphere(NP.Location, WidestRadius, 8, 0, 255, 0, false, 120);
                    KFDL.AddDebugText3D(NP.Location + vect(0, 0, 12), (string(NP) $ ": ") $ string(NP.DebugTag), true, 20, 70, 150, false, 120);
                    WidestRadius = 0;
                    continue;
                }
                KFDL.ClearAll();
            }            
        }        
    }
}

exec function AISetPeriph(float NewPeripheralVision)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.MyKFPawn.PeripheralVision = NewPeripheralVision;
    Outer.ClientMessage((string(KFAIC.MyKFPawn) $ "'s peripheral vision is now ") $ string(KFAIC.MyKFPawn.PeripheralVision), CheatType);
}

exec function AIDebugVision()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if(!KFAIC.bHasDebugCommand)
    {
        Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " must have a controller in debug mode first!", CheatType);
    }
    AICommand_Debug(KFAIC.GetActiveCommand()).Debug_Vision(Outer.Pawn);
}

exec function AISetSightRadius(float NewSightRadius)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.MyKFPawn.SightRadius = NewSightRadius;
    Outer.ClientMessage((string(KFAIC.MyKFPawn) $ "'s sightradius is now ") $ string(KFAIC.MyKFPawn.PeripheralVision), CheatType);
}

exec function PathInfo()
{
    Outer.ClientMessage("Paths last built: " $ Outer.WorldInfo.LastSuccessfulPathBuildTime, CheatType);
}

exec function AIDebugMode(optional bool bDebugMode)
{
    local KFGameInfo KFG;
    local KFAIDirector AIManager;

    bDebugMode = true;
    KFG = KFGameInfo(Outer.WorldInfo.Game);
    if(KFG != none)
    {
        AIManager = KFG.GetAIDirector();
        if(AIManager != none)
        {
            AIManager.SetAIDebug(bDebugMode);
            if(bDebugMode)
            {
                Outer.ClientMessage("Debug mode turned on for active NPCs, and new NPCs will spawn in debug mode.", CheatType);                
            }
            else
            {
                Outer.ClientMessage("Debug mode turned off for active NPCs, and new NPCs will no longer spawn in debug mode.", CheatType);
            }
        }
    }
}

exec function ShowDebugStrikeRanges(optional bool bShowAll)
{
    bShowAll = false;    
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowStrikeRange true");
    if(bShowAll)
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange true");        
    }
    else
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange false");
    }
}

exec function HideDebugStrikeRanges()
{
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowStrikeRange false");    
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange false");
}

exec function AIDebug(optional bool bAllZeds)
{
    local KFAIController KFAIC;

    bAllZeds = false;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
        {
            if(bAllZeds || Outer.IsAimingAt(KFAIC.Pawn, 0.95))
            {
                KFAIC.StopAllLatentMovement();
                KFAIC.AbortMovementCommands();
                KFAIC.AbortMovementPlugIns();
                KFAIC.BeginDebugCommand();
            }
        }        
    }    
}

exec function AIFlee(optional float FleeDuration, optional float FleeDistance)
{
    local KFAIController KFAIC;

    FleeDistance = 5000;
    KFAIC = GetKFAICFromAim();
    if(KFAIC != none)
    {
        KFAIC.DoFleeFrom(GetMyPawn(), FleeDuration, FleeDistance);
    }
}

exec function AIWander(optional bool bWanderTowardMe, optional bool bWanderAwayFromMe, optional float WanderDuration, optional float MaxWanderDistance)
{
    local KFAIController KFAIC;

    WanderDuration = -1;
    MaxWanderDistance = 10000;
    KFAIC = GetKFAICFromAim();
    if(KFAIC != none)
    {
        if(bWanderTowardMe || bWanderAwayFromMe)
        {
            KFAIC.DoWander(GetMyPawn(), WanderDuration, bWanderAwayFromMe, MaxWanderDistance);            
        }
        else
        {
            KFAIC.DoWander(,, WanderDuration, false, MaxWanderDistance);
        }
    }
}

exec function AIDebugSteering()
{
    local AICommand_Debug DebugCommand;

    DebugCommand = GetDebugAICommand();
    if(DebugCommand != none)
    {
        DebugCommand.Debug_Steering();
    }
}

exec function AIDebugStepAside(optional bool bOn)
{
    local AICommand_Debug DebugCommand;

    bOn = true;
    DebugCommand = GetDebugAICommand();
    if(DebugCommand != none)
    {
        DebugCommand.Debug_StepAside(bOn);
    }
}

exec function ShowAIStuckNpcsToggle()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.ShowStuckNpcsToggle();        
    }    
}

exec function ToggleShowVisualStuckZedDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowVisualStuckZedDebugInfo = !KFGameInfo.AIDirector.bShowVisualStuckZedDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowVisualStuckZedDebugInfo = !KFAIC.bShowVisualStuckZedDebugInfo;
        LogInternal("ToggleShowVisualStuckZedDebugInfo - " @ string(KFAIC.bShowVisualStuckZedDebugInfo));        
    }    
}

exec function ToggleShowMovePointsDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowMovePointsDebugInfo = !KFGameInfo.AIDirector.bShowMovePointsDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowMovePointsDebugInfo = !KFAIC.bShowMovePointsDebugInfo;
        LogInternal("ToggleShowMovePointsDebugInfo - " @ string(KFAIC.bShowMovePointsDebugInfo));        
    }    
}

exec function ToggleShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = !KFGameInfo.AIDirector.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = !KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
        LogInternal("ToggleShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState - " @ string(KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState));        
    }    
}

exec function ToggleShowHighDetailCombatMovementDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowHighDetailCombatMovementDebugInfo = !KFGameInfo.AIDirector.bShowHighDetailCombatMovementDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowHighDetailCombatMovementDebugInfo = !KFAIC.bShowHighDetailCombatMovementDebugInfo;
        LogInternal("ToggleShowVisualStuckZedDebugInfo - " @ string(KFAIC.bShowHighDetailCombatMovementDebugInfo));        
    }    
}

exec function ToggleShowLeapDownDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowLeapDownDebugArtifacts = !KFGameInfo.AIDirector.bShowLeapDownDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowLeapDownDebugArtifacts = !KFAIC.bShowLeapDownDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowLeapDownDebugArtifacts));        
    }    
}

exec function ToggleShowDoorNavigationDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowDoorNavigationDebugArtifacts = !KFGameInfo.AIDirector.bShowDoorNavigationDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowDoorNavigationDebugArtifacts = !KFAIC.bShowDoorNavigationDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowDoorNavigationDebugArtifacts));        
    }    
}

exec function ToggleShowDestructibleNavigationDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowDestructibleNavigationDebugArtifacts = !KFGameInfo.AIDirector.bShowDestructibleNavigationDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowDestructibleNavigationDebugArtifacts = !KFAIC.bShowDestructibleNavigationDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowDestructibleNavigationDebugArtifacts));        
    }    
}

exec function CheckReachSpecs()
{
    local NavigationPoint NP;
    local int I, X, iCount;
    local array<NavigationPoint> Templist;

    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', NP)
    {
        I = 0;
        J0x54:

        if(I < NP.PathList.Length)
        {
            if(NP.PathList[I].End.Actor == none)
            {
                LogInternal((((string(NP) $ " FOUND NO END FOR REACHSPEC ") $ string(NP.PathList[I])) $ " in slot ") $ string(I));
            }
            Templist.AddItem(NavigationPoint(NP.PathList[I].End.Actor);
            ++ I;
            goto J0x54;
        }
        X = 0;
        J0x1CA:

        if(X < NP.PathList.Length)
        {
            iCount = 0;
            I = 0;
            J0x20D:

            if(I < Templist.Length)
            {
                if(NavigationPoint(NP.PathList[X].End.Actor) == Templist[I])
                {
                    if(iCount > 0)
                    {
                        LogInternal((((("FOUND DUPE REACHSPEC (" $ string(NP.PathList[X])) $ " IN ") $ string(NP)) $ " LEADING TO ") $ string(Templist[I]));
                    }
                    ++ iCount;
                }
                ++ I;
                goto J0x20D;
            }
            ++ X;
            goto J0x1CA;
        }
        Templist.Length = 0;        
    }    
}

function KFAIController GetKFAICFromAim(optional bool bOnlyPawnsWithDebug, optional float Epsilon)
{
    local KFPawn_Monster KFPM;

    Epsilon = 0.92;
    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none) && Outer.IsAimingAt(KFPM, Epsilon))
        {
            if(bOnlyPawnsWithDebug && !KFPM.MyKFAIC.bHasDebugCommand)
            {
                continue;                
            }            
            return KFPM.MyKFAIC;
        }        
    }    
    return none;
}

function KFPawn_Monster GetKFMPFromAim(optional bool bOnlyPawnsWithDebug)
{
    local KFPawn_Monster KFPM;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && Outer.IsAimingAt(KFPM, 0.95))
        {
            if((KFPM.MyKFAIC != none) && bOnlyPawnsWithDebug && !KFPM.MyKFAIC.bHasDebugCommand)
            {
                continue;                
            }            
            return KFPM;
        }        
    }    
    return none;
}

exec function ToggleDebugCamera(optional bool bDrawDebugText)
{
    bDrawDebugText = true;
    Outer.bGodMode = true;
    super.ToggleDebugCamera(bDrawDebugText);
}

exec function TDC(optional bool bDrawDebugText)
{
    bDrawDebugText = true;
    ToggleDebugCamera(bDrawDebugText);
}

function EnableDebugCamera(bool bEnableDebugText)
{
    super.EnableDebugCamera(bEnableDebugText);
    KFDebugCameraController(DebugCameraControllerRef).bDebugSceneEnabled = bDebugSceneEnabled;
    KFDebugCameraController(DebugCameraControllerRef).DebugSceneCamera = DebugSceneCamera;
    KFDebugCameraController(DebugCameraControllerRef).DebugTarget = DebugTarget;
}

exec function DumpInfoForAI(optional bool bOutputToConsole)
{
    local float TimeSinceLastRender;
    local string Info;
    local KFAIController KFAIC;

    bOutputToConsole = true;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        TimeSinceLastRender = Outer.WorldInfo.TimeSeconds - KFAIC.Pawn.LastRenderTime;
        Info = (((((((((((Info $ " 
... ") $ string(KFAIC)) @ string(KFAIC.Pawn)) $ "(ActvCmd:") $ KFAIC.GetActionString()) $ ")  -- TimeSinceLastRender:") @ string(TimeSinceLastRender)) @ "Enemy:") @ string(KFAIC.Enemy)) @ "AILoc:") @ string(KFAIC.Pawn.Location)) $ "
";        
    }    
    if((bOutputToConsole && Outer.Player != none) && LocalPlayer(Outer.Player) != none)
    {
        LocalPlayer(Outer.Player).ViewportClient.ViewportConsole.OutputText(Info);
    }
    LogInternal(Info);
}

exec function ViewSelf(optional bool bQuiet)
{
    if((Outer.ViewTarget != none) && KFPawn_Monster(Outer.ViewTarget) != none)
    {
        KFPawn_Monster(Outer.ViewTarget).SetDebugTextRendering(false);
        SetNPCDebugCategory(false, 'AICommands');
    }
    super(CheatManager).ViewSelf(bQuiet);
}

exec function ViewZed(optional bool bLogBugItInfo)
{
    local Actor first;
    local bool bFound;
    local KFAIController C;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', C)
    {
        if((C.Pawn != none) && C.Pawn.Health > 0)
        {
            if(bFound || first == none)
            {
                first = C.Pawn;
                if(bFound)
                {
                    break;
                }
            }
            if((C.PlayerReplicationInfo == Outer.RealViewTarget) || C.Pawn == Outer.ViewTarget)
            {
                bFound = true;
            }
        }        
    }    
    if(first != none)
    {
        LogInternal("view " $ string(first));
        Outer.SetViewTarget(first);
        Outer.SetCameraMode('FreeCam');
        KFPawn_Monster(first).SetDebugTextRendering(true);
        SetNPCDebugCategory(true, 'AICommands');
        Outer.FixFOV();
        if(bLogBugItInfo)
        {
            Outer.BugItAI((((("Viewing from " $ string(first)) $ ", health: ") $ string(Pawn(first).Health)) $ " command: ") $ string(KFPawn_Monster(first).MyKFAIC.GetActiveCommand()));
        }
        Outer.ClientMessage(("Viewing from " $ string(first)) $ ", type 'ViewSelf' to return to your body. Type 'Camera first' to switch to first-person.", CheatType);        
    }
    else
    {
        ViewSelf(true);
    }
}

exec function TeleportPawnToCamera(optional bool bToggleDebugCameraOff)
{
    bToggleDebugCameraOff = false;
    super.TeleportPawnToCamera(bToggleDebugCameraOff);
}

exec function AIMoveForward()
{
    GetDebugAICommand().Debug_MoveForward();
}

exec function AIHide_Debug()
{
    local KFPawn_Monster KFPM;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none) && Outer.IsAimingAt(KFPM, 0.88))
        {
            if(KFPM.MyKFAIC.bHasDebugCommand)
            {
                KFPM.MyKFAIC.SetEnemy(Outer.Pawn);
                AICommand_Debug(KFPM.MyKFAIC.GetActiveCommand()).Debug_Hide();
            }
        }        
    }    
}

exec function AIFPRoam()
{
    local KFPawn_Monster KFPM;
    local KFAIController KFAIC;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            if(KFPM.IsA('KFPawn_ZedFleshpound'))
            {
                KFAIC = KFPM.MyKFAIC;
                if(KFAIC.bHasDebugCommand)
                {
                    AICommand_Debug(KFAIC.GetActiveCommand()).GotoState('Roaming');
                    break;
                }
            }
        }        
    }    
}

exec function EnterZedVictoryState()
{
    local KFAIController AI;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        AI.EnterZedVictoryState();        
    }    
}

exec function AddAIFilter(coerce string Filter)
{
    local KFAIController AI;
    local int Idx;
    local name N;

    N = name(Filter);
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        Idx = AI.AILogFilter.Find(N;
        if(Idx < 0)
        {
            AI.AILogFilter[AI.AILogFilter.Length] = N;
        }        
    }    
}

exec function RemoveAIFilter(coerce string Filter)
{
    local KFAIController AI;
    local int Idx;
    local name N;

    N = name(Filter);
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        Idx = AI.AILogFilter.Find(N;
        if(Idx >= 0)
        {
            Outer.Pawn.MessagePlayer("Removed Filter" @ Filter);
            AI.AILogFilter.Remove(Idx, 1;
        }        
    }    
}

exec function FlushAILogs()
{
    local KFAIController GAI;

    if(!Outer.WorldInfo.bPlayersOnly)
    {
        Outer.DebugFreezeGame();
    }
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', GAI)
    {
        if(GAI.AILogFile != none)
        {
            GAI.AILogFile.CloseLog();
            GAI.AILogFile.Destroy();
            GAI.AILogFile = none;
        }        
    }    
}

exec function AIFPEnrage()
{
    local KFPawn_Monster KFPM;
    local KFAIController KFAIC;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            if(KFPM.IsA('KFPawn_ZedFleshpound'))
            {
                KFPM.MyKFAIC.Enemy = Outer.Pawn;
                KFAIC = KFPM.MyKFAIC;
                KFAIC.SetEnemy(Outer.Pawn);
                KFAIC.MyKFPawn.SetEnraged(true);
            }
        }        
    }    
}

exec function AIScream()
{
    local KFPawn_Monster KFPM, Siren;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsA('KFPawn_ZedSiren') && KFPM.IsAliveAndWell()) && KFPM.MyKFAIC != none)
        {
            Siren = KFPM;
            KFPM.DoSpecialMove(16, true);
        }        
    }    
    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsA('KFPawn_ZedClot'))
        {
            KFPM.MyKFAIC.Focus = Siren;
            KFPM.LookAtPawn(Siren);
        }        
    }    
}

exec function ToggleNPCDebug(optional name Category)
{
    local KFPawn_Monster KFPM;
    local bool bNPCDebugIsOn;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFPM = GetKFMPFromAim();
    if((KFPM != none) && KFPM.IsAliveAndWell())
    {
        bNPCDebugIsOn = KFPM.bDebug_DrawOverheadInfo;
        bNPCDebugIsOn = !bNPCDebugIsOn;
        Outer.ClientMessage((("Turning " $ ((bNPCDebugIsOn) ? "on" : "off")) $ " debug text rendering for ") $ string(KFPM), CheatType);
        KFPM.SetDebugTextRendering(bNPCDebugIsOn);
        SetNPCDebugCategory(bNPCDebugIsOn, Category);        
    }
    else
    {
        Outer.ClientMessage("You must be aiming toward a living NPC to use this command, or use 'ToggleAllNPCDebug' for ALL NPCs.", CheatType);
    }
}

exec function AIStepAside(optional bool bForMe)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if(((KFAIC != none) && KFAIC.MyKFPawn != none) && KFAIC.MyKFPawn.IsAliveAndWell())
    {
        if(!bForMe)
        {
            Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " stepping aside.", CheatType);
            KFAIC.StepAsideFor(KFAIC.MyKFPawn, vector(KFAIC.MyKFPawn.Rotation));            
        }
        else
        {
            Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " stepping out of your way.", CheatType);
            KFAIC.StepAsideFor(Outer.Pawn, vector(Outer.Pawn.Rotation));
        }
    }
}

exec function ShowAIInfo(optional bool bOn)
{
    local KFPawn_Monster KFMP;

    bOn = true;
    KFMP = GetKFMPFromAim();
    if((((DebugTarget != none) && !DebugTarget.bDeleteMe) && DebugTarget.Health > 0) && DebugTarget.MyKFAIC != none)
    {
        DebugTarget.SetDebugTextRendering(false);
        SetNPCDebugCategory(false, 'AICommands');
        Outer.ClientMessage("Turning off AICommand debugging for " $ string(KFMP), CheatType);
        DebugTarget = none;
        return;
    }
    if((KFMP != none) && KFMP.Health > 0)
    {
        DebugTarget = KFMP;
        KFMP.SetDebugTextRendering(bOn);
        SetNPCDebugCategory(bOn, 'AICommands');
        Outer.ClientMessage("Turning on AICommand debugging for " $ string(KFMP), CheatType);
    }
}

exec function ToggleAllNPCDebug(optional name Category)
{
    local KFGameInfo KFGI;
    local KFAIDirector Director;
    local KFPawn_Monster KFPM;
    local bool bNPCDebugIsOn;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director != none)
        {
            Director.bShowAINames = !Director.bShowAINames;
            bNPCDebugIsOn = Director.bShowAINames;
            Outer.ClientMessage("bShowAINames [Director] is now " $ string(Director.bShowAINames), CheatType);
            Outer.ClientMessage("bNPCDebugIsOn is " $ string(bNPCDebugIsOn), CheatType);
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell())
        {
            KFPM.SetDebugTextRendering(bNPCDebugIsOn);
        }        
    }    
    SetNPCDebugCategory(bNPCDebugIsOn, Category);
    Outer.ClientMessage(("Turning " $ ((bNPCDebugIsOn) ? "on" : "off")) $ " debug text rendering for NPCs", CheatType);
}

exec function SetAllNPCDebug(bool bTurnOn, optional name Category)
{
    local KFGameInfo KFGI;
    local KFAIDirector Director;
    local KFPawn_Monster KFPM;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director != none)
        {
            Director.bShowAINames = bTurnOn;
            Outer.ClientMessage("bShowAINames [Director] is now " $ string(Director.bShowAINames), CheatType);
            Outer.ClientMessage("bTurnOn is " $ string(bTurnOn), CheatType);
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell())
        {
            KFPM.SetDebugTextRendering(bTurnOn);
        }        
    }    
    SetNPCDebugCategory(bTurnOn, Category);
    Outer.ClientMessage(("Turning " $ ((bTurnOn) ? "on" : "off")) $ " debug text rendering for NPCs", CheatType);
}

simulated function SetNPCDebugCategory(bool bTurnOn, optional name Category)
{
    local PlayerController PC;
    local KFHUDBase KFHud;

    Category = 'All';
    foreach Outer.LocalPlayerControllers(Class'PlayerController', PC)
    {
        KFHud = KFHUDBase(PC.myHUD);        
    }    
    if(KFHud != none)
    {
        if(-1 != KFHud.DebugDisplay.RemoveItem(Category)
        {
            KFHud.SaveConfig();
        }
        if(bTurnOn)
        {
            KFHud.ShowDebug(Category);
        }
        KFHud.bShowDebugInfo = false;
    }
}

exec function TAND(optional name Category)
{
    Category = 'All';
    ToggleAllNPCDebug(Category);
}

exec function ShowAiDebugText(optional bool bAffectAllZeds, optional name DebugCategory)
{
    local KFAIController KFAIC;
    local KFGameInfo KFGI;
    local KFAIDirector Director;

    bAffectAllZeds = false;
    DebugCategory = 'All';
    if(DebugCategory == 'None')
    {
        DebugCategory = 'All';
    }
    if(DebugCategory != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(DebugCategory != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    if(bAffectAllZeds)
    {
        KFGI = KFGameInfo(Outer.WorldInfo.Game);
        if(KFGI != none)
        {
            Director = KFGI.GetAIDirector();
            Director.bShowAINames = !Director.bShowAINames;
            SetNPCDebugCategory(Director.bShowAINames, DebugCategory);
            foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
            {
                KFAIC.bDebug_PostRenderInfo = !KFAIC.bDebug_PostRenderInfo;
                KFAIC.bDebug_DrawOverheadInfo = KFAIC.bDebug_PostRenderInfo;
                KFAIC.SetPostRendering(KFAIC.bDebug_PostRenderInfo);
                if((KFPawn_Monster(KFAIC.Pawn) != none) && KFPawn_Monster(KFAIC.Pawn).IsAliveAndWell())
                {
                    KFPawn_Monster(KFAIC.Pawn).SetDebugTextRendering(Director.bShowAINames);
                }                
            }            
        }        
    }
    else
    {
        KFAIC = GetKFAICFromAim();
        if((KFAIC != none) && KFAIC.Pawn != none)
        {
            KFAIC.bDebug_PostRenderInfo = !KFAIC.bDebug_PostRenderInfo;
            KFAIC.bDebug_DrawOverheadInfo = KFAIC.bDebug_PostRenderInfo;
            SetNPCDebugCategory(KFAIC.bDebug_DrawOverheadInfo, DebugCategory);
            KFAIC.SetPostRendering(KFAIC.bDebug_PostRenderInfo);
            if((KFPawn_Monster(KFAIC.Pawn) != none) && KFPawn_Monster(KFAIC.Pawn).IsAliveAndWell())
            {
                KFPawn_Monster(KFAIC.Pawn).SetDebugTextRendering(KFAIC.bDebug_DrawOverheadInfo);
            }
        }
    }
}

exec function AIShowNames(optional bool bOff)
{
    local KFAIController KFAIC;
    local KFGameInfo KFGI;
    local KFAIDirector Director;

    bOff = false;
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director.bShowAINames && bOff)
        {
            Outer.ClientMessage("Turning off AIShowNames...", CheatType);
            Director.bShowAINames = false;            
        }
        else
        {
            if(Director.bShowAINames)
            {
                Outer.ClientMessage("AIShowNames is already on, enter 'AIShowNames false' to turn off.", CheatType);                
            }
            else
            {
                Outer.ClientMessage("Turning on AIShowNames...", CheatType);
            }
            Director.bShowAINames = true;
        }
        foreach Outer.AllActors(Class'KFAIController', KFAIC)
        {
            KFAIC.bDebug_PostRenderInfo = Director.bShowAINames;
            KFAIC.bDebug_DrawOverheadInfo = Director.bShowAINames;            
        }        
    }
}

exec function AIShowDebug()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(DebugKFAIC != none)
        {
            KFAIC.bDebug_DrawAIDebug = false;
            KFAIC.SetupDebug();
            DebugKFAIC = none;
        }
        if((KFAIC.Pawn != none) && Outer.IsAimingAt(KFAIC.Pawn, 0.95))
        {
            KFAIC.bDebug_DrawAIDebug = true;
            DebugKFAIC = KFAIC;
            KFAIC.SetupDebug();
        }        
    }    
}

function AICommand_Debug GetDebugAICommand()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(Outer.IsAimingAt(KFAIC.Pawn, 0.92))
        {
            if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
            {                
                return AICommand_Debug(KFAIC.GetActiveCommand());
            }
        }        
    }    
    Outer.ClientMessage("You need to be aiming at a DebugMode Zed in order for this to work.", CheatType);
    return none;
}

exec function MarkLocation()
{
    local Vector SphereLocation;

    if((Outer.Pawn == none) && DebugCameraController(Outer) != none)
    {
        SphereLocation = Outer.Location;        
    }
    else
    {
        SphereLocation = Outer.Pawn.Location;
    }
    Outer.DrawDebugSphere(SphereLocation, 36, 8, 255, 255, 0, true);
}

exec function AISetEnemyToMe(optional bool bAllAI)
{
    local KFAIController KFAIC;

    bAllAI = false;
    if(!bAllAI)
    {
        KFAIC = GetKFAICFromAim();
        if(KFAIC != none)
        {
            KFAIC.SetEnemy(Outer.Pawn);
        }        
    }
    else
    {
        foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
        {
            if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
            {
                KFAIC.SetEnemy(Outer.Pawn);
            }            
        }        
    }
}

exec function AISetCanAttack(bool bCanAttack)
{
    GetDebugAICommand().bAllowedToAttack = bCanAttack;
    Outer.ClientMessage((((string(GetDebugAIController().Pawn) $ " ") $ string(GetDebugAICommand())) $ " bAllowedToAttack is now ") $ string(bCanAttack), CheatType);
}

exec function GetYawRate()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if(KFAIC != none)
    {
        Outer.ClientMessage((string(KFAIC.Pawn) $ "'s RotationRate.Yaw is ") $ string(KFAIC.Pawn.RotationRate.Yaw), CheatType);
    }
}

exec function AIDisableBump()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.Disable('NotifyBump');
        Outer.ClientMessage(string(KFAIC.Pawn) $ " Bump Disabled", CheatType);
    }
}

exec function AIEnableBump()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.Enable('NotifyBump');
        Outer.ClientMessage(string(KFAIC.Pawn) $ " Bump Enabled", CheatType);
    }
}

exec function AIToggleHeadTracking()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        if(KFAIC.MyKFPawn.bIsHeadTrackingActive)
        {
            KFAIC.MyKFPawn.ClearHeadTrackTarget(Outer.GetALocalPlayerController().Pawn, 0.25);            
        }
        else
        {
            KFAIC.MyKFPawn.LookAtPawn(Outer.GetALocalPlayerController().Pawn);
        }
    }
}

exec function TestScreamEffect()
{
    Outer.Pawn.TakeDamage(1, Outer, Outer.Pawn.Location, vect(0, 0, 0), Class'KFDT_Sonic');
}

function KFAIController GetDebugAIController(optional bool bGetClosest, optional name inFunctionName)
{
    local KFAIController KFAIC, ClosestKFAIC;

    bGetClosest = false;    
    if(inFunctionName == 'None')
    {
        inFunctionName = GetFuncName();
    }
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
        {
            if(bGetClosest)
            {
                if(ClosestKFAIC == none)
                {
                    ClosestKFAIC = KFAIC;                    
                }
                else
                {
                    if(VSize(KFAIC.Pawn.Location - Outer.Pawn.Location) < VSize(ClosestKFAIC.Pawn.Location - Outer.Pawn.Location))
                    {
                        ClosestKFAIC = KFAIC;
                    }
                }
                continue;
            }
            if(Outer.IsAimingAt(KFAIC.Pawn, 0.8))
            {
                ClosestKFAIC = KFAIC;
                break;
            }
        }        
    }    
    if(ClosestKFAIC == none)
    {
        Outer.ClientMessage(string(inFunctionName) $ " : You need to be aiming at a valid NPC to do this.", CheatType);
    }
    return ClosestKFAIC;
}

exec function AIDebugTurnInPlace(optional bool bEnableMelee)
{
    local KFAIController KFAIC;

    bEnableMelee = false;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.DoDebugTurnInPlace(KFPlayerController(Outer), bEnableMelee);        
    }    
}

exec function AIToggleTurnInPlace()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.bDisableTurnInPlace = !KFAIC.MyKFPawn.bDisableTurnInPlace;
    }
    if(KFAIC.MyKFPawn.bDisableTurnInPlace)
    {
        Outer.ClientMessage(string(KFAIC.Pawn) $ " TurnInPlace disabled", CheatType);        
    }
    else
    {
        Outer.ClientMessage(string(KFAIC.Pawn) $ " TurnInPlace enabled", CheatType);
    }
}

exec function ToggleKFDebugLines()
{
    KFDL();
}

exec function KFDL()
{
    local KFGameEngine KFGEngine;

    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        Class'KFGameEngine'.default.bEnableAdvDebugLines = !Class'KFGameEngine'.default.bEnableAdvDebugLines;
        Outer.ClientMessage("KFDebugLines on: " $ string(Class'KFGameEngine'.default.bEnableAdvDebugLines), CheatType);
    }
}

exec function ClearDebugLines()
{
    local KFDebugLines KFDL;

    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        KFDL.ClearAll();
    }
}

exec function AIShowDropDowns(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFWallPathNode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFWallPathNode', NP)
        {
            if(bOn)
            {
                if(NP.DropDownNode != none)
                {
                    I = 0;
                    J0xA7:

                    if(I < NP.PathList.Length)
                    {
                        if((KFPathnode(NP.PathList[I].End.Actor) == NP.DropDownNode) && NP.PathList[I].IsA('WallToFloorReachSpec'))
                        {
                            KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                            if(WallToFloorReachSpec(NP.PathList[I]).bJumpDownTo)
                            {
                                KFDL.AddDebugLine(NP.Location, NP.DropDownNode.Location, 0, 200, 0, true, 220, NP.Name, I);                                
                            }
                            else
                            {
                                KFDL.AddDebugLine(NP.Location, NP.DropDownNode.Location, 255, 255, 0, true, 220, NP.Name, I);
                            }
                        }
                        ++ I;
                        goto J0xA7;
                    }
                }
                continue;
            }
            KFDL.RemoveOwnedDebugLines(NP.Name, 0);
            KFDL.RemoveOwnedDebugSpheres(NP.Name, 0);            
        }        
    }
}

exec function AIShowFloorToWallNodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if(NP.bWallNode)
            {
                continue;                
            }
            if(bOn)
            {
                I = 0;
                J0xA9:

                if(I < NP.PathList.Length)
                {
                    if(NP.PathList[I].IsA('FloorToWallReachSpec'))
                    {
                        KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                        KFDL.AddDebugLine(NP.Location, NP.PathList[I].End.Actor.Location, 100, 200, 150, true, 220, NP.Name, I);
                    }
                    ++ I;
                    goto J0xA9;
                }
                continue;
            }
            I = 0;
            J0x27B:

            if(I < NP.PathList.Length)
            {
                KFDL.RemoveOwnedDebugLines(NP.Name, I);
                KFDL.RemoveOwnedDebugSpheres(NP.Name, I);
                ++ I;
                goto J0x27B;
            }            
        }        
    }
}

exec function AIShowForcedSpecs(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if(NP.bWallNode)
            {
                continue;                
            }
            if(bOn)
            {
                I = 0;
                J0xA9:

                if(I < NP.PathList.Length)
                {
                    if(NP.PathList[I].IsA('KFForcedReachSpec'))
                    {
                        KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                        KFDL.AddDebugLine(NP.Location, NP.PathList[I].End.Actor.Location, 100, 200, 150, true, 220, NP.Name, I);
                    }
                    ++ I;
                    goto J0xA9;
                }
                continue;
            }
            I = 0;
            J0x27B:

            if(I < NP.PathList.Length)
            {
                KFDL.RemoveOwnedDebugLines(NP.Name, I);
                KFDL.RemoveOwnedDebugSpheres(NP.Name, I);
                ++ I;
                goto J0x27B;
            }            
        }        
    }
}

exec function AIShowLitNodes()
{
    local NavigationPoint NP;
    local float ColorScale, TempFloat;

    Outer.FlushPersistentDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        TempFloat = ((NP.Intensity.R + NP.Intensity.G) + NP.Intensity.B) / 3;
        ColorScale = float(Clamp(int(TempFloat * 255), 30, 255));
        Outer.DrawDebugSphere(NP.Location, 32, 8, byte(ColorScale), byte(ColorScale), 0, true);        
    }    
}

exec function AIPlayTaunt(byte TauntType)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(Outer.IsAimingAt(KFAIC.Pawn, 0.88))
        {
            Class'AICommand_TauntEnemy'.static.Taunt(KFAIC, KFPawn(Outer.Pawn), TauntType);
        }        
    }    
}

exec function DebugNextPhase()
{
    local KFAIController_ZedBoss KFAICB;

    foreach Outer.AllActors(Class'KFAIController_ZedBoss', KFAICB)
    {
        KFAICB.DebugNextPhase();        
    }    
}

exec function HansNextPhase()
{
    DebugNextPhase();
}

exec function HansGas()
{
    local KFPawn_ZedHansBase HansPawn;

    foreach Outer.AllActors(Class'KFPawn_ZedHansBase', HansPawn)
    {
        HansPawn.ANIMNOTIFY_AoENerveGas();        
    }    
}

exec function AISummonZeds(int BattlePhase, int DifficultyIndex)
{
    local KFAIController_ZedBoss KFAIC;
    local KFAIWaveInfo MinionWave;
    local KFPawn_MonsterBoss BossPawn;

    foreach Outer.AllActors(Class'KFAIController_ZedBoss', KFAIC)
    {
        BossPawn = KFPawn_MonsterBoss(KFAIC.MyKFPawn);
        if(BossPawn == none)
        {            
            return;
        }
        if(BattlePhase == 0)
        {
            MinionWave = BossPawn.SummonWaves[DifficultyIndex].PhaseOneWave;            
        }
        else
        {
            if(BattlePhase == 1)
            {
                MinionWave = BossPawn.SummonWaves[DifficultyIndex].PhaseTwoWave;                
            }
            else
            {
                if(BattlePhase == 2)
                {
                    MinionWave = BossPawn.SummonWaves[DifficultyIndex].PhaseThreeWave;
                }
            }
        }
        Class'AICommand_SummonZeds'.static.Summon(KFAIC, MinionWave, BossPawn.NumMinionsToSpawn);        
    }    
}

exec function ShowBlockedPathnodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local int I;
    local NavigationPoint NP;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        if(bOn && NP.bBlocked)
        {
            ++ I;
            KFDL.AddDebugSphere(NP.Location, 24, 12, 0, 255, 0, true,, NP.Name, I);
            continue;
        }
        KFDL.RemoveOwnedDebugSpheres(NP.Name);        
    }    
}

exec function ShowPathnodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local int I;
    local NavigationPoint NP;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        if(bOn)
        {
            ++ I;
            KFDL.AddDebugSphere(NP.Location, 24, 12, 0, 255, 0, true,, NP.Name, I);
            continue;
        }
        KFDL.RemoveOwnedDebugSpheres(NP.Name);        
    }    
}

exec function AIMoveToMeAsEnemy()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.IsInDebugMode())
        {
            KFAIC.bIsProbingMeleeRangeEvents = false;
            KFAIC.SetEnemy(Outer.Pawn);
            KFAIC.Enemy = Outer.Pawn;
            AICommand_Debug(KFAIC.GetActiveCommand()).LastDebugGoal = KFAIC.Enemy;
            KFAIC.SetEnemyMoveGoal(none, true,,, false);
        }        
    }    
}

exec function AIEnableMeleeEvents()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.EnableMeleeRangeEventProbing();
}

exec function AIDisableMeleeEvents()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.DisableMeleeRangeEventProbing();
}

exec function AIPathTo(name DebugGoalName, optional float OffsetDistance, optional bool bMarkGoalLocation)
{
    local KFPathnode CheckNode;
    local Actor DebugGoal;
    local KFAIController KFAIC;
    local KFPawn KFP;

    OffsetDistance = 0;    
    if(DebugGoalName == 'None')
    {
        Outer.ClientMessage("Use the Tag property in KFPathNodes, and specify that name to have AI path to a specific node. Exampe: AIPathTo TestGoal.  PLAYER is also a valid argument.", CheatType);
        return;
    }
    if(DebugGoalName != 'Player')
    {
        foreach Outer.WorldInfo.AllNavigationPoints(Class'KFPathnode', CheckNode)
        {
            if(CheckNode.DebugTag == DebugGoalName)
            {
                DebugGoal = CheckNode;
                break;
            }            
        }                
    }
    else
    {
        DebugGoal = Outer.GetALocalPlayerController().Pawn;
    }
    if(DebugGoal == none)
    {
        foreach Outer.AllActors(Class'KFPawn', KFP)
        {
            if((KFP.Controller == none) || !KFP.Controller.IsA('KFAIController'))
            {
                DebugGoal = KFP;
                break;
            }            
        }        
        if(DebugGoal == none)
        {
            Outer.ClientMessage(("Cannot find a valid goal for '" $ string(DebugGoalName)) $ ".", CheatType);
            return;
        }
    }
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.IsInDebugMode())
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).LastDebugGoal = DebugGoal;
            Outer.ClientMessage((((string(KFAIC.Pawn) $ " Moving to ") $ string(DebugGoal)) $ " with an offset distance of ") $ string(OffsetDistance), CheatType);
        }        
    }    
    if(bMarkGoalLocation)
    {
        Outer.ClientMessage("Type 'FlushPersistentDebugLines' to remove the debug sphere at goal location", CheatType);
        Outer.DrawDebugSphere(DebugGoal.Location, 32, 8, 189, 183, 107, true);
    }
}

exec function AIDebugCrawler()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if((KFAIC == none) || !KFAIC.IsA('KFAIController_ZedCrawler'))
    {
        Outer.ClientMessage("You must be aiming at a debug-mode NPC!");
        return;
    }
    KFAIC.Pawn.bDebugCrawlerPhysics = !KFAIC.Pawn.bDebugCrawlerPhysics;
    Outer.ClientMessage((("DebugCrawler is now " $ string(KFAIC.Pawn.bDebugCrawlerPhysics)) $ " for ") $ string(KFAIC.Pawn), CheatType);
    if(KFAIC.Pawn.bDebugCrawlerPhysics)
    {
        Outer.ClientMessage(("Warning - PlayersOnly will be activated throughout " $ string(KFAIC.Pawn)) $ "'s moves.", CheatType, 13);
    }
}

exec function AITestCrawler()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if(KFAIC == none)
    {
        Outer.ClientMessage("You must be aiming at a debug-mode NPC!", CheatType);
    }
    if(!KFAIC.bHasDebugCommand)
    {
        Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " must have a controller in debug mode first!", CheatType);
    }
    AICommand_Debug(KFAIC.GetActiveCommand()).Debug_DebugNodes();
}

exec function AITestCrawlers()
{
    local KFAIController_ZedCrawler KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_ZedCrawler', KFAIC)
    {
        if(KFAIC.bHasDebugCommand)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).Debug_DebugNodes();
        }        
    }    
}

exec function AITestCrawlerAttack()
{
    local KFAIController_ZedCrawler KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_ZedCrawler', KFAIC)
    {
        if(KFAIC.bHasDebugCommand)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).Debug_CrawlerAttack();
        }        
    }    
}

exec function AITestGrab()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(false, 0.9);
    if(KFAIC != none)
    {
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = true;
        }
        KFAIC.DoGrabAttack(Outer.Pawn,, 5);
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = false;
        }
    }
}

exec function AIHansTestGrenadeTrajectory(optional float Speed, optional float ZPct)
{
    local KFAIController_Hans KFAIC;
    local Vector EstimatedStartThrowLocation, TossVelocity;

    Speed = 2500;
    ZPct = 0.45;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_Hans', KFAIC)
    {
        if(KFAIC != none)
        {
            EstimatedStartThrowLocation = KFAIC.Pawn.GetPawnViewLocation() + (vect(15, 32, -12) >> KFAIC.Pawn.GetViewRotation());
            if(!KFAIC.Pawn.SuggestTossVelocity(TossVelocity, GetMyPawn().Location, EstimatedStartThrowLocation, Speed,, ZPct))
            {
                Outer.ClientMessage((((((("FAIL for Speed:" $ string(Speed)) $ " ZPCt:") $ string(ZPct)) $ " 2DDist: ") $ string(VSize2D(KFAIC.Pawn.Location - GetMyPawn().Location))) $ " ZDiff:") $ string(Abs(KFAIC.Pawn.Location.Z - GetMyPawn().Location.Z)), CheatType);
                continue;
            }
            Outer.ClientMessage((((((("SUCCESS for Speed:" $ string(Speed)) $ " ZPCt:") $ string(ZPct)) $ " 2DDist: ") $ string(VSize2D(KFAIC.Pawn.Location - GetMyPawn().Location))) $ " ZDiff:") $ string(Abs(KFAIC.Pawn.Location.Z - GetMyPawn().Location.Z)), CheatType);
        }        
    }    
}

exec function AIHansGrenade(optional bool bGrenadeBarrage)
{
    local KFAIController_Hans KFAIC;

    KFAIC = KFAIController_Hans(GetKFAICFromAim(false, 0.9));
    if(KFAIC != none)
    {
        KFAIC.Enemy = GetMyPawn();
        KFAIC.DoGrenadeThrow(bGrenadeBarrage);
    }
}

exec function AITestHansGrab()
{
    local KFAIController_Hans KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_Hans', KFAIC)
    {
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = true;
        }
        KFAIC.DoGrabAttack(Outer.Pawn,, 5);
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = false;
        }        
    }    
}

exec function AISetDebugColor(byte R, byte G, byte B)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride = MakeColor(R, G, B, 255);        
    }    
}

exec function AISetDebugColorR(byte R)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.R = R;        
    }    
}

exec function AISetDebugColorG(byte G)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.G = G;        
    }    
}

exec function AISetDebugColorB(byte B)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.B = B;        
    }    
}

exec function AISetDebugColorA(byte A)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.A = A;        
    }    
}

exec function AIDebugEnemy()
{
    GetDebugAICommand().Debug_Enemy(Outer.Pawn);
}

exec function DumpReachSpecs()
{
    local int I, Count;
    local NavigationPoint Nav, StartNav, EndNav;
    local float Length, TotalDist;

    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', Nav)
    {
        LogInternal("--------------------------------------------------------------------------------");
        LogInternal("Checking Nav: " $ string(Nav));
        I = 0;
        J0xC9:

        if(I < Nav.PathList.Length)
        {
            StartNav = Nav;
            EndNav = Nav.PathList[I].GetEnd();
            if(!Nav.PathList[I].IsA('ProscribedReachSpec'))
            {
                ++ Count;
                if((StartNav != none) && EndNav != none)
                {
                    Length = VSize(EndNav.Location - Nav.Location);
                    LogInternal(((((("		" $ string(Nav.PathList[I])) $ " connected to ") $ string(EndNav)) $ " ") $ string(Length)) $ " length");
                    TotalDist += Length;
                }
            }
            ++ I;
            goto J0xC9;
        }        
    }    
    LogInternal("Avg Dist: " $ string(TotalDist / float(Count)));
}

exec function KillOtherZeds()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        if((AIP.Health > 0) && !Outer.IsAimingAt(AIP, 0.98))
        {
            AIP.TakeDamage(20000, Outer, AIP.Location, vect(0, 0, 0), Class'KFDamageType');
        }        
    }    
}

exec function KillZeds(optional float KillDistance, optional bool LogKilledZedInfo)
{
    local PlayerController KFPC;
    local DebugCameraController DCC;
    local KFPawn_Monster AIP;
    local Pawn MyPawn;

    KillDistance = 0;
    LogKilledZedInfo = true;
    KFPC = Outer;
    if(KFPC != none)
    {
        DumpInfoForAI();
        foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
        {
            if(!AIP.IsAliveAndWell())
            {
                continue;                
            }
            if(KillDistance > 0)
            {
                if(Outer.Pawn != none)
                {
                    MyPawn = Outer.Pawn;                    
                }
                else
                {
                    if(DebugCameraController(KFPC) != none)
                    {
                        DCC = DebugCameraController(KFPC);
                        if(((DCC != none) && DCC.OriginalControllerRef != none) && DCC.OriginalControllerRef.Pawn != none)
                        {
                            MyPawn = DCC.OriginalControllerRef.Pawn;
                        }
                    }
                }
                if((MyPawn != none) && VSizeSq(AIP.Location - MyPawn.Location) > (KillDistance * KillDistance))
                {
                    LogInternal(((((string(self) $ " Not killing ") $ string(AIP)) $ " who is ") $ string(VSize(AIP.Location - MyPawn.Location))) $ " units away");
                    continue;                    
                }
            }
            if(AIP.Health > 0)
            {
                AIP.Died(none, none, AIP.Location);
            }            
        }        
    }
}

exec function AIRage()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(((P.IsAliveAndWell() && P.IsA('KFPawn_ZedFleshpound')) && !P.IsEnraged()) && Outer.IsAimingAt(P, 0.95))
        {
            P.MyKFAIC.SetEnemy(Outer.Pawn);
            P.SetEnraged(true);
        }        
    }    
}

exec function ShowCrawlerPath(optional bool bAllowPartial, optional int OverrideFloorCostMin, optional int OverrideFloorCostMax)
{
    local KFPawn_Monster KFPM;
    local Actor Result;
    local KFGameEngine KFGEngine;
    local KFDebugLines KFDL;

    bAllowPartial = false;        
    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        Class'KFGameEngine'.default.bEnableAdvDebugLines = true;
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if((((KFPM.Health > 0) && KFPM.bCrawler) && KFPM.MyKFAIC != none) && KFPM.MyKFAIC.bHasDebugCommand)
        {
            KFPM.MyKFAIC.RouteCache.Length = 0;
            if((OverrideFloorCostMin > 0) && OverrideFloorCostMax > 0)
            {
                KFAIController_ZedCrawler(KFPM.MyKFAIC).MinExtraCostForFloorNodes = OverrideFloorCostMin;
                KFAIController_ZedCrawler(KFPM.MyKFAIC).MaxExtraCostForFloorNodes = OverrideFloorCostMax;
            }
            KFDL = Class'KFDebugLines'.static.GetDebugLines();
            Result = KFPM.MyKFAIC.GeneratePathTo(GetMyPawn(),, bAllowPartial);
            if(Result == none)
            {
                Outer.ClientMessage(string(KFPM) $ " failed to build path", CheatType);
            }
            KFDL.ClearAll();
            KFPM.MyKFAIC.KFDebug_DrawMyPath();
        }        
    }    
}

exec function AIDebugLOS()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.MyKFAIC.bHasDebugCommand && KFPM.IsAliveAndWell())
        {
            AICommand_Debug(KFPM.MyKFAIC.GetActiveCommand()).Debug_LOS();
        }        
    }    
}

exec function DumpAICommands()
{
    local KFAIController AI;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        AI.DumpCommandStack();        
    }    
}

exec function TestSpecDist(optional bool bOnlyPathNodes)
{
    local NavigationPoint NP, StartNav, EndNav;
    local int I;
    local array<float> Distances;
    local float Total;

    bOnlyPathNodes = false;
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        I = 0;
        J0x3E:

        if(I < NP.PathList.Length)
        {
            StartNav = NP.PathList[I].Start;
            EndNav = NP.PathList[I].GetEnd();
            if((StartNav != none) && EndNav != none)
            {
                if(bOnlyPathNodes)
                {
                    if((StartNav.Class != Class'PathNode') || EndNav.Class != Class'PathNode')
                    {
                        goto J0x23A;
                    }
                }
                Distances.AddItem(VSize(NP.PathList[I].Start.Location - NP.PathList[I].GetEnd().Location);
            }
            J0x23A:

            ++ I;
            goto J0x3E;
        }        
    }    
    I = 0;
    J0x255:

    if(I < Distances.Length)
    {
        LogInternal((("DISTANCES[" $ string(I)) $ "] : ") $ string(Distances[I]));
        Total += Distances[I];
        ++ I;
        goto J0x255;
    }
    LogInternal((((("TOTAL: " $ string(Total)) $ " LENGTH: ") $ string(Distances.Length)) $ " AVG: ") $ string(Total / float(Distances.Length)));
}

simulated exec function BigHeadMode()
{
    local Pawn P;
    local KFPawn_Monster Clot;

    P = Outer.WorldInfo.PawnList;
    J0x3D:

    if(P != none)
    {
        Clot = KFPawn_Monster(P);
        if(Clot != none)
        {
            if(Clot.IK_Look_Head == none)
            {
                Clot.IK_Look_Head = SkelControlLookAt(Clot.Mesh.FindSkelControl('HeadLook'));
            }
            if(Clot.IK_Look_Head != none)
            {
                if(Clot.IK_Look_Head.BoneScale > 1)
                {
                    Clot.IK_Look_Head.BoneScale = 1;                    
                }
                else
                {
                    Clot.IK_Look_Head.BoneScale = 3;
                }
            }
        }
        P = P.NextPawn;
        goto J0x3D;
    }
}

simulated exec function BigZedMode(optional float Scale, optional bool bScaleCollision)
{
    local Pawn P;
    local KFPawn_Monster Zed;

    Scale = 2;    
    P = Outer.WorldInfo.PawnList;
    J0x47:

    if(P != none)
    {
        Zed = KFPawn_Monster(P);
        if(Zed != none)
        {
            Zed.SetDrawScale(Scale);
            if(bScaleCollision)
            {
                Zed.SetCollisionSize(Zed.CylinderComponent.default.CollisionRadius * Scale, Zed.CylinderComponent.default.CollisionHeight * Scale);
            }
        }
        P = P.NextPawn;
        goto J0x47;
    }
}

simulated exec function AISetInUseCost(optional float NewCost)
{
    local KFAIController KFAIC;

    NewCost = 10;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.InUseNodeCostMultiplier == float(0))
        {
            KFAIC.InUseNodeCostMultiplier = 10;            
        }
        else
        {
            KFAIC.InUseNodeCostMultiplier = 0;
        }
        Outer.ClientMessage((string(KFAIC.Pawn) $ " InUseNodeCostMultiplier is now ") $ string(KFAIC.InUseNodeCostMultiplier), CheatType);        
    }    
}

simulated exec function AILookAtMe(bool bEnabled)
{
    local Pawn P;
    local KFPawn_Monster KFP;

    P = Outer.WorldInfo.PawnList;
    J0x3D:

    if(P != none)
    {
        KFP = KFPawn_Monster(P);
        if(((KFP != none) && KFP.bCanHeadTrack) && Outer.IsAimingAt(KFP, 0.88))
        {
            if(bEnabled)
            {
                KFP.IK_Look_Head = SkelControlLookAt(KFP.Mesh.FindSkelControl('HeadLook'));
                KFP.bIsHeadTrackingActive = true;
                KFP.SetHeadTrackTarget(Outer.Pawn, vect(0, 0, 0), 1, false);                
            }
            else
            {
                KFP.ClearHeadTrackTarget(KFP.MyLookAtInfo.LookAtTarget, 0.5);
                KFP.bIsHeadTrackingActive = false;
            }
        }
        P = P.NextPawn;
        goto J0x3D;
    }
}

exec function InjureZedArm()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.RagdollArm(false);        
    }    
}

exec function CrippleZeds()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.CauseHeadTrauma(AIP.HeadlessBleedOutTime);        
    }    
}

exec function CrippleZed()
{
    local KFPawn_Monster AIP;

    AIP = GetKFMPFromAim();
    if(AIP != none)
    {
        AIP.CauseHeadTrauma(AIP.HeadlessBleedOutTime);
    }
}

exec function EnableLivingGore()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.InitPartialKinematics();        
    }    
}

exec function PlayRandomStumble()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackRandomSMFlags(P));        
    }    
}

exec function PlayTaunt()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.WalkBlendList.QueueTauntWalk();        
    }    
}

exec function PlayKnockdown()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.Knockdown(,, vect(1, 1, 1), Outer.Pawn.Location, 1000, 100);        
    }    
}

exec function PlayStunned()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell())
        {
            P.DoSpecialMove(9);
        }        
    }    
}

exec function EMPWander(bool bEnable)
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell() && P.MyKFAIC != none)
        {
            if(bEnable)
            {
                P.CausePanicWander();
                P.AfflictionHandler.SetEMPEffects(true, false);
                continue;
            }
            P.EndPanicWander();
            P.AfflictionHandler.SetEMPEffects(false, false);
        }        
    }    
}

exec function EMPValTest(float EMPValue)
{
    local KFPawn_Monster P;
    local MaterialInstanceConstant MIC;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell())
        {
            MIC = ((P.bIsGoreMesh) ? P.GoreMIC : P.BodyMIC);
            MIC.SetScalarParameterValue('Scalar_EMP', EMPValue);
        }        
    }    
}

exec function BurnValTest(float BurnValue)
{
    local KFPawn_Monster P;
    local MaterialInstanceConstant MIC;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell())
        {
            MIC = ((P.bIsGoreMesh) ? P.GoreMIC : P.BodyMIC);
            MIC.SetScalarParameterValue('Scalar_Burnt', BurnValue);
        }        
    }    
}

simulated exec function SpawnAI(string ZedName, optional float Distance, optional name SpawnAtTag)
{
    local KFPawn Zed;

    Distance = 500;    
    Zed = SpawnAIZed(ZedName, Distance, SpawnAtTag);
    if(Zed != none)
    {
        Zed.SpawnDefaultController();
        if(KFAIController(Zed.Controller) != none)
        {
            KFAIController(Zed.Controller).SetTeam(1);
        }
    }
}

simulated exec function SpawnDebugAI(string ZedName, optional float Distance, optional name SpawnAtTag, optional bool bShowDebugTxt)
{
    local KFPawn Zed;

    Distance = 200;    
    bShowDebugTxt = false;
    Zed = SpawnAIZed(ZedName, Distance, SpawnAtTag);
    if(Zed != none)
    {
        Zed.SpawnDefaultController();
        if(Zed.Controller != none)
        {
            if(bShowDebugTxt)
            {
                KFPawn_Monster(Zed).SetDebugTextRendering(true);
                SetNPCDebugCategory(true, 'All');
            }
            KFAIController(Zed.Controller).BeginDebugCommand();
            KFAIController(Zed.Controller).DefaultCommandClass = Class'AICommand_Debug';
            KFAIController(Zed.Controller).MeleeCommandClass = Class'AICommand_Debug';
        }
    }
}

simulated exec function AIShowAttackAnims(optional bool bSetEnemyForDebugModeAI)
{
    local KFAIController KFAIC;

    bSetEnemyForDebugModeAI = true;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
        {
            if(Outer.IsAimingAt(KFAIC.Pawn, 0.95))
            {
                if(bSetEnemyForDebugModeAI)
                {
                    KFAIC.SetEnemy(Outer.Pawn);
                }
                if(KFAIC.bDebug_DrawAttackAnimInfo)
                {
                    KFAIC.bDebug_DrawAttackAnimInfo = false;
                    Outer.ClientMessage("Turning off attack animation info for " $ string(KFAIC.Pawn), CheatType);                    
                    return;
                    continue;
                }
                KFAIC.bDebug_DrawAttackAnimInfo = true;
                KFAIC.SetPostRendering(true);
                KFAIC.bDebug_PostRenderInfo = true;
                Outer.ClientMessage("Now showing attack animation info for " $ string(KFAIC.Pawn), CheatType);                
                return;
            }
        }        
    }    
    Outer.ClientMessage("You need to be aiming at an NPC first!", CheatType);
}

simulated function KFPawn SpawnAIZed(string ZedName, float Distance, optional name SpawnAtTag)
{
    local KFPawn Zed;

    Zed = SpawnZed(ZedName, Distance,, SpawnAtTag);
    LogInternal((string(GetFuncName()) $ "() Spawned: ") $ string(Zed));
    return Zed;
}

exec function SetBossNum(int PosInBossArray)
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager ForcedBossNum" @ string(PosInBossArray));
}

function class<KFPawn_Monster> LoadMonsterByName(string ZedName)
{
    if(Left(ZedName, 5) ~= "ClotA")
    {
        return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Alpha", Class'Class'));        
    }
    else
    {
        if(Left(ZedName, 5) ~= "ClotS")
        {
            return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Slasher", Class'Class'));            
        }
        else
        {
            if(Left(ZedName, 5) ~= "ClotC")
            {
                return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Cyst", Class'Class'));                
            }
            else
            {
                if(ZedName ~= "CLOT")
                {
                    return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Cyst", Class'Class'));                    
                }
                else
                {
                    if(Left(ZedName, 3) ~= "FHa")
                    {
                        return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHansFriendlyTest", Class'Class'));                        
                    }
                    else
                    {
                        if(Left(ZedName, 3) ~= "FHu")
                        {
                            return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHuskFriendlyTest", Class'Class'));                            
                        }
                        else
                        {
                            if(Left(ZedName, 1) ~= "F")
                            {
                                return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedFleshpound", Class'Class'));                                
                            }
                            else
                            {
                                if(Left(ZedName, 1) ~= "G")
                                {
                                    return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedGorefast", Class'Class'));                                    
                                }
                                else
                                {
                                    if(Left(ZedName, 2) ~= "St")
                                    {
                                        return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedStalker", Class'Class'));                                        
                                    }
                                    else
                                    {
                                        if(Left(ZedName, 1) ~= "B")
                                        {
                                            return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat", Class'Class'));                                            
                                        }
                                        else
                                        {
                                            if(Left(ZedName, 2) ~= "Sc")
                                            {
                                                return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedScrake", Class'Class'));                                                
                                            }
                                            else
                                            {
                                                if(Left(ZedName, 2) ~= "Pa")
                                                {
                                                    return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedPatriarch", Class'Class'));                                                    
                                                }
                                                else
                                                {
                                                    if(Left(ZedName, 2) ~= "Cr")
                                                    {
                                                        return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedCrawler", Class'Class'));                                                        
                                                    }
                                                    else
                                                    {
                                                        if(Left(ZedName, 2) ~= "Hu")
                                                        {
                                                            return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHusk", Class'Class'));                                                            
                                                        }
                                                        else
                                                        {
                                                            if(Left(ZedName, 8) ~= "TestHusk")
                                                            {
                                                                return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHusk_New", Class'Class'));                                                                
                                                            }
                                                            else
                                                            {
                                                                if(Left(ZedName, 2) ~= "Ha")
                                                                {
                                                                    return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHans", Class'Class'));                                                                    
                                                                }
                                                                else
                                                                {
                                                                    if(Left(ZedName, 2) ~= "Si")
                                                                    {
                                                                        return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedSiren", Class'Class'));                                                                        
                                                                    }
                                                                    else
                                                                    {
                                                                        if(Left(ZedName, 1) ~= "P")
                                                                        {
                                                                            return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedPatriarch", Class'Class'));
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    Outer.ClientMessage(("Could not spawn ZED [" $ ZedName) $ "]. Please make sure you specified a valid ZED name (ClotA, ClotS, ClotC, etc.) and that the ZED has a valid archetype setup.", CheatType);
}

exec function SpawnHumanPawn(optional bool bEnemy, optional bool bUseGodMode, optional int CharIndex)
{
    local KFAIController KFBot;
    local KFPlayerReplicationInfo KFPRI;
    local Vector CamLoc;
    local Rotator CamRot;
    local KFPawn_Human KFPH;
    local Vector HitLocation, HitNormal;
    local Actor TraceOwner;

    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    if(Outer.Pawn != none)
    {
        TraceOwner = Outer.Pawn;        
    }
    else
    {
        TraceOwner = Outer;
    }
    TraceOwner.Trace(HitLocation, HitNormal, CamLoc + (vector(CamRot) * float(250000)), CamLoc, true, vect(0, 0, 0));
    HitLocation.Z += float(100);
    KFPH = Outer.Spawn(Class'KFPawn_Human',,, HitLocation);
    KFPH.SetPhysics(2);
    KFBot = Outer.Spawn(Class'KFAIController');
    Outer.WorldInfo.Game.ChangeName(KFBot, "Braindead Human", false);
    if(!bEnemy)
    {
        KFGameInfo(Outer.WorldInfo.Game).SetTeam(KFBot, KFGameInfo(Outer.WorldInfo.Game).Teams[0]);
    }
    KFBot.Possess(KFPH, false);
    if(bUseGodMode)
    {
        KFBot.bGodMode = true;
    }
    KFPRI = KFPlayerReplicationInfo(KFBot.PlayerReplicationInfo);
    KFPRI.CurrentPerkClass = Class'KFPlayerController'.default.PerkList[1].PerkClass;
    KFPRI.NetPerkIndex = 1;
    if(KFPRI != none)
    {
        KFPRI.PlayerHealth = byte(KFPH.Health);
        KFPRI.PlayerHealthMax = byte(KFPH.HealthMax);
    }
    KFPH.AddDefaultInventory();
}

exec function KillBots()
{
    local Controller P;

    foreach Outer.WorldInfo.AllControllers(Class'Controller', P)
    {
        if((KFAIController(P) != none) && KFAIController(P).bIsPlayer)
        {
            P.Pawn.KilledBy(P.Pawn);
            P.Destroy();
        }        
    }    
}

simulated exec function KFPawn SpawnZed(string ZedName, optional float Distance, optional bool bNoCollisionFail, optional name SpawnAtTag)
{
    local class<KFPawn> SpawnClass;
    local Vector SpawnLoc;
    local Rotator SpawnRot;
    local KFPawn KFP;
    local KFPathnode KFPN;

    Distance = 200;        
    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return none;
    }
    if(SpawnAtTag != 'None')
    {
        foreach Outer.WorldInfo.AllNavigationPoints(Class'KFPathnode', KFPN)
        {
            if(KFPN.DebugTag != 'None')
            {
                if(KFPN.DebugTag == SpawnAtTag)
                {
                    SpawnLoc = KFPN.Location;
                }
            }            
        }                
    }
    else
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
    }
    SpawnLoc += ((Distance * vector(Outer.Rotation)) + (vect(0, 0, 1) * float(15)));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot,, bNoCollisionFail);
    if(KFP != none)
    {
        KFP.SetPhysics(2);
        if(KFGameInfo(Outer.WorldInfo.Game) != none)
        {
            KFGameInfo(Outer.WorldInfo.Game).SetAIDefaults(KFPawn_Monster(KFP));
        }        
    }
    else
    {
        Outer.ClientMessage(("Could not spawn ZED [" $ ZedName) $ "]. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
    }
    return KFP;
}

simulated exec function SpawnZedGroup(string ZedName, int NumRows, int NumCols, optional float Spacing, optional bool bUseGoreLOD, optional int ForcedLOD)
{
    local class<KFPawn> SpawnClass;
    local Vector StartLoc, SpawnLoc, RightDir, FaceDir;
    local Rotator SpawnRot;
    local KFPawn KFP;
    local KFPawn_Monster KFPM;
    local int I, J;

    Spacing = 100;
    bUseGoreLOD = false;
    ForcedLOD = 0;
    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return;
    }
    if(Outer.Pawn != none)
    {
        StartLoc = Outer.Pawn.Location;        
    }
    else
    {
        StartLoc = Outer.Location;
    }
    FaceDir = Normal(GetRotatorAxis(Outer.Rotation, 0));
    RightDir = Normal(GetRotatorAxis(Outer.Rotation, 1));
    I = 0;
    J0x142:

    if(I < NumRows)
    {
        J = 0;
        J0x164:

        if(J < NumCols)
        {
            SpawnLoc = ((StartLoc + ((float(I + 1) * Spacing) * FaceDir)) + ((float(J - (NumCols / 2)) * Spacing) * RightDir)) + (vect(0, 0, 1) * float(15));
            SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
            KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
            if(KFP != none)
            {
                KFP.SetPhysics(2);
                if(bUseGoreLOD)
                {
                    KFPM = KFPawn_Monster(KFP);
                    if(KFPM != none)
                    {
                        KFPM.SwitchToGoreMesh(KFPM.GetCharacterMonsterInfo().GoreMesh, KFPM.GetCharacterMonsterInfo().CharacterGoreMaterialID);
                        KFPM.GoreMeshSwapped();                        
                    }
                    else
                    {
                        Outer.ClientMessage("Failed to switch to gore LOD", CheatType);
                    }
                }
                if(ForcedLOD != 0)
                {
                    KFP.Mesh.ForcedLodModel = ForcedLOD;
                }
            }
            ++ J;
            goto J0x164;
        }
        ++ I;
        goto J0x142;
    }
}

simulated exec function SpawnZedLODs(string ZedName)
{
    local class<KFPawn> SpawnClass;
    local Vector StartLoc, SpawnLoc, RightDir, FaceDir;
    local Rotator SpawnRot;
    local KFPawn KFP;

    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return;
    }
    if(Outer.Pawn != none)
    {
        StartLoc = Outer.Pawn.Location;        
    }
    else
    {
        StartLoc = Outer.Location;
    }
    FaceDir = Normal(GetRotatorAxis(Outer.Rotation, 0));
    RightDir = Normal(GetRotatorAxis(Outer.Rotation, 1));
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) - (float(200) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 1;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) - (float(100) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 2;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) + (float(0) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 3;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) + (float(100) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 4;
}

function string GetRandomClotType()
{
    switch(Rand(2))
    {
        case 0:
            return "KFGameContent.KFPawn_ZedClot_Alpha";
        case 1:
            return "KFGameContent.KFPawn_ZedClot_Slasher";
        case 2:
            return "KFGameContent.KFPawn_ZedClot_Cyst";
        default:
            WarnInternal("GetRandomClotType no type selected");
            break;
    }
}

exec function TestPortalNearby(string ZedName, optional int NumSpawns)
{
    local KFSpawner Spawner, Best;
    local Vector MyLocation;
    local float bestDist;

    NumSpawns = 1;
    foreach Outer.WorldInfo.AllActors(Class'KFSpawner', Spawner)
    {
        MyLocation = ((Outer.Pawn != none) ? Outer.Pawn.Location : Outer.Location);
        if((Best == none) || VSize(Spawner.Location - MyLocation) < bestDist)
        {
            Best = Spawner;
            bestDist = VSize(Best.Location - MyLocation);
        }        
    }    
    if(Best != none)
    {
        Best.TestSpawn(LoadMonsterByName(ZedName), NumSpawns, true);
    }
}

exec function TestPortalAll(optional string ZedName)
{
    local KFSpawner Spawner;

    foreach Outer.WorldInfo.AllActors(Class'KFSpawner', Spawner)
    {
        Spawner.TestSpawn(LoadMonsterByName(ZedName), 1, true);
        Spawner.bIgnoreChildren = true;        
    }    
}

exec function TestPortalActive(optional string ZedName)
{
    local KFSpawner ActiveSpawner;

    ActiveSpawner = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.ActiveSpawner;
    if(ActiveSpawner != none)
    {
        ActiveSpawner.TestSpawn(LoadMonsterByName(ZedName), 1, true);        
    }
    else
    {
        Outer.ClientMessage("Warning - No spawn volume has been activated.", CheatType, 13);
        LogInternal("Say No spawn volume has been activated");
    }
}

exec function TestSpawnVolume(int SpawnAmount, optional bool bCrawlersOnly, optional bool bBloatsOnly)
{
    local KFSpawnVolume SpawnVolume, ClosestSpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    I = 0;
    J0x0D:

    if(I < SpawnAmount)
    {
        if(bCrawlersOnly)
        {
            TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedCrawler", Class'Class'));            
        }
        else
        {
            if(bBloatsOnly)
            {
                TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat", Class'Class'));                
            }
            else
            {
                TempPawn = class<KFPawn_Monster>(DynamicLoadObject(GetRandomClotType(), Class'Class'));
            }
        }
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x0D;
    }
    I = 0;
    J0x132:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0x132;
    }
    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        if(ClosestSpawnVolume == none)
        {
            ClosestSpawnVolume = SpawnVolume;
            continue;
        }
        if(Outer.Pawn != none)
        {
            if(VSize(SpawnVolume.Location - Outer.Pawn.Location) < VSize(ClosestSpawnVolume.Location - Outer.Pawn.Location))
            {
                ClosestSpawnVolume = SpawnVolume;
            }
            continue;
        }
        if(VSize(SpawnVolume.Location - Outer.Location) < VSize(ClosestSpawnVolume.Location - Outer.Location))
        {
            ClosestSpawnVolume = SpawnVolume;
        }        
    }    
    ClosestSpawnVolume.SpawnWave(FakeSpawnList, false);
}

exec function SetSpawnVolumeDebug(bool bSpawnDebug, optional bool bDebugRating, optional bool bDebugVisibility)
{
    local KFSpawnVolume SpawnVolume;
    local KFSpawner Spawner;

    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        SpawnVolume.bDebugSpawning = bSpawnDebug;
        SpawnVolume.bDebugRatingChecks = bDebugRating;
        SpawnVolume.bDebugVisibilityChecks = bDebugVisibility;        
    }    
    foreach Outer.AllActors(Class'KFSpawner', Spawner)
    {
        Spawner.bDebugSpawning = bSpawnDebug;        
    }    
    Outer.ClientMessage(("Setting bDebugSpawning to " $ string(bSpawnDebug)) $ " for Spawn Volumes and Portal Spawns", CheatType);
}

exec function SetSpawnVolumeMinDebug(bool bNewMinDebug)
{
    local KFSpawnVolume SpawnVolume;

    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        SpawnVolume.bMinimalDebugRatingChecks = bNewMinDebug;        
    }    
    Outer.ClientMessage(("Setting bMinimalDebugRatingChecks to " $ string(bNewMinDebug)) $ " for Spawn Volumes", CheatType);
}

exec function SpawnTest(int SpawnAmount, optional bool bSimSpawn, optional bool bSpawnZeds)
{
    local KFSpawnVolume SpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    Outer.FlushPersistentDebugLines();
    Outer.RemoveAllDebugStrings();
    I = 0;
    J0x4B:

    if(I < SpawnAmount)
    {
        TempPawn = class<KFPawn_Monster>(DynamicLoadObject(GetRandomClotType(), Class'Class'));
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x4B;
    }
    I = 0;
    J0xC2:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0xC2;
    }
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).SpawnManager.DesiredSquadType = 4;
        SpawnVolume = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.GetBestSpawnVolume(FakeSpawnList);
        if(bSimSpawn && !bSpawnZeds)
        {
            SpawnVolume.SetLastSpawnTime(Outer.WorldInfo.TimeSeconds);
            KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.AddRecentSpawnVolume(SpawnVolume.Location);
        }
    }
    Outer.ClientMessage("Checking Spawns, best volume = " $ string(SpawnVolume), CheatType);
    if(bSpawnZeds)
    {
        SpawnVolume.SpawnWave(FakeSpawnList, true);
    }
}

exec function SpawnBloatTest(int SpawnAmount, optional bool bSimSpawn, optional bool bSpawnZeds)
{
    local KFSpawnVolume SpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    Outer.FlushPersistentDebugLines();
    Outer.RemoveAllDebugStrings();
    I = 0;
    J0x4B:

    if(I < SpawnAmount)
    {
        TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat", Class'Class'));
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x4B;
    }
    I = 0;
    J0xD7:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0xD7;
    }
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).SpawnManager.DesiredSquadType = 4;
        SpawnVolume = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.GetBestSpawnVolume(FakeSpawnList);
        if(bSimSpawn && !bSpawnZeds)
        {
            SpawnVolume.SetLastSpawnTime(Outer.WorldInfo.TimeSeconds);
            KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.AddRecentSpawnVolume(SpawnVolume.Location);
        }
    }
    Outer.ClientMessage("Checking Spawns, best volume = " $ string(SpawnVolume), CheatType);
    if(bSpawnZeds)
    {
        SpawnVolume.SpawnWave(FakeSpawnList, true);
    }
}

exec function FocusOnZed(optional bool bTextOnly)
{
    local class<Actor> FocusClass;
    local Actor PotentialFocusActor, FirstActor;
    local bool bFound;

    bTextOnly = false;
    FocusClass = Class'KFPawn_Monster';
    foreach Outer.AllActors(FocusClass, PotentialFocusActor)
    {
        if((KFPawn(PotentialFocusActor) != none) && !KFPawn(PotentialFocusActor).IsAliveAndWell())
        {
            continue;            
        }
        if(bFound || FirstActor == none)
        {
            FirstActor = PotentialFocusActor;
            if(bFound)
            {
                break;
            }
        }
        if((DebugSceneCamera != none) && PotentialFocusActor == DebugSceneCamera.FocusActor)
        {
            bFound = true;
        }        
    }    
    if(FirstActor != none)
    {
        Outer.ClientMessage(("Focusing on Zed: " $ string(FirstActor.Name)) $ " [Note: For additional debug scene window, add TRUE to the command ( FocusOnZed TRUE )]", CheatType);
        InitDebugScene(FirstActor, bTextOnly);
    }
}

exec function FocusOn(class<Actor> FocusClass, optional bool bTextOnly)
{
    local Actor PotentialFocusActor, FirstActor;
    local bool bFound;

    bTextOnly = false;
    foreach Outer.AllActors(FocusClass, PotentialFocusActor)
    {
        if((Pawn(PotentialFocusActor) != none) && !Pawn(PotentialFocusActor).IsAliveAndWell())
        {
            continue;            
        }
        if(bFound || FirstActor == none)
        {
            FirstActor = PotentialFocusActor;
            if(bFound)
            {
                break;
            }
        }
        if((DebugSceneCamera != none) && PotentialFocusActor == DebugSceneCamera.FocusActor)
        {
            bFound = true;
        }        
    }    
    if(FirstActor != none)
    {
        Outer.ClientMessage("DebugView from: " $ string(FirstActor.Name), CheatType);
        InitDebugScene(FirstActor, bTextOnly);
    }
}

function InitDebugScene(Actor ActorToWatch, optional bool bTextOnly)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(KFPC != none)
    {
        if(DebugSceneCamera == none)
        {
            DebugSceneCamera = Outer.Spawn(Class'KFSceneCaptureDebugCam', Outer.Pawn,, Outer.Pawn.Location, Outer.Pawn.Rotation,, true);
            DebugSceneCamera.bTextOnly = bTextOnly;
        }
        Outer.myHUD.bShowOverlays = true;
        Outer.myHUD.AddPostRenderedActor(DebugSceneCamera);
        bDebugSceneEnabled = DebugSceneCamera.InitDebugScene(KFPC, ActorToWatch);
    }
}

exec function WeldDoors(optional int inNewIntegrity)
{
    local KFDoorActor KFDA;
    local int NewIntegrity;

    inNewIntegrity = -1;
    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        if(inNewIntegrity == -1)
        {
            NewIntegrity = KFDA.MaxWeldIntegrity;            
        }
        else
        {
            NewIntegrity = inNewIntegrity;
        }
        KFDA.WeldIntegrity = NewIntegrity;        
    }    
}

exec function DestroyDoors(optional byte Reverse)
{
    local KFDoorActor KFDA;

    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        ++ KFDA.HitCount;
        if(Reverse != 0)
        {
            KFDA.HitCount = byte(KFDA.HitCount | KFDA.128);            
        }
        else
        {
            KFDA.HitCount = byte(KFDA.HitCount & byte(~KFDA.128));
        }
        KFDA.PlayDestroyed();        
    }    
}

exec function ResetDoors()
{
    local KFDoorActor KFDA;

    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        KFDA.ResetDoor();        
    }    
}

exec function AISetFocalPoint(optional bool bClear)
{
    local KFAIController KFAIC;

    bClear = false;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if((KFAIC != none) && Outer.FastTrace(KFAIC.Pawn.Location, Outer.Pawn.Location))
        {
            if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
            {
                if(bClear)
                {
                    Outer.SetFocalPoint(vect(0, 0, 0));
                    continue;
                }
                KFAIC.SetFocalPoint(Outer.Pawn.Location);
            }
        }        
    }    
    Outer.ClientMessage((string(KFAIC.Pawn) $ "'s FocalPoint is now ") $ string(KFAIC.GetFocalPoint()), CheatType);
}

exec function AIClearFocus(optional bool bResetDesiredRot, optional bool bResetFocus, optional bool bResetFocalPoint)
{
    local KFAIController KFAIC;
    local string msg;

    KFAIC = GetKFAICFromAim(false);
    if(KFAIC != none)
    {
        msg = string(Outer.Pawn) $ " [ClearFocus]";
        if(bResetDesiredRot)
        {
            msg = msg $ "[Resetting DesiredRotation]";
            KFAIC.MyKFPawn.ResetDesiredRotation();
        }
        if(bResetFocalPoint)
        {
            msg = msg $ "[Resetting FocalPoint]";
            KFAIC.SetFocalPoint(vect(0, 0, 0));
        }
        if(bResetFocus)
        {
            msg = msg $ "[Resetting Focus]";
            KFAIC.Focus = none;
        }
    }
}

exec function AIUnlockDesiredRotation()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.LockDesiredRotation(false);
    }
}

exec function AILockDesiredRotation(optional bool bLock)
{
    local KFAIController KFAIC;

    bLock = true;
    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.LockDesiredRotation(bLock);
    }
}

exec function AISetFocus(optional bool bFocusOnMe, optional bool bSetFocalPoint, optional bool bSetDesiredRot, optional bool bLockDesiredRot)
{
    local KFAIController KFAIC;
    local string msg;

    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        msg = string(KFAIC.Pawn) $ " [SetFocus]";
        if(bSetDesiredRot)
        {
            KFAIC.MyKFPawn.SetDesiredRotation(rotator(GetMyPawn().Location - KFAIC.Pawn.Location), bLockDesiredRot);
            msg = ((msg $ "[DesiredRot: ") $ string(KFAIC.MyKFPawn.DesiredRotation)) $ "]";
        }
        if(bSetFocalPoint)
        {
            KFAIC.SetFocalPoint(GetMyPawn().Location);
            msg = ((msg $ "[FocalPoint: ") $ string(KFAIC.GetFocalPoint())) $ "]";
        }
        if(bFocusOnMe)
        {
            KFAIC.Focus = GetMyPawn();
            msg = ((msg $ "[Focus: ") $ string(Outer.Focus)) $ "]";
        }
        Outer.ClientMessage(msg, CheatType);
    }
}

exec function FocusOff()
{
    DestroyDebugScene();
}

function DestroyDebugScene()
{
    bDebugSceneEnabled = false;
    Outer.myHUD.bShowOverlays = false;
    if(DebugSceneCamera != none)
    {
        Outer.myHUD.RemovePostRenderedActor(DebugSceneCamera);
        DebugSceneCamera.DestroyDebugScene();
        DebugSceneCamera = none;
    }
}

exec function ToggleDebugSceneOrbit()
{
    if(DebugSceneCamera != none)
    {
        DebugSceneCamera.ToggleDebugSceneOrbit();
    }
}

exec function PauseDebugSceneUpdate()
{
    if(DebugSceneCamera != none)
    {
        DebugSceneCamera.PauseDebugSceneUpdate();
    }
}

function SetDebugSceneViewMode(Engine.SceneCaptureComponent.ESceneCaptureViewMode NewViewMode)
{
    if(bDebugSceneEnabled && DebugSceneCamera != none)
    {
        DebugSceneCamera.SetDebugSceneViewMode(NewViewMode);
    }
}

exec function SetDebugSceneView()
{
    if(bDebugSceneEnabled && DebugSceneCamera != none)
    {
        DebugSceneCamera.MoveToMyPawnLocation();
    }
}

exec function ToggleSplatterGun()
{
    local KeyBind TempKeyBind;
    local KFPlayerInput KFInput;

    TempKeyBind.Name = 'LeftMouseButton';
    KFInput = KFPlayerInput(Outer.PlayerInput);
    if(KFInput != none)
    {
        if(!bUsingSplatterGun && KFPlayerInput(Outer.PlayerInput) != none)
        {
            KFInput.RemoveCommandFromBind(TempKeyBind, "GBA_Fire");
            KFInput.SetKeyBind(TempKeyBind, "SplatterFire");
            bUsingSplatterGun = true;            
        }
        else
        {
            KFInput.RemoveCommandFromBind(TempKeyBind, "SplatterFire");
            KFInput.SetKeyBind(TempKeyBind, "GBA_Fire");
            bUsingSplatterGun = false;
        }
    }
}

exec function SplatterFire()
{
    local KFGoreManager GoreManager;
    local Vector StartTrace, TraceDir;

    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        WarnInternal("##### Could not find gore manager #####");
        return;
    }
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    GoreManager.LeaveAPersistentBloodSplat(StartTrace, TraceDir);
}

exec function ClearSplatters()
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        WarnInternal("##### Could not find gore manager #####");
        return;
    }
    GoreManager.ClearPersistentBloodSplats();
}

exec function ClearCorpses()
{
    local int I;
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        return;
    }
    I = GoreManager.CorpsePool.Length - 1;
    J0x83:

    if(I >= 0)
    {
        GoreManager.RemoveAndDeleteCorpse(I);
        -- I;
        goto J0x83;
    }
}

exec function CameraBlood()
{
    Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_BloodBase');
}

exec function HeadShotPing(bool Value)
{
    if(Value)
    {
        Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_RackemHeadShotPing');        
    }
    else
    {
        Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_RackemHeadShot');
    }
}

exec function CameraPuke()
{
    Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_Puke');
}

exec function EnableAtkAnimDifficultyScaling()
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAnimInfo bEnableDifficultyScaling true");
}

exec function DisableAtkAnimDifficultyScaling()
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAnimInfo bEnableDifficultyScaling false");
}

exec function ToggleAIDefaultsLog()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.bLogAIDefaults = !KFGI.bLogAIDefaults;
    }
}

exec function SetLivingPlayers(byte NewLivingPlayers)
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.ForceLivingPlayerCount(NewLivingPlayers);
    }
}

exec function ConvertFOV(float InFOV)
{
    local float AspectRatio, OriginalAspectRatio, NewFOV;

    AspectRatio = 16 / float(9);
    OriginalAspectRatio = 4 / float(3);
    NewFOV = (Atan2(Tan((InFOV * 3.141593) / 360) * (AspectRatio / OriginalAspectRatio), 1) * 360) / 3.141593;
    LogInternal((("FOV --- Original:" @ string(InFOV)) @ "New:") @ string(NewFOV));
}

exec function TurnOnAIArenaLight()
{
    local PointLightToggleable PLT;

    foreach Outer.WorldInfo.AllActors(Class'PointLightToggleable', PLT)
    {
        PLT.bEnabled = true;
        PLT.LightComponent.SetEnabled(true);
        PLT.LastRenderTime = Outer.WorldInfo.TimeSeconds;        
    }    
}

exec function SetNadeRadiusDebug(bool bShowRadius)
{
    Class'KFExplosionActor'.default.bDrawDebug = bShowRadius;
    Class'KFExplosionActor'.static.StaticSaveConfig();
}

exec function LaunchChunks(int NumChunks, bool bNoSpread)
{
    local Vector SpawnPos, BaseChunkDir;
    local Rotator Rot;
    local int I;
    local Projectile NewChunk;
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local KFPerk MyPerk;

    MyPerk = KFPawn(Outer.Pawn).GetPerk();
    Outer.GetPlayerViewPoint(ViewLocation, ViewRotation);
    SpawnPos = ViewLocation;
    if((Outer.Pawn != none) && Outer.Pawn.Role == ROLE_Authority)
    {
        BaseChunkDir = vector(ViewRotation);
        I = 0;
        J0x10F:

        if(I < NumChunks)
        {
            if(bNoSpread)
            {
                Rot = rotator(BaseChunkDir);                
            }
            else
            {
                Rot = rotator((float(8) * BaseChunkDir) + VRand());
            }
            NewChunk = Outer.Pawn.Weapon.Spawn(MyPerk.GrenadeClass.default.ExplosionTemplate.ShardClass, ((Outer.Pawn.Weapon != none) ? Outer.Pawn.Weapon : Outer.Pawn),, SpawnPos, Rot);
            if(NewChunk != none)
            {
                NewChunk.Init(vector(Rot));
            }
            ++ I;
            goto J0x10F;
        }
    }
}

exec function ShowMeleeCollision(optional bool bEnable)
{
    bEnable = true;    
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bDebugShowCollision" @ string(bEnable));
}

exec function Chris()
{
    Outer.ConsoleCommand("SUPPRESS DevPhysics");
    God();
    AllWeapons();
    UberAmmo();    
    Outer.ConsoleCommand("ToggleSpawning");
}

exec function TestGameSearch(optional bool bSearchLan)
{
    local KFDataStore_OnlineGameSearch SearchDataStore;
    local DataStoreClient DataStoreManager;
    local bool succeed;
    local OnlineGameSearch GameSearch;

    DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
    if(DataStoreManager == none)
    {
        LogInternal("No data store manager");
        Outer.ClientMessage("No data store manager", CheatType);
        return;
    }
    SearchDataStore = KFDataStore_OnlineGameSearch(DataStoreManager.FindDataStore('KFGameSearch', LocalPlayer(Outer.Player)));
    if(SearchDataStore == none)
    {
        LogInternal("No search data store found");
        Outer.ClientMessage("No search data store found", CheatType);
        return;
    }
    GameSearch = SearchDataStore.GetCurrentGameSearch();
    if(GameSearch == none)
    {
        LogInternal("No current game search found");
        Outer.ClientMessage("No current game search found", CheatType);
        return;
    }
    GameSearch.bIsLanQuery = bSearchLan;
    succeed = SearchDataStore.SubmitGameSearch(0);
    if(succeed)
    {
        LogInternal("Search start succeeded");
        Outer.ClientMessage("Search start succeeded", CheatType);        
    }
    else
    {
        LogInternal("Search start failed");
        Outer.ClientMessage("Search start failed", CheatType);
    }
}

exec function ShowLevelUpPopUp(bool bTierUnlock)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(((KFPC != none) && KFPC.MyGFxHUD != none) && KFPC.MyGFxHUD.LevelUpNotificationWidget != none)
    {
        KFPC.MyGFxHUD.LevelUpNotificationWidget.ShowLevelUpNotification(KFPC.CurrentPerk.Class, KFPC.GetLevel(), bTierUnlock);
    }
}

exec function GetCurrentPerkXP()
{
    Outer.ClientMessage((("Perk:" @ Mid(string(KFPawn(Outer.Pawn).GetPerk()), 7)) @ "XP:") @ string(KFPlayerController(Outer).GetPerkXP(KFPawn(Outer.Pawn).GetPerk().Class)), CheatType);
}

exec function TestFalloffDamage(float Distance, float MaxRadius, float FalloffExponent)
{
    local float DamageScale;

    DamageScale = FClamp(1 - (Distance / MaxRadius), 0, 1);
    DamageScale = DamageScale ** FalloffExponent;
    LogInternal((string(GetFuncName()) @ "Result:") $ string(DamageScale));
}

exec function ZedTimeTest(float NewCustomTimeDilation)
{
    GetMyPawn().CustomTimeDilation = NewCustomTimeDilation;
    GetMyPawn().Weapon.CustomTimeDilation = NewCustomTimeDilation;
}

exec function FakeDramaEvent()
{
    DramaEvent(1);
    ZedTimeTest(5);
    Outer.SetTimer(0.6, false, 'ClearFakeDramaEvent', self);
}

simulated function ClearFakeDramaEvent()
{
    GetMyPawn().CustomTimeDilation = 1;
    GetMyPawn().Weapon.CustomTimeDilation = 1;
}

exec function StopPosedPlayers()
{
    Class'KFDebugPosedPlayer'.static.StopPosedPlayers(Outer.WorldInfo);
}

exec function SpawnPosedPlayers()
{
    Class'KFDebugPosedPlayer'.static.SpawnPosedPlayers(Outer.WorldInfo);
}

exec function PossessPosedPlayer()
{
    Class'KFDebugPosedPlayer'.static.PossessPosedPlayer(Outer.WorldInfo);
}

exec function DBJump()
{
    local Vector UsedKickMomentum;

    if(Outer.Pawn != none)
    {
        UsedKickMomentum.X = -1000;
        if(Outer.Pawn.Physics == 2)
        {
            UsedKickMomentum = UsedKickMomentum >> Outer.Pawn.GetViewRotation();
            UsedKickMomentum *= 0.5;            
        }
        else
        {
            UsedKickMomentum = UsedKickMomentum >> Outer.Pawn.Rotation;
            UsedKickMomentum.Z = 0;
        }
        Outer.Pawn.AddVelocity(UsedKickMomentum, Outer.Pawn.Location, none);
    }
}

exec function ShowKFGameVersion()
{
    LogInternal("Current KFGame version:" @ string(Class'KFGameEngine'.static.GetKFGameVersion()));
}

exec function LogAmmoPickups()
{
    local KFGameInfo KFGI;
    local float NumTotalAmmoPickups, NumActiveAmmoPickups, NumSleepingAmmoPickups, NumDisabledAmmoPickups;
    local int I;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        LogInternal("~~LogAmmoPickups START~~~");
        I = 0;
        J0x7E:

        if(I < KFGI.AmmoPickups.Length)
        {
            NumTotalAmmoPickups += 1;
            if(KFGI.AmmoPickups[I].IsInState('Disabled'))
            {
                NumDisabledAmmoPickups += 1;
                LogInternal((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is disabled! Location:") @ string(KFGI.AmmoPickups[I].Location));                
            }
            else
            {
                if(KFGI.AmmoPickups[I].IsInState('Sleeping'))
                {
                    NumSleepingAmmoPickups += 1;
                    LogInternal((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is sleeping! Location:") @ string(KFGI.AmmoPickups[I].Location));                    
                }
                else
                {
                    if(KFGI.AmmoPickups[I].IsInState('Pickup'))
                    {
                        NumActiveAmmoPickups += 1;
                        LogInternal((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is ACTIVE! Location:") @ string(KFGI.AmmoPickups[I].Location));
                    }
                }
            }
            ++ I;
            goto J0x7E;
        }
        LogInternal("~~LogAmmoPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogAmmoPickups: Total num ammo pickup ups:   " @ string(Round(NumTotalAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Disabled ammo pickup ups:    " @ string(Round(NumDisabledAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Sleeping ammo pickup ups:    " @ string(Round(NumSleepingAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Active ammo pickup ups:      " @ string(Round(NumActiveAmmoPickups)));
        LogInternal(((((((("~~LogAmmoPickups: Percentages: Disabled:" @ string((float(100) / NumTotalAmmoPickups) * NumDisabledAmmoPickups)) $ "%") @ "Sleeping:") @ string((float(100) / NumTotalAmmoPickups) * NumSleepingAmmoPickups)) $ "%") @ "Active:") @ string((float(100) / NumTotalAmmoPickups) * NumActiveAmmoPickups)) $ "%");
        LogInternal("~~LogAmmoPickups END~~~");
    }
}

exec function LogItemPickups()
{
    local KFGameInfo KFGI;
    local float NumTotalItemPickups, NumActiveItemPickups, NumSleepingItemPickups, NumDisabledItemPickups;
    local int I;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogItemPickups START~~~");
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        I = 0;
        J0xF2:

        if(I < KFGI.ItemPickups.Length)
        {
            NumTotalItemPickups += 1;
            if(KFGI.ItemPickups[I].IsInState('Disabled'))
            {
                NumDisabledItemPickups += 1;
                LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is disabled! Location:") @ string(KFGI.ItemPickups[I].Location));                
            }
            else
            {
                if(KFGI.ItemPickups[I].IsInState('Sleeping'))
                {
                    NumSleepingItemPickups += 1;
                    LogInternal("~~LogItemPickups -------------------------------------");
                    LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is sleeping! Location:") @ string(KFGI.ItemPickups[I].Location));                    
                }
                else
                {
                    if(KFGI.ItemPickups[I].IsInState('Pickup'))
                    {
                        NumActiveItemPickups += 1;
                        LogInternal("~~LogItemPickups -------------------------------------");
                        LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is ACTIVE! Location:") @ string(KFGI.ItemPickups[I].Location));
                        LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "item is a") @ string(KFPickupFactory_Item(KFGI.ItemPickups[I]).ItemPickups[KFPickupFactory_Item(KFGI.ItemPickups[I]).PickupIndex].ItemClass.Name));
                    }
                }
            }
            ++ I;
            goto J0xF2;
        }
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogItemPickups: Total num item pickups:   " @ string(Round(NumTotalItemPickups)));
        LogInternal("~~LogItemPickups: Disabled item pickups:    " @ string(Round(NumDisabledItemPickups)));
        LogInternal("~~LogItemPickups: Sleeping item pickups:    " @ string(Round(NumSleepingItemPickups)));
        LogInternal("~~LogItemPickups: Active item pickups:      " @ string(Round(NumActiveItemPickups)));
        LogInternal(((((((("~~LogItemPickups: Percentages: Disabled:" @ string((float(100) / NumTotalItemPickups) * NumDisabledItemPickups)) $ "%") @ "Sleeping:") @ string((float(100) / NumTotalItemPickups) * NumSleepingItemPickups)) $ "%") @ "Active:") @ string((float(100) / NumTotalItemPickups) * NumActiveItemPickups)) $ "%");
        LogInternal("~~LogItemPickups END~~~");
    }
}

exec function ToggleRelevancyView()
{
    local Actor A;

    foreach Outer.AllActors(Class'Actor', A)
    {
        if(A.bIgnoreNetRelevancyCollision)
        {
            A.SetHidden(!A.bHidden);
        }        
    }    
}

exec function ToggleVisibilityView()
{
    local Actor A;
    local StaticMeshActor SM;
    local editinline StaticMeshComponent SMC;

    foreach Outer.AllActors(Class'Actor', A)
    {
        SM = StaticMeshActor(A);
        if(SM != none)
        {
            SMC = SM.StaticMeshComponent;
            if(!SMC.RBCollideWithChannels.Visibility)
            {
                SMC.SetHidden(!SMC.HiddenGame);
            }
            continue;
        }
        A.SetHidden(!A.bHidden);        
    }    
}

exec function LogServerMovementVars()
{
    if(Outer.Pawn != none)
    {
        LogInternal((string(Outer.Pawn) @ "Velocity:") @ string(Outer.Pawn.Velocity));
        LogInternal((string(Outer.Pawn) @ "Acceleration:") @ string(Outer.Pawn.Acceleration));
        LogInternal((string(Outer.Pawn) @ "Physics:") @ string(Outer.Pawn.Physics));
        LogInternal((string(Outer.Pawn) @ "bIsWalking:") @ string(Outer.Pawn.bIsWalking));
        LogInternal((string(Outer.Pawn) @ "bIsSprinting:") @ string(KFPawn(Outer.Pawn).bIsSprinting));
        LogInternal((string(Outer.Pawn) @ "bIsCrouched:") @ string(Outer.Pawn.bIsCrouched));
        LogInternal((string(Outer.Pawn) @ "WeaponEncumbrance:") @ string(KFInventoryManager(Outer.Pawn.InvManager).GetEncumbranceSpeedMod()));
        LogInternal((string(Outer.Pawn) @ "GroundSpeed:") @ string(Outer.Pawn.GroundSpeed));
        LogInternal((string(Outer.Pawn) @ "Speed:") @ string(VSize(Outer.Pawn.Velocity)));
        LogInternal((string(Outer.Pawn) @ "MovementSpeedModifier:") @ string(Outer.Pawn.MovementSpeedModifier));
        LogInternal((string(Outer.Pawn) @ "Controller State:") @ string(Outer.GetStateName()));
    }
}

exec function RespawnSpectators()
{
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).StartHumans();
    }
}

exec function WeaponGotoState(name StateName)
{
    if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
    {
        Outer.Pawn.Weapon.GotoState(StateName);
    }
}

exec function SetWeaponSkin(int MaterialIndex, string MaterialName)
{
    local MaterialInterface NewMat;

    if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
    {
        NewMat = MaterialInterface(DynamicLoadObject(MaterialName, Class'MaterialInterface'));
        Outer.Pawn.Weapon.Mesh.SetMaterial(MaterialIndex, NewMat);
    }
}

exec function DemiGod()
{
    if(Outer.bDemiGodMode)
    {
        Outer.bDemiGodMode = false;
        Outer.ClientMessage("Demi God mode off");
        return;
    }
    Outer.bDemiGodMode = true;
    Outer.ClientMessage("Demi God Mode on");
}

exec function TestGrapple()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.CanDoSpecialMove(4))
        {
            P.DoSpecialMove(4, true, Outer.Pawn);
        }        
    }    
}

defaultproperties
{
    CheatType=KFCheat
    DebugCameraControllerClassName="KFGame.KFDebugCameraController"
}