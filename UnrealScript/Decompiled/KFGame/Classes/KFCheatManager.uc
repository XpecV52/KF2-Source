/*******************************************************************************
 * KFCheatManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFCheatManager extends GameCheatManager within GamePlayerController
    native
    config(Game);

const KFID_QuickWeaponSelect = 100;
const KFID_CurrentLayoutIndex = 101;
const KFID_ForceFeedbackEnabled = 103;
const KFID_SavedPerkIndex = 105;
const KFID_AllowBloodSplatterDecals = 106;
const KFID_GoreLevel = 107;
const KFID_StoredCharIndex = 111;
const KFID_MasterVolumeMultiplier = 112;
const KFID_DialogVolumeMultiplier = 113;
const KFID_MusicVolumeMultiplier = 114;
const KFID_SFXVolumeMultiplier = 115;
const KFID_GammaMultiplier = 117;
const KFID_MusicVocalsEnabled = 118;
const KFID_MinimalChatter = 119;
const KFID_ShowCrossHair = 121;
const KFID_FOVOptionsPercentageValue = 122;
const KFID_ShowKillTicker = 123;
const KFID_FriendlyHudScale = 125;
const KFID_FavoriteWeapons = 127;
const KFID_GearLoadouts = 128;
const KFID_SetGamma = 129;
const KFID_RequiresPushToTalk = 130;
const KFID_InvertController = 131;
const KFID_AutoTargetEnabled = 132;
const KFID_GamepadSensitivityScale = 133;
const KFID_ZoomedSensitivityScale = 134;
const KFID_GamepadZoomedSensitivityScale = 135;
const KFID_EnableMouseSmoothing = 136;
const KFID_MouseSensitivity = 138;
const KFID_TargetAdhesionEnabled = 139;
const KFID_TargetFrictionEnabled = 140;
const KFID_InvertMouse = 142;
const KFID_DEPRECATED_143 = 143;
const KFID_SavedSoloModeIndex = 144;
const KFID_SavedSoloMapString = 145;
const KFID_SavedSoloDifficultyIndex = 146;
const KFID_SavedSoloLengthIndex = 147;
const KFID_SavedModeIndex = 148;
const KFID_SavedMapString = 149;
const KFID_SavedDifficultyIndex = 150;
const KFID_SavedLengthIndex = 151;
const KFID_SavedPrivacyIndex = 152;
const KFID_SavedServerTypeIndex = 153;
const KFID_SavedInProgressIndex = 154;
const KFID_ControllerSoundEnabled = 155;
const KFID_MatchmakingRegion = 156;
const KFID_UseAltAimOnDuals = 157;
const KFID_HideBossHealthBar = 158;
const KFID_AntiMotionSickness = 159;
const KFID_ShowWelderInInventory = 160;
const KFID_AutoTurnOff = 161;
const KFID_ReduceHightPitchSounds = 162;
const KFID_ShowConsoleCrossHair = 163;
const KFID_VOIPVolumeMultiplier = 164;
const KFID_WeaponSkinAssociations = 165;
const KFID_SavedEmoteId = 166;
const KFID_DisableAutoUpgrade = 167;
const KFID_SafeFrameScale = 168;
const KFID_Native4kResolution = 169;
const KFID_HideRemoteHeadshotEffects = 170;
const KFID_SavedHeadshotID = 171;
const KFID_ToggleToRun = 172;
const KFID_ClassicPlayerInfo = 173;
const KFID_VOIPMicVolumeMultiplier = 174;

var bool bDebugSceneEnabled;
var transient bool bUsingSplatterGun;
var transient bool bRequestedGlobalStats;
var KFSceneCaptureDebugCam DebugSceneCamera;
var KFAIController DebugKFAIC;
var KFPawn_Monster DebugTarget;
var name CheatType;

// Export UKFCheatManager::execSetPerkLevel(FFrame&, void* const)
native final exec function SetPerkLevel(int NewPerkLevel);

// Export UKFCheatManager::execSetPerkPrestigeLevel(FFrame&, void* const)
native final exec function SetPerkPrestigeLevel(int NewPerkLevel);

// Export UKFCheatManager::execResetPerkLevels(FFrame&, void* const)
native final exec function ResetPerkLevels();

// Export UKFCheatManager::execAnalyzeCharacterAttachments(FFrame&, void* const)
native final exec function AnalyzeCharacterAttachments();

// Export UKFCheatManager::execFixupCharacterAttachmentLocalization(FFrame&, void* const)
native final exec function FixupCharacterAttachmentLocalization();

// Export UKFCheatManager::execReadGlobalStat(FFrame&, void* const)
native exec function ReadGlobalStat(string StatId, optional int HistoryNumDays);

// Export UKFCheatManager::execFindTranslucencyInheritDominantShadowMaterials(FFrame&, void* const)
native final exec function FindTranslucencyInheritDominantShadowMaterials();

// Export UKFCheatManager::execMakeEmptyPackage(FFrame&, void* const)
native final function MakeEmptyPackage();

// Export UKFCheatManager::execForceDailyObjective(FFrame&, void* const)
native exec function ForceDailyObjective(int ObjectiveIndex, int UIIndex);

// Export UKFCheatManager::execResetDailyObjectives(FFrame&, void* const)
native exec function ResetDailyObjectives();

// Export UKFCheatManager::execGiveVaultDosh(FFrame&, void* const)
native exec function GiveVaultDosh(int Amount);

function Pawn GetMyPawn()
{
    return ((Outer.Pawn != none) ? Outer.Pawn : DebugCameraController(Outer).OriginalControllerRef.Pawn);
}

exec function SetShellToState(int ShellIndex, byte ShellState)
{
    local KFWeap_GrenadeLauncher_CylinderBase GLBase;
    local KFPawn MyPawn;

    MyPawn = KFPawn(GetMyPawn());
    if((MyPawn != none) && MyPawn.MyKFWeapon != none)
    {
        GLBase = KFWeap_GrenadeLauncher_CylinderBase(MyPawn.MyKFWeapon);
        if(GLBase != none)
        {
            GLBase.SetShellToState(ShellIndex, ShellState);
        }
    }
}

exec function SetFakeDownloadProgress(bool bDownloading, float PercentageComplete)
{
    local KFGameViewportClient KFVP;

    KFVP = KFGameViewportClient(Class'Engine'.static.GetEngine().GameViewport);
    KFVP.NotifyDownloadProgress(3, "TEST", "59");
}

exec function SetInventoryFilter(string FilterType, int NewEnum)
{
    local string MyFilterType;
    local KFPlayerController KFPC;

    LogInternal(("Set Filter Called: " @ FilterType) @ string(NewEnum));
    MyFilterType = Caps(FilterType);
    KFPC = KFPlayerController(Outer);
    if(((KFPC != none) && KFPC.MyGFxManager != none) && KFPC.MyGFxManager.InventoryMenu != none)
    {
        switch(MyFilterType)
        {
            case "WEAPON":
                KFPC.MyGFxManager.InventoryMenu.Callback_WeaponTypeFilterChanged(NewEnum);
                break;
            case "RARITY":
                KFPC.MyGFxManager.InventoryMenu.Callback_RarityTypeFilterChanged(NewEnum);
                break;
            case "PERK":
                KFPC.MyGFxManager.InventoryMenu.Callback_PerkTypeFilterChanged(NewEnum);
                break;
            default:
                LogInternal("Bad filter type provided!" @ FilterType);
                break;
        }
    }
}

exec function PrintOutCurrentPrestigeInfo()
{
    local KFPlayerController KFPC;
    local KFPlayerReplicationInfo KFPRI;

    KFPC = KFPlayerController(Outer);
    LogInternal("Curennt perk prestige level: " @ string(KFPC.CurrentPerk.GetPrestigeLevel()));
    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    LogInternal("KPRI active prestige level: " @ string(KFPRI.GetActivePerkPrestigeLevel()));
}

exec function DisplayFreeTrialFeatureBlockedPopUp()
{
    Class'KFGFxMoviePlayer_Manager'.static.DisplayFreeTrialFeatureBlockedPopUp();
}

exec function DisplayFreeTrialOverPopUp()
{
    Class'KFGFxMoviePlayer_Manager'.static.DisplayFreeTrialOverPopUp();
}

exec function TestItemServerStatusIndicatorStart()
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if((KFPC.MyGFxManager != none) && KFPC.MyGFxManager.BackendStatusIndicatorWidget != none)
    {
        KFPC.MyGFxManager.BackendStatusIndicatorWidget.StartFlickeringConnectionLost();
    }
}

exec function TestItemServerStatusIndicatorStop()
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if((KFPC.MyGFxManager != none) && KFPC.MyGFxManager.BackendStatusIndicatorWidget != none)
    {
        KFPC.MyGFxManager.BackendStatusIndicatorWidget.StopFlickeringConnectionLost();
    }
}

exec function OpenScreenSizeMovie()
{
    KFPlayerController(Outer).MyGFxManager.OpenScreenSizeMovie();
}

exec function CloseScreenSizeMovie()
{
    KFPlayerController(Outer).MyGFxManager.ScreenSizeMovie.SaveAndClose();
}

exec function OpenIIS()
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    KFPC.MyGFxManager.OpenMenu(17);
}

exec function SetIISText(string MyString)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    KFPC.MyGFxManager.IISMenu.SetString("loginText", MyString);
}

exec function TestSongInfoWidget(string S)
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.myGfxHUD != none)
    {
        KFPC.myGfxHUD.MusicNotification.ShowSongInfo(S);
    }
}

exec function TestNumbPrompts(int NumberOfPrompts)
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.MyGFxManager != none)
    {
        KFPC.MyGFxManager.ManagerObject.SetInt("numPrompts", NumberOfPrompts);
    }
}

exec function MakeFakePopUp()
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.MyGFxManager != none)
    {
        KFPC.MyGFxManager.DelayedShowDisconnectMessage();
    }
}

exec function SetCharacterAttachment(int MeshIndex, int SkinIndex, int AttachmentIndex, optional bool bIgnoreConflictingSlots)
{
    local Pawn P;
    local KFPlayerController KFPC;

    bIgnoreConflictingSlots = false;
    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if((KFPC.MyGFxManager != none) && KFPC.MyGFxManager.GearMenu != none)
    {
        KFPC.MyGFxManager.GearMenu.RelayFromCheatManager(P, 3, MeshIndex, SkinIndex, AttachmentIndex, bIgnoreConflictingSlots);
    }
}

exec function PrintOutCharacterCosmeticInfo()
{
    local KFPlayerReplicationInfo KFPRI;
    local int I;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI == none)
    {
        return;
    }
    LogInternal("PRINTING OUT COSMETIC INFO!");
    I = 0;
    J0x6D:

    if(I < 3)
    {
        LogInternal((((("Item on slot index: " @ string(I)) @ "Mesh index: ") @ string(KFPRI.RepCustomizationInfo.AttachmentMeshIndices[I])) @ "Skin index") @ string(KFPRI.RepCustomizationInfo.AttachmentSkinIndices[I]));
        ++ I;
        goto J0x6D;
    }
    LogInternal("********END PRINT ATTACHMENTS*****************");
}

exec function TestLocalMessage()
{
    Outer.ReceiveLocalizedMessage(Class'KFLocalMessage', 18);
}

exec function AutoFire(float interval)
{
    Outer.StartFire();
    Outer.SetTimer(interval, true, 'FireAgain', self);
}

exec function StopAutoFire()
{
    Outer.StopFire();
    Outer.ClearTimer('FireAgain', self);
}

simulated function FireAgain()
{
    Outer.StopFire();
    Outer.StartFire();
}

exec function TestGrenade(optional string GrenadePath)
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    if(GrenadePath == "")
    {
        GrenadePath = "KFGameContent.KFProj_HEGrenade";
    }
    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject(GrenadePath, Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function TestConcussiveGrenade()
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject("KFGameContent.KFProj_DynamiteGrenade", Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.ExplosionTemplate.ExplosionEffects = SpawnedGrenade.default.AltExploEffects;
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function TestNukeGrenade()
{
    local Vector StartTrace, TraceDir;
    local KFProj_Grenade SpawnedGrenade;
    local class<KFProj_Grenade> GrenadeClass;

    GrenadeClass = class<KFProj_Grenade>(DynamicLoadObject("KFGameContent.KFProj_DynamiteGrenade", Class'Class'));
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    SpawnedGrenade = Outer.Pawn.Weapon.Spawn(GrenadeClass, Outer.Pawn.Weapon);
    if((SpawnedGrenade != none) && !SpawnedGrenade.bDeleteMe)
    {
        SpawnedGrenade.ExplosionTemplate = Class'KFPerk_Demolitionist'.static.GetNukeExplosionTemplate();
        SpawnedGrenade.ExplosionActorClass = Class'KFPerk_Demolitionist'.static.GetNukeExplosionActorClass();
        SpawnedGrenade.Init(TraceDir);
    }
}

exec function BurnFX()
{
    KFPawn(GetMyPawn()).AfflictionHandler.ToggleEffects(1, true);
}

exec function StopBurnFX()
{
    KFPawn(GetMyPawn()).AfflictionHandler.ToggleEffects(1, false);
}

exec function SetInflate(float InflateParam)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.AfflictionHandler.UpdateMaterialParameter(10, InflateParam);        
    }    
}

exec function SetChar(float CharParam)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.AfflictionHandler.UpdateMaterialParameter(1, CharParam);        
    }    
}

exec function ToggleZedsIgnoreMe()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if((KFAIC != none) && KFAIC.Enemy == (GetMyPawn()))
        {
            KFAIC.Enemy = none;
        }        
    }    
    Outer.ClientMessage((string(GetMyPawn()) @ "Zeds Ignore Me: ") $ string(KFPawn(GetMyPawn()).bAIZedsIgnoreMe), CheatType);
}

exec function ToggleFrustration(optional int enabledValue)
{
    enabledValue = 5;
    if(Class'KFAIController'.default.FrustrationThreshold == 0)
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController FrustrationThreshold" @ string(enabledValue));        
    }
    else
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController FrustrationThreshold" @ string(0));
    }
}

exec function ZedTeleport()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC != none)
        {
            KFAIC.RelocateTeleport();
        }        
    }    
    Outer.ClientMessage("Teleporting zeds for reorganization", CheatType);
}

exec function ZedStuck()
{
    local KFAIController KFAIC;

    KFPawn(GetMyPawn()).bAIZedsIgnoreMe = !KFPawn(GetMyPawn()).bAIZedsIgnoreMe;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC != none)
        {
            KFAIC.HandleStuck();
        }        
    }    
    Outer.ClientMessage("Forcing HandleStuck For Zeds", CheatType);
}

exec function LogCurrentWave()
{
    local int I, J, K;
    local KFAISpawnManager SpawnManager;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        SpawnManager = KFGameInfo(Outer.WorldInfo.Game).SpawnManager;
        LogInternal("Current Loaded Wave Setup");
        I = 0;
        J0xC6:

        if(I < SpawnManager.AvailableSquads.Length)
        {
            J = 0;
            J0xFE:

            if(J < SpawnManager.AvailableSquads[I].MonsterList.Length)
            {
                LogInternal((((((((("AvailableSquads " $ string(I)) $ " MonsterList ") $ string(J)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.AvailableSquads[I].MonsterList[J].Type))) $ " Num: ") $ string(SpawnManager.AvailableSquads[I].MonsterList[J].Num)) $ " SquadName: ") $ string(SpawnManager.AvailableSquads[I]));
                ++ J;
                goto J0xFE;
            }
            ++ I;
            goto J0xC6;
        }
        LogInternal(((("Current Waves Info For Wave: " $ string(KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum)) $ " which is ") $ string(KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum - 1)) $ " in the wave array ");
        I = KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.WaveNum - 1;
        J = 0;
        J0x46B:

        if(J < SpawnManager.WaveSettings.Waves[I].Squads.Length)
        {
            K = 0;
            J0x4D5:

            if(K < SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList.Length)
            {
                LogInternal((((((((("Wave " $ string(I)) $ " Squads ") $ string(J)) $ " MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList[K].Num));
                ++ K;
                goto J0x4D5;
            }
            ++ J;
            goto J0x46B;
        }
        J = 0;
        J0x70F:

        if(J < SpawnManager.WaveSettings.Waves[I].SpecialSquads.Length)
        {
            if(SpawnManager.WaveSettings.Waves[I].SpecialSquads[J] != none)
            {
                K = 0;
                J0x7D9:

                if(K < SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList.Length)
                {
                    LogInternal((((((("Wave " $ string(I)) $ " Special Squad MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList[K].Num));
                    ++ K;
                    goto J0x7D9;
                }                
            }
            else
            {
                LogInternal(("Wave " $ string(I)) $ " No Special Squad ");
            }
            ++ J;
            goto J0x70F;
        }
    }
}

exec function LogAllWaves()
{
    local int I, J, K;
    local KFAISpawnManager SpawnManager;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        SpawnManager = KFGameInfo(Outer.WorldInfo.Game).SpawnManager;
        LogInternal("Current Loaded Wave Setup");
        I = 0;
        J0xC6:

        if(I < SpawnManager.AvailableSquads.Length)
        {
            J = 0;
            J0xFE:

            if(J < SpawnManager.AvailableSquads[I].MonsterList.Length)
            {
                LogInternal((((((((("AvailableSquads " $ string(I)) $ " MonsterList ") $ string(J)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.AvailableSquads[I].MonsterList[J].Type))) $ " Num: ") $ string(SpawnManager.AvailableSquads[I].MonsterList[J].Num)) $ " SquadName: ") $ string(SpawnManager.AvailableSquads[I]));
                ++ J;
                goto J0xFE;
            }
            ++ I;
            goto J0xC6;
        }
        LogInternal("All Waves Info");
        I = 0;
        J0x2E3:

        if(I < SpawnManager.WaveSettings.Waves.Length)
        {
            J = 0;
            J0x32E:

            if(J < SpawnManager.WaveSettings.Waves[I].Squads.Length)
            {
                K = 0;
                J0x398:

                if(K < SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList.Length)
                {
                    LogInternal((((((((("Wave " $ string(I)) $ " Squads ") $ string(J)) $ " MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.WaveSettings.Waves[I].Squads[J].MonsterList[K].Num));
                    ++ K;
                    goto J0x398;
                }
                ++ J;
                goto J0x32E;
            }
            J = 0;
            J0x5D2:

            if(J < SpawnManager.WaveSettings.Waves[I].SpecialSquads.Length)
            {
                if(SpawnManager.WaveSettings.Waves[I].SpecialSquads[J] != none)
                {
                    K = 0;
                    J0x69C:

                    if(K < SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList.Length)
                    {
                        LogInternal((((((("Wave " $ string(I)) $ " Special Squad MonsterList ") $ string(K)) $ " is ") $ string(GetEnum(Enum'EAIType', SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList[K].Type))) $ " Num: ") $ string(SpawnManager.WaveSettings.Waves[I].SpecialSquads[J].MonsterList[K].Num));
                        ++ K;
                        goto J0x69C;
                    }                    
                }
                else
                {
                    LogInternal(("Wave " $ string(I)) $ " No Special Squad ");
                }
                ++ J;
                goto J0x5D2;
            }
            ++ I;
            goto J0x2E3;
        }
    }
}

exec function PowerUpHellishRage()
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(KFPC != none)
    {
        KFPC.ReceivePowerUp(Class'KFPowerUp_HellishRage');
    }
}

exec function SpawnGunModel(string GunMeshString)
{
    local SkeletalMesh GunMesh;

    GunMesh = SkeletalMesh(DynamicLoadObject(GunMeshString, Class'SkeletalMesh'));
    KFPawn(Outer.Pawn).ArmsMesh.DetachFromAny();
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).SetSkeletalMesh(GunMesh);
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).SetAnimTreeTemplate(none);
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).AnimSets.Length = 0;
}

exec function HansGunsOut()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.DoSpecialMove(39, false, none, 1);        
    }    
}

exec function HansGunsAway()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.DoSpecialMove(39, false, none, 0);        
    }    
}

exec function WeapForceIdle()
{
    KFWeapon(Outer.Pawn.Weapon).PlayAnimation(KFWeapon(Outer.Pawn.Weapon).IdleAnims[0], 0, false, 0);
    Outer.SetTimer(0.001, false, 'FreezeWeapAnimUpdate', self);
}

simulated function FreezeWeapAnimUpdate()
{
    KFSkeletalMeshComponent(Outer.Pawn.Weapon.Mesh).bPauseAnims = true;
}

exec function TestWeaponAnim(name AnimName)
{
    KFWeapon(Outer.Pawn.Weapon).PlayAnimation(AnimName, 0, false, 0);
}

exec function SetPauseMonsterAnims(bool bPause)
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        KFPM.Mesh.bPauseAnims = bPause;        
    }    
}

exec function NoSpread()
{
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).Spread[0] = 0;
        KFWeapon(Outer.Pawn.Weapon).Spread[1] = 0;
        Outer.ClientMessage("Spread Disabled", CheatType);
    }
}

exec function GoSpread()
{
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).Spread[0] = KFWeapon(Outer.Pawn.Weapon).default.Spread[0];
        KFWeapon(Outer.Pawn.Weapon).Spread[1] = KFWeapon(Outer.Pawn.Weapon).default.Spread[1];
        Outer.ClientMessage("Spread Enabled", CheatType);
    }
}

exec function HideMenus()
{
    if(KFPlayerController(Outer).MyGFxManager != none)
    {
        KFPlayerController(Outer).MyGFxManager.SetMenuVisibility(false);        
    }
    else
    {
        LogInternal("MENU MANAGER NOT READY");
    }
}

exec function DebugShowVoteKick()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if((KFPlayerController(Outer).myGfxHUD != none) && KFPRI != none)
    {
        KFPlayerController(Outer).myGfxHUD.ShowKickVote(KFPRI, 10, true);
    }
}

exec function DebugShowVoteSkipTrader()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if((KFPlayerController(Outer).myGfxHUD != none) && KFPRI != none)
    {
        KFPlayerController(Outer).myGfxHUD.ShowSkipTraderVote(KFPRI, 10, true);
    }
}

exec function ToggleForceCrosshair()
{
    KFHUDBase(Outer.myHUD).bForceDrawCrosshair = !KFHUDBase(Outer.myHUD).bForceDrawCrosshair;
}

exec function ToggleCrosshair()
{
    KFHUDBase(Outer.myHUD).bDrawCrosshair = !KFHUDBase(Outer.myHUD).bDrawCrosshair;
}

exec function FlameSetComplex(bool bDoCollideComplex)
{
    if(KFWeap_FlameBase(Outer.Pawn.Weapon) != none)
    {
        KFWeap_FlameBase(Outer.Pawn.Weapon).SetFlameComplex(bDoCollideComplex);
    }
}

exec function FlameDebugDamage(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision)
{
    local KFWeap_FlameBase KWFB;

    KWFB = KFWeap_FlameBase(Outer.Pawn.Weapon);
    if(KWFB != none)
    {
        KWFB.SetFlameDebugDamage(bDebugDirectDamage, bDebugSplashDamage, bDebugShowSplashRadius, bDebugShowCollision);
    }
}

exec function FlameDebugFX(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles)
{
    local KFWeap_FlameBase KWFB;

    KWFB = KFWeap_FlameBase(Outer.Pawn.Weapon);
    if(KWFB != none)
    {
        KWFB.SetFlameDebugFX(bDebugShowSeeds, bDebugShowBones, bDebugForceNonPlayerParticles);
    }
}

exec function FlameDebugFX3P(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles)
{
    local KFWeapAttach_SprayBase KFSB;
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFSB = KFWeapAttach_SprayBase(KFP.WeaponAttachment);
        if(KFSB != none)
        {
            KFSB.SetFlameDebugFX(bDebugShowSeeds, bDebugShowBones, bDebugForceNonPlayerParticles);
        }
    }
}

exec function FlameDebugDamage3P(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision)
{
    local KFWeapAttach_SprayBase KFSB;
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFSB = KFWeapAttach_SprayBase(KFP.WeaponAttachment);
        if(KFSB != none)
        {
            KFSB.SetFlameDebugDamage(bDebugDirectDamage, bDebugSplashDamage, bDebugShowSplashRadius, bDebugShowCollision);
        }
    }
}

simulated exec function NextTrack()
{
    if(KFGameReplicationInfo(Outer.WorldInfo.GRI) != none)
    {
        KFGameReplicationInfo(Outer.WorldInfo.GRI).PlayNewMusicTrack();
    }
}

simulated exec function SetMusicVolume(float NewVolume)
{
    local float MusicVolumeMultiplier;
    local OnlinePlayerStorage Profile;

    Profile = Class'GameEngine'.static.GetOnlineSubsystem().PlayerInterface.GetProfileSettings(byte(LocalPlayer(Outer.Player).ControllerId));
    MusicVolumeMultiplier = NewVolume;
    Outer.GetALocalPlayerController().SetAudioGroupVolume('Music', MusicVolumeMultiplier);
    Profile.SetProfileSettingValueFloat(114, MusicVolumeMultiplier);
    KFProfileSettings(Profile).Save(byte(LocalPlayer(Outer.Player).ControllerId));
    Class'KFGameEngine'.static.StaticSaveConfig();
}

simulated exec function SetPadVolume(float NewVolume)
{
    Class'KFGameEngine'.static.SetWWisePADVolume(NewVolume);
}

exec function Weapon GiveWeapon(string WeaponClassStr)
{
    local KFInventoryManager KFIM;
    local Weapon NewWeap;

    KFIM = KFInventoryManager(Outer.Pawn.InvManager);
    if(KFIM != none)
    {
        KFIM.bInfiniteWeight = true;
        NewWeap = super(CheatManager).GiveWeapon(WeaponClassStr);
        KFIM.bInfiniteWeight = false;
    }
    return NewWeap;
}

simulated exec function MKB()
{
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_DualMKb42_Hans");
}

simulated exec function Minigun()
{
    GiveWeapon("KFGameContent.KFWeap_Minigun");
}

simulated exec function Pistols()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_G18C");
    GiveWeapon("KFGameContent.KFWeap_Revolver_Rem1858");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Medic");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_HX25");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Colt1911");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Flare");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_ChiappaRhino");
}

simulated exec function DummyWeapon()
{
    GiveWeapon("KFGameContent.KFWeap_AssetDummy");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Dummy");
}

simulated exec function Melee()
{
    GiveWeapon("KFGameContent.KFWeap_Knife_Berserker");
    GiveWeapon("KFGameContent.KFWeap_Knife_Commando");
    GiveWeapon("KFGameContent.KFWeap_Knife_Support");
    GiveWeapon("KFGameContent.KFWeap_Knife_Demolitionist");
    GiveWeapon("KFGameContent.KFWeap_Knife_Firebug");
    GiveWeapon("KFGameContent.KFWeap_Knife_FieldMedic");
    GiveWeapon("KFGameContent.KFWeap_Knife_Gunslinger");
    GiveWeapon("KFGameContent.KFWeap_Knife_Sharpshooter");
    GiveWeapon("KFGameContent.KFWeap_Knife_SWAT");
    GiveWeapon("KFGameContent.KFWeap_Knife_Survivalist");
}

simulated exec function Nails()
{
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Nailgun");
}

simulated exec function Berserk()
{
    GiveWeapon("KFGameContent.KFWeap_Blunt_Crovel");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Nailgun");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_HRGTeslauncher");
    GiveWeapon("KFGameContent.KFWeap_Edged_Katana");
    GiveWeapon("KFGameContent.KFWeap_Edged_FireAxe");
    GiveWeapon("KFGameContent.KFWeap_Blunt_ChainBat");
    GiveWeapon("KFGameContent.KFWeap_Blunt_MedicBat");
    GiveWeapon("KFGameContent.KFWeap_Edged_Zweihander");
    GiveWeapon("KFGameContent.KFWeap_Blunt_Pulverizer");
    GiveWeapon(" KFGameContent.KFWeap_Blunt_PowerGloves");
    GiveWeapon("KFGameContent.KFWeap_Eviscerator");
    GiveWeapon("KFGameContent.KFWeap_Blunt_MaceAndShield");
    GiveWeapon("KFGameContent.KFWeap_Edged_IonThruster");
    GiveWeapon("KFGameContent.KFWeap_Edged_AbominationAxe");
}

simulated exec function Assault()
{
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_AR15");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Bullpup");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_AK12");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_MKB42");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_SCAR");
    GiveWeapon("KFGameContent.KFWeap_LMG_Stoner63A");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Thompson");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_M16M203");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Medic");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_FNFal");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_MedicRifleGrenadeLauncher");
    GiveWeapon("KFGameContent.KFWeap_Minigun");
}

simulated exec function Shotty()
{
    GiveWeapon("KFGameContent.KFWeap_Shotgun_MB500");
    GiveWeapon("KFGameContent.KFWeap_HRG_Revolver_Buckshot");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DoubleBarrel");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_HZ12");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_M4");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_AA12");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_ElephantGun");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DragonsBreath");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Nailgun");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Medic");
}

simulated exec function MineRec()
{
    GiveWeapon("KFGameContent.KFWeap_Mine_Reconstructor");
}

simulated exec function Medic()
{
    GiveWeapon("KFGameContent.KFWeap_Mine_Reconstructor");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Medic");
    GiveWeapon("KFGameContent.KFWeap_SMG_Medic");
    GiveWeapon("KFGameContent.KFWeap_HRG_Healthrower");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_Medic");
    GiveWeapon("KFGameContent.KFWeap_Rifle_Hemogoblin");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Medic");
    GiveWeapon("KFGameContent.KFWeap_Rifle_HRGIncision");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_MedicRifleGrenadeLauncher");
    GiveWeapon("KFGameContent.KFWeap_Blunt_MedicBat");
}

simulated exec function Demo()
{
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_HX25");
    GiveWeapon("KFGameContent.KFWeap_Thrown_C4");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_M79");
    GiveWeapon("KFGameContent.KFWeap_RocketLauncher_SealSqueal");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_M16M203");
    GiveWeapon("KFGameContent.KFWeap_RocketLauncher_RPG7");
    GiveWeapon("KFGameContent.KFWeap_RocketLauncher_Seeker6");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_M32");
    GiveWeapon("KFGameContent.KFWeap_Blunt_Pulverizer");
    GiveWeapon("KFGameContent.KFWeap_HuskCannon");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_HRG_Kaboomstick");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Blunderbuss");
}

simulated exec function Firebug()
{
    GiveWeapon("KFGameContent.KFWeap_Flame_CaulkBurn");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Flare");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualFlare");
    GiveWeapon("KFGameContent.KFWeap_Shotgun_DragonsBreath");
    GiveWeapon("KFGameContent.KFWeap_SMG_Mac10");
    GiveWeapon("KFGameContent.KFWeap_Flame_Flamethrower");
    GiveWeapon("KFGameContent.KFWeap_Beam_Microwave");
    GiveWeapon("KFGameContent.KFWeap_HuskCannon");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Microwave");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_HRGIncendiaryRifle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_HRGScorcher");
}

simulated exec function Dualies()
{
    GiveWeapon("KFGameContent.KFWeap_Revolver_DualRem1858");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualColt1911");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualG18");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualHRGWinterbite");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualDeagle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_ChiappaRhinoDual");
    GiveWeapon("KFGameContent.KFWeap_Revolver_DualSW500");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualAF2011");
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualFlare");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Dual9mm");
}

simulated exec function Singles()
{
    GiveWeapon("KFGameContent.KFWeap_Revolver_Rem1858");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Colt1911");
    GiveWeapon("KFGameContent.KFWeap_Pistol_HRGWinterbite");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
    GiveWeapon("KFGameContent.KFWeap_Pistol_ChiappaRhino");
    GiveWeapon("KFGameContent.KFWeap_Revolver_SW500");
    GiveWeapon("KFGameContent.KFWeap_Pistol_AF2011");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Medic");
    GiveWeapon("KFGameContent.KFWeap_Rifle_Winchester1894");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_HX25");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Flare");
    GiveWeapon("KFGameContent.KFWeap_Rifle_CenterfireMB464");
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
}

simulated exec function Sharpshooter()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_Winchester1894");
    GiveWeapon("KFGameContent.KFWeap_Rifle_CenterfireMB464");
    GiveWeapon("KFGameContent.KFWeap_Bow_Crossbow");
    GiveWeapon("KFGameContent.KFWeap_Rifle_MosinNagant");
    GiveWeapon("KFGameContent.KFWeap_Rifle_M14EBR");
    GiveWeapon("KFGameContent.KFWeap_Rifle_RailGun");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_FNFal");
    GiveWeapon("KFGameContent.KFWeap_Rifle_M99");
    GiveWeapon("KFGameContent.KFWeap_Revolver_Rem1858");
    GiveWeapon("KFGameContent.KFWeap_Revolver_SW500");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Flare");
    GiveWeapon("KFGameContent.KFWeap_Bow_CompoundBow");
}

simulated exec function SWAT()
{
    GiveWeapon("KFGameContent.KFWeap_SMG_MP7");
    GiveWeapon("KFGameContent.KFWeap_SMG_MP5RAS");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Thompson");
    GiveWeapon("KFGameContent.KFWeap_HRG_Nailgun");
    GiveWeapon("KFGameContent.KFWeap_SMG_P90");
    GiveWeapon("KFGameContent.KFWeap_SMG_HK_UMP");
    GiveWeapon("KFGameContent.KFWeap_SMG_Kriss");
    GiveWeapon("KFGameContent.KFWeap_SMG_G18");
    GiveWeapon("KFGameContent.KFWeap_SMG_Medic");
    GiveWeapon("KFGameContent.KFWeap_SMG_Mac10");
}

exec function Surv()
{
    GiveWeapon("KFGameContent.KFWeap_HRG_EMP_ArcGenerator");
    GiveWeapon("KFGameContent.KFWeap_Ice_FreezeThrower");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_LazerCutter");
}

simulated exec function Scope()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_M14EBR");
}

simulated exec function ScopeFOV(float NewFOV)
{
    if(KFWeap_ScopedBase(Outer.Pawn.Weapon) != none)
    {
        KFWeap_ScopedBase(Outer.Pawn.Weapon).SceneCapture.SetCaptureParameters(,, NewFOV);
    }
}

simulated exec function Winter()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_DualHRGWinterbite");
    GiveWeapon("KFGameContent.KFWeapDef_HRGWinterbite");
    GiveWeapon("KFGameContent.KFWeap_Rifle_HRGIncision");
    GiveWeapon("KFGameContent.KFWeap_SMG_G18");
    GiveWeapon("KFGameContent.KFWeap_Rifle_MosinNagant");
}

simulated exec function Summer()
{
    GiveWeapon("KFGameContent.KFWeap_Blunt_PowerGloves");
    GiveWeapon("KFGameContent.KFWeap_Rifle_M99");
    GiveWeapon("KFGameContent.KFWeap_GrenadeLauncher_M32");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_Thompson");
    GiveWeapon("KFGameContent.KFWeap_AssaultRifle_MKB42");
    GiveWeapon("KFGameContent.KFWeap_Pistol_ChiappaRhinoDual");
}

simulated exec function Flame()
{
    Firebug();
}

simulated exec function Rifle()
{
    GiveWeapon("KFGameContent.KFWeap_Rifle_Winchester1894");
}

simulated exec function SMG()
{
    SWAT();
    GiveWeapon("KFGameContent.KFWeap_SMG_Medic");
}

exec function AllWeapons()
{
    GiveWeapon("KFGameContent.KFWeap_Pistol_9mm");
    GiveWeapon("KFGameContent.KFWeap_Pistol_Deagle");
    Assault();
    Berserk();
    Demo();
    Firebug();
    Medic();
    SWAT();
    Shotty();
    Surv();
}

simulated exec function KillRecoil()
{
    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        KFWeapon(Outer.Pawn.Weapon).maxRecoilPitch = 0;
        KFWeapon(Outer.Pawn.Weapon).minRecoilPitch = 0;
        KFWeapon(Outer.Pawn.Weapon).maxRecoilYaw = 0;
        KFWeapon(Outer.Pawn.Weapon).minRecoilYaw = 0;
        Outer.ClientMessage("Recoil Disabled", CheatType);
    }
}

simulated exec function WeapFOV(float NewFOV, optional bool bScaleByAspectRatio)
{
    local float AdjustedFOV, DummyParam;

    bScaleByAspectRatio = true;
    if(KFWeapon(Outer.Pawn.Weapon) != none)
    {
        if(bScaleByAspectRatio)
        {
            AdjustedFOV = KFPlayerController(Outer).CalcFOVForAspectRatio(NewFOV, Outer.myHUD.SizeX, Outer.myHUD.SizeY, DummyParam);            
        }
        else
        {
            AdjustedFOV = NewFOV;
        }
        KFWeapon(Outer.Pawn.Weapon).SetFOV(AdjustedFOV);
    }
}

exec function QuickDOF(bool bEnableDOF, optional float StaticDOFDistance, optional float Aperture, optional float FocusBlendRate)
{
    local KFPlayerController KFPC;

    StaticDOFDistance = 1000;
    Aperture = 0.25;
    FocusBlendRate = 0;
    KFPC = KFPlayerController(Outer);
    if(KFPC != none)
    {
        KFPC.ClientEnableDepthOfField(bEnableDOF, StaticDOFDistance, Aperture, FocusBlendRate);
    }
}

exec function CustomDOF(bool bEnableDOF, optional float FocalDistance, optional float FocalRadius, optional float SharpRadius, optional float MinBlurSize, optional float MaxNearBlurSize, optional float MaxFarBlurSize, optional float ExpFalloff, optional float BlendInSpeed, optional float BlendOutSpeed)
{
    local KFPlayerController KFPC;

    FocalDistance = 1200;
    FocalRadius = 1200;
    SharpRadius = 1000;
    MinBlurSize = 0;
    MaxNearBlurSize = 4;
    MaxFarBlurSize = 3;
    ExpFalloff = 1;
    BlendInSpeed = 1;
    BlendOutSpeed = 1;
    KFPC = KFPlayerController(Outer);
    if(KFPC != none)
    {
        KFPC.ClientCustomDepthOfField(bEnableDOF, FocalDistance, FocalRadius, SharpRadius, MinBlurSize, MaxNearBlurSize, MaxFarBlurSize, ExpFalloff, BlendInSpeed, BlendOutSpeed);
    }
}

simulated exec function ShowDownloadPopup(string NewText, string NewTExt2)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    KFPC.ShowConnectionProgressPopup(3, NewText, NewTExt2);
}

simulated exec function BackgroundBlur(bool bBlur)
{
    local KFPlayerController KFPC;
    local KFPawn KFP;

    KFPC = KFPlayerController(Outer);
    KFP = KFPawn(Outer.Pawn);
    if(bBlur)
    {
        KFPC.EnableBlur(true, 6, 1, 1);        
        KFPC.ConsoleCommand("PlayersOnly");
        KFPC.EnableReflections(false);
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(false);
            KFP.DetachComponent(KFP.ArmsMesh);
        }        
    }
    else
    {
        KFPC.EnableBlur(false, 0, 1, 1);        
        KFPC.ConsoleCommand("PlayersOnly");
        KFPC.EnableReflections(true);
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(true);
            KFP.AttachComponent(KFP.ArmsMesh);
        }
    }
}

exec function ShowHands(bool bShow)
{
    local KFPlayerController KFPC;
    local KFPawn KFP;

    KFPC = KFPlayerController(Outer);
    KFP = KFPawn(Outer.Pawn);
    if(!bShow)
    {
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(false);
            KFP.DetachComponent(KFP.ArmsMesh);
        }        
    }
    else
    {
        if(KFPC.UsingFirstPersonCamera())
        {
            KFP.SetFirstPersonVisibility(true);
            KFP.AttachComponent(KFP.ArmsMesh);
        }
    }
}

simulated exec function ScaleShootCameraAnims(float NewScale)
{
    local int I;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastAnim, NewScale);
        I = 0;
        J0x19F:

        if(I < KFWeapon(Outer.Pawn.Weapon).FireSightedAnims.Length)
        {
            SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireSightedAnims[I], NewScale);
            ++ I;
            goto J0x19F;
        }
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndSightedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireScopedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopScopedAnim, NewScale);
        SetWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastScopedAnim, NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst2', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst2_Iron', NewScale);
        SetWeaponCameraAnimScale('Shoot_Burst_Iron', NewScale);
    }
}

simulated exec function RestoreShootCameraAnims()
{
    local int I;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastAnim);
        I = 0;
        J0x184:

        if(I < KFWeapon(Outer.Pawn.Weapon).FireSightedAnims.Length)
        {
            RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireSightedAnims[I]);
            ++ I;
            goto J0x184;
        }
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopStartSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopEndSightedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireScopedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLoopScopedAnim);
        RestoreWeaponCameraAnimScale(KFWeapon(Outer.Pawn.Weapon).FireLastScopedAnim);
        RestoreWeaponCameraAnimScale('Shoot_Burst2');
        RestoreWeaponCameraAnimScale('Shoot_Burst');
        RestoreWeaponCameraAnimScale('Shoot_Burst2_Iron');
        RestoreWeaponCameraAnimScale('Shoot_Burst_Iron');
    }
}

simulated function SetWeaponCameraAnimScale(name CameraAnimName, float NewScale)
{
    local AnimSequence AnimSeq;
    local int I;
    local KFAnimNotify_CameraAnim CameraAnim;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        AnimSeq = KFWeapon(Outer.Pawn.Weapon).MySkelMesh.FindAnimSequence(CameraAnimName);
        if(AnimSeq != none)
        {
            I = 0;
            J0xFC:

            if(I < AnimSeq.Notifies.Length)
            {
                CameraAnim = KFAnimNotify_CameraAnim(AnimSeq.Notifies[I].Notify);
                if(CameraAnim != none)
                {
                    CameraAnim.CameraAnimScale = NewScale;
                }
                ++ I;
                goto J0xFC;
            }
        }
    }
}

simulated function RestoreWeaponCameraAnimScale(name CameraAnimName)
{
    local AnimSequence AnimSeq;
    local int I;
    local KFAnimNotify_CameraAnim CameraAnim;

    if((Outer.Pawn != none) && KFWeapon(Outer.Pawn.Weapon) != none)
    {
        AnimSeq = KFWeapon(Outer.Pawn.Weapon).MySkelMesh.FindAnimSequence(CameraAnimName);
        if(AnimSeq != none)
        {
            I = 0;
            J0xFC:

            if(I < AnimSeq.Notifies.Length)
            {
                CameraAnim = KFAnimNotify_CameraAnim(AnimSeq.Notifies[I].Notify);
                if(CameraAnim != none)
                {
                    CameraAnim.CameraAnimScale = CameraAnim.default.CameraAnimScale;
                }
                ++ I;
                goto J0xFC;
            }
        }
    }
}

simulated exec function DramaEvent(float Chance, optional float Duration, optional bool bPartial)
{
    Duration = 3;    
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        Outer.ClientMessage((("DramaEvent Chance = " $ string(Chance)) $ " Duration = ") $ string(Duration), CheatType);
        KFPlayerController(Outer).bForcePartialZedTime = bPartial;
        KFGameInfo(Outer.WorldInfo.Game).DramaticEvent(Chance, Duration);
        KFPlayerController(Outer).bForcePartialZedTime = KFPlayerController(Outer).default.bForcePartialZedTime;
    }
}

exec function TestCheat()
{
    LogInternal("Cheat Manager works!");
}

exec function ImRich()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.AddDosh(1000000);
    }
}

exec function DoshMe(int NewDoshAmount)
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        NewDoshAmount = int(float(NewDoshAmount) - KFPRI.Score);
        KFPRI.AddDosh(NewDoshAmount);
    }
}

exec function ShoppingSpree()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(Outer.PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.AddDosh(5000);
    }
    KFPlayerController(Outer).OpenTraderMenu(true);
}

exec function HurtMe(optional int DamageAmount)
{
    DamageAmount = 50;
    if(Outer.Pawn != none)
    {
        Outer.Pawn.TakeDamage(DamageAmount, none, vect(0, 0, 0), vect(0, 0, 0), none);
    }
}

exec function DoTMe(optional int DamageAmount)
{
    DamageAmount = 50;
    KFPawn(Outer.Pawn).ApplyDamageOverTime(DamageAmount, Outer.Pawn.Controller, Class'KFDT_Fire');
}

exec function HealMe(optional int HealAmount)
{
    HealAmount = 50;
    if(Outer.Pawn != none)
    {
        Outer.Pawn.HealDamage(HealAmount, Outer.Pawn.Controller, none);
    }
}

exec function ArmorMe(optional int ArmorAmount)
{
    ArmorAmount = 50;
    if((Outer.Pawn != none) && KFPawn_Human(Outer.Pawn) != none)
    {
        KFPawn_Human(Outer.Pawn).AddArmor(ArmorAmount);
    }
}

exec function PlayMuzzleFlash()
{
    local KFPawn KFP;

    KFP = KFPawn(Outer.Pawn);
    if(KFP != none)
    {
        KFP.WeaponAttachment.MuzzleFlash.CauseMuzzleFlash();
    }
}

exec function PlayShellEject()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(KFW.MuzzleFlash != none)
        {
            KFW.MuzzleFlash.CauseShellEject();
        }
    }
}

exec function SpamShellEject(optional float LifeParam, optional float interval)
{
    local KFWeapon KFW;

    LifeParam = 0;
    interval = 0.05;
    if(Outer.IsTimerActive('PlayShellEject', self))
    {
        Outer.ClearTimer('PlayShellEject', self);
        return;
    }
    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(KFW.MuzzleFlash == none)
        {
            KFW.AttachMuzzleFlash();
        }
        if((KFW.MuzzleFlash != none) && LifeParam > 0)
        {
            KFW.MuzzleFlash.SetShellEjectLife(LifeParam);
        }
    }
    Outer.SetTimer(interval, true, 'PlayShellEject', self);
}

simulated exec function TestHitZones()
{
    local Actor TestActor;
    local Vector HitLocation, HitNormal, TraceStart, TraceEnd;
    local TraceHitInfo CurrentImpact;

    TraceStart = Outer.PlayerCamera.CameraCache.POV.Location;
    TraceEnd = Outer.PlayerCamera.CameraCache.POV.Location + (vector(Outer.PlayerCamera.CameraCache.POV.Rotation) * float(2000));
    foreach Outer.Pawn.TraceActors(Class'Actor', TestActor, HitLocation, HitNormal, TraceEnd, TraceStart,, CurrentImpact, Outer.1)
    {
        if(TestActor.bBlockActors || TestActor.bProjTarget)
        {
            LogInternal((((("Hit this: " $ string(TestActor)) $ " ") $ string(CurrentImpact.HitComponent)) $ " ") $ string(CurrentImpact.BoneName));
        }        
    }    
}

simulated exec function SpawnFlare(optional float NewBrightness, optional float NewRadius, optional byte R, optional byte G, optional byte B)
{
    local KFDebugFlare NewFlare;

    NewBrightness = 1;
    NewRadius = 512;
    R = 255;
    G = 255;
    B = 255;
    if((Outer.Pawn == none) || Outer.Pawn.Weapon == none)
    {
        return;
    }
    NewFlare = Outer.Pawn.Spawn(Class'KFDebugFlare',,, Outer.Pawn.Weapon.GetPhysicalFireStartLoc());
    if(NewFlare != none)
    {
        NewFlare.Velocity = (500 * vector(Outer.Pawn.Rotation)) + (vect(0, 0, 1) * 150);
        NewFlare.FlareLight.SetLightProperties(NewBrightness, MakeColor(R, G, B));
        NewFlare.FlareLight.Radius = NewRadius;
    }
}

exec function KillFlares()
{
    local KFDebugFlare Flare;

    foreach Outer.Pawn.DynamicActors(Class'KFDebugFlare', Flare)
    {
        Flare.Destroy();        
    }    
}

exec function AllAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.AmmoCount[0] = KFW.MagazineCapacity[0];
        KFW.AddAmmo(KFW.GetMaxAmmoAmount(0));
        KFW.AddSecondaryAmmo(KFW.MagazineCapacity[1]);        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).AddGrenades(100);
    }
}

exec function UberAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.SpareAmmoCount[0] = KFW.GetMaxAmmoAmount(0) * 3;
        KFW.AmmoCount[0] = KFW.MagazineCapacity[0];
        KFW.AmmoCount[1] = KFW.MagazineCapacity[1];
        KFW.bInfiniteAmmo = true;        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).GrenadeCount = 255;
    }
}

exec function NoAmmo()
{
    local KFWeapon KFW;

    if(Outer.Pawn == none)
    {
        return;
    }
    foreach Outer.Pawn.InvManager.InventoryActors(Class'KFWeapon', KFW)
    {
        KFW.SpareAmmoCount[0] = 0;
        KFW.AmmoCount[0] = 0;
        KFW.AmmoCount[1] = 0;
        KFW.bInfiniteAmmo = false;        
    }    
    if(KFInventoryManager(Outer.Pawn.InvManager) != none)
    {
        KFInventoryManager(Outer.Pawn.InvManager).GrenadeCount = 0;
    }
}

exec function ToggleWeapCanPause()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.bPauseWithPlayersOnly = !KFW.bPauseWithPlayersOnly;
    }
}

exec function SetDebugRecoil3d(bool bNewDebug)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.bDebugRecoilPosition = bNewDebug;
    }
}

exec function SetIronIdleAnims(bool bNewUseAnims)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        if(bNewUseAnims)
        {
            KFW.IdleSightedAnims[0] = 'None';            
        }
        else
        {
            KFW.IdleSightedAnims[0] = KFW.default.IdleSightedAnims[0];
        }
    }
}

exec function SetISMeshCompScale(float DebugScale)
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.IronSightMeshFOVCompensationScale = DebugScale;
    }
}

exec function NoRecoil()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.maxRecoilPitch = 0;
        KFW.minRecoilPitch = 0;
        KFW.maxRecoilYaw = 0;
        KFW.minRecoilYaw = 0;
        Outer.ClientMessage("Recoil Disabled", CheatType);
    }
}

exec function GoRecoil()
{
    local KFWeapon KFW;

    KFW = KFWeapon(Outer.Pawn.Weapon);
    if(KFW != none)
    {
        KFW.maxRecoilPitch = KFW.default.maxRecoilPitch;
        KFW.minRecoilPitch = KFW.default.minRecoilPitch;
        KFW.maxRecoilYaw = KFW.default.maxRecoilYaw;
        KFW.minRecoilYaw = KFW.default.minRecoilYaw;
        Outer.ClientMessage("Recoil Enabled", CheatType);
    }
}

exec function ShowTraderPath()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenedTrader.ShowTraderPath();
}

exec function HideTraderPath()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenedTrader.HideTraderPath();
}

exec function OpenTrader()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.bTraderIsOpen = true;
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenTrader(300);
}

exec function OpenTraderNext()
{
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.bTraderIsOpen = true;
    KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.OpenTraderNext(300);
}

exec function OpenTraderMenu()
{
    KFPlayerController(Outer).OpenTraderMenu(true);
}

exec function FPDL()
{
    Outer.FlushPersistentDebugLines();
}

exec function GoToActor(name actorName)
{
    local Actor A;

    foreach Outer.AllActors(Class'Actor', A)
    {
        if(A.Name == actorName)
        {
            Ghost();
            Outer.Pawn.SetLocation(A.Location);
        }        
    }    
}

exec function AIHelp()
{
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
    if(true)
    {
        LogInternal("AI Debug Commands");
    }
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
    if(true)
    {
        LogInternal("	AIDEBUG					Makes AI non-aggressive and ready to receive debug commands");
    }
    if(true)
    {
        LogInternal(" AISETCANATTACK True/False Sets whether the debug mode pawn should be capable of attacking you");
    }
    if(true)
    {
        LogInternal("	TOGGLEALLNPCDEBUG		Renders names, some vital info, and a health bar above NPC heads");
    }
    if(true)
    {
        LogInternal("	AISTEPASIDE				Forces StepAside AI Command");
    }
    if(true)
    {
        LogInternal("	AITOGGLEHEADTRACKING	Toggles AI HeadTracking");
    }
    if(true)
    {
        LogInternal("	AIDEBUGTURNINPLACE		Starts TurnInPlace debug command - AI will constantly turn to player");
    }
    if(true)
    {
        LogInternal("	AITAUNT					Forces AI to execute a taunt command");
    }
    if(true)
    {
        LogInternal("	AIPATHTO <name>			AI will attempt to move/path to KFPathnode with DebugTagName matching <name>");
    }
    if(true)
    {
        LogInternal("--------------------------------------------------------------------------------------------");
    }
}

exec function AIHuskFlamethrower()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if((((KFAIC != none) && KFAIC.Pawn != none) && KFAIC.Pawn.Health > 0) && KFAIC.Pawn.IsA('KFPawn_ZedHusk'))
    {
        KFAIC.MovementPlugin.DisablePlugin();
        KFPawn(KFAIC.Pawn).DoSpecialMove(23, true, Outer.Pawn, 255);        
    }
    else
    {
        Outer.ClientMessage("You must be aiming toward a living Husk to execute this command.", CheatType);
    }
}

exec function DrawLineFromNPC(optional float Length)
{
    local KFDebugLines KFDL;
    local KFAIController KFAIC;

    Length = 500;
    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(KFAIC.Pawn.Location, 32, 8, 0, 255, 0, true);
        KFDL.AddDebugLine(KFAIC.Pawn.Location, KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * Length), 255, 0, 0, true);
        KFDL.AddDebugText3D(KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * (Length * 0.5)), string(Length) @ "Units", true, 0, 0, 255, true);
    }
}

exec function AllZedsTaunt(optional bool bSlow)
{
    local KFPawn_Monster KFPM;
    local bool bFound;

    bSlow = true;
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.MyKFAIC != none) && KFPM.IsAliveAndWell())
        {
            Class'AICommand_TauntEnemy'.static.Taunt(KFPM.MyKFAIC, KFPawn(Outer.Pawn), 1);
            bFound = true;
        }        
    }    
    if(bFound && bSlow)
    {
        Outer.SetTimer(2.5, false, 'ZedTauntTimer', self);
    }
}

exec function SlasherTaunt(optional bool bSlow)
{
    local KFPawn_Monster KFPM;
    local bool bFound;

    bSlow = true;
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(((KFPM.MyKFAIC != none) && KFPM.IsA('KFPawn_ZedClot_Slasher')) && KFPM.IsAliveAndWell())
        {
            Class'AICommand_TauntEnemy'.static.Taunt(KFPM.MyKFAIC, KFPawn(Outer.Pawn), 1);
            bFound = true;
        }        
    }    
    if(!bFound)
    {
        SpawnDebugAI("ClotS");
        foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
        {
            if(((KFPM.MyKFAIC != none) && KFPM.IsA('KFPawn_ZedClot_Slasher')) && KFPM.IsAliveAndWell())
            {
                Class'AICommand_TauntEnemy'.static.Taunt(KFPM.MyKFAIC, KFPawn(Outer.Pawn), 1);
                bFound = true;
            }            
        }        
    }
    if(bFound && bSlow)
    {
        Outer.SetTimer(2.5, false, 'SlasherTauntTimer', self);
    }
}

function ZedTauntTimer()
{
    KFGameInfo(Outer.WorldInfo.Game).DramaticEvent(1, 13);
}

function SlasherTauntTimer()
{
    KFGameInfo(Outer.WorldInfo.Game).DramaticEvent(1, 13);
}

exec function AIShowAnchor()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        KFAIC.bDebug_DrawAnchor = !KFAIC.bDebug_DrawAnchor;
        if(KFAIC.bDebug_DrawAnchor)
        {
            Outer.ClientMessage(("Rendering line to " $ string(KFAIC.Pawn)) $ "'s anchor.", CheatType);
        }
    }
}

exec function AIDebugFloor()
{
    local KFAIController KFAIC;
    local Vector Start, End;

    KFAIC = GetKFAICFromAim();
    if((KFAIC != none) && KFAIC.Pawn != none)
    {
        Start = KFAIC.Pawn.Location + (vector(KFAIC.Pawn.Rotation) * 64);
        End = Start + (Outer.Pawn.Floor * 512);
        Outer.DrawDebugLine(Start, End, 0, 0, 255, true);
        Outer.DrawDebugSphere(End, 24, 8, 0, 0, 255, true);
    }
}

exec function Puke(optional int SeqNum, optional bool bLooping)
{
    local KFPawn_Monster KFPM;
    local name SeqName;

    bLooping = true;
    if(SeqNum == 1)
    {
        SeqName = 'Atk_Vomit_V3';        
    }
    else
    {
        if(SeqNum == 2)
        {
            SeqName = 'Atk_Vomit_Move_V1';            
        }
        else
        {
            SeqName = 'Atk_Vomit_V1';
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if((((KFPM.IsA('KFPawn_ZedBloat') && KFPM.IsAliveAndWell()) && KFPM.MyKFAIC != none) && KFPM.MyKFAIC.bHasDebugCommand) && KFPM.PawnAnimInfo != none)
        {
            KFPM.PlayBodyAnim(SeqName, 0,,,, bLooping);
        }        
    }    
}

exec function AIHeadlessWander()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            KFPM.Health = 15;
            KFPM.CauseHeadTrauma();
        }        
    }    
}

exec function ShowBlockedPaths(optional bool bSkipWalls, optional bool bRenderResult, optional bool bLogResult, optional float WithinPawnRadius)
{
    local KFPawn_Monster KFMP;
    local KFAIController KFAIC;
    local NavigationPoint N;
    local int SpecIdx, LocalBlockedSpecIdx, RouteCacheIdx, Cost, BlockedCount, Total;

    local bool bInBlockedPathList;
    local string BlockedStr;
    local float BlockedTimeRemaining;

    bSkipWalls = true;
    bRenderResult = true;
    bLogResult = true;
    WithinPawnRadius = 0;
    if(!bRenderResult && !bLogResult)
    {
        bRenderResult = true;
    }
    KFMP = GetKFMPFromAim();
    if((KFMP != none) && KFMP.MyKFAIC != none)
    {
        KFAIC = KFMP.MyKFAIC;
        if(bLogResult)
        {
            LogInternal("===============================================================================");
            LogInternal((((((((((("Blocked paths for " $ string(KFMP)) $ " <") $ string(KFMP.MyKFAIC)) $ "> at ") $ string(KFMP.Location)) $ " [NPC Radius: ") $ string(KFMP.GetCollisionRadius())) $ " Height: ") $ string(KFMP.GetCollisionHeight())) $ "] Time: ") $ string(Outer.WorldInfo.TimeSeconds));
            LogInternal(" ");
        }
        foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', N)
        {
            if((WithinPawnRadius > 0) && VSize(N.Location - KFMP.Location) > WithinPawnRadius)
            {
                continue;                
            }
            if(bLogResult)
            {
                LogInternal("   Checking " $ string(N));
                LogInternal((((("    bBlocked:" $ string(N.bBlocked)) $ " bOneWayPath:") $ string(N.bOneWayPath)) $ " ExtraCost: ") $ string(N.ExtraCost));
                if(N.AnchoredPawn != none)
                {
                    LogInternal((("    AnchoredPawn:" $ string(N.AnchoredPawn)) $ " LastAnchoredPawnTime:") $ string(N.LastAnchoredPawnTime));
                }
            }
            if(N.bBlocked && bRenderResult)
            {
                Outer.DrawDebugSphere(N.Location, 24, 6, 255, 0, 0, true);
            }
            SpecIdx = 0;
            J0x4D1:

            if(SpecIdx < N.PathList.Length)
            {
                bInBlockedPathList = false;
                BlockedTimeRemaining = 0;
                ++ Total;
                Cost = N.PathList[SpecIdx].GetCostFor(KFMP);
                LocalBlockedSpecIdx = 0;
                J0x580:

                if(LocalBlockedSpecIdx < KFAIC.BlockedPathList.Length)
                {
                    if(N.PathList[SpecIdx] == KFAIC.BlockedPathList[LocalBlockedSpecIdx].BlockedReachSpec)
                    {
                        bInBlockedPathList = true;
                        BlockedTimeRemaining = KFAIC.BlockedPathList[LocalBlockedSpecIdx].BlockedTime;
                        goto J0x677;
                    }
                    ++ LocalBlockedSpecIdx;
                    goto J0x580;
                }
                J0x677:

                if((bInBlockedPathList || N.bBlocked) || Cost >= N.PathList[SpecIdx].10000000)
                {
                    ++ BlockedCount;
                    if(bLogResult)
                    {
                        LogInternal(((((((((("  Found blocked path for " $ string(KFMP)) $ " in NavPoint ") $ string(N)) $ " [bBlocked:") $ string(N.bBlocked)) $ "][OneWay:") $ string(N.bOneWayPath)) $ "][ExtraCost:") $ string(N.ExtraCost)) $ "]");
                        if(N.AnchoredPawn != none)
                        {
                            LogInternal((("   " $ string(N)) $ "'s anchored pawn is ") $ string(N.AnchoredPawn));
                        }
                        BlockedStr = ((((((((((("		**** Path from " $ string(N)) $ " to ") $ string(N.PathList[SpecIdx].End.Actor)) $ " [Cost:") $ string(Cost)) $ " Start:") $ string(N.PathList[SpecIdx].Start)) $ " End:") $ string(N.PathList[SpecIdx].End.Actor)) $ " ReachFlags:") $ string(N.PathList[SpecIdx].reachFlags)) $ "] is blocked ";
                        if(bInBlockedPathList)
                        {
                            BlockedStr = ((((BlockedStr $ "(ReachSpec Found In ") $ string(KFAIC)) $ " BlockedPathList [TimeRemaining:") $ string(BlockedTimeRemaining)) $ " seconds]) ";
                        }
                        if(N.bBlocked)
                        {
                            BlockedStr = ((BlockedStr $ "(") $ string(N)) $ " bBlocked is TRUE) ";
                        }
                        LogInternal(BlockedStr);
                        LogInternal((((((("		  Max Radius:" $ string(N.PathList[SpecIdx].CollisionRadius)) $ " Max Height:") $ string(N.PathList[SpecIdx].CollisionHeight)) $ " MaxLandingVelocity:") $ string(N.PathList[SpecIdx].MaxLandingVelocity)) $ " bCanCutCorners:") $ string(N.PathList[SpecIdx].bCanCutCorners));
                        RouteCacheIdx = 0;
                        J0xC56:

                        if(RouteCacheIdx < KFAIC.RouteCache.Length)
                        {
                            if(KFAIC.RouteCache[RouteCacheIdx] == N)
                            {
                                LogInternal(((((("		  Found " $ string(N)) $ " in ") $ string(KFAIC)) $ "'s routecache [Slot ") $ string(RouteCacheIdx)) $ "]");
                                goto J0xD25;
                            }
                            ++ RouteCacheIdx;
                            goto J0xC56;
                        }
                    }
                    J0xD25:

                    if(bRenderResult)
                    {
                        Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 255, 0, 0, true);
                    }
                }
                ++ SpecIdx;
                goto J0x4D1;
            }
            if(bLogResult)
            {
                LogInternal("-------------------------------------------------------------------------------");
            }            
        }        
        if(bLogResult)
        {
            LogInternal(" ");
            LogInternal((((("	  Found " $ string(BlockedCount)) $ " blocked paths (out of ") $ string(Total)) $ " checked) for ") $ string(KFMP));
            LogInternal("===============================================================================");
        }
    }
}

exec function ShowReachSpecsFor(name ZedType, optional bool bShowBlocked)
{
    local NavigationPoint N;
    local int SpecIdx;
    local float Radius, Height;
    local KFPawn Spawned;
    local bool bShowWallPaths;

    bShowBlocked = true;
    switch(ZedType)
    {
        case 'FP':
            Spawned = SpawnZed("FP",, true);
            break;
        default:
            bShowWallPaths = true;
            Spawned = SpawnZed("CR",, true);
            break;
    }
    if(Spawned != none)
    {
        Radius = Spawned.GetCollisionRadius();
        Height = Spawned.GetCollisionHeight();
    }
    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', N)
    {
        if(!bShowWallPaths && KFWallPathNode(N) != none)
        {
            continue;            
        }
        SpecIdx = 0;
        J0x14E:

        if(SpecIdx < N.PathList.Length)
        {
            if((float(N.PathList[SpecIdx].CollisionRadius) >= Radius) && float(N.PathList[SpecIdx].CollisionHeight) >= Height)
            {
                Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 0, 255, 0, true);                
            }
            else
            {
                if(bShowBlocked)
                {
                    Outer.DrawDebugLine(N.PathList[SpecIdx].Start.Location, N.PathList[SpecIdx].End.Actor.Location, 255, 0, 0, true);
                }
            }
            ++ SpecIdx;
            goto J0x14E;
        }        
    }    
    if(Spawned != none)
    {
        Spawned.Destroy();
    }
}

exec function DumpDebugNodes()
{
    local KFPathnode KFPN;

    foreach Outer.WorldInfo.AllActors(Class'KFPathnode', KFPN)
    {
        if(KFPN.DebugTag != 'None')
        {
            LogInternal((((("Found " $ string(KFPN)) $ " with DebugTag ") $ string(KFPN.DebugTag)) $ " at ") $ string(KFPN.Location));
        }        
    }    
}

exec function GotoDebugNode(name TagName)
{
    local KFPathnode KFPN;

    foreach Outer.WorldInfo.AllActors(Class'KFPathnode', KFPN)
    {
        if((KFPN.DebugTag != 'None') && KFPN.DebugTag == TagName)
        {
            if(Outer.bCollideWorld)
            {
                Ghost();
            }
            if(!Outer.Pawn.SetLocation(KFPN.Location + vect(0, 0, 32)))
            {
                Outer.ClientMessage("Ghost mode is on, but I failed to set your location!", CheatType);
                continue;
            }
            Outer.ClientMessage(((("Teleported to " $ string(KFPN)) $ "'s location [") $ string(KFPN.Location)) $ "] - Ghost Mode is on", CheatType);
        }        
    }    
}

exec function ShowDebugNodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local float WidestRadius;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if((NP.DebugTag != 'None') && NP.DebugTag != NP.Class.Name)
            {
                if(bOn)
                {
                    I = 0;
                    J0x107:

                    if(I < NP.PathList.Length)
                    {
                        if((WidestRadius == 0) || float(NP.PathList[I].CollisionRadius) < WidestRadius)
                        {
                            WidestRadius = float(NP.PathList[I].CollisionRadius);
                        }
                        ++ I;
                        goto J0x107;
                    }
                    KFDL.AddDebugSphere(NP.Location, WidestRadius, 8, 0, 255, 0, false, 120);
                    KFDL.AddDebugText3D(NP.Location + vect(0, 0, 12), (string(NP) $ ": ") $ string(NP.DebugTag), true, 20, 70, 150, false, 120);
                    WidestRadius = 0;
                    continue;
                }
                KFDL.ClearAll();
            }            
        }        
    }
}

exec function AISetPeriph(float NewPeripheralVision)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.MyKFPawn.PeripheralVision = NewPeripheralVision;
    Outer.ClientMessage((string(KFAIC.MyKFPawn) $ "'s peripheral vision is now ") $ string(KFAIC.MyKFPawn.PeripheralVision), CheatType);
}

exec function AIDebugVision()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if(!KFAIC.bHasDebugCommand)
    {
        Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " must have a controller in debug mode first!", CheatType);
    }
    AICommand_Debug(KFAIC.GetActiveCommand()).Debug_Vision(Outer.Pawn);
}

exec function AISetSightRadius(float NewSightRadius)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.MyKFPawn.SightRadius = NewSightRadius;
    Outer.ClientMessage((string(KFAIC.MyKFPawn) $ "'s sightradius is now ") $ string(KFAIC.MyKFPawn.PeripheralVision), CheatType);
}

exec function PathInfo()
{
    Outer.ClientMessage("Paths last built: " $ Outer.WorldInfo.LastSuccessfulPathBuildTime, CheatType);
}

exec function AIDebugMode(optional bool bDebugMode)
{
    local KFGameInfo KFG;
    local KFAIDirector AIManager;

    bDebugMode = true;
    KFG = KFGameInfo(Outer.WorldInfo.Game);
    if(KFG != none)
    {
        AIManager = KFG.GetAIDirector();
        if(AIManager != none)
        {
            AIManager.SetAIDebug(bDebugMode);
            if(bDebugMode)
            {
                Outer.ClientMessage("Debug mode turned on for active NPCs, and new NPCs will spawn in debug mode.", CheatType);                
            }
            else
            {
                Outer.ClientMessage("Debug mode turned off for active NPCs, and new NPCs will no longer spawn in debug mode.", CheatType);
            }
        }
    }
}

exec function ShowDebugStrikeRanges(optional bool bShowAll)
{
    bShowAll = false;    
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowStrikeRange true");
    if(bShowAll)
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange true");        
    }
    else
    {        
        Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange false");
    }
}

exec function HideDebugStrikeRanges()
{
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowStrikeRange false");    
    Outer.ConsoleCommand("SETNOPEC KFAIController bDebug_ShowAllStrikeRange false");
}

exec function AIDebug(optional bool bAllZeds)
{
    local KFAIController KFAIC;

    bAllZeds = false;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
        {
            if(bAllZeds || Outer.IsAimingAt(KFAIC.Pawn, 0.95))
            {
                KFAIC.StopAllLatentMovement();
                KFAIC.AbortMovementCommands();
                KFAIC.AbortMovementPlugIns();
                KFAIC.BeginDebugCommand();
            }
        }        
    }    
}

exec function AIFlee(optional float FleeDuration, optional float FleeDistance)
{
    local KFAIController KFAIC;

    FleeDistance = 5000;
    KFAIC = GetKFAICFromAim();
    if(KFAIC != none)
    {
        KFAIC.DoFleeFrom(GetMyPawn(), FleeDuration, FleeDistance);
    }
}

exec function AIWander(optional bool bWanderTowardMe, optional bool bWanderAwayFromMe, optional float WanderDuration, optional float MaxWanderDistance)
{
    local KFAIController KFAIC;

    WanderDuration = -1;
    MaxWanderDistance = 10000;
    KFAIC = GetKFAICFromAim();
    if(KFAIC != none)
    {
        if(bWanderTowardMe || bWanderAwayFromMe)
        {
            KFAIC.DoWander(GetMyPawn(), WanderDuration, bWanderAwayFromMe, MaxWanderDistance);            
        }
        else
        {
            KFAIC.DoWander(,, WanderDuration, false, MaxWanderDistance);
        }
    }
}

exec function AIDebugSteering()
{
    local AICommand_Debug DebugCommand;

    DebugCommand = GetDebugAICommand();
    if(DebugCommand != none)
    {
        DebugCommand.Debug_Steering();
    }
}

exec function AIDebugStepAside(optional bool bOn)
{
    local AICommand_Debug DebugCommand;

    bOn = true;
    DebugCommand = GetDebugAICommand();
    if(DebugCommand != none)
    {
        DebugCommand.Debug_StepAside(bOn);
    }
}

exec function ShowAIStuckNpcsToggle()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.ShowStuckNpcsToggle();        
    }    
}

exec function ToggleShowVisualStuckZedDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowVisualStuckZedDebugInfo = !KFGameInfo.AIDirector.bShowVisualStuckZedDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowVisualStuckZedDebugInfo = !KFAIC.bShowVisualStuckZedDebugInfo;
        LogInternal("ToggleShowVisualStuckZedDebugInfo - " @ string(KFAIC.bShowVisualStuckZedDebugInfo));        
    }    
}

exec function ToggleShowMovePointsDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowMovePointsDebugInfo = !KFGameInfo.AIDirector.bShowMovePointsDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowMovePointsDebugInfo = !KFAIC.bShowMovePointsDebugInfo;
        LogInternal("ToggleShowMovePointsDebugInfo - " @ string(KFAIC.bShowMovePointsDebugInfo));        
    }    
}

exec function ToggleShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = !KFGameInfo.AIDirector.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = !KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
        LogInternal("ToggleShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState - " @ string(KFAIC.bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState));        
    }    
}

exec function ToggleShowHighDetailCombatMovementDebugInfo()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowHighDetailCombatMovementDebugInfo = !KFGameInfo.AIDirector.bShowHighDetailCombatMovementDebugInfo;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowHighDetailCombatMovementDebugInfo = !KFAIC.bShowHighDetailCombatMovementDebugInfo;
        LogInternal("ToggleShowVisualStuckZedDebugInfo - " @ string(KFAIC.bShowHighDetailCombatMovementDebugInfo));        
    }    
}

exec function ToggleShowLeapDownDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowLeapDownDebugArtifacts = !KFGameInfo.AIDirector.bShowLeapDownDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowLeapDownDebugArtifacts = !KFAIC.bShowLeapDownDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowLeapDownDebugArtifacts));        
    }    
}

exec function ToggleShowDoorNavigationDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowDoorNavigationDebugArtifacts = !KFGameInfo.AIDirector.bShowDoorNavigationDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowDoorNavigationDebugArtifacts = !KFAIC.bShowDoorNavigationDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowDoorNavigationDebugArtifacts));        
    }    
}

exec function ToggleShowDestructibleNavigationDebugArtifacts()
{
    local KFAIController KFAIC;
    local KFGameInfo KFGameInfo;

    if(KFGameInfo(Outer.WorldInfo.Game) == none)
    {
        return;
    }
    KFGameInfo = KFGameInfo(Outer.WorldInfo.Game);
    KFGameInfo.AIDirector.bShowDestructibleNavigationDebugArtifacts = !KFGameInfo.AIDirector.bShowDestructibleNavigationDebugArtifacts;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.bShowDestructibleNavigationDebugArtifacts = !KFAIC.bShowDestructibleNavigationDebugArtifacts;
        LogInternal((string(GetFuncName()) @ " - ") @ string(KFAIC.bShowDestructibleNavigationDebugArtifacts));        
    }    
}

exec function CheckReachSpecs()
{
    local NavigationPoint NP;
    local int I, X, iCount;
    local array<NavigationPoint> Templist;

    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', NP)
    {
        I = 0;
        J0x54:

        if(I < NP.PathList.Length)
        {
            if(NP.PathList[I].End.Actor == none)
            {
                LogInternal((((string(NP) $ " FOUND NO END FOR REACHSPEC ") $ string(NP.PathList[I])) $ " in slot ") $ string(I));
            }
            Templist.AddItem(NavigationPoint(NP.PathList[I].End.Actor);
            ++ I;
            goto J0x54;
        }
        X = 0;
        J0x1CA:

        if(X < NP.PathList.Length)
        {
            iCount = 0;
            I = 0;
            J0x20D:

            if(I < Templist.Length)
            {
                if(NavigationPoint(NP.PathList[X].End.Actor) == Templist[I])
                {
                    if(iCount > 0)
                    {
                        LogInternal((((("FOUND DUPE REACHSPEC (" $ string(NP.PathList[X])) $ " IN ") $ string(NP)) $ " LEADING TO ") $ string(Templist[I]));
                    }
                    ++ iCount;
                }
                ++ I;
                goto J0x20D;
            }
            ++ X;
            goto J0x1CA;
        }
        Templist.Length = 0;        
    }    
}

function KFAIController GetKFAICFromAim(optional bool bOnlyPawnsWithDebug, optional float Epsilon)
{
    local KFPawn_Monster KFPM;

    Epsilon = 0.92;
    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none) && Outer.IsAimingAt(KFPM, Epsilon))
        {
            if(bOnlyPawnsWithDebug && !KFPM.MyKFAIC.bHasDebugCommand)
            {
                continue;                
            }            
            return KFPM.MyKFAIC;
        }        
    }    
    return none;
}

function KFPawn_Monster GetKFMPFromAim(optional bool bOnlyPawnsWithDebug)
{
    local KFPawn_Monster KFPM;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && Outer.IsAimingAt(KFPM, 0.95))
        {
            if((KFPM.MyKFAIC != none) && bOnlyPawnsWithDebug && !KFPM.MyKFAIC.bHasDebugCommand)
            {
                continue;                
            }            
            return KFPM;
        }        
    }    
    return none;
}

exec function ToggleDebugCamera(optional bool bDrawDebugText)
{
    bDrawDebugText = true;
    Outer.bGodMode = true;
    super.ToggleDebugCamera(bDrawDebugText);
}

exec function TDC(optional bool bDrawDebugText)
{
    bDrawDebugText = true;
    ToggleDebugCamera(bDrawDebugText);
}

function EnableDebugCamera(bool bEnableDebugText)
{
    super.EnableDebugCamera(bEnableDebugText);
    KFDebugCameraController(DebugCameraControllerRef).bDebugSceneEnabled = bDebugSceneEnabled;
    KFDebugCameraController(DebugCameraControllerRef).DebugSceneCamera = DebugSceneCamera;
    KFDebugCameraController(DebugCameraControllerRef).DebugTarget = DebugTarget;
}

exec function DumpInfoForAI(optional bool bOutputToConsole)
{
    local float TimeSinceLastRender;
    local string Info;
    local KFAIController KFAIC;

    bOutputToConsole = true;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        TimeSinceLastRender = Outer.WorldInfo.TimeSeconds - KFAIC.Pawn.LastRenderTime;
        Info = (((((((((((Info $ " 
... ") $ string(KFAIC)) @ string(KFAIC.Pawn)) $ "(ActvCmd:") $ KFAIC.GetActionString()) $ ")  -- TimeSinceLastRender:") @ string(TimeSinceLastRender)) @ "Enemy:") @ string(KFAIC.Enemy)) @ "AILoc:") @ string(KFAIC.Pawn.Location)) $ "
";        
    }    
    if((bOutputToConsole && Outer.Player != none) && LocalPlayer(Outer.Player) != none)
    {
        LocalPlayer(Outer.Player).ViewportClient.ViewportConsole.OutputText(Info);
    }
    LogInternal(Info);
}

exec function ViewSelf(optional bool bQuiet)
{
    if((Outer.ViewTarget != none) && KFPawn_Monster(Outer.ViewTarget) != none)
    {
        KFPawn_Monster(Outer.ViewTarget).SetDebugTextRendering(false);
        SetNPCDebugCategory(false, 'AICommands');
    }
    super(CheatManager).ViewSelf(bQuiet);
}

exec function ViewZed(optional bool bLogBugItInfo)
{
    local Actor first;
    local bool bFound;
    local KFAIController C;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', C)
    {
        if((C.Pawn != none) && C.Pawn.Health > 0)
        {
            if(bFound || first == none)
            {
                first = C.Pawn;
                if(bFound)
                {
                    break;
                }
            }
            if((C.PlayerReplicationInfo == Outer.RealViewTarget) || C.Pawn == Outer.ViewTarget)
            {
                bFound = true;
            }
        }        
    }    
    if(first != none)
    {
        LogInternal("view " $ string(first));
        Outer.SetViewTarget(first);
        Outer.SetCameraMode('FreeCam');
        KFPawn_Monster(first).SetDebugTextRendering(true);
        SetNPCDebugCategory(true, 'AICommands');
        Outer.FixFOV();
        if(bLogBugItInfo)
        {
            Outer.BugItAI((((("Viewing from " $ string(first)) $ ", health: ") $ string(Pawn(first).Health)) $ " command: ") $ string(KFPawn_Monster(first).MyKFAIC.GetActiveCommand()));
        }
        Outer.ClientMessage(("Viewing from " $ string(first)) $ ", type 'ViewSelf' to return to your body. Type 'Camera first' to switch to first-person.", CheatType);        
    }
    else
    {
        ViewSelf(true);
    }
}

exec function TeleportPawnToCamera(optional bool bToggleDebugCameraOff)
{
    bToggleDebugCameraOff = false;
    super.TeleportPawnToCamera(bToggleDebugCameraOff);
}

exec function AIMoveForward()
{
    GetDebugAICommand().Debug_MoveForward();
}

exec function AIHide_Debug()
{
    local KFPawn_Monster KFPM;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none) && Outer.IsAimingAt(KFPM, 0.88))
        {
            if(KFPM.MyKFAIC.bHasDebugCommand)
            {
                KFPM.MyKFAIC.SetEnemy(Outer.Pawn);
                AICommand_Debug(KFPM.MyKFAIC.GetActiveCommand()).Debug_Hide();
            }
        }        
    }    
}

exec function AIFPRoam()
{
    local KFPawn_Monster KFPM;
    local KFAIController KFAIC;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            if(KFPM.IsA('KFPawn_ZedFleshpound'))
            {
                KFAIC = KFPM.MyKFAIC;
                if(KFAIC.bHasDebugCommand)
                {
                    AICommand_Debug(KFAIC.GetActiveCommand()).GotoState('Roaming');
                    break;
                }
            }
        }        
    }    
}

exec function EnterZedVictoryState()
{
    local KFAIController AI;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        AI.EnterZedVictoryState();        
    }    
}

exec function AddAIFilter(coerce string Filter)
{
    local KFAIController AI;
    local int Idx;
    local name N;

    N = name(Filter);
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        Idx = AI.AILogFilter.Find(N;
        if(Idx < 0)
        {
            AI.AILogFilter[AI.AILogFilter.Length] = N;
        }        
    }    
}

exec function RemoveAIFilter(coerce string Filter)
{
    local KFAIController AI;
    local int Idx;
    local name N;

    N = name(Filter);
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        Idx = AI.AILogFilter.Find(N;
        if(Idx >= 0)
        {
            Outer.Pawn.MessagePlayer("Removed Filter" @ Filter);
            AI.AILogFilter.Remove(Idx, 1;
        }        
    }    
}

exec function FlushAILogs()
{
    local KFAIController GAI;

    if(!Outer.WorldInfo.bPlayersOnly)
    {
        Outer.DebugFreezeGame();
    }
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', GAI)
    {
        if(GAI.AILogFile != none)
        {
            GAI.AILogFile.CloseLog();
            GAI.AILogFile.Destroy();
            GAI.AILogFile = none;
        }        
    }    
}

exec function AIFPEnrage()
{
    local KFPawn_Monster KFPM;
    local KFAIController KFAIC;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell() && KFPM.MyKFAIC != none)
        {
            if(KFPM.IsA('KFPawn_ZedFleshpound'))
            {
                KFPM.MyKFAIC.Enemy = Outer.Pawn;
                KFAIC = KFPM.MyKFAIC;
                KFAIC.SetEnemy(Outer.Pawn);
                KFAIC.MyKFPawn.SetEnraged(true);
            }
        }        
    }    
}

exec function AIScream()
{
    local KFPawn_Monster KFPM, Siren;

    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if((KFPM.IsA('KFPawn_ZedSiren') && KFPM.IsAliveAndWell()) && KFPM.MyKFAIC != none)
        {
            Siren = KFPM;
            KFPM.DoSpecialMove(21, true);
        }        
    }    
    foreach Outer.DynamicActors(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsA('KFPawn_ZedClot'))
        {
            KFPM.MyKFAIC.Focus = Siren;
            KFPM.LookAtPawn(Siren);
        }        
    }    
}

exec function ToggleNPCDebug(optional name Category)
{
    local KFPawn_Monster KFPM;
    local bool bNPCDebugIsOn;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFPM = GetKFMPFromAim();
    if((KFPM != none) && KFPM.IsAliveAndWell())
    {
        bNPCDebugIsOn = KFPM.bDebug_DrawOverheadInfo;
        bNPCDebugIsOn = !bNPCDebugIsOn;
        Outer.ClientMessage((("Turning " $ ((bNPCDebugIsOn) ? "on" : "off")) $ " debug text rendering for ") $ string(KFPM), CheatType);
        KFPM.SetDebugTextRendering(bNPCDebugIsOn);
        SetNPCDebugCategory(bNPCDebugIsOn, Category);        
    }
    else
    {
        Outer.ClientMessage("You must be aiming toward a living NPC to use this command, or use 'ToggleAllNPCDebug' for ALL NPCs.", CheatType);
    }
}

exec function AIStepAside(optional bool bForMe)
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    if(((KFAIC != none) && KFAIC.MyKFPawn != none) && KFAIC.MyKFPawn.IsAliveAndWell())
    {
        if(!bForMe)
        {
            Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " stepping aside.", CheatType);
            KFAIC.StepAsideFor(KFAIC.MyKFPawn, vector(KFAIC.MyKFPawn.Rotation));            
        }
        else
        {
            Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " stepping out of your way.", CheatType);
            KFAIC.StepAsideFor(Outer.Pawn, vector(Outer.Pawn.Rotation));
        }
    }
}

exec function ShowAIInfo(optional bool bOn)
{
    local KFPawn_Monster KFMP;

    bOn = true;
    KFMP = GetKFMPFromAim();
    if((((DebugTarget != none) && !DebugTarget.bDeleteMe) && DebugTarget.Health > 0) && DebugTarget.MyKFAIC != none)
    {
        DebugTarget.SetDebugTextRendering(false);
        SetNPCDebugCategory(false, 'AICommands');
        Outer.ClientMessage("Turning off AICommand debugging for " $ string(KFMP), CheatType);
        DebugTarget = none;
        return;
    }
    if((KFMP != none) && KFMP.Health > 0)
    {
        DebugTarget = KFMP;
        KFMP.SetDebugTextRendering(bOn);
        SetNPCDebugCategory(bOn, 'AICommands');
        Outer.ClientMessage("Turning on AICommand debugging for " $ string(KFMP), CheatType);
    }
}

exec function ToggleAllNPCDebug(optional name Category)
{
    local KFGameInfo KFGI;
    local KFAIDirector Director;
    local KFPawn_Monster KFPM;
    local bool bNPCDebugIsOn;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director != none)
        {
            Director.bShowAINames = !Director.bShowAINames;
            bNPCDebugIsOn = Director.bShowAINames;
            Outer.ClientMessage("bShowAINames [Director] is now " $ string(Director.bShowAINames), CheatType);
            Outer.ClientMessage("bNPCDebugIsOn is " $ string(bNPCDebugIsOn), CheatType);
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell())
        {
            KFPM.SetDebugTextRendering(bNPCDebugIsOn);
        }        
    }    
    SetNPCDebugCategory(bNPCDebugIsOn, Category);
    Outer.ClientMessage(("Turning " $ ((bNPCDebugIsOn) ? "on" : "off")) $ " debug text rendering for NPCs", CheatType);
}

exec function SetAllNPCDebug(bool bTurnOn, optional name Category)
{
    local KFGameInfo KFGI;
    local KFAIDirector Director;
    local KFPawn_Monster KFPM;

    Category = 'All';
    if(Category == 'None')
    {
        Category = 'All';
    }
    if(Category != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(Category != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director != none)
        {
            Director.bShowAINames = bTurnOn;
            Outer.ClientMessage("bShowAINames [Director] is now " $ string(Director.bShowAINames), CheatType);
            Outer.ClientMessage("bTurnOn is " $ string(bTurnOn), CheatType);
        }
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.IsAliveAndWell())
        {
            KFPM.SetDebugTextRendering(bTurnOn);
        }        
    }    
    SetNPCDebugCategory(bTurnOn, Category);
    Outer.ClientMessage(("Turning " $ ((bTurnOn) ? "on" : "off")) $ " debug text rendering for NPCs", CheatType);
}

simulated function SetNPCDebugCategory(bool bTurnOn, optional name Category)
{
    local PlayerController PC;
    local KFHUDBase KFHud;

    Category = 'All';
    foreach Outer.LocalPlayerControllers(Class'PlayerController', PC)
    {
        KFHud = KFHUDBase(PC.myHUD);        
    }    
    if(KFHud != none)
    {
        if(-1 != KFHud.DebugDisplay.RemoveItem(Category)
        {
            KFHud.SaveConfig();
        }
        if(bTurnOn)
        {
            KFHud.ShowDebug(Category);
        }
        KFHud.bShowDebugInfo = false;
    }
}

exec function TAND(optional name Category)
{
    Category = 'All';
    ToggleAllNPCDebug(Category);
}

exec function ShowAiDebugText(optional bool bAffectAllZeds, optional name DebugCategory)
{
    local KFAIController KFAIC;
    local KFGameInfo KFGI;
    local KFAIDirector Director;

    bAffectAllZeds = false;
    DebugCategory = 'All';
    if(DebugCategory == 'None')
    {
        DebugCategory = 'All';
    }
    if(DebugCategory != 'All')
    {
        SetNPCDebugCategory(false, 'All');
    }
    if(DebugCategory != 'AllVerbose')
    {
        SetNPCDebugCategory(false, 'AllVerbose');
    }
    if(bAffectAllZeds)
    {
        KFGI = KFGameInfo(Outer.WorldInfo.Game);
        if(KFGI != none)
        {
            Director = KFGI.GetAIDirector();
            Director.bShowAINames = !Director.bShowAINames;
            SetNPCDebugCategory(Director.bShowAINames, DebugCategory);
            foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
            {
                KFAIC.bDebug_PostRenderInfo = !KFAIC.bDebug_PostRenderInfo;
                KFAIC.bDebug_DrawOverheadInfo = KFAIC.bDebug_PostRenderInfo;
                KFAIC.SetPostRendering(KFAIC.bDebug_PostRenderInfo);
                if((KFPawn_Monster(KFAIC.Pawn) != none) && KFPawn_Monster(KFAIC.Pawn).IsAliveAndWell())
                {
                    KFPawn_Monster(KFAIC.Pawn).SetDebugTextRendering(Director.bShowAINames);
                }                
            }            
        }        
    }
    else
    {
        KFAIC = GetKFAICFromAim();
        if((KFAIC != none) && KFAIC.Pawn != none)
        {
            KFAIC.bDebug_PostRenderInfo = !KFAIC.bDebug_PostRenderInfo;
            KFAIC.bDebug_DrawOverheadInfo = KFAIC.bDebug_PostRenderInfo;
            SetNPCDebugCategory(KFAIC.bDebug_DrawOverheadInfo, DebugCategory);
            KFAIC.SetPostRendering(KFAIC.bDebug_PostRenderInfo);
            if((KFPawn_Monster(KFAIC.Pawn) != none) && KFPawn_Monster(KFAIC.Pawn).IsAliveAndWell())
            {
                KFPawn_Monster(KFAIC.Pawn).SetDebugTextRendering(KFAIC.bDebug_DrawOverheadInfo);
            }
        }
    }
}

exec function AIShowNames(optional bool bOff)
{
    local KFAIController KFAIC;
    local KFGameInfo KFGI;
    local KFAIDirector Director;

    bOff = false;
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        Director = KFGI.GetAIDirector();
        if(Director.bShowAINames && bOff)
        {
            Outer.ClientMessage("Turning off AIShowNames...", CheatType);
            Director.bShowAINames = false;            
        }
        else
        {
            if(Director.bShowAINames)
            {
                Outer.ClientMessage("AIShowNames is already on, enter 'AIShowNames false' to turn off.", CheatType);                
            }
            else
            {
                Outer.ClientMessage("Turning on AIShowNames...", CheatType);
            }
            Director.bShowAINames = true;
        }
        foreach Outer.AllActors(Class'KFAIController', KFAIC)
        {
            KFAIC.bDebug_PostRenderInfo = Director.bShowAINames;
            KFAIC.bDebug_DrawOverheadInfo = Director.bShowAINames;            
        }        
    }
}

exec function AIShowDebug()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(DebugKFAIC != none)
        {
            KFAIC.bDebug_DrawAIDebug = false;
            KFAIC.SetupDebug();
            DebugKFAIC = none;
        }
        if((KFAIC.Pawn != none) && Outer.IsAimingAt(KFAIC.Pawn, 0.95))
        {
            KFAIC.bDebug_DrawAIDebug = true;
            DebugKFAIC = KFAIC;
            KFAIC.SetupDebug();
        }        
    }    
}

function AICommand_Debug GetDebugAICommand()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(Outer.IsAimingAt(KFAIC.Pawn, 0.92))
        {
            if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
            {                
                return AICommand_Debug(KFAIC.GetActiveCommand());
            }
        }        
    }    
    Outer.ClientMessage("You need to be aiming at a DebugMode Zed in order for this to work.", CheatType);
    return none;
}

exec function MarkLocation()
{
    local Vector SphereLocation;

    if((Outer.Pawn == none) && DebugCameraController(Outer) != none)
    {
        SphereLocation = Outer.Location;        
    }
    else
    {
        SphereLocation = Outer.Pawn.Location;
    }
    Outer.DrawDebugSphere(SphereLocation, 36, 8, 255, 255, 0, true);
}

exec function AISetEnemyToMe(optional bool bAllAI)
{
    local KFAIController KFAIC;

    bAllAI = false;
    if(!bAllAI)
    {
        KFAIC = GetKFAICFromAim();
        if(KFAIC != none)
        {
            KFAIC.SetEnemy(Outer.Pawn);
        }        
    }
    else
    {
        foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
        {
            if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
            {
                KFAIC.SetEnemy(Outer.Pawn);
            }            
        }        
    }
}

exec function AISetCanAttack(bool bCanAttack)
{
    GetDebugAICommand().bAllowedToAttack = bCanAttack;
    Outer.ClientMessage((((string(GetDebugAIController().Pawn) $ " ") $ string(GetDebugAICommand())) $ " bAllowedToAttack is now ") $ string(bCanAttack), CheatType);
}

exec function GetYawRate()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if(KFAIC != none)
    {
        Outer.ClientMessage((string(KFAIC.Pawn) $ "'s RotationRate.Yaw is ") $ string(KFAIC.Pawn.RotationRate.Yaw), CheatType);
    }
}

exec function AIDisableBump()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.Disable('NotifyBump');
        Outer.ClientMessage(string(KFAIC.Pawn) $ " Bump Disabled", CheatType);
    }
}

exec function AIEnableBump()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.Enable('NotifyBump');
        Outer.ClientMessage(string(KFAIC.Pawn) $ " Bump Enabled", CheatType);
    }
}

exec function AIToggleHeadTracking()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        if(KFAIC.MyKFPawn.bIsHeadTrackingActive)
        {
            KFAIC.MyKFPawn.ClearHeadTrackTarget(Outer.GetALocalPlayerController().Pawn, 0.25);            
        }
        else
        {
            KFAIC.MyKFPawn.LookAtPawn(Outer.GetALocalPlayerController().Pawn);
        }
    }
}

exec function TestScreamEffect()
{
    Outer.Pawn.TakeDamage(1, Outer, Outer.Pawn.Location, vect(0, 0, 0), Class'KFDT_Sonic');
}

function KFAIController GetDebugAIController(optional bool bGetClosest, optional name inFunctionName)
{
    local KFAIController KFAIC, ClosestKFAIC;

    bGetClosest = false;    
    if(inFunctionName == 'None')
    {
        inFunctionName = GetFuncName();
    }
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
        {
            if(bGetClosest)
            {
                if(ClosestKFAIC == none)
                {
                    ClosestKFAIC = KFAIC;                    
                }
                else
                {
                    if(VSize(KFAIC.Pawn.Location - Outer.Pawn.Location) < VSize(ClosestKFAIC.Pawn.Location - Outer.Pawn.Location))
                    {
                        ClosestKFAIC = KFAIC;
                    }
                }
                continue;
            }
            if(Outer.IsAimingAt(KFAIC.Pawn, 0.8))
            {
                ClosestKFAIC = KFAIC;
                break;
            }
        }        
    }    
    if(ClosestKFAIC == none)
    {
        Outer.ClientMessage(string(inFunctionName) $ " : You need to be aiming at a valid NPC to do this.", CheatType);
    }
    return ClosestKFAIC;
}

exec function AIDebugTurnInPlace(optional bool bEnableMelee)
{
    local KFAIController KFAIC;

    bEnableMelee = false;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.DoDebugTurnInPlace(KFPlayerController(Outer), bEnableMelee);        
    }    
}

exec function AIToggleTurnInPlace()
{
    local KFAIController KFAIC;

    KFAIC = GetDebugAIController();
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.bDisableTurnInPlace = !KFAIC.MyKFPawn.bDisableTurnInPlace;
    }
    if(KFAIC.MyKFPawn.bDisableTurnInPlace)
    {
        Outer.ClientMessage(string(KFAIC.Pawn) $ " TurnInPlace disabled", CheatType);        
    }
    else
    {
        Outer.ClientMessage(string(KFAIC.Pawn) $ " TurnInPlace enabled", CheatType);
    }
}

exec function ToggleKFDebugLines()
{
    KFDL();
}

exec function KFDL()
{
    local KFGameEngine KFGEngine;

    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        Class'KFGameEngine'.default.bEnableAdvDebugLines = !Class'KFGameEngine'.default.bEnableAdvDebugLines;
        Outer.ClientMessage("KFDebugLines on: " $ string(Class'KFGameEngine'.default.bEnableAdvDebugLines), CheatType);
    }
}

exec function ClearDebugLines()
{
    local KFDebugLines KFDL;

    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        KFDL.ClearAll();
    }
}

exec function AIShowDropDowns(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFWallPathNode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFWallPathNode', NP)
        {
            if(bOn)
            {
                if(NP.DropDownNode != none)
                {
                    I = 0;
                    J0xA7:

                    if(I < NP.PathList.Length)
                    {
                        if((KFPathnode(NP.PathList[I].End.Actor) == NP.DropDownNode) && NP.PathList[I].IsA('WallToFloorReachSpec'))
                        {
                            KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                            if(WallToFloorReachSpec(NP.PathList[I]).bJumpDownTo)
                            {
                                KFDL.AddDebugLine(NP.Location, NP.DropDownNode.Location, 0, 200, 0, true, 220, NP.Name, I);                                
                            }
                            else
                            {
                                KFDL.AddDebugLine(NP.Location, NP.DropDownNode.Location, 255, 255, 0, true, 220, NP.Name, I);
                            }
                        }
                        ++ I;
                        goto J0xA7;
                    }
                }
                continue;
            }
            KFDL.RemoveOwnedDebugLines(NP.Name, 0);
            KFDL.RemoveOwnedDebugSpheres(NP.Name, 0);            
        }        
    }
}

exec function AIShowFloorToWallNodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if(NP.bWallNode)
            {
                continue;                
            }
            if(bOn)
            {
                I = 0;
                J0xA9:

                if(I < NP.PathList.Length)
                {
                    if(NP.PathList[I].IsA('FloorToWallReachSpec'))
                    {
                        KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                        KFDL.AddDebugLine(NP.Location, NP.PathList[I].End.Actor.Location, 100, 200, 150, true, 220, NP.Name, I);
                    }
                    ++ I;
                    goto J0xA9;
                }
                continue;
            }
            I = 0;
            J0x27B:

            if(I < NP.PathList.Length)
            {
                KFDL.RemoveOwnedDebugLines(NP.Name, I);
                KFDL.RemoveOwnedDebugSpheres(NP.Name, I);
                ++ I;
                goto J0x27B;
            }            
        }        
    }
}

exec function AIShowForcedSpecs(optional bool bOn)
{
    local KFDebugLines KFDL;
    local KFPathnode NP;
    local int I;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    if(KFDL != none)
    {
        foreach Outer.AllActors(Class'KFPathnode', NP)
        {
            if(NP.bWallNode)
            {
                continue;                
            }
            if(bOn)
            {
                I = 0;
                J0xA9:

                if(I < NP.PathList.Length)
                {
                    if(NP.PathList[I].IsA('KFForcedReachSpec'))
                    {
                        KFDL.AddDebugSphere(NP.Location, 24, 8, 0, 255, 0, true, 250, NP.Name, 0);
                        KFDL.AddDebugLine(NP.Location, NP.PathList[I].End.Actor.Location, 100, 200, 150, true, 220, NP.Name, I);
                    }
                    ++ I;
                    goto J0xA9;
                }
                continue;
            }
            I = 0;
            J0x27B:

            if(I < NP.PathList.Length)
            {
                KFDL.RemoveOwnedDebugLines(NP.Name, I);
                KFDL.RemoveOwnedDebugSpheres(NP.Name, I);
                ++ I;
                goto J0x27B;
            }            
        }        
    }
}

exec function AIShowLitNodes()
{
    local NavigationPoint NP;
    local float ColorScale, TempFloat;

    Outer.FlushPersistentDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        TempFloat = ((NP.Intensity.R + NP.Intensity.G) + NP.Intensity.B) / 3;
        ColorScale = float(Clamp(int(TempFloat * 255), 30, 255));
        Outer.DrawDebugSphere(NP.Location, 32, 8, byte(ColorScale), byte(ColorScale), 0, true);        
    }    
}

exec function AIPlayTaunt(byte TauntType)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(Outer.IsAimingAt(KFAIC.Pawn, 0.88))
        {
            Class'AICommand_TauntEnemy'.static.Taunt(KFAIC, KFPawn(Outer.Pawn), TauntType);
        }        
    }    
}

exec function DebugNextPhase()
{
    local KFAIController_ZedBoss KFAICB;

    foreach Outer.AllActors(Class'KFAIController_ZedBoss', KFAICB)
    {
        KFAICB.DebugNextPhase();        
    }    
}

exec function HansNextPhase()
{
    DebugNextPhase();
}

exec function HansGas()
{
    local KFPawn_ZedHansBase HansPawn;

    foreach Outer.AllActors(Class'KFPawn_ZedHansBase', HansPawn)
    {
        HansPawn.ANIMNOTIFY_AoENerveGas();        
    }    
}

exec function AISummonZeds(int BattlePhase, int DifficultyIndex)
{
    local KFAIController KFAIC;
    local KFInterface_MonsterBoss BossRef;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        BossRef = KFInterface_MonsterBoss(KFAIC.MyKFPawn);
        if(EqualEqual_InterfaceInterface(BossRef, (none)))
        {            
            return;
        }
        Class'AICommand_SummonZeds'.static.Summon(KFAIC, BossRef.GetWaveInfo(BattlePhase, DifficultyIndex), BossRef.GetNumMinionsToSpawn());        
    }    
}

exec function ShowBlockedPathnodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local int I;
    local NavigationPoint NP;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        if(bOn && NP.bBlocked)
        {
            ++ I;
            KFDL.AddDebugSphere(NP.Location, 24, 12, 0, 255, 0, true,, NP.Name, I);
            continue;
        }
        KFDL.RemoveOwnedDebugSpheres(NP.Name);        
    }    
}

exec function ShowPathnodes(optional bool bOn)
{
    local KFDebugLines KFDL;
    local int I;
    local NavigationPoint NP;

    bOn = true;
    KFDL = Class'KFDebugLines'.static.GetDebugLines();
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        if(bOn)
        {
            ++ I;
            KFDL.AddDebugSphere(NP.Location, 24, 12, 0, 255, 0, true,, NP.Name, I);
            continue;
        }
        KFDL.RemoveOwnedDebugSpheres(NP.Name);        
    }    
}

exec function AIMoveToMeAsEnemy()
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.IsInDebugMode())
        {
            KFAIC.bIsProbingMeleeRangeEvents = false;
            KFAIC.SetEnemy(Outer.Pawn);
            KFAIC.Enemy = Outer.Pawn;
            AICommand_Debug(KFAIC.GetActiveCommand()).LastDebugGoal = KFAIC.Enemy;
            KFAIC.SetEnemyMoveGoal(none, true,,, false);
        }        
    }    
}

exec function AIEnableMeleeEvents()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.EnableMeleeRangeEventProbing();
}

exec function AIDisableMeleeEvents()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim();
    KFAIC.DisableMeleeRangeEventProbing();
}

exec function AIPathTo(name DebugGoalName, optional float OffsetDistance, optional bool bMarkGoalLocation)
{
    local KFPathnode CheckNode;
    local Actor DebugGoal;
    local KFAIController KFAIC;
    local KFPawn KFP;

    OffsetDistance = 0;    
    if(DebugGoalName == 'None')
    {
        Outer.ClientMessage("Use the Tag property in KFPathNodes, and specify that name to have AI path to a specific node. Exampe: AIPathTo TestGoal.  PLAYER is also a valid argument.", CheatType);
        return;
    }
    if(DebugGoalName != 'Player')
    {
        foreach Outer.WorldInfo.AllNavigationPoints(Class'KFPathnode', CheckNode)
        {
            if(CheckNode.DebugTag == DebugGoalName)
            {
                DebugGoal = CheckNode;
                break;
            }            
        }                
    }
    else
    {
        DebugGoal = Outer.GetALocalPlayerController().Pawn;
    }
    if(DebugGoal == none)
    {
        foreach Outer.AllActors(Class'KFPawn', KFP)
        {
            if((KFP.Controller == none) || !KFP.Controller.IsA('KFAIController'))
            {
                DebugGoal = KFP;
                break;
            }            
        }        
        if(DebugGoal == none)
        {
            Outer.ClientMessage(("Cannot find a valid goal for '" $ string(DebugGoalName)) $ ".", CheatType);
            return;
        }
    }
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.IsInDebugMode())
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).LastDebugGoal = DebugGoal;
            Outer.ClientMessage((((string(KFAIC.Pawn) $ " Moving to ") $ string(DebugGoal)) $ " with an offset distance of ") $ string(OffsetDistance), CheatType);
        }        
    }    
    if(bMarkGoalLocation)
    {
        Outer.ClientMessage("Type 'FlushPersistentDebugLines' to remove the debug sphere at goal location", CheatType);
        Outer.DrawDebugSphere(DebugGoal.Location, 32, 8, 189, 183, 107, true);
    }
}

exec function AIDebugCrawler()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if((KFAIC == none) || !KFAIC.IsA('KFAIController_ZedCrawler'))
    {
        Outer.ClientMessage("You must be aiming at a debug-mode NPC!");
        return;
    }
    KFAIC.Pawn.bDebugCrawlerPhysics = !KFAIC.Pawn.bDebugCrawlerPhysics;
    Outer.ClientMessage((("DebugCrawler is now " $ string(KFAIC.Pawn.bDebugCrawlerPhysics)) $ " for ") $ string(KFAIC.Pawn), CheatType);
    if(KFAIC.Pawn.bDebugCrawlerPhysics)
    {
        Outer.ClientMessage(("Warning - PlayersOnly will be activated throughout " $ string(KFAIC.Pawn)) $ "'s moves.", CheatType, 13);
    }
}

exec function AITestCrawler()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(true);
    if(KFAIC == none)
    {
        Outer.ClientMessage("You must be aiming at a debug-mode NPC!", CheatType);
    }
    if(!KFAIC.bHasDebugCommand)
    {
        Outer.ClientMessage(string(KFAIC.MyKFPawn) $ " must have a controller in debug mode first!", CheatType);
    }
    AICommand_Debug(KFAIC.GetActiveCommand()).Debug_DebugNodes();
}

exec function AITestCrawlers()
{
    local KFAIController_ZedCrawler KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_ZedCrawler', KFAIC)
    {
        if(KFAIC.bHasDebugCommand)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).Debug_DebugNodes();
        }        
    }    
}

exec function AITestCrawlerAttack()
{
    local KFAIController_ZedCrawler KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_ZedCrawler', KFAIC)
    {
        if(KFAIC.bHasDebugCommand)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).Debug_CrawlerAttack();
        }        
    }    
}

exec function AITestGrab()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(false, 0.9);
    if(KFAIC != none)
    {
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = true;
        }
        KFAIC.DoGrabAttack(Outer.Pawn, 5);
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = false;
        }
    }
}

exec function AIHansTestGrenadeTrajectory(optional float Speed, optional float ZPct)
{
    local KFAIController_Hans KFAIC;
    local Vector EstimatedStartThrowLocation, TossVelocity;

    Speed = 2500;
    ZPct = 0.45;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_Hans', KFAIC)
    {
        if(KFAIC != none)
        {
            EstimatedStartThrowLocation = KFAIC.Pawn.GetPawnViewLocation() + (vect(15, 32, -12) >> KFAIC.Pawn.GetViewRotation());
            if(!KFAIC.Pawn.SuggestTossVelocity(TossVelocity, GetMyPawn().Location, EstimatedStartThrowLocation, Speed,, ZPct))
            {
                Outer.ClientMessage((((((("FAIL for Speed:" $ string(Speed)) $ " ZPCt:") $ string(ZPct)) $ " 2DDist: ") $ string(VSize2D(KFAIC.Pawn.Location - GetMyPawn().Location))) $ " ZDiff:") $ string(Abs(KFAIC.Pawn.Location.Z - GetMyPawn().Location.Z)), CheatType);
                continue;
            }
            Outer.ClientMessage((((((("SUCCESS for Speed:" $ string(Speed)) $ " ZPCt:") $ string(ZPct)) $ " 2DDist: ") $ string(VSize2D(KFAIC.Pawn.Location - GetMyPawn().Location))) $ " ZDiff:") $ string(Abs(KFAIC.Pawn.Location.Z - GetMyPawn().Location.Z)), CheatType);
        }        
    }    
}

exec function AIHansGrenade(optional bool bGrenadeBarrage)
{
    local KFAIController_Hans KFAIC;

    KFAIC = KFAIController_Hans(GetKFAICFromAim(false, 0.9));
    if(KFAIC != none)
    {
        KFAIC.Enemy = GetMyPawn();
        KFAIC.DoGrenadeThrow(bGrenadeBarrage);
    }
}

exec function AITestHansGrab()
{
    local KFAIController_Hans KFAIC;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController_Hans', KFAIC)
    {
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = true;
        }
        KFAIC.DoGrabAttack(Outer.Pawn, 5);
        if(AICommand_Debug(KFAIC.GetActiveCommand()) != none)
        {
            AICommand_Debug(KFAIC.GetActiveCommand()).bAllowedToAttack = false;
        }        
    }    
}

exec function AISetDebugColor(byte R, byte G, byte B)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride = MakeColor(R, G, B, 255);        
    }    
}

exec function AISetDebugColorR(byte R)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.R = R;        
    }    
}

exec function AISetDebugColorG(byte G)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.G = G;        
    }    
}

exec function AISetDebugColorB(byte B)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.B = B;        
    }    
}

exec function AISetDebugColorA(byte A)
{
    local KFAIController KFAIC;

    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        KFAIC.Debug_TextColorOverride.A = A;        
    }    
}

exec function AIDebugEnemy()
{
    GetDebugAICommand().Debug_Enemy(Outer.Pawn);
}

exec function DumpReachSpecs()
{
    local int I, Count;
    local NavigationPoint Nav, StartNav, EndNav;
    local float Length, TotalDist;

    foreach Outer.WorldInfo.AllNavigationPoints(Class'NavigationPoint', Nav)
    {
        LogInternal("--------------------------------------------------------------------------------");
        LogInternal("Checking Nav: " $ string(Nav));
        I = 0;
        J0xC9:

        if(I < Nav.PathList.Length)
        {
            StartNav = Nav;
            EndNav = Nav.PathList[I].GetEnd();
            if(!Nav.PathList[I].IsA('ProscribedReachSpec'))
            {
                ++ Count;
                if((StartNav != none) && EndNav != none)
                {
                    Length = VSize(EndNav.Location - Nav.Location);
                    LogInternal(((((("		" $ string(Nav.PathList[I])) $ " connected to ") $ string(EndNav)) $ " ") $ string(Length)) $ " length");
                    TotalDist += Length;
                }
            }
            ++ I;
            goto J0xC9;
        }        
    }    
    LogInternal("Avg Dist: " $ string(TotalDist / float(Count)));
}

exec function KillOtherZeds()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        if((AIP.Health > 0) && !Outer.IsAimingAt(AIP, 0.98))
        {
            AIP.TakeDamage(20000, Outer, AIP.Location, vect(0, 0, 0), Class'KFDamageType');
        }        
    }    
}

exec function KillZeds(optional float KillDistance, optional bool LogKilledZedInfo)
{
    local PlayerController KFPC;
    local DebugCameraController DCC;
    local KFPawn_Monster AIP;
    local Pawn MyPawn;

    KillDistance = 0;
    LogKilledZedInfo = true;
    KFPC = Outer;
    if(KFPC != none)
    {
        DumpInfoForAI();
        foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
        {
            if(!AIP.IsAliveAndWell())
            {
                continue;                
            }
            if(KillDistance > 0)
            {
                if(Outer.Pawn != none)
                {
                    MyPawn = Outer.Pawn;                    
                }
                else
                {
                    if(DebugCameraController(KFPC) != none)
                    {
                        DCC = DebugCameraController(KFPC);
                        if(((DCC != none) && DCC.OriginalControllerRef != none) && DCC.OriginalControllerRef.Pawn != none)
                        {
                            MyPawn = DCC.OriginalControllerRef.Pawn;
                        }
                    }
                }
                if((MyPawn != none) && VSizeSq(AIP.Location - MyPawn.Location) > (KillDistance * KillDistance))
                {
                    LogInternal(((((string(self) $ " Not killing ") $ string(AIP)) $ " who is ") $ string(VSize(AIP.Location - MyPawn.Location))) $ " units away");
                    continue;                    
                }
            }
            if(AIP.Health > 0)
            {
                if(PlayerController(AIP.Controller) == none)
                {
                    AIP.Died(none, none, AIP.Location);
                }
            }            
        }        
    }
}

exec function AIRage()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(((P.IsAliveAndWell() && P.IsA('KFPawn_ZedFleshpound')) && !P.IsEnraged()) && Outer.IsAimingAt(P, 0.95))
        {
            P.MyKFAIC.SetEnemy(Outer.Pawn);
            P.SetEnraged(true);
        }        
    }    
}

exec function ShowCrawlerPath(optional bool bAllowPartial, optional int OverrideFloorCostMin, optional int OverrideFloorCostMax)
{
    local KFPawn_Monster KFPM;
    local Actor Result;
    local KFGameEngine KFGEngine;
    local KFDebugLines KFDL;

    bAllowPartial = false;        
    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        Class'KFGameEngine'.default.bEnableAdvDebugLines = true;
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if((((KFPM.Health > 0) && KFPM.bCrawler) && KFPM.MyKFAIC != none) && KFPM.MyKFAIC.bHasDebugCommand)
        {
            KFPM.MyKFAIC.RouteCache.Length = 0;
            if((OverrideFloorCostMin > 0) && OverrideFloorCostMax > 0)
            {
                KFAIController_ZedCrawler(KFPM.MyKFAIC).MinExtraCostForFloorNodes = OverrideFloorCostMin;
                KFAIController_ZedCrawler(KFPM.MyKFAIC).MaxExtraCostForFloorNodes = OverrideFloorCostMax;
            }
            KFDL = Class'KFDebugLines'.static.GetDebugLines();
            Result = KFPM.MyKFAIC.GeneratePathTo(GetMyPawn(),, bAllowPartial);
            if(Result == none)
            {
                Outer.ClientMessage(string(KFPM) $ " failed to build path", CheatType);
            }
            KFDL.ClearAll();
            KFPM.MyKFAIC.KFDebug_DrawMyPath();
        }        
    }    
}

exec function AIDebugLOS()
{
    local KFPawn_Monster KFPM;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM)
    {
        if(KFPM.MyKFAIC.bHasDebugCommand && KFPM.IsAliveAndWell())
        {
            AICommand_Debug(KFPM.MyKFAIC.GetActiveCommand()).Debug_LOS();
        }        
    }    
}

exec function DumpAICommands()
{
    local KFAIController AI;

    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', AI)
    {
        AI.DumpCommandStack();        
    }    
}

exec function TestSpecDist(optional bool bOnlyPathNodes)
{
    local NavigationPoint NP, StartNav, EndNav;
    local int I;
    local array<float> Distances;
    local float Total;

    bOnlyPathNodes = false;
    foreach Outer.AllActors(Class'NavigationPoint', NP)
    {
        I = 0;
        J0x3E:

        if(I < NP.PathList.Length)
        {
            StartNav = NP.PathList[I].Start;
            EndNav = NP.PathList[I].GetEnd();
            if((StartNav != none) && EndNav != none)
            {
                if(bOnlyPathNodes)
                {
                    if((StartNav.Class != Class'PathNode') || EndNav.Class != Class'PathNode')
                    {
                        goto J0x23A;
                    }
                }
                Distances.AddItem(VSize(NP.PathList[I].Start.Location - NP.PathList[I].GetEnd().Location);
            }
            J0x23A:

            ++ I;
            goto J0x3E;
        }        
    }    
    I = 0;
    J0x255:

    if(I < Distances.Length)
    {
        LogInternal((("DISTANCES[" $ string(I)) $ "] : ") $ string(Distances[I]));
        Total += Distances[I];
        ++ I;
        goto J0x255;
    }
    LogInternal((((("TOTAL: " $ string(Total)) $ " LENGTH: ") $ string(Distances.Length)) $ " AVG: ") $ string(Total / float(Distances.Length)));
}

simulated exec function BigHeadMode()
{
    local Pawn P;
    local KFPawn KFPawn;

    P = Outer.WorldInfo.PawnList;
    J0x3D:

    if(P != none)
    {
        KFPawn = KFPawn(P);
        if(KFPawn != none)
        {
            KFPawn.SetHeadScale(3, KFPawn.CurrentHeadScale);
        }
        P = P.NextPawn;
        goto J0x3D;
    }
}

simulated exec function BigZedMode(optional float Scale, optional bool bScaleCollision)
{
    local Pawn P;
    local KFPawn_Monster Zed;

    Scale = 2;    
    P = Outer.WorldInfo.PawnList;
    J0x47:

    if(P != none)
    {
        Zed = KFPawn_Monster(P);
        if(Zed != none)
        {
            Zed.SetDrawScale(Scale);
            if(bScaleCollision)
            {
                Zed.SetCollisionSize(Zed.CylinderComponent.default.CollisionRadius * Scale, Zed.CylinderComponent.default.CollisionHeight * Scale);
            }
        }
        P = P.NextPawn;
        goto J0x47;
    }
}

simulated exec function AISetInUseCost(optional float NewCost)
{
    local KFAIController KFAIC;

    NewCost = 10;
    foreach Outer.AllActors(Class'KFAIController', KFAIC)
    {
        if(KFAIC.InUseNodeCostMultiplier == float(0))
        {
            KFAIC.InUseNodeCostMultiplier = 10;            
        }
        else
        {
            KFAIC.InUseNodeCostMultiplier = 0;
        }
        Outer.ClientMessage((string(KFAIC.Pawn) $ " InUseNodeCostMultiplier is now ") $ string(KFAIC.InUseNodeCostMultiplier), CheatType);        
    }    
}

simulated exec function AILookAtMe(bool bEnabled)
{
    local Pawn P;
    local KFPawn_Monster KFP;

    P = Outer.WorldInfo.PawnList;
    J0x3D:

    if(P != none)
    {
        KFP = KFPawn_Monster(P);
        if(((KFP != none) && KFP.bCanHeadTrack) && Outer.IsAimingAt(KFP, 0.88))
        {
            if(bEnabled)
            {
                KFP.IK_Look_Head = SkelControlLookAt(KFP.Mesh.FindSkelControl('HeadLook'));
                KFP.bIsHeadTrackingActive = true;
                KFP.SetHeadTrackTarget(Outer.Pawn, vect(0, 0, 0), 1, false);                
            }
            else
            {
                KFP.ClearHeadTrackTarget(KFP.MyLookAtInfo.LookAtTarget, 0.5);
                KFP.bIsHeadTrackingActive = false;
            }
        }
        P = P.NextPawn;
        goto J0x3D;
    }
}

exec function InjureZedArm()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.RagdollArm(false);        
    }    
}

exec function CrippleZeds()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.CauseHeadTrauma(AIP.HeadlessBleedOutTime);        
    }    
}

exec function CrippleZed()
{
    local KFPawn_Monster AIP;

    AIP = GetKFMPFromAim();
    if(AIP != none)
    {
        AIP.CauseHeadTrauma(AIP.HeadlessBleedOutTime);
    }
}

exec function EnableLivingGore()
{
    local KFPawn_Monster AIP;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        AIP.InitPartialKinematics();        
    }    
}

exec function PlayRandomStumble()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackRandomSMFlags(P));        
    }    
}

exec function PlayTaunt()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.WalkBlendList.QueueTauntWalk();        
    }    
}

exec function PlayKnockdown(optional Vector LinearVelocity)
{
    local KFPawn_Monster P;

    LinearVelocity = vect(0, 0, 0);
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        P.Knockdown(LinearVelocity, vect(1, 1, 1), Outer.Pawn.Location, 1000, 100);        
    }    
}

exec function PlayStunned()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell())
        {
            P.DoSpecialMove(8);
        }        
    }    
}

exec function EMPWander(bool bEnable)
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.IsAliveAndWell() && P.MyKFAIC != none)
        {
            if(bEnable)
            {
                P.CausePanicWander();
                P.AfflictionHandler.ToggleEffects(0, true, false);
                continue;
            }
            P.EndPanicWander();
            P.AfflictionHandler.ToggleEffects(0, false, false);
        }        
    }    
}

exec function EMPValTest(float EMPValue)
{
    local KFPawn P;
    local MaterialInstanceConstant MIC;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn', P)
    {
        if(P.IsAliveAndWell())
        {
            foreach P.CharacterMICs(MIC,)
            {
                MIC.SetScalarParameterValue('Scalar_EMP', EMPValue);                
            }            
        }        
    }    
}

exec function BurnValTest(float BurnValue)
{
    local KFPawn P;
    local MaterialInstanceConstant MIC;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn', P)
    {
        if(P.IsAliveAndWell())
        {
            foreach P.CharacterMICs(MIC,)
            {
                MIC.SetScalarParameterValue('Scalar_Burnt', BurnValue);                
            }            
        }        
    }    
}

simulated exec function SpawnAI(string ZedName, optional float Distance, optional name SpawnAtTag)
{
    local KFPawn Zed;

    Distance = 500;    
    Zed = SpawnAIZed(ZedName, Distance, SpawnAtTag);
    if(Zed != none)
    {
        Zed.SpawnDefaultController();
        if(KFAIController(Zed.Controller) != none)
        {
            KFAIController(Zed.Controller).SetTeam(1);
        }
    }
}

exec function SpawnAIV(string ZedName, optional float Distance)
{
    local class<KFPawn_Monster> MonsterClass;
    local Vector SpawnLoc;
    local Rotator SpawnRot;
    local KFAIController KFAIC;
    local KFPawn KFP;

    Distance = 500;
    if(!Outer.WorldInfo.Game.IsA('KFGameInfo_VersusSurvival'))
    {
        Outer.ClientMessage("This cheat command is only valid in Versus Survival mode!", CheatType);
        return;
    }
    MonsterClass = LoadMonsterByName(ZedName, true);
    if(MonsterClass != none)
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
        SpawnLoc += ((Distance * vector(Outer.Rotation)) + (vect(0, 0, 1) * 15));
        SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
        KFP = Outer.Spawn(MonsterClass,,, SpawnLoc, SpawnRot,, false);
        if(KFP != none)
        {
            KFP.SetPhysics(2);
            if(KFP.ControllerClass != none)
            {
                KFAIC = KFAIController(KFP.Spawn(KFP.ControllerClass));
                if(KFAIC != none)
                {
                    KFAIC.bIsSimulatedPlayerController = true;
                    KFAIC.SetTeam(1);
                    KFAIC.Possess(KFP, false);
                }
                return;
            }
        }
    }
    Outer.ClientMessage((" Could not spawn AI Versus ZED [" $ ZedName) $ "]. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
}

simulated exec function SpawnDebugAI(string ZedName, optional float Distance, optional name SpawnAtTag, optional bool bShowDebugTxt)
{
    local KFPawn Zed;

    Distance = 200;    
    bShowDebugTxt = false;
    Zed = SpawnAIZed(ZedName, Distance, SpawnAtTag);
    if(Zed != none)
    {
        Zed.SpawnDefaultController();
        if(Zed.Controller != none)
        {
            if(bShowDebugTxt)
            {
                KFPawn_Monster(Zed).SetDebugTextRendering(true);
                SetNPCDebugCategory(true, 'All');
            }
            KFAIController(Zed.Controller).BeginDebugCommand();
            KFAIController(Zed.Controller).DefaultCommandClass = Class'AICommand_Debug';
            KFAIController(Zed.Controller).MeleeCommandClass = Class'AICommand_Debug';
        }
    }
}

simulated exec function AIShowAttackAnims(optional bool bSetEnemyForDebugModeAI)
{
    local KFAIController KFAIC;

    bSetEnemyForDebugModeAI = true;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if((KFAIC.Pawn != none) && KFAIC.Pawn.IsAliveAndWell())
        {
            if(Outer.IsAimingAt(KFAIC.Pawn, 0.95))
            {
                if(bSetEnemyForDebugModeAI)
                {
                    KFAIC.SetEnemy(Outer.Pawn);
                }
                if(KFAIC.bDebug_DrawAttackAnimInfo)
                {
                    KFAIC.bDebug_DrawAttackAnimInfo = false;
                    Outer.ClientMessage("Turning off attack animation info for " $ string(KFAIC.Pawn), CheatType);                    
                    return;
                    continue;
                }
                KFAIC.bDebug_DrawAttackAnimInfo = true;
                KFAIC.SetPostRendering(true);
                KFAIC.bDebug_PostRenderInfo = true;
                Outer.ClientMessage("Now showing attack animation info for " $ string(KFAIC.Pawn), CheatType);                
                return;
            }
        }        
    }    
    Outer.ClientMessage("You need to be aiming at an NPC first!", CheatType);
}

simulated function KFPawn SpawnAIZed(string ZedName, float Distance, optional name SpawnAtTag)
{
    local KFPawn Zed;

    Zed = SpawnZed(ZedName, Distance,, SpawnAtTag);
    LogInternal((string(GetFuncName()) $ "() Spawned: ") $ string(Zed));
    return Zed;
}

exec function SpawnZedVC(string ZedName)
{
    local KFPlayerController KFPC;
    local class<KFPawn_Monster> MonsterClass;
    local Vector SpawnLoc;
    local Rotator SpawnRot;
    local KFPawn KFP;

    if(!Outer.WorldInfo.Game.IsA('KFGameInfo_VersusSurvival'))
    {
        Outer.ClientMessage("This cheat command is only valid in Versus Survival mode!", CheatType);
        return;
    }
    MonsterClass = LoadMonsterByName(ZedName, true);
    if(MonsterClass != none)
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
        SpawnLoc += ((200 * vector(Outer.Rotation)) + (vect(0, 0, 1) * 15));
        SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
        KFP = Outer.Spawn(MonsterClass,,, SpawnLoc, SpawnRot,, false);
        if(KFP != none)
        {
            KFPC = Outer.Spawn(Class'KFPlayerController');
            Outer.WorldInfo.Game.ChangeName(KFPC, "Braindead Human", false);
            KFPC.Possess(KFP, false);
            KFP.SetPhysics(2);            
        }
        else
        {
            Outer.ClientMessage((" Could not spawn Versus ZED [" $ ZedName) $ "] with a PC. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
        }
    }
}

exec function SpawnZedV(string ZedName, optional bool bPossess)
{
    local class<KFPawn_Monster> MonsterClass;
    local Vector SpawnLoc;
    local Rotator SpawnRot;
    local KFPawn KFP;

    bPossess = true;
    if(!Outer.WorldInfo.Game.IsA('KFGameInfo_VersusSurvival'))
    {
        Outer.ClientMessage("This cheat command is only valid in Versus Survival mode!", CheatType);
        return;
    }
    MonsterClass = LoadMonsterByName(ZedName, true);
    if(MonsterClass != none)
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
        SpawnLoc += ((200 * vector(Outer.Rotation)) + (vect(0, 0, 1) * 15));
        SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
        KFP = Outer.Spawn(MonsterClass,,, SpawnLoc, SpawnRot,, false);
        if(KFP != none)
        {
            if(bPossess)
            {
                if(Outer.Pawn != none)
                {
                    Outer.Pawn.Destroy();
                }
                if(KFP.Controller != none)
                {
                    KFP.Controller.Destroy();
                }
                KFGameInfo(Outer.WorldInfo.Game).SetTeam(KFPlayerController(Outer), KFGameInfo(Outer.WorldInfo.Game).Teams[1]);
                Outer.Possess(KFP, false);
                Outer.ServerCamera('ThirdPerson');
            }
            KFP.SetPhysics(2);            
        }
        else
        {
            Outer.ClientMessage((" Could not spawn Versus ZED [" $ ZedName) $ "]. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
        }
    }
}

exec function GoHumanV()
{
    local class<KFPawn_Human> HumanClass;
    local KFPawn_Human KFPH;
    local Vector SpawnLoc;
    local Rotator SpawnRot;

    if(!Outer.WorldInfo.Game.IsA('KFGameInfo_VersusSurvival'))
    {
        Outer.ClientMessage("This cheat command is only valid in Versus Survival mode!", CheatType);
        return;
    }
    if(Outer.Pawn != none)
    {
        SpawnLoc = Outer.Pawn.Location;
        Outer.Pawn.Destroy();        
    }
    else
    {
        SpawnLoc = Outer.Location;
    }
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    HumanClass = class<KFPawn_Human>(DynamicLoadObject("KFGameContent.KFPawn_Human_Versus", Class'Class'));
    KFPH = Outer.Spawn(HumanClass,,, SpawnLoc, SpawnRot,, false);
    if(KFPH != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).SetTeam(KFPlayerController(Outer), KFGameInfo(Outer.WorldInfo.Game).Teams[0]);
        KFPH.AddDefaultInventory();
        Outer.Possess(KFPH, false);
        Outer.ServerCamera('FirstPerson');
        KFPH.SetPhysics(2);        
    }
    else
    {
        Outer.ClientMessage("Could not spawn Versus Human.", CheatType);
    }
}

exec function SetBossNum(int PosInBossArray)
{
    Outer.ConsoleCommand("SETNOPEC KFAISpawnManager ForcedBossNum" @ string(PosInBossArray));
}

function class<KFPawn_Monster> LoadMonsterByName(string ZedName, optional bool bIsVersusPawn)
{
    local string VersusSuffix;
    local class<KFPawn_Monster> SpawnClass;

    VersusSuffix = ((bIsVersusPawn) ? "_Versus" : "");
    if(Left(ZedName, 5) ~= "ClotA")
    {
        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Alpha" $ VersusSuffix, Class'Class'));        
    }
    else
    {
        if(Left(ZedName, 4) ~= "EAlp")
        {
            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_AlphaKing" $ VersusSuffix, Class'Class'));            
        }
        else
        {
            if(Left(ZedName, 4) ~= "ECra")
            {
                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedCrawlerKing" $ VersusSuffix, Class'Class'));                
            }
            else
            {
                if(Left(ZedName, 5) ~= "ClotS")
                {
                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Slasher" $ VersusSuffix, Class'Class'));                    
                }
                else
                {
                    if(Left(ZedName, 5) ~= "ClotC")
                    {
                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Cyst" $ VersusSuffix, Class'Class'));                        
                    }
                    else
                    {
                        if(ZedName ~= "CLOT")
                        {
                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedClot_Cyst" $ VersusSuffix, Class'Class'));                            
                        }
                        else
                        {
                            if(Left(ZedName, 3) ~= "FHa")
                            {
                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHansFriendlyTest" $ VersusSuffix, Class'Class'));                                
                            }
                            else
                            {
                                if(Left(ZedName, 3) ~= "FHu")
                                {
                                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHuskFriendlyTest" $ VersusSuffix, Class'Class'));                                    
                                }
                                else
                                {
                                    if(Left(ZedName, 5) ~= "KingF")
                                    {
                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedFleshpoundKing" $ VersusSuffix, Class'Class'));                                        
                                    }
                                    else
                                    {
                                        if(Left(ZedName, 5) ~= "MiniF")
                                        {
                                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedFleshpoundMini" $ VersusSuffix, Class'Class'));                                            
                                        }
                                        else
                                        {
                                            if(Left(ZedName, 1) ~= "F")
                                            {
                                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedFleshpound" $ VersusSuffix, Class'Class'));                                                
                                            }
                                            else
                                            {
                                                if(Left(ZedName, 3) ~= "GF2")
                                                {
                                                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedGorefastDualBlade" $ VersusSuffix, Class'Class'));                                                    
                                                }
                                                else
                                                {
                                                    if(Left(ZedName, 1) ~= "G")
                                                    {
                                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedGorefast" $ VersusSuffix, Class'Class'));                                                        
                                                    }
                                                    else
                                                    {
                                                        if(Left(ZedName, 2) ~= "St")
                                                        {
                                                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedStalker" $ VersusSuffix, Class'Class'));                                                            
                                                        }
                                                        else
                                                        {
                                                            if(Left(ZedName, 1) ~= "B")
                                                            {
                                                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat" $ VersusSuffix, Class'Class'));                                                                
                                                            }
                                                            else
                                                            {
                                                                if(Left(ZedName, 5) ~= "KingB")
                                                                {
                                                                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloatKing" $ VersusSuffix, Class'Class'));                                                                    
                                                                }
                                                                else
                                                                {
                                                                    if(Left(ZedName, 4) ~= "Poop")
                                                                    {
                                                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloatKingSubspawn", Class'Class'));                                                                        
                                                                    }
                                                                    else
                                                                    {
                                                                        if(Left(ZedName, 2) ~= "Sc")
                                                                        {
                                                                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedScrake" $ VersusSuffix, Class'Class'));                                                                            
                                                                        }
                                                                        else
                                                                        {
                                                                            if(Left(ZedName, 2) ~= "Pa")
                                                                            {
                                                                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedPatriarch" $ VersusSuffix, Class'Class'));                                                                                
                                                                            }
                                                                            else
                                                                            {
                                                                                if(Left(ZedName, 2) ~= "Cr")
                                                                                {
                                                                                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedCrawler" $ VersusSuffix, Class'Class'));                                                                                    
                                                                                }
                                                                                else
                                                                                {
                                                                                    if(Left(ZedName, 2) ~= "Hu")
                                                                                    {
                                                                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHusk" $ VersusSuffix, Class'Class'));                                                                                        
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        if(Left(ZedName, 8) ~= "TestHusk")
                                                                                        {
                                                                                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHusk_New" $ VersusSuffix, Class'Class'));                                                                                            
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            if(Left(ZedName, 2) ~= "Ha")
                                                                                            {
                                                                                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedHans" $ VersusSuffix, Class'Class'));                                                                                                
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                if(Left(ZedName, 2) ~= "Si")
                                                                                                {
                                                                                                    return class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedSiren" $ VersusSuffix, Class'Class'));                                                                                                    
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                    if(Left(ZedName, 1) ~= "P")
                                                                                                    {
                                                                                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedPatriarch" $ VersusSuffix, Class'Class'));                                                                                                        
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                        if(Left(ZedName, 3) ~= "Emp")
                                                                                                        {
                                                                                                            SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedDAR_EMP" $ VersusSuffix, Class'Class'));                                                                                                            
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                            if(Left(ZedName, 5) ~= "Laser")
                                                                                                            {
                                                                                                                SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedDAR_Laser" $ VersusSuffix, Class'Class'));                                                                                                                
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                                if(Left(ZedName, 4) ~= "Rock")
                                                                                                                {
                                                                                                                    SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedDAR_Rocket" $ VersusSuffix, Class'Class'));                                                                                                                    
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                    if(Left(ZedName, 1) ~= "M")
                                                                                                                    {
                                                                                                                        SpawnClass = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedMatriarch" $ VersusSuffix, Class'Class'));
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if(SpawnClass != none)
    {
        SpawnClass = SpawnClass.static.GetAIPawnClassToSpawn();
    }
    if(SpawnClass == none)
    {
        Outer.ClientMessage(("Could not spawn ZED [" $ ZedName) $ "]. Please make sure you specified a valid ZED name (ClotA, ClotS, ClotC, etc.) and that the ZED has a valid archetype setup.", CheatType);
        return none;
    }
    return SpawnClass;
}

// Export UKFCheatManager::execGetAITypeByName(FFrame&, void* const)
native function int GetAITypeByName(string ZedName);

exec function SpawnHumanPawn(optional bool bEnemy, optional bool bUseGodMode, optional int CharIndex)
{
    local KFAIController KFBot;
    local KFPlayerReplicationInfo KFPRI;
    local Vector CamLoc;
    local Rotator CamRot;
    local KFPawn_Human KFPH;
    local Vector HitLocation, HitNormal;
    local Actor TraceOwner;

    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    if(Outer.Pawn != none)
    {
        TraceOwner = Outer.Pawn;        
    }
    else
    {
        TraceOwner = Outer;
    }
    TraceOwner.Trace(HitLocation, HitNormal, CamLoc + (vector(CamRot) * float(250000)), CamLoc, true, vect(0, 0, 0));
    HitLocation.Z += float(100);
    KFPH = Outer.Spawn(Class'KFPawn_Human',,, HitLocation);
    KFPH.SetPhysics(2);
    KFBot = Outer.Spawn(Class'KFAIController');
    Outer.WorldInfo.Game.ChangeName(KFBot, "Braindead Human", false);
    if(!bEnemy)
    {
        KFGameInfo(Outer.WorldInfo.Game).SetTeam(KFBot, KFGameInfo(Outer.WorldInfo.Game).Teams[0]);
    }
    KFBot.Possess(KFPH, false);
    if(bUseGodMode)
    {
        KFBot.bGodMode = true;
    }
    KFPRI = KFPlayerReplicationInfo(KFBot.PlayerReplicationInfo);
    KFPRI.CurrentPerkClass = Class'KFPlayerController'.default.PerkList[1].PerkClass;
    KFPRI.NetPerkIndex = 1;
    if(KFPRI != none)
    {
        KFPRI.PlayerHealthPercent = FloatToByte(float(KFPH.Health) / float(KFPH.HealthMax));
        KFPRI.PlayerHealth = byte(KFPH.Health);
    }
    KFPH.AddDefaultInventory();
}

exec function KillBots()
{
    local Controller P;

    foreach Outer.WorldInfo.AllControllers(Class'Controller', P)
    {
        if((KFAIController(P) != none) && KFAIController(P).bIsPlayer)
        {
            P.Pawn.KilledBy(P.Pawn);
            P.Destroy();
        }        
    }    
}

simulated exec function KFPawn SpawnZed(string ZedName, optional float Distance, optional bool bNoCollisionFail, optional name SpawnAtTag)
{
    local class<KFPawn> SpawnClass;
    local Vector SpawnLoc;
    local Rotator SpawnRot;
    local KFPawn KFP;
    local KFPathnode KFPN;

    Distance = 200;        
    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return none;
    }
    if(SpawnAtTag != 'None')
    {
        foreach Outer.WorldInfo.AllNavigationPoints(Class'KFPathnode', KFPN)
        {
            if(KFPN.DebugTag != 'None')
            {
                if(KFPN.DebugTag == SpawnAtTag)
                {
                    SpawnLoc = KFPN.Location;
                }
            }            
        }                
    }
    else
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
    }
    SpawnLoc += ((Distance * vector(Outer.Rotation)) + (vect(0, 0, 1) * float(15)));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot,, bNoCollisionFail);
    if(KFP != none)
    {
        if(KFPawn_Monster(KFP) != none)
        {
            KFPawn_Monster(KFP).bDebug_SpawnedThroughCheat = true;
        }
        KFP.SetPhysics(2);
        KFGameInfo(Outer.WorldInfo.Game).SetMonsterDefaults(KFPawn_Monster(KFP));
        if((KFP.Controller != none) && KFAIController(KFP.Controller) != none)
        {
            KFGameInfo(Outer.WorldInfo.Game).GetAIDirector().AIList.AddItem(KFAIController(KFP.Controller);
        }        
    }
    else
    {
        Outer.ClientMessage(("Could not spawn ZED [" $ ZedName) $ "]. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
    }
    return KFP;
}

simulated exec function SpawnZedAIGroup(string ZedName, int NumRows, int NumCols, optional float Spacing)
{
    local class<KFPawn> SpawnClass;
    local Vector StartLoc, SpawnLoc, RightDir, FaceDir;
    local Rotator SpawnRot;
    local KFPawn KFP;
    local int I, J;

    Spacing = 100;
    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return;
    }
    if(Outer.Pawn != none)
    {
        StartLoc = Outer.Pawn.Location;        
    }
    else
    {
        StartLoc = Outer.Location;
    }
    FaceDir = Normal(GetRotatorAxis(Outer.Rotation, 0));
    RightDir = Normal(GetRotatorAxis(Outer.Rotation, 1));
    I = 0;
    J0x139:

    if(I < NumRows)
    {
        J = 0;
        J0x15B:

        if(J < NumCols)
        {
            SpawnLoc = ((StartLoc + ((float(I + 1) * Spacing) * FaceDir)) + ((float(J - (NumCols / 2)) * Spacing) * RightDir)) + (vect(0, 0, 1) * float(15));
            SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
            KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot,, false);
            if(KFP != none)
            {
                if(KFPawn_Monster(KFP) != none)
                {
                    KFPawn_Monster(KFP).bDebug_SpawnedThroughCheat = true;
                }
                KFP.SetPhysics(2);
                KFGameInfo(Outer.WorldInfo.Game).SetMonsterDefaults(KFPawn_Monster(KFP));
                if((KFP.Controller != none) && KFAIController(KFP.Controller) != none)
                {
                    KFGameInfo(Outer.WorldInfo.Game).GetAIDirector().AIList.AddItem(KFAIController(KFP.Controller);
                }
                KFP.SpawnDefaultController();
                if(KFAIController(KFP.Controller) != none)
                {
                    KFAIController(KFP.Controller).SetTeam(1);
                }                
            }
            else
            {
                Outer.ClientMessage(("Could not spawn ZED [" $ ZedName) $ "]. Please make sure that the ZED name to archetype mapping is set up correctly.", CheatType);
            }
            ++ J;
            goto J0x15B;
        }
        ++ I;
        goto J0x139;
    }
}

simulated exec function SpawnZedGroup(string ZedName, int NumRows, int NumCols, optional float Spacing, optional bool bUseGoreLOD, optional int ForcedLOD)
{
    local class<KFPawn> SpawnClass;
    local Vector StartLoc, SpawnLoc, RightDir, FaceDir;
    local Rotator SpawnRot;
    local KFPawn KFP;
    local KFPawn_Monster KFPM;
    local int I, J;

    Spacing = 100;
    bUseGoreLOD = false;
    ForcedLOD = 0;
    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return;
    }
    if(Outer.Pawn != none)
    {
        StartLoc = Outer.Pawn.Location;        
    }
    else
    {
        StartLoc = Outer.Location;
    }
    FaceDir = Normal(GetRotatorAxis(Outer.Rotation, 0));
    RightDir = Normal(GetRotatorAxis(Outer.Rotation, 1));
    I = 0;
    J0x143:

    if(I < NumRows)
    {
        J = 0;
        J0x165:

        if(J < NumCols)
        {
            SpawnLoc = ((StartLoc + ((float(I + 1) * Spacing) * FaceDir)) + ((float(J - (NumCols / 2)) * Spacing) * RightDir)) + (vect(0, 0, 1) * float(15));
            SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
            KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
            if(KFP != none)
            {
                KFP.SetPhysics(2);
                if((KFP.Controller != none) && KFAIController(KFP.Controller) != none)
                {
                    KFGameInfo(Outer.WorldInfo.Game).GetAIDirector().AIList.AddItem(KFAIController(KFP.Controller);
                }
                if(bUseGoreLOD)
                {
                    KFPM = KFPawn_Monster(KFP);
                    if(KFPM != none)
                    {
                        KFPM.SwitchToGoreMesh();                        
                    }
                    else
                    {
                        Outer.ClientMessage("Failed to switch to gore LOD", CheatType);
                    }
                }
                if(ForcedLOD != 0)
                {
                    KFP.Mesh.ForcedLodModel = ForcedLOD;
                }
            }
            ++ J;
            goto J0x165;
        }
        ++ I;
        goto J0x143;
    }
}

simulated exec function SpawnZedLODs(string ZedName)
{
    local class<KFPawn> SpawnClass;
    local Vector StartLoc, SpawnLoc, RightDir, FaceDir;
    local Rotator SpawnRot;
    local KFPawn KFP;

    SpawnClass = LoadMonsterByName(ZedName);
    if(SpawnClass == none)
    {
        return;
    }
    if(Outer.Pawn != none)
    {
        StartLoc = Outer.Pawn.Location;        
    }
    else
    {
        StartLoc = Outer.Location;
    }
    FaceDir = Normal(GetRotatorAxis(Outer.Rotation, 0));
    RightDir = Normal(GetRotatorAxis(Outer.Rotation, 1));
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) - (float(200) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 1;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) - (float(100) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 2;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) + (float(0) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 3;
    SpawnLoc = ((StartLoc + (float(200) * FaceDir)) + (float(100) * RightDir)) + (vect(0, 0, 1) * float(15));
    SpawnRot.Yaw = Outer.Rotation.Yaw + 32768;
    KFP = Outer.Spawn(SpawnClass,,, SpawnLoc, SpawnRot);
    KFP.Mesh.ForcedLodModel = 4;
}

function string GetRandomClotType()
{
    switch(Rand(2))
    {
        case 0:
            return "KFGameContent.KFPawn_ZedClot_Alpha";
        case 1:
            return "KFGameContent.KFPawn_ZedClot_Slasher";
        case 2:
            return "KFGameContent.KFPawn_ZedClot_Cyst";
        default:
            WarnInternal("GetRandomClotType no type selected");
            break;
    }
}

exec function TestPortalNearby(string ZedName, optional int NumSpawns)
{
    local KFSpawner Spawner, Best;
    local Vector MyLocation;
    local float bestDist;

    NumSpawns = 1;
    foreach Outer.WorldInfo.AllActors(Class'KFSpawner', Spawner)
    {
        MyLocation = ((Outer.Pawn != none) ? Outer.Pawn.Location : Outer.Location);
        if((Best == none) || VSize(Spawner.Location - MyLocation) < bestDist)
        {
            Best = Spawner;
            bestDist = VSize(Best.Location - MyLocation);
        }        
    }    
    if(Best != none)
    {
        Best.TestSpawn(LoadMonsterByName(ZedName), NumSpawns, true);
    }
}

exec function TestPortalAll(optional string ZedName)
{
    local KFSpawner Spawner;

    foreach Outer.WorldInfo.AllActors(Class'KFSpawner', Spawner)
    {
        Spawner.TestSpawn(LoadMonsterByName(ZedName), 1, true);
        Spawner.bIgnoreChildren = true;        
    }    
}

exec function TestPortalActive(optional string ZedName)
{
    local KFSpawner ActiveSpawner;

    ActiveSpawner = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.ActiveSpawner;
    if(ActiveSpawner != none)
    {
        ActiveSpawner.TestSpawn(LoadMonsterByName(ZedName), 1, true);        
    }
    else
    {
        Outer.ClientMessage("Warning - No spawn volume has been activated.", CheatType, 13);
        LogInternal("Say No spawn volume has been activated");
    }
}

exec function TestSpawnVolume(int SpawnAmount, optional bool bCrawlersOnly, optional bool bBloatsOnly)
{
    local KFSpawnVolume SpawnVolume, ClosestSpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    I = 0;
    J0x0D:

    if(I < SpawnAmount)
    {
        if(bCrawlersOnly)
        {
            TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedCrawler", Class'Class'));            
        }
        else
        {
            if(bBloatsOnly)
            {
                TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat", Class'Class'));                
            }
            else
            {
                TempPawn = class<KFPawn_Monster>(DynamicLoadObject(GetRandomClotType(), Class'Class'));
            }
        }
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x0D;
    }
    I = 0;
    J0x132:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0x132;
    }
    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        if(ClosestSpawnVolume == none)
        {
            ClosestSpawnVolume = SpawnVolume;
            continue;
        }
        if(Outer.Pawn != none)
        {
            if(VSize(SpawnVolume.Location - Outer.Pawn.Location) < VSize(ClosestSpawnVolume.Location - Outer.Pawn.Location))
            {
                ClosestSpawnVolume = SpawnVolume;
            }
            continue;
        }
        if(VSize(SpawnVolume.Location - Outer.Location) < VSize(ClosestSpawnVolume.Location - Outer.Location))
        {
            ClosestSpawnVolume = SpawnVolume;
        }        
    }    
    ClosestSpawnVolume.SpawnWave(FakeSpawnList, false);
}

exec function SetSpawnVolumeDebug(bool bSpawnDebug, optional bool bDebugRating, optional bool bDebugVisibility)
{
    local KFSpawnVolume SpawnVolume;
    local KFSpawner Spawner;

    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        SpawnVolume.bDebugSpawning = bSpawnDebug;
        SpawnVolume.bDebugRatingChecks = bDebugRating;
        SpawnVolume.bDebugVisibilityChecks = bDebugVisibility;        
    }    
    foreach Outer.AllActors(Class'KFSpawner', Spawner)
    {
        Spawner.bDebugSpawning = bSpawnDebug;        
    }    
    Outer.ClientMessage(("Setting bDebugSpawning to " $ string(bSpawnDebug)) $ " for Spawn Volumes and Portal Spawns", CheatType);
}

exec function SetSpawnVolumeMinDebug(bool bNewMinDebug)
{
    local KFSpawnVolume SpawnVolume;

    foreach Outer.AllActors(Class'KFSpawnVolume', SpawnVolume)
    {
        SpawnVolume.bMinimalDebugRatingChecks = bNewMinDebug;        
    }    
    Outer.ClientMessage(("Setting bMinimalDebugRatingChecks to " $ string(bNewMinDebug)) $ " for Spawn Volumes", CheatType);
}

exec function SpawnTest(int SpawnAmount, optional bool bSimSpawn, optional bool bSpawnZeds)
{
    local KFSpawnVolume SpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    Outer.FlushPersistentDebugLines();
    Outer.RemoveAllDebugStrings();
    I = 0;
    J0x4B:

    if(I < SpawnAmount)
    {
        TempPawn = class<KFPawn_Monster>(DynamicLoadObject(GetRandomClotType(), Class'Class'));
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x4B;
    }
    I = 0;
    J0xC2:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0xC2;
    }
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).SpawnManager.DesiredSquadType = 4;
        SpawnVolume = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.GetBestSpawnVolume(FakeSpawnList);
        if(bSimSpawn && !bSpawnZeds)
        {
            SpawnVolume.SetLastSpawnTime(Outer.WorldInfo.TimeSeconds);
            KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.AddRecentSpawnVolume(SpawnVolume.Location);
        }
    }
    Outer.ClientMessage("Checking Spawns, best volume = " $ string(SpawnVolume), CheatType);
    if(bSpawnZeds)
    {
        SpawnVolume.SpawnWave(FakeSpawnList, true);
    }
}

exec function SpawnBloatTest(int SpawnAmount, optional bool bSimSpawn, optional bool bSpawnZeds)
{
    local KFSpawnVolume SpawnVolume;
    local array< class<KFPawn_Monster> > FakeSpawnList;
    local int I;
    local class<KFPawn_Monster> TempPawn;

    Outer.FlushPersistentDebugLines();
    Outer.RemoveAllDebugStrings();
    I = 0;
    J0x4B:

    if(I < SpawnAmount)
    {
        TempPawn = class<KFPawn_Monster>(DynamicLoadObject("KFGameContent.KFPawn_ZedBloat", Class'Class'));
        FakeSpawnList.AddItem(TempPawn;
        ++ I;
        goto J0x4B;
    }
    I = 0;
    J0xD7:

    if(I < SpawnAmount)
    {
        LogInternal((("FakeSpawnList " $ string(I)) $ " is ") $ string(FakeSpawnList[I]));
        ++ I;
        goto J0xD7;
    }
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).SpawnManager.DesiredSquadType = 4;
        SpawnVolume = KFGameInfo(Outer.WorldInfo.Game).SpawnManager.GetBestSpawnVolume(FakeSpawnList);
        if(bSimSpawn && !bSpawnZeds)
        {
            SpawnVolume.SetLastSpawnTime(Outer.WorldInfo.TimeSeconds);
            KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.AddRecentSpawnVolume(SpawnVolume.Location);
        }
    }
    Outer.ClientMessage("Checking Spawns, best volume = " $ string(SpawnVolume), CheatType);
    if(bSpawnZeds)
    {
        SpawnVolume.SpawnWave(FakeSpawnList, true);
    }
}

exec function FocusOnZed(optional bool bTextOnly)
{
    local class<Actor> FocusClass;
    local Actor PotentialFocusActor, FirstActor;
    local bool bFound;

    bTextOnly = false;
    FocusClass = Class'KFPawn_Monster';
    foreach Outer.AllActors(FocusClass, PotentialFocusActor)
    {
        if((KFPawn(PotentialFocusActor) != none) && !KFPawn(PotentialFocusActor).IsAliveAndWell())
        {
            continue;            
        }
        if(bFound || FirstActor == none)
        {
            FirstActor = PotentialFocusActor;
            if(bFound)
            {
                break;
            }
        }
        if((DebugSceneCamera != none) && PotentialFocusActor == DebugSceneCamera.FocusActor)
        {
            bFound = true;
        }        
    }    
    if(FirstActor != none)
    {
        Outer.ClientMessage(("Focusing on Zed: " $ string(FirstActor.Name)) $ " [Note: For additional debug scene window, add TRUE to the command ( FocusOnZed TRUE )]", CheatType);
        InitDebugScene(FirstActor, bTextOnly);
    }
}

exec function FocusOn(class<Actor> FocusClass, optional bool bTextOnly)
{
    local Actor PotentialFocusActor, FirstActor;
    local bool bFound;

    bTextOnly = false;
    foreach Outer.AllActors(FocusClass, PotentialFocusActor)
    {
        if((Pawn(PotentialFocusActor) != none) && !Pawn(PotentialFocusActor).IsAliveAndWell())
        {
            continue;            
        }
        if(bFound || FirstActor == none)
        {
            FirstActor = PotentialFocusActor;
            if(bFound)
            {
                break;
            }
        }
        if((DebugSceneCamera != none) && PotentialFocusActor == DebugSceneCamera.FocusActor)
        {
            bFound = true;
        }        
    }    
    if(FirstActor != none)
    {
        Outer.ClientMessage("DebugView from: " $ string(FirstActor.Name), CheatType);
        InitDebugScene(FirstActor, bTextOnly);
    }
}

function InitDebugScene(Actor ActorToWatch, optional bool bTextOnly)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(KFPC != none)
    {
        if(DebugSceneCamera == none)
        {
            DebugSceneCamera = Outer.Spawn(Class'KFSceneCaptureDebugCam', Outer.Pawn,, Outer.Pawn.Location, Outer.Pawn.Rotation,, true);
            DebugSceneCamera.bTextOnly = bTextOnly;
        }
        Outer.myHUD.bShowOverlays = true;
        Outer.myHUD.AddPostRenderedActor(DebugSceneCamera);
        bDebugSceneEnabled = DebugSceneCamera.InitDebugScene(KFPC, ActorToWatch);
    }
}

exec function WeldDoors(optional int inNewIntegrity)
{
    local KFDoorActor KFDA;
    local int NewIntegrity;

    inNewIntegrity = -1;
    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        if(inNewIntegrity == -1)
        {
            NewIntegrity = KFDA.MaxWeldIntegrity;            
        }
        else
        {
            NewIntegrity = inNewIntegrity;
        }
        KFDA.WeldIntegrity = NewIntegrity;        
    }    
}

exec function DestroyDoors(optional byte Reverse)
{
    local KFDoorActor KFDA;

    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        ++ KFDA.HitCount;
        if(Reverse != 0)
        {
            KFDA.HitCount = byte(KFDA.HitCount | KFDA.128);            
        }
        else
        {
            KFDA.HitCount = byte(KFDA.HitCount & byte(~KFDA.128));
        }
        KFDA.PlayDestroyed();        
    }    
}

exec function ResetLevel()
{
    Outer.WorldInfo.Game.ResetLevel();
}

exec function ResetDoors()
{
    local KFDoorActor KFDA;

    foreach Outer.WorldInfo.AllActors(Class'KFDoorActor', KFDA)
    {
        KFDA.ResetDoor();        
    }    
}

exec function AISetFocalPoint(optional bool bClear)
{
    local KFAIController KFAIC;

    bClear = false;
    foreach Outer.WorldInfo.AllControllers(Class'KFAIController', KFAIC)
    {
        if((KFAIC != none) && Outer.FastTrace(KFAIC.Pawn.Location, Outer.Pawn.Location))
        {
            if(KFAIC.GetActiveCommand().IsA('AICommand_Debug'))
            {
                if(bClear)
                {
                    Outer.SetFocalPoint(vect(0, 0, 0));
                    continue;
                }
                KFAIC.SetFocalPoint(Outer.Pawn.Location);
            }
        }        
    }    
    Outer.ClientMessage((string(KFAIC.Pawn) $ "'s FocalPoint is now ") $ string(KFAIC.GetFocalPoint()), CheatType);
}

exec function AIClearFocus(optional bool bResetDesiredRot, optional bool bResetFocus, optional bool bResetFocalPoint)
{
    local KFAIController KFAIC;
    local string msg;

    KFAIC = GetKFAICFromAim(false);
    if(KFAIC != none)
    {
        msg = string(Outer.Pawn) $ " [ClearFocus]";
        if(bResetDesiredRot)
        {
            msg = msg $ "[Resetting DesiredRotation]";
            KFAIC.MyKFPawn.ResetDesiredRotation();
        }
        if(bResetFocalPoint)
        {
            msg = msg $ "[Resetting FocalPoint]";
            KFAIC.SetFocalPoint(vect(0, 0, 0));
        }
        if(bResetFocus)
        {
            msg = msg $ "[Resetting Focus]";
            KFAIC.Focus = none;
        }
    }
}

exec function AIUnlockDesiredRotation()
{
    local KFAIController KFAIC;

    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.LockDesiredRotation(false);
    }
}

exec function AILockDesiredRotation(optional bool bLock)
{
    local KFAIController KFAIC;

    bLock = true;
    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        KFAIC.MyKFPawn.LockDesiredRotation(bLock);
    }
}

exec function AISetFocus(optional bool bFocusOnMe, optional bool bSetFocalPoint, optional bool bSetDesiredRot, optional bool bLockDesiredRot)
{
    local KFAIController KFAIC;
    local string msg;

    KFAIC = GetKFAICFromAim(false);
    if((KFAIC != none) && KFAIC.MyKFPawn != none)
    {
        msg = string(KFAIC.Pawn) $ " [SetFocus]";
        if(bSetDesiredRot)
        {
            KFAIC.MyKFPawn.SetDesiredRotation(rotator(GetMyPawn().Location - KFAIC.Pawn.Location), bLockDesiredRot);
            msg = ((msg $ "[DesiredRot: ") $ string(KFAIC.MyKFPawn.DesiredRotation)) $ "]";
        }
        if(bSetFocalPoint)
        {
            KFAIC.SetFocalPoint(GetMyPawn().Location);
            msg = ((msg $ "[FocalPoint: ") $ string(KFAIC.GetFocalPoint())) $ "]";
        }
        if(bFocusOnMe)
        {
            KFAIC.Focus = GetMyPawn();
            msg = ((msg $ "[Focus: ") $ string(Outer.Focus)) $ "]";
        }
        Outer.ClientMessage(msg, CheatType);
    }
}

exec function FocusOff()
{
    DestroyDebugScene();
}

function DestroyDebugScene()
{
    bDebugSceneEnabled = false;
    Outer.myHUD.bShowOverlays = false;
    if(DebugSceneCamera != none)
    {
        Outer.myHUD.RemovePostRenderedActor(DebugSceneCamera);
        DebugSceneCamera.DestroyDebugScene();
        DebugSceneCamera = none;
    }
}

exec function ToggleDebugSceneOrbit()
{
    if(DebugSceneCamera != none)
    {
        DebugSceneCamera.ToggleDebugSceneOrbit();
    }
}

exec function PauseDebugSceneUpdate()
{
    if(DebugSceneCamera != none)
    {
        DebugSceneCamera.PauseDebugSceneUpdate();
    }
}

function SetDebugSceneViewMode(Engine.SceneCaptureComponent.ESceneCaptureViewMode NewViewMode)
{
    if(bDebugSceneEnabled && DebugSceneCamera != none)
    {
        DebugSceneCamera.SetDebugSceneViewMode(NewViewMode);
    }
}

exec function SetDebugSceneView()
{
    if(bDebugSceneEnabled && DebugSceneCamera != none)
    {
        DebugSceneCamera.MoveToMyPawnLocation();
    }
}

exec function ToggleSplatterGun()
{
    local KeyBind TempKeyBind;
    local KFPlayerInput KFInput;

    TempKeyBind.Name = 'LeftMouseButton';
    KFInput = KFPlayerInput(Outer.PlayerInput);
    if(KFInput != none)
    {
        if(!bUsingSplatterGun && KFPlayerInput(Outer.PlayerInput) != none)
        {
            KFInput.RemoveCommandFromBind(TempKeyBind, "GBA_Fire");
            KFInput.SetKeyBind(TempKeyBind, "SplatterFire", false);
            KFInput.SaveConfig();
            bUsingSplatterGun = true;            
        }
        else
        {
            KFInput.RemoveCommandFromBind(TempKeyBind, "SplatterFire");
            KFInput.SetKeyBind(TempKeyBind, "GBA_Fire", false);
            KFInput.SaveConfig();
            bUsingSplatterGun = false;
        }
    }
}

exec function SplatterFire()
{
    if(Outer.IsTimerActive('DoSplatterFire', self))
    {
        StopSplatterFire();        
    }
    else
    {
        DoSplatterFire();
        Outer.SetTimer(0.1, true, 'DoSplatterFire', self);
    }
}

exec function StopSplatterFire()
{
    Outer.ClearTimer('DoSplatterFire', self);
}

function DoSplatterFire()
{
    local KFGoreManager GoreManager;
    local Vector StartTrace, TraceDir;

    if(!bUsingSplatterGun)
    {
        StopSplatterFire();
    }
    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        WarnInternal("##### Could not find gore manager #####");
        return;
    }
    StartTrace = Outer.Pawn.GetWeaponStartTraceLocation();
    TraceDir = vector(Outer.Pawn.Weapon.GetAdjustedAim(StartTrace));
    GoreManager.LeaveAPersistentBloodSplat(StartTrace, TraceDir);
}

exec function ClearSplatters()
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        WarnInternal("##### Could not find gore manager #####");
        return;
    }
    GoreManager.ClearPersistentBloodSplats();
}

exec function ClearCorpses()
{
    local int I;
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(Outer.WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        return;
    }
    I = GoreManager.CorpsePool.Length - 1;
    J0x83:

    if(I >= 0)
    {
        GoreManager.RemoveAndDeleteCorpse(I);
        -- I;
        goto J0x83;
    }
}

exec function EndRound(optional bool bSkipResults)
{
    if(Outer.WorldInfo.Game != none)
    {
        Outer.WorldInfo.Game.GotoState('RoundEnded', ((bSkipResults) ? 'ForceEnded' : 'Begin'));
    }
}

exec function CameraBlood()
{
    Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_BloodBase');
}

exec function HeadShotPing(bool Value);

exec function CameraPuke()
{
    Outer.ClientSpawnCameraLensEffect(Class'KFCameraLensEmit_Puke');
}

exec function EnableAtkAnimDifficultyScaling()
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAnimInfo bEnableDifficultyScaling true");
}

exec function DisableAtkAnimDifficultyScaling()
{
    Outer.ConsoleCommand("SETNOPEC KFPawnAnimInfo bEnableDifficultyScaling false");
}

exec function ToggleAIDefaultsLog()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.bLogAIDefaults = !KFGI.bLogAIDefaults;
    }
}

exec function SetLivingPlayers(byte NewLivingPlayers, optional bool bSoloMode)
{
    local KFGameInfo KFGI;

    bSoloMode = false;
    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.bOnePlayerAtStart = bSoloMode;
        KFGI.ForceLivingPlayerCount(NewLivingPlayers);
    }
}

exec function ConvertFOV(float InFOV)
{
    local float AspectRatio, OriginalAspectRatio, NewFOV;

    AspectRatio = 16 / float(9);
    OriginalAspectRatio = 4 / float(3);
    NewFOV = (Atan2(Tan((InFOV * 3.141593) / 360) * (AspectRatio / OriginalAspectRatio), 1) * 360) / 3.141593;
    LogInternal((("FOV --- Original:" @ string(InFOV)) @ "New:") @ string(NewFOV));
}

exec function TurnOnAIArenaLight()
{
    local PointLightToggleable PLT;

    foreach Outer.WorldInfo.AllActors(Class'PointLightToggleable', PLT)
    {
        PLT.bEnabled = true;
        PLT.LightComponent.SetEnabled(true);
        PLT.LastRenderTime = Outer.WorldInfo.TimeSeconds;        
    }    
}

exec function SetNadeRadiusDebug(bool bShowRadius)
{
    Class'KFExplosionActor'.default.bDrawDebug = bShowRadius;
    Class'KFExplosionActor'.static.StaticSaveConfig();
}

exec function LaunchChunks(int NumChunks, bool bNoSpread)
{
    local Vector SpawnPos, BaseChunkDir;
    local Rotator Rot;
    local int I;
    local Projectile NewChunk;
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local KFPerk MyPerk;

    MyPerk = KFPawn(Outer.Pawn).GetPerk();
    Outer.GetPlayerViewPoint(ViewLocation, ViewRotation);
    SpawnPos = ViewLocation;
    if((Outer.Pawn != none) && Outer.Pawn.Role == ROLE_Authority)
    {
        BaseChunkDir = vector(ViewRotation);
        I = 0;
        J0x10F:

        if(I < NumChunks)
        {
            if(bNoSpread)
            {
                Rot = rotator(BaseChunkDir);                
            }
            else
            {
                Rot = rotator((float(8) * BaseChunkDir) + VRand());
            }
            NewChunk = Outer.Pawn.Weapon.Spawn(MyPerk.GrenadeClass.default.ExplosionTemplate.ShardClass, ((Outer.Pawn.Weapon != none) ? Outer.Pawn.Weapon : Outer.Pawn),, SpawnPos, Rot);
            if(NewChunk != none)
            {
                NewChunk.Init(vector(Rot));
            }
            ++ I;
            goto J0x10F;
        }
    }
}

exec function ShowMeleeCollision(optional bool bEnable)
{
    bEnable = true;    
    Outer.ConsoleCommand("SETNOPEC KFMeleeHelperBase bDebugShowCollision" @ string(bEnable));
}

exec function Chris()
{
    Outer.ConsoleCommand("SUPPRESS DevPhysics");
    God();
    AllWeapons();
    UberAmmo();    
    Outer.ConsoleCommand("ToggleSpawning");
}

exec function TestGameSearch(optional bool bSearchLan)
{
    local KFDataStore_OnlineGameSearch SearchDataStore;
    local DataStoreClient DataStoreManager;
    local bool succeed;
    local OnlineGameSearch GameSearch;

    DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
    if(DataStoreManager == none)
    {
        LogInternal("No data store manager");
        Outer.ClientMessage("No data store manager", CheatType);
        return;
    }
    SearchDataStore = KFDataStore_OnlineGameSearch(DataStoreManager.FindDataStore('KFGameSearch', LocalPlayer(Outer.Player)));
    if(SearchDataStore == none)
    {
        LogInternal("No search data store found");
        Outer.ClientMessage("No search data store found", CheatType);
        return;
    }
    GameSearch = SearchDataStore.GetCurrentGameSearch();
    if(GameSearch == none)
    {
        LogInternal("No current game search found");
        Outer.ClientMessage("No current game search found", CheatType);
        return;
    }
    GameSearch.bIsLanQuery = bSearchLan;
    succeed = SearchDataStore.SubmitGameSearch(0);
    if(succeed)
    {
        LogInternal("Search start succeeded");
        Outer.ClientMessage("Search start succeeded", CheatType);        
    }
    else
    {
        LogInternal("Search start failed");
        Outer.ClientMessage("Search start failed", CheatType);
    }
}

exec function ShowLevelUpPopUp(bool bTierUnlock)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(((KFPC != none) && KFPC.myGfxHUD != none) && KFPC.myGfxHUD.LevelUpNotificationWidget != none)
    {
        KFPC.myGfxHUD.LevelUpNotificationWidget.ShowLevelUpNotification(KFPC.CurrentPerk.Class, KFPC.GetLevel(), bTierUnlock);
    }
}

exec function GetCurrentPerkXP()
{
    Outer.ClientMessage((("Perk:" @ Mid(string(KFPawn(Outer.Pawn).GetPerk()), 7)) @ "XP:") @ string(KFPlayerController(Outer).GetPerkXP(KFPawn(Outer.Pawn).GetPerk().Class)), CheatType);
}

exec function TestFalloffDamage(float Distance, float MaxRadius, float FalloffExponent)
{
    local float DamageScale;

    DamageScale = FClamp(1 - (Distance / MaxRadius), 0, 1);
    DamageScale = DamageScale ** FalloffExponent;
    LogInternal((string(GetFuncName()) @ "Result:") $ string(DamageScale));
}

exec function ZedTimeTest(float NewCustomTimeDilation)
{
    GetMyPawn().CustomTimeDilation = NewCustomTimeDilation;
    GetMyPawn().Weapon.CustomTimeDilation = NewCustomTimeDilation;
}

exec function FakeDramaEvent()
{
    DramaEvent(1);
    ZedTimeTest(5);
    Outer.SetTimer(0.6, false, 'ClearFakeDramaEvent', self);
}

simulated function ClearFakeDramaEvent()
{
    GetMyPawn().CustomTimeDilation = 1;
    GetMyPawn().Weapon.CustomTimeDilation = 1;
}

exec function DBJump()
{
    local Vector UsedKickMomentum;

    if(Outer.Pawn != none)
    {
        UsedKickMomentum.X = -1000;
        if(Outer.Pawn.Physics == 2)
        {
            UsedKickMomentum = UsedKickMomentum >> Outer.Pawn.GetViewRotation();
            UsedKickMomentum *= 0.5;            
        }
        else
        {
            UsedKickMomentum = UsedKickMomentum >> Outer.Pawn.Rotation;
            UsedKickMomentum.Z = 0;
        }
        Outer.Pawn.AddVelocity(UsedKickMomentum, Outer.Pawn.Location, none);
    }
}

exec function ShowKFGameVersion()
{
    LogInternal("Current KFGame version:" @ string(Class'KFGameEngine'.static.GetKFGameVersion()));
}

exec function LogAmmoPickups()
{
    local KFGameInfo KFGI;
    local float NumTotalAmmoPickups, NumActiveAmmoPickups, NumSleepingAmmoPickups, NumDisabledAmmoPickups;
    local int I;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        LogInternal("~~LogAmmoPickups START~~~");
        I = 0;
        J0x7E:

        if(I < KFGI.AmmoPickups.Length)
        {
            NumTotalAmmoPickups += 1;
            if(KFGI.AmmoPickups[I].IsInState('Disabled'))
            {
                NumDisabledAmmoPickups += 1;
                LogInternal((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is disabled! Location:") @ string(KFGI.AmmoPickups[I].Location));                
            }
            else
            {
                if(KFGI.AmmoPickups[I].IsInState('Sleeping'))
                {
                    NumSleepingAmmoPickups += 1;
                    LogInternal((((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is sleeping! Location:") @ string(KFGI.AmmoPickups[I].Location)) @ "; Time until respawn: ") @ string(KFGI.AmmoPickups[I].GetRemainingTimeForTimer('Reset')));                    
                }
                else
                {
                    if(KFGI.AmmoPickups[I].IsInState('Pickup'))
                    {
                        NumActiveAmmoPickups += 1;
                        LogInternal((("~~LogAmmoPickups: AmmoPickup" @ string(I)) @ "is ACTIVE! Location:") @ string(KFGI.AmmoPickups[I].Location));
                    }
                }
            }
            ++ I;
            goto J0x7E;
        }
        LogInternal("~~LogAmmoPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogAmmoPickups: Total num ammo pickup ups:   " @ string(Round(NumTotalAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Disabled ammo pickup ups:    " @ string(Round(NumDisabledAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Sleeping ammo pickup ups:    " @ string(Round(NumSleepingAmmoPickups)));
        LogInternal("~~LogAmmoPickups: Active ammo pickup ups:      " @ string(Round(NumActiveAmmoPickups)));
        LogInternal(((((((("~~LogAmmoPickups: Percentages: Disabled:" @ string((float(100) / NumTotalAmmoPickups) * NumDisabledAmmoPickups)) $ "%") @ "Sleeping:") @ string((float(100) / NumTotalAmmoPickups) * NumSleepingAmmoPickups)) $ "%") @ "Active:") @ string((float(100) / NumTotalAmmoPickups) * NumActiveAmmoPickups)) $ "%");
        LogInternal("~~LogAmmoPickups END~~~");
    }
}

exec function LogItemPickups()
{
    local KFGameInfo KFGI;
    local float NumTotalItemPickups, NumActiveItemPickups, NumSleepingItemPickups, NumDisabledItemPickups;
    local int I;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogItemPickups START~~~");
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        I = 0;
        J0xF2:

        if(I < KFGI.ItemPickups.Length)
        {
            NumTotalItemPickups += 1;
            if(KFGI.ItemPickups[I].IsInState('Disabled'))
            {
                NumDisabledItemPickups += 1;
                LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is disabled! Location:") @ string(KFGI.ItemPickups[I].Location));                
            }
            else
            {
                if(KFGI.ItemPickups[I].IsInState('Sleeping'))
                {
                    NumSleepingItemPickups += 1;
                    LogInternal("~~LogItemPickups -------------------------------------");
                    LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is sleeping! Location:") @ string(KFGI.ItemPickups[I].Location));                    
                }
                else
                {
                    if(KFGI.ItemPickups[I].IsInState('Pickup'))
                    {
                        NumActiveItemPickups += 1;
                        LogInternal("~~LogItemPickups -------------------------------------");
                        LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "is ACTIVE! Location:") @ string(KFGI.ItemPickups[I].Location));
                        LogInternal((("~~LogItemPickups: ItemPickup" @ string(I)) @ "item is a") @ string(KFPickupFactory_Item(KFGI.ItemPickups[I]).ItemPickups[KFPickupFactory_Item(KFGI.ItemPickups[I]).PickupIndex].ItemClass.Name));
                    }
                }
            }
            ++ I;
            goto J0xF2;
        }
        LogInternal("~~LogItemPickups ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        LogInternal("~~LogItemPickups: Total num item pickups:   " @ string(Round(NumTotalItemPickups)));
        LogInternal("~~LogItemPickups: Disabled item pickups:    " @ string(Round(NumDisabledItemPickups)));
        LogInternal("~~LogItemPickups: Sleeping item pickups:    " @ string(Round(NumSleepingItemPickups)));
        LogInternal("~~LogItemPickups: Active item pickups:      " @ string(Round(NumActiveItemPickups)));
        LogInternal(((((((("~~LogItemPickups: Percentages: Disabled:" @ string((float(100) / NumTotalItemPickups) * NumDisabledItemPickups)) $ "%") @ "Sleeping:") @ string((float(100) / NumTotalItemPickups) * NumSleepingItemPickups)) $ "%") @ "Active:") @ string((float(100) / NumTotalItemPickups) * NumActiveItemPickups)) $ "%");
        LogInternal("~~LogItemPickups END~~~");
    }
}

exec function LogStatValue(int StatId)
{
    KFPlayerController(Outer).LogStatValue(StatId);
}

exec function ToggleRelevancyView()
{
    local Actor A;

    foreach Outer.AllActors(Class'Actor', A)
    {
        if(A.bIgnoreNetRelevancyCollision)
        {
            A.SetHidden(!A.bHidden);
        }        
    }    
}

exec function ToggleVisibilityView()
{
    local Actor A;
    local StaticMeshActor SM;
    local editinline StaticMeshComponent SMC;

    foreach Outer.AllActors(Class'Actor', A)
    {
        SM = StaticMeshActor(A);
        if(SM != none)
        {
            SMC = SM.StaticMeshComponent;
            if(!SMC.RBCollideWithChannels.Visibility)
            {
                SMC.SetHidden(!SMC.HiddenGame);
            }
            continue;
        }
        A.SetHidden(!A.bHidden);        
    }    
}

exec function LogServerMovementVars()
{
    if(Outer.Pawn != none)
    {
        LogInternal((string(Outer.Pawn) @ "Velocity:") @ string(Outer.Pawn.Velocity));
        LogInternal((string(Outer.Pawn) @ "Acceleration:") @ string(Outer.Pawn.Acceleration));
        LogInternal((string(Outer.Pawn) @ "Physics:") @ string(Outer.Pawn.Physics));
        LogInternal((string(Outer.Pawn) @ "bIsWalking:") @ string(Outer.Pawn.bIsWalking));
        LogInternal((string(Outer.Pawn) @ "bIsSprinting:") @ string(KFPawn(Outer.Pawn).bIsSprinting));
        LogInternal((string(Outer.Pawn) @ "bIsCrouched:") @ string(Outer.Pawn.bIsCrouched));
        LogInternal((string(Outer.Pawn) @ "WeaponEncumbrance:") @ string(KFInventoryManager(Outer.Pawn.InvManager).GetEncumbranceSpeedMod()));
        LogInternal((string(Outer.Pawn) @ "GroundSpeed:") @ string(Outer.Pawn.GroundSpeed));
        LogInternal((string(Outer.Pawn) @ "Speed:") @ string(VSize(Outer.Pawn.Velocity)));
        LogInternal((string(Outer.Pawn) @ "MovementSpeedModifier:") @ string(Outer.Pawn.MovementSpeedModifier));
        LogInternal((string(Outer.Pawn) @ "Controller State:") @ string(Outer.GetStateName()));
    }
}

exec function RespawnSpectators()
{
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).StartHumans();
    }
}

exec function WeaponGotoState(name StateName)
{
    if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
    {
        Outer.Pawn.Weapon.GotoState(StateName);
    }
}

exec function SetWeaponSkin(int MaterialIndex, string MaterialName)
{
    local MaterialInterface NewMat;

    if((Outer.Pawn != none) && Outer.Pawn.Weapon != none)
    {
        NewMat = MaterialInterface(DynamicLoadObject(MaterialName, Class'MaterialInterface'));
        Outer.Pawn.Weapon.Mesh.SetMaterial(MaterialIndex, NewMat);
    }
}

exec function DemiGod()
{
    if(Outer.bDemiGodMode)
    {
        Outer.bDemiGodMode = false;
        Outer.ClientMessage("Demi God mode off");
        return;
    }
    Outer.bDemiGodMode = true;
    Outer.ClientMessage("Demi God Mode on");
}

exec function TestGrapple()
{
    local KFPawn_Monster P;

    foreach Outer.WorldInfo.AllPawns(Class'KFPawn_Monster', P)
    {
        if(P.CanDoSpecialMove(3))
        {
            P.DoSpecialMove(3, true, Outer.Pawn);
        }        
    }    
}

exec function SpawnHumanPawnV(optional bool bEnemy, optional bool bUseGodMode, optional int CharIndex)
{
    local KFAIController KFBot;
    local KFPlayerReplicationInfo KFPRI;
    local Vector CamLoc;
    local Rotator CamRot;
    local class<KFPawn_Human> PawnClass;
    local KFPawn_Human KFPH;
    local Vector HitLocation, HitNormal;
    local Actor TraceOwner;

    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    if(Outer.Pawn != none)
    {
        TraceOwner = Outer.Pawn;        
    }
    else
    {
        TraceOwner = Outer;
    }
    TraceOwner.Trace(HitLocation, HitNormal, CamLoc + (vector(CamRot) * float(250000)), CamLoc, true, vect(0, 0, 0));
    HitLocation.Z += float(100);
    PawnClass = class<KFPawn_Human>(DynamicLoadObject("KFGameContent.KFPawn_Human_Versus", Class'Class'));
    KFPH = Outer.Spawn(PawnClass,,, HitLocation);
    KFPH.SetPhysics(2);
    KFBot = Outer.Spawn(Class'KFAIController');
    Outer.WorldInfo.Game.ChangeName(KFBot, "Braindead Vs. Human", false);
    if(!bEnemy)
    {
        KFGameInfo(Outer.WorldInfo.Game).SetTeam(KFBot, KFGameInfo(Outer.WorldInfo.Game).Teams[0]);
    }
    KFBot.Possess(KFPH, false);
    if(bUseGodMode)
    {
        KFBot.bGodMode = true;
    }
    KFPRI = KFPlayerReplicationInfo(KFBot.PlayerReplicationInfo);
    KFPRI.CurrentPerkClass = Class'KFPlayerController'.default.PerkList[1].PerkClass;
    KFPRI.NetPerkIndex = 1;
    if(KFPRI != none)
    {
        KFPRI.PlayerHealthPercent = FloatToByte(float(KFPH.Health) / float(KFPH.HealthMax));
        KFPRI.PlayerHealth = byte(KFPH.Health);
    }
    KFPH.AddDefaultInventory();
}

exec function ShowPostRoundMenu()
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    KFPC.ClientOpenRoundSummary();
}

exec function Hats()
{
    Outer.ConsoleCommand("set kfunlockmanager bdebugunlocks true");
}

exec function LoginSelf()
{
    TestLogin(Outer.PlayerReplicationInfo.PlayerName);
}

exec function TestLogin(string InName)
{
    LogInternal("Logging in" @ InName);
    Class'GameEngine'.static.GetPlayfabInterface().AddOnLoginCompleteDelegate(OnLoginComplete);
    Class'GameEngine'.static.GetPlayfabInterface().Login(InName);
}

function OnLoginComplete(bool bWasSuccessful, string SessionTicket, string PlayFabId)
{
    Class'GameEngine'.static.GetPlayfabInterface().ClearOnLoginCompleteDelegate(OnLoginComplete);
    LogInternal((((("Login complete with success" @ string(bWasSuccessful)) @ "and playfab ID") @ PlayFabId) @ "and session ticket") @ SessionTicket);
}

exec function TestPlayfabGameSearch()
{
    local KFDataStore_OnlineGameSearch SearchDataStore;

    SearchDataStore = KFDataStore_OnlineGameSearch(Class'UIInteraction'.static.GetDataStoreClient().FindDataStore('KFGameSearch'));
    SearchDataStore.ActiveSearchIndex = 0;
    Class'GameEngine'.static.GetPlayfabInterface().AddFindOnlineGamesCompleteDelegate(OnFindOnlinePlayfabGamesComplete);
    Class'GameEngine'.static.GetPlayfabInterface().FindOnlineGames(SearchDataStore.GameSearchCfgList[0].Search);
}

function OnFindOnlinePlayfabGamesComplete(bool bSuccess)
{
    local int I;
    local KFDataStore_OnlineGameSearch SearchDataStore;
    local KFOnlineGameSettings GS;

    SearchDataStore = KFDataStore_OnlineGameSearch(Class'UIInteraction'.static.GetDataStoreClient().FindDataStore('KFGameSearch'));
    Class'GameEngine'.static.GetPlayfabInterface().ClearFindOnlineGamesCompleteDelegate(OnFindOnlinePlayfabGamesComplete);
    LogInternal("Search finished with success" @ string(bSuccess));
    I = 0;
    J0xD2:

    if(I < SearchDataStore.GameSearchCfgList[0].Search.Results.Length)
    {
        GS = KFOnlineGameSettings(SearchDataStore.GameSearchCfgList[0].Search.Results[I].GameSettings);
        LogInternal((((((((((("Listing result with region" @ GS.Region) @ "and join string") @ GS.JoinString) @ "and gamemode") @ string(GS.Mode)) @ "and lobby ID") @ GS.LobbyId) @ "and num open connections") @ string(GS.NumOpenPublicConnections)) @ "and max players") @ string(GS.NumPublicConnections));
        ++ I;
        goto J0xD2;
    }
}

exec function TestServerInfoQuery(string LobbyId)
{
    Class'GameEngine'.static.GetPlayfabInterface().AddQueryServerInfoCompleteDelegate(OnQueryServerInfoComplete);
    Class'GameEngine'.static.GetPlayfabInterface().QueryServerInfo(LobbyId);
}

function OnQueryServerInfoComplete(bool bWasSuccessful, string LobbyId, string ServerIP, int ServerPort, string AuthTicket)
{
    Class'GameEngine'.static.GetPlayfabInterface().ClearQueryServerInfoCompleteDelegate(OnQueryServerInfoComplete);
    LogInternal((((((((("OnQueryServerInfoComplete complete with succcess" @ string(bWasSuccessful)) @ "and lobby ID") @ LobbyId) @ "and server IP") @ ServerIP) @ "and port") @ string(ServerPort)) @ "and auth ticket") @ AuthTicket);
}

exec function StartupServer(optional string ServerCommandline)
{
    Class'GameEngine'.static.GetPlayfabInterface().AddOnServerStartedDelegate(OnServerStarted);
    Class'GameEngine'.static.GetPlayfabInterface().StartNewServerInstance(ServerCommandline);
}

function OnServerStarted(bool bWasSuccessful, string ServerLobbyId, string ServerIP, int ServerPort, string ServerTicket)
{
    local string OpenCommand;

    LogInternal((((((((("Server started with success flag" @ string(bWasSuccessful)) @ "and with lobby id") @ ServerLobbyId) @ "and server IP") @ ServerIP) @ "and port") @ string(ServerPort)) @ "and ticket") @ ServerTicket);
    Class'GameEngine'.static.GetPlayfabInterface().ClearOnServerStartedDelegate(OnServerStarted);
    if(bWasSuccessful)
    {
        OpenCommand = (("open" @ ServerIP) $ ":") $ string(ServerPort);        
        OpenCommand $= ("?AuthTicket=" $ ServerTicket);        
        OpenCommand $= ("?PlayfabPlayerId=" $ Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId);
        LogInternal("Going to connect with URL:" @ OpenCommand);        
        Outer.ConsoleCommand(OpenCommand);
    }
}

exec function SetMatchmakingRegion(string InRegion)
{
    Class'GameEngine'.static.GetPlayfabInterface().CurrRegionName = InRegion;
}

exec function ReadPFStoreData()
{
    Class'GameEngine'.static.GetPlayfabInterface().AddStoreDataReadCompleteDelegate(OnPlayfabStoreReadComplete);
    Class'GameEngine'.static.GetPlayfabInterface().ReadStoreData();
}

function OnPlayfabStoreReadComplete(bool bSuccessful)
{
    Class'GameEngine'.static.GetPlayfabInterface().ClearStoreDataReadCompleteDelegate(OnPlayfabStoreReadComplete);
    LogInternal("store catalog read with success" @ string(bSuccessful));
}

exec function ReadPFUserInventory()
{
    Class'GameEngine'.static.GetPlayfabInterface().AddInventoryReadCompleteDelegate(OnPlayfabInventoryReadComplete);
    Class'GameEngine'.static.GetPlayfabInterface().ReadInventory();
}

function OnPlayfabInventoryReadComplete(bool bSuccessful)
{
    Class'GameEngine'.static.GetPlayfabInterface().ClearInventoryReadCompleteDelegate(OnPlayfabInventoryReadComplete);
    LogInternal("Inventory read with success" @ string(bSuccessful));
}

exec function UnlockContainer(string ContainerItemID)
{
    Class'GameEngine'.static.GetPlayfabInterface().UnlockContainer(ContainerItemID);
}

exec function DumpItemDefinitions()
{
    local int I;
    local OnlineSubsystem OSS;

    OSS = Class'GameEngine'.static.GetOnlineSubsystem();
    I = 0;
    J0x34:

    if(I < OSS.ItemPropertiesList.Length)
    {
        LogInternal(((((((((("Listing item" @ string(OSS.ItemPropertiesList[I].Definition)) @ "with name") @ OSS.ItemPropertiesList[I].Name) @ "and type") @ string(OSS.ItemPropertiesList[I].Type)) @ "and price") @ OSS.ItemPropertiesList[I].Price) @ "and URL") @ OSS.ItemPropertiesList[I].IconURL) @ OSS.ItemPropertiesList[I].IconURLLarge);
        LogInternal("   and short description" @ OSS.ItemPropertiesList[I].ShortDescription);
        LogInternal("   and description" @ OSS.ItemPropertiesList[I].Description);
        LogInternal("   and bundle" @ OSS.ItemPropertiesList[I].Bundle);
        LogInternal("   and exchange" @ OSS.ItemPropertiesList[I].Exchange);
        ++ I;
        goto J0x34;
    }
}

exec function DumpInventory()
{
    local int I;
    local OnlineSubsystem OSS;

    OSS = Class'GameEngine'.static.GetOnlineSubsystem();
    I = 0;
    J0x34:

    if(I < OSS.CurrentInventory.Length)
    {
        LogInternal((("Listing item" @ string(OSS.CurrentInventory[I].Definition)) @ "and quantity") @ string(OSS.CurrentInventory[I].Quantity));
        ++ I;
        goto J0x34;
    }
}

exec function DumpExchangeRules()
{
    local int I, J;
    local OnlineSubsystem OSS;

    OSS = Class'GameEngine'.static.GetOnlineSubsystem();
    I = 0;
    J0x34:

    if(I < OSS.ExchangeRuleSetList.Length)
    {
        LogInternal((("For target" @ string(OSS.ExchangeRuleSetList[I].Target)) @ "and item type") @ string(OSS.ExchangeRuleSetList[I].Type));
        J = 0;
        J0x10A:

        if(J < OSS.ExchangeRuleSetList[I].Sources.Length)
        {
            LogInternal((("	" $ string(OSS.ExchangeRuleSetList[I].Sources[J].Definition)) @ "x") $ string(OSS.ExchangeRuleSetList[I].Sources[J].Quantity));
            ++ J;
            goto J0x10A;
        }
        ++ I;
        goto J0x34;
    }
}

exec function DebugUpdateInternalData(string InKey, string InValue)
{
    local array<string> Keys, Values;

    Keys.AddItem(InKey;
    Values.AddItem(InValue;
    Class'GameEngine'.static.GetPlayfabInterface().ServerUpdateInternalUserData(Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId, Keys, Values);
}

exec function DebugUpdateServerData()
{
    Class'GameEngine'.static.GetPlayfabInterface().CreateGameSettings(Class'KFOnlineGameSettings');
    Class'GameEngine'.static.GetPlayfabInterface().ServerUpdateOnlineGame();
}

exec function DebugRetrieveInternalData(string InKey)
{
    local array<string> Keys;

    Keys.AddItem(InKey;
    Class'GameEngine'.static.GetPlayfabInterface().ServerRetrieveInternalUserData(Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId, Keys);
}

exec function DebugAddCurrency(int Amount)
{
    Class'GameEngine'.static.GetPlayfabInterface().ServerAddVirtualCurrencyForUser(Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId, Amount);
}

exec function DebugRemoveCurrency(int Amount)
{
    Class'GameEngine'.static.GetPlayfabInterface().ServerRemoveVirtualCurrencyForUser(Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId, Amount);
}

exec function DebugGrantItem(string ItemId)
{
    local array<string> ItemIds;

    ItemIds.AddItem(ItemId;
    Class'GameEngine'.static.GetPlayfabInterface().ServerGrantItemsForUser(Class'GameEngine'.static.GetPlayfabInterface().CachedPlayfabId, ItemIds);
}

exec function DebugConsumeEntitlements()
{
    Class'GameEngine'.static.GetPlayfabInterface().ConsumeEntitlements();
}

exec function TestTutorialRewards()
{
    Class'GameEngine'.static.GetPlayfabInterface().ExecuteCloudScript("ClaimTutorialRewards", none);
}

exec function DeleteXboxSaveData()
{
    Outer.OnlineSub.ContentInterface.DeleteSaveGame(byte(LocalPlayer(Outer.Player).ControllerId), 0, "", "ProfileData");
}

exec function ShowXboxProductDetails(optional string ProductID)
{
    Outer.OnlineSub.PlayerInterfaceEx.ShowProductDetailsUI(byte(LocalPlayer(Outer.Player).ControllerId), ProductID);
}

exec function ShowXboxStoreUI()
{
    Outer.OnlineSub.PlayerInterfaceEx.ShowContentMarketplaceUI(byte(LocalPlayer(Outer.Player).ControllerId), 1, 1, "65656f5b-117f-43d2-ae4c-74aea578c32d");
}

exec function DumpGameProducts()
{
    DumpStoreCatalog(1);
}

exec function DumpApplicationProducts()
{
    DumpStoreCatalog(2);
}

exec function DumpDurables()
{
    DumpStoreCatalog(3);
}

exec function DumpConsumables()
{
    DumpStoreCatalog(4);
}

exec function DumpSubscriptions()
{
    DumpStoreCatalog(5);
}

exec function DumpFullCatalog()
{
    LogInternal("Dumping Game Products");
    DumpGameProducts();
    LogInternal("Dumping Application Products");
    DumpApplicationProducts();
    LogInternal("Dumping Durable Products");
    DumpDurables();
    LogInternal("Dumping Consumable Products");
    DumpConsumables();
    LogInternal("Dumping Subscription Products");
    DumpSubscriptions();
}

exec function DumpStoreCatalog(Engine.OnlineSubsystem.EMediaItemType MediaType)
{
    local int I, J, K;
    local array<MarketplaceProductDetails> AvailableProducts;

    Outer.OnlineSub.MarketplaceInterface.GetAvailableProducts(byte(LocalPlayer(Outer.Player).ControllerId), MediaType, AvailableProducts);
    LogInternal("Dumping products now... size" @ string(AvailableProducts.Length));
    I = 0;
    J0xD4:

    if(I < AvailableProducts.Length)
    {
        LogInternal((string(I) @ "StandardId") @ AvailableProducts[I].StandardId);
        LogInternal((string(I) @ "MediaItemType") @ string(AvailableProducts[I].MediaItemType));
        LogInternal((string(I) @ "ProductName") @ AvailableProducts[I].ProductName);
        LogInternal((string(I) @ "ProductId") @ AvailableProducts[I].ProductID);
        LogInternal((string(I) @ "SandboxId") @ AvailableProducts[I].SandboxId);
        LogInternal((string(I) @ "TitleId") @ string(AvailableProducts[I].TitleId));
        LogInternal((string(I) @ "IsBundle") @ string(AvailableProducts[I].bIsBundle));
        LogInternal((string(I) @ "IsPartOfAnyBundle") @ string(AvailableProducts[I].bIsPartOfAnyBundle));
        LogInternal((string(I) @ "ReducedName") @ AvailableProducts[I].ReducedName);
        LogInternal((string(I) @ "DetailsReadState") @ string(AvailableProducts[I].DetailsReadState));
        LogInternal((string(I) @ "ProductDescription") @ AvailableProducts[I].ProductDescription);
        LogInternal((string(I) @ "images length") @ string(AvailableProducts[I].Images.Length));
        J = 0;
        J0x44C:

        if(J < AvailableProducts[I].Images.Length)
        {
            LogInternal("  Id" @ AvailableProducts[I].Images[J].Id);
            LogInternal("  Height" @ string(AvailableProducts[I].Images[J].Height));
            LogInternal("  Width" @ string(AvailableProducts[I].Images[J].Width));
            LogInternal("  Purpose" @ AvailableProducts[I].Images[J].Purpose);
            LogInternal("  ResizeURL" @ AvailableProducts[I].Images[J].ResizeURL);
            LogInternal("  purposes length" @ string(AvailableProducts[I].Images[J].Purposes.Length));
            K = 0;
            J0x687:

            if(K < AvailableProducts[I].Images[J].Purposes.Length)
            {
                LogInternal("      " @ AvailableProducts[I].Images[J].Purposes[K]);
                ++ K;
                goto J0x687;
            }
            ++ J;
            goto J0x44C;
        }
        LogInternal((string(I) @ "availabilities length") @ string(AvailableProducts[I].Availabilities.Length));
        J = 0;
        J0x7AC:

        if(J < AvailableProducts[I].Availabilities.Length)
        {
            LogInternal("  Title" @ AvailableProducts[I].Availabilities[J].Title);
            LogInternal("  Description" @ AvailableProducts[I].Availabilities[J].Description);
            LogInternal("  ContentId" @ AvailableProducts[I].Availabilities[J].ContentId);
            LogInternal("  CurrencyCode" @ AvailableProducts[I].Availabilities[J].CurrencyCode);
            LogInternal("  DisplayListPrice" @ AvailableProducts[I].Availabilities[J].DisplayListPrice);
            LogInternal("  DisplayPrice" @ AvailableProducts[I].Availabilities[J].DisplayPrice);
            LogInternal("  DistributionType" @ AvailableProducts[I].Availabilities[J].DistributionType);
            LogInternal("  bIsPurchasable" @ string(AvailableProducts[I].Availabilities[J].bIsPurchasable));
            LogInternal("  ListPrice" @ string(AvailableProducts[I].Availabilities[J].ListPrice));
            LogInternal("  Price" @ string(AvailableProducts[I].Availabilities[J].Price));
            LogInternal("  PromotionalText" @ AvailableProducts[I].Availabilities[J].PromotionalText);
            LogInternal("  OfferId" @ AvailableProducts[I].Availabilities[J].OfferId);
            LogInternal("  SignedOffer" @ AvailableProducts[I].Availabilities[J].SignedOffer);
            LogInternal("  AcceptablePaymentInstrumentTypes length" @ string(AvailableProducts[I].Availabilities[J].AcceptablePaymentInstrumentTypes.Length));
            K = 0;
            J0xCD3:

            if(K < AvailableProducts[I].Availabilities[J].AcceptablePaymentInstrumentTypes.Length)
            {
                LogInternal("      " @ AvailableProducts[I].Availabilities[J].AcceptablePaymentInstrumentTypes[K]);
                ++ K;
                goto J0xCD3;
            }
            ++ J;
            goto J0x7AC;
        }
        ++ I;
        goto J0xD4;
    }
}

exec function RefreshXboxInventory()
{
    Outer.OnlineSub.MarketplaceInterface.ResetInventoryItems(byte(LocalPlayer(Outer.Player).ControllerId), 6);
    Outer.OnlineSub.MarketplaceInterface.ReadInventoryItems(byte(LocalPlayer(Outer.Player).ControllerId), 6);
}

exec function ReadPlayfabTitleData()
{
    Class'GameEngine'.static.GetPlayfabInterface().AddTitleDataReadCompleteDelegate(OnTitleDataRead);
    Class'GameEngine'.static.GetPlayfabInterface().ReadTitleData();
}

exec function OnTitleDataRead()
{
    LogInternal("Title data read");
}

exec function GetTitleDataValueForKey(string Key)
{
    Class'GameEngine'.static.GetPlayfabInterface().ClearTitleDataReadCompleteDelegate(OnTitleDataRead);
    LogInternal((("title data value for key" @ Key) @ "is") @ Class'GameEngine'.static.GetPlayfabInterface().GetTitleDataForKey(Key));
}

exec function DebugEndGameRewards(float GameplayTime, optional bool bFinal)
{
    local JsonObject Parms;

    Parms = new Class'JsonObject';
    Parms.SetIntValue("UpdateTime", int(GameplayTime));
    Parms.SetBoolValue("bGameEnd", bFinal);
    Outer.PlayfabInter.ExecuteCloudScript("UpdatePlayRewards", Parms);
}

exec function DebugSetSafeFrame(float NewScale)
{
    KFGameEngine(Class'Engine'.static.GetEngine()).SafeFrameScale = NewScale;
}

exec function StartMixer()
{
    KFPlayerController(Outer).InitializeMixer();
}

exec function StopMixer()
{
    KFPlayerController(Outer).ShutdownMixer();
}

exec function TestGaveAmmo(string UserName)
{
    KFPlayerController(Outer).myGfxHUD.ShowNonCriticalMessage(UserName @ Class'KFCommon_LocalizedStrings'.default.MixerGaveAmmoString);
}

exec function TestMixerButton(string Button, string MetaData, int Amount, int Cooldown)
{
    local array<string> MetaKeys, MetaProps;

    if(MetaData != "")
    {
        MetaKeys.AddItem("Type";
        MetaProps.AddItem(MetaData;
    }
    if(Amount > 0)
    {
        MetaKeys.AddItem("Amount";
        MetaProps.AddItem(string(Amount);
    }
    if(Cooldown > 0)
    {
        MetaKeys.AddItem("Cooldown";
        MetaProps.AddItem(string(Cooldown);
    }
    KFPlayerController(Outer).TestMixerCall(Button, MetaKeys, MetaProps);
}

exec function ForceMixerScene(string VersionNumber, string ShareCode)
{
    Class'MixerIntegration'.static.ForceMixerScene(VersionNumber, ShareCode);
}

exec function InitLEDEffects()
{
    local LogitechLEDInterface LogtitechLED;
    local RazerLEDInterface RazerFXLED;
    local AlienFXLEDInterface AlienFXLED;

    AlienFXLED = Class'PlatformInterfaceBase'.static.GetAlienFXIntegration();
    RazerFXLED = Class'PlatformInterfaceBase'.static.GetRazerIntegration();
    LogtitechLED = Class'PlatformInterfaceBase'.static.GetLogitechIntegration();
    if(RazerFXLED == none)
    {
        LogInternal("RazerFXLED == none");
    }
    if(LogtitechLED == none)
    {
        LogInternal("LogtitechLED == none");
    }
    if(AlienFXLED == none)
    {
        LogInternal("AlienFXLED == none");        
    }
    else
    {
        AlienFXLED.Activate();
    }
}

exec function SetLEDRGB(byte RedPercent, byte GreenPercent, byte BluePercent)
{
    local LogitechLEDInterface LogtitechLED;
    local RazerLEDInterface RazerFXLED;
    local AlienFXLEDInterface AlienFXLED;

    LogtitechLED = Class'PlatformInterfaceBase'.static.GetLogitechIntegration();
    RazerFXLED = Class'PlatformInterfaceBase'.static.GetRazerIntegration();
    AlienFXLED = Class'PlatformInterfaceBase'.static.GetAlienFXIntegration();
    if(LogtitechLED != none)
    {
        LogtitechLED.SetColor(RedPercent, GreenPercent, BluePercent);
    }
    if(RazerFXLED != none)
    {
        RazerFXLED.SetColor(RedPercent, GreenPercent, BluePercent);
    }
    if(AlienFXLED != none)
    {
        if(!AlienFXLED.SetColor(RedPercent, GreenPercent, BluePercent))
        {
            LogInternal("Failed to set color for AlienFX");
        }
    }
}

exec function LEDSetFlashingRBG(int RedPercent, int GreenPercent, int BluePercent, int milliSecondsDuration, int milliSecondsInterval)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Outer);
    if(KFPC.LEDEffectsManager != none)
    {
        KFPC.LEDEffectsManager.PlayEffectPuke(0);
    }
}

exec function LEDPulseLighting(int RedPercent, int GreenPercent, int BluePercent, int milliSecondsDuration, int milliSecondsInterval)
{
    local LogitechLEDInterface LogtitechLED;
    local RazerLEDInterface RazerFXLED;
    local AlienFXLEDInterface AlienFXLED;

    LogtitechLED = Class'PlatformInterfaceBase'.static.GetLogitechIntegration();
    RazerFXLED = Class'PlatformInterfaceBase'.static.GetRazerIntegration();
    AlienFXLED = Class'PlatformInterfaceBase'.static.GetAlienFXIntegration();
    if(LogtitechLED != none)
    {
        LogtitechLED.LEDPulseLighting(RedPercent, GreenPercent, BluePercent, milliSecondsDuration, milliSecondsInterval);
    }
    if(RazerFXLED != none)
    {
        RazerFXLED.LEDPulseLighting(byte(RedPercent), byte(GreenPercent), byte(BluePercent), milliSecondsDuration, milliSecondsInterval);
    }
    if(AlienFXLED != none)
    {
        AlienFXLED.LEDPulseLighting(byte(RedPercent), byte(GreenPercent), byte(BluePercent), milliSecondsDuration, milliSecondsInterval);
    }
}

exec function LedStopEffects()
{
    local LogitechLEDInterface LogtitechLED;
    local RazerLEDInterface RazerFXLED;

    LogtitechLED = Class'PlatformInterfaceBase'.static.GetLogitechIntegration();
    RazerFXLED = Class'PlatformInterfaceBase'.static.GetRazerIntegration();
    if(LogtitechLED != none)
    {
        LogtitechLED.LedStopEffects();
    }
    if(RazerFXLED != none)
    {
        RazerFXLED.LedStopEffects();
    }
}

exec function LedRestoreLighting()
{
    local LogitechLEDInterface LogtitechLED;

    LogtitechLED = Class'PlatformInterfaceBase'.static.GetLogitechIntegration();
    if(LogtitechLED != none)
    {
        LogtitechLED.LedRestoreLighting();        
    }
    else
    {
        LogInternal("LogtitechLED == none");
    }
}

exec function SetMissionObjectiveActive(bool bActive)
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.myGfxHUD != none)
    {
        KFPC.myGfxHUD.WaveInfoWidget.ObjectiveContainer.SetActive(bActive);
    }
}

exec function SetMissionFailState(bool bFailed)
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.myGfxHUD != none)
    {
        KFPC.myGfxHUD.WaveInfoWidget.ObjectiveContainer.SetFailState(bFailed);
    }
}

exec function SetMissionObjectiveVisible(bool bVisible)
{
    local Pawn P;
    local KFPlayerController KFPC;

    P = GetMyPawn();
    KFPC = KFPlayerController(Outer);
    if((P == none) || KFPC == none)
    {
        return;
    }
    if(KFPC.myGfxHUD != none)
    {
        KFPC.myGfxHUD.WaveInfoWidget.ObjectiveContainer.SetVisible(bVisible);
    }
}

exec function UpgradeWeapon()
{
    local KFPawn MyPawn;

    MyPawn = KFPawn(GetMyPawn());
    if((MyPawn != none) && MyPawn.MyKFWeapon != none)
    {
        MyPawn.MyKFWeapon.UpgradeWeapon();
    }
}

exec function ForceSpecialWave(optional string ZedTypeName)
{
    local int AIType;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).bForceSpecialWave = true;
        if(ZedTypeName != "")
        {
            AIType = GetAITypeByName(ZedTypeName);
            if(AIType != -1)
            {
                KFGameInfo(Outer.WorldInfo.Game).DebugForceSpecialWaveZedType = AIType;                
            }
            else
            {
                Outer.ClientMessage(ZedTypeName @ "is not a valid special wave type.", CheatType);
            }
        }
    }
}

exec function ForceOutbreakWave(optional int OutbreakIdx)
{
    OutbreakIdx = -1;
    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).bForceOutbreakWave = true;
        if(OutbreakIdx != -1)
        {
            KFGameInfo(Outer.WorldInfo.Game).DebugForcedOutbreakIdx = OutbreakIdx;
        }
    }
}

exec function ForceNextObjective()
{
    if((KFGameInfo(Outer.WorldInfo.Game) != none) && KFGameInfo(Outer.WorldInfo.Game).MyKFGRI != none)
    {
        KFGameInfo(Outer.WorldInfo.Game).MyKFGRI.bForceNextObjective = true;
    }
}

exec function ActivateAllPickups()
{
    local int I;

    if(KFGameInfo(Outer.WorldInfo.Game) != none)
    {
        I = 0;
        J0x4D:

        if(I < KFGameInfo(Outer.WorldInfo.Game).ItemPickups.Length)
        {
            KFGameInfo(Outer.WorldInfo.Game).ActivateNextPickup(KFGameInfo(Outer.WorldInfo.Game).ItemPickups[I], 1);
            ++ I;
            goto J0x4D;
        }
    }
}

exec function ForceUpdateDiscordPresence();

defaultproperties
{
    CheatType=KFCheat
    DebugCameraControllerClassName="KFGame.KFDebugCameraController"
}