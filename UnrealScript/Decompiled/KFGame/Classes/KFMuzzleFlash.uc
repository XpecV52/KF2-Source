/*******************************************************************************
 * KFMuzzleFlash generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFMuzzleFlash extends Object
    native(Effect)
    config(Game)
    hidecategories(Object);

struct native MuzzleEffectInfo
{
    /** Dynamic light component */
    var() KFExplosionLight LightTemplate;
    /** Muzzle flash PSC and Templates */
    var() ParticleSystem ParticleSystemTemplate;
    /** Muzzle flash PSC and Templates */
    var() bool bPSCLoops;
    /** Sets LifeSpan of PSC (iff bMuzzleFlashPSCLoops=FALSE) and light */
    var() float Duration;
    /** The default socket name to attach to */
    var() name SocketName;
    var const name TimerName;
    var export editinline transient KFParticleSystemComponent PSC;
    var export editinline transient KFExplosionLightComponent LightComponent;
    var transient bool bIsActive;

    structdefaultproperties
    {
        LightTemplate=none
        ParticleSystemTemplate=none
        bPSCLoops=false
        Duration=0.33
        SocketName=MuzzleFlash
        TimerName=None
        PSC=none
        LightComponent=none
        bIsActive=false
    }
};

var transient Actor Owner;
var() MuzzleEffectInfo MuzzleFlash;
var() MuzzleEffectInfo MuzzleFlashAlt<EditCondition=bEnableSecondaryMuzzleFlash>;
/** If set, creates a second set of muzzle flash data used for alt firemode */
var() bool bEnableSecondaryMuzzleFlash;
var transient bool bLastWasPrimary;
/** If set, the shell eject will automatically trigger with the muzzle flash */
var(ShellEject) bool bAutoActivateShellEject;
/** Set this to a fire mode when you want them to alternate between the primary muzzle flash, and alternate when using this fire mode */
var(Advanced) byte FireModeAlternateBothEffects;
/** Set this to a fire mode when you want them to fire both the primary muzzle flash, and alternate when using this fire mode */
var(Advanced) byte FireModeFireBothEffects;
/** Muzzle flash PSC and Templates */
var(ShellEject) ParticleSystem ShellEjectPSCTemplate;
/** The default socket name to attach to */
var(ShellEject) name ShellEjectSocketName;
var export editinline transient KFParticleSystemComponent ShellEjectPSC;
var globalconfig float ShellEjectLifetime;

// Export UKFMuzzleFlash::execCauseMuzzleFlash(FFrame&, void* const)
native function CauseMuzzleFlash(optional byte FiringMode);

// Export UKFMuzzleFlash::execStopMuzzleFlash(FFrame&, void* const)
native function StopMuzzleFlash();

// Export UKFMuzzleFlash::execMuzzleFlashTimer(FFrame&, void* const)
native function MuzzleFlashTimer();

// Export UKFMuzzleFlash::execMuzzleFlashAltTimer(FFrame&, void* const)
native function MuzzleFlashAltTimer();

function AttachMuzzleFlash(SkeletalMeshComponent OwnerMesh, optional name SocketNameOverride, optional name AltSocketNameOverride)
{
    local float OwnerMeshFOV;

    if(SocketNameOverride != 'None')
    {
        MuzzleFlash.SocketName = SocketNameOverride;
    }
    if(MuzzleFlash.ParticleSystemTemplate != none)
    {
        OwnerMesh.AttachComponentToSocket(MuzzleFlash.PSC, MuzzleFlash.SocketName);
        MuzzleFlash.PSC.SetTemplate(MuzzleFlash.ParticleSystemTemplate);
    }
    if(MuzzleFlash.LightTemplate != none)
    {
        MuzzleFlash.LightComponent = new (self) Class'KFExplosionLightComponent';
        MuzzleFlash.LightComponent.SetTemplate(MuzzleFlash.LightTemplate);
        MuzzleFlash.LightComponent.SetEnabled(false);
        OwnerMesh.AttachComponentToSocket(MuzzleFlash.LightComponent, MuzzleFlash.SocketName);
    }
    if(bEnableSecondaryMuzzleFlash)
    {
        if(AltSocketNameOverride != 'None')
        {
            MuzzleFlashAlt.SocketName = AltSocketNameOverride;
        }
        if(MuzzleFlashAlt.ParticleSystemTemplate != none)
        {
            OwnerMesh.AttachComponentToSocket(MuzzleFlashAlt.PSC, MuzzleFlashAlt.SocketName);
            MuzzleFlashAlt.PSC.SetTemplate(MuzzleFlashAlt.ParticleSystemTemplate);
        }
        if(MuzzleFlashAlt.LightTemplate != none)
        {
            MuzzleFlashAlt.LightComponent = new (self) Class'KFExplosionLightComponent';
            MuzzleFlashAlt.LightComponent.SetTemplate(MuzzleFlashAlt.LightTemplate);
            MuzzleFlashAlt.LightComponent.SetEnabled(false);
            OwnerMesh.AttachComponentToSocket(MuzzleFlashAlt.LightComponent, MuzzleFlashAlt.SocketName);
        }
    }
    if(ShellEjectPSCTemplate != none)
    {
        ShellEjectPSC = new (self) Class'KFParticleSystemComponent';
        ShellEjectPSC.bAutoActivate = false;
        ShellEjectPSC.SetTemplate(ShellEjectPSCTemplate);
        ShellEjectPSC.SetFloatParameter('LifetimeParam', ShellEjectLifetime);
        OwnerMesh.AttachComponentToSocket(ShellEjectPSC, ShellEjectSocketName);
    }
    if(OwnerMesh.DepthPriorityGroup == 2)
    {
        MuzzleFlash.PSC.bDepthTestEnabled = false;
        MuzzleFlashAlt.PSC.bDepthTestEnabled = false;
    }
    if(OwnerMesh.IsA('KFSkeletalMeshComponent'))
    {
        OwnerMeshFOV = KFSkeletalMeshComponent(OwnerMesh).FOV;
        SetFOV(OwnerMeshFOV);
    }
    Owner = OwnerMesh.Owner;
}

simulated event SetFOV(float NewFOV)
{
    MuzzleFlash.PSC.super(KFMuzzleFlash).SetFOV(NewFOV);
    if(MuzzleFlashAlt.PSC != none)
    {
        MuzzleFlashAlt.PSC.super(KFMuzzleFlash).SetFOV(NewFOV);
    }
}

function DetachMuzzleFlash(SkeletalMeshComponent OwnerMesh)
{
    OwnerMesh.DetachComponent(MuzzleFlash.PSC);
    OwnerMesh.DetachComponent(MuzzleFlashAlt.PSC);
    if(MuzzleFlash.LightComponent != none)
    {
        OwnerMesh.DetachComponent(MuzzleFlash.LightComponent);
    }
    if(MuzzleFlashAlt.LightComponent != none)
    {
        OwnerMesh.DetachComponent(MuzzleFlashAlt.LightComponent);
    }
    if(ShellEjectPSC != none)
    {
        OwnerMesh.DetachComponent(ShellEjectPSC);
    }
}

function name GetSocketName()
{
    return MuzzleFlash.SocketName;
}

function name GetAltSocketName()
{
    return MuzzleFlashAlt.SocketName;
}

function CauseShellEject()
{
    if(!Owner.WorldInfo.bDropDetail && ShellEjectPSC != none)
    {
        ShellEjectPSC.ActivateSystem();
    }
}

function SetShellEjectLife(optional float NewLifetime)
{
    NewLifetime = 8;
    if(ShellEjectPSCTemplate != none)
    {
        ShellEjectPSC.SetFloatParameter('LifetimeParam', NewLifetime);
    }
}

defaultproperties
{
    MuzzleFlash=(LightTemplate=none,ParticleSystemTemplate=none,bPSCLoops=false,Duration=0.33,SocketName=MuzzleFlash,TimerName=MuzzleFlashTimer,PSC=KFParticleSystemComponent'Default__KFMuzzleFlash.ParticleSystemComponent0',LightComponent=none,bIsActive=false)
    MuzzleFlashAlt=(LightTemplate=none,ParticleSystemTemplate=none,bPSCLoops=false,Duration=0.33,SocketName=MuzzleFlash,TimerName=MuzzleFlashAltTimer,PSC=KFParticleSystemComponent'Default__KFMuzzleFlash.ParticleSystemComponent1',LightComponent=none,bIsActive=false)
    bAutoActivateShellEject=true
    FireModeAlternateBothEffects=255
    FireModeFireBothEffects=255
    ShellEjectSocketName=ShellEject
    ShellEjectLifetime=10
}