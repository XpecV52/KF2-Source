/*******************************************************************************
 * AICommand_Crawler_LeapToWall generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Crawler_LeapToWall extends AICommand within KFAIController_ZedCrawler;

var KFWallPathNode WallNode;
var NavigationPoint StartLeapNode;
var NavigationPoint EndLeapNode;
var float JumpTime;

static function bool LeapToWall(KFAIController_ZedCrawler AI, NavigationPoint Start, NavigationPoint End, float InJumpTime)
{
    local AICommand_Crawler_LeapToWall Cmd;

    if(AI != none)
    {
        Cmd = new (AI) default.Class;
        if(Cmd != none)
        {
            Cmd.StartLeapNode = Start;
            Cmd.EndLeapNode = End;
            Cmd.JumpTime = InJumpTime;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    Outer.DisableMeleeRangeEventProbing();
    Outer.StopAllLatentMovement();
    GotoState('LeapingToWall');
}

function Popped()
{
    super.Popped();
    Outer.EnableMeleeRangeEventProbing();
}

function bool CanChangeEnemy(Pawn NewEnemy)
{
    return false;
}

function bool NotifyLanded(Vector HitNormal, Actor FloorActor)
{
    Outer.Pawn.SetPhysics(8);
    return true;
}

function bool NotifyFallingHitWall(Vector HitNormal, Actor Wall)
{
    return NotifyHitWall(HitNormal, Wall);
}

function bool NotifyHitWall(Vector HitNormal, Actor HitActor)
{
    if(!HitActor.bCanStepUpOn)
    {
        WarnInternal(((string(GetFuncName()) $ "() Wall ") $ string(HitActor)) $ " bCanStepUpOn is FALSE");
        return false;
    }
    if(Outer.Pawn.Physics == 2)
    {
        Outer.Pawn.SetPhysics(8);
        Outer.Pawn.SetBase(HitActor, HitNormal);
        Outer.DisableNotifyHitWall(1);
    }
    return true;
}

state LeapingToWall
{
    event BeginState(name PreviousStateName)
    {
        Outer.Pawn.ZeroMovementVariables();
    }

    function bool NotifyHitWall(Vector HitNormal, Actor HitActor)
    {
        if(!HitActor.bCanStepUpOn)
        {
            WarnInternal(((string(GetFuncName()) $ "() Wall ") $ string(HitActor)) $ " bCanStepUpOn is FALSE");
            return false;
        }
        if(Outer.Pawn.Physics == 2)
        {
            Outer.Pawn.SetPhysics(8);
            Outer.Pawn.SetBase(HitActor, HitNormal);
            Outer.DisableNotifyHitWall(1);
        }
        return true;
    }

    function bool NotifyLanded(Vector HitNormal, Actor FloorActor)
    {
        if(HitNormal != vect(0, 0, 1))
        {
            Outer.Pawn.SetPhysics(8);
            return true;
        }
        return false;
    }

    function bool DoWallLeap(Actor Target)
    {
        local Vector JumpVel;

        if((Outer.Pawn.Physics == 1) || Outer.Pawn.Physics == 8)
        {
            Outer.MoveTimer = 2;
            JumpVel = Outer.ComputeTrajectoryByTime(Outer.Pawn.Location, Target.Location, JumpTime);
            Outer.MyKFPawn.Velocity = JumpVel;
            Outer.MoveTarget = Target;
            Outer.MyKFPawn.SetPhysics(2);
            return true;
        }
        return false;
    }

    function DoLeap()
    {
        local Vector JumpVel;

        JumpVel = Outer.ComputeTrajectoryByTime(Outer.Pawn.Location, EndLeapNode.Location, JumpTime);
        Outer.Pawn.ZeroMovementVariables();
        if(EndLeapNode.Location.Z > Outer.Pawn.Location.Z)
        {
            JumpVel.Z *= 1.04;
        }
        Outer.MyKFPawn.Velocity = JumpVel;
        Outer.MyKFPawn.SetPhysics(2);
        Outer.SetFocalPoint(vect(0, 0, 0));
        Outer.Focus = EndLeapNode;
    }
Begin:

    DoWallLeap(EndLeapNode);
    Outer.WaitForLanding();
    if(NavigationPoint(Outer.MoveTarget) != none)
    {
        Outer.Pawn.SetAnchor(NavigationPoint(Outer.MoveTarget));
    }
    J0xB4:

    if((Outer.RouteCache.Length > 0) && Outer.RouteCache[0] == Outer.Pawn.Anchor)
    {
        Outer.RouteCache_RemoveIndex(0);
        goto J0xB4;
    }
    Outer.Focus = Outer.RouteCache[0];
    Outer.Pawn.ZeroMovementVariables();
    Outer.Sleep(0.35);
    Outer.RecordLeapToWall();
    Status = 'Success';
    Outer.PopCommand(self);
    stop;            
}

state RotateToFocus
{
    function PushedState()
    {
        super(Object).PushedState();
        Outer.AIActionStatus = "In RotateToFocus state";
    }
Begin:

    Outer.SetFocalPoint(vect(0, 0, 0));
    Outer.Focus = EndLeapNode;
    Outer.FinishRotation();
    Outer.SetFocalPoint(vect(0, 0, 0));
    Outer.Focus = none;
    Outer.Pawn.ResetDesiredRotation();
    PopState();
    stop;            
}

defaultproperties
{
    bAllowedToAttack=false
    bIgnoreNotifies=true
    bIgnoreStepAside=true
}