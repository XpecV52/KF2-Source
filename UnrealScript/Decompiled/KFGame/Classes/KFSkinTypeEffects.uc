/*******************************************************************************
 * KFSkinTypeEffects generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSkinTypeEffects extends Object
    native(Effect)
    config(Engine)
    hidecategories(Object);

const FXG_MAX = 22;

enum EEffectDamageGroup
{
    FXG_Ballistic,
    FXG_Bludgeon,
    FXG_Piercing,
    FXG_Slashing,
    FXG_Fire,
    FXG_Toxic,
    FXG_Healing,
    FXG_Sawblade,
    FXG_DrainLife,
    FXG_IncendiaryRound,
    FXG_UnexplodedGrenade,
    FXG_MicrowaveBlast,
    FXG_ShieldBash,
    FXG_MetalMace,
    FXG_Flare,
    FXG_Freeze,
    FXG_Bludgeon_Chains,
    FXG_MicrowaveProj,
    FXG_Electricity,
    FXG_Slashing_Ion,
    FXG_Energy_Yellow,
    FXG_Energy_Magenta,
    FXG_MAX
};

struct native SkinEffectInfo
{
    /** type for readability in editor */
    var() editoronly editconst KFSkinTypeEffects.EEffectDamageGroup Type;
    /** particle system used for this impact */
    var() ParticleSystem DefaultParticle;
    /** If true, attach particle to the hit bone (e.g. fire) */
    var() bool bAttachParticle<DisplayName=Attach FX To Hit Bone|EditCondition=!bAttachToHitLocation>;
    /** If true, attach particle to hit bone but offset to the location of the hit (e.g. electricity) */
    var() bool bAttachToHitLocation<DisplayName=Attach FX to Hit Location|EditCondition=!bAttachParticle>;
    /** Sound used for this impact */
    var() AkEvent DefaultSound;
    /** Sounds used for local player (1st person) impacts only */
    var() AkEvent LocalSound;
    /** Sound played when I'm the one taking damage */
    var() AkEvent LocalTakeHitSound;

    structdefaultproperties
    {
        Type=EEffectDamageGroup.FXG_Ballistic
        DefaultParticle=none
        bAttachParticle=false
        bAttachToHitLocation=false
        DefaultSound=none
        LocalSound=none
        LocalTakeHitSound=none
    }
};

/** Container for effects per type of damage/weapon */
var() SkinEffectInfo ImpactFXArray[22];
/** Dynamic container for additional modability */
var() array<SkinEffectInfo> CustomEffects;
var config float ImpactParticleEffectInterval;
var float ImpactSoundInterval;

function PlayImpactParticleEffect(KFPawn P, Vector HitLocation, Vector HitDirection, byte HitZoneIndex, KFSkinTypeEffects.EEffectDamageGroup EffectGroup, optional ParticleSystem ForceParticleTemplate)
{
    local ParticleSystem ParticleTemplate;
    local name HitBoneName;

    if(ForceParticleTemplate != none)
    {
        ParticleTemplate = ForceParticleTemplate;        
    }
    else
    {
        ParticleTemplate = GetImpactParticleEffect(EffectGroup);
    }
    if(ParticleTemplate == none)
    {
        return;
    }
    if(ConfigureEmitter(P, HitLocation, HitDirection, HitZoneIndex, HitLocation, HitDirection, HitBoneName, EffectGroup))
    {
        SpawnEmitter(P, ParticleTemplate, HitBoneName, HitLocation, HitDirection);
    }
}

function bool ConfigureEmitter(KFPawn P, Vector InHitLocation, Vector InHitDirection, int HitZoneIndex, out Vector OutHitLocation, out Vector OutHitDirection, out name OutHitBoneName, KFSkinTypeEffects.EEffectDamageGroup EffectGroup)
{
    local int HitBoneIdx;
    local Vector HitDirectionRight, HitDirectionLeft, RelativeHitDirection;

    if(ImpactFXArray[EffectGroup].bAttachParticle)
    {
        if((P.WorldInfo.TimeSeconds - P.LastImpactParticleEffectTime) < ImpactParticleEffectInterval)
        {
            return false;
        }
        OutHitBoneName = ((HitZoneIndex < P.HitZones.Length) ? P.HitZones[HitZoneIndex].BoneName : P.TorsoBoneName);
        OutHitLocation = vect(0, 0, 0);        
    }
    else
    {
        if(ImpactFXArray[EffectGroup].bAttachToHitLocation)
        {
            if(HitZoneIndex >= P.HitZones.Length)
            {
                return false;
            }
            if((P.WorldInfo.TimeSeconds - P.LastImpactParticleEffectTime) < ImpactParticleEffectInterval)
            {
                return false;
            }
            OutHitBoneName = P.HitZones[HitZoneIndex].BoneName;
            HitBoneIdx = P.Mesh.MatchRefBone(OutHitBoneName);
            OutHitLocation = InverseTransformVector(P.Mesh.GetBoneMatrix(HitBoneIdx), InHitLocation);            
        }
        else
        {
            if(P.WorldInfo.bDropDetail || P.WorldInfo.GetDetailMode() == 0)
            {
                if((P.WorldInfo.TimeSeconds - P.LastImpactParticleEffectTime) == float(0))
                {
                    return false;
                }
            }
            switch(EffectGroup)
            {
                case 1:
                case 2:
                case 3:
                case 7:
                    OutHitDirection = -InHitDirection;
                    break;
                default:
                    InHitDirection.Z = 0;
                    HitDirectionRight = InHitDirection Cross vect(0, 0, 1);
                    HitDirectionLeft = -HitDirectionRight;
                    RelativeHitDirection = InHitLocation - P.Location;
                    OutHitDirection = (((HitDirectionRight Dot RelativeHitDirection) >= float(0)) ? HitDirectionRight : HitDirectionLeft);
                    break;
                    break;
            }
        }
    }
    return true;
}

function ParticleSystemComponent SpawnEmitter(KFPawn P, ParticleSystem ParticleTemplate, optional name HitBoneName, optional Vector HitLocation, optional Vector HitDirection)
{
    local editinline ParticleSystemComponent PSC;

    if(HitBoneName != 'None')
    {
        PSC = P.WorldInfo.ImpactFXEmitterPool.SpawnEmitterMeshAttachment(ParticleTemplate, P.Mesh, HitBoneName, false, HitLocation, rotator(HitDirection));
        if(PSC != none)
        {
            PSC.SetAbsolute(false, true, true);
        }        
    }
    else
    {
        PSC = P.WorldInfo.ImpactFXEmitterPool.SpawnEmitter(ParticleTemplate, HitLocation, rotator(HitDirection));
        if(PSC != none)
        {
            PSC.SetLightingChannels(P.PawnLightingChannel);
        }
    }
    if(PSC != none)
    {
        P.LastImpactParticleEffectTime = P.WorldInfo.TimeSeconds;
    }
    return PSC;
}

function ParticleSystem GetImpactParticleEffect(KFSkinTypeEffects.EEffectDamageGroup EffectGroup)
{
    return ImpactFXArray[EffectGroup].DefaultParticle;
}

function PlayTakeHitSound(KFPawn P, Vector HitLocation, Pawn DamageCauser, KFSkinTypeEffects.EEffectDamageGroup EffectGroup, optional AkEvent ForceImpactSound)
{
    local AkEvent ImpactSound;
    local float ArmorPct;

    if(P.ActorEffectIsRelevant(DamageCauser, false, 4000))
    {
        if((P.WorldInfo.TimeSeconds - P.LastImpactSoundTime) < ImpactSoundInterval)
        {
            return;
        }
        if(ForceImpactSound != none)
        {
            ImpactSound = ForceImpactSound;            
        }
        else
        {
            ImpactSound = GetImpactSound(EffectGroup, DamageCauser, P);
        }
        if(ShouldSetArmorValue(P, ArmorPct))
        {
            P.Controller.SetRTPCValue('Armor_Level', ArmorPct, true);
        }
        if(ImpactSound != none)
        {
            P.LastImpactSoundTime = P.WorldInfo.TimeSeconds;
            P.PlaySoundBase(ImpactSound, true,,, HitLocation);
        }
    }
}

function AkEvent GetImpactSound(KFSkinTypeEffects.EEffectDamageGroup EffectGroup, Pawn DamageCauser, Pawn HitPawn)
{
    if((((ImpactFXArray[EffectGroup].LocalSound != none) && DamageCauser != none) && DamageCauser.IsLocallyControlled()) && DamageCauser.IsHumanControlled())
    {
        return ImpactFXArray[EffectGroup].LocalSound;        
    }
    else
    {
        if(((HitPawn.Controller != none) && HitPawn.Controller.IsLocalController()) && ImpactFXArray[EffectGroup].LocalTakeHitSound != none)
        {
            return ImpactFXArray[EffectGroup].LocalTakeHitSound;
        }
    }
    return ImpactFXArray[EffectGroup].DefaultSound;
}

function bool ShouldSetArmorValue(Pawn HitPawn, out float ArmorPct)
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(HitPawn);
    if((((KFPH != none) && KFPH.Controller != none) && KFPH.Controller.IsLocalController()) && KFPH.Armor > 0)
    {
        ArmorPct = float(KFPH.Armor) / float(KFPH.MaxArmor);
        return true;
    }
    return false;
}

defaultproperties
{
    ImpactParticleEffectInterval=0.5
    ImpactSoundInterval=0.05
}