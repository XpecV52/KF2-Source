/*******************************************************************************
 * KFPlayerController generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPlayerController extends GamePlayerController
    native(Controller)
    nativereplication
    config(Game)
    hidecategories(Navigation);

const MAX_AIM_CORRECTION_SIZE = 40.f;

enum EAnalogMovementSpeed
{
    AMOVESPEED,
    AMOVESPEED_1,
    AMOVESPEED_2,
    AMOVESPEED_3,
    AMOVESPEED_MAX
};

enum KFSpectateModes
{
    SMODE_PawnFreeCam,
    SMODE_PawnThirdPerson,
    SMODE_PawnFirstPerson,
    SMODE_Roaming,
    SMODE_MAX
};

enum ETrackingRangeMode
{
    ETR_Custom,
    ETR_10Meters,
    ETR_25Meters,
    ETR_50Meters,
    ETR_100Meters,
    ETR_250Meters,
    ETR_MAX
};

enum ETrackingMode
{
    ETM_All,
    ETM_AllButTargeting,
    ETM_PawnsOnly,
    ETM_PawnsAndTargetingOnly,
    ETM_SpawnsOnly,
    ETM_FailedSpawnsOnly,
    ETM_HumansAndSpawnsOnly,
    ETM_PickupsOnly,
    ETM_MAX
};

enum EGameConductorDebugMode
{
    EGCDM_Skill,
    EGCDM_LifeSpan,
    EGCDM_Status,
    EGCDM_MAX
};

struct native PerkInfo
{
    var class<KFPerk> PerkClass;
    var byte PerkLevel;
    var KFPerk PerkArchetype;

    structdefaultproperties
    {
        PerkClass=none
        PerkLevel=0
        PerkArchetype=none
    }
};

struct native PlayerSteamAvatar
{
    var Texture2D Avatar;
    var UniqueNetId NetId;

    structdefaultproperties
    {
        Avatar=none
        NetId=(Uid=none)
    }
};

struct native ObjectiveAnnouncementInfo
{
    /** the default announcement sound to play (can be None) */
    var() SoundNodeWave AnnouncementSound;
    /** text displayed onscreen for this announcement */
    var() const localized string AnnouncementText;

    structdefaultproperties
    {
        AnnouncementSound=none
        AnnouncementText=""
    }
};

struct native PostWaveReplicationInfo
{
    var Vector VectData1;
    var Vector VectData2;
    var byte LargeZedKills;
    var byte DeathStreakStartWave;
    var byte DeathStreakEndWave;
    var bool bBestTeammate;
    var bool bKilledMostZeds;
    var bool bEarnedMostDosh;
    var bool bAllSurvivedLastWave;
    var bool bSomeSurvivedLastWave;
    var bool bOneSurvivedLastWave;
    var bool bKilledFleshpoundLastWave;
    var bool bKilledScrakeLastWave;
    var class<KFPawn_Monster> ClassKilledByLastWave;
    var byte RepCount;

    structdefaultproperties
    {
        VectData1=(X=0,Y=0,Z=0)
        VectData2=(X=0,Y=0,Z=0)
        LargeZedKills=0
        DeathStreakStartWave=0
        DeathStreakEndWave=0
        bBestTeammate=false
        bKilledMostZeds=false
        bEarnedMostDosh=false
        bAllSurvivedLastWave=false
        bSomeSurvivedLastWave=false
        bOneSurvivedLastWave=false
        bKilledFleshpoundLastWave=false
        bKilledScrakeLastWave=false
        ClassKilledByLastWave=none
        RepCount=0
    }
};

var array<PlayerSteamAvatar> AvatarList;
var array<PerkInfo> PerkList;
var KFPerk CurrentPerk;
var class<KFPerk> ServPendingPerkClass;
var int ServPendingPerkBuild;
var int ServPendingPerkLevel;
var const name MusicMessageType;
var private const bool bPerkStatsLoaded;
var bool bAcuteHearing;
var bool bUsePhysicsRotation;
var bool bIsAchievementPlayer;
var config bool bHideTraderPaths;
var transient bool bClientTraderMenuOpen;
var bool bPlayerUsedUpdatePerk;
var bool bNightVisionActive;
var bool bPerkEffectIsActive;
var bool bGrabEffectIsActive;
var transient bool bPlayingLowHealthSFX;
var bool bCachedSeeZedTimePawn;
var bool bRecursingZedTimeVisibility;
var bool bDOFEnabled;
var bool bGamePlayDOFActive;
var bool bIronSightsDOFActive;
var bool bReflectionsEnabled;
var bool bBlurEnabled;
var protected config bool bDebugTargetAdhesion;
var(AimAssist) protected bool bDebugAutoTarget;
/** Don't use the countdown time, just keep looking at the ForceLookAtPawn */
var() bool bLockToForceLookAtPawn;
var bool bDebugPartialZedTime;
var bool bForcePartialZedTime;
/** If true the tracking map is a top down view, otherwise its a side view */
var(ZedMap) bool bTrackingMapTopView;
var config byte SavedPerkIndex;
var transient KFPlayerController.KFSpectateModes CurrentSpectateMode;
var transient KFPlayerController.ETrackingRangeMode CurrentTrackerRangeMode;
var transient KFPlayerController.ETrackingMode CurrentTrackingMode;
var transient KFPlayerController.EGameConductorDebugMode CurrentGameConductorDebugMode;
var KFPawn_Human UsablePawn;
var KFEmit_CameraEffect CameraEffect;
var PostProcessSettings PostProcessModifier;
var float NextAdminCmdTime;
var int ShotsFired;
var int ShotsHit;
var int ShotsHitHeadshot;
var KFGFxMoviePlayer_Manager MyGFxManager;
var KFGFxMoviePlayer_HUD MyGFxHUD;
var AkEvent ZedTimeEnterSound;
var AkEvent ZedTimeExitSound;
var AkEvent ZedTimePartialEnterSound;
var AkEvent ZedTimePartialExitSound;
var float LastTimeDilation;
var AkEvent PauseWwiseEvent;
var AkEvent ResumeWwiseEvent;
var AkEvent EarsRingingPlayEvent;
var AkEvent EarsRingingStopEvent;
var AkEvent LowHealthStartEvent;
var AkEvent LowHealthStopEvent;
var export editinline AkComponent StingerAkComponent;
var AkEvent ResetFiltersEvent;
var AkEvent FlashlightOnEvent;
var AkEvent FlashlightOffEvent;
var AkEvent NightVisionOnEvent;
var AkEvent NightVisionOffEvent;
var AkEvent AllMapCollectiblesFoundEvent;
var MaterialEffect GameplayPostProcessEffects;
var name GameplayPostProcessEffectName;
var MaterialInstanceConstant GameplayPostProcessEffectMIC;
var name EffectPainParamName;
var name EffectLowHealthParamName;
var name EffectZedTimeParamName;
var name EffectNightVisionParamName;
var name EffectSirenScreamParamName;
var name EffectBloatsPukeParamName;
var name EffectHealParamName;
var name EffectPerkParamName;
var transient float PainEffectDuration;
var transient float PainEffectTimeRemaining;
var transient float HealEffectDuration;
var transient float HealEffectTimeRemaining;
var transient float SonicScreamEffectDuration;
var transient float SirenScreamEffectTimeRemaining;
var transient float BloatPukeEffectDuration;
var transient float BloatPukeEffectTimeRemaining;
var const int LowHealthThreshold;
var transient float TargetZEDTimeEffectIntensity;
var transient float CurrentZEDTimeEffectIntensity;
var transient float ZEDTimeEffectInterpTimeRemaining;
var const float PartialZEDTimeEffectIntensity;
var transient float ExplosionEarRingDuration;
var transient float ExplosionEarRingTimeRemaining;
var transient float ExplosionEarRingEffectIntensity;
var transient float ExplosionEarRingDelay;
var float CachedZedTimeVisibilityTime;
var float ZedTimeSightCounter;
var() export editinline PointLightComponent AmplificationLightTemplate;
var export editinline transient PointLightComponent AmplificationLight;
var private transient float PauseMoveInputTimeLeft;
/** @name Night Vision */
var() export editinline PointLightComponent NVGLightTemplate;
var export editinline transient PointLightComponent NVGLight;
var(DOF) float DOFFocalRange;
var(DOF) float DOFFocalAperture;
/** How quickly for the focus distance to adjust to what the player is currently looking at. This is not directly comparable to time, but the calculation is as BlendRate*Time */
var(DOF) float DOFFocusBlendRate;
var float DOFFocusDepth;
/** What max focus depth we'll use. If this is too far, when the focus trace fails (like tracing against the skybox) we end up blurring the whole screen. So this caps the max distance so this doesn't happen */
var(DOF) float DOFMaxFocusDepth;
/** Maximum angle (in degrees) to an enemy for calculating focal distance */
var(DOF) float DOFStaticFocusDepth;
var(DOF) editconst float DOFMaxEnemyAngle;
var float DOF_GP_LerpControl;
var float DOF_IS_LerpControl;
var float DOF_NVG_BlendInSpeed;
var float DOF_NVG_BlendOutSpeed;
/** Postprocess parameters when Night Vision is enabled */
var(NVG_Post) float NVG_FocusBlendRate;
var(NVG_Post) float NVG_ImageGrainScale;
/** [World] Fixed focal distance for NVG */
var(NVG_Post) float NVG_DOF_FocalDistance;
/** [World] World-unit radius around the focal point that is unblurred. */
var(NVG_Post) float NVG_DOF_SharpRadius;
/** [World] World-unit focal radius that defines how far away from the focal plane ( +/- sharp radius ) the maximum far/near blur radius is reached. */
var(NVG_Post) float NVG_DOF_FocalRadius;
/** [World] Minimum blur size. */
var(NVG_Post) float NVG_DOF_MinBlurSize;
/** [World] Maximum blur size for near-field (objects closer than focal point). */
var(NVG_Post) float NVG_DOF_MaxNearBlurSize;
/** [World] Maximum blur size for far-field (objects more distance than focal point). */
var(NVG_Post) float NVG_DOF_MaxFarBlurSize;
/** < 1 faster than linear transition */
var(NVG_Post) float NVG_DOF_ExpFalloff;
/** Cinematic mode DOF overrides */
var(Cinematic_DOF) float DOF_Cinematic_BlendInSpeed;
var(Cinematic_DOF) float DOF_Cinematic_BlendOutSpeed;
var(Cinematic_DOF) float DOF_Cinematic_FocalDistance;
var(Cinematic_DOF) float DOF_Cinematic_SharpRadius;
var(Cinematic_DOF) float DOF_Cinematic_FocalRadius;
var(Cinematic_DOF) float DOF_Cinematic_MinBlurSize;
var(Cinematic_DOF) float DOF_Cinematic_MaxNearBlurSize;
var(Cinematic_DOF) float DOF_Cinematic_MaxFarBlurSize;
var(Cinematic_DOF) float DOF_Cinematic_ExpFalloff;
/** Gameplay DOF overrides */
var(GP_DOF) float DOF_GP_BlendInSpeed;
var(GP_DOF) float DOF_GP_BlendOutSpeed;
var(GP_DOF) float DOF_GP_FocalDistance;
var(GP_DOF) float DOF_GP_SharpRadius;
var(GP_DOF) float DOF_GP_FocalRadius;
var(GP_DOF) float DOF_GP_MinBlurSize;
var(GP_DOF) float DOF_GP_MaxNearBlurSize;
var(GP_DOF) float DOF_GP_MaxFarBlurSize;
var(GP_DOF) float DOF_GP_ExpFalloff;
var float BlurStrength;
var float BlurBlendInSpeed;
var float BlurBlendOutSpeed;
var float BlurLerpControl;
var private KFOnlineStatsRead StatsRead;
var private KFOnlineStatsWrite StatsWrite;
var repnotify PostWaveReplicationInfo PWRI;
var EphemeralMatchStats MatchStats;
var class<EphemeralMatchStats> MatchStatsClass;
var transient float LastUpdateSpectatorActiveTime;
var transient float UpdateSpectatorActiveInterval;
/** Interp curve to scale autotarget scoring for different ranges */
var(AimAssist) InterpCurveFloat ScoreTargetDistanceCurve;
/** Aim correction */
var(AimAssist) float MaxAimCorrectionDistance;
/** How long to force us to look at a pawn */
var() float ForceLookAtPawnTime;
/** Pawn we're being forced to look at */
var() KFPawn ForceLookAtPawn;
/** Position to draw the tracking map */
var(ZedMap) float TrackerXPosition;
/** Position to draw the tracking map */
var(ZedMap) float TrackerYPosition;
/** Scale to draw the tracking map at */
var(ZedMap) float TrackingMapScale;
/** Position to draw the tracking map */
var(ZedMap) float TrackerSpawnVolumeSizeX;
/** Position to draw the tracking map */
var(ZedMap) float TrackerSpawnVolumeSizeY;
/** Distance range for the tracking map */
var(ZedMap) float TrackingMapRange;

replication
{
     if(bNetDirty)
        CurrentPerk, PWRI;

     if(bNetDirty)
        ForceLookAtPawn, ForceLookAtPawnTime, 
        bLockToForceLookAtPawn;
}

// Export UKFPlayerController::execSetHardwarePhysicsEnabled(FFrame&, void* const)
native function SetHardwarePhysicsEnabled(bool bEnabled);

// Export UKFPlayerController::execIsKeyboardAvailable(FFrame&, void* const)
native simulated function bool IsKeyboardAvailable();

// Export UKFPlayerController::execIsMouseAvailable(FFrame&, void* const)
native simulated function bool IsMouseAvailable();

// Export UKFPlayerController::execGetTargetAdhesionFrictionTarget(FFrame&, void* const)
native function Pawn GetTargetAdhesionFrictionTarget(float MaxDistance, const out Vector CamLoc, const out Rotator CamRot, const InterpCurveFloat TargetingAngle);

// Export UKFPlayerController::execCheckBulletWhip(FFrame&, void* const)
native function CheckBulletWhip(AkEvent BulletWhip, Vector FireLocation, Vector FireDir, Vector HitLocation, Actor ShootActor);

// Export UKFPlayerController::execGetPerk(FFrame&, void* const)
native final simulated function KFPerk GetPerk();

simulated event PreBeginPlay()
{
    super(Actor).PreBeginPlay();
    PostAkEvent(ResetFiltersEvent);
}

simulated event PostBeginPlay()
{
    super(PlayerController).PostBeginPlay();
    MatchStats = new (self) MatchStatsClass;
}

simulated event ReplicatedEvent(name VarName)
{
    super(Controller).ReplicatedEvent(VarName);
    if(VarName == 'Pawn')
    {
        SetAmplificationLightEnabled(Pawn != none);
        ToggleHealthEffects(Pawn != none);
    }
    if(VarName == 'PWRI')
    {
        if((self != none) && self.MatchStats != none)
        {
            self.MatchStats.RecordWaveInfo();
        }
    }
}

simulated event ReceivedPlayer()
{
    super(PlayerController).ReceivedPlayer();
    if((Role == ROLE_Authority) && IsLocalController())
    {
        PlayerReplicationInfo.ClientInitialize(self);
    }
}

simulated function ReceivedGameClass(class<GameInfo> GameClass)
{
    local LocalPlayer LP;

    super(PlayerController).ReceivedGameClass(GameClass);
    LP = LocalPlayer(Player);
    if(LP != none)
    {
        LP.RemoveAllPostProcessingChains();
        LP.InsertPostProcessingChain(LP.Outer.GetWorldPostProcessChain(), -1, true);
        InitGameplayPostProcessFX();
    }
}

event Possess(Pawn aPawn, bool bVehicleTransition)
{
    if(aPawn != none)
    {
        bIsAchievementPlayer = true;
    }
    super(PlayerController).Possess(aPawn, bVehicleTransition);
}

reliable client simulated function ClientRestart(Pawn NewPawn)
{
    super(PlayerController).ClientRestart(NewPawn);
    if(NewPawn == none)
    {
        return;
    }
    UsablePawn = KFPawn_Human(NewPawn);
    FixFOV();
    MyGFxManager.CloseMenus();
    if(WorldInfo.MyGoreEffectManager != none)
    {
        KFGoreManager(WorldInfo.MyGoreEffectManager).ResetPersistantGore(true);
    }
    if((AmplificationLight == none) && AmplificationLightTemplate != none)
    {
        AmplificationLight = new (self) Class'PointLightComponent' (AmplificationLightTemplate);
        Pawn.AttachComponent(AmplificationLight);
    }
    EnableDepthOfField(false);
    bIsAchievementPlayer = true;
    NewPawn.MovementSpeedModifier = 1;
}

reliable client simulated function ClientReset()
{
    ResetGameplayPostProcessFX();
    EnableDepthOfField(false);
    super(PlayerController).ClientReset();
}

function SpawnReconnectedPlayer()
{
    if(WorldInfo.NetMode == NM_Client)
    {
        return;
    }
    WorldInfo.Game.RestartPlayer(self);
}

function ResetPlayerMovementInput()
{
    if(!bCinematicMode)
    {
        super(PlayerController).ResetPlayerMovementInput();
    }
}

event InitInputSystem()
{
    super(PlayerController).InitInputSystem();
    if(OnlineSub != none)
    {
        OnlineSub.RegisterLocalTalker(0);        
    }
    else
    {
        if(NotEqual_InterfaceInterface(VoiceInterface, (none)))
        {
            VoiceInterface.RegisterLocalTalker(0);
        }
    }
    RegisterTalkerDelegate();
}

function CreateCustomizationPawn()
{
    local KFGameInfo KFGI;
    local NavigationPoint BestStart;

    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI == none) || (KFGI.bRestartLevel && WorldInfo.NetMode != NM_DedicatedServer) && WorldInfo.NetMode != NM_ListenServer)
    {
        WarnInternal("bRestartLevel && !server, abort from RestartPlayer" @ string(WorldInfo.NetMode));
        return;
    }
    BestStart = GetBestCustomizationStart(KFGI);
    if(Pawn == none)
    {
        Pawn = KFGI.SpawnCustomizationPawn(BestStart);
    }
    if(KFPawn_Customization(Pawn) != none)
    {
        KFPawn_Customization(Pawn).InitializeCustomizationPawn(self, BestStart);
    }
}

function NavigationPoint GetBestCustomizationStart(KFGameInfo KFGI)
{
    local NavigationPoint BestStartSpot;

    BestStartSpot = KFGI.FindCustomizationStart(self);
    if(BestStartSpot == none)
    {
        BestStartSpot = KFGI.FindPlayerStart(self, 0);
        WarnInternal("No customization points have been found, using PlayerStart instead");
        if(BestStartSpot == none)
        {
            WarnInternal("Player start not found, failed to restart player");
            return none;
        }
    }
    return BestStartSpot;
}

function AddShotsFired(int AddedShots)
{
    ShotsFired += AddedShots;
}

function AddShotsHit(int AddedHits)
{
    ShotsHit += AddedHits;
}

function AddHeadHit(int AddedHits)
{
    ShotsHitHeadshot += AddedHits;
}

function RegisterTalkerDelegate()
{
    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.VoiceInterface, (none)))
    {
        OnlineSub.VoiceInterface.AddPlayerTalkingDelegate(OnPlayerTalking);
    }
}

function OnPlayerTalking(UniqueNetId TalkingPlayer, bool bIsTalking)
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        if(KFPRI.UniqueId == TalkingPlayer)
        {
            KFPRI.VOIPStatusChanged(KFPRI, bIsTalking);
            if(bIsTalking)
            {
                KFPRI.ServerNotifyStartVoip();                
            }
            else
            {
                KFPRI.ServerNotifyStopVOIP();
            }
        }
    }
}

reliable client simulated function ClientStartNetworkedVoice()
{
    local KFPlayerReplicationInfo KFPRI;

    super(PlayerController).ClientStartNetworkedVoice();
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.VOIPStatusChanged(PlayerReplicationInfo, true);
        KFPRI.ServerNotifyStartVoip();
    }
}

reliable client simulated function ClientStopNetworkedVoice()
{
    local KFPlayerReplicationInfo KFPRI;

    super(PlayerController).ClientStopNetworkedVoice();
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.VOIPStatus = 0;
        KFPRI.VOIPStatusChanged(PlayerReplicationInfo, false);
        KFPRI.ServerNotifyStopVOIP();
    }
}

function SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons)
{
    super(PlayerController).SetCinematicMode(bInCinematicMode, bHidePlayer, bAffectsHUD, bAffectsMovement, bAffectsTurning, bAffectsButtons);
    ClientSetIgnoreButtons(bAffectsButtons);
}

reliable client simulated function ClientSetIgnoreButtons(bool bAffectsButtons)
{
    local KFGFxHudWrapper GFxHUDWrapper;

    if(bAffectsButtons && MyGFxManager != none)
    {
        MyGFxManager.CloseMenus();
    }
    GFxHUDWrapper = KFGFxHudWrapper(myHUD);
    if((GFxHUDWrapper != none) && GFxHUDWrapper.HudMovie != none)
    {
        if(bAffectsButtons)
        {
            GFxHUDWrapper.HudMovie.HudChatBox.ClearAndCloseChat();
        }
        GFxHUDWrapper.HudMovie.EatMyInput(bAffectsButtons);
    }
}

simulated function bool IsForceFeedbackAllowed()
{
    local KFPlayerInput KFInput;

    KFInput = KFPlayerInput(PlayerInput);
    return ((KFInput != none) && KFInput.bForceFeedbackEnabled) && super(PlayerController).IsForceFeedbackAllowed();
}

// Export UKFPlayerController::execClientInitializePerks(FFrame&, void* const)
native final function ClientInitializePerks();

// Export UKFPlayerController::execResetPerkStatsLoaded(FFrame&, void* const)
private native final function ResetPerkStatsLoaded();

// Export UKFPlayerController::execLoadAllPerkLevels(FFrame&, void* const)
private native final function LoadAllPerkLevels();

// Export UKFPlayerController::execReadStatsTimeout(FFrame&, void* const)
private native final function ReadStatsTimeout();

// Export UKFPlayerController::execGetLevel(FFrame&, void* const)
native final function byte GetLevel();

// Export UKFPlayerController::execSetActivePerkLevel(FFrame&, void* const)
private native final simulated function SetActivePerkLevel(byte NewLevel);

// Export UKFPlayerController::execServerSetLevel(FFrame&, void* const)
private reliable server native final event ServerSetLevel(class<KFPerk> PerkClass, byte NewLevel);

// Export UKFPlayerController::execClientSetLevelCheat(FFrame&, void* const)
private reliable server native final event ClientSetLevelCheat(byte NewLevel);

// Export UKFPlayerController::execRequestPerkChange(FFrame&, void* const)
native final event RequestPerkChange(byte NewPerkIndex);

// Export UKFPlayerController::execServerSetPendingPerkUpdate(FFrame&, void* const)
private reliable server native final event ServerSetPendingPerkUpdate(byte NewPerkIndex, int NewPerkBuild, byte NewLevel);

// Export UKFPlayerController::execServerSelectPerk(FFrame&, void* const)
private reliable server native final event ServerSelectPerk(byte NewPerkIndex, byte NewLevel);

// Export UKFPlayerController::execCanUpdatePerkInfo(FFrame&, void* const)
native final function bool CanUpdatePerkInfo();

// Export UKFPlayerController::execApplyPendingPerks(FFrame&, void* const)
native final function ApplyPendingPerks();

static function string GetPerkName(int Index)
{
    return default.PerkList[Index].PerkClass.default.PerkName;
}

unreliable server function ServerCallOutPawnCloaking(KFPawn_Monster CloakedPawn)
{
    if(CloakedPawn != none)
    {
        CloakedPawn.CallOutCloaking(self);
    }
}

simulated event UpdatePerkLevelMenu(class<KFPerk> PerkClass)
{
    local KFGFxMenu_Perks PerkMenu;

    if(MyGFxManager != none)
    {
        PerkMenu = KFGFxMenu_Perks(MyGFxManager.CurrentMenu);
        if(PerkMenu != none)
        {
            PerkMenu.UpdateContainers(PerkClass);
        }
    }
}

event SetHaveUpdatePerk(bool bUsedUpdate)
{
    bPlayerUsedUpdatePerk = bUsedUpdate;
}

event NotifyPendingPerkChanges()
{
    ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 13, PlayerReplicationInfo);
}

event NotifyPerkUpdated()
{
    ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 14, PlayerReplicationInfo);
}

function NotifyXPGain(class<KFPerk> PerkClass, int Amount)
{
    if((((PerkClass != none) && MyGFxHUD != none) && MyGFxHUD.PlayerStatusContainer != none) && IsLocalController())
    {
        MyGFxHUD.PlayerStatusContainer.UpdateXP(Amount, 0, false, PerkClass);
    }
    if(((self != none) && self.MatchStats != none) && PerkClass != none)
    {
        self.MatchStats.RecordPerkXPGain(PerkClass, Amount);
    }
}

function NotifyLevelUp(class<KFPerk> PerkClass, byte PerkLevel)
{
    local bool bTierUnlocked;

    if((PerkClass != none) && IsLocalController())
    {
        if((PerkLevel % 5) == 0)
        {
            bTierUnlocked = true;
            Class'KFPerk'.static.SaveTierUnlockToConfig(PerkClass, 1, PerkLevel);
            Class'KFLocalMessage_Priority'.static.ClientReceive(self, 10);            
        }
        else
        {
            bTierUnlocked = false;
            Class'KFLocalMessage_Priority'.static.ClientReceive(self, 9);
        }
        MyGFxHUD.LevelUpNotificationWidget.ShowLevelUpNotification(PerkClass, PerkLevel, bTierUnlocked);
        PerkList[GetPerkIndexFromClass(PerkClass)].PerkLevel = PerkLevel;
        if(CurrentPerk.Class == PerkClass)
        {
            SetActivePerkLevel(PerkLevel);
            if(bTierUnlocked)
            {
                PostTierUnlock(PerkClass);
            }
        }
        UpdatePerkLevelMenu(PerkClass);
        ClientWriteAndFlushStats();
    }
    if(Role == ROLE_Authority)
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayLevelUpDialog(self);
        }        
    }
    else
    {
        ServerPlayLevelUpDialog();
    }
}

function PostTierUnlock(class<KFPerk> PerkClass)
{
    local int PerkBuild;
    local byte SelectedSkillsHolder[5];

    PerkBuild = GetPerkBuildByPerkClass(PerkClass);
    GetPerk().GetUnpackedSkillsArray(PerkClass, PerkBuild, SelectedSkillsHolder);
    CurrentPerk.UpdatePerkBuild(SelectedSkillsHolder, PerkClass);
}

event int GetPerkIndexFromClass(class<KFPerk> InPerkClass)
{
    return PerkList.Find('PerkClass', InPerkClass;
}

function PlayRMEffect(AkEvent RhythmMethodSound, name RhytmMethodRTPCName, int Level)
{
    SetRTPCValue(RhytmMethodRTPCName, float(Level), true);
    PlayAkEvent(RhythmMethodSound);
}

// Export UKFPlayerController::execSetViewTarget(FFrame&, void* const)
native function SetViewTarget(Actor NewViewTarget, optional ViewTargetTransitionParams TransitionParams);

// Export UKFPlayerController::execChooseRandomCameraAnim(FFrame&, void* const)
native final simulated function int ChooseRandomCameraAnim(const out array<CameraAnim> Anims, optional float Scale, optional bool bDoNotRandomize)
{
    Scale = 1;                        
}

// Export UKFPlayerController::execCameraAnimHasEnoughSpace(FFrame&, void* const)
native final simulated function bool CameraAnimHasEnoughSpace(CameraAnim Anim, optional float Scale)
{
    Scale = 1;                
}

// Export UKFPlayerController::execUpdateDOF(FFrame&, void* const)
native final function UpdateDOF(float DeltaTime);

// Export UKFPlayerController::execUpdateDOFGamePlayLerpControl(FFrame&, void* const)
native final function UpdateDOFGamePlayLerpControl(float DeltaTime);

// Export UKFPlayerController::execUpdateDOFIronSightsLerpControl(FFrame&, void* const)
native final function UpdateDOFIronSightsLerpControl(float DeltaTime);

// Export UKFPlayerController::execUpdateFullscreenBlur(FFrame&, void* const)
native final function UpdateFullscreenBlur(float DeltaTime);

exec function ShowTestDownloadNotification(string ItemName, float PercentComplete, int ItemsRemaining)
{
    if((MyGFxManager != none) && MyGFxManager.PartyWidget != none)
    {
        MyGFxManager.PartyWidget.ShowDownLoadNotification(ItemName, PercentComplete, ItemsRemaining);
    }
}

exec function ToggleScreenShotMode()
{
    myHUD.ToggleHUD();
    if((Pawn != none) && KFWeapon(Pawn.Weapon) != none)
    {
        KFWeapon(Pawn.Weapon).bForceHidden = !myHUD.bShowHUD;
    }
}

function RemoveCameraEffect(KFEmit_CameraEffect CamEmitter)
{
    if(CameraEffect == CamEmitter)
    {
        CameraEffect = none;
    }
}

unreliable client simulated function ClientSpawnCameraEffect(class<KFEmit_CameraEffect> CameraEffectClass)
{
    local Vector CamLoc;
    local Rotator CamRot;

    if((CameraEffectClass != none) && CameraEffect == none)
    {
        CameraEffect = Spawn(CameraEffectClass, self);
        if(CameraEffect != none)
        {
            GetPlayerViewPoint(CamLoc, CamRot);
            CameraEffect.RegisterCamera(self);
            CameraEffect.UpdateLocation(CamLoc, CamRot, FOVAngle);
        }
    }
}

function ClearCameraEffect()
{
    if(CameraEffect != none)
    {
        CameraEffect.Destroy();
        CameraEffect = none;
    }
}

simulated function HandleTransitionFOVAspectAdjusted(float NewFOV, float TransitionTime)
{
    local float AdjustedFOV;

    if((PlayerCamera != none) && KFPlayerCamera(PlayerCamera) != none)
    {
        AdjustedFOV = CalcFOVForAspectRatio(NewFOV, myHUD.SizeX, myHUD.SizeY);
        KFPlayerCamera(PlayerCamera).TransitionFOV(AdjustedFOV, TransitionTime);
    }
}

simulated function HandleTransitionFOV(float NewFOV, float TransitionTime)
{
    if((PlayerCamera != none) && KFPlayerCamera(PlayerCamera) != none)
    {
        KFPlayerCamera(PlayerCamera).TransitionFOV(NewFOV, TransitionTime);
    }
}

simulated function NotifyResolutionChanged(float NewSizeX, float NewSizeY)
{
    local float AspectRatio, NewFOV, UsedPlayerIronSightFOV;
    local KFWeapon KFWeap;

    AspectRatio = NewSizeX / NewSizeY;
    NewFOV = CalcFOVForAspectRatio(PlayerCamera.default.DefaultFOV, NewSizeX, NewSizeY);
    if(AspectRatio >= 1.77)
    {        
    }
    else
    {
        if(AspectRatio >= 1.7)
        {            
        }
    }
    DefaultFOV = NewFOV;
    PlayerCamera.DefaultFOV = NewFOV;
    if((Pawn != none) && KFInventoryManager(Pawn.InvManager) != none)
    {
        KFInventoryManager(Pawn.InvManager).InitFOV(NewSizeX, NewSizeY, DefaultFOV);
    }
    if((PlayerCamera != none) && KFPlayerCamera(PlayerCamera) != none)
    {
        if(Pawn != none)
        {
            KFWeap = KFWeapon(Pawn.Weapon);
        }
        if((KFWeap != none) && KFWeap.bUsingSights)
        {
            UsedPlayerIronSightFOV = KFWeap.PlayerIronSightFOV;
            KFPlayerCamera(PlayerCamera).TransitionFOV(UsedPlayerIronSightFOV, 0);            
        }
        else
        {
            KFPlayerCamera(PlayerCamera).TransitionFOV(DefaultFOV, 0);
        }
    }
}

static function float CalcFOVForAspectRatio(float OriginalFOV, float SizeX, float SizeY)
{
    local float AspectRatio, OriginalAspectRatio, NewFOV;

    if(SizeY > float(0))
    {
        AspectRatio = SizeX / SizeY;
        OriginalAspectRatio = 16 / float(9);
        NewFOV = (Atan2(Tan((OriginalFOV * 3.141593) / 360) * (AspectRatio / OriginalAspectRatio), 1) * 360) / 3.141593;
    }
    if(NewFOV == float(0))
    {
        LogInternal((((("*** BAD FOV CALC DETECTED ***" @ string(GetFuncName())) @ "SizeX=") $ string(SizeX)) @ "SizeY=") $ string(SizeY));
    }
    return NewFOV;
}

function FixFOV()
{
    if(myHUD != none)
    {
        if(PlayerCamera != none)
        {
            FOVAngle = CalcFOVForAspectRatio(PlayerCamera.default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);
            DesiredFOV = CalcFOVForAspectRatio(PlayerCamera.default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);
            DefaultFOV = CalcFOVForAspectRatio(PlayerCamera.default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);            
        }
        else
        {
            FOVAngle = CalcFOVForAspectRatio(default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);
            DesiredFOV = CalcFOVForAspectRatio(default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);
            DefaultFOV = CalcFOVForAspectRatio(default.DefaultFOV, myHUD.SizeX, myHUD.SizeY);
        }        
    }
    else
    {
        FOVAngle = PlayerCamera.default.DefaultFOV;
        DesiredFOV = PlayerCamera.default.DefaultFOV;
        DefaultFOV = PlayerCamera.default.DefaultFOV;
    }
    if((myHUD != none) && KFPlayerCamera(PlayerCamera) != none)
    {
        KFPlayerCamera(PlayerCamera).TransitionFOV(DefaultFOV, 0);
    }
}

function ResetFOV()
{
    super(PlayerController).ResetFOV();
    if(KFPlayerCamera(PlayerCamera) != none)
    {
        KFPlayerCamera(PlayerCamera).TransitionFOV(PlayerCamera.DefaultFOV, 0);
    }
}

reliable client simulated function ClientSetCameraMode(name NewCamMode)
{
    local KFPawn KFP;
    local KFPawn_MonsterBoss KFBoss;

    if(PlayerCamera != none)
    {
        PlayerCamera.CameraStyle = NewCamMode;
    }
    KFP = KFPawn(ViewTarget);
    if(KFP != none)
    {
        KFP.SetMeshVisibility(NewCamMode != 'FirstPerson');
        KFP.bEnableAimOffset = NewCamMode != 'Fixed';
    }
    if(NewCamMode == 'Boss')
    {
        KFBoss = GetBoss();
        SetNightVision(false);
        if(((KFBoss != none) && KFBoss.Health > 0) && !PlayerReplicationInfo.bIsSpectator)
        {
            if(KFGameReplicationInfo(WorldInfo.GRI).AnyPlayersAlive())
            {
                ShowBossNameplate(KFBoss);
            }
        }
        if(!ViewTarget.IsA('KFPawn_MonsterBoss'))
        {
            SetViewTarget(KFBoss);
        }        
    }
    else
    {
        HideBossNamePlate();
        if((NewCamMode == 'FirstPerson') && !PlayerReplicationInfo.bIsSpectator)
        {
            if((Pawn != none) && ViewTarget != Pawn)
            {
                SetViewTarget(Pawn);
            }
        }
    }
}

function KFPawn_MonsterBoss GetBoss()
{
    local KFPawn_MonsterBoss KFBoss;

    foreach WorldInfo.AllPawns(Class'KFPawn_MonsterBoss', KFBoss)
    {        
        return KFBoss;        
    }    
    return none;
}

function SetCameraMode(name NewCamMode)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.CameraStyle = NewCamMode;
        if(WorldInfo.Role == ROLE_Authority)
        {
            ClientSetCameraMode(NewCamMode);
        }
    }
}

simulated function bool LandingShake()
{
    return true;
}

function ProcessViewRotation(float DeltaTime, out Rotator out_ViewRotation, Rotator DeltaRot)
{
    if((Pawn != none) && KFWeapon(Pawn.Weapon) != none)
    {
        KFWeapon(Pawn.Weapon).WeaponProcessViewRotation(self, DeltaTime, DeltaRot);
    }
    super(PlayerController).ProcessViewRotation(DeltaTime, out_ViewRotation, DeltaRot);
}

function SetBossCamera(Pawn Boss)
{
    local KFPawn_MonsterBoss KFPMBoss;

    KFPMBoss = KFPawn_MonsterBoss(Boss);
    if((Boss == none) || (KFPMBoss != none) && KFPMBoss.HitFxInfo.bObliterated)
    {
        SetLocation(Boss.Location);
    }
    SetViewTarget(Boss);
    ServerCamera('Boss');
}

event ResetCameraMode()
{
    if((PlayerCamera != none) && PlayerCamera.CameraStyle != 'Boss')
    {
        super(PlayerController).ResetCameraMode();
    }
}

simulated function EnableDepthOfField(bool bEnableDOF, optional float StaticDOFDistance, optional float Aperture)
{
    DOFStaticFocusDepth = StaticDOFDistance;
    DOFFocalAperture = Aperture;
    bDOFEnabled = bEnableDOF;
}

simulated function EnableBlur(bool bEnableBlur, float BlurAmount, float InSpeed, float OutSpeed)
{
    bBlurEnabled = bEnableBlur;
    if(bBlurEnabled)
    {
        BlurStrength = BlurAmount;
    }
    BlurBlendInSpeed = InSpeed;
    BlurBlendOutSpeed = OutSpeed;
}

simulated function EnableIronSights(bool bEnableIronSights)
{
    bIronSightsDOFActive = bEnableIronSights;
}

simulated function EnableReflections(bool bEnabled)
{
    bReflectionsEnabled = bEnabled;
}

exec function Camera(name NewMode);

function bool AdminCmdOk()
{
    if((WorldInfo.NetMode == NM_ListenServer) && LocalPlayer(Player) != none)
    {
        return true;
    }
    if(WorldInfo.TimeSeconds < NextAdminCmdTime)
    {
        return false;
    }
    NextAdminCmdTime = WorldInfo.TimeSeconds + 5;
    return true;
}

exec function AdminLogin(string Password)
{
    if((Password != "") && AdminCmdOk())
    {
        ServerAdminLogin(Password);
    }
}

private reliable server final function ServerAdminLogin(string Password)
{
    if((WorldInfo.Game.AccessControl != none) && AdminCmdOk())
    {
        if(WorldInfo.Game.AccessControl.AdminLogin(self, Password))
        {
            WorldInfo.Game.AccessControl.AdminEntered(self);
        }
    }
}

exec function AdminLogout()
{
    if(AdminCmdOk())
    {
        ServerAdminLogOut();
    }
}

private reliable server final function ServerAdminLogOut()
{
    if(WorldInfo.Game.AccessControl != none)
    {
        if(WorldInfo.Game.AccessControl.AdminLogout(self))
        {
            WorldInfo.Game.AccessControl.AdminExited(self);
        }
    }
}

exec function Admin(string CommandLine)
{
    if(PlayerReplicationInfo.bAdmin)
    {
        ServerAdmin(CommandLine);
    }
}

private reliable server final function ServerAdmin(string CommandLine)
{
    local string Result;

    if(PlayerReplicationInfo.bAdmin)
    {
        Result = ConsoleCommand(CommandLine);
        if(Result != "")
        {
            ClientMessage(Result);
        }
    }
}

reliable client simulated event ClientWasKicked()
{
    if(IsPrimaryPlayer())
    {
        ClientSetProgressMessage(4, Class'KFLocalMessage'.default.KickedFromServerString, Localize("Errors", "ConnectionFailed_Title", "Engine"));        
        ConsoleCommand("DISCONNECT TWFORCED");
    }
}

// Export UKFPlayerController::execPickAimAtTarget(FFrame&, void* const)
private native final function Pawn PickAimAtTarget(out float bestAim, out float bestDist, Vector FireDir, Vector projStart, float MaxRange, optional bool bTargetTeammates)
{
    bTargetTeammates = false;                                
}

exec function SwitchToBestWeapon(optional bool bForceNewWeapon)
{
    if(((Pawn != none) && Pawn.Weapon != none) && KFWeapon(Pawn.Weapon) != none)
    {
        if(!KFWeapon(Pawn.Weapon).CanSwitchWeapons())
        {
            return;
        }
    }
    super(Controller).SwitchToBestWeapon(bForceNewWeapon);
}

function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    local Vector FireDir, HitLocation, HitNormal;
    local Actor BestTarget, HitActor;
    local float bestAim, bestDist;
    local bool bNoAimCorrection, bInstantHit;
    local Rotator BaseAimRot;

    bInstantHit = (W == none) || W.bInstantHit;
    BaseAimRot = ((Pawn != none) ? Pawn.GetBaseAimRotation() : Rotation);
    if(W != none)
    {
        BaseAimRot += WeaponBufferRotation;
    }
    if((Role < ROLE_Authority) && !AimingHelp(bInstantHit))
    {
        return BaseAimRot;
    }
    FireDir = vector(BaseAimRot);
    HitActor = Trace(HitLocation, HitNormal, StartFireLoc + (W.GetTraceRange() * FireDir), StartFireLoc, true);
    if((HitActor != none) && HitActor.bProjTarget)
    {
        BestTarget = HitActor;
        bNoAimCorrection = true;
        bestDist = VSize(BestTarget.Location - Pawn.Location);        
    }
    else
    {
        bestAim = 0.9;
        if(AimingHelp(bInstantHit))
        {
            bestAim = AimHelpDot(bInstantHit);            
        }
        else
        {
            if(bInstantHit)
            {
                bestAim = 1;
            }
        }
        BestTarget = PickAimAtTarget(bestAim, bestDist, FireDir, StartFireLoc, W.WeaponRange);
        if(BestTarget == none)
        {
            return BaseAimRot;
        }
    }
    ShotTarget = Pawn(BestTarget);
    if(!AimingHelp(bInstantHit))
    {
        return BaseAimRot;
    }
    if(!bNoAimCorrection && W != none)
    {
        ProcessAimCorrection(ShotTarget, KFWeapon(W), StartFireLoc, BaseAimRot);
    }
    return BaseAimRot;
}

function ProcessAimCorrection(Pawn Target, KFWeapon W, Vector StartLoc, out Rotator AimRot)
{
    local Vector AimLoc, TargetLoc, HeadLoc;
    local Vector2D Offset;
    local float Distance, AimCorrection;
    local KFPawn KFP;

    if((W == none) || W.AimCorrectionSize <= float(0))
    {
        return;
    }
    HeadLoc = Target.Mesh.GetBoneLocation('head');
    Distance = VSize(HeadLoc - StartLoc);
    if(IsZero(HeadLoc) || Distance > MaxAimCorrectionDistance)
    {
        return;
    }
    AimLoc = StartLoc + (vector(AimRot) * Distance);
    TargetLoc = HeadLoc;
    TargetLoc.Z = AimLoc.Z;
    Offset.X = PointDistToLine(AimLoc, TargetLoc - StartLoc, StartLoc);
    TargetLoc = HeadLoc;
    TargetLoc.X = AimLoc.X;
    TargetLoc.Y = AimLoc.Y;
    Offset.Y = PointDistToLine(AimLoc, TargetLoc - StartLoc, StartLoc);
    AimCorrection = FMin(W.AimCorrectionSize, 40);
    if(self.WorldInfo.TimeDilation < 1)
    {
        AimCorrection *= 0.5;
    }
    if((Offset.X <= AimCorrection) && Offset.Y <= AimCorrection)
    {
        KFP = KFPawn(Target);
        if((KFP != none) && KFP.IsHeadless())
        {
            return;
        }
        AimRot = rotator(HeadLoc - StartLoc);
    }
}

reliable server function ServerThrowOtherWeapon(Weapon W)
{
    if(((W != none) && W.Instigator == Pawn) && W.CanThrow())
    {
        Pawn.TossInventory(W);
    }
}

function HandleWalking()
{
    local bool bShouldSprint;

    if(Pawn != none)
    {
        if(Pawn.Weapon != none)
        {
            Pawn.SetWalking(Pawn.Weapon.ShouldOwnerWalk());            
        }
        else
        {
            Pawn.SetWalking(false);
        }
        bShouldSprint = (bRun != 0) && !IsZero(Pawn.Acceleration);
        if(bShouldSprint)
        {
            bDuck = 0;
        }
        KFPawn(Pawn).SetSprinting(bShouldSprint);
    }
}

function CheckJumpOrDuck()
{
    if(Pawn == none)
    {
        return;
    }
    if(bPressedJump)
    {
        Pawn.DoJump(bUpdating);
    }
    if((Pawn.Physics != 2) && Pawn.bCanCrouch)
    {
        Pawn.ShouldCrouch((bDuck != 0) && bRun == 0);
    }
}

function PauseMoveInput(optional float PauseTime)
{
    PauseTime = 0.5;
    if(((IsLocalPlayerController()) && PauseTime > 0) && PauseMoveInputTimeLeft == 0)
    {
        IgnoreMoveInput(true);
        PauseMoveInputTimeLeft = PauseTime;
    }
}

function TickPauseMoveInput(float DeltaTime)
{
    local float RealDeltaTime;

    if(PauseMoveInputTimeLeft > 0)
    {
        RealDeltaTime = DeltaTime / WorldInfo.TimeDilation;
        PauseMoveInputTimeLeft -= RealDeltaTime;
        if(PauseMoveInputTimeLeft <= float(0))
        {
            IgnoreMoveInput(false);
            PauseMoveInputTimeLeft = 0;
        }
    }
}

unreliable server function ServerMove(float TimeStamp, Vector InAccel, Vector ClientLoc, byte MoveFlags, byte ClientRoll, int View, optional int FreeAimRot)
{
    local Rotator NewFreeAimRot;
    local int FreeAimPitch, FreeAimYaw;

    if((Pawn != none) && Pawn.Weapon != none)
    {
        FreeAimPitch = FreeAimRot & 65535;
        FreeAimYaw = FreeAimRot >> 16;
        NewFreeAimRot.Pitch = FreeAimPitch;
        NewFreeAimRot.Yaw = FreeAimYaw;
        WeaponBufferRotation = NewFreeAimRot;
    }
    super(PlayerController).ServerMove(TimeStamp, InAccel, ClientLoc, MoveFlags, ClientRoll, View, FreeAimRot);
}

unreliable server function DualServerMove(float TimeStamp0, Vector InAccel0, byte PendingFlags, int View0, float TimeStamp, Vector InAccel, Vector ClientLoc, byte NewFlags, byte ClientRoll, int View, optional int FreeAimRot0, optional int FreeAimRot)
{
    ServerMove(TimeStamp0, InAccel0, vect(1, 2, 3), PendingFlags, ClientRoll, View0, FreeAimRot0);
    ServerMove(TimeStamp, InAccel, ClientLoc, NewFlags, ClientRoll, View, FreeAimRot);
}

function CallServerMove(SavedMove NewMove, Vector ClientLoc, byte ClientRoll, int View, SavedMove OldMove)
{
    local Vector BuildAccel;
    local byte OldAccelX, OldAccelY, OldAccelZ;
    local int FreeAimRot;

    FreeAimRot = ((WeaponBufferRotation.Yaw & 65535) << 16) + (WeaponBufferRotation.Pitch & 65535);
    if(OldMove != none)
    {
        BuildAccel = (0.05 * OldMove.Acceleration) + vect(0.5, 0.5, 0.5);
        OldAccelX = byte(CompressAccel(int(BuildAccel.X)));
        OldAccelY = byte(CompressAccel(int(BuildAccel.Y)));
        OldAccelZ = byte(CompressAccel(int(BuildAccel.Z)));
        OldServerMove(OldMove.TimeStamp, OldAccelX, OldAccelY, OldAccelZ, OldMove.CompressedFlags());
    }
    if(PendingMove != none)
    {
        DualServerMove(PendingMove.TimeStamp, PendingMove.Acceleration * float(10), PendingMove.CompressedFlags(), ((PendingMove.Rotation.Yaw & 65535) << 16) + (PendingMove.Rotation.Pitch & 65535), NewMove.TimeStamp, NewMove.Acceleration * float(10), ClientLoc, NewMove.CompressedFlags(), ClientRoll, View, ((PendingMove.WeaponBufferRotation.Yaw & 65535) << 16) + (PendingMove.WeaponBufferRotation.Pitch & 65535), FreeAimRot);        
    }
    else
    {
        ServerMove(NewMove.TimeStamp, NewMove.Acceleration * float(10), ClientLoc, NewMove.CompressedFlags(), ClientRoll, View, FreeAimRot);
    }
    if((PlayerCamera != none) && PlayerCamera.bUseClientSideCameraUpdates)
    {
        PlayerCamera.bShouldSendClientSideCameraUpdate = true;
    }
}

function float GetServerMoveDeltaTime(float TimeStamp)
{
    MaxResponseTime = default.MaxResponseTime * WorldInfo.TimeDilation;
    return super(PlayerController).GetServerMoveDeltaTime(TimeStamp);
}

function ModifyUpdateRotation(float DeltaTime, out Rotator DeltaRot)
{
    local KFPlayerInput KFInput;

    KFInput = KFPlayerInput(PlayerInput);
    if(((Pawn != none) && ForceLookAtPawn != none) && (ForceLookAtPawnTime >= float(0)) || bLockToForceLookAtPawn)
    {
        if(!bLockToForceLookAtPawn)
        {
            ForceLookAtPawnTime -= DeltaTime;
        }
        KFInput.ApplyForceLookAtPawn(DeltaTime, DeltaRot.Yaw, DeltaRot.Pitch);
        if(!bLockToForceLookAtPawn && ForceLookAtPawnTime <= float(0))
        {
            ForceLookAtPawn = none;
        }        
    }
    else
    {
        if(((Pawn != none) && KFInput.CurrentAutoTarget != none) && KFInput.AutoTargetTimeLeft >= float(0))
        {
            KFInput.ApplyAutoTarget(DeltaTime, KFWeapon(Pawn.Weapon), DeltaRot.Yaw, DeltaRot.Pitch);            
        }
        else
        {
            if((KFInput.IsAimAssistAdhesionEnabled() && Pawn != none) && (PlayerInput.aForward != float(0)) || PlayerInput.aStrafe != float(0))
            {
                KFInput.ApplyTargetAdhesion(DeltaTime, KFWeapon(Pawn.Weapon), DeltaRot.Yaw, DeltaRot.Pitch);
            }
        }
    }
}

simulated function StartAutoTargeting()
{
    local KFPlayerInput KFInput;

    if(!IsLocalController())
    {
        return;
    }
    if(!PlayerInput.bUsingGamepad)
    {
        return;
    }
    KFInput = KFPlayerInput(PlayerInput);
    KFInput.InitAutoTarget();
}

function bool AimingHelp(bool bInstantHit)
{
    if((((PlayerInput != none) && PlayerInput.bUsingGamepad) && MaxAimCorrectionDistance > 0) && IsLocalController())
    {
        return true;
    }
    return false;
}

static simulated function KFInterface_Usable GetCurrentUsableActor(Pawn P, optional bool bUseOnFind)
{
    local KFInterface_Usable UsableActor;
    local Actor A, BestActor;
    local KFInterface_Usable BestUsableActor;
    local int InteractionIndex, BestInteractionIndex;

    bUseOnFind = false;
    BestInteractionIndex = -1;
    if(P != none)
    {
        foreach P.TouchingActors(Class'Actor', A)
        {
            UsableActor = KFInterface_Usable(A);
            if(NotEqual_InterfaceInterface(UsableActor, (none)) && UsableActor.GetIsUsable(P))
            {
                InteractionIndex = UsableActor.GetInteractionIndex();
                if(InteractionIndex > BestInteractionIndex)
                {
                    BestInteractionIndex = InteractionIndex;
                    BestUsableActor = UsableActor;
                    BestActor = A;
                }
            }            
        }        
        if(NotEqual_InterfaceInterface(BestUsableActor, (none)))
        {
            if(bUseOnFind)
            {
                BestActor.UsedBy(P);
            }
            return BestUsableActor;
        }
    }
    return none;
}

function bool TriggerInteracted()
{
    if(super(PlayerController).TriggerInteracted())
    {
        return true;
    }
    if(Pawn != none)
    {
        GetCurrentUsableActor(Pawn, true);
    }
    return false;
}

reliable client simulated event ReceiveLocalizedMessage(class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    local string TempMessage;

    if((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.GRI == none)
    {
        return;
    }
    if((Message == Class'KFLocalMessage_Game') && MyGFxHUD != none)
    {
        TempMessage = Class'KFLocalMessage_Game'.static.GetString(Switch, true, RelatedPRI_1, RelatedPRI_2, OptionalObject);
        if(TempMessage != "")
        {
            MyGFxHUD.ShowNonCriticalMessage(TempMessage);
        }        
    }
    else
    {
        super(PlayerController).ReceiveLocalizedMessage(Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
    }
}

function SetPendingInteractionMessage()
{
    SetTimer(0.01, false, 'UpdatePendingInteractionMessage');
}

function UpdatePendingInteractionMessage()
{
    if(Pawn != none)
    {
        UpdateInteractionMessages(Pawn);
    }
}

static function UpdateInteractionMessages(Actor InteractingActor)
{
    local KFInterface_Usable UsableActor;
    local Pawn P;
    local PlayerController PC;

    P = Pawn(InteractingActor);
    if(P != none)
    {
        PC = PlayerController(P.Controller);
        if(PC != none)
        {
            UsableActor = GetCurrentUsableActor(P);
            if(NotEqual_InterfaceInterface(UsableActor, (none)))
            {
                PC.SetTimer(1, true, 'CheckCurrentUsableActor', PC);
                PC.ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', UsableActor.GetInteractionIndex());                
            }
            else
            {
                PC.ClearTimer('CheckCurrentUsableActor', PC);
                PC.ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 0);
            }
        }
    }
}

function CheckCurrentUsableActor()
{
    local KFInterface_Usable UsableActor;

    UsableActor = GetCurrentUsableActor(Pawn);
    if(NotEqual_InterfaceInterface(UsableActor, (none)))
    {
        ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', UsableActor.GetInteractionIndex());        
    }
    else
    {
        ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 0);
        ClearTimer('CheckCurrentUsableActor');
    }
}

simulated function PlayScreenHitFX(class<KFDamageType> KFDT, bool bShowPainEffect)
{
    PlayScreenEffects(KFDT);
    PlayScreenMaterialEffects(KFDT, bShowPainEffect);
}

simulated function PlayScreenEffects(class<KFDamageType> KFDT)
{
    local class<EmitterCameraLensEffectBase> LensEffectTemplate;
    local KFPerk MyKFPerk;

    MyKFPerk = GetPerk();
    if(((Pawn != none) && Pawn.IsFirstPerson()) && MyKFPerk != none)
    {
        if((GetEffectTimeRemaining(KFDT)) <= float(0))
        {
            LensEffectTemplate = MyKFPerk.GetPerkLensEffect(KFDT);
            if(LensEffectTemplate != none)
            {
                ClientSpawnCameraLensEffect(LensEffectTemplate);
            }
        }
    }
}

simulated function PlayScreenMaterialEffects(class<KFDamageType> KFDT, bool bShowPainEffect)
{
    if(bShowPainEffect)
    {
        PainEffectTimeRemaining = PainEffectDuration;
    }
    if(KFDT.default.ScreenMaterialName != 'None')
    {
        switch(KFDT.default.ScreenMaterialName)
        {
            case EffectSirenScreamParamName:
                SirenScreamEffectTimeRemaining = default.SonicScreamEffectDuration;
                CheckForReducedSirenScreamEffect();
                break;
            case EffectBloatsPukeParamName:
                BloatPukeEffectTimeRemaining = default.BloatPukeEffectDuration;
                break;
            case EffectHealParamName:
                HealEffectTimeRemaining = default.HealEffectDuration;
                break;
            default:
                break;
        }
    }
    else
    {
    }
}

simulated function CheckForReducedSirenScreamEffect()
{
    local KFPerk MyPerk;

    MyPerk = GetPerk();
    if((MyPerk != none) && GameplayPostProcessEffectMIC != none)
    {
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectSirenScreamParamName, MyPerk.GetSirenScreamStrength());
    }
}

simulated function float GetEffectTimeRemaining(class<KFDamageType> KFDT)
{
    switch(KFDT.default.ScreenMaterialName)
    {
        case EffectSirenScreamParamName:
            return SirenScreamEffectTimeRemaining;
            break;
        case EffectBloatsPukeParamName:
            return BloatPukeEffectTimeRemaining;
            break;
        default:
            break;
    }
    return 0;
}

event PlayerTick(float DeltaTime)
{
    super(PlayerController).PlayerTick(DeltaTime);
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        UpdateLowHealthEffect(DeltaTime);
        UpdateZEDTimeEffects(DeltaTime);
        UpdateDOF(DeltaTime);
        UpdateFullscreenBlur(DeltaTime);
        if(ExplosionEarRingTimeRemaining > float(0))
        {
            UpdateEarRingEffect(DeltaTime);
        }
        if(PainEffectTimeRemaining > float(0))
        {
            UpdateScreenEffect(DeltaTime, EffectPainParamName, PainEffectTimeRemaining, default.PainEffectDuration);
        }
        if(HealEffectTimeRemaining > float(0))
        {
            UpdateScreenEffect(DeltaTime, EffectHealParamName, HealEffectTimeRemaining, default.HealEffectDuration);
        }
        if(SirenScreamEffectTimeRemaining > float(0))
        {
            UpdateScreenEffect(DeltaTime, EffectSirenScreamParamName, SirenScreamEffectTimeRemaining, default.SonicScreamEffectDuration);
        }
        if(BloatPukeEffectTimeRemaining > float(0))
        {
            UpdateScreenEffect(DeltaTime, EffectBloatsPukeParamName, BloatPukeEffectTimeRemaining, default.BloatPukeEffectDuration);
        }
        if(GameplayPostProcessEffects != none)
        {
            GameplayPostProcessEffects.bShowInGame = ShouldDisplayGameplayPostProcessFX();
        }
    }
    if(PauseMoveInputTimeLeft > 0)
    {
        TickPauseMoveInput(DeltaTime);
    }
}

function SetGrabEffect(bool bValue)
{
    bGrabEffectIsActive = bValue;
    if(bGrabEffectIsActive)
    {
        ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 9);        
    }
    else
    {
        ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 0);
    }
    if(GameplayPostProcessEffectMIC != none)
    {
        if(bGrabEffectIsActive)
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue('Effect_Grabbed', 1);            
        }
        else
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue('Effect_Grabbed', 0);
        }
    }
}

function SetPerkEffect(bool bValue)
{
    bPerkEffectIsActive = bValue;
    if(GameplayPostProcessEffectMIC != none)
    {
        if(bPerkEffectIsActive)
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectPerkParamName, 1);            
        }
        else
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectPerkParamName, 0);
        }
    }
}

function InitGameplayPostProcessFX()
{
    local MaterialInstanceConstant GameplayPPMIC;

    if(LocalPlayer(Player) != none)
    {
        GameplayPostProcessEffects = MaterialEffect(LocalPlayer(Player).PlayerPostProcess.FindPostProcessEffect(GameplayPostProcessEffectName));
        if(GameplayPostProcessEffects == none)
        {
            WarnInternal("[GameplayFX] Could not cache gameplay post process effect. Gameplay post-processing will be disabled");
        }
        GameplayPPMIC = MaterialInstanceConstant(GameplayPostProcessEffects.Material);
        if(GameplayPPMIC != none)
        {
            GameplayPostProcessEffectMIC = new Class'MaterialInstanceConstant';
            GameplayPostProcessEffectMIC.SetParent(GameplayPPMIC);
            GameplayPostProcessEffects.Material = GameplayPostProcessEffectMIC;            
        }
        else
        {
            WarnInternal("[GameplayFX] Could not find MIC in gameplay post process effect. Gameplay post-processing will be disabled");
        }
        ResetGameplayPostProcessFX();
    }
}

function ResetGameplayPostProcessFX()
{
    if(GameplayPostProcessEffectMIC != none)
    {
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectPainParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectLowHealthParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectZedTimeParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectNightVisionParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectSirenScreamParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectBloatsPukeParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectHealParamName, 0);
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectPerkParamName, 0);
    }
    if(GameplayPostProcessEffects != none)
    {
        GameplayPostProcessEffects.bShowInGame = false;
    }
    bNightVisionActive = false;
    bGamePlayDOFActive = false;
    bPerkEffectIsActive = false;
}

function bool ShouldDisplayGameplayPostProcessFX()
{
    return (((((((bPerkEffectIsActive || bGrabEffectIsActive) || PainEffectTimeRemaining > 0) || (Pawn != none) && Pawn.Health <= default.LowHealthThreshold) || HealEffectTimeRemaining > 0) || CurrentZEDTimeEffectIntensity > 0) || bNightVisionActive) || SirenScreamEffectTimeRemaining > 0) || BloatPukeEffectTimeRemaining > 0;
}

function UpdateScreenEffect(float DeltaTime, name EffectName, out float TimeRemaining, float Duration)
{
    local float Intensity;

    if(TimeRemaining > 0)
    {
        if(TimeRemaining > DeltaTime)
        {
            TimeRemaining -= DeltaTime;
            Intensity = FClamp(TimeRemaining / Duration, 0, 1);            
        }
        else
        {
            TimeRemaining = 0;
            Intensity = 0;
        }
        if(GameplayPostProcessEffectMIC != none)
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectName, Intensity);
        }
    }
}

function SetZedTimeEffectIntensity(float TargetWeight, optional float BlendTime)
{
    BlendTime = 0.5;
    TargetZEDTimeEffectIntensity = TargetWeight;
    ZEDTimeEffectInterpTimeRemaining = BlendTime;
}

function UpdateZEDTimeEffects(float DeltaTime)
{
    local KFPawn KFP;
    local float BlendDelta, ZedTimeAudioModifier, RealDeltaTime, OldZEDTimeEffectIntensity;
    local MaterialInstanceConstant WorldMIC;

    if(TargetZEDTimeEffectIntensity == PartialZEDTimeEffectIntensity)
    {
        KFP = KFPawn(Pawn);
        if((KFP != none) && !KFP.bUnaffectedByZedTime)
        {
            ClientEnterZedTime(false);
        }
    }
    if(WorldInfo.TimeDilation != LastTimeDilation)
    {
        ZedTimeAudioModifier = float(Max(int((float(1) - WorldInfo.TimeDilation) * float(100)), 0));
        SetRTPCValue('ZEDTime_Modifier', ZedTimeAudioModifier, true);
        LastTimeDilation = WorldInfo.TimeDilation;
    }
    OldZEDTimeEffectIntensity = CurrentZEDTimeEffectIntensity;
    if(ZEDTimeEffectInterpTimeRemaining > float(0))
    {
        RealDeltaTime = DeltaTime / WorldInfo.TimeDilation;
        BlendDelta = TargetZEDTimeEffectIntensity - CurrentZEDTimeEffectIntensity;
        CurrentZEDTimeEffectIntensity += ((BlendDelta / ZEDTimeEffectInterpTimeRemaining) * RealDeltaTime);
        ZEDTimeEffectInterpTimeRemaining -= RealDeltaTime;        
    }
    else
    {
        ZEDTimeEffectInterpTimeRemaining = 0;
        CurrentZEDTimeEffectIntensity = TargetZEDTimeEffectIntensity;
    }
    if(OldZEDTimeEffectIntensity != CurrentZEDTimeEffectIntensity)
    {
        if(GameplayPostProcessEffectMIC != none)
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectZedTimeParamName, CurrentZEDTimeEffectIntensity);
        }
        foreach WorldInfo.ZedTimeMICs(WorldMIC,)
        {
            WorldMIC.SetScalarParameterValue(EffectZedTimeParamName, CurrentZEDTimeEffectIntensity);            
        }        
    }
}

simulated function PlayEarRingEffect(float Intensity)
{
    ExplosionEarRingDuration = 10;
    if(ExplosionEarRingTimeRemaining <= 1)
    {
        ExplosionEarRingTimeRemaining = ExplosionEarRingDuration * Intensity;
        ExplosionEarRingDelay = 0.5;
        PlaySoundBase(EarsRingingPlayEvent, true);
    }
}

simulated function UpdateEarRingEffect(float DeltaTime)
{
    if(ExplosionEarRingDelay > 0)
    {
        ExplosionEarRingEffectIntensity = (1 - (ExplosionEarRingDelay / 0.5)) * 100;
        ExplosionEarRingDelay -= DeltaTime;
        SetRTPCValue('GRENADEFX', ExplosionEarRingEffectIntensity, true);
        return;
    }
    if(ExplosionEarRingTimeRemaining > float(0))
    {
        ExplosionEarRingEffectIntensity = (ExplosionEarRingTimeRemaining / ExplosionEarRingDuration) * 100;
        ExplosionEarRingTimeRemaining -= DeltaTime;
        if(((ExplosionEarRingTimeRemaining <= float(0)) || Pawn == none) || Pawn.Health <= 0)
        {
            ExplosionEarRingTimeRemaining = 0;
            ExplosionEarRingEffectIntensity = 0;
            PlaySoundBase(EarsRingingStopEvent, true);
        }
        SetRTPCValue('GRENADEFX', ExplosionEarRingEffectIntensity, true);
    }
}

function UpdateLowHealthEffect(float DeltaTime)
{
    local bool bLowHealth;

    if(Pawn != none)
    {
        bLowHealth = (Pawn.Health > 0) && Pawn.Health <= default.LowHealthThreshold;
        if(GameplayPostProcessEffectMIC != none)
        {
            GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectLowHealthParamName, ((bLowHealth) ? 1 : 0));
        }
        if(bLowHealth)
        {
            if(!bPlayingLowHealthSFX)
            {
                PostAkEvent(LowHealthStartEvent);
                bPlayingLowHealthSFX = true;
            }            
        }
        else
        {
            if(bPlayingLowHealthSFX)
            {
                PostAkEvent(LowHealthStopEvent);
                bPlayingLowHealthSFX = false;
            }
        }
        SetRTPCValue('Health', float(Pawn.Health), true);
    }
}

function ToggleHealthEffects(bool bEnableFX)
{
    if(!bEnableFX)
    {
        if(bPlayingLowHealthSFX)
        {
            PostAkEvent(LowHealthStopEvent);
            bPlayingLowHealthSFX = false;
        }
        SetRTPCValue('Health', 100, true);
    }
}

protected simulated function DoForceFeedbackForScreenShake(CameraShake ShakeData, float Scale)
{
    local KFCameraShake KFCS;
    local int ShakeLevel;
    local float RotMag, LocMag, FOVMag;

    if(Scale == 0)
    {
        return;
    }
    KFCS = KFCameraShake(ShakeData);
    if((KFCS == none) || KFCS.FFWaveform == none)
    {
        if(ShakeData != none)
        {
            RotMag = ShakeData.GetRotOscillationMagnitude() * Scale;
            if(RotMag > 40)
            {
                ShakeLevel = 2;                
            }
            else
            {
                if(RotMag > 20)
                {
                    ShakeLevel = 1;
                }
            }
            if(ShakeLevel < 2)
            {
                LocMag = ShakeData.GetLocOscillationMagnitude() * Scale;
                if(LocMag > 10)
                {
                    ShakeLevel = 2;                    
                }
                else
                {
                    if(LocMag > 5)
                    {
                        ShakeLevel = 1;
                    }
                }
                FOVMag = ShakeData.FOVOscillation.Amplitude * Scale;
                if(ShakeLevel < 2)
                {
                    if(FOVMag > 5)
                    {
                        ShakeLevel = 2;                        
                    }
                    else
                    {
                        if(FOVMag > 2)
                        {
                            ShakeLevel = 1;
                        }
                    }
                }
            }
            if(ShakeLevel == 2)
            {
                if(ShakeData.OscillationDuration <= float(1))
                {
                    ClientPlayForceFeedbackWaveform(Class'KFGameWaveforms'.default.CameraShakeBigShort);                    
                }
                else
                {
                    ClientPlayForceFeedbackWaveform(Class'KFGameWaveforms'.default.CameraShakeBigLong);
                }                
            }
            else
            {
                if(ShakeLevel == 1)
                {
                    if(ShakeData.OscillationDuration <= float(1))
                    {
                        ClientPlayForceFeedbackWaveform(Class'KFGameWaveforms'.default.CameraShakeMediumShort);                        
                    }
                    else
                    {
                        ClientPlayForceFeedbackWaveform(Class'KFGameWaveforms'.default.CameraShakeMediumLong);
                    }
                }
            }
        }        
    }
    else
    {
        ClientPlayForceFeedbackWaveform(KFCameraShake(ShakeData).FFWaveform);
    }
}

simulated function SetAmplificationLightEnabled(bool bEnabled)
{
    if(bEnabled)
    {
        if(AmplificationLight != none)
        {
            AmplificationLight.DetachFromAny();
            AmplificationLight = none;
        }
        if(AmplificationLightTemplate != none)
        {
            AmplificationLight = new (self) Class'PointLightComponent' (AmplificationLightTemplate);
        }
        if(AmplificationLight != none)
        {
            Pawn.AttachComponent(AmplificationLight);
        }        
    }
    else
    {
        if(AmplificationLight != none)
        {
            AmplificationLight.DetachFromAny();
            AmplificationLight = none;
        }
    }
}

simulated function SetNightVision(bool bEnabled)
{
    if(GameplayPostProcessEffectMIC != none)
    {
        bNightVisionActive = bEnabled;
        GameplayPostProcessEffectMIC.SetScalarParameterValue(EffectNightVisionParamName, ((bNightVisionActive) ? 1 : 0));
        if(bEnabled)
        {
            bGamePlayDOFActive = true;
            DOF_GP_BlendInSpeed = DOF_NVG_BlendInSpeed;
            DOF_GP_BlendOutSpeed = DOF_NVG_BlendOutSpeed;
            DOF_GP_FocalDistance = NVG_DOF_FocalDistance;
            DOF_GP_SharpRadius = NVG_DOF_SharpRadius;
            DOF_GP_FocalRadius = NVG_DOF_FocalRadius;
            DOF_GP_MinBlurSize = NVG_DOF_MinBlurSize;
            DOF_GP_MaxNearBlurSize = NVG_DOF_MaxNearBlurSize;
            DOF_GP_MaxFarBlurSize = NVG_DOF_MaxFarBlurSize;
            DOF_GP_ExpFalloff = NVG_DOF_ExpFalloff;            
        }
        else
        {
            bGamePlayDOFActive = false;
        }
    }
    if(Pawn != none)
    {
        if((NVGLight == none) && NVGLightTemplate != none)
        {
            NVGLight = new (self) Class'PointLightComponent' (NVGLightTemplate);
        }
        if(bEnabled)
        {
            Pawn.AttachComponent(NVGLight);
            NVGLight.SetEnabled(bEnabled);
            AmplificationLight.SetEnabled(!bEnabled);            
        }
        else
        {
            Pawn.DetachComponent(NVGLight);
            NVGLight.SetEnabled(bEnabled);
            AmplificationLight.SetEnabled(!bEnabled);
        }
    }
}

reliable client simulated function ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
    bCinematicMode = bInCinematicMode;
    if(bCinematicMode)
    {
        bGamePlayDOFActive = true;
        DOF_GP_BlendInSpeed = DOF_Cinematic_BlendInSpeed;
        DOF_GP_BlendOutSpeed = DOF_Cinematic_BlendOutSpeed;
        DOF_GP_FocalDistance = DOF_Cinematic_FocalDistance;
        DOF_GP_SharpRadius = DOF_Cinematic_SharpRadius;
        DOF_GP_FocalRadius = DOF_Cinematic_FocalRadius;
        DOF_GP_MinBlurSize = DOF_Cinematic_MinBlurSize;
        DOF_GP_MaxNearBlurSize = DOF_Cinematic_MaxNearBlurSize;
        DOF_GP_MaxFarBlurSize = DOF_Cinematic_MaxFarBlurSize;
        DOF_GP_ExpFalloff = DOF_Cinematic_ExpFalloff;        
    }
    else
    {
        bGamePlayDOFActive = false;
    }
    if((myHUD != none) && bAffectsHUD)
    {
        myHUD.bShowHUD = !bCinematicMode;
    }
    if(bAffectsMovement)
    {
        IgnoreMoveInput(bCinematicMode);
    }
    if(bAffectsTurning)
    {
        IgnoreLookInput(bCinematicMode);
    }
}

// Export UKFPlayerController::execCanSeeZedTimePawn(FFrame&, void* const)
native function bool CanSeeZedTimePawn(bool bZedTimeStart, optional int RecursionCount);

// Export UKFPlayerController::execStartPartialZedTimeSightCounter(FFrame&, void* const)
native function StartPartialZedTimeSightCounter();

event NotifyPartialZedTimeExited();

function bool IsAffectedByZedTime()
{
    if(bForcePartialZedTime)
    {
        return false;
    }
    return CanSeeZedTimePawn(true);
}

function EnterZedTime()
{
    local KFPawn KFP;
    local KFPerk MyPerk;
    local bool bPartialZedTime;

    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.NotifyZedTimeStarted();
    }
    KFP = KFPawn(Pawn);
    if(KFP != none)
    {
        KFP.bUnaffectedByZedTime = !IsAffectedByZedTime();
        bPartialZedTime = KFP.bUnaffectedByZedTime;
        if(bPartialZedTime)
        {
            StartPartialZedTimeSightCounter();
        }
    }
    ClientEnterZedTime(bPartialZedTime);
}

function FadeOutZedTime()
{
    local KFPerk MyPerk;

    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.NotifyZedTimeEnded();
    }
    ClientFadeOutZedTime();
}

reliable client simulated function ClientEnterZedTime(bool bPartialOnly)
{
    if(bPartialOnly)
    {
        PlaySoundBase(ZedTimePartialEnterSound, true);
        SetZedTimeEffectIntensity(PartialZEDTimeEffectIntensity);        
    }
    else
    {
        PlaySoundBase(ZedTimeEnterSound, true);
        SetZedTimeEffectIntensity(1);
    }
}

reliable client simulated function ClientFadeOutZedTime()
{
    local KFPawn KFP;
    local bool bIsPartialZedTime;

    KFP = KFPawn(Pawn);
    if((KFP != none) && KFP.bUnaffectedByZedTime)
    {
        bIsPartialZedTime = true;
    }
    PlaySoundBase(((bIsPartialZedTime) ? ZedTimePartialExitSound : ZedTimeExitSound), true);
    SetZedTimeEffectIntensity(0);
}

function SetGFxHUD(KFGFxMoviePlayer_HUD NewGFxHud)
{
    MyGFxHUD = NewGFxHud;
}

function ShowBossNameplate(KFPawn_MonsterBoss KFBoss)
{
    if(MyGFxHUD != none)
    {
        MyGFxHUD.ShowBossNameplate(KFBoss.default.BossName, KFBoss.default.BossCaptionStrings[Rand(KFBoss.default.BossCaptionStrings.Length)]);
    }
}

function HideBossNamePlate()
{
    if(MyGFxHUD != none)
    {
        MyGFxHUD.HideBossNamePlate();
    }
}

reliable client simulated function ClientSetFrontEnd(class<KFGFxMoviePlayer_Manager> FrontEndClass, optional bool bSkipMenus)
{
    local LocalPlayer LP;

    if(MyGFxManager == none)
    {
        MyGFxManager = new (self) FrontEndClass;
        LP = LocalPlayer(Player);
        if(LP != none)
        {
            MyGFxManager.Init(LP);
            MyGFxManager.LaunchMenus(bSkipMenus);
        }
    }
}

reliable server function SkipLobby()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.LobbyCountdownComplete();
    }
}

function NotifyUnsuccessfulSearch()
{
    if(MyGFxManager != none)
    {
        MyGFxManager.NotifyUnsuccessfulSearch();
    }
}

function OnLobbyStatusChanged(bool bInLobby)
{
    if(MyGFxManager != none)
    {
        MyGFxManager.OnLobbyStatusChanged(bInLobby);
    }
}

function string GetSteamAvatar(UniqueNetId NetId)
{
    local string AvatarPath;
    local int I;
    local bool bFoundAvatar;
    local PlayerSteamAvatar CurrentAvatar;

    AvatarPath = "";
    I = 0;
    J0x17:

    if(I < AvatarList.Length)
    {
        if(AvatarList[I].NetId == NetId)
        {
            bFoundAvatar = true;
            if(AvatarList[I].Avatar != none)
            {
                AvatarPath = (("img://" $ string(AvatarList[I].Avatar.GetPackageName())) $ ".") $ string(AvatarList[I].Avatar.Name);
            }
        }
        ++ I;
        goto J0x17;
    }
    if(!bFoundAvatar)
    {
        CurrentAvatar.NetId = NetId;
        AvatarList.AddItem(CurrentAvatar;
        if(OnlineSub != none)
        {
            OnlineSub.ReadOnlineAvatar(NetId, 64, OnAvatarReceived);
        }
    }
    return AvatarPath;
}

function OnAvatarReceived(const UniqueNetId NetId, Texture2D Avatar)
{
    local byte I;

    I = 0;
    J0x0C:

    if(I < AvatarList.Length)
    {
        if(AvatarList[I].NetId == NetId)
        {
            AvatarList[I].Avatar = Avatar;
            return;
        }
        ++ I;
        goto J0x0C;
    }
}

unreliable server function ServerSay(string msg)
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(!KFGI.bDisablePublicTextChat || PlayerReplicationInfo.bAdmin)
    {
        super(PlayerController).ServerSay(msg);
    }
}

unreliable server function ServerTeamSay(string msg)
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(!KFGI.bDisablePublicTextChat || PlayerReplicationInfo.bAdmin)
    {
        super(PlayerController).ServerTeamSay(msg);
    }
}

reliable client simulated event TeamMessage(PlayerReplicationInfo PRI, coerce string S, name Type, optional float MsgLifeTime)
{
    local string ChatMessage;

    if(PRI == none)
    {
        return;
    }
    ChatMessage = (PRI.PlayerName $ ": ") $ S;
    if((MyGFxManager != none) && Type != MusicMessageType)
    {
        if(Class'WorldInfo'.static.IsMenuLevel())
        {
            ChatMessage = S;
        }
        if((MyGFxManager.PartyWidget != none) && !MyGFxManager.PartyWidget.ReceiveMessage(ChatMessage))
        {
            return;
        }
        if(MyGFxManager.PostGameMenu != none)
        {
            MyGFxManager.PostGameMenu.ReceiveMessage(ChatMessage);
        }
    }
    if(MyGFxHUD != none)
    {
        if(Type == MusicMessageType)
        {
            MyGFxHUD.MusicNotification.ShowSongInfo(S);            
        }
        else
        {
            if((Type != 'Event') && Type != 'None')
            {
                if(PRI.bAdmin)
                {
                    ChatMessage = Class'KFLocalMessage'.default.AdminString $ ChatMessage;
                    MyGFxHUD.HudChatBox.AddChatMessage(ChatMessage, Class'KFLocalMessage'.default.PriorityColor);                    
                }
                else
                {
                    MyGFxHUD.HudChatBox.AddChatMessage(ChatMessage, Class'KFLocalMessage'.default.SayColor);
                }                
            }
            else
            {
                MyGFxHUD.HudChatBox.AddChatMessage(Class'KFLocalMessage'.default.SystemString @ S, Class'KFLocalMessage'.default.EventColor);
            }
        }
    }
}

function OpenChatBox()
{
    local KFGFxHudWrapper GFxHUDWrapper;

    GFxHUDWrapper = KFGFxHudWrapper(myHUD);
    if((GFxHUDWrapper != none) && GFxHUDWrapper.HudMovie != none)
    {
        GFxHUDWrapper.HudMovie.OpenChatBox();
    }
}

exec function Talk()
{
    OpenChatBox();
}

exec function TeamTalk()
{
    OpenChatBox();
}

reliable client simulated function ClientSetCountdown(bool bFinalCountdown, byte CountdownTime)
{
    if((MyGFxManager != none) && MyGFxManager.PartyWidget != none)
    {
        MyGFxManager.PartyWidget.StartCountdown(CountdownTime, bFinalCountdown);        
    }
    else
    {
        KFGameReplicationInfo(WorldInfo.GRI).RemainingTime = CountdownTime;
    }
}

reliable client simulated function ClientResetCountdown()
{
    if((MyGFxManager != none) && MyGFxManager.PartyWidget != none)
    {
        MyGFxManager.PartyWidget.StopCountdown();
    }
}

exec function StartFire(optional byte FireModeNum)
{
    local KFInventoryManager KFIM;

    if(!KFPlayerInput(PlayerInput).bQuickWeaponSelect)
    {
        if((MyGFxHUD != none) && MyGFxHUD.WeaponSelectWidget.bChangingWeapons)
        {
            KFIM = KFInventoryManager(Pawn.InvManager);
            KFIM.SetCurrentWeapon(KFIM.PendingWeapon);
            MyGFxHUD.WeaponSelectWidget.FadeOut();
            return;
        }
    }
    super(PlayerController).StartFire(FireModeNum);
}

exec function StartAltFire(optional byte FireModeNum)
{
    if(!KFPlayerInput(PlayerInput).bQuickWeaponSelect)
    {
        if(KFPlayerInput(PlayerInput).bGamepadWeaponSelectOpen)
        {
            return;
        }
    }
    super(PlayerController).StartAltFire(FireModeNum);
}

function OpenTraderMenu()
{
    if((Role == ROLE_Authority) && Pawn != none)
    {
        KFInventoryManager(Pawn.InvManager).bServerTraderMenuOpen = true;
        ClientOpenTraderMenu();
    }
}

reliable client simulated function ClientOpenTraderMenu()
{
    if(MyGFxManager != none)
    {
        MyGFxManager.OpenMenu(14, false);
        if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
        {
            KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayOpenTraderMenuDialog(self);
        }
    }
}

function CloseTraderMenu()
{
    if(MyGFxManager != none)
    {
        MyGFxManager.CloseTraderMenu();
    }
}

function NotifyAddInventory(Inventory NewItem)
{
    local KFGFxMenu_Trader TraderMenu;
    local KFWeapon KFW;

    TraderMenu = KFGFxMenu_Trader(MyGFxManager.CurrentMenu);
    if(TraderMenu != none)
    {
        KFW = KFWeapon(NewItem);
        if(KFW != none)
        {
            TraderMenu.GiveExternalWeapon(KFW);
        }
    }
}

simulated function NotifyTraderDoshChanged()
{
    local KFGFxMenu_Trader TraderMenu;

    if(MyGFxManager != none)
    {
        TraderMenu = KFGFxMenu_Trader(MyGFxManager.CurrentMenu);
        if(TraderMenu != none)
        {
            TraderMenu.NotifyDoshChanged();
        }
    }
}

reliable client simulated function ClientOpenPostGameMenu()
{
    if(MyGFxManager != none)
    {
        MyGFxManager.bPostGameState = true;
        MyGFxManager.bCanCloseMenu = false;
        MyGFxManager.OpenMenu(13, false);
        myHUD.bShowHUD = false;
    }
}

function ClosePostGameMenu()
{
    if(MyGFxManager != none)
    {
        MyGFxManager.ClosePostGameMenu();
    }
}

function UpdateRhythmCounterWidget(int Count)
{
    if(MyGFxHUD != none)
    {
        MyGFxHUD.UpdateRhythmCounterWidget(Count);
    }
}

reliable client simulated function ClientAcceptObj()
{
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if((KFGRI != none) && KFGRI.CurrentObjective != none)
    {
        KFGRI.CurrentObjective.AcceptObj();
    }
}

reliable server function ServerAcceptObj()
{
    local KFPlayerReplicationInfo KFPRI;
    local KFGameReplicationInfo KFGRI;

    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.bObjectivePlayer = true;
    }
    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if((KFGRI != none) && KFGRI.CurrentObjective != none)
    {
        KFGRI.CurrentObjective.AddObjectivePlayer(PlayerReplicationInfo);
    }
    UpdateInteractionMessages(Pawn);
    ClientAcceptObj();
    WorldInfo.Game.Broadcast(KFPRI, KFPRI.PlayerName @ "has accepted the Objective.");
}

// Export UKFPlayerController::execGetPooledAkComponent(FFrame&, void* const)
native function AkComponent GetPooledAkComponent(optional Actor SourceActor);

unreliable client simulated event WwiseClientHearSound(AkEvent ASound, Actor SourceActor, Vector SourceLocation, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    local int I;
    local name EnvironmentName;
    local bool bFollowSourceActor;

    bFollowSourceActor = (SourceActor != none) && IsZero(SourceLocation);
    if(bFollowSourceActor && ASound.bForceHearSoundLocational)
    {
        bFollowSourceActor = false;
        SourceLocation = SourceActor.Location;
    }
    if(ASound.bUseEnvironmentReverbSwitchGroup)
    {
        if(bFollowSourceActor && WorldInfo != none)
        {
            EnvironmentName = WorldInfo.GetAkEnvironmentName(SourceActor.Location);            
        }
        else
        {
            if(WorldInfo != none)
            {
                EnvironmentName = WorldInfo.GetAkEnvironmentName(SourceLocation);
            }
        }
        I = 0;
        J0x164:

        if(I < ASound.CustomSwitches.Length)
        {
            if(ASound.CustomSwitches[0].SwitchGroupName == 'Environment_Reverb')
            {
                ASound.CustomSwitches[I].SwitchName = EnvironmentName;
                goto J0x228;
            }
            ++ I;
            goto J0x164;
        }
        J0x228:

        if(I >= ASound.CustomSwitches.Length)
        {
            ASound.CustomSwitches.Insert(0, 1;
            ASound.CustomSwitches[0].SwitchGroupName = 'Environment_Reverb';
            ASound.CustomSwitches[0].SwitchName = EnvironmentName;
        }
    }
    if(bFollowSourceActor)
    {
        SourceActor.PostAkEvent(ASound, bIsOccluded, !(SourceActor == self) || SourceActor == Pawn, bStopWhenOwnerDestroyed);        
    }
    else
    {
        PostAkEventAtLocation(ASound, SourceLocation, bIsOccluded);
    }
}

unreliable client simulated event ClientHearSoundAdvanced(AkEvent ASound, Actor SourceActor, Vector SourceLocation, byte CompressedSourcePitch, byte CompressedSourceYaw, byte RapidFireEnabled, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    local Rotator SoundRotation;

    SoundRotation.Pitch = 256 * CompressedSourcePitch;
    SoundRotation.Yaw = 256 * CompressedSourceYaw;
    ProcessAdvancedHearSound(ASound, SourceActor, SourceLocation, SoundRotation, RapidFireEnabled, bStopWhenOwnerDestroyed, bIsOccluded);
}

unreliable client simulated event ClientHearSoundAdvancedRelevant(AkEvent ASound, Actor SourceActor, Vector SourceLocation, byte RapidFireEnabled, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    local Rotator SoundRotation;

    SoundRotation = SourceActor.GetAKRotation();
    ProcessAdvancedHearSound(ASound, SourceActor, SourceLocation, SoundRotation, RapidFireEnabled, bStopWhenOwnerDestroyed, bIsOccluded);
}

simulated function ProcessAdvancedHearSound(AkEvent ASound, Actor SourceActor, Vector SourceLocation, Rotator SourceRotation, byte RapidFireEnabled, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    local int I;

    if((RapidFireEnabled != 0) && !IsZero(SourceLocation))
    {
        I = 0;
        J0x33:

        if(I < ASound.CustomRTPCs.Length)
        {
            if(ASound.CustomRTPCs[0].RTPCName == 'ZEDTime_CommandoPerk')
            {
                ASound.CustomRTPCs[I].RTPCValue = 100;
                goto J0xF3;
            }
            ++ I;
            goto J0x33;
        }
        J0xF3:

        if(I >= ASound.CustomRTPCs.Length)
        {
            ASound.CustomRTPCs.Insert(0, 1;
            ASound.CustomRTPCs[0].RTPCName = 'ZEDTime_CommandoPerk';
            ASound.CustomRTPCs[0].RTPCValue = 100;
        }
    }
    WwiseClientHearSound(ASound, SourceActor, SourceLocation, bStopWhenOwnerDestroyed, bIsOccluded);
    if((SourceActor != none) && IsZero(SourceLocation))
    {
        SourceLocation = SourceActor.Location;
    }
    HearEchoes(ASound, SourceLocation, SourceRotation);
}

simulated function HearEchoes(AkEvent ASound, Vector SourceLocation, Rotator SourceRotation)
{
    local float EchoDistance;
    local ReverbVolume EchoVolume;
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local float ViewDist;

    Class'KFReverbVolume'.static.CalculateEchoVolumeAndDistance(WorldInfo, SourceLocation, EchoVolume, EchoDistance);
    GetPlayerViewPoint(ViewLocation, ViewRotation);
    ViewDist = VSizeSq(ViewLocation - SourceLocation);
    if((EchoDistance == float(0)) || ViewDist < (EchoDistance * EchoDistance))
    {
        SourceRotation.Pitch = 0;
        PlayDirectionalEcho(ASound.EchoFront, EchoVolume, SourceLocation, EchoDistance, vect(1, 0, 0) >> SourceRotation);
        PlayDirectionalEcho(ASound.EchoLeft, EchoVolume, SourceLocation, EchoDistance, vect(0, -1, 0) >> SourceRotation);
        PlayDirectionalEcho(ASound.EchoRight, EchoVolume, SourceLocation, EchoDistance, vect(0, 1, 0) >> SourceRotation);
        PlayDirectionalEcho(ASound.EchoRear, EchoVolume, SourceLocation, EchoDistance, vect(-1, 0, 0) >> SourceRotation);        
    }
    else
    {
        PlayEcho(ASound.EchoMono, SourceLocation, FMin((EchoDistance / 34029) * 2, 5));
    }
}

function PlayDirectionalEcho(AkEvent EchoSound, ReverbVolume EchoVolume, Vector SourceLocation, float EchoDistance, Vector EchoDirection)
{
    local Vector EchoLocation;
    local float EchoDelay;

    Class'KFReverbVolume'.static.CalculateEchoLocationAndDelay(EchoVolume, SourceLocation, EchoDirection, EchoDistance, EchoLocation, EchoDelay);
    PlayEcho(EchoSound, EchoLocation, EchoDelay);
}

function PlayEcho(AkEvent EchoSound, Vector EchoLocation, float EchoDelay)
{
    if(EchoSound != none)
    {
        EchoSound.SetCustomRTPC('EchoDistance', EchoDelay);
        PlaySoundBase(EchoSound, true, true, false, EchoLocation, true);
    }
}

function PauseWwiseForAllPlayers(bool bPause)
{
    local KFPlayerController PC;

    foreach WorldInfo.AllControllers(Class'KFPlayerController', PC)
    {
        PC.ClientPauseWwise(bPause);        
    }    
}

reliable client simulated function ClientPauseWwise(bool bPause)
{
    if(bPause)
    {
        PostAkEvent(PauseWwiseEvent);        
    }
    else
    {
        PostAkEvent(ResumeWwiseEvent);
    }
}

function bool SetPause(bool bPause, optional delegate<CanUnpause> CanUnpauseDelegate)
{
    local bool bWasPaused, bIsPaused;

    CanUnpauseDelegate = CanUnpause;
    bWasPaused = IsPaused();
    bIsPaused = super(PlayerController).SetPause(bPause, CanUnpauseDelegate);
    if(bWasPaused != bIsPaused)
    {
        PauseWwiseForAllPlayers(!bWasPaused && bIsPaused);
    }
    return bIsPaused;
}

function OnExternalUIChanged(bool bIsOpening)
{
    bIsExternalUIOpen = bIsOpening;
    if((WorldInfo.NetMode == NM_Standalone) && MyGFxManager.bMenusOpen)
    {
        return;
    }
    SetPause(bIsOpening, CanUnpauseExternalUI);
}

reliable server function ServerPause()
{
    if(WorldInfo.Game.AllowPausing(self))
    {
        if(!IsPaused())
        {
            SetPause(true);            
        }
        else
        {
            SetPause(false);
        }
    }
}

// Export UKFPlayerController::execGetPerkXP(FFrame&, void* const)
native function int GetPerkXP(class<KFPerk> PerkClass);

// Export UKFPlayerController::execGetPerkBuildByPerkClass(FFrame&, void* const)
native function int GetPerkBuildByPerkClass(class<KFPerk> PerkClass);

// Export UKFPlayerController::execGiveXP(FFrame&, void* const)
native exec function GiveXP(int XP);

// Export UKFPlayerController::execLogPerkBuilds(FFrame&, void* const)
native exec function LogPerkBuilds();

simulated event InitializeStats()
{
    if((StatsRead == none) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        StatsWrite = new (self) Class'KFOnlineStatsWrite';
        StatsRead = new (self) Class'KFOnlineStatsRead';
        StatsWrite.MyKFPC = self;
        StatsRead.OwningUniqueID = PlayerReplicationInfo.UniqueId;
        StatsRead.LinkedWriteObject = StatsWrite;
        ReadStats();
    }
}

simulated function ReadStats()
{
    local array<UniqueNetId> Players;

    if(StatsRead.bLogStatsRead)
    {
        LogInternal((((("ReadStats called! OnlineSub=" $ string(OnlineSub)) @ "StatsRead.UserStatsReceivedState=") $ string(StatsRead.UserStatsReceivedState)) @ "StatsRead.OwningUniqueID=") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(StatsRead.OwningUniqueID));
    }
    if((OnlineSub != none) && StatsRead.UserStatsReceivedState != 2)
    {
        OnlineSub.StatsInterface.AddReadOnlineStatsCompleteDelegate(OnStatsInitialized);
        Players[0] = StatsRead.OwningUniqueID;
        OnlineSub.StatsInterface.ReadOnlineStats(Players, StatsRead);        
    }
    else
    {
        if(OnlineSub == none)
        {
            WarnInternal("KFPlayerController.ReadStats: No online subsystem present.");
            OnStatsInitialized(false);
        }
    }
}

simulated function OnStatsInitialized(bool bWasSuccessful)
{
    local int I;

    if(OnlineSub != none)
    {
        OnlineSub.StatsInterface.ClearReadOnlineStatsCompleteDelegate(OnStatsInitialized);
    }
    StatsRead.OnStatsInitialized(bWasSuccessful);
    if(MyGFxManager != none)
    {
        MyGFxManager.StatsInitialized();
    }
    ClientInitializePerks();
    I = 0;
    J0xC1:

    if(I < PerkList.Length)
    {
        if(((self != none) && self.MatchStats != none) && PerkList[I].PerkClass != none)
        {
            self.MatchStats.RecordPerkXPGain(PerkList[I].PerkClass, 0);
        }
        ++ I;
        goto J0xC1;
    }
}

reliable client simulated function ClientWriteAndFlushStats()
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if((((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none))) && StatsWrite != none) && !StatsWrite.HasCheated())
    {
        if(StatsWrite.bLogStatsWrite)
        {
            LogInternal(string(GetFuncName()) @ "Writing and flushing stats to steam!");
        }
        OnlineSub.StatsInterface.WriteOnlineStats('Game', PlayerReplicationInfo.UniqueId, StatsWrite);
        OnlineSub.StatsInterface.FlushOnlineStats('Game');
        ClientLogWeldAndHealXP();        
    }
    else
    {
        if(StatsWrite == none)
        {
            if(StatsWrite.bLogStatsWrite)
            {
                LogInternal(string(GetFuncName()) @ "Not writing and flushing stats to steam because StatsWrite is null.");
            }
        }
    }
}

reliable client simulated function ClientWonGame(string MapName, byte Difficulty, byte GameLength, byte bCoop)
{
    if((WorldInfo.NetMode != NM_DedicatedServer) && IsLocalPlayerController())
    {
        StatsWrite.OnGameWon(MapName, Difficulty, GameLength, bCoop, GetPerk().Class);
    }
}

reliable client simulated event ClientUnlockAchievement(int AchievementIndex, optional bool bAlwaysUnlock)
{
    bAlwaysUnlock = false;
    if((((((WorldInfo.NetMode != NM_DedicatedServer) && IsLocalPlayerController()) && bIsAchievementPlayer || bAlwaysUnlock) && !PlayerReplicationInfo.bOnlySpectator) && !StatsWrite.HasCheated()) && !StatsWrite.IsAchievementUnlocked(AchievementIndex))
    {
        if(OnlineSub.PlayerInterface.UnlockAchievement(0, AchievementIndex))
        {
            StatsWrite.OnUnlockAchievement(AchievementIndex);
        }
    }
}

function float GetPerkLevelProgressPercentage(class<KFPerk> PerkClass, optional out int CurrentLevelEXP, optional out int NextLevelEXP)
{
    local int NextEXP, CurrentEXP;
    local float EXPPercent;
    local byte PerkLevel;

    PerkLevel = GetPerkLevelFromPerkList(PerkClass);
    CurrentEXP = GetPerkXP(PerkClass);
    if(PerkLevel < 25)
    {
        NextEXP = Class'KFOnlineStatsWrite'.static.GetXPNeededAt(PerkLevel);
        EXPPercent = float(CurrentEXP) / float(NextEXP);        
    }
    else
    {
        EXPPercent = 1;
    }
    CurrentLevelEXP = CurrentEXP;
    NextLevelEXP = NextEXP;
    return EXPPercent * float(100);
}

event byte GetPerkLevelFromPerkList(class<KFPerk> PerkClass)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PerkList.Length)
    {
        if(PerkList[I].PerkClass == PerkClass)
        {
            return PerkList[I].PerkLevel;
        }
        ++ I;
        goto J0x0B;
    }
    return 0;
}

function AddZedKill(class<KFPawn_Monster> MonsterClass, byte Difficulty, class<DamageType> DT)
{
    ClientAddZedKill(MonsterClass, Difficulty, DT);
    if(((((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress()) && MonsterClass.static.IsStalkerClass()) && Class'KFPerk'.static.IsDamageTypeOnThisPerk(class<KFDamageType>(DT), Class'KFPerk_Commando'.static.GetPerkClass()))
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerIntEvent(1303, self, Class'KFPerk_Commando'.static.GetStalkerKillXP(Difficulty));
    }
}

// Export UKFPlayerController::execClientAddZedKill(FFrame&, void* const)
private reliable client native final simulated function ClientAddZedKill(class<KFPawn_Monster> MonsterClass, byte Difficulty, class<DamageType> DT);

function AddZedHeadshot(byte Difficulty, class<DamageType> DT)
{
    ClientAddZedHeadshot(Difficulty, DT);
}

// Export UKFPlayerController::execClientAddZedHeadshot(FFrame&, void* const)
private reliable client native final simulated function ClientAddZedHeadshot(byte Difficulty, class<DamageType> DT);

function AddPlayerXP(int XP, class<KFPerk> PerkClass)
{
    ClientAddPlayerXP(XP, PerkClass);
}

// Export UKFPlayerController::execClientAddPlayerXP(FFrame&, void* const)
private reliable client native final simulated function ClientAddPlayerXP(int XP, class<KFPerk> PerkClass);

function AddSmallRadiusKill(byte Difficulty)
{
    ClientAddSmallRadiusKill(Difficulty);
}

// Export UKFPlayerController::execClientAddSmallRadiusKill(FFrame&, void* const)
private reliable client native final simulated function ClientAddSmallRadiusKill(byte Difficulty);

function AddWeldPoints(int PointsWelded)
{
    ClientAddWeldPoints(PointsWelded);
}

// Export UKFPlayerController::execClientAddWeldPoints(FFrame&, void* const)
private reliable client native final simulated function ClientAddWeldPoints(int PointsWelded);

function AddHealPoints(int PointsHealed)
{
    ClientAddHealPoints(PointsHealed);
}

// Export UKFPlayerController::execClientAddHealPoints(FFrame&, void* const)
private reliable client native final simulated function ClientAddHealPoints(int PointsHealed);

function ClientLogWeldAndHealXP()
{
    if(Role == ROLE_Authority)
    {
        if(StatsWrite.PerRoundHealXP > 0)
        {
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerIntEvent(1300, self, StatsWrite.PerRoundHealXP);
            }
        }
        if(StatsWrite.PerRoundWeldXP > 0)
        {
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerIntEvent(1301, self, StatsWrite.PerRoundWeldXP);
            }
        }        
    }
    else
    {
        ServerLogWeldAndHealXP(StatsWrite.PerRoundWeldXP, StatsWrite.PerRoundHealXP);
    }
    StatsWrite.PerRoundWeldXP = 0;
    StatsWrite.PerRoundHealXP = 0;
}

unreliable server function ServerLogWeldAndHealXP(int WeldingXP, int HealingXP)
{
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerIntEvent(1300, self, HealingXP);
    }
    if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerIntEvent(1301, self, WeldingXP);
    }
}

exec function ResetStats(string ConfirmSteamNickInQuotes, optional bool bResetAchievements)
{
    bResetAchievements = false;
    if(IsLocalPlayerController())
    {
        if(ConfirmSteamNickInQuotes != PlayerReplicationInfo.PlayerName)
        {
            LocalPlayer(Player).ViewportClient.ViewportConsole.OutputText("Failed - Confirm using your Steam nickname (Case sensitive)");
            return;
        }
        if(OnlineSub.ResetStats(bResetAchievements))
        {
            LocalPlayer(Player).ViewportClient.ViewportConsole.OutputText("Reset was successful");            
        }
        else
        {
            WarnInternal("Reset Stats Failed!");
        }
    }
}

final exec function LogStats()
{
    if(StatsWrite != none)
    {
        StatsWrite.LogStats();
    }
}

exec function EnableCheats()
{
    if(!PlayerReplicationInfo.bAdmin && WorldInfo.NetMode != NM_Standalone)
    {
        ReceiveLocalizedMessage(Class'KFLocalMessage', 2, PlayerReplicationInfo);
        return;
    }
    ServerEnableCheats();
}

private reliable server final function ServerEnableCheats()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        AddCheats(true);
        ClientNotifyCheats();
        BroadcastLocalizedMessage(Class'KFLocalMessage', 3, PlayerReplicationInfo);
        KFGI.SetGameUnranked(true);
        KFGI.UpdateGameSettings();
    }
}

private reliable client final simulated function ClientNotifyCheats()
{
    if(StatsWrite != none)
    {
        StatsWrite.NotifyCheats();
    }
}

reliable client simulated event OnMapCollectibleFound(PlayerReplicationInfo FinderPRI, int CollectibleID)
{
    local string CollectibleFoundMsg;
    local KFMapInfo KFMI;

    KFMI = KFMapInfo(WorldInfo.GetMapInfo());
    CollectibleFoundMsg = Localize("KFMapInfo", "FoundCollectibleString", "KFGame");
    CollectibleFoundMsg = Repl(CollectibleFoundMsg, "%x%", FinderPRI.PlayerName);
    CollectibleFoundMsg = Repl(CollectibleFoundMsg, "%y%", string(KFMI.CollectiblesToFind - CollectibleID));
    MyGFxHUD.ShowNonCriticalMessage(CollectibleFoundMsg);
}

reliable client simulated event OnAllMapCollectiblesFound()
{
    MyGFxHUD.ShowNonCriticalMessage(Localize("KFMapInfo", "FoundAllCollectiblesString", "KFGame"));
    PostAkEvent(AllMapCollectiblesFoundEvent);
}

// Export UKFPlayerController::execLogOutBugItAIGoToLogFile(FFrame&, void* const)
native function LogOutBugItAIGoToLogFile(const string InScreenShotDesc, const string InGoString, const string InLocString);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local KFGameReplicationInfo KFGRI;
    local KFAIController KFAIC;

    super(PlayerController).DisplayDebug(HUD, out_YL, out_YPos);
    if(HUD.ShouldDisplayDebug('Memory'))
    {
        DrawDebugMemory(HUD.Canvas, out_YL, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Difficulty'))
    {
        DrawDebugDifficulty(HUD.Canvas, out_YL, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('SpawnWaves'))
    {
        DrawDebugSpawning(HUD.Canvas);
    }
    if(HUD.ShouldDisplayDebug('Map'))
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if(KFGRI.bTrackingMapEnabled)
        {
            DrawDebugMap(HUD.Canvas);
        }
    }
    if(HUD.ShouldDisplayDebug('DoorGraph'))
    {
    }
    if(HUD.ShouldDisplayDebug('GRI'))
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if(KFGRI != none)
        {
            KFGRI.DisplayDebug(HUD, out_YL, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('Time'))
    {
        HUD.Canvas.SetDrawColor(0, 255, 0);
        HUD.Canvas.DrawText((("TIME: WorldInfo.TimeDilation: " $ string(WorldInfo.TimeDilation)) $ " CustomTimeDilation: ") $ string(CustomTimeDilation));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('FireAttacks'))
    {
        foreach WorldInfo.AllControllers(Class'KFAIController', KFAIC)
        {
            KFAIC.DrawFireAttackDebug();            
        }        
    }
    if(KFPlayerInput(PlayerInput) != none)
    {
        KFPlayerInput(PlayerInput).DisplayDebug(HUD, out_YL, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Conductor'))
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if(KFGRI.bGameConductorGraphingEnabled)
        {
            DrawDebugConductor(HUD.Canvas);
        }
    }
}

function DrawDebugMemory(Canvas Canvas, out float out_YL, out float out_YPos)
{
    local int I, ClassCount;
    local float ClassSize, ResourceSize;
    local array< Class > MemoryArray;

    MemoryArray.AddItem(Class'KFWeapon';
    MemoryArray.AddItem(Class'KFWeaponAttachment';
    MemoryArray.AddItem(Class'KFPawn_Human';
    MemoryArray.AddItem(Class'KFPawn_Monster';
    MemoryArray.AddItem(Class'Projectile';
    Canvas.SetDrawColor(0, 255, 0);
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText("---------- KFPlayerController: Memory ----------");
    out_YPos += out_YL;
    I = 0;
    J0x136:

    if(I < MemoryArray.Length)
    {
        ClassCount = 0;
        ClassSize = 0;
        ResourceSize = 0;
        (((I % 2) == 0) ? Canvas.SetDrawColor(0, 255, 0) : Canvas.SetDrawColor(180, 255, 0));
        Class'KFGameEngine'.static.GetClassCountAndSize(ClassCount, ClassSize, ResourceSize, MemoryArray[I]);
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText(string(MemoryArray[I].Name) $ ":");
        Canvas.SetPos(154, out_YPos);
        Canvas.DrawText("# Objects = " $ string(ClassCount));
        Canvas.SetPos(254, out_YPos);
        Canvas.DrawText(("Class Size = " $ string(ClassSize)) $ "KB");
        Canvas.SetPos(404, out_YPos);
        Canvas.DrawText(("True Resource Size = " $ string(ResourceSize)) $ "MB");
        out_YPos += out_YL;
        ++ I;
        goto J0x136;
    }
}

function DrawDebugDifficulty(Canvas Canvas, out float out_YL, out float out_YPos)
{
    local KFGameInfo KFGI;
    local byte NumLivingPlayers, NumPlayers;

    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && KFGI.DifficultyInfo != none)
    {
        NumLivingPlayers = byte(KFGI.GetLivingPlayerCount());
        NumPlayers = byte(KFGI.GetNumPlayers());
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("---------- KFPlayerController: Difficulty ----------");
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, (("Current Difficulty: " @ "(") $ string(KFGI.GameDifficulty)) $ ")");
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Global Health Mod: " @ string(KFGI.DifficultyInfo.GetGlobalHealthMod()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Ground Speed Mod: " @ string(KFGI.DifficultyInfo.GetAIGroundSpeedMod()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Difficulty Wave Count Mod: " @ string(KFGI.DifficultyInfo.GetDifficultyMaxAIModifier()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Dosh Per Kill Mod: " @ string(KFGI.DifficultyInfo.GetKillCashModifier()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Starting Dosh: " @ string(KFGI.DifficultyInfo.GetAdjustedStartingCash()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Respawn Dosh: " @ string(KFGI.DifficultyInfo.GetAdjustedRespawnCash()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Active Ammo Pickups Mod: " @ string(KFGI.DifficultyInfo.GetAmmoPickupModifier()));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Active Weapon Pickups Mod: " @ string(KFGI.DifficultyInfo.GetItemPickupModifier()));
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.DrawText("---------- NumPlayer Modifiers ----------");
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Num Living Players: " @ string(NumLivingPlayers));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Hidden AI Movement Speed Mod: " @ string(KFGI.DifficultyInfo.GetAIHiddenSpeedModifier(NumLivingPlayers)));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Num Players Wave Count Mod: " @ string(KFGI.DifficultyInfo.GetPlayerNumMaxAIModifier(NumPlayers)));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, true, "Ammo Pickups Respawn Time: " @ string(KFGI.DifficultyInfo.GetAmmoPickupInterval(NumLivingPlayers)));
        DrawNextDebugLine(Canvas, out_YL, out_YPos, false, "Weapon Pickups Respawn Time: " @ string(KFGI.DifficultyInfo.GetWeaponPickupInterval(NumLivingPlayers)));
    }
}

function DrawNextDebugLine(out Canvas Canvas, out float out_YL, out float out_YPos, bool bAlternate, string DebugString, optional float XPos)
{
    ((!bAlternate) ? Canvas.SetDrawColor(0, 255, 0) : Canvas.SetDrawColor(180, 255, 0));
    out_YPos += out_YL;
    if(XPos != float(0))
    {
        Canvas.SetPos(XPos, out_YPos);
    }
    Canvas.DrawText(DebugString);
}

function DrawDebugSpawning(out Canvas Canvas)
{
    local float Buffer, XPos, YPos, BackgroundScale, MarkerScale, BackgroundWidth,
	    BackgroundHeight, HalfMarkerWidth, HalfMarkerHeight, CompleteCycle;

    local byte NumCycles;
    local KFGameReplicationInfo KFGRI;
    local Texture2D SineTex, MarkerTex;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFGRI == none)
    {
        return;
    }
    SineTex = Texture2D'AbsSine_TEX';
    MarkerTex = Texture2D'SineWaveMarker_TEX';
    BackgroundScale = 0.5;
    MarkerScale = 0.75 * BackgroundScale;
    BackgroundWidth = float(SineTex.SizeX) * BackgroundScale;
    BackgroundHeight = float(SineTex.SizeY) * BackgroundScale;
    HalfMarkerWidth = (float(MarkerTex.SizeX) * MarkerScale) / float(2);
    HalfMarkerHeight = (float(MarkerTex.SizeY) * MarkerScale) / float(2);
    Buffer = 8;
    XPos = (Canvas.ClipX - (float(SineTex.SizeX) * BackgroundScale)) - Buffer;
    YPos = Buffer;
    NumCycles = 1;
    CompleteCycle = 6.28 / KFGRI.CurrentSineWavFreq;
    DrawNextSpawnTimeInfo(Canvas, XPos, BackgroundHeight, Buffer * float(2));
    Canvas.SetPos(XPos, YPos);
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawTexture(SineTex, BackgroundScale);
    XPos += ((((KFGRI.CurrentTotalWavesActiveTime / CompleteCycle) % float(NumCycles)) * BackgroundWidth) - HalfMarkerWidth);
    YPos += ((KFGRI.CurrentSineMod * BackgroundHeight) - HalfMarkerHeight);
    Canvas.SetPos(XPos, YPos);
    Canvas.DrawTexture(MarkerTex, MarkerScale);
}

function DrawDebugMap(out Canvas Canvas);

simulated function DrawMapElement(Canvas Canvas, float ScreenScale, float AdjustedMapSize, Vector2D CenterLocation, Vector MapHolderLocation, Vector ElementLocation, class<KFPawn> ElementClass, Color IconColor, bool bUsingSuperSpeed, bool bDrawHeightArrows, optional bool BBox, optional Vector EnemyLocation, optional bool bFailed);

function DrawDebugConductor(out Canvas Canvas);

function DrawNextSpawnTimeInfo(out Canvas Canvas, float XPos, float YPos, float Buffer)
{
    local KFMapInfo KFMI;
    local float MapSpawnTime;
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFGRI != none)
    {
        KFMI = KFMapInfo(WorldInfo.GetMapInfo());
        MapSpawnTime = ((KFMI != none) ? KFMI.WaveSpawnPeriod : Class'KFMapInfo'.default.WaveSpawnPeriod);
        DrawNextDebugLine(Canvas, Buffer, YPos, false, "(Y Axis) Zed Spawning Intensity " @ string(float(1) - KFGRI.CurrentSineMod), XPos);
        DrawNextDebugLine(Canvas, Buffer, YPos, true, "Base Map Spawn Time: " @ string(MapSpawnTime), XPos);
        DrawNextDebugLine(Canvas, Buffer, YPos, false, "Length and Num Players Modifier: " @ string(KFGRI.CurrentNextSpawnTimeMod), XPos);
        if(KFGRI.CurrentMaxMonsters <= KFGRI.CurrentAIAliveCount)
        {
            DrawNextDebugLine(Canvas, Buffer, YPos, false, "Max Monsters Reached", XPos);            
        }
        else
        {
            if(KFGRI.bCurrentSMFinishedSpawning)
            {
                DrawNextDebugLine(Canvas, Buffer, YPos, false, "All zeds are in game", XPos);                
            }
            else
            {
                DrawNextDebugLine(Canvas, Buffer, YPos, false, "Time until next spawn: " @ string(KFGRI.CurrentTimeTilNextSpawn), XPos);
                DrawNextDebugLine(Canvas, Buffer, YPos, false, "Current spawn delay: " @ string(KFGRI.CurrentNextSpawnTime), XPos);
            }
        }
        DrawNextDebugLine(Canvas, Buffer, YPos, true, ((string(KFGRI.CurrentAIAliveCount) @ "/") @ string(KFGRI.CurrentMaxMonsters)) @ "Zeds In Game", XPos);
    }
}

event Destroyed()
{
    local KFProjectile KFProj;

    if(StingerAkComponent != none)
    {
        StingerAkComponent.StopEvents();
    }
    SetRTPCValue('Health', 100, true);
    PostAkEvent(LowHealthStopEvent);
    bPlayingLowHealthSFX = false;
    foreach DynamicActors(Class'KFProjectile', KFProj)
    {
        if(KFProj.InstigatorController == self)
        {
            KFProj.OnInstigatorControllerLeft();
        }        
    }    
    super(PlayerController).Destroyed();
}

function StartSpectate(optional name SpectateType)
{
    if(Role == ROLE_Authority)
    {
        if(IsLocalPlayerController())
        {
            ClientGotoState('Spectating');            
        }
        else
        {
            GotoState('Spectating');
            ClientGotoState('Spectating');
        }
    }
}

simulated function NextSpectateMode();

unreliable server function ServerSetSpectatorActive();

function NotifyChangeSpectateViewTarget()
{
    local KFPlayerReplicationInfo KFPRI;
    local KFPawn_Human KFP;

    KFP = KFPawn_Human(ViewTarget);
    if(((MyGFxHUD != none) && MyGFxHUD.SpectatorInfoWidget != none) && KFP != none)
    {
        if((KFP == Pawn) && Pawn.IsAliveAndWell())
        {
            return;
        }
        KFPRI = KFPlayerReplicationInfo(KFP.PlayerReplicationInfo);
        if(KFPRI != none)
        {
            MyGFxHUD.SpectatorInfoWidget.SetSpectatedKFPRI(KFPRI);
        }
    }
}

reliable client simulated event ClientSetViewTarget(Actor A, optional ViewTargetTransitionParams TransitionParams)
{
    local Vector ViewLocation;
    local Rotator ViewRotation;

    if(IsSpectating())
    {
        GetPlayerViewPoint(ViewLocation, ViewRotation);
        SetLocation(ViewLocation);
        ViewRotation.Roll = 0;
        SetRotation(ViewRotation);
        ServerSetSpectatorLocation(Location);
    }
    super(PlayerController).ClientSetViewTarget(A, TransitionParams);
    if((IsSpectating()) && ViewTarget != none)
    {
        NotifyChangeSpectateViewTarget();
    }
}

unreliable server function ServerNextSpectateMode()
{
    local KFPawn_Human HumanViewTarget;

    if(!IsSpectating())
    {
        return;
    }
    if(CurrentSpectateMode != 3)
    {
        HumanViewTarget = KFPawn_Human(ViewTarget);
        if((HumanViewTarget == none) || !HumanViewTarget.IsAliveAndWell())
        {
            SpectateRoaming();
            return;
        }
    }
    switch(CurrentSpectateMode)
    {
        case 0:
            SpectatePlayer(1);
            break;
        case 1:
            SpectatePlayer(2);
            break;
        case 2:
            SpectateRoaming();
            break;
        case 3:
            SpectatePlayer(0);
            break;
        default:
            break;
    }
}

function SpectatePlayer(KFPlayerController.KFSpectateModes Mode)
{
    if((PlayerCamera != none) && PlayerCamera.CameraStyle == 'Boss')
    {
        return;
    }
    CurrentSpectateMode = Mode;
    if(KFPawn_Human(ViewTarget) == none)
    {
        TryViewNextPlayer();
        if(KFPawn_Human(ViewTarget) == none)
        {
            SpectateRoaming();
            return;
        }
    }
    switch(Mode)
    {
        case 0:
            SetCameraMode('FreeCam');
            break;
        case 1:
            SetCameraMode('ThirdPerson');
            break;
        case 2:
            SetCameraMode('FirstPerson');
            break;
        default:
            break;
    }
}

reliable server function SpectateRoaming()
{
    CurrentSpectateMode = 3;
    ServerViewSelf();
    if(ViewTarget == self)
    {
        SetCameraMode('FirstPerson');
    }
}

reliable server function TryViewNextPlayer()
{
    local KFPawn_Human KFPHTarget;

    KFPHTarget = KFPawn_Human(ViewTarget);
    if((KFPHTarget == none) || KFPHTarget.IsAliveAndWell())
    {
        ServerViewNextPlayer();
    }
}

unreliable server function ServerViewNextPlayer()
{
    switch(CurrentSpectateMode)
    {
        case 0:
        case 1:
        case 2:
            super(PlayerController).ServerViewNextPlayer();
            break;
        default:
            break;
    }
}

function ReplicatePWRI()
{
    if(Role == ROLE_Authority)
    {
        if((self != none) && self.MatchStats != none)
        {
            self.MatchStats.RecordWaveInfo();
        }
        ++ PWRI.RepCount;
    }
}

function SavePersonalBest(EphemeralMatchStats.EPersonalBests PersonalBestID, int Value)
{
    StatsWrite.SavePersonalBest(PersonalBestID, Value);
}

function int GetPersonalBest(EphemeralMatchStats.EPersonalBests PersonalBestID)
{
    return StatsWrite.GetPersonalBest(PersonalBestID);
}

reliable client simulated function ClientReceiveAwardInfo(byte AwardID, PlayerReplicationInfo PRI, int Value)
{
    MatchStats.ReceiveAwardInfo(AwardID, PRI, Value);
}

reliable client simulated function ReceiveTopWeapons(TopWeaponReplicationInfo TopWeapons)
{
    MatchStats.UnpackTopWeapons(TopWeapons);
}

function ResetLastWaveInfo()
{
    PWRI.VectData1.X = 0;
    PWRI.VectData1.Y = 0;
    PWRI.VectData1.Z = 0;
    PWRI.VectData2.X = 0;
    PWRI.VectData2.Y = 0;
    PWRI.VectData2.Z = 0;
    PWRI.bKilledMostZeds = false;
    PWRI.bKilledFleshpoundLastWave = false;
    PWRI.bKilledScrakeLastWave = false;
    PWRI.ClassKilledByLastWave = none;
    PWRI.bAllSurvivedLastWave = false;
    PWRI.bSomeSurvivedLastWave = false;
    PWRI.bOneSurvivedLastWave = false;
    MatchStats.ZedsKilledLastWave = 0;
}

unreliable client simulated event ClientHearDialog(Actor DialogSpeaker, AkEvent DialogEvent, byte bCanBeMinimized)
{
    local KFPawn KFP;

    if((bCanBeMinimized == 1) && Class'KFGameEngine'.default.bMinimalChatter)
    {
        return;
    }
    KFP = KFPawn(DialogSpeaker);
    if(KFP != none)
    {
        KFP.PlayDialogEvent(DialogEvent);
    }
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    super(Controller).NotifyKilled(Killer, Killed, KilledPawn, DamageType);
    if((self == Killer) && self != Killed)
    {
        if(!PWRI.bKilledFleshpoundLastWave && KilledPawn.IsA('KFPawn_ZedFleshpound'))
        {
            PWRI.bKilledFleshpoundLastWave = true;            
        }
        else
        {
            if(!PWRI.bKilledScrakeLastWave && KilledPawn.IsA('KFPawn_ZedScrake'))
            {
                PWRI.bKilledScrakeLastWave = true;
            }
        }
        ++ MatchStats.ZedsKilledLastWave;
    }
    if(self == Killed)
    {
        SetLocation(KilledPawn.Location + (vect(0, 0, 1) * (KilledPawn.GetCollisionRadius() * 2)));
    }
}

function PlayTraderDialog(int DialogEventID)
{
    if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
    {
        KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayDialog(DialogEventID, self);
    }
}

reliable client simulated function ClientPlayTraderDialog(int DialogEventID)
{
    if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
    {
        KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlayDialog(DialogEventID, self);
    }
}

simulated function PlayTraderSelectItemDialog(bool bTooExpensive, bool bTooHeavy)
{
    if(((WorldInfo.NetMode != NM_DedicatedServer) && KFGameReplicationInfo(WorldInfo.GRI) != none) && KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager != none)
    {
        KFGameReplicationInfo(WorldInfo.GRI).TraderDialogManager.PlaySelectItemDialog(self, bTooExpensive, bTooHeavy);
    }
}

unreliable server function ServerPlayLevelUpDialog()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayLevelUpDialog(self);
    }
}

unreliable server function ServerPlayVoiceCommsDialog(int CommsIndex)
{
    BroadcastLocalizedMessage(Class'KFLocalMessage_VoiceComms', CommsIndex, PlayerReplicationInfo);
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayVoiceCommandDialog(KFPawn(Pawn), CommsIndex);
    }
}

function CancelDownload()
{
    ConsoleCommand("DISCONNECT");
}

reliable client simulated event bool ShowConnectionProgressPopup(Engine.PlayerController.EProgressMessageType ProgressType, string ProgressTitle, string ProgressDescription, optional bool SuppressPasswordRetry)
{
    local KFGameEngine KFGEngine;
    local KFGameViewportClient KFGVPC;
    local string CachedTitle, CachedMessage;

    SuppressPasswordRetry = false;
    if(MyGFxManager == none)
    {
        return false;
    }
    KFGVPC = KFGameViewportClient(LocalPlayer(Player).ViewportClient);
    if((KFGVPC != none) && KFGVPC.ErrorTitle != "")
    {
        KFGVPC.GetErrorMessage(CachedTitle, CachedMessage);        
    }
    else
    {
        CachedTitle = ProgressTitle;
        CachedMessage = ProgressDescription;
    }
    switch(ProgressType)
    {
        case 4:
        case 5:
            DestroyOnlineGame();
            KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
            if(KFGEngine != none)
            {
                switch(KFGEngine.LastConnectionError)
                {
                    case 2:
                    case 3:
                        if(SuppressPasswordRetry)
                        {
                            MyGFxManager.OpenPopup(2, CachedTitle, CachedMessage, Class'KFCommon_LocalizedStrings'.default.OKString);
                            KFGEngine.LastConnectionError = 0;                            
                        }
                        else
                        {
                            MyGFxManager.OpenPopup(4, CachedMessage, "", Class'KFCommon_LocalizedStrings'.default.ConfirmString, Class'KFCommon_LocalizedStrings'.default.CancelString, OnAttemptPassword);
                            KFGEngine.LastConnectionError = 0;
                        }
                        return true;
                    default:
                        MyGFxManager.OpenPopup(2, CachedTitle, CachedMessage, Class'KFCommon_LocalizedStrings'.default.OKString);
                        KFGEngine.LastConnectionError = 0;
                        return true;
                        break;
                }
            }
            break;
        case 2:
        case 3:
            MyGFxManager.OpenPopup(0, CachedTitle, CachedMessage, "", "", None, None, Class'KFCommon_LocalizedStrings'.default.CancelString, CancelDownload);
            return true;
            break;
        default:
            break;
    }
    return false;
}

event bool NotifyDisconnect(string Command)
{
    ClientWriteAndFlushStats();
    DestroyOnlineGame();
    return super(PlayerController).NotifyDisconnect(Command);
}

event DestroyOnlineGame()
{
    OnlineSub.GameInterface.DestroyOnlineGame(PlayerReplicationInfo.SessionName);
}

function OnAttemptPassword()
{
    local string URL, Password;
    local KFGameViewportClient Viewport;

    Password = KFGFxPopup_InputPrompt(MyGFxManager.CurrentPopup).PlayerInputString;
    Viewport = KFGameViewportClient(LocalPlayer(Player).ViewportClient);
    URL = (("Open" @ Viewport.LastConnectionAttemptAddress) $ "?Password=") $ Password;    
    ConsoleCommand(URL);
}

function ClearOnlineDelegates()
{
    OnlineSub.GameInterface.ClearOnlineDelegates();
    super(PlayerController).ClearOnlineDelegates();
}

state PlayerWalking
{
    ignores SeePlayer, HearNoise, Bump;

    function ProcessMove(float DeltaTime, Vector newAccel, Engine.Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        local float MinMoveScale, MaxMoveScale;
        local InterpCurveFloat MoveSensitivityCurve;

        super.ProcessMove(DeltaTime, newAccel, DoubleClickMove, DeltaRot);
        MoveSensitivityCurve = Class'KFPlayerInput'.default.MoveSensitivityScaleCurve;
        MinMoveScale = MoveSensitivityCurve.Points[0].OutVal;
        MaxMoveScale = MoveSensitivityCurve.Points[MoveSensitivityCurve.Points.Length - 1].OutVal;
        Pawn.MovementSpeedModifier = Lerp(MaxMoveScale, MinMoveScale, float(DoubleClickMove) / float(4));
    }

    function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        if(Pawn != none)
        {
            Pawn.MovementSpeedModifier = 1;
        }
    }
    stop;    
}

state Dead
{
    event BeginState(name PreviousStateName)
    {
        local KFPawn KFP;
        local KFGameInfo KFGI;
        local KFGameReplicationInfo KFGRI;
        local KFPlayerInput KFPI;

        super.BeginState(PreviousStateName);
        SetTimer(5, false, 'StartSpectate');
        ResetGameplayPostProcessFX();
        KFP = KFPawn(ViewTarget);
        if((KFP != none) && UsingFirstPersonCamera())
        {
            KFP.Mesh.SetOwnerNoSee(true);
            KFP.Mesh.CastShadow = false;
            KFP.SetThirdPersonAttachmentVisibility(false);
            KFP.SetFirstPersonVisibility(false);
        }
        if(CurrentPerk != none)
        {
            CurrentPerk.PlayerDied();
        }
        KFGI = KFGameInfo(WorldInfo.Game);
        if((((((Role == ROLE_Authority) && KFGI != none) && KFGI.GetLivingPlayerCount() > 0) && KFP != none) && !KFP.bPendingDelete) && !KFP.IsA('KFPawn_Customization'))
        {
            KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
            if((KFGRI != none) && KFGRI.bMatchHasBegun)
            {
                ReceiveLocalizedMessage(Class'KFLocalMessage_Priority', 11);
            }
        }
        KFPI = KFPlayerInput(PlayerInput);
        if(KFPI != none)
        {
            KFPI.HideVoiceComms();
        }
        if(MyGFxManager != none)
        {
            MyGFxManager.CloseMenus();
        }
        if(MyGFxHUD != none)
        {
            MyGFxHUD.ClearBuffIcons();
        }
    }

    exec function StartFire(optional byte FireModeNum)
    {
        StartSpectate();
    }

    function SetViewTarget(Actor NewViewTarget, optional ViewTargetTransitionParams TransitionParams)
    {
        if(PlayerCamera.CameraStyle == 'Boss')
        {
            super(PlayerController).SetViewTarget(NewViewTarget, TransitionParams);
        }
    }

    event EndState(name NextStateName)
    {
        local KFPawn KFP;

        super.EndState(NextStateName);
        ClearTimer('StartSpectate');
        KFP = KFPawn(ViewTarget);
        if(KFP != none)
        {
            KFP.Mesh.CastShadow = KFP.Mesh.default.CastShadow;
        }
        NotifyChangeSpectateViewTarget();
    }

    event ResetCameraMode()
    {
        if(Role == ROLE_Authority)
        {
            global.ResetCameraMode();
        }
    }
    stop;    
}

state Spectating
{
    ignores StartFire;

    event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(MyGFxHUD != none)
        {
            MyGFxHUD.SetHUDSpectating(true);
        }
        if(Role == ROLE_Authority)
        {
            SpectatePlayer(ROLE_None);
            NotifyChangeSpectateViewTarget();
        }
        if(WorldInfo.NetMode == NM_Standalone)
        {
            ToggleHealthEffects(false);
        }
    }

    exec function SpectateNextPlayer()
    {
        ServerViewNextPlayer();
        if(Role == ROLE_Authority)
        {
            NotifyChangeSpectateViewTarget();
        }
    }

    exec function SpectatePreviousPlayer()
    {
        ServerViewPrevPlayer();
        if(Role == ROLE_Authority)
        {
            NotifyChangeSpectateViewTarget();
        }
    }

    exec function SpectateChangeCamMode()
    {
        ServerNextSpectateMode();
    }

    event EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        if(MyGFxHUD != none)
        {
            MyGFxHUD.SetHUDSpectating(false);
        }
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z;
        local Rotator OldRotation;

        OldRotation = Rotation;
        GetAxes(Rotation, X, Y, Z);
        Acceleration = ((PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y)) + (PlayerInput.aUp * vect(0, 0, 1));
        UpdateRotation(DeltaTime);
        if(Role < ROLE_Authority)
        {
            ReplicateMove(DeltaTime, Acceleration, 0, rot(0, 0, 0));
            if((!IsZero(Acceleration) || OldRotation != Rotation) && (WorldInfo.TimeSeconds - LastUpdateSpectatorActiveTime) > UpdateSpectatorActiveInterval)
            {
                LastUpdateSpectatorActiveTime = WorldInfo.TimeSeconds;
                ServerSetSpectatorActive();
            }            
        }
        else
        {
            ProcessMove(DeltaTime, Acceleration, 0, rot(0, 0, 0));
        }
    }

    unreliable server function ServerSetSpectatorActive()
    {
        LastActiveTime = WorldInfo.TimeSeconds;
    }
    stop;    
}

defaultproperties
{
    PerkList(0)=(PerkClass=Class'KFPerk_Berserker',PerkLevel=0,PerkArchetype=none)
    PerkList(1)=(PerkClass=Class'KFPerk_Commando',PerkLevel=0,PerkArchetype=none)
    PerkList(2)=(PerkClass=Class'KFPerk_Support',PerkLevel=0,PerkArchetype=none)
    PerkList(3)=(PerkClass=Class'KFPerk_FieldMedic',PerkLevel=0,PerkArchetype=none)
    PerkList(4)=(PerkClass=Class'KFPerk_Demolitionist',PerkLevel=0,PerkArchetype=none)
    PerkList(5)=(PerkClass=Class'KFPerk_Firebug',PerkLevel=0,PerkArchetype=none)
    PerkList(6)=(PerkClass=Class'KFPerk_Gunslinger',PerkLevel=0,PerkArchetype=none)
    ServPendingPerkBuild=-1
    ServPendingPerkLevel=-1
    MusicMessageType=Music
    bReflectionsEnabled=true
    bTrackingMapTopView=true
    SavedPerkIndex=1
    ZedTimeEnterSound=AkEvent'WW_GLO_Runtime.Set_ZEDTime_On'
    ZedTimeExitSound=AkEvent'WW_GLO_Runtime.Set_ZEDTime_Off'
    ZedTimePartialEnterSound=AkEvent'WW_GLO_Runtime.Set_ZEDTime_Partial_On'
    ZedTimePartialExitSound=AkEvent'WW_GLO_Runtime.Set_ZEDTime_Partial_Off'
    PauseWwiseEvent=AkEvent'AK_GLO_Runtime.Pause_All'
    ResumeWwiseEvent=AkEvent'AK_GLO_Runtime.Resume_All'
    EarsRingingPlayEvent=AkEvent'WW_UI_PlayerCharacter.Play_PC_Concussion_Ear_Ring_Loop'
    EarsRingingStopEvent=AkEvent'WW_UI_PlayerCharacter.Stop_PC_Concussion_Ear_Ring_Loop'
    LowHealthStartEvent=AkEvent'WW_UI_PlayerCharacter.Play_UI_Low_Health_LP'
    LowHealthStopEvent=AkEvent'WW_UI_PlayerCharacter.Stop_UI_Low_Health_LP'
    begin object name=AkComponent class=AkComponent
        BoneName=Root
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPlayerController.AkComponent'
    StingerAkComponent=AkComponent
    ResetFiltersEvent=AkEvent'WW_UI_PlayerCharacter.Reset_LowPass_Filters'
    FlashlightOnEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_Flashlight_TurnOn'
    FlashlightOffEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_Flashlight_TurnOff'
    NightVisionOnEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_Nightvision_TurnOn'
    NightVisionOffEvent=AkEvent'WW_UI_PlayerCharacter.Play_WEP_Nightvision_TurnOff'
    AllMapCollectiblesFoundEvent=AkEvent'WW_UI_PlayerCharacter.Play_UI_Collectible_CollectAll'
    GameplayPostProcessEffectName=GameplayEffect
    EffectPainParamName=Effect_Pain
    EffectLowHealthParamName=Effect_LowHealth
    EffectZedTimeParamName=Effect_ZEDTIME
    EffectNightVisionParamName=Effect_NightVision
    EffectSirenScreamParamName=Effect_Siren
    EffectBloatsPukeParamName=Effect_Puke
    EffectHealParamName=Effect_Heal
    EffectPerkParamName=Effect_PerkSkill
    PainEffectDuration=0.5
    HealEffectDuration=1
    SonicScreamEffectDuration=6
    BloatPukeEffectDuration=2
    LowHealthThreshold=50
    CurrentZEDTimeEffectIntensity=-1
    PartialZEDTimeEffectIntensity=0.35
    begin object name=AmplificationLightTemplate class=PointLightComponent
        Radius=200
        bAIIgnoreLuminosity=true
        Brightness=0.02
        CastShadows=false
        CastStaticShadows=false
        bDisableSpecular=true
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPlayerController.AmplificationLightTemplate'
    AmplificationLightTemplate=AmplificationLightTemplate
    begin object name=NVGLightTemplate class=PointLightComponent
        Radius=800
        bAIIgnoreLuminosity=true
        Brightness=0.05
        bEnabled=false
        CastShadows=false
        CastStaticShadows=false
        bDisableSpecular=true
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPlayerController.NVGLightTemplate'
    NVGLightTemplate=NVGLightTemplate
    DOFFocalRange=0.25
    DOFFocalAperture=0.2
    DOFFocusBlendRate=2
    DOFMaxFocusDepth=5000
    DOFMaxEnemyAngle=15
    DOF_NVG_BlendInSpeed=4
    DOF_NVG_BlendOutSpeed=10
    NVG_FocusBlendRate=3
    NVG_ImageGrainScale=6
    NVG_DOF_FocalDistance=1200
    NVG_DOF_SharpRadius=1000
    NVG_DOF_FocalRadius=1200
    NVG_DOF_MaxNearBlurSize=4
    NVG_DOF_MaxFarBlurSize=3
    NVG_DOF_ExpFalloff=1
    DOF_Cinematic_BlendInSpeed=50
    DOF_Cinematic_BlendOutSpeed=10
    DOF_Cinematic_FocalDistance=300
    DOF_Cinematic_SharpRadius=200
    DOF_Cinematic_FocalRadius=300
    DOF_Cinematic_MaxFarBlurSize=4
    DOF_Cinematic_ExpFalloff=1
    BlurBlendInSpeed=1
    BlurBlendOutSpeed=1
    MatchStatsClass=Class'EphemeralMatchStats'
    UpdateSpectatorActiveInterval=1
    ScoreTargetDistanceCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0.3,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    MaxAimCorrectionDistance=10000
    TrackerXPosition=0.67
    TrackerYPosition=0.025
    TrackingMapScale=1
    TrackerSpawnVolumeSizeX=15
    TrackerSpawnVolumeSizeY=13
    TrackingMapRange=5000
    CameraClass=Class'KFPlayerCamera'
    bCheckSoundOcclusion=true
    DesiredFOV=90
    DefaultFOV=90
    CheatClass=Class'KFCheatManager'
    InputClass=Class'KFPlayerInput'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPlayerController.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    ForceFeedbackManagerClassName="WinDrv.XnaForceFeedbackManager"
    bSkipExtraLOSChecks=true
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPlayerController.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=AkComponent class=AkComponent
        BoneName=Root
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPlayerController.AkComponent'
    Components(1)=AkComponent
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPlayerController.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}