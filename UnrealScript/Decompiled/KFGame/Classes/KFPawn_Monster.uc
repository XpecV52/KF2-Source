/*******************************************************************************
 * KFPawn_Monster generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_Monster extends KFPawn
    abstract
    native(Pawn)
    nativereplication
    config(Game)
    hidecategories(Navigation);

const SLOW_SPEED_MOD = 0.8f;

enum EPlayerZedGamepadMove
{
    ZGM_Attack_R2,
    ZGM_Block_R1,
    ZGM_Melee_Square,
    ZGM_Special_R3,
    ZGM_Explosive_Ll,
    ZGM_Attack_L2,
    ZGM_Melee_Triangle,
    ZGM_MAX
};

struct native DamageModifierInfo
{
    /** A damage type to modify damage to this zed when it is received */
    var() class<DamageType> DamageType;
    /** Damage scale for this damage type. Additional array elements (MAX:4) can be used to modify for higher game difficulties */
    var() array<float> DamageScale;

    structdefaultproperties
    {
        DamageType=none
        DamageScale(0)=1
    }
};

struct native SpecialMoveCooldownInfo
{
    var float CoolDownTime;
    var transient float LastUsedTime;
    var KFPawn.ESpecialMove SMHandle;
    var Texture2D SpecialMoveIcon;
    var int Charges;
    var string NameLocalizationKey;
    var bool bShowOnHud;

    structdefaultproperties
    {
        CoolDownTime=0
        LastUsedTime=0
        SMHandle=ESpecialMove.SM_None
        SpecialMoveIcon=Texture2D'UI_Widgets.MenuBarWidget_SWF_IF'
        Charges=-1
        NameLocalizationKey=""
        bShowOnHud=true
    }
};

struct native sBlockInfo
{
    var float Chance;
    var float Duration;
    var float MaxBlocks;
    var float Cooldown;
    var float DamagedHealthPctToTrigger;
    var float MeleeDamageModifier;
    var float DamageModifier;
    var float AfflictionModifier;
    var float SoloChanceMultiplier;

    structdefaultproperties
    {
        Chance=0
        Duration=0
        MaxBlocks=0
        Cooldown=0
        DamagedHealthPctToTrigger=0
        MeleeDamageModifier=1
        DamageModifier=1
        AfflictionModifier=1
        SoloChanceMultiplier=0
    }
};

struct native sRallyInfo
{
    var bool bCanRally;
    var bool bCauseSprint;
    var float RallyBuffTime;
    var float TakenDamageModifier;
    var float DealtDamageModifier;

    structdefaultproperties
    {
        bCanRally=true
        bCauseSprint=false
        RallyBuffTime=10
        TakenDamageModifier=1
        DealtDamageModifier=1
    }
};

struct native AttachedGoreChunkInfo
{
    var int AttachmentIndex;
    var export editinline StaticMeshComponent AttachedComponent;

    structdefaultproperties
    {
        AttachmentIndex=0
        AttachedComponent=none
    }
};

struct native ExtraVFXInfo
{
    /**  
     *@name  ExtraVFX
     *// Particle effect to play
     */
    var() ParticleSystem VFX;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)

     */
    var() name SocketName;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)

     */
    var() name Label;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)
// Audio event to play when vfx start

     */
    var() AkEvent SFXStartEvent;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)
// Audio event to play when vfx start
// Audio event to play when vfx stop

     */
    var() AkEvent SFXStopEvent;

    structdefaultproperties
    {
        VFX=none
        SocketName=None
        Label=None
        SFXStartEvent=none
        SFXStopEvent=none
    }
};

struct native ExtraVFXAttachmentInfo
{
    var export editinline ParticleSystemComponent VFXComponent;
    var ExtraVFXInfo Info;

    structdefaultproperties
    {
        VFXComponent=none
        Info=(VFX=none,SocketName=None,Label=None,SFXStartEvent=none,SFXStopEvent=none)
    }
};

var bool bLargeZed;
var bool bVersusZed;
var(Combat) bool bCanGrabAttack;
var(Combat) bool bCanMeleeAttack;
var(Combat) bool bHasExtraSprintJumpVelocity;
var repnotify bool bIsHeadless;
var protected bool bHasReducedMeleeDamage;
var protected bool bShowHealth;
var transient bool bCheckingExtraHeadDamage;
var bool bJumped;
var repnotify bool bIsPoisoned;
var bool bMicrowavePanicked;
var bool bKnockdownWhenJumpedOn;
var bool bDisableGoreMeshWhileAlive;
var bool bUseExplosiveDeath;
var bool bUseDamageInflation;
var bool bPlayPanicked;
var bool bPlayShambling;
var transient bool bIsBlocking;
var bool bCloakOnMeleeEnd;
var bool bIsCloakingSpottedByLP;
var repnotify bool bIsCloakingSpottedByTeam;
var bool bCanRage;
var repnotify bool bIsEnraged;
var private bool bIsStalkerClass;
var private bool bIsCrawlerClass;
var private bool bIsFleshpoundClass;
var private bool bIsClotClass;
var private bool bIsBloatClass;
var bool bMatchEnemySpeed;
var bool bRestoreCollisionOnLand;
var bool bPlayingSprintLoop;
var transient bool bPlayedExplosionEffect;
var bool bCouldTurnIntoShrapnel;
var bool bDisableHeadless;
var bool bDebug_DrawOverheadInfo;
var bool bDebug_DrawSprintingOverheadInfo;
var const bool bDebug_UseIconForShowingSprintingOverheadInfo;
var bool bDebug_SpawnedThroughCheat;
var bool bReducedZedOnZedPinchPointCollisionStateActive;
var protected bool bOnDeathAchivementbDisabled;
var const string MonsterArchPath;
var private const KFCharacterInfo_Monster CharacterMonsterArch;
var const array< class<KFPawn_Monster> > ElitePawnClass;
/** Custom third person camera offsets */
var() ViewOffsetData ThirdPersonViewOffset;
var int RandomColorIdx;
var export editinline array<export editinline StaticMeshComponent> StaticAttachList;
/** The chance that this monster pawn will sprint */
var(Combat) float SprintChance;
/** Odds (0-1) of evaluating whether to do a grab attack instead of a basic melee attack */
var(Combat) float GrabAttackFrequency;
/** The amount to scale this Zed's damage based on difficulty */
var(Combat) float DifficultyDamageMod;
/** GameInfo based damage resistance modifier cached at spawn time (0: Ignore, 1: Standard) */
var(Combat) float GameResistancePct;
/** Time until death after head is taken off */
var(Combat) float HeadlessBleedOutTime;
var byte MaxHeadChunkGoreWhileAlive;
var byte ParryResistance;
var repnotify byte RepInflateMatParam;
var repnotify byte RepDamageInflateParam;
var repnotify byte RepBleedInflateMatParam;
/**  
 *When spawning in a spawn volume, the squad type as to be at least this big (can be bigger
 *  if there are other zeds in the spawn squad that are larger).
 */
var() KFSpawnVolume.ESquadType MinSpawnSquadSizeType;
var repnotify byte RepArmorPct[3];
var repnotify byte ArmorZoneStatus;
var byte PreviousArmorZoneStatus;
/** Object that manages melee attacks, and stores default damage */
var(Weapon) export editinline KFMeleeHelperAI MeleeAttackHelper;
var private const int DoshValue;
var private const float XPValues[4];
/** List of sockets representing weakpoint zone locations */
var() array<name> WeakSpotSocketNames;
var array<DamageModifierInfo> DamageTypeModifiers;
var array<DamageModifierInfo> LiveDamageTypeModifiers;
var float ZedBumpDamageScale;
/** Base human-controlled melee damage */
var(Combat) float HumanBaseMeleeDamage;
var class<KFMonsterDifficultyInfo> DifficultySettings;
var array<KFPawn.ESpecialMove> MoveListGamepadScheme;
var array<SpecialMoveCooldownInfo> SpecialMoveCooldowns;
var transient float LastAttackHumanWarningTime;
var transient int OldHealth;
var float ZeroHealthInflation;
var float DamageInflationRate;
var float DamageDeflationRate;
var float IntendedDamageInflationPercent;
var float DamageInflationPercent;
var float InflateDeathGravity;
var float InflationExplosionTimer;
var const ParticleSystem BleedIncapFX;
var export editinline ParticleSystemComponent BleedIncapPSC;
var KFAnim_RandomScripted WalkBlendList;
var protected transient sBlockInfo DifficultyBlockSettings;
var protected const float MinBlockFOV;
var protected const float BlockSprintSpeedModifier;
var transient float LastBlockTime;
var float KnockedDownBySonicWaveOdds;
var float LastSpottedStatusUpdate;
var KFPlayerController LastStoredCC;
var export editinline transient ParticleSystemComponent RallyPSC;
var export editinline transient ParticleSystemComponent RallyHandPSCs[2];
var protected transient sRallyInfo DifficultyRallySettings;
var transient float NormalGroundSpeed;
var transient float NormalSprintSpeed;
var transient float InitialGroundSpeedModifier;
var transient float LastAISpeedCheckTime;
var transient float LastLOSOrRelevantTime;
var float MatchEnemySpeedAtDistance;
var float MinimumEnemySpeedToMatch;
var float PursuitSpeedScale;
var float ReachedEnemyThresholdScale;
var float ReachedGoalThresh_Walking;
var float ReachedGoalThresh_Spider;
var float LastBumpTime;
var float BumpFrequency;
var class<KFDamageType> BumpDamageType;
var class<KFDamageType> JumpBumpDamageType;
var protected float FootstepCameraShakeInnerRadius;
var protected float FootstepCameraShakeOuterRadius;
var CameraShake FootstepCameraShake;
var float DesiredAdjustedGroundSpeed;
var float DesiredAdjustedSprintSpeed;
var float SpeedAdjustTransitionRate;
var export editinline AkComponent SprintAkComponent;
var export editinline AkComponent HeadShotAkComponent;
var AkEvent StartSprintingSound;
var AkEvent SprintLoopingSound;
var AkEvent StopSprintingSound;
var transient array<AttachedGoreChunkInfo> AttachedGoreChunks;
var transient int NumHeadChunksRemoved;
var transient array<name> BrokenHeadBones;
var protected transient float LastNapalmInfectCheckTime;
var transient int DeadHorseHitStreakAmt;
var transient float LastDeadHorseHitTime;
var float DefaultCollisionRadius;
var KFTrigger_ChokePoint CurrentChokePointTrigger;
var const float CollisionRadiusForReducedZedOnZedPinchPointCollisionState;
var protected const int OnDeathAchievementID;
var class<KFZedArmorInfo> ArmorInfoClass;
var KFZedArmorInfo ArmorInfo;
var const int OverrideArmorFXIndex;
var transient array<ExtraVFXAttachmentInfo> ExtraVFXAttachments;
var delegate<GoreChunkAttachmentCriteria> __GoreChunkAttachmentCriteria__Delegate;
var delegate<GoreChunkDetachmentCriteria> __GoreChunkDetachmentCriteria__Delegate;

replication
{
     if(bNetDirty)
        InflateDeathGravity, InflationExplosionTimer, 
        MaxHeadChunkGoreWhileAlive, RepBleedInflateMatParam, 
        RepDamageInflateParam, RepInflateMatParam, 
        bDisableGoreMeshWhileAlive, bDisableHeadless, 
        bIsHeadless, bIsPoisoned, 
        bPlayPanicked, bPlayShambling, 
        bUseDamageInflation, bUseExplosiveDeath;

     if(bNetDirty && bCanCloak)
        bIsCloakingSpottedByTeam;

     if(bNetDirty && bCanRage)
        bIsEnraged;

     if(Role == ROLE_Authority)
        ArmorZoneStatus, RepArmorPct;
}

simulated delegate bool GoreChunkAttachmentCriteria();

simulated delegate bool GoreChunkDetachmentCriteria();

// Export UKFPawn_Monster::execSpiderPhysicsWallAdjust(FFrame&, void* const)
native function bool SpiderPhysicsWallAdjust(Vector HitNormal, Actor HitActor);

// Export UKFPawn_Monster::execSetChokePointCollision(FFrame&, void* const)
native function SetChokePointCollision(bool bUseChokeCollision);

// Export UKFPawn_Monster::execCheckEncroachingWorldGeometry(FFrame&, void* const)
native function bool CheckEncroachingWorldGeometry();

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'bIsHeadless':
            StopAkEventsOnBone('head');
            bCanBeAdheredTo = false;
            bCanBeFrictionedTo = false;
            break;
        case 'bIsPoisoned':
            AfflictionHandler.ToggleEffects(6, bIsPoisoned);
            break;
        case 'RepInflateMatParam':
            AfflictionHandler.UpdateMaterialParameter(10, GetCurrentInflation());
            break;
        case 'RepBleedInflateMatParam':
            AfflictionHandler.UpdateMaterialParameter(11, ByteToFloat(RepBleedInflateMatParam));
            UpdateBleedIncapFX();
            break;
        case 'Controller':
            SetSwitch('Player_Zed', ((IsHumanControlled()) ? 'Player' : 'NotPlayer'));
            break;
        case 'bEmpDisrupted':
            if(bEmpDisrupted)
            {
                PutAllMovesOnCooldown();
            }
            break;
        case 'RepDamageInflateParam':
            HandleDamageInflation();
            break;
        case 'RepArmorPct':
            if(ArmorInfo != none)
            {
                ArmorInfo.UpdateArmorPieces();
            }
            break;
        case 'ArmorZoneStatus':
            if(ArmorInfo != none)
            {
                ArmorInfo.UpdateArmorPieces();
            }
            break;
        case 'bIsEnraged':
            SetEnraged(bIsEnraged);
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

static simulated function int GetDoshValue()
{
    return default.DoshValue;
}

static simulated function float GetXPValue(byte Difficulty)
{
    return default.XPValues[Difficulty];
}

static event class<KFPawn_Monster> GetAIPawnClassToSpawn()
{
    local WorldInfo WI;

    WI = Class'WorldInfo'.static.GetWorldInfo();
    if(((default.ElitePawnClass.Length > 0) && default.DifficultySettings != none) && FRand() < default.DifficultySettings.static.GetSpecialSpawnChance(KFGameReplicationInfo(WI.GRI)))
    {
        return default.ElitePawnClass[Rand(default.ElitePawnClass.Length)];
    }
    return default.Class;
}

// Export UKFPawn_Monster::execPreloadContent(FFrame&, void* const)
native static final function PreloadContent();

// Export UKFPawn_Monster::execLastChanceLoad(FFrame&, void* const)
private native final function LastChanceLoad();

simulated event PreBeginPlay()
{
    CheckShouldAlwaysBeRelevant();
    DefaultCollisionRadius = CylinderComponent.default.CollisionRadius;
    super.PreBeginPlay();
    if(CharacterArch == none)
    {
        if(CharacterMonsterArch == none)
        {
            LastChanceLoad();
        }
        if(CharacterMonsterArch != none)
        {
            SetCharacterArch(CharacterMonsterArch);
        }
    }
    if(CharacterArch == none)
    {
        WarnInternal("Failed to find character info for KFMonsterPawn!");
        Destroy();
    }
    NormalGroundSpeed = default.GroundSpeed;
    NormalSprintSpeed = default.SprintSpeed;
    if(ArmorInfoClass != none)
    {
        ArmorInfo = new (self) ArmorInfoClass;
    }
}

simulated event CheckShouldAlwaysBeRelevant()
{
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if((KFGRI != none) && float(KFGRI.AIRemaining) <= Class'KFGameInfo'.static.GetNumAlwaysRelevantZeds())
    {
        bAlwaysRelevant = true;
    }
}

simulated event PostBeginPlay()
{
    local KFGameReplicationInfo KFGRI;

    super.PostBeginPlay();
    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFGRI != none)
    {
        SetRallySettings(DifficultySettings.static.GetRallySettings(self, KFGRI));
        SetZedTimeSpeedScale(DifficultySettings.static.GetZedTimeSpeedScale(self, KFGRI));
    }
    if((WorldInfo.NetMode != NM_Client) && IsABoss())
    {
        if((WorldInfo.GRI != none) && WorldInfo.GRI.GameClass.static.AllowAnalyticsLogging())
        {
            WorldInfo.TWLogEvent("boss_spawn", none, string(Class.Name));
        }
    }
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    local int I;

    super.SetMeshLightingChannels(NewLightingChannels);
    I = 0;
    J0x1E:

    if(I < StaticAttachList.Length)
    {
        if(StaticAttachList[I] != none)
        {
            StaticAttachList[I].SetLightingChannels(NewLightingChannels);
        }
        ++ I;
        goto J0x1E;
    }
}

simulated function NotifyTeamChanged()
{
    if(CharacterArch != none)
    {
        CharacterArch.SetCharacterFromArch(self, KFPlayerReplicationInfo(PlayerReplicationInfo));
    }
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    local string NPCName;
    local KFPlayerReplicationInfo KFPRI;
    local KFGameReplicationInfo KFGRI;

    super.PossessedBy(C, bVehicleTransition);
    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if(KFAIController(C) != none)
    {
        MyKFAIC = KFAIController(C);
        if((!bDebug_SpawnedThroughCheat || WorldInfo.Game.GetStateName() == 'DebugSuspendWave' && KFGRI != none) && !KFGRI.bWaveIsActive)
        {
            Suicide();
            return;
        }
    }
    bReducedZedOnZedPinchPointCollisionStateActive = false;
    if(IsHumanControlled())
    {
        KFPRI = KFPlayerReplicationInfo(C.PlayerReplicationInfo);
        if(KFPRI != none)
        {
            KFPRI.PlayerHealth = byte(Health);
            KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
            SetCharacterArch(CharacterMonsterArch, true);
        }
        if(Role == ROLE_Authority)
        {
            LastAttackHumanWarningTime = WorldInfo.TimeSeconds;
        }        
    }
    else
    {
        AirControl = 0.35;
    }
    KFGameInfo(WorldInfo.Game).SetMonsterDefaults(self);
    if((MyKFAIC != none) && MyKFAIC.PlayerReplicationInfo != none)
    {
        NPCName = string(self);
        NPCName = Repl(NPCName, "KFPawn_Zed", "", false);
        PlayerReplicationInfo.PlayerName = NPCName;
        MyKFAIC.PlayerReplicationInfo.PlayerName = NPCName;
    }
    if(KFGRI != none)
    {
        SetBlockSettings(DifficultySettings.static.GetBlockSettings(self, KFGRI));
        if(MyKFAIC != none)
        {
            MyKFAIC.EvadeOnDamageSettings = DifficultySettings.static.GetEvadeOnDamageSettings(self, KFGRI);
        }
    }
    if(ArmorInfo != none)
    {
        ArmorInfo.InitArmor();
    }
    SetSwitch('Player_Zed', ((IsHumanControlled()) ? 'Player' : 'NotPlayer'));
}

event BaseChange()
{
    if(IsAliveAndWell() && MyKFAIC != none)
    {
        if(MyKFAIC.NotifyBaseChange(Base, Floor))
        {
            return;
        }
    }
    super.BaseChange();
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    WalkBlendList = KFAnim_RandomScripted(SkelComp.FindAnimNode('WalkRandomList'));
}

function ApplySpecialZoneHealthMod(float HealthMod)
{
    HitZones[0].GoreHealth = int(float(default.HitZones[0].GoreHealth) * HealthMod);
    HitZones[0].MaxGoreHealth = HitZones[0].GoreHealth;
}

function SetShieldScale(float InScale)
{
    if(ArmorInfo != none)
    {
        ArmorInfo.SetShieldScale(InScale);
    }
}

function bool CanTakeOver()
{
    local KFVersusNoTakeoverVolume KFNTV;

    if(((bVersusZed || IsDoingSpecialMove()) || IsHeadless()) || !IsAliveAndWell())
    {
        return false;
    }
    foreach TouchingActors(Class'KFVersusNoTakeoverVolume', KFNTV)
    {        
        return false;        
    }    
    return true;
}

simulated event Tick(float DeltaTime)
{
    super.Tick(DeltaTime);
    if((WorldInfo.NetMode != NM_DedicatedServer) && IsAliveAndWell())
    {
        if(bIsSprinting && VSizeSq(Velocity) > 40000)
        {
            if(!bPlayingSprintLoop)
            {
                if((StartSprintingSound != none) && !SprintAkComponent.IsPlaying(StartSprintingSound))
                {
                    SprintAkComponent.PlayEvent(StartSprintingSound, true, true);
                }
            }
            if((SprintLoopingSound != none) && !SprintAkComponent.IsPlaying(SprintLoopingSound))
            {
                SprintAkComponent.PlayEvent(SprintLoopingSound, true, true);
                bPlayingSprintLoop = true;
            }            
        }
        else
        {
            if(bPlayingSprintLoop && !bIsSprinting || VSizeSq(Velocity) <= 40000)
            {
                if((SprintLoopingSound != none) && SprintAkComponent.IsPlaying(SprintLoopingSound))
                {
                    SprintAkComponent.StopEvents();
                    bPlayingSprintLoop = false;
                }
                if((StopSprintingSound != none) && !SprintAkComponent.IsPlaying(StopSprintingSound))
                {
                    SprintAkComponent.PlayEvent(StopSprintingSound, true, true);
                }
            }
        }
    }
}

simulated function SetCharacterArch(KFCharacterInfoBase Info, optional bool bForce)
{
    super.SetCharacterArch(Info, bForce);
    PlayExtraVFX('AlwaysOn');
}

// Export UKFPawn_Monster::execGetCharacterMonsterInfo(FFrame&, void* const)
native function KFCharacterInfo_Monster GetCharacterMonsterInfo();

simulated event bool UsePlayerControlledZedSkin()
{
    return bVersusZed;
}

function float GetBlockingSprintSpeedModifier()
{
    return BlockSprintSpeedModifier;
}

function AdjustMovementSpeed(float SpeedAdjust)
{
    DesiredAdjustedGroundSpeed = (default.GroundSpeed * SpeedAdjust) * InitialGroundSpeedModifier;
    if(IsDoingSpecialMove())
    {
        DesiredAdjustedSprintSpeed = FMax(((default.SprintSpeed * SpeedAdjust) * InitialGroundSpeedModifier) * SpecialMoves[SpecialMove].GetSprintSpeedModifier(), DesiredAdjustedGroundSpeed);        
    }
    else
    {
        DesiredAdjustedSprintSpeed = FMax((default.SprintSpeed * SpeedAdjust) * InitialGroundSpeedModifier, DesiredAdjustedGroundSpeed);
    }
    NormalGroundSpeed = DesiredAdjustedGroundSpeed;
    NormalSprintSpeed = DesiredAdjustedSprintSpeed;
}

simulated event PlayFootStepSound(int FootDown)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    super.PlayFootStepSound(FootDown);
    if(((((Physics == 1) && Base != none) && Mesh.RootMotionMode == 2) && FootstepCameraShake != none) && VSizeSq(Velocity) >= 10000)
    {
        Class'Camera'.static.PlayWorldCameraShake(FootstepCameraShake, self, Location, FootstepCameraShakeInnerRadius, FootstepCameraShakeOuterRadius, 1.3, true);
    }
}

event SpiderBumpLevel(Vector HitLocation, Vector HitNormal, optional Actor Wall);

simulated event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    super(Actor).Bump(Other, OtherComp, HitNormal);
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].NotifyBump(Other, HitNormal);
    }
    if((((Physics == 2) && JumpBumpDamageType != none) && Other.GetTeamNum() != GetTeamNum()) && VSizeSq2D(Velocity) > Square(GroundSpeed * 1.1))
    {
        Other.TakeDamage(int(MeleeAttackHelper.BaseDamage), Controller, Other.Location, Normal(Velocity), JumpBumpDamageType);
    }
}

function HandleMonsterBump(KFPawn_Monster Other, Vector HitNormal)
{
    local KFPlayerController KFPC;

    if(!Other.IsNapalmInfected() && CanNapalmInfect(KFPC))
    {
        InfectWithNapalm(Other, KFPC);
    }
}

event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    local KFDoorActor door;

    if(IsHumanControlled())
    {
        if(!Wall.bStatic && IsAliveAndWell())
        {
            door = KFDoorActor(Wall);
            if(door != none)
            {
                TryDestroyDoor(door);
            }
        }
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((string(GetFuncName()) $ "() Wall: ") $ string(Wall), 'BumpEvent');
    }
    NotifyCollideWithActor(HitNormal, Wall);
    super(Actor).HitWall(HitNormal, Wall, WallComp);
}

function bool HandleAIDoorBump(KFDoorActor door)
{
    return TryDestroyDoor(door);
}

function bool TryDestroyDoor(KFDoorActor door)
{
    if((((((IsABoss()) && door != none) && !door.bIsDoorOpen) && !door.bIsDestroyed) && door.WeldIntegrity == 0) && CanObliterateDoors())
    {
        door.IncrementHitCount(self);
        door.DestroyDoor(Controller);
        return true;
    }
    return false;
}

function bool CanObliterateDoors()
{
    if((IsABoss()) && !bIsSprinting)
    {
        return false;
    }
    return true;
}

function bool NotifyCollideWithActor(Vector HitNormal, Actor Other)
{
    local KFDestructibleActor KFDA;

    if(!Other.bStatic && IsHumanControlled())
    {
        KFDA = KFDestructibleActor(Other);
        if(KFDA != none)
        {
            HandleDestructibleBump(KFDA, HitNormal);
        }
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((string(GetFuncName()) $ "() Other: ") $ string(Other), 'BumpEvent');
    }
    return false;
}

function HandleDestructibleBump(KFDestructibleActor Destructible, Vector HitNormal)
{
    Destructible.BumpedByMonster(self, HitNormal);
}

simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    if(MyKFAIC != none)
    {
        MyKFAIC.Touch(Other, OtherComp, HitLocation, HitNormal);
    }
    super.Touch(Other, OtherComp, HitLocation, HitNormal);
}

function SetSprinting(bool bNewSprintStatus)
{
    if(MyKFAIC != none)
    {
        if(!MyKFAIC.CanSetSprinting(bNewSprintStatus))
        {
            return;
        }
    }
    if(bIsBlocking && IsHumanControlled())
    {
        if(bIsSprinting)
        {
            bNewSprintStatus = false;            
        }
        else
        {
            return;
        }
    }
    super.SetSprinting(bNewSprintStatus);
}

event StuckOnPawn(Pawn OtherPawn)
{
    JumpOffPawn();
    if(MyKFAIC != none)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
        {
            MyKFAIC.AILog_Internal((((string(self) $ " StuckOnPawn event at ") $ string(Location)) $ " Base: ") $ string(Base));
        }
        MyKFAIC.DumpCommandStack();
        MyKFAIC.DumpCommandHistory();
    }
}

function bool DoJump(bool bUpdating)
{
    local Vector JumpVelocity;
    local Rotator ViewRotation;
    local Vector ViewDirection;

    if(bCanJump)
    {
        if(IsHumanControlled())
        {
            if(IsDoingSpecialMove())
            {
                return false;
            }
            ViewRotation = GetViewRotation();
            ViewDirection = Normal(vector(ViewRotation));
            if(((bJumpCapable && !bIsCrouched) && !bWantsToCrouch) && ((Physics == 1) || Physics == 9) || Physics == 8)
            {
                if(Physics == 8)
                {
                    Velocity = Velocity + ((GetJumpZ()) * Floor);                    
                }
                else
                {
                    if(Physics == 9)
                    {
                        Velocity.Z = 0;                        
                    }
                    else
                    {
                        if(bIsWalking)
                        {
                            Velocity.Z = default.JumpZ;                            
                        }
                        else
                        {
                            if(bIsSprinting && bHasExtraSprintJumpVelocity)
                            {
                                JumpVelocity = GetSprintJumpVelocity(ViewDirection);
                                JumpVelocity.Z = GetJumpZ();
                                Velocity += JumpVelocity;                                
                            }
                            else
                            {
                                Velocity.Z = GetJumpZ();
                            }
                        }
                    }
                }
                if(((Base != none) && !Base.bWorldGeometry) && Base.Velocity.Z > 0)
                {
                    Velocity.Z += Base.Velocity.Z;
                }
                SetPhysics(2);
                bJumped = true;
                return true;
            }
            return false;            
        }
        else
        {
            return super.DoJump(bUpdating);
        }
    }
}

simulated function float GetJumpZ()
{
    return JumpZ;
}

simulated function Vector GetSprintJumpVelocity(Vector ViewDirection)
{
    return (ViewDirection * (GetJumpZ())) * (GetDirectionalJumpScale());
}

simulated function float GetDirectionalJumpScale()
{
    return 1;
}

function class<KFDamageType> GetBumpAttackDamageType();

function TakeFallingDamage();

event Landed(Vector HitNormal, Actor FloorActor)
{
    local Controller StoredLastHitBy;
    local int SMIndex;

    StoredLastHitBy = LastHitBy;
    if(bRestoreCollisionOnLand)
    {
        bRestoreCollisionOnLand = false;
        SetCollisionSize(default.CylinderComponent.CollisionRadius, default.CylinderComponent.CollisionHeight);
        FitCollision();
    }
    if(IsHumanControlled())
    {
        if(bJumped && IsLocallyControlled())
        {
            SMIndex = SpecialMoveCooldowns.Find('SMHandle', 12;
            if(SMIndex != -1)
            {
                SpecialMoveCooldowns[SMIndex].LastUsedTime = WorldInfo.TimeSeconds;
            }
        }
        bJumped = false;
    }
    super.Landed(HitNormal, FloorActor);
    LastHitBy = StoredLastHitBy;
}

function SetMovementPhysics()
{
    if((Physics == 0) && IsDoingSpecialMove())
    {
        return;
    }
    super(Pawn).SetMovementPhysics();
}

function CrushedBy(Pawn OtherPawn)
{
    super.CrushedBy(OtherPawn);
    if(((((bKnockdownWhenJumpedOn && Health > 0) && !IsDoingSpecialMove(11)) && (OtherPawn.Location.Z - Location.Z) > (OtherPawn.CylinderComponent.CollisionHeight + CylinderComponent.CollisionHeight)) && !IsHumanControlled()) && GetTeamNum() != OtherPawn.GetTeamNum())
    {
        Knockdown(,, vect(1, 1, 1), OtherPawn.Location, 1000, 100);
    }
}

simulated function SetZedTimeSpeedScale(float SpeedScale)
{
    if(SpeedScale > 0)
    {
        bMovesFastInZedTime = true;
        ZedTimeSpeedScale = SpeedScale;        
    }
    else
    {
        bMovesFastInZedTime = false;
    }
}

// Export UKFPawn_Monster::execIsValidEnemyTargetFor(FFrame&, void* const)
native function bool IsValidEnemyTargetFor(const PlayerReplicationInfo PRI, bool bNoPRIisEnemy);

// Export UKFPawn_Monster::execInChargeRange(FFrame&, void* const)
native function bool InChargeRange(const Vector TestLocation);

// Export UKFPawn_Monster::execInMeleeRange(FFrame&, void* const)
native function bool InMeleeRange(const Vector TestLocation, optional name AttackTag);

// Export UKFPawn_Monster::execInAttackTagRange(FFrame&, void* const)
native function bool InAttackTagRange(const name AttackTag, const Vector TestLocation);

// Export UKFPawn_Monster::execInAnyAttackTagRange(FFrame&, void* const)
native function bool InAnyAttackTagRange(const Vector TestLocation, out name outAttackTag);

// Export UKFPawn_Monster::execGetEnemy(FFrame&, void* const)
native function KFPawn GetEnemy();

// Export UKFPawn_Monster::execIsLocationValidForCombat(FFrame&, void* const)
native final function bool IsLocationValidForCombat(KFPawn CheckPawn, const Vector CheckLocation);

simulated function bool SetEnraged(bool bNewEnraged)
{
    if(!bCanRage)
    {
        return false;
    }
    if(Role == ROLE_Authority)
    {
        if(bNewEnraged == bIsEnraged)
        {
            return false;
        }
        bIsEnraged = bNewEnraged;
        if(IsDoingSpecialMove(17))
        {
            EndSpecialMove();
        }
        if(!IsHumanControlled())
        {
            SetSprinting(bNewEnraged);
        }
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && !IsHumanControlled())
    {
        if(bNewEnraged)
        {
            PlayExtraVFX('Enraged');            
        }
        else
        {
            StopExtraVFX('Enraged');
        }
    }
    return true;
}

simulated event bool IsEnraged();

function NotifyFriendlyAIDamageTaken(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType)
{
    if(MyKFAIC != none)
    {
        MyKFAIC.NotifyFriendlyAIDamageTaken(DamagerController, Damage, DamageCauser, DamageType);
    }
}

simulated function MeleeImpactNotify(KFAnimNotify_MeleeImpact Notify)
{
    if(MeleeAttackHelper != none)
    {
        MeleeAttackHelper.bHasAlreadyHit = false;
        MeleeAttackHelper.MeleeImpactNotify(Notify);
    }
    if(((MyKFAIC != none) && MyKFAIC.Enemy != none) && MyKFAIC.Enemy.Health <= 0)
    {
        ClearHeadTrackTarget(Controller.Enemy);
        MyKFAIC.AbortCommand(none, Class'AICommand_Attack_Grab');
        MyKFAIC.AbortCommand(none, Class'AICommand_Attack_Melee');
        Class'AICommand_TauntEnemy'.static.Taunt(KFAIController(Controller),, 1);
    }
}

function NotifyMeleeDamageDealt();

event bool IsInAttackTagRange(Vector TestLocation, name AttackTag)
{
    local Vector2D MinMaxRange;
    local float DistSq;

    if((MyKFAIC == none) || PawnAnimInfo == none)
    {
        MinMaxRange = PawnAnimInfo.GetAttackRangeByName(AttackTag);
        DistSq = VSizeSq(TestLocation - Location);
        if((DistSq > (MinMaxRange.X * MinMaxRange.X)) && DistSq < (MinMaxRange.Y * MinMaxRange.Y))
        {
            return true;
        }
    }
    return false;
}

event bool IsInAnyAttackTagRange(Vector TestLocation, out name outAttackTag)
{
    local int Idx;

    if((MyKFAIC == none) || PawnAnimInfo == none)
    {
        outAttackTag = 'None';
        return false;
    }
    Idx = 0;
    J0x40:

    if(Idx < PawnAnimInfo.Attacks.Length)
    {
        if((PawnAnimInfo.Attacks[Idx].Tag == 'None') || PawnAnimInfo.Attacks[Idx].Chance <= 0)
        {            
        }
        else
        {
            if(IsInAttackTagRange(TestLocation, PawnAnimInfo.Attacks[Idx].Tag))
            {
                outAttackTag = PawnAnimInfo.Attacks[Idx].Tag;
                return true;
            }
        }
        ++ Idx;
        goto J0x40;
    }
    outAttackTag = 'None';
    return false;
}

simulated function StartPlayerZedMove(KFPawn.ESpecialMove Move)
{
    local byte SMFlags;

    if(Move != 0)
    {
        if((GetSpecialMoveCooldownTimeRemaining(Move)) > 0)
        {
            return;
        }
        if(SpecialMove == Move)
        {
            SpecialMoves[SpecialMove].SpecialMoveButtonRetriggered();            
        }
        else
        {
            if(CanDoSpecialMove(Move))
            {
                SMFlags = SpecialMoveHandler.SpecialMoveClasses[Move].static.PackFlagsBase(self);
                DoSpecialMove(Move, true, InteractionPawn, SMFlags);
                if((Role < ROLE_Authority) && IsDoingSpecialMove(Move))
                {
                    ServerDoSpecialMove(Move, true, InteractionPawn, SMFlags);
                }
            }
        }
    }
}

simulated function StopPlayerZedMove(KFPawn.ESpecialMove Move)
{
    if(!IsDoingSpecialMove())
    {
        return;
    }
    if(SpecialMove == Move)
    {
        SpecialMoves[Move].SpecialMoveButtonReleased();
    }
}

simulated function NotifySpecialMoveEnded(KFSpecialMove FinishedMove, KFPawn.ESpecialMove SMHandle)
{
    local int SMIndex;

    if(IsHumanControlled() && IsLocallyControlled())
    {
        SMIndex = SpecialMoveCooldowns.Find('SMHandle', SMHandle;
        if(SMIndex != -1)
        {
            SpecialMoveCooldowns[SMIndex].LastUsedTime = WorldInfo.TimeSeconds;
        }
    }
}

function float GetSpecialMoveCooldownPercent(const out SpecialMoveCooldownInfo Cooldown)
{
    local float CDTime;

    if(Cooldown.SMHandle != 0)
    {
        if((Cooldown.LastUsedTime > 0) && Cooldown.CoolDownTime > 0)
        {
            CDTime = ((!bEmpDisrupted) ? Cooldown.CoolDownTime : AfflictionHandler.GetAfflictionDuration(0));
            return FClamp((WorldInfo.TimeSeconds - Cooldown.LastUsedTime) / CDTime, 0, 1);
        }
    }
    return 1;
}

function float GetSpecialMoveCooldownTimeRemaining(KFPawn.ESpecialMove SMHandle)
{
    local float CDTime;
    local int I;

    I = SpecialMoveCooldowns.Find('SMHandle', SMHandle;
    if(I != -1)
    {
        if((SpecialMoveCooldowns[I].LastUsedTime > 0) && SpecialMoveCooldowns[I].CoolDownTime > 0)
        {
            CDTime = ((!bEmpDisrupted) ? SpecialMoveCooldowns[I].CoolDownTime : AfflictionHandler.GetAfflictionDuration(0));
            return CDTime - FMin(WorldInfo.TimeSeconds - SpecialMoveCooldowns[I].LastUsedTime, CDTime);
        }
        return 0;
    }
    return 100;
}

simulated function array<SpecialMoveCooldownInfo> GetSpecialMoveCooldowns()
{
    return SpecialMoveCooldowns;
}

function PutAllMovesOnCooldown()
{
    local int I;

    if(IsHumanControlled() && IsLocallyControlled())
    {
        I = 0;
        J0x28:

        if(I < SpecialMoveCooldowns.Length)
        {
            if(SpecialMoveCooldowns[I].SMHandle != 0)
            {
                SpecialMoveCooldowns[I].LastUsedTime = WorldInfo.TimeSeconds;
            }
            ++ I;
            goto J0x28;
        }
    }
}

simulated function bool UseAdjustedControllerSensitivity();

function bool CanBlock()
{
    if(((Physics == 1) && CanDoSpecialMove(17)) && IsCombatCapable())
    {
        if(FRand() > (DifficultyBlockSettings.Chance * ((WorldInfo.Game.NumPlayers == 1) ? DifficultyBlockSettings.SoloChanceMultiplier : 1)))
        {
            return false;
        }
        return (WorldInfo.TimeSeconds - LastBlockTime) >= DifficultyBlockSettings.Cooldown;
    }
    return false;
}

simulated function SetBlockSettings(const sBlockInfo NewBlockSettings)
{
    DifficultyBlockSettings = NewBlockSettings;
}

simulated function sBlockInfo GetBlockSettings()
{
    return DifficultyBlockSettings;
}

simulated function float GetMinBlockFOV()
{
    return MinBlockFOV;
}

simulated function AdjustAffliction(out float AfflictionPower)
{
    if((Role == ROLE_Authority) && bIsBlocking)
    {
        AfflictionPower *= DifficultyBlockSettings.AfflictionModifier;
    }
    super.AdjustAffliction(AfflictionPower);
}

function bool ShouldDrawBossIcon()
{
    return false;
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    local KFPlayerController KFPC;
    local string ClassName;

    Timer_EndRallyBoost();
    super.PlayDying(DamageType, HitLoc);
    if((IsABoss()) && class<KFGameInfo>(WorldInfo.GRI.GameClass).default.bGoToBossCameraOnDeath)
    {
        KFPC = KFPlayerController(GetALocalPlayerController());
        if(KFPC != none)
        {
            KFPC.SetBossCamera((self));
        }
        ClassName = string(Class.Name);        
        ClassName -= string('_Versus');
        Class'GameEngine'.static.GetOnlineSubsystem().PlayerInterfaceEx.PostActivityFeedBossKill(GetLocalizedName(), ClassName, WorldInfo.GetMapName(true));
    }
    if(bUseExplosiveDeath)
    {
        PlayExplosiveDeath();
    }
    if(bUseDamageInflation)
    {
        PlayInflationDeath();
    }
    UpdateBleedIncapFX();
    StopExtraVFX('None');
}

simulated function PlayInflationDeath()
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < Mesh.PhysicsAssetInstance.Bodies.Length)
    {
        Mesh.PhysicsAssetInstance.Bodies[Idx].CustomGravityFactor = InflateDeathGravity;
        if(InflationExplosionTimer > float(0))
        {
            SetTimer(InflationExplosionTimer, false, 'InflationExplode');
        }
        ++ Idx;
        goto J0x0B;
    }
}

simulated function PlayExplosiveDeath()
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowMutilation())
    {
        HandlePartialGoreAndGibs(Class'KFDT_Explosive_Sacrifice', Location, vect(0, 0, 0), 'hips', true);
        GoreManager.SpawnObliterationBloodEffect(self);        
    }
    else
    {
        HandlePartialGoreAndGibs(Class'KFDT_Explosive_Sacrifice', Location, vect(0, 0, 0), 'hips', false);
    }
}

simulated function InflationExplode()
{
    local int Idx;

    RepDamageInflateParam = 0;
    bUseDamageInflation = false;
    Idx = 0;
    J0x23:

    if(Idx < Mesh.PhysicsAssetInstance.Bodies.Length)
    {
        Mesh.PhysicsAssetInstance.Bodies[Idx].CustomGravityFactor = 1;
        ++ Idx;
        goto J0x23;
    }
    PlayExplosiveDeath();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        UpdateVisualInflation((GetCurrentInflation()) * 2);
    }
}

function bool CanCountHeadshots()
{
    return !bIsHeadless;
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local KFPawn_Human HumanInstigator;
    local KFAIController_Monster AIMonster;
    local class<KFDamageType> KFDT;
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;
    local KFPlayerReplicationInfo KFPRI;
    local KFAIController KFAIC;
    local KFPawn_Monster KFPM;
    local float NapalmCheckDist;

    AIMonster = KFAIController_Monster(InstigatedBy);
    KFDT = class<KFDamageType>(DamageType);
    KFPC = KFPlayerController(InstigatedBy);
    if(KFPC != none)
    {
        InstigatorPerk = KFPC.GetPerk();
        KFAIC = KFAIController(Controller);
        if((KFAIC != none) && KFAIC.TimeFirstSawPlayer == float(0))
        {
            KFAIC.TimeFirstSawPlayer = WorldInfo.TimeSeconds;
        }
    }
    if(((AIMonster != none) && KFDT != none) && !KFDT.default.bIgnoreZedOnZedScaling)
    {
        if(Health >= 100)
        {
            Damage *= float(2 - ((HealthMax - Health) / HealthMax));
        }
    }
    if(((Damage > 0) && InstigatorPerk != none) && KFDT != none)
    {
        bCouldTurnIntoShrapnel = InstigatorPerk.CouldBeZedShrapnel(KFDT);
    }
    super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        HumanInstigator = KFPawn_Human(InstigatedBy.Pawn);
        if(HumanInstigator != none)
        {
            HumanInstigator.ResetIdleStartTime();
        }
    }
    if(((((((Damage > 0) && InstigatedBy != none) && DamageCauser != none) && KFDT != none) && KFDT.default.DoT_Type == 1) && KFDT != Class'KFDT_Fire_Napalm') && (WorldInfo.RealTimeSeconds - LastNapalmInfectCheckTime) > 0.25)
    {
        if((((KFPC != none) && KFPC.GetPerk() != none) && KFPC.GetPerk().CanSpreadNapalm()) && Class'KFPerk'.static.IsDamageTypeOnThisPerk(KFDT, Class'KFPerk_Firebug'))
        {
            NapalmCheckDist = Square(CylinderComponent.CollisionRadius * Class'KFPerk_Firebug'.static.GetNapalmCheckCollisionScale());
            foreach WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM, Location)
            {
                if(((KFPM != self) && KFPM.IsAliveAndWell()) && !KFPM.IsNapalmInfected())
                {
                    if(VSizeSq(Location - KFPM.Location) > NapalmCheckDist)
                    {
                        continue;                        
                    }
                    InfectWithNapalm(KFPM, KFPC);
                }                
            }            
            LastNapalmInfectCheckTime = WorldInfo.RealTimeSeconds;
            if(!IsNapalmInfected())
            {
                InfectWithNapalm(self, KFPC);
            }
        }
    }
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.PlayerHealth = byte(Health);
        KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
    }
    if(bUseDamageInflation)
    {
        IntendedDamageInflationPercent = float(Health) / float(HealthMax);
    }
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    local KFPlayerController KFPC;
    local KFPawn_Human KFPH;
    local float TempDamage;
    local int HitZoneIdx, ExtraHeadDamage;
    local KFPerk InstigatorPerk;
    local class<KFDamageType> KFDT;

    super.AdjustDamage(InDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
    if(DamageType.default.bCausedByWorld && ClassIsChildOf(DamageType, Class'KFDT_Falling'))
    {
        InDamage = 0;
        return;
    }
    InDamage *= (GetDamageTypeModifier(DamageType));
    GetRallyBoostResistance(InDamage);
    ApplyBlockingDamageModifier(InDamage, InstigatedBy, DamageType);
    HitZoneIdx = HitZones.Find('ZoneName', HitInfo.BoneName;
    KFPC = KFPlayerController(InstigatedBy);
    if(KFPC != none)
    {
        InstigatorPerk = KFPC.GetPerk();
        if(InstigatorPerk != none)
        {
            InstigatorPerk.ModifyDamageGiven(InDamage, DamageCauser, self, KFPC, class<KFDamageType>(DamageType), HitZoneIdx);
        }
        if(KFPC.Pawn != none)
        {
            KFPH = KFPawn_Human(KFPC.Pawn);
            if(KFPH != none)
            {
                TempDamage = float(InDamage);
                TempDamage *= KFPH.GetHealingDamageBoostModifier();
                InDamage = FCeil(TempDamage);
            }
        }
    }
    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitZoneIdx = 0;
    }
    if(((!bCheckingExtraHeadDamage && HitZoneIdx == 0) && HitZones[0].GoreHealth > 0) && InDamage > HitZones[0].GoreHealth)
    {
        KFDT = class<KFDamageType>(DamageType);
        if(KFDT != none)
        {
            InDamage *= KFDT.default.HeadDestructionDamageScale;
        }
        ExtraHeadDamage = int(float(InDamage) + (float(HealthMax) * 0.25));
        bCheckingExtraHeadDamage = true;
        AdjustDamage(ExtraHeadDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
        bCheckingExtraHeadDamage = false;
        InDamage += ExtraHeadDamage;
    }
    if(!bCheckingExtraHeadDamage && InstigatedBy != none)
    {
        AddTakenDamage(InstigatedBy, int(FMin(float(Health), float(InDamage))), DamageCauser, class<KFDamageType>(DamageType));
    }
    if((HitZoneIdx == 0) && bIsHeadless)
    {
        InDamage = 1;
    }
    if((InstigatedBy == none) || InstigatedBy.GetTeamNum() != GetTeamNum())
    {
        InDamage = Max(InDamage, 1);
    }
    if(ArmorInfo != none)
    {
        if(HitInfo.BoneName != 'None')
        {
            ArmorInfo.AdjustBoneDamage(InDamage, HitInfo.BoneName, DamageCauser.Location);            
        }
        else
        {
            ArmorInfo.AdjustNonBoneDamage(InDamage);
        }
        if(bLogTakeDamage)
        {
            LogInternal(((((((((string(self) @ string(GetFuncName())) @ " After armor adjustment Damage=") $ string(InDamage)) @ "Momentum=") $ string(Momentum)) @ "Zone=") $ string(HitInfo.BoneName)) @ "DamageType=") $ string(DamageType));
        }
    }
    if(bLogTakeDamage)
    {
        LogInternal((string(self) @ "Adjusted Monster Damage=") $ string(InDamage));
    }
}

function float GetDamageTypeModifier(class<DamageType> DT)
{
    local int I, DifficultyIdx;
    local float DamageModifier;

    if(LiveDamageTypeModifiers.Length > 0)
    {
        AppendLiveDamageTypeModifiers();
    }
    I = DamageTypeModifiers.Length - 1;
    J0x31:

    if(I >= 0)
    {
        if(ClassIsChildOf(DT, DamageTypeModifiers[I].DamageType))
        {
            if((WorldInfo.Game != none) && DamageTypeModifiers[I].DamageScale.Length > 1)
            {
                DifficultyIdx = Min(WorldInfo.Game.GetModifiedGameDifficulty(), DamageTypeModifiers[I].DamageScale.Length);
                DamageModifier = DamageTypeModifiers[I].DamageScale[DifficultyIdx];                
            }
            else
            {
                DamageModifier = DamageTypeModifiers[I].DamageScale[0];
            }
            if(DamageModifier < 1)
            {
                DamageModifier = FMax(Lerp(1, DamageModifier, GameResistancePct), 0);
            }
            if(bLogTakeDamage)
            {
                LogInternal((((string(self) @ "Scaling damage taken from") @ string(DT)) @ "by") @ string(DamageModifier));
            }
            return DamageModifier;
        }
        -- I;
        goto J0x31;
    }
    return 1;
}

function AppendLiveDamageTypeModifiers()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < LiveDamageTypeModifiers.Length)
    {
        if(LiveDamageTypeModifiers[I].DamageType != none)
        {
            DamageTypeModifiers.AddItem(LiveDamageTypeModifiers[I];            
        }
        else
        {
            goto J0x83;
        }
        ++ I;
        goto J0x0B;
    }
    J0x83:

    LiveDamageTypeModifiers.Length = 0;
}

function ApplyBlockingDamageModifier(out int Damage, Controller InstigatedBy, class<DamageType> DamageType)
{
    local Vector DamageDirNormal;

    if((((!bIsBlocking || Damage <= 0) || InstigatedBy == none) || InstigatedBy.Pawn == none) || InstigatedBy.GetTeamNum() == GetTeamNum())
    {
        return;
    }
    DamageDirNormal = Normal(InstigatedBy.Pawn.Location - Location);
    if((DamageDirNormal Dot vector(Rotation)) > MinBlockFOV)
    {
        if(ClassIsChildOf(DamageType, Class'KFDT_Bludgeon') || ClassIsChildOf(DamageType, Class'KFDT_Slashing'))
        {
            Damage = int(float(Damage) * DifficultyBlockSettings.MeleeDamageModifier);            
        }
        else
        {
            Damage = int(float(Damage) * DifficultyBlockSettings.DamageModifier);
        }
    }
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bRepairArmor, optional bool bMessageHealer)
{
    bRepairArmor = true;
    bMessageHealer = true;
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlaySpotZedHealingDialog(self);
    }
    super.HealDamage(Amount, Healer, DamageType);
    return true;
}

function bool HasReducedMeleeDamage()
{
    return bHasReducedMeleeDamage;
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum, Actor DamageCauser)
{
    local KFPawn_Human KFPH_Instigator;

    super(Pawn).NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum, DamageCauser);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        KFPH_Instigator = KFPawn_Human(InstigatedBy.Pawn);
        if(KFPH_Instigator != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayDamageZedContinuousDialog(KFPH_Instigator, self);
            }
        }
    }
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].NotifyOwnerTakeHit(class<KFDamageType>(DamageType), HitLocation, Normal(Momentum), InstigatedBy);
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((((string(GetFuncName()) $ "() Instigator:") $ string(InstigatedBy)) $ " DT: ") $ string(DamageType), 'Damage');
    }
}

function PlayHit(float Damage, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, Vector Momentum, TraceHitInfo HitInfo)
{
    local KFPawn_Human KFPH_Instigator;

    super.PlayHit(Damage, InstigatedBy, HitLocation, DamageType, Momentum, HitInfo);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        KFPH_Instigator = KFPawn_Human(InstigatedBy.Pawn);
        if(KFPH_Instigator != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayDamagedZedDialog(KFPH_Instigator, self, DamageType);
            }
        }
    }
}

function NotifyMeleeTakeHit(Controller InstigatedBy, Vector HitLocation);

function BleedOutTimer()
{
    if(!bPlayedDeath)
    {
        if(bLogTakeDamage)
        {
            LogInternal((string(GetFuncName()) @ "LastHitBy") @ string(LastHitBy));
        }
        Died(LastHitBy, Class'KFDT_Bleeding', Location);
    }
}

simulated function bool Rally(KFPawn RallyInstigator, ParticleSystem RallyEffect, name EffectBoneName, Vector EffectOffset, ParticleSystem AltRallyEffect, name AltEffectBoneNames[2], Vector AltEffectOffset, optional bool bSkipEffects)
{
    local sRallyInfo RallyInfo;
    local KFAIController KFAIC;
    local bool bStartedBoostRally;
    local name SocketBoneName, AltSocketBoneName;

    bSkipEffects = false;
    GetDifficultyRallyInfo(RallyInfo);
    if(!RallyInfo.bCanRally || !IsAliveAndWell())
    {
        return false;
    }
    if(RallyInfo.DealtDamageModifier > 1)
    {
        if(!IsTimerActive('Timer_EndRallyBoost'))
        {
            SetTimer(RallyInfo.RallyBuffTime, false, 'Timer_EndRallyBoost');
            bStartedBoostRally = true;
        }
    }
    if(((Role == ROLE_Authority) && Controller != none) && RallyInfo.bCauseSprint)
    {
        KFAIC = KFAIController(Controller);
        KFAIC.SetSprintingDisabled(false);
        KFAIC.SetCanSprint(true);
        KFAIC.bDefaultCanSprint = true;
        KFAIC.bCanSprintWhenDamaged = true;
        KFAIC.bForceFrustration = true;
        SetSprinting(true);
        SetEnraged(true);
        if(KFGameInfo(WorldInfo.Game) != none)
        {
            KFGameInfo(WorldInfo.Game).NotifyRally(self);
        }
    }
    if(!bSkipEffects && WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(RallyPSC != none)
        {
            RallyPSC.DeactivateSystem();
            DetachComponent(RallyPSC);
        }
        RallyPSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(RallyEffect, Mesh, EffectBoneName, false, EffectOffset);
        if(bStartedBoostRally)
        {
            SocketBoneName = Mesh.GetSocketBoneName(AltEffectBoneNames[0]);
            if((SocketBoneName != 'None') && SocketBoneName != 'None')
            {
                RallyHandPSCs[0] = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(AltRallyEffect, Mesh, AltEffectBoneNames[0], true, AltEffectOffset);
            }
            AltSocketBoneName = Mesh.GetSocketBoneName(AltEffectBoneNames[1]);
            if((AltSocketBoneName != 'None') && AltSocketBoneName != 'None')
            {
                RallyHandPSCs[1] = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(AltRallyEffect, Mesh, AltEffectBoneNames[1], true, AltEffectOffset);
            }
        }
    }
    return true;
}

simulated function Timer_EndRallyBoost()
{
    if((RallyHandPSCs[0] != none) && RallyHandPSCs[0].bIsActive)
    {
        RallyHandPSCs[0].DeactivateSystem();
    }
    if((RallyHandPSCs[1] != none) && RallyHandPSCs[1].bIsActive)
    {
        RallyHandPSCs[1].DeactivateSystem();
    }
}

simulated function SetRallySettings(sRallyInfo NewRallyInfo)
{
    DifficultyRallySettings = NewRallyInfo;
}

simulated function GetDifficultyRallyInfo(out sRallyInfo RallyInfo)
{
    RallyInfo = DifficultyRallySettings;
}

simulated function int GetRallyBoostDamage(int NewDamage)
{
    local sRallyInfo RallyInfo;

    GetDifficultyRallyInfo(RallyInfo);
    return int(float(NewDamage) * ((IsTimerActive('Timer_EndRallyBoost')) ? RallyInfo.DealtDamageModifier : 1));
}

simulated function int GetRallyBoostResistance(int NewDamage)
{
    local sRallyInfo RallyInfo;

    GetDifficultyRallyInfo(RallyInfo);
    return int(float(NewDamage) * ((IsTimerActive('Timer_EndRallyBoost')) ? RallyInfo.TakenDamageModifier : 1));
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;

    if(super.Died(Killer, DamageType, HitLocation))
    {
        if(((Killer != none) && Killer.Pawn != none) && KFPawn_Human(Killer.Pawn) != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayKilledZedDialog(KFPawn_Human(Killer.Pawn), self, DamageType, IsDoingSpecialMove(6) || IsDoingSpecialMove(5));
            }
        }
        if(bCouldTurnIntoShrapnel)
        {
            if(Killer != none)
            {
                KFPC = KFPlayerController(Killer);
                if(KFPC != none)
                {
                    InstigatorPerk = KFPC.GetPerk();
                    if((InstigatorPerk != none) && InstigatorPerk.ShouldShrapnel())
                    {
                        ShrapnelExplode(Killer, InstigatorPerk);
                    }
                }
            }
        }
        OnZedDied(Killer);
        return true;
    }
    return false;
}

function OnZedDied(Controller Killer);

simulated event Destroyed()
{
    AfflictionHandler.ShutDown();
    super.Destroyed();
}

event OnRigidBodyLinearConstraintViolated(name StretchedBoneName)
{
    local KFGoreManager GoreManager;

    LogInternal("Linear constraint violated, hiding bone " @ string(StretchedBoneName));
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
        if(bIsGoreMesh)
        {
            GoreManager.CrushBone(self, StretchedBoneName);
            return;
        }
    }
    Mesh.HideBoneByName(StretchedBoneName, 1);
}

protected simulated function ResetHealthVisibilty()
{
    bShowHealth = false;
}

simulated function bool CanShowHealth()
{
    return bShowHealth;
}

simulated function bool IsNapalmInfected()
{
    return DamageOverTimeArray.Find('DamageType', Class'KFDT_Fire_Napalm' != -1;
}

function bool CanNapalmInfect(out KFPlayerController NapalmInstigator)
{
    local int DoTIndex;
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;

    if(DamageOverTimeArray.Length > 0)
    {
        DoTIndex = DamageOverTimeArray.Find('DoT_Type', Class'KFDT_Fire'.default.DoT_Type;
        if((DoTIndex != -1) && DamageOverTimeArray[DoTIndex].InstigatedBy != none)
        {
            KFPC = KFPlayerController(DamageOverTimeArray[DoTIndex].InstigatedBy);
            if(KFPC != none)
            {
                InstigatorPerk = KFPC.GetPerk();
                if((InstigatorPerk != none) && InstigatorPerk.CanSpreadNapalm())
                {
                    NapalmInstigator = KFPC;
                    return true;
                }
            }
        }
    }
    NapalmInstigator = none;
    return false;
}

function InfectWithNapalm(KFPawn_Monster KFPM, KFPlayerController KFPC)
{
    if(KFPC != none)
    {
        KFPM.TakeDamage(Class'KFPerk_Firebug'.static.GetNapalmDamage(), KFPC, vect(0, 0, 0), vect(0, 0, 0), Class'KFDT_Fire_Napalm',, KFPC);
    }
}

function ShrapnelExplode(Controller Killer, KFPerk InstigatorPerk)
{
    local KFExplosionActorReplicated ExploActor;
    local Actor InstigatorActor;
    local GameExplosion ExplosionTemplate;

    if(Role < ROLE_Authority)
    {
        return;
    }
    InstigatorActor = ((Killer.Pawn != none) ? Killer.Pawn : Killer);
    ExploActor = Spawn(Class'KFExplosionActorReplicated', InstigatorActor,, Location,,, true);
    if(ExploActor != none)
    {
        ExploActor.InstigatorController = Killer;
        if(Killer.Pawn != none)
        {
            ExploActor.Instigator = Killer.Pawn;
        }
        if(InstigatorPerk != none)
        {
            ExplosionTemplate = InstigatorPerk.GetExplosionTemplate();
            ExploActor.Explode(ExplosionTemplate);
        }
    }
}

simulated function UpdateVisualInflation(float InflationAmount)
{
    local MaterialInstanceConstant MIC;
    local int I, J;

    if(bIsGoreMesh)
    {
        InflationAmount = 0;
    }
    foreach CharacterMICs(MIC,)
    {
        MIC.SetScalarParameterValue('Scalar_Inflate', InflationAmount);        
    }    
    I = 0;
    J0x71:

    if(I < 3)
    {
        if(ThirdPersonAttachments[I] != none)
        {
            J = 0;
            J0xA5:

            if(J < ThirdPersonAttachments[I].Materials.Length)
            {
                MIC = MaterialInstanceConstant(ThirdPersonAttachments[I].GetMaterial(J));
                if(MIC != none)
                {
                    MIC.SetScalarParameterValue('Scalar_Inflate', InflationAmount);
                }
                ++ J;
                goto J0xA5;
            }
        }
        ++ I;
        goto J0x71;
    }
    I = 0;
    J0x188:

    if(I < StaticAttachList.Length)
    {
        if(StaticAttachList[I] != none)
        {
            J = 0;
            J0x1C4:

            if(J < StaticAttachList[I].Materials.Length)
            {
                MIC = MaterialInstanceConstant(StaticAttachList[I].GetMaterial(J));
                if(MIC != none)
                {
                    MIC.SetScalarParameterValue('Scalar_Inflate', InflationAmount);
                }
                ++ J;
                goto J0x1C4;
            }
        }
        ++ I;
        goto J0x188;
    }
}

function CauseHeadTrauma(optional float BleedOutTime)
{
    BleedOutTime = 5;
    if((!bIsHeadless && !bPlayedDeath) && !bDisableHeadless)
    {
        if(((MyKFAIC != none) && KFGameInfo(WorldInfo.Game) != none) && MyKFAIC.TimeFirstSawPlayer >= float(0))
        {
            KFGameInfo(WorldInfo.Game).GameConductor.HandleZedKill(FMax(WorldInfo.TimeSeconds - MyKFAIC.TimeFirstSawPlayer, 0));
            MyKFAIC.TimeFirstSawPlayer = -1;
        }
        bPlayShambling = true;
        bIsHeadless = true;
        if(MyKFAIC != none)
        {
            MyKFAIC.SetSprintingDisabled(true);
        }
        bCanBeAdheredTo = false;
        bCanBeFrictionedTo = false;
        StopAkEventsOnBone('head');
        if(IsDoingSpecialMove() && Mesh.RootMotionMode == 3)
        {
            Died(LastHitBy, Class'DamageType', Location);            
        }
        else
        {
            if(bIsSprinting && FRand() < 0.25)
            {
                Knockdown(Velocity, vect(1, 1, 1));
            }
        }
        if(IsAliveAndWell() && MyKFAIC != none)
        {
            if((SpecialMove == 0) || !SpecialMoves[SpecialMove].bCanOnlyWanderAtEnd)
            {
                MyKFAIC.DoHeadlessWander();
            }
        }
        if(BleedOutTime > float(0))
        {
            SetTimer(BleedOutTime, false, 'BleedOutTimer');
        }
    }
}

function OnStackingAfflictionChanged(byte Id)
{
    local bool bShouldBeWandering, bWasWandering;

    bWasWandering = bPlayShambling || bPlayPanicked;
    bPlayShambling = bEmpPanicked || bIsHeadless;
    bPlayPanicked = (bFirePanicked || bIsPoisoned) || bMicrowavePanicked;
    bShouldBeWandering = bPlayShambling || bPlayPanicked;
    if(!bWasWandering && bShouldBeWandering)
    {
        CausePanicWander();        
    }
    else
    {
        if(bWasWandering)
        {
            EndPanicWander();
        }
    }
}

function CausePanicWander()
{
    if(!bIsHeadless && !bPlayedDeath)
    {
        if((SpecialMove != 0) && SpecialMoves[SpecialMove].bCanOnlyWanderAtEnd)
        {
            return;
        }
        if(MyKFAIC != none)
        {
            MyKFAIC.SetSprintingDisabled(true);
        }
        if(IsAliveAndWell() && MyKFAIC != none)
        {
            MyKFAIC.DoPanicWander();
        }
    }
}

function EndPanicWander()
{
    if(MyKFAIC != none)
    {
        MyKFAIC.SetSprintingDisabled(false);
    }
    if(IsAliveAndWell() && MyKFAIC != none)
    {
        MyKFAIC.EndPanicWander();
    }
}

simulated function bool ShouldBeWandering()
{
    return bPlayShambling || bPlayPanicked;
}

simulated function bool IsHeadless()
{
    return bIsHeadless;
}

simulated function bool IsImpaired()
{
    return (bPlayPanicked || bEmpDisrupted) || bPlayShambling && !bIsHeadless;
}

simulated function UpdateGameplayMICParams()
{
    if(AfflictionHandler != none)
    {
        AfflictionHandler.ToggleEffects(6, bIsPoisoned);
        if(bIsGoreMesh)
        {
            AfflictionHandler.UpdateMaterialParameter(10, 0);
        }
    }
    super.UpdateGameplayMICParams();
}

function bool NotifyAttackParried(Pawn InstigatedBy, byte InParryStrength)
{
    if(InParryStrength < ParryResistance)
    {
        return false;
    }
    return super.NotifyAttackParried(InstigatedBy, InParryStrength);
}

function SetCloaked(bool bNewCloaking)
{
    if(bNewCloaking)
    {
        ClearBloodDecals();
    }
}

function CallOutCloaking(optional KFPlayerController CallOutController);

function MeleeSpecialMoveEnded();

function ANIMNOTIFY_Knockdown()
{
    if(SpecialMove == 11)
    {
        KFSM_Emerge(SpecialMoves[11]).bDoKnockdown = true;
    }
}

function NotifyAnimInterrupt(optional AnimNodeSequence SeqNode);

function msg(string MsgTxt)
{
    MessagePlayer(MsgTxt);
}

function float GetCircleStrafeDuration()
{
    return 0;
}

function float GetStepBackInCombatOdds()
{
    return 0.12;
}

function Pawn GetPawnToLookAt(optional bool bRequireLOS)
{
    local Pawn P;
    local array<Pawn> InterestingPawns;

    P = WorldInfo.PawnList;
    J0x29:

    if(P != none)
    {
        if(((P != self) && P.IsAliveAndWell()) && !bRequireLOS || LineOfSightTo(P))
        {
            InterestingPawns.AddItem(P;
        }
        P = P.NextPawn;
        goto J0x29;
    }
    if(InterestingPawns.Length > 0)
    {
        return InterestingPawns[Rand(InterestingPawns.Length)];
    }
    return none;
}

simulated function bool LookAtPawn(optional Pawn P, optional float Strength)
{
    Strength = 0.5;
    if(IK_Look_Head == none)
    {
        IK_Look_Head = SkelControlLookAt(Mesh.FindSkelControl('HeadLook'));
    }
    if(IK_Look_Head != none)
    {
        if(P == none)
        {
            P = GetPawnToLookAt(true);
        }
        if(P != none)
        {
            bIsHeadTrackingActive = true;
            if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
            {
                MyKFAIC.AILog_Internal(string(GetFuncName()) @ string(P), 'HeadTracking');
            }
            SetHeadTrackTarget(P, vect(0, 0, 1) * P.BaseEyeHeight, Strength, false);
            return true;
        }
    }
    return false;
}

simulated function StopLookingAtPawn(optional Pawn P)
{
    if((bCanHeadTrack && bIsHeadTrackingActive) && MyLookAtInfo.LookAtTarget != none)
    {
        if(P == none)
        {
            P = Pawn(MyLookAtInfo.LookAtTarget);
        }
        if(P != none)
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging && MyKFAIC != none)
            {
                MyKFAIC.AILog_Internal(string(GetFuncName()) @ string(P), 'HeadTracking');
            }
            ClearHeadTrackTarget(P);
        }
    }
}

// Export UKFPawn_Monster::execSwitchToGoreMesh(FFrame&, void* const)
native final simulated function bool SwitchToGoreMesh();

simulated event NotifyGoreMeshActive()
{
    UpdateGameplayMICParams();
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].OnGoreMeshSwap();
    }
}

simulated function GetClosestHitBones(int NumBones, Vector TestLocation, out array<name> OutHitBoneList)
{
    local int I;
    local array<name> SearchList;

    I = 0;
    J0x0B:

    if(I < Mesh.PhysicsAsset.BodySetup.Length)
    {
        SearchList.AddItem(Mesh.PhysicsAsset.BodySetup[I].BoneName;
        ++ I;
        goto J0x0B;
    }
    Mesh.FindClosestBones(TestLocation, NumBones, OutHitBoneList, SearchList);
}

simulated event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex)
{
    local int I;
    local KFGoreManager GoreManager;
    local RigidBodyContactInfo ContactInfo;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && (WorldInfo.TimeSeconds - LastGibCollisionTime) > GoreManager.GetTimeBetweenGibBloodSplats())
    {
        LastGibCollisionTime = WorldInfo.TimeSeconds;
        if(((OtherComponent != none) && OtherComponent.Owner != none) && !OtherComponent.Owner.IsA('KFPawn'))
        {
            SoundGroupArch.PlayRigidBodyCollisionSound(self, RigidCollisionData.ContactInfos[ContactIndex].ContactPosition);
            I = 0;
            J0x18C:

            if(I < RigidCollisionData.ContactInfos.Length)
            {
                ContactInfo = RigidCollisionData.ContactInfos[I];
                GoreManager.LeaveAPersistentBloodSplat(ContactInfo.ContactPosition, -ContactInfo.ContactNormal);
                ++ I;
                goto J0x18C;
            }
        }
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation, optional bool bUseHitImpulse)
{
    local class<KFDamageType> dmgType;
    local name HitZoneName, HitBoneName;
    local int HitZoneIndex;

    bUseHitImpulse = true;
    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitFxInfo.HitBoneIndex = 0;
    }
    dmgType = HitFxInfo.DamageType;
    HitZoneIndex = HitFxInfo.HitBoneIndex;
    if((HitZoneIndex != 255) && HitZoneIndex <= HitZones.Length)
    {
        HitZoneName = HitZones[HitZoneIndex].ZoneName;
        HitBoneName = HitZones[HitZoneIndex].BoneName;
    }
    if(dmgType != none)
    {
        if(bTearOff && !bPlayedDeath)
        {
            PlayDying(HitDamageType, TakeHitLocation);
        }
        if(bPlayedDeath)
        {
            PlayDeadHitEffects(HitLocation, HitDirection, HitZoneIndex, HitZoneName, HitBoneName, dmgType, bUseHitImpulse);            
        }
        else
        {
            PlayLivingHitEffects(HitLocation, HitDirection, HitZoneIndex, HitZoneName, HitBoneName, dmgType, bUseHitImpulse);
        }
    }
    if(!bPlayedDeath)
    {
        bShowHealth = true;
        SetTimer(2, false, 'ResetHealthVisibilty');
    }
    super.PlayTakeHitEffects(HitDirection, HitLocation, bUseHitImpulse);
}

simulated function PlayDeadHitEffects(Vector HitLocation, Vector HitDirection, int HitZoneIndex, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, optional bool bUseHitImpulse)
{
    local class<KFProj_PinningBullet> PinProjectileClass;
    local KFPawn DeadPawn;
    local KFGoreManager GoreManager;
    local bool bIsDismemberingHit, bWasObliterated;

    if(bAllowRagdollAndGoreOnDeadBodies || (WorldInfo.TimeSeconds - TimeOfDeath) <= 3)
    {
        if(((InjuredHitZones & (1 << HitZoneIndex)) > 0) && !HitZones[HitZoneIndex].bPlayedInjury)
        {
            bIsDismemberingHit = PlayDismemberment(HitZoneIndex, dmgType, HitDirection);
            if(!bIsDismemberingHit && (InjuredHitZones & (1 << 0)) > 0)
            {
                PlayHeadAsplode();
                bIsDismemberingHit = true;
            }
        }
        GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
        if(((GoreManager.AllowMutilation() && HitFxInfo.bObliterated) && (WorldInfo.TimeSeconds - TimeOfDeath) < 0.25) && !bUseDamageInflation)
        {
            bWasObliterated = true;
            bIsDismemberingHit = true;
            HandlePartialGoreAndGibs(dmgType, HitLocation, HitDirection, HitBoneName, true);
            GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
            GoreManager.SpawnObliterationBloodEffect(self);            
        }
        else
        {
            PinProjectileClass = dmgType.static.GetPinProjectileClass();
            if(PinProjectileClass != none)
            {
                DeadPawn = self;
                PinProjectileClass.static.CreatePin(DeadPawn, HitLocation, HitDirection, HitBoneName);
            }
            HandlePartialGoreAndGibs(dmgType, HitLocation, HitDirection, HitBoneName, false);
        }
        HandleRagdollImpulseEffects(HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, bIsDismemberingHit, bUseHitImpulse);
    }
    ApplyBloodDecals(HitZoneIndex, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, bIsDismemberingHit, bWasObliterated);
}

simulated function HandleRagdollImpulseEffects(Vector HitLocation, Vector HitDirection, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, bool bIsDismemberingHit, optional bool bUseHitImpulse)
{
    local Vector ImpulseDir, ParentImpulseDir;
    local float ImpulseScale, ParentImpulseScale;
    local name RBBoneName, HitBoneParentName;

    ImpulseDir = HitDirection;
    ParentImpulseDir = HitDirection;
    ImpulseScale = 1;
    ParentImpulseScale = 1;
    if(bIsDismemberingHit)
    {
        dmgType.static.ModifyDismembermentHitImpulse(self, HitZoneName, ImpulseDir, HitDirection, ParentImpulseDir, ImpulseScale, ParentImpulseScale);
    }
    if(HitBoneName != 'None')
    {
        RBBoneName = GetRBBoneFromBoneName(HitBoneName);
    }
    if(bUseHitImpulse)
    {
        ApplyRagdollImpulse(dmgType, HitLocation, ImpulseDir, RBBoneName, ImpulseScale);
        if(bIsDismemberingHit && ParentImpulseScale > float(0))
        {
            HitBoneParentName = Mesh.GetParentBone(HitBoneName);
            if(((HitBoneName == 'head') || HitBoneParentName == 'neck') && dmgType != none)
            {
                ParentImpulseScale *= dmgType.default.HeadDestructionImpulseForceScale;
            }
            HitBoneParentName = GetRBBoneFromBoneName(HitBoneParentName);
            if((RBBoneName != HitBoneParentName) && Mesh.PhysicsAsset.FindBodyIndex(HitBoneParentName) != -1)
            {
                ApplyRagdollImpulse(dmgType, HitLocation, ParentImpulseDir, HitBoneParentName, ParentImpulseScale);
            }
        }
    }
}

simulated function PlayLivingHitEffects(Vector HitLocation, Vector HitDirection, int HitZoneIndex, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, optional bool bUseHitImpulse)
{
    if((!TryPlayHitReactionAnim(HitDirection, dmgType, byte(HitZoneIndex)) && PawnAnimInfo.bCanPlayPhysicsHitReactions) && ActorEffectIsRelevant(HitFxInstigator, false))
    {
        PlayPhysicsBodyImpact(HitLocation, HitDirection, dmgType, HitBoneName);
    }
    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitZoneIndex = 0;
    }
    if(HitZoneIndex == 0)
    {
        if((bUseHitImpulse && Mesh.PhysicsWeight == 1) && bIsHeadless)
        {
            ApplyRagdollImpulse(dmgType, HitLocation, HitDirection, HeadBoneName, 1);
        }
        ApplyHeadChunkGore(dmgType, HitLocation, HitDirection);
    }
    ApplyBloodDecals(HitZoneIndex, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, false, false);
}

simulated function PlayDyingSound()
{
    if(ClassIsChildOf(HitDamageType, Class'KFDT_Bleeding'))
    {
        SoundGroupArch.PlayBleedoutDyingSound(self);        
    }
    else
    {
        if(bHasBrokenConstraints && !HasMouth())
        {
            SoundGroupArch.PlayMouthlessDyingSound(self);            
        }
        else
        {
            super.PlayDyingSound();
        }
    }
}

simulated function PlayHitZoneGoreSounds(name HitBoneName, Vector HitLocation)
{
    if(SoundGroupArch.ShouldPlayCleaveSound(HitBoneName))
    {
        SoundGroupArch.PlayCleaveSound(self, HitLocation);        
    }
    else
    {
        SoundGroupArch.PlayDismembermentSounds(self, HitLocation);
    }
}

simulated function bool HeadBoneAlreadyBroken(name BoneName)
{
    if(BrokenHeadBones.Find(BoneName != -1)
    {
        return true;
    }
    return false;
}

simulated function AddBrokenHeadBone(name BoneName)
{
    if(BrokenHeadBones.Find(BoneName == -1)
    {
        BrokenHeadBones.AddItem(BoneName;
    }
    return;
}

simulated function bool ShouldAllowHeadBoneToBreak(name BoneName)
{
    if((!bPlayedDeath && !bIsHeadless) && !bTearOff)
    {
        if(NumHeadChunksRemoved >= MaxHeadChunkGoreWhileAlive)
        {
            return false;
        }
        if((((((BoneName == 'Gore_FrontL') && BrokenHeadBones.Find('Gore_FrontR' != -1) || (BoneName == 'Gore_FrontR') && BrokenHeadBones.Find('Gore_FrontL' != -1) || ((BoneName == 'Gore_BackL') && BrokenHeadBones.Find('gore_jaw' != -1) && BrokenHeadBones.Find('Gore_BackR' != -1) || ((BoneName == 'Gore_BackR') && BrokenHeadBones.Find('gore_jaw' != -1) && BrokenHeadBones.Find('Gore_BackL' != -1) || ((BoneName == 'gore_jaw') && BrokenHeadBones.Find('Gore_BackR' != -1) && BrokenHeadBones.Find('Gore_BackL' != -1)
        {
            return false;
        }
    }
    return true;
}

simulated function UpdateGoreChunkData(name BoneName)
{
    if((((BoneName == 'Gore_FrontL') || BoneName == 'Gore_FrontR') || BoneName == 'Gore_BackL') || BoneName == 'Gore_BackR')
    {
        ++ NumHeadChunksRemoved;
    }
}

simulated function bool ShouldAttachSkullChunk()
{
    return NumHeadChunksRemoved < 3;
}

simulated function bool ShouldDetachSkullChunk()
{
    return (NumHeadChunksRemoved >= 3) && (bPlayedDeath || bIsHeadless) || bTearOff;
}

simulated function HandleGoreChunkAttachments(name DismemberedBone)
{
    local int AttachmentIndex, ChunkRef;
    local editinline StaticMeshComponent AttachComp;
    local KFCharacterInfo_Monster MonsterInfo;
    local AttachedGoreChunkInfo ChunkInfo;
    local KFGoreChunkAttachmentInfo CurrentChunk;

    UpdateGoreChunkData(DismemberedBone);
    MonsterInfo = GetCharacterMonsterInfo();
    if(MonsterInfo != none)
    {
        AttachmentIndex = 0;
        J0x41:

        if(AttachmentIndex < MonsterInfo.GoreChunkAttachments.Length)
        {
            CurrentChunk = MonsterInfo.GoreChunkAttachments[AttachmentIndex];
            if(CurrentChunk.DismemberedBoneList.Find(DismemberedBone != -1)
            {
                ChunkRef = AttachedGoreChunks.Find('AttachmentIndex', AttachmentIndex;
                if(CurrentChunk.ShouldAttachGoreChunk(self) && ChunkRef == -1)
                {
                    AttachComp = new (self) Class'StaticMeshComponent';
                    AttachComp.SetStaticMesh(CurrentChunk.StaticMesh);
                    AttachComp.SetLightingChannels(PawnLightingChannel);
                    AttachComp.CastShadow = true;
                    AttachComp.bCastDynamicShadow = true;
                    AttachComp.bAllowPerObjectShadowBatching = true;
                    if((CurrentChunk.SocketName == 'Head_Attach') && CurrentHeadScale > 1)
                    {
                        AttachComp.SetCullDistance(1000 * CurrentHeadScale);                        
                    }
                    else
                    {
                        AttachComp.SetCullDistance(1000);
                    }
                    AttachComp.SetShadowParent(Mesh);
                    AttachComp.bAllowApproximateOcclusion = true;
                    AttachComp.SetTraceBlocking(false, false);
                    AttachComp.SetActorCollision(false, false);
                    Mesh.AttachComponentToSocket(AttachComp, CurrentChunk.SocketName);
                    ChunkInfo.AttachmentIndex = AttachmentIndex;
                    ChunkInfo.AttachedComponent = AttachComp;
                    AttachedGoreChunks.AddItem(ChunkInfo;                    
                }
                else
                {
                    if(CurrentChunk.ShouldDetachGoreChunk(self) && ChunkRef != -1)
                    {
                        AttachComp = AttachedGoreChunks[ChunkRef].AttachedComponent;
                        Mesh.DetachComponent(AttachComp);
                        AttachedGoreChunks.Remove(ChunkRef, 1;
                    }
                }
            }
            ++ AttachmentIndex;
            goto J0x41;
        }
    }
}

simulated function bool TryPlayHitReactionAnim(Vector HitDirection, class<KFDamageType> DamageType, byte HitZoneIdx)
{
    local KFPawn.EPawnOctant AnimDir;
    local KFPawnAnimInfo.EHitReactionAnimType HitReactionType;
    local KFAfflictionManager.EHitZoneBodyPart BodyPart;
    local bool bOnlyAdditiveHits;

    if((DamageType == none) || ActorTimeSince(NextHitReactionAnim_ActorTime) < float(0))
    {
        return false;
    }
    if(IsDoingSpecialMove())
    {
        bOnlyAdditiveHits = true;
        if(!SpecialMoves[SpecialMove].bAllowHitReactions)
        {
            return false;
        }
    }
    BodyPart = (((HitZoneIdx != 255) && HitZoneIdx < HitZones.Length) ? HitZones[HitZoneIdx].Limb : 0);
    HitReactionType = 0;
    bOnlyAdditiveHits = bOnlyAdditiveHits || VSizeSq(Velocity) > 50;
    if(!bOnlyAdditiveHits)
    {
        HitReactionType = AfflictionHandler.GetPredictedHitReaction(DamageType, BodyPart);
    }
    switch(BodyPart)
    {
        case 2:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 4;                
            }
            else
            {
                AnimDir = 6;
            }
            break;
        case 3:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 5;                
            }
            else
            {
                AnimDir = 7;
            }
            break;
        default:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            break;
            break;
    }
    return PawnAnimInfo.PlayHitReactionAnim(self, HitReactionType, AnimDir);
}

simulated function ApplyBloodDecals(int HitZoneIndex, Vector HitLocation, Vector HitDirection, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, bool bIsDismemberingHit, bool bWasObliterated)
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(!bWasObliterated && !bIsCloaking)
        {
            GoreManager.LeaveABodyWoundDecal(self, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType);
        }
        if(dmgType.default.bShouldSpawnBloodSplat)
        {
            GoreManager.LeaveABloodSplatterDecal(self, HitLocation, HitDirection);
        }
        if(dmgType.default.bShouldSpawnPersistentBlood)
        {
            GoreManager.CausePersistentBlood(self, dmgType, HitLocation, HitDirection, HitZoneIndex, bIsDismemberingHit, bWasObliterated);
        }
    }
}

simulated function HandlePartialGoreAndGibs(class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection, name HitBoneName, bool ObliterateGibs)
{
    local KFGoreManager GoreManager;
    local KFCharacterInfo_Monster MonsterInfo;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(GoreManager.AllowMutilation())
        {
            if(!bIsGoreMesh)
            {
                SwitchToGoreMesh();
            }
            if(bIsGoreMesh)
            {
                MonsterInfo = GetCharacterMonsterInfo();
                if(ObliterateGibs)
                {
                    ApplyObliterationFxGore(GoreManager, MonsterInfo, dmgType);                    
                }
                else
                {
                    if(HitFxInfo.bRadialDamage)
                    {
                        ApplyRadialFxGore(GoreManager, MonsterInfo, dmgType);                        
                    }
                    else
                    {
                        ApplyTakeHitFxGore(GoreManager, MonsterInfo, dmgType, HitLocation, HitDirection, HitBoneName);
                    }
                }
            }
        }
    }
}

simulated function ApplyRadialFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType)
{
    local array<name> OutGibBoneList;
    local float NormalizedDistanceScale;
    local Vector ExplosionOrigin;
    local int NumGibs;

    if(dmgType.default.bCanGib)
    {
        ExplosionOrigin = HitFxRadialInfo.RadiusHurtOrigin;
        NormalizedDistanceScale = VSize(Location - ExplosionOrigin) / 1000;
        NumGibs = FCeil(FMax(1 - NormalizedDistanceScale, 0) * float(Rand(10))) + Rand(3);
        NumGibs *= MonsterInfo.ExplosionGibScale;
        GetClosestHitBones(NumGibs, ExplosionOrigin, OutGibBoneList);
        GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ExplosionOrigin, OutGibBoneList, MonsterInfo.ExplosionEffectTemplate, Mesh.GetBoneLocation(Mesh.GetBoneName(0)));
    }
}

simulated function ApplyObliterationFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType)
{
    local array<name> OutGibBoneList;
    local Vector ObliterationLocation;
    local int MaxNumGibs;

    if(dmgType.default.MaxObliterationGibs > float(0))
    {
        MaxNumGibs = int(dmgType.default.MaxObliterationGibs);        
    }
    else
    {
        MaxNumGibs = 100;
    }
    if(dmgType.default.bCanGib)
    {
        if(HitFxInfo.bRadialDamage == true)
        {
            ObliterationLocation = HitFxRadialInfo.RadiusHurtOrigin;            
        }
        else
        {
            if(dmgType.default.bUseHitLocationForGibImpulses)
            {
                ObliterationLocation = HitFxInfo.HitLocation;
                if(dmgType.default.bPointImpulseTowardsOrigin)
                {
                    ObliterationLocation -= ((DecodeUnitVector(HitFxInfo.EncodedHitDirection)) * dmgType.default.ImpulseOriginScale);                    
                }
                else
                {
                    ObliterationLocation.Z = Location.Z - (CylinderComponent.CollisionHeight * 0.25);
                }                
            }
            else
            {
                ObliterationLocation = self.Location;
            }
        }
        GetClosestHitBones(MaxNumGibs, ObliterationLocation, OutGibBoneList);
        GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ObliterationLocation, OutGibBoneList, MonsterInfo.ExplosionEffectTemplate, Mesh.GetBoneLocation(Mesh.GetBoneName(0)));
    }
}

simulated function ApplyTakeHitFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection, name HitBoneName)
{
    local array<name> OutGibBoneList;
    local int JointIndex, ExplosionBreakIdx, BoneIdx;
    local Vector ExplosionOrigin;
    local name GibBone;

    GoreManager.ConditionalApplyPartialGore(self, dmgType, HitLocation, HitDirection, HitBoneName);
    JointIndex = 0;
    J0x50:

    if(JointIndex < MonsterInfo.GoreJointSettings.Length)
    {
        if(MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == HitBoneName)
        {
            ExplosionBreakIdx = 0;
            J0xD3:

            if(ExplosionBreakIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore.Length)
            {
                if(((MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Length == 0) || MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Find(0 != -1) || MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Find(dmgType.default.GoreDamageGroup != -1)
                {
                    ExplosionOrigin = Mesh.GetBoneLocation(HitBoneName);
                    BoneIdx = 0;
                    J0x2B2:

                    if(BoneIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones.Length)
                    {
                        GibBone = MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones[BoneIdx].BoneName;
                        if(!Mesh.IsBrokenConstraint(GibBone))
                        {
                            OutGibBoneList.AddItem(GibBone;
                        }
                        ++ BoneIdx;
                        goto J0x2B2;
                    }
                    GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ExplosionOrigin, OutGibBoneList, MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ParticleSystemTemplate, ExplosionOrigin, HitBoneName);
                }
                ++ ExplosionBreakIdx;
                goto J0xD3;
            }
        }
        ++ JointIndex;
        goto J0x50;
    }
}

simulated function ApplyHeadChunkGore(class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection)
{
    local KFGoreManager GoreManager;

    if(bCanCloak && IsAliveAndWell())
    {
        return;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(GoreManager.AllowMutilation())
        {
            if(!bIsGoreMesh)
            {
                SwitchToGoreMesh();
            }
            if(!bPlayedDeath)
            {
                dmgType = Class'KFDT_Ballistic';
                GoreManager.ConditionalApplyPartialGore(self, dmgType, HitLocation, HitDirection, HitZones[0].BoneName);
            }
        }
    }
}

simulated function HitZoneInjured(optional int HitZoneIdx)
{
    HitZoneIdx = -1;
    if((Role == ROLE_Authority) && HitZoneIdx != -1)
    {
        if(HitZoneIdx == 0)
        {
            CauseHeadTrauma();
        }
        InjuredHitZones = InjuredHitZones | (1 << HitZoneIdx);
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && !bTearOff && !bPlayedDeath)
    {
        if(((InjuredHitZones & (1 << 0)) > 0) && !bDisableHeadless)
        {
            if((WorldInfo.TimeSeconds - CreationTime) > 1)
            {
                PlayDismemberment(0, HitFxInfo.DamageType);
            }
            if(!HitZones[0].bPlayedInjury)
            {
                PlayHeadAsplode();
            }
        }
    }
}

simulated function PlayHeadAsplode()
{
    local KFGoreManager GoreManager;
    local name BoneName;

    if(HitZones[0].bPlayedInjury)
    {
        return;
    }
    if(bDisableHeadless)
    {
        return;
    }
    if(((bTearOff || bPlayedDeath) && TimeOfDeath > float(0)) && (WorldInfo.TimeSeconds - TimeOfDeath) > 0.75)
    {
        return;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowHeadless())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
    }
    if(bIsGoreMesh && GoreManager != none)
    {
        BoneName = HitZones[0].BoneName;
        GoreManager.CrushBone(self, BoneName);
        SoundGroupArch.PlayHeadPopSounds(self, Mesh.GetBoneLocation(BoneName));
        HitZones[0].bPlayedInjury = true;
        SpawnHeadShotFX(KFPlayerReplicationInfo(HitFxInfo.DamagerPRI));
    }
}

simulated function bool PlayDismemberment(int InHitZoneIndex, class<KFDamageType> InDmgType, optional Vector HitDirection)
{
    local KFGoreManager GoreManager;
    local name BreakBoneName;

    if(HitZones[InHitZoneIndex].bPlayedInjury)
    {
        return false;
    }
    if(!InDmgType.static.CanDismemberHitZone(HitZones[InHitZoneIndex].ZoneName))
    {
        return false;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
        if(bIsGoreMesh)
        {
            BreakBoneName = HitZones[InHitZoneIndex].BoneName;
            if((Health <= 0) && !IsZero(HitDirection))
            {
                InDmgType.static.GetBoneToDismember(self, HitDirection, HitZones[InHitZoneIndex].ZoneName, BreakBoneName);
            }
            GoreManager.CauseDismemberment(self, BreakBoneName, InDmgType);
            if(InHitZoneIndex == 0)
            {
                SpawnHeadShotFX(KFPlayerReplicationInfo(HitFxInfo.DamagerPRI));
            }
            PlayHitZoneGoreSounds(BreakBoneName, Mesh.GetBoneLocation(BreakBoneName));
            HitZones[InHitZoneIndex].bPlayedInjury = true;
            if((Health > 0) && bHasBrokenConstraints)
            {
                InitPartialKinematics();
            }
            return true;
        }
    }
    return false;
}

function TakeHitZoneDamage(float Damage, class<DamageType> DamageType, int HitZoneIdx, Vector InstigatorLocation)
{
    local float HeadHealthPercentage;

    if(HitZoneIdx > HitZones.Length)
    {
        return;
    }
    super.TakeHitZoneDamage(Damage, DamageType, HitZoneIdx, InstigatorLocation);
    if((HitZones[HitZoneIdx].GoreHealth <= 0) && CanInjureHitZone(DamageType, HitZoneIdx))
    {
        HitZoneInjured(HitZoneIdx);
    }
    if(HitZoneIdx == 0)
    {
        if((!bPlayedDeath && !bIsHeadless) && !bTearOff)
        {
            HeadHealthPercentage = GetHeadHealthPercent();
            if(HeadHealthPercentage > 0.5)
            {
                MaxHeadChunkGoreWhileAlive = 1;                
            }
            else
            {
                if(HeadHealthPercentage > 0.25)
                {
                    MaxHeadChunkGoreWhileAlive = 2;                    
                }
                else
                {
                    if(HeadHealthPercentage > 0)
                    {
                        MaxHeadChunkGoreWhileAlive = 3;
                    }
                }
            }
        }
    }
}

function float GetHeadHealthPercent()
{
    local float HeadHealth, HeadHealthMax;

    HeadHealth = float(HitZones[0].GoreHealth);
    HeadHealthMax = float(HitZones[0].MaxGoreHealth);
    return HeadHealth / HeadHealthMax;
}

simulated function bool ShouldPlayHeadlessMeleeAnims()
{
    return bIsHeadless || bEmpPanicked;
}

simulated event bool HasMouth()
{
    if(!bHasBrokenConstraints)
    {
        return true;
    }
    return !Mesh.IsBrokenConstraint('head') && !Mesh.IsBoneHidden(Mesh.MatchRefBone('gore_jaw'));
}

simulated function ForceBreakAllConstraints()
{
    local int I;
    local KFGoreManager GoreManager;

    bHasBrokenConstraints = true;
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        return;
    }
    if(GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
        I = 0;
        J0x94:

        if(I < CharacterMonsterArch.GoreJointSettings.Length)
        {
            if(!CharacterMonsterArch.GoreJointSettings[I].bNonBreakableJoint)
            {
                GoreManager.BreakConstraint(self, CharacterMonsterArch.GoreJointSettings[I].HitBoneName);
            }
            ++ I;
            goto J0x94;
        }
    }
}

function NotifyMeleeAttackFinished();

simulated function ChokePointTimer()
{
    if(!IsTimerActive('ChokePointTimer'))
    {
        SetTimer(0.3, true, 'ChokePointTimer', self);
    }
    if(CurrentChokePointTrigger != none)
    {
        if(CurrentChokePointTrigger.CanRestoreChokeCollision(self))
        {
            if((CylinderComponent.CollisionRadius < CylinderComponent.default.CollisionRadius) && !CheckEncroachingWorldGeometry())
            {
                SetChokePointCollision(false);
            }            
        }
        else
        {
            if(CylinderComponent.CollisionRadius > CurrentChokePointTrigger.MaxCollisionRadius)
            {
                SetChokePointCollision(true);
            }
        }        
    }
    else
    {
        if(!CheckEncroachingWorldGeometry())
        {
            if(CylinderComponent.CollisionRadius < CylinderComponent.default.CollisionRadius)
            {
                SetChokePointCollision(false);
            }
            ClearTimer('ChokePointTimer', self);
        }
    }
}

event SetDamageInflation(float NewInflation)
{
    RepDamageInflateParam = FloatToByte(NewInflation);
    SetHeadScale(1 + ((GetCurrentInflation()) / 2), CurrentHeadScale);
    HandleDamageInflation();
}

simulated function float GetCurrentInflation()
{
    local float CurrentInflation;

    CurrentInflation = FClamp((ByteToFloat(RepInflateMatParam) + ByteToFloat(RepDamageInflateParam)) - ByteToFloat(RepBleedInflateMatParam), -1, 1);
    return CurrentInflation;
}

simulated function HandleDamageInflation()
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        UpdateVisualInflation((GetCurrentInflation()) * 2);
    }
}

simulated function UpdateBleedIncapFX()
{
    local float CurrentStrength;

    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        CurrentStrength = ByteToFloat(RepBleedInflateMatParam);
        if(((CurrentStrength != float(0)) && IsAliveAndWell()) && BleedIncapPSC == none)
        {
            BleedIncapPSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BleedIncapFX, Mesh, Class'KFSM_Stunned'.default.DazedFXSocketName, true);
            if(BleedIncapPSC != none)
            {
                BleedIncapPSC.SetAbsolute(false, true, false);
                BleedIncapPSC.SetRotation(rotator(vect(0, 0, 1)) + Class'KFSM_Stunned'.default.DazedFXRelativeRotation);
            }            
        }
        else
        {
            if(((CurrentStrength == float(0)) || !IsAliveAndWell()) && BleedIncapPSC != none)
            {
                BleedIncapPSC.DeactivateSystem();
                DetachComponent(BleedIncapPSC);
                BleedIncapPSC = none;
            }
        }
    }
}

private final simulated function SpawnHeadShotFX(KFPlayerReplicationInfo DamagerPRI)
{
    local KFPlayerController KFPC;
    local HeadshotEffect SHeadshotEffect;
    local Vector SpawnVector;

    if(DamagerPRI != none)
    {
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            KFPC = KFPlayerController(WorldInfo.GetALocalPlayerController());
            if((KFPC == none) || KFPC.bHideRemotePlayerHeadshotEffects && DamagerPRI != KFPC.PlayerReplicationInfo)
            {
                return;
            }
            SHeadshotEffect = Class'KFHeadShotEffectList'.static.GetUnlockedHeadshotEffect(DamagerPRI.GetHeadShotEffectID());
            if(SHeadshotEffect.Id != -1)
            {
                Mesh.GetSocketWorldLocationAndRotation(Class'KFSM_Stunned'.default.DazedFXSocketName, SpawnVector);
                WorldInfo.MyEmitterPool.SpawnEmitter(SHeadshotEffect.EffectPS, SpawnVector);
                HeadShotAkComponent.PlayEvent(SHeadshotEffect.HeadshotSoundEffect, true, true);
            }
        }
    }
}

static function bool IsLargeZed()
{
    return default.bLargeZed;
}

static event bool IsABoss()
{
    return false;
}

simulated event UpdateSpottedStatus();

static function bool IsStalkerClass()
{
    return default.bIsStalkerClass;
}

static function bool IsCrawlerClass()
{
    return default.bIsCrawlerClass;
}

static function bool IsFleshpoundClass()
{
    return default.bIsFleshpoundClass;
}

static function bool IsClotClass()
{
    return default.bIsClotClass;
}

static function bool IsBloatClass()
{
    return default.bIsBloatClass;
}

function float GetPerkDoTScaler(optional Controller InstigatedBy, optional class<KFDamageType> KFDT)
{
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;
    local float DoTScaler;

    DoTScaler = 1;
    if(InstigatedBy != none)
    {
        KFPC = KFPlayerController(InstigatedBy);
        if(KFPC != none)
        {
            InstigatorPerk = KFPC.GetPerk();
            if(InstigatorPerk != none)
            {
                DoTScaler += InstigatorPerk.GetDoTScalerAdditions(KFDT);
            }
        }
    }
    return DoTScaler;
}

function SetDebugTextRendering(bool bTurnOn)
{
    local PlayerController PC;
    local KFHUDBase KFHud;

    bDebug_DrawOverheadInfo = bTurnOn;
    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        KFHud = KFHUDBase(PC.myHUD);        
    }    
    if(KFHud != none)
    {
        KFHud.SetPostRenderingFor(bTurnOn, self);
    }
}

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir)
{
    local KFHUDBase PCHUD;
    local bool bShowAllCategories;
    local Vector2D ScreenPos;

    PCHUD = KFHUDBase(PC.myHUD);
    if(PCHUD.ShouldDisplayDebug('All') || PCHUD.ShouldDisplayDebug('AllVerbose'))
    {
        bShowAllCategories = true;
    }
    if(MyKFAIC != none)
    {
        if((bShowAllCategories || PCHUD.ShouldDisplayDebug('AIMovement')) || PCHUD.ShouldDisplayDebug('AIPathing'))
        {
            MyKFAIC.DrawDebugOverheadMovementPhaseData(PCHUD, ScreenPos);
        }
        if(bShowAllCategories || PCHUD.ShouldDisplayDebug('BehaviorTree'))
        {
            MyKFAIC.DrawBehaviorTreeIconOverhead(PCHUD);
        }
    }
    if(((PC != none) && PC.myHUD != none) && bDebug_DrawOverheadInfo)
    {
        PCHUD = KFHUDBase(PC.myHUD);
        if(PCHUD != none)
        {
            DrawDebugOverheadText(PCHUD, ScreenPos);
        }        
    }
    else
    {
        if(((PC != none) && PC.myHUD != none) && bDebug_DrawSprintingOverheadInfo)
        {
            PCHUD = KFHUDBase(PC.myHUD);
            if(PCHUD != none)
            {
                DrawDebugOverheadSprintingText(PCHUD);
            }
        }
    }
}

function DrawDebugOverheadText(KFHUDBase HUD, out Vector2D ScreenPos)
{
    local Texture2D Icon;
    local PlayerController PC;
    local Canvas Canvas;
    local Vector CameraLoc, ScreenLoc;
    local Rotator CameraRot;
    local float X, Y, Dot;
    local array<string> OverheadTexts;
    local array<Color> OverheadColors;
    local int I;

    if(!IsAliveAndWell())
    {
        return;
    }
    Canvas = HUD.Canvas;
    ScreenLoc = Canvas.Project(Location + ((vect(0, 0, 1) * (GetCollisionHeight())) * 1.5));
    if(((ScreenLoc.X < float(0)) || ScreenLoc.X >= HUD.Canvas.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    PC = HUD.PlayerOwner;
    Canvas.SetDrawColor(0, 255, 64);
    OverheadColors[OverheadColors.Length] = MakeColor(0, 255, 64);
    PC.GetPlayerViewPoint(CameraLoc, CameraRot);
    Dot = vector(CameraRot) Dot (Location - CameraLoc);
    if(Dot < 0.5)
    {
        return;
    }
    Icon = Texture2D'S_AI';
    if(Icon != none)
    {
        Canvas.SetPos(ScreenLoc.X - float(Icon.SizeX / 2), ScreenLoc.Y - float(Icon.SizeY / 2), ScreenLoc.Z);
        Canvas.DrawTexture(Icon, 1);
        X = (ScreenLoc.X + float(Icon.SizeX / 2)) + float(5);
        Y = ScreenLoc.Y - float(Icon.SizeY / 2);        
    }
    else
    {
        X = ScreenLoc.X;
        Y = ScreenLoc.Y;
    }
    if((ScreenPos.X == float(0)) && ScreenPos.Y == float(0))
    {
        Canvas.SetPos(X, Y);        
    }
    else
    {
        Canvas.SetPos(ScreenPos.X, ScreenPos.Y);
    }
    Canvas.Font = Class'Engine'.static.GetSmallFont();
    GetOverheadDebugText(HUD, OverheadTexts, OverheadColors);
    if(MyKFAIC != none)
    {
        MyKFAIC.GetCommandStack(HUD, OverheadTexts, OverheadColors);
    }
    I = 0;
    J0x5F3:

    if(I < OverheadTexts.Length)
    {
        if(OverheadColors[I] != MakeColor(0, 0, 0, 0))
        {
            Canvas.SetDrawColor(OverheadColors[I].R, OverheadColors[I].G, OverheadColors[I].B, 255);            
        }
        else
        {
            Canvas.SetDrawColor(0, 255, 64, 255);
        }
        Canvas.DrawText(OverheadTexts[I]);
        ++ I;
        goto J0x5F3;
    }
    ScreenPos.X = Canvas.CurX;
    ScreenPos.Y = Canvas.CurY;
    if(HUD.ShouldDisplayDebug('AIMovement'))
    {
        DrawDebugSphere(Location - (vect(0, 0, 1) * ((GetCollisionHeight()) - MaxStepHeight)), 8, 10, 255, 255, 0, false);
        DrawDebugSphere(Location + (vect(0, 0, 1) * MaxJumpHeight), 15, 10, 0, 255, 0, false);
    }
}

function DrawDebugOverheadSprintingText(KFHUDBase HUD)
{
    local Texture2D moveTypeIcon;
    local PlayerController plyCtrl;
    local Canvas displayCanvas;
    local Vector plyCameraLoc, plyScreenLoc;
    local Rotator plyCameraRot;
    local string displayStr;
    local float displayX, displayY, infrontDOT;
    local Color newTextColor;

    if(!IsAliveAndWell())
    {
        return;
    }
    displayCanvas = HUD.Canvas;
    plyScreenLoc = displayCanvas.Project(Location + ((vect(0, 0, 1) * (GetCollisionHeight())) * 1.5));
    if(((plyScreenLoc.X < float(0)) || plyScreenLoc.X >= HUD.Canvas.ClipX) || (plyScreenLoc.Y < float(0)) && plyScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    plyCtrl = HUD.PlayerOwner;
    displayCanvas.SetDrawColor(255, 255, 255);
    plyCtrl.GetPlayerViewPoint(plyCameraLoc, plyCameraRot);
    infrontDOT = vector(plyCameraRot) Dot (Location - plyCameraLoc);
    if(infrontDOT < 0.5)
    {
        return;
    }
    if(bDebug_UseIconForShowingSprintingOverheadInfo)
    {
        if(bIsSprinting)
        {
            moveTypeIcon = MyKFAIC.MyAIDirector.GetDebugIsSprintingIcon();            
        }
        else
        {
            moveTypeIcon = MyKFAIC.MyAIDirector.GetDebugIsWalkingIcon();
        }        
    }
    else
    {
        moveTypeIcon = none;
        if(bIsSprinting)
        {
            displayStr = "S";
            newTextColor = Class'HUD'.default.RedColor;            
        }
        else
        {
            displayStr = "W";
            newTextColor = Class'HUD'.default.GreenColor;
        }
    }
    if(moveTypeIcon != none)
    {
        displayCanvas.SetPos(plyScreenLoc.X - float(moveTypeIcon.SizeX / 2), plyScreenLoc.Y - float(moveTypeIcon.SizeY / 2), plyScreenLoc.Z);
        displayCanvas.DrawTexture(moveTypeIcon, 1);
        displayX = (plyScreenLoc.X + float(moveTypeIcon.SizeX / 2)) + float(5);
        displayY = plyScreenLoc.Y - float(moveTypeIcon.SizeY / 2);        
    }
    else
    {
        displayX = plyScreenLoc.X - (GetCollisionRadius());
        displayY = plyScreenLoc.Y;
    }
    displayCanvas.SetPos(displayX, displayY);
    if(Len(displayStr) > 0)
    {
        displayCanvas.Font = MyKFAIC.MyAIDirector.GetAiDebugScreenLargeFont();
        Class'KFAIController'.static.DrawDebugText(HUD, displayStr, newTextColor);
    }
}

simulated function GetOverheadDebugText(KFHUDBase HUD, out array<string> OverheadTexts, out array<Color> OverheadColors)
{
    local string DebugText;
    local KFGameInfo KFGI;
    local float HealthMod, HeadHealthMod;
    local bool bShowAll, bShowAllVerbose;

    if(HUD.ShouldDisplayDebug('All'))
    {
        bShowAll = true;
    }
    if(HUD.ShouldDisplayDebug('AllVerbose'))
    {
        bShowAll = true;
        bShowAllVerbose = true;
    }
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.DifficultyInfo.GetAIHealthModifier(self, float(KFGI.GetModifiedGameDifficulty()), byte(KFGI.GetLivingPlayerCount()), HealthMod, HeadHealthMod);
        if(bShowAllVerbose || HUD.ShouldDisplayDebug('ZedHealthVerbose'))
        {
            DebugText = ((((((((((((((" Health: " $ string(Health)) $ " HeadHealth: ") $ string(HitZones[0].GoreHealth)) $ "
") $ " Starting Health: ") $ string(HealthMod * float(default.Health))) $ " Starting HeadHealth: ") $ string(HeadHealthMod * float(default.HitZones[0].GoreHealth))) $ "
") $ " Health Modifier: ") $ string(HealthMod)) $ " Default Health: ") $ string(default.Health)) $ " Default HeadHealth: ") $ string(default.HitZones[0].GoreHealth);            
        }
        else
        {
            if(bShowAll || HUD.ShouldDisplayDebug('ZedHealth'))
            {
                DebugText = ((((" Health: " $ string(Health)) $ " HeadHealth: ") $ string(HitZones[0].GoreHealth)) $ " HeadHealth %: ") $ string((float(HitZones[0].GoreHealth) / (HeadHealthMod * float(default.HitZones[0].GoreHealth))) * float(100));
            }
        }
    }
    OverheadTexts[OverheadTexts.Length] = DebugText;
    if(bShowAll || HUD.ShouldDisplayDebug('AITargeting'))
    {
        if(MyKFAIC != none)
        {
            DebugText = "---------- AI Targeting ----------
";
            if(MyKFAIC.Enemy != none)
            {
                DebugText = ((((DebugText @ "ENEMY: ") $ MyKFAIC.Enemy.GetHumanReadableName()) $ " Enemy Dist: ") $ string(VSize(MyKFAIC.Enemy.Location - Location))) $ "
";                
            }
            else
            {
                DebugText = (DebugText @ "ENEMY: NO Enemy ") $ "
";
            }
            if(MyKFAIC.Focus != none)
            {
                DebugText = ((DebugText @ "FOCUS: ") $ string(MyKFAIC.Focus)) $ "
";
                DrawDebugLine(Mesh.GetBoneLocation(HeadBoneName), MyKFAIC.Focus.Location, 255, 255, 0, false);
            }
            if(MyKFAIC.GetFocalPoint() != vect(0, 0, 0))
            {
                DrawDebugLine(Mesh.GetBoneLocation(HeadBoneName), MyKFAIC.GetFocalPoint(), 255, 255, 0, false);
            }
            OverheadTexts[OverheadTexts.Length] = DebugText;
        }
    }
    if(bShowAll || HUD.ShouldDisplayDebug('AIMovement'))
    {
        DebugText = "---------- AI MOVEMENT ----------
";
        DebugText = ((((((((((DebugText $ "Velocity: ") $ string(VSize(Velocity))) $ " X: ") $ string(Velocity.X)) $ " Y: ") $ string(Velocity.Y)) $ " Z: ") $ string(Velocity.Z)) $ " UU/S, ") $ string(VSize(Velocity) / float(100))) $ "
";
        DebugText = ((((((((((DebugText $ "Acceleration: ") $ string(VSize(Acceleration))) $ " X: ") $ string(Acceleration.X)) $ " Y: ") $ string(Acceleration.Y)) $ " Z: ") $ string(Acceleration.Z)) $ " Physics: ") $ (GetPhysicsName())) $ "
";
        DebugText = ((((((DebugText $ "SuperSpeed: ") $ string(IsUsingSuperSpeed())) $ " LastLOSOrRelevantTime: ") $ string(WorldInfo.TimeSeconds - LastLOSOrRelevantTime)) $ " LastRenderTime: ") $ string(WorldInfo.TimeSeconds - LastRenderTime)) $ "
";
        if(MyKFAIC != none)
        {
            if(MyKFAIC.bPreparingMove)
            {
                DebugText = (DebugText @ "bPreparingMove:") $ string(MyKFAIC.bPreparingMove);
            }
        }
        OverheadTexts[OverheadTexts.Length] = DebugText;
    }
}

function int GetKillerDialogID()
{
    return 65;
}

function int GetSpotterDialogID()
{
    return 125;
}

function UpdateDeadHorseStreak(bool bStillActive)
{
    if(bStillActive)
    {
        ++ DeadHorseHitStreakAmt;        
    }
    else
    {
        DeadHorseHitStreakAmt = 1;
    }
    LastDeadHorseHitTime = WorldInfo.TimeSeconds;
}

static function int GetTraderAdviceID()
{
    return -1;
}

function PlayLeapedDialog();

function PlayLandedDialog();

function MotivatePlayerToAttack(float Percentage, class<DamageType> AntiGriefDamageTypeClass)
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    if((PC != none) && (WorldInfo.TimeSeconds - LastAttackHumanWarningTime) > float(9))
    {
        PC.ReceiveLocalizedMessage(Class'KFLocalMessage_Priority', 14);
        LastAttackHumanWarningTime = WorldInfo.TimeSeconds;
    }
    TakeDamage(int(float(HealthMax) * 0.05), none, Location + (VRand() * 5), VRand(), AntiGriefDamageTypeClass);
}

static function string GetLocalizedName()
{
    local string MonsterName;

    MonsterName = Localize("Zeds", string(default.LocalizationKey) $ (GetSeasonalLocalizationSuffix()), "KFGame");
    if(InStr(MonsterName, "?") >= 0)
    {
        MonsterName = Localize("Zeds", string(default.LocalizationKey), "KFGame");
    }
    return MonsterName;
}

static function string GetSeasonalLocalizationSuffix()
{
    switch(Class'KFGameEngine'.static.GetSeasonalEventID() % 10)
    {
        case 1:
            return "_Spring";
        case 2:
            return "_Summer";
        case 3:
            return "_Fall";
        case 4:
            return "_Winter";
        default:
            return "";
            break;
    }
    return "";
}

function ZedExplodeArmor(int ArmorZoneIdx, name ArmorZoneName)
{
    if(ArmorInfo != none)
    {
        ArmorInfo.ExplodeArmor(ArmorZoneIdx, ArmorZoneName);
    }
}

// Export UKFPawn_Monster::execShouldGrandOnDeathAchievement(FFrame&, void* const)
protected native function bool ShouldGrandOnDeathAchievement();

// Export UKFPawn_Monster::execGetZedOnDeathAchievement(FFrame&, void* const)
protected native function int GetZedOnDeathAchievement();

// Export UKFPawn_Monster::execDisablebOnDeathAchivement(FFrame&, void* const)
native function DisablebOnDeathAchivement();

simulated function PlayExtraVFX(name FXLabel)
{
    local int I;
    local ExtraVFXAttachmentInfo VFXAttachment;
    local bool bActivatedExistingSystem;
    local name SFXBoneName;

    if((WorldInfo.NetMode == NM_DedicatedServer) || FXLabel == 'None')
    {
        return;
    }
    I = 0;
    J0x4F:

    if(I < ExtraVFXAttachments.Length)
    {
        if(ExtraVFXAttachments[I].Info.Label == FXLabel)
        {
            ExtraVFXAttachments[I].VFXComponent = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(ExtraVFXAttachments[I].Info.VFX, Mesh, ExtraVFXAttachments[I].Info.SocketName, true);
            if(ExtraVFXAttachments[I].Info.SFXStartEvent != none)
            {
                SFXBoneName = Mesh.GetSocketBoneName(ExtraVFXAttachments[I].Info.SocketName);
                if(SFXBoneName != 'None')
                {
                    PostAkEventOnBone(ExtraVFXAttachments[I].Info.SFXStartEvent, SFXBoneName, false, true);                    
                }
                else
                {
                    PostAkEvent(ExtraVFXAttachments[I].Info.SFXStartEvent, false, true, false);
                }
            }
            bActivatedExistingSystem = true;
        }
        ++ I;
        goto J0x4F;
    }
    if(bActivatedExistingSystem)
    {
        return;
    }
    I = 0;
    J0x30A:

    if(I < CharacterMonsterArch.ExtraVFX.Length)
    {
        if(CharacterMonsterArch.ExtraVFX[I].Label == FXLabel)
        {
            if(CharacterMonsterArch.ExtraVFX[I].SocketName == 'None')
            {
                WarnInternal(((((string(self) $ "::PlayExtraVFX - SocketName for ExtraVFX ") $ string(I)) $ " (") $ string(FXLabel)) $ ") is NONE");                
            }
            else
            {
                VFXAttachment.VFXComponent = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(CharacterMonsterArch.ExtraVFX[I].VFX, Mesh, CharacterMonsterArch.ExtraVFX[I].SocketName, true);
                if(CharacterMonsterArch.ExtraVFX[I].SFXStartEvent != none)
                {
                    SFXBoneName = Mesh.GetSocketBoneName(CharacterMonsterArch.ExtraVFX[I].SocketName);
                    if(SFXBoneName != 'None')
                    {
                        PostAkEventOnBone(CharacterMonsterArch.ExtraVFX[I].SFXStartEvent, SFXBoneName, false, true);                        
                    }
                    else
                    {
                        PostAkEvent(CharacterMonsterArch.ExtraVFX[I].SFXStartEvent, false, true, false);
                    }
                }
                VFXAttachment.Info = CharacterMonsterArch.ExtraVFX[I];
                ExtraVFXAttachments.AddItem(VFXAttachment;
            }
        }
        ++ I;
        goto J0x30A;
    }
}

simulated function StopExtraVFX(name FXLabel)
{
    local int I;
    local name SFXBoneName;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    I = 0;
    J0x36:

    if(I < ExtraVFXAttachments.Length)
    {
        if((FXLabel == 'None') || ExtraVFXAttachments[I].Info.Label == FXLabel)
        {
            ExtraVFXAttachments[I].VFXComponent.SetActive(false);
            if(ExtraVFXAttachments[I].Info.SFXStopEvent != none)
            {
                SFXBoneName = Mesh.GetSocketBoneName(ExtraVFXAttachments[I].Info.SocketName);
                if(SFXBoneName != 'None')
                {
                    PostAkEventOnBone(ExtraVFXAttachments[I].Info.SFXStopEvent, SFXBoneName, false, true);                    
                }
                else
                {
                    PostAkEvent(ExtraVFXAttachments[I].Info.SFXStopEvent, false, true, false);
                }
            }
        }
        ++ I;
        goto J0x36;
    }
}

state Dying
{
    event OnSleepRBPhysics()
    {
        local int I;

        Mesh.PerObjectShadowCullDistance *= 0.6;
        ReattachComponent(Mesh);
        I = 0;
        J0x43:

        if(I < 3)
        {
            if(ThirdPersonAttachments[I] != none)
            {
                ThirdPersonAttachments[I].PerObjectShadowCullDistance *= 0.6;
                ReattachComponent(ThirdPersonAttachments[I]);
            }
            ++ I;
            goto J0x43;
        }
        super.OnSleepRBPhysics();
    }

    event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
    {
        local KFPawn_Human KFPH;

        super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
        if((InstigatedBy != none) && InstigatedBy.Pawn != none)
        {
            KFPH = KFPawn_Human(InstigatedBy.Pawn);
            if(KFPH != none)
            {
                if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
                {
                    KFGameInfo(WorldInfo.Game).DialogManager.PlayBeatDeadHorseDialog(KFPH, self);
                }
            }
        }
    }

    simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
    {
        local PlayerController PC;
        local Matrix HeadMatrix;
        local Vector HeadLoc;

        PC = GetALocalPlayerController();
        if(((PC != none) && !PC.IsSpectating()) && PC.ViewTarget == self)
        {
            HeadMatrix = Mesh.GetBoneMatrix(Mesh.MatchRefBone('head'));
            HeadLoc = MatrixGetOrigin(HeadMatrix);
            out_CamRot = RInterpTo(out_CamRot, rotator(HeadLoc - out_CamLoc), fDeltaTime, 10);
            return true;
        }
        return global.CalcCamera(fDeltaTime, out_CamLoc, out_CamRot, out_FOV);
    }
    stop;    
}

defaultproperties
{
    bCanMeleeAttack=true
    bKnockdownWhenJumpedOn=true
    bDebug_UseIconForShowingSprintingOverheadInfo=true
    RandomColorIdx=-1
    DifficultyDamageMod=1
    GameResistancePct=1
    HeadlessBleedOutTime=5
    ParryResistance=1
    MinSpawnSquadSizeType=ESquadType.EST_Small
    begin object name=MeleeHelper class=KFMeleeHelperAI
        BaseDamage=6
        MaxHitRange=180
    object end
    // Reference: KFMeleeHelperAI'Default__KFPawn_Monster.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    WeakSpotSocketNames(0)=FX_Dazed
    LiveDamageTypeModifiers(0)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(1)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(2)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(3)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(4)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(5)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(6)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(7)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(8)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(9)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(10)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(11)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(12)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(13)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(14)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(15)=(DamageType=none,DamageScale=(1))
    ZedBumpDamageScale=1
    DifficultySettings=Class'KFMonsterDifficultyInfo'
    DamageInflationRate=1
    IntendedDamageInflationPercent=1
    DamageInflationPercent=1
    BleedIncapFX=ParticleSystem'FX_Gameplay_EMIT_THREE.FX_Incap_Bleed_01'
    DifficultyBlockSettings=(Chance=0,Duration=0,MaxBlocks=0,Cooldown=0,DamagedHealthPctToTrigger=0,MeleeDamageModifier=1,DamageModifier=1,AfflictionModifier=1,SoloChanceMultiplier=0)
    MinBlockFOV=0.1
    BlockSprintSpeedModifier=0.75
    DifficultyRallySettings=(bCanRally=true,bCauseSprint=false,RallyBuffTime=10,TakenDamageModifier=1,DealtDamageModifier=1)
    InitialGroundSpeedModifier=1
    MatchEnemySpeedAtDistance=200
    MinimumEnemySpeedToMatch=280
    PursuitSpeedScale=1
    ReachedEnemyThresholdScale=1
    BumpFrequency=0.5
    BumpDamageType=Class'KFDT_NPCBump'
    SpeedAdjustTransitionRate=200
    begin object name=SprintAkComponent0 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_Monster.SprintAkComponent0'
    SprintAkComponent=SprintAkComponent0
    begin object name=HeadshotAkComponent0 class=AkComponent
        BoneName=head
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_Monster.HeadshotAkComponent0'
    HeadShotAkComponent=HeadshotAkComponent0
    CollisionRadiusForReducedZedOnZedPinchPointCollisionState=1
    OnDeathAchievementID=-1
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_Monster.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bCanHeadTrack=true
    HitZones(0)=(ZoneName=head,BoneName=head,GoreHealth=20,MaxGoreHealth=-1,DmgScale=1.1,Limb=EHitZoneBodyPart.BP_Head,SkinID=1,bPlayedInjury=false)
    HitZones(1)=(ZoneName=neck,BoneName=neck,GoreHealth=20,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Head,SkinID=0,bPlayedInjury=false)
    HitZones(2)=(ZoneName=chest,BoneName=Spine2,GoreHealth=150,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(3)=(ZoneName=heart,BoneName=Spine2,GoreHealth=150,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Special,SkinID=0,bPlayedInjury=false)
    HitZones(4)=(ZoneName=lupperarm,BoneName=LeftArm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(5)=(ZoneName=lforearm,BoneName=LeftForearm,GoreHealth=15,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(6)=(ZoneName=lhand,BoneName=LeftForearm,GoreHealth=20,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(7)=(ZoneName=rupperarm,BoneName=RightArm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(8)=(ZoneName=rforearm,BoneName=RightForearm,GoreHealth=15,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(9)=(ZoneName=rhand,BoneName=RightForearm,GoreHealth=20,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(10)=(ZoneName=stomach,BoneName=Spine1,GoreHealth=150,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(11)=(ZoneName=abdomen,BoneName=hips,GoreHealth=150,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(12)=(ZoneName=lthigh,BoneName=LeftUpLeg,GoreHealth=75,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(13)=(ZoneName=lcalf,BoneName=LeftLeg,GoreHealth=25,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(14)=(ZoneName=lfoot,BoneName=LeftLeg,GoreHealth=15,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(15)=(ZoneName=rthigh,BoneName=RightUpLeg,GoreHealth=75,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    HitZones(16)=(ZoneName=rcalf,BoneName=RightLeg,GoreHealth=25,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    HitZones(17)=(ZoneName=rfoot,BoneName=RightLeg,GoreHealth=15,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    AfflictionHandler=KFAfflictionManager'Default__KFPawn_Monster.Afflictions'
    IncapSettings(0)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(1)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(2)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(3)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(4)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(5)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(6)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(7)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(8)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(9)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(10)=(Duration=5,Cooldown=5,Vulnerability=none)
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    ArmPhysicsBoneList(0)=RightShoulder
    ArmPhysicsBoneList(1)=RightArm
    ArmPhysicsBoneList(2)=RightForearm
    ArmPhysicsBoneList(3)=RightHand
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses(0)=none
        SpecialMoveClasses(1)=class'KFSM_MeleeAttack'
        SpecialMoveClasses(2)=class'KFSM_DoorMeleeAttack'
        SpecialMoveClasses(3)=class'KFSM_GrappleCombined'
        SpecialMoveClasses(4)=class'KFSM_Stumble'
        SpecialMoveClasses(5)=class'KFSM_RecoverFromRagdoll'
        SpecialMoveClasses(6)=class'KFSM_RagdollKnockdown'
        SpecialMoveClasses(7)=class'KFSM_DeathAnim'
        SpecialMoveClasses(8)=class'KFSM_Stunned'
        SpecialMoveClasses(9)=class'KFSM_Frozen'
        SpecialMoveClasses(10)=none
        SpecialMoveClasses(11)=none
        SpecialMoveClasses(12)=none
        SpecialMoveClasses(13)=class'KFSM_Zed_Taunt'
        SpecialMoveClasses(14)=class'KFSM_Zed_WalkingTaunt'
        SpecialMoveClasses(15)=none
        SpecialMoveClasses(16)=none
        SpecialMoveClasses(17)=none
        SpecialMoveClasses(18)=none
        SpecialMoveClasses(19)=none
        SpecialMoveClasses(20)=none
        SpecialMoveClasses(21)=none
        SpecialMoveClasses(22)=none
        SpecialMoveClasses(23)=none
        SpecialMoveClasses(24)=none
        SpecialMoveClasses(25)=none
        SpecialMoveClasses(26)=none
        SpecialMoveClasses(27)=none
        SpecialMoveClasses(28)=none
        SpecialMoveClasses(29)=none
        SpecialMoveClasses(30)=none
        SpecialMoveClasses(31)=none
        SpecialMoveClasses(32)=none
        SpecialMoveClasses(33)=none
        SpecialMoveClasses(34)=none
        SpecialMoveClasses(35)=none
        SpecialMoveClasses(36)=none
        SpecialMoveClasses(37)=class'KFSM_Zed_Boss_Theatrics'
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_Monster.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_Monster.WeaponAmbientEchoHandler'
    FootstepAkComponent=AkComponent'Default__KFPawn_Monster.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_Monster.DialogAkSoundComponent'
    MaxTurningRadius=64
    AccelConvergeFalloffDistance=400
    HiddenGroundSpeed=600
    LedgeCheckThreshold=350
    bCanCrouch=false
    bCanStrafe=true
    bCanLeap=true
    bModifyReachSpecCost=true
    PathSearchType=EPathSearchType.PST_Constraint
    Alertness=1
    SightRadius=16384
    PeripheralVision=-1
    JumpZ=750
    ControllerClass=Class'KFAIController_Monster'
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        WireframeColor=(B=0,G=255,R=255,A=255)
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_Monster.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_Monster.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        WireframeColor=(B=0,G=255,R=255,A=255)
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_Monster.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_Monster.DialogAkSoundComponent'
    begin object name=SprintAkComponent0 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_Monster.SprintAkComponent0'
    Components(8)=SprintAkComponent0
    begin object name=HeadshotAkComponent0 class=AkComponent
        BoneName=head
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_Monster.HeadshotAkComponent0'
    Components(9)=HeadshotAkComponent0
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}