/*******************************************************************************
 * KFPawn_Monster generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_Monster extends KFPawn
    abstract
    native(Pawn)
    nativereplication
    config(Game)
    hidecategories(Navigation);

const SLOW_SPEED_MOD = 0.8f;

struct native DamageModifierInfo
{
    /** A damage type to modify damage to this zed when it is received */
    var() class<DamageType> DamageType;
    /** Damage scale for this damage type. Additional array elements (MAX:4) can be used to modify for higher game difficulties */
    var() array<float> DamageScale;

    structdefaultproperties
    {
        DamageType=none
        DamageScale(0)=1
    }
};

struct native SpecialMoveCooldownInfo
{
    var float CoolDownTime;
    var transient float LastUsedTime;
    var KFPawn.ESpecialMove SMHandle;
    var Texture2D SpecialMoveIcon;
    var int Charges;
    var string NameLocalizationKey;
    var string GBA_Name;
    var string ALT_GBA_NAME;
    var bool bShowOnHud;

    structdefaultproperties
    {
        CoolDownTime=0
        LastUsedTime=0
        SMHandle=ESpecialMove.SM_None
        SpecialMoveIcon=Texture2D'UI_Widgets.MenuBarWidget_SWF_IF'
        Charges=-1
        NameLocalizationKey=""
        GBA_Name=""
        ALT_GBA_NAME=""
        bShowOnHud=true
    }
};

struct native AttachedGoreChunkInfo
{
    var int AttachmentIndex;
    var export editinline StaticMeshComponent AttachedComponent;

    structdefaultproperties
    {
        AttachmentIndex=0
        AttachedComponent=none
    }
};

var bool bLargeZed;
var bool bVersusZed;
var const bool bForceUseOfDebugCharInfo;
var(Combat) bool bCanGrabAttack;
var(Combat) bool bCanMeleeAttack;
var(Combat) bool bHasExtraSprintJumpVelocity;
var repnotify bool bIsHeadless;
var protected bool bHasReducedMeleeDamage;
var bool bShowHealth;
var transient bool bCheckingExtraHeadDamage;
var bool bIsBlocking;
var bool bJumped;
var repnotify bool bIsPoisoned;
var bool bMicrowavePanicked;
var bool bKnockdownWhenJumpedOn;
var bool bPlayPanicked;
var bool bPlayShambling;
var bool bCloakOnMeleeEnd;
var bool bIsCloakingSpottedByLP;
var repnotify bool bIsCloakingSpottedByTeam;
var bool bCanRage;
var repnotify bool bIsEnraged;
var private bool bIsStalkerClass;
var private bool bIsCrawlerClass;
var private bool bIsFleshpoundClass;
var private bool bIsBloatClass;
var bool bMatchEnemySpeed;
var bool bRestoreCollisionOnLand;
var transient bool bPlayedExplosionEffect;
var bool bNapalmInfected;
var bool bCouldTurnIntoShrapnel;
var bool bDebug_DrawOverheadInfo;
var bool bDebug_DrawSprintingOverheadInfo;
var const bool bDebug_UseIconForShowingSprintingOverheadInfo;
var bool bReducedZedOnZedPinchPointCollisionStateActive;
var protected bool bOnDeathAchivementbDisabled;
var private const KFCharacterInfo_Monster CharacterMonsterArch;
var private const KFCharacterInfo_Monster CharacterMonsterArchDebug;
/** Custom third person camera offsets */
var() ViewOffsetData ThirdPersonViewOffset;
/** The chance that this monster pawn will sprint */
var(Combat) float SprintChance;
/** Odds (0-1) of evaluating whether to do a grab attack instead of a basic melee attack */
var(Combat) float GrabAttackFrequency;
/** The amount to scale this Zed's damage based on difficulty */
var(Combat) float DifficultyDamageMod;
/** Time until death after head is taken off */
var(Combat) float HeadlessBleedOutTime;
var byte MaxHeadChunkGoreWhileAlive;
var byte ParryResistance;
var repnotify byte RepInflateMatParam;
/**  
 *When spawning in a spawn volume, the squad type as to be at least this big (can be bigger
 *  if there are other zeds in the spawn squad that are larger).
 */
var() KFSpawnVolume.ESquadType MinSpawnSquadSizeType;
/** Object that manages melee attacks, and stores default damage */
var(Weapon) export editinline KFMeleeHelperAI MeleeAttackHelper;
var private const int DoshValue;
var private const float XPValues[4];
/** List of sockets representing weakpoint zone locations */
var() array<name> WeakSpotSocketNames;
var array<DamageModifierInfo> DamageTypeModifiers;
var array<DamageModifierInfo> LiveDamageTypeModifiers;
var float ZedBumpDamageScale;
/** Base human-controlled melee damage */
var(Combat) float HumanBaseMeleeDamage;
var float MinBlockFOV;
var float BlockingDamageModifier;
var float MeleeBlockingDamageModifier;
var protected array<SpecialMoveCooldownInfo> SpecialMoveCooldowns;
var transient float LastAttackHumanWarningTime;
var transient int OldHealth;
var KFAnim_RandomScripted WalkBlendList;
var float KnockedDownBySonicWaveOdds;
var float LastSpottedStatusUpdate;
var KFPlayerController LastStoredCC;
var export editinline transient ParticleSystemComponent RallyPSC;
var float PlayerRallyBuffTime;
var float PlayerRallyBuffPowerBoostPct;
var export editinline transient ParticleSystemComponent PlayerRallyPSCs[2];
var transient float NormalGroundSpeed;
var transient float NormalSprintSpeed;
var transient float RandomGroundSpeedModifier;
var transient float LastAISpeedCheckTime;
var transient float LastLOSOrRelevantTime;
var float MatchEnemySpeedAtDistance;
var float MinimumEnemySpeedToMatch;
var float PursuitSpeedScale;
var float ReachedEnemyThresholdScale;
var float ReachedGoalThresh_Walking;
var float ReachedGoalThresh_Spider;
var float LastBumpTime;
var float BumpFrequency;
var class<KFDamageType> BumpDamageType;
var class<KFDamageType> JumpBumpDamageType;
var protected const float FootstepCameraShakeInnerRadius;
var protected const float FootstepCameraShakeOuterRadius;
var CameraShake FootstepCameraShake;
var float DesiredAdjustedGroundSpeed;
var float DesiredAdjustedSprintSpeed;
var float SpeedAdjustTransitionRate;
var transient array<AttachedGoreChunkInfo> AttachedGoreChunks;
var transient int NumHeadChunksRemoved;
var transient array<name> BrokenHeadBones;
var transient int DeadHorseHitStreakAmt;
var transient float LastDeadHorseHitTime;
var float DefaultCollisionRadius;
var KFTrigger_ChokePoint CurrentChokePointTrigger;
var const float CollisionRadiusForReducedZedOnZedPinchPointCollisionState;
var protected const int OnDeathAchievementID;
var delegate<GoreChunkAttachmentCriteria> __GoreChunkAttachmentCriteria__Delegate;
var delegate<GoreChunkDetachmentCriteria> __GoreChunkDetachmentCriteria__Delegate;

replication
{
     if(bNetDirty)
        MaxHeadChunkGoreWhileAlive, RepInflateMatParam, 
        bIsHeadless, bIsPoisoned, 
        bPlayPanicked, bPlayShambling, 
        bShowHealth;

     if(bNetDirty && bCanCloak)
        bIsCloakingSpottedByTeam;

     if(bNetDirty && bCanRage)
        bIsEnraged;
}

simulated delegate bool GoreChunkAttachmentCriteria();

simulated delegate bool GoreChunkDetachmentCriteria();

// Export UKFPawn_Monster::execSpiderPhysicsWallAdjust(FFrame&, void* const)
native function bool SpiderPhysicsWallAdjust(Vector HitNormal, Actor HitActor);

// Export UKFPawn_Monster::execSetChokePointCollision(FFrame&, void* const)
native function SetChokePointCollision(bool bUseChokeCollision);

// Export UKFPawn_Monster::execCheckEncroachingWorldGeometry(FFrame&, void* const)
native function bool CheckEncroachingWorldGeometry();

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'bIsHeadless':
            StopAkEventsOnBone('head');
            bCanBeAdheredTo = false;
            bCanBeFrictionedTo = false;
            break;
        case 'bIsPoisoned':
            AfflictionHandler.ToggleEffects(6, bIsPoisoned);
            break;
        case 'RepInflateMatParam':
            AfflictionHandler.UpdateMaterialParameter(9, ByteToFloat(RepInflateMatParam));
            break;
        case 'Controller':
            SetSwitch('Player_Zed', ((IsHumanControlled()) ? 'Player' : 'NotPlayer'));
            break;
        case 'bEmpDisrupted':
            if(bEmpDisrupted)
            {
                PutAllMovesOnCooldown();
            }
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

static simulated function int GetDoshValue()
{
    return default.DoshValue;
}

static simulated function float GetXPValue(byte Difficulty)
{
    return default.XPValues[Difficulty];
}

simulated event PreBeginPlay()
{
    DefaultCollisionRadius = CylinderComponent.default.CollisionRadius;
    super.PreBeginPlay();
    if(CharacterArch == none)
    {
        if(bForceUseOfDebugCharInfo && CharacterMonsterArchDebug != none)
        {
            SetCharacterArch(CharacterMonsterArchDebug);            
        }
        else
        {
            if(CharacterMonsterArch != none)
            {
                SetCharacterArch(CharacterMonsterArch);
            }
        }
    }
    if(CharacterArch == none)
    {
        WarnInternal("Failed to find character info for KFMonsterPawn!");
        Destroy();
    }
    NormalGroundSpeed = default.GroundSpeed;
    NormalSprintSpeed = default.SprintSpeed;
}

simulated function NotifyTeamChanged()
{
    if(CharacterArch != none)
    {
        CharacterArch.SetCharacterFromArch(self, KFPlayerReplicationInfo(PlayerReplicationInfo));
    }
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    local string NPCName;
    local KFPlayerReplicationInfo KFPRI;

    super.PossessedBy(C, bVehicleTransition);
    if(KFAIController(C) != none)
    {
        MyKFAIC = KFAIController(C);
    }
    bReducedZedOnZedPinchPointCollisionStateActive = false;
    if(IsHumanControlled())
    {
        KFPRI = KFPlayerReplicationInfo(C.PlayerReplicationInfo);
        if(KFPRI != none)
        {
            KFPRI.PlayerHealth = byte(Health);
            KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
            SetCharacterArch(CharacterMonsterArch, true);
        }
        if(Role == ROLE_Authority)
        {
            LastAttackHumanWarningTime = WorldInfo.TimeSeconds;
        }        
    }
    else
    {
        AirControl = 0.35;
    }
    KFGameInfo(WorldInfo.Game).SetMonsterDefaults(self);
    if((MyKFAIC != none) && MyKFAIC.PlayerReplicationInfo != none)
    {
        NPCName = string(self);
        NPCName = Repl(NPCName, "KFPawn_Zed", "", false);
        PlayerReplicationInfo.PlayerName = NPCName;
        MyKFAIC.PlayerReplicationInfo.PlayerName = NPCName;
    }
    SetSwitch('Player_Zed', ((IsHumanControlled()) ? 'Player' : 'NotPlayer'));
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    local string msg;

    WarnInternal(string(self) $ " FELL OUT OF WORLD!");
    if(Health > 0)
    {
        msg = (((string(WorldInfo.TimeSeconds) @ string(self)) @ string(GetFuncName())) @ "fell out of world! Current location:") @ string(Location);
        if(MyKFAIC != none)
        {
            msg = (((msg @ "Controller:") @ string(MyKFAIC)) @ "active command:") @ string(MyKFAIC.GetActiveCommand());
            if(MyKFAIC.MoveTarget != none)
            {
                msg = (msg @ "MoveTarget:") @ string(MyKFAIC.MoveTarget);
            }
        }
        WarnInternal(msg);
    }
    super(Pawn).FellOutOfWorld(dmgType);
}

event BaseChange()
{
    if(IsAliveAndWell() && MyKFAIC != none)
    {
        if(MyKFAIC.NotifyBaseChange(Base, Floor))
        {
            return;
        }
    }
    super.BaseChange();
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    WalkBlendList = KFAnim_RandomScripted(SkelComp.FindAnimNode('WalkRandomList'));
}

function ApplySpecialZoneHealthMod(float HealthMod)
{
    HitZones[0].GoreHealth = int(float(default.HitZones[0].GoreHealth) * HealthMod);
}

// Export UKFPawn_Monster::execGetCharacterMonsterInfo(FFrame&, void* const)
native function KFCharacterInfo_Monster GetCharacterMonsterInfo();

simulated function bool UsePlayerControlledZedSkin()
{
    return bVersusZed;
}

function AdjustMovementSpeed(float SpeedAdjust)
{
    DesiredAdjustedGroundSpeed = (default.GroundSpeed * SpeedAdjust) * RandomGroundSpeedModifier;
    DesiredAdjustedSprintSpeed = (default.SprintSpeed * SpeedAdjust) * RandomGroundSpeedModifier;
    NormalGroundSpeed = DesiredAdjustedGroundSpeed;
    NormalSprintSpeed = DesiredAdjustedSprintSpeed;
}

simulated event PlayFootStepSound(int FootDown)
{
    super.PlayFootStepSound(FootDown);
    if(((MyKFAIC != none) && FootstepCameraShake != none) && MyKFAIC.IsDoingLatentMove())
    {
        Class'Camera'.static.PlayWorldCameraShake(FootstepCameraShake, self, Location, FootstepCameraShakeInnerRadius, FootstepCameraShakeOuterRadius, 1.3, true);
    }
}

event SpiderBumpLevel(Vector HitLocation, Vector HitNormal, optional Actor Wall);

simulated event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local KFPawn_Monster KFPM;
    local KFPawn_Human KFPH;
    local byte DoTIndex;

    super(Actor).Bump(Other, OtherComp, HitNormal);
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].NotifyBump(Other, HitNormal);
    }
    if(DamageOverTimeArray.Length > 0)
    {
        DoTIndex = byte(DamageOverTimeArray.Find('DoT_Type', Class'KFDT_Fire'.default.DoT_Type);
        if((DoTIndex != -1) && !bNapalmInfected)
        {
            KFPM = KFPawn_Monster(Other);
            if(KFPM != none)
            {
                CheckForNapalmInfect(KFPM, DoTIndex);
            }
        }
    }
    if(JumpBumpDamageType != none)
    {
        KFPH = KFPawn_Human(Other);
        if(((KFPH != none) && Physics == 2) && VSize2D(Velocity) > (GroundSpeed * 1.1))
        {
            KFPH.TakeDamage(int(MeleeAttackHelper.BaseDamage), Controller, KFPH.Location, Normal(Velocity), JumpBumpDamageType);
        }
    }
}

event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    if(MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((string(GetFuncName()) $ "() Wall: ") $ string(Wall), 'BumpEvent');
    }
    NotifyCollideWithActor(HitNormal, Wall);
    super(Actor).HitWall(HitNormal, Wall, WallComp);
}

function bool NotifyCollideWithActor(Vector HitNormal, Actor Other)
{
    if(MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((string(GetFuncName()) $ "() Other: ") $ string(Other), 'BumpEvent');
    }
    return false;
}

simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    if(MyKFAIC != none)
    {
        MyKFAIC.Touch(Other, OtherComp, HitLocation, HitNormal);
    }
    super.Touch(Other, OtherComp, HitLocation, HitNormal);
}

function SetSprinting(bool bNewSprintStatus)
{
    if(MyKFAIC != none)
    {
        if(!MyKFAIC.CanSetSprinting(bNewSprintStatus))
        {
            return;
        }
    }
    if(bIsBlocking)
    {
        if(bIsSprinting)
        {
            bNewSprintStatus = false;            
        }
        else
        {
            return;
        }
    }
    super.SetSprinting(bNewSprintStatus);
}

event StuckOnPawn(Pawn OtherPawn)
{
    JumpOffPawn();
    if(MyKFAIC != none)
    {
        if(MyKFAIC != none)
        {
            MyKFAIC.AILog_Internal((((string(self) $ " StuckOnPawn event at ") $ string(Location)) $ " Base: ") $ string(Base));
        }
        MyKFAIC.DumpCommandStack();
        MyKFAIC.DumpCommandHistory();
    }
}

function bool DoJump(bool bUpdating)
{
    local Vector JumpVelocity;
    local Rotator ViewRotation;
    local Vector ViewDirection;

    if(IsHumanControlled())
    {
        if(IsDoingSpecialMove())
        {
            return false;
        }
        ViewRotation = GetViewRotation();
        ViewDirection = Normal(vector(ViewRotation));
        if(((bJumpCapable && !bIsCrouched) && !bWantsToCrouch) && ((Physics == 1) || Physics == 9) || Physics == 8)
        {
            if(Physics == 8)
            {
                Velocity = Velocity + ((GetJumpZ()) * Floor);                
            }
            else
            {
                if(Physics == 9)
                {
                    Velocity.Z = 0;                    
                }
                else
                {
                    if(bIsWalking)
                    {
                        Velocity.Z = default.JumpZ;                        
                    }
                    else
                    {
                        if(bIsSprinting && bHasExtraSprintJumpVelocity)
                        {
                            JumpVelocity = GetSprintJumpVelocity(ViewDirection);
                            JumpVelocity.Z = GetJumpZ();
                            Velocity += JumpVelocity;                            
                        }
                        else
                        {
                            Velocity.Z = GetJumpZ();
                        }
                    }
                }
            }
            if(((Base != none) && !Base.bWorldGeometry) && Base.Velocity.Z > 0)
            {
                Velocity.Z += Base.Velocity.Z;
            }
            SetPhysics(2);
            bJumped = true;
            return true;
        }
        return false;        
    }
    else
    {
        return super.DoJump(bUpdating);
    }
}

simulated function float GetJumpZ()
{
    return JumpZ;
}

simulated function Vector GetSprintJumpVelocity(Vector ViewDirection)
{
    return (ViewDirection * (GetJumpZ())) * (GetDirectionalJumpScale());
}

simulated function float GetDirectionalJumpScale()
{
    return 1;
}

function class<KFDamageType> GetBumpAttackDamageType();

function TakeFallingDamage();

event Landed(Vector HitNormal, Actor FloorActor)
{
    local Controller StoredLastHitBy;
    local int SMIndex;

    StoredLastHitBy = LastHitBy;
    if(bRestoreCollisionOnLand)
    {
        bRestoreCollisionOnLand = false;
        SetCollisionSize(default.CylinderComponent.CollisionRadius, default.CylinderComponent.CollisionHeight);
        FitCollision();
    }
    if(IsHumanControlled())
    {
        if(bJumped && IsLocallyControlled())
        {
            SMIndex = SpecialMoveCooldowns.Find('SMHandle', 11;
            if(SMIndex != -1)
            {
                SpecialMoveCooldowns[SMIndex].LastUsedTime = WorldInfo.TimeSeconds;
            }
        }
        bJumped = false;
    }
    super.Landed(HitNormal, FloorActor);
    LastHitBy = StoredLastHitBy;
}

function SetMovementPhysics()
{
    if((Physics == 0) && IsDoingSpecialMove())
    {
        return;
    }
    super(Pawn).SetMovementPhysics();
}

function CrushedBy(Pawn OtherPawn)
{
    super(Pawn).CrushedBy(OtherPawn);
    if((((bKnockdownWhenJumpedOn && Health > 0) && (OtherPawn.Location.Z - Location.Z) > (OtherPawn.CylinderComponent.CollisionHeight + CylinderComponent.CollisionHeight)) && !IsHumanControlled()) && GetTeamNum() != OtherPawn.GetTeamNum())
    {
        Knockdown(,, vect(1, 1, 1), OtherPawn.Location, 1000, 100);
    }
}

// Export UKFPawn_Monster::execIsValidEnemyTargetFor(FFrame&, void* const)
native function bool IsValidEnemyTargetFor(const PlayerReplicationInfo PRI, bool bNoPRIisEnemy);

// Export UKFPawn_Monster::execInChargeRange(FFrame&, void* const)
native function bool InChargeRange(const Vector TestLocation);

// Export UKFPawn_Monster::execInMeleeRange(FFrame&, void* const)
native function bool InMeleeRange(const Vector TestLocation, optional name AttackTag);

// Export UKFPawn_Monster::execInAttackTagRange(FFrame&, void* const)
native function bool InAttackTagRange(const name AttackTag, const Vector TestLocation);

// Export UKFPawn_Monster::execInAnyAttackTagRange(FFrame&, void* const)
native function bool InAnyAttackTagRange(const Vector TestLocation, out name outAttackTag);

// Export UKFPawn_Monster::execGetEnemy(FFrame&, void* const)
native function KFPawn GetEnemy();

// Export UKFPawn_Monster::execIsLocationValidForCombat(FFrame&, void* const)
native final function bool IsLocationValidForCombat(KFPawn CheckPawn, const Vector CheckLocation);

simulated function SetEnraged(bool bNewEnraged);

simulated event bool IsEnraged();

simulated function MeleeImpactNotify(KFAnimNotify_MeleeImpact Notify)
{
    if(MeleeAttackHelper != none)
    {
        MeleeAttackHelper.bHasAlreadyHit = false;
        MeleeAttackHelper.MeleeImpactNotify(Notify);
    }
    if(((MyKFAIC != none) && MyKFAIC.Enemy != none) && MyKFAIC.Enemy.Health <= 0)
    {
        ClearHeadTrackTarget(Controller.Enemy);
        MyKFAIC.AbortCommand(none, Class'AICommand_Attack_Grab');
        MyKFAIC.AbortCommand(none, Class'AICommand_Attack_Melee');
        Class'AICommand_TauntEnemy'.static.Taunt(KFAIController(Controller),, 1);
    }
}

function NotifyMeleeDamageDealt();

event bool IsInAttackTagRange(Vector TestLocation, name AttackTag)
{
    local Vector2D MinMaxRange;
    local float DistSq;

    if((MyKFAIC == none) || PawnAnimInfo == none)
    {
        MinMaxRange = PawnAnimInfo.GetAttackRangeByName(AttackTag);
        DistSq = VSizeSq(TestLocation - Location);
        if((DistSq > (MinMaxRange.X * MinMaxRange.X)) && DistSq < (MinMaxRange.Y * MinMaxRange.Y))
        {
            return true;
        }
    }
    return false;
}

event bool IsInAnyAttackTagRange(Vector TestLocation, out name outAttackTag)
{
    local int Idx;

    if((MyKFAIC == none) || PawnAnimInfo == none)
    {
        outAttackTag = 'None';
        return false;
    }
    Idx = 0;
    J0x40:

    if(Idx < PawnAnimInfo.Attacks.Length)
    {
        if((PawnAnimInfo.Attacks[Idx].Tag == 'None') || PawnAnimInfo.Attacks[Idx].Chance <= 0)
        {            
        }
        else
        {
            if(IsInAttackTagRange(TestLocation, PawnAnimInfo.Attacks[Idx].Tag))
            {
                outAttackTag = PawnAnimInfo.Attacks[Idx].Tag;
                return true;
            }
        }
        ++ Idx;
        goto J0x40;
    }
    outAttackTag = 'None';
    return false;
}

simulated function StartFire(byte FireModeNum)
{
    local KFPawn.ESpecialMove DesiredSpecialMove;
    local byte SMFlags;

    if(!IsHumanControlled())
    {
        super(Pawn).StartFire(FireModeNum);
        return;
    }
    if((FireModeNum >= SpecialMoveCooldowns.Length) || SpecialMoveCooldowns[FireModeNum].SMHandle == 0)
    {
        return;
    }
    switch(FireModeNum)
    {
        case 0:
            DesiredSpecialMove = 21;
            break;
        case 1:
            DesiredSpecialMove = 22;
            break;
        case 2:
            DesiredSpecialMove = 12;
            break;
        case 3:
            DesiredSpecialMove = 23;
            break;
        case 4:
            DesiredSpecialMove = 24;
            break;
        case 5:
            DesiredSpecialMove = 25;
            break;
        case 6:
            DesiredSpecialMove = 26;
            break;
        default:
            break;
    }
    if(SpecialMoveCooldowns[FireModeNum].SMHandle != DesiredSpecialMove)
    {
        WarnInternal(((((("FireMode/SpecialMoveCooldown mismatch. Attempted" @ string(DesiredSpecialMove)) @ "with FireMode") @ string(FireModeNum)) $ ", but cooldown SM handle is") @ string(SpecialMoveCooldowns[FireModeNum].SMHandle)) $ "!");
        return;
    }
    if(DesiredSpecialMove != 0)
    {
        if((GetSpecialMoveCooldownTimeRemaining(SpecialMoveCooldowns[FireModeNum])) > 0)
        {
            return;
        }
        if(SpecialMove == DesiredSpecialMove)
        {
            SpecialMoves[SpecialMove].SpecialMoveButtonRetriggered();            
        }
        else
        {
            if(CanDoSpecialMove(DesiredSpecialMove))
            {
                SMFlags = SpecialMoveHandler.SpecialMoveClasses[DesiredSpecialMove].static.PackFlagsBase(self);
                DoSpecialMove(DesiredSpecialMove, true, InteractionPawn, SMFlags);
                if((Role < ROLE_Authority) && IsDoingSpecialMove(DesiredSpecialMove))
                {
                    ServerDoSpecialMove(DesiredSpecialMove, true, InteractionPawn, SMFlags);
                }
            }
        }
    }
}

simulated function StopFire(byte FireModeNum)
{
    local KFPawn.ESpecialMove DesiredSpecialMove;

    if(!IsHumanControlled())
    {
        super(Pawn).StopFire(FireModeNum);
        return;
    }
    if(!IsDoingSpecialMove())
    {
        return;
    }
    switch(FireModeNum)
    {
        case 0:
            DesiredSpecialMove = 21;
            break;
        case 1:
            DesiredSpecialMove = 22;
            break;
        case 2:
            DesiredSpecialMove = 12;
            break;
        case 3:
            DesiredSpecialMove = 23;
            break;
        case 4:
            DesiredSpecialMove = 24;
            break;
        case 5:
            DesiredSpecialMove = 25;
            break;
        case 6:
            DesiredSpecialMove = 26;
            break;
        default:
            break;
    }
    if(SpecialMove == DesiredSpecialMove)
    {
        SpecialMoves[SpecialMove].SpecialMoveButtonReleased();
    }
}

simulated function NotifySpecialMoveEnded(KFSpecialMove FinishedMove, KFPawn.ESpecialMove SMHandle)
{
    local byte SMIndex;

    if(IsHumanControlled() && IsLocallyControlled())
    {
        SMIndex = byte(SpecialMoveCooldowns.Find('SMHandle', SMHandle);
        if(SMIndex != -1)
        {
            SpecialMoveCooldowns[SMIndex].LastUsedTime = WorldInfo.TimeSeconds;
        }
    }
}

function float GetSpecialMoveCooldownPercent(SpecialMoveCooldownInfo Cooldown)
{
    local float CDTime;

    if(Cooldown.SMHandle != 0)
    {
        if((Cooldown.LastUsedTime > 0) && Cooldown.CoolDownTime > 0)
        {
            CDTime = ((!bEmpDisrupted) ? Cooldown.CoolDownTime : AfflictionHandler.GetAfflictionDuration(0));
            return FClamp((WorldInfo.TimeSeconds - Cooldown.LastUsedTime) / CDTime, 0, 1);
        }
    }
    return 1;
}

function float GetSpecialMoveCooldownTimeRemaining(SpecialMoveCooldownInfo Cooldown)
{
    local float CDTime;

    if(Cooldown.SMHandle != 0)
    {
        if((Cooldown.LastUsedTime > 0) && Cooldown.CoolDownTime > 0)
        {
            CDTime = ((!bEmpDisrupted) ? Cooldown.CoolDownTime : AfflictionHandler.GetAfflictionDuration(0));
            return CDTime - FMin(WorldInfo.TimeSeconds - Cooldown.LastUsedTime, CDTime);
        }
    }
    return 0;
}

function float GetSpecialMoveCooldownTimeRemainingByHandle(KFPawn.ESpecialMove SMHandle)
{
    local byte SMIndex;

    SMIndex = byte(SpecialMoveCooldowns.Find('SMHandle', SMHandle);
    if(SMIndex != -1)
    {
        return GetSpecialMoveCooldownTimeRemaining(SpecialMoveCooldowns[SMIndex]);
    }
    return 0;
}

function byte GetSMHandleFireMode(KFPawn.ESpecialMove SMHandle)
{
    return byte(SpecialMoveCooldowns.Find('SMHandle', SMHandle);
}

simulated function array<SpecialMoveCooldownInfo> GetSpecialMoveCooldowns()
{
    return SpecialMoveCooldowns;
}

function PutAllMovesOnCooldown()
{
    local int I;

    if(IsHumanControlled() && IsLocallyControlled())
    {
        I = 0;
        J0x28:

        if(I < SpecialMoveCooldowns.Length)
        {
            if(SpecialMoveCooldowns[I].SMHandle != 0)
            {
                SpecialMoveCooldowns[I].LastUsedTime = WorldInfo.TimeSeconds;
            }
            ++ I;
            goto J0x28;
        }
    }
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    EndPlayerRallyBoost();
    super.PlayDying(DamageType, HitLoc);
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local KFPawn_Human HumanInstigator;
    local KFAIController_Monster AIMonster;
    local class<KFDamageType> KFDT;
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;
    local KFPlayerReplicationInfo KFPRI;
    local KFAIController KFAIC;
    local KFPawn_Monster KFPM;

    AIMonster = KFAIController_Monster(InstigatedBy);
    KFDT = class<KFDamageType>(DamageType);
    KFPC = KFPlayerController(InstigatedBy);
    if(KFPC != none)
    {
        InstigatorPerk = KFPC.GetPerk();
        KFAIC = KFAIController(Controller);
        if((KFAIC != none) && KFAIC.TimeFirstSawPlayer == float(0))
        {
            KFAIC.TimeFirstSawPlayer = WorldInfo.TimeSeconds;
        }
    }
    if(Damage <= 0)
    {
        if(((KFPC != none) && InstigatorPerk != none) && KFDT != none)
        {
            if(KFDT.static.IsToxicDartWithACMedicPerk())
            {
                InstigatorPerk.ModifyACDamage(Damage);
            }
        }
    }
    if(((AIMonster != none) && KFDT != none) && !KFDT.default.bIgnoreZedOnZedScaling)
    {
        if(Health >= 100)
        {
            Damage *= float(2 - ((HealthMax - Health) / HealthMax));
        }
    }
    super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        HumanInstigator = KFPawn_Human(InstigatedBy.Pawn);
        if(HumanInstigator != none)
        {
            HumanInstigator.ResetIdleStartTime();
        }
    }
    if(Damage > 0)
    {
        if((InstigatorPerk != none) && KFDT != none)
        {
            bCouldTurnIntoShrapnel = InstigatorPerk.CouldBeZedShrapnel(KFDT);
        }
        if(ClassIsChildOf(KFDT, Class'KFDT_Fire') && InstigatedBy != none)
        {
            foreach WorldInfo.AllPawns(Class'KFPawn_Monster', KFPM, Location, 30)
            {
                if(KFPM != self)
                {
                    CheckForNapalmInfect(KFPM, 255, InstigatedBy);
                }                
            }            
        }
        bShowHealth = true;
        SetTimer(2, false, 'ResetHealthVisibilty');
    }
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.PlayerHealth = byte(Health);
        KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
    }
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    local KFPlayerController KFPC;
    local KFPawn_Human KFPH;
    local float TempDamage;
    local int HitZoneIdx, ExtraHeadDamage;
    local KFPerk InstigatorPerk;
    local class<KFDamageType> KFDT;

    super.AdjustDamage(InDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
    if(DamageType.default.bCausedByWorld && ClassIsChildOf(DamageType, Class'KFDT_Falling'))
    {
        InDamage = 0;
        return;
    }
    InDamage *= (GetDamageTypeModifier(DamageType));
    ApplyBlockingDamageModifier(InDamage, InstigatedBy, DamageType);
    HitZoneIdx = HitZones.Find('ZoneName', HitInfo.BoneName;
    KFPC = KFPlayerController(InstigatedBy);
    if(KFPC != none)
    {
        InstigatorPerk = KFPC.GetPerk();
        if(InstigatorPerk != none)
        {
            InstigatorPerk.ModifyDamageGiven(InDamage, DamageCauser, self, KFPC, class<KFDamageType>(DamageType), HitZoneIdx);
        }
        if(KFPC.Pawn != none)
        {
            KFPH = KFPawn_Human(KFPC.Pawn);
            if((KFPH != none) && KFPH.bHasSupportBarrageBuff)
            {
                TempDamage = float(InDamage);
                TempDamage *= Class'KFPerk'.static.GetBarrageDamageModifier();
                InDamage = FCeil(TempDamage);
            }
        }
    }
    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitZoneIdx = 0;
    }
    if(((!bCheckingExtraHeadDamage && HitZoneIdx == 0) && HitZones[0].GoreHealth > 0) && InDamage > HitZones[0].GoreHealth)
    {
        KFDT = class<KFDamageType>(DamageType);
        if(KFDT != none)
        {
            InDamage *= KFDT.default.HeadDestructionDamageScale;
        }
        ExtraHeadDamage = int(float(InDamage) + (float(HealthMax) * 0.25));
        bCheckingExtraHeadDamage = true;
        AdjustDamage(ExtraHeadDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
        bCheckingExtraHeadDamage = false;
        InDamage += ExtraHeadDamage;
    }
    if(!bCheckingExtraHeadDamage && InstigatedBy != none)
    {
        AddTakenDamage(InstigatedBy, int(FMin(float(Health), float(InDamage))), DamageCauser, class<KFDamageType>(DamageType));
    }
    if((HitZoneIdx == 0) && bIsHeadless)
    {
        InDamage = 1;
    }
    if(bLogTakeDamage)
    {
        LogInternal((string(self) @ "Adjusted Monster Damage=") $ string(InDamage));
    }
}

function float GetDamageTypeModifier(class<DamageType> DT)
{
    local int I, DifficultyIdx;

    if(LiveDamageTypeModifiers.Length > 0)
    {
        AppendLiveDamageTypeModifiers();
    }
    I = DamageTypeModifiers.Length - 1;
    J0x31:

    if(I >= 0)
    {
        if(ClassIsChildOf(DT, DamageTypeModifiers[I].DamageType))
        {
            if((WorldInfo.Game != none) && DamageTypeModifiers[I].DamageScale.Length > 1)
            {
                DifficultyIdx = Min(int(WorldInfo.Game.GameDifficulty), DamageTypeModifiers[I].DamageScale.Length);
            }
            if(bLogTakeDamage)
            {
                LogInternal((((string(self) @ "Scaling damage taken from") @ string(DT)) @ "by") @ string(DamageTypeModifiers[I].DamageScale[DifficultyIdx]));
            }
            return DamageTypeModifiers[I].DamageScale[DifficultyIdx];
        }
        -- I;
        goto J0x31;
    }
    return 1;
}

function AppendLiveDamageTypeModifiers()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < LiveDamageTypeModifiers.Length)
    {
        if(LiveDamageTypeModifiers[I].DamageType != none)
        {
            DamageTypeModifiers.AddItem(LiveDamageTypeModifiers[I];            
        }
        else
        {
            goto J0x83;
        }
        ++ I;
        goto J0x0B;
    }
    J0x83:

    LiveDamageTypeModifiers.Length = 0;
}

function ApplyBlockingDamageModifier(out int Damage, Controller InstigatedBy, class<DamageType> DamageType)
{
    local Vector DamageDirNormal;

    if((((!bIsBlocking || Damage <= 0) || InstigatedBy == none) || InstigatedBy.Pawn == none) || InstigatedBy.GetTeamNum() == GetTeamNum())
    {
        return;
    }
    DamageDirNormal = Normal(InstigatedBy.Pawn.Location - Location);
    if((DamageDirNormal Dot vector(Rotation)) > MinBlockFOV)
    {
        if(ClassIsChildOf(DamageType, Class'KFDT_Bludgeon') || ClassIsChildOf(DamageType, Class'KFDT_Slashing'))
        {
            Damage = int(float(Damage) * MeleeBlockingDamageModifier);            
        }
        else
        {
            Damage = int(float(Damage) * BlockingDamageModifier);
        }
    }
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bRepairArmor, optional bool bMessageHealer)
{
    bRepairArmor = true;
    bMessageHealer = true;
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlaySpotZedHealingDialog(self);
    }
    super.HealDamage(Amount, Healer, DamageType);
    return true;
}

function bool HasReducedMeleeDamage()
{
    return bHasReducedMeleeDamage;
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum, Actor DamageCauser)
{
    local KFPawn_Human KFPH_Instigator;

    super(Pawn).NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum, DamageCauser);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        KFPH_Instigator = KFPawn_Human(InstigatedBy.Pawn);
        if(KFPH_Instigator != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayDamageZedContinuousDialog(KFPH_Instigator, self);
            }
        }
    }
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].NotifyOwnerTakeHit(class<KFDamageType>(DamageType), HitLocation, Normal(Momentum), InstigatedBy);
    }
    if(MyKFAIC != none)
    {
        MyKFAIC.AILog_Internal((((string(GetFuncName()) $ "() Instigator:") $ string(InstigatedBy)) $ " DT: ") $ string(DamageType), 'Damage');
    }
}

function PlayHit(float Damage, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, Vector Momentum, TraceHitInfo HitInfo)
{
    local KFPawn_Human KFPH_Instigator;

    super.PlayHit(Damage, InstigatedBy, HitLocation, DamageType, Momentum, HitInfo);
    if((InstigatedBy != none) && InstigatedBy.Pawn != none)
    {
        KFPH_Instigator = KFPawn_Human(InstigatedBy.Pawn);
        if(KFPH_Instigator != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayDamagedZedDialog(KFPH_Instigator, self, DamageType);
            }
        }
    }
}

function NotifyMeleeTakeHit(Controller InstigatedBy, Vector HitLocation);

function BleedOutTimer()
{
    if(!bPlayedDeath)
    {
        if(bLogTakeDamage)
        {
            LogInternal((string(GetFuncName()) @ "LastHitBy") @ string(LastHitBy));
        }
        Died(LastHitBy, Class'KFDT_Bleeding', Location);
    }
}

simulated function Rally(ParticleSystem RallyEffect, name EffectBoneName, Vector EffectOffset, ParticleSystem PlayerRallyEffect, name PlayerEffectBoneNames[2], Vector PlayerEffectOffset)
{
    local KFAIController KFAIC;
    local bool bStartedPlayerRally;

    if(bVersusZed)
    {
        if(!IsTimerActive('EndPlayerRallyBoost'))
        {
            SetTimer(PlayerRallyBuffTime, false, 'EndPlayerRallyBoost');
            bStartedPlayerRally = true;
        }        
    }
    else
    {
        if((Role == ROLE_Authority) && Controller != none)
        {
            KFAIC = KFAIController(Controller);
            KFAIC.SetSprintingDisabled(false);
            KFAIC.SetCanSprint(true);
            KFAIC.bDefaultCanSprint = true;
            KFAIC.bForceFrustration = true;
            SetSprinting(true);
            SetEnraged(true);
        }
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(RallyPSC != none)
        {
            RallyPSC.DeactivateSystem();
            DetachComponent(RallyPSC);
        }
        RallyPSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(RallyEffect, Mesh, EffectBoneName, false, EffectOffset);
        if(bStartedPlayerRally)
        {
            if(Mesh.MatchRefBone(PlayerEffectBoneNames[0]) != -1)
            {
                PlayerRallyPSCs[0] = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(PlayerRallyEffect, Mesh, PlayerEffectBoneNames[0], false, PlayerEffectOffset);
            }
            if(Mesh.MatchRefBone(PlayerEffectBoneNames[1]) != -1)
            {
                PlayerRallyPSCs[1] = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(PlayerRallyEffect, Mesh, PlayerEffectBoneNames[1], false, PlayerEffectOffset);
            }
        }
    }
}

simulated function EndPlayerRallyBoost()
{
    if((PlayerRallyPSCs[0] != none) && PlayerRallyPSCs[0].bIsActive)
    {
        PlayerRallyPSCs[0].DeactivateSystem();
    }
    if((PlayerRallyPSCs[1] != none) && PlayerRallyPSCs[1].bIsActive)
    {
        PlayerRallyPSCs[1].DeactivateSystem();
    }
}

simulated function int GetRallyBoostDamage(int NewDamage)
{
    return int(float(NewDamage) * ((IsTimerActive('EndPlayerRallyBoost')) ? PlayerRallyBuffPowerBoostPct : 1));
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;

    if(super.Died(Killer, DamageType, HitLocation))
    {
        if(((Killer != none) && Killer.Pawn != none) && KFPawn_Human(Killer.Pawn) != none)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayKilledZedDialog(KFPawn_Human(Killer.Pawn), self, DamageType, IsDoingSpecialMove(6) || IsDoingSpecialMove(5));
            }
        }
        if(bCouldTurnIntoShrapnel)
        {
            if(Killer != none)
            {
                KFPC = KFPlayerController(Killer);
                if(KFPC != none)
                {
                    InstigatorPerk = KFPC.GetPerk();
                    if((InstigatorPerk != none) && InstigatorPerk.ShouldShrapnel())
                    {
                        ShrapnelExplode(Killer);
                    }
                }
            }
        }
        return true;
    }
    return false;
}

simulated event Destroyed()
{
    AfflictionHandler.ShutDown();
    super.Destroyed();
}

event OnRigidBodyLinearConstraintViolated(name StretchedBoneName)
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
    }
    if(bIsGoreMesh && GoreManager != none)
    {
        GoreManager.CrushBone(self, StretchedBoneName);        
    }
    else
    {
        Mesh.HideBoneByName(StretchedBoneName, 1);
    }
    LogInternal("Linear constraint violated, hiding bone " @ string(StretchedBoneName));
}

function ResetHealthVisibilty()
{
    bShowHealth = false;
}

function CheckForNapalmInfect(KFPawn_Monster KFPM, byte DoTIndex, optional Controller InstigatedBy)
{
    local KFPerk InstigatorPerk;
    local KFPlayerController KFPC;

    if((InstigatedBy == none) && DoTIndex >= DamageOverTimeArray.Length)
    {
        return;
    }
    KFPC = ((InstigatedBy != none) ? KFPlayerController(InstigatedBy) : KFPlayerController(DamageOverTimeArray[DoTIndex].InstigatedBy));
    if(KFPC != none)
    {
        InstigatorPerk = KFPC.GetPerk();
        if((InstigatorPerk != none) && InstigatorPerk.CanSpreadNapalm())
        {
            KFPM.TakeDamage(10, KFPC, vect(0, 0, 0), vect(0, 0, 0), Class'KFDT_Fire');
            KFPM.bNapalmInfected = true;
        }
    }
}

function ShrapnelExplode(Controller Killer)
{
    local KFExplosionActorReplicated ExploActor;
    local Actor InstigatorActor;
    local GameExplosion ExplosionTemplate;

    if(Role < ROLE_Authority)
    {
        return;
    }
    InstigatorActor = ((Killer.Pawn != none) ? Killer.Pawn : Killer);
    ExploActor = Spawn(Class'KFExplosionActorReplicated', InstigatorActor,, Location,,, true);
    if(ExploActor != none)
    {
        ExploActor.InstigatorController = Killer;
        if(Killer.Pawn != none)
        {
            ExploActor.Instigator = Killer.Pawn;
        }
        ExplosionTemplate = Class'KFPerk_Firebug'.static.GetExplosionTemplate();
        ExploActor.Explode(ExplosionTemplate);
    }
}

function CauseHeadTrauma(optional float BleedOutTime)
{
    local KFPlayerController KFPC;
    local KFGameInfo KFGI;

    BleedOutTime = 5;
    if(!bIsHeadless)
    {
        KFPC = KFPlayerController(HitFxInstigator.Controller);
        KFGI = KFGameInfo(WorldInfo.Game);
        if((KFPC != none) && KFGI != none)
        {
            KFPC.AddZedHeadshot(byte(KFGI.GameDifficulty), HitFxInfo.DamageType);
            if((KFPC != none) && HitFxInfo.DamageType != none)
            {
                Class'EphemeralMatchStats'.static.RecordWeaponHeadShot(KFPC, HitFxInfo.DamageType);
            }
        }
    }
    if(!bIsHeadless && !bPlayedDeath)
    {
        if(((MyKFAIC != none) && KFGameInfo(WorldInfo.Game) != none) && MyKFAIC.TimeFirstSawPlayer >= float(0))
        {
            KFGameInfo(WorldInfo.Game).GameConductor.HandleZedKill(FMax(WorldInfo.TimeSeconds - MyKFAIC.TimeFirstSawPlayer, 0));
            MyKFAIC.TimeFirstSawPlayer = -1;
        }
        bPlayShambling = true;
        bIsHeadless = true;
        if(MyKFAIC != none)
        {
            MyKFAIC.SetSprintingDisabled(true);
        }
        bCanBeAdheredTo = false;
        bCanBeFrictionedTo = false;
        StopAkEventsOnBone('head');
        if(IsDoingSpecialMove() && Mesh.RootMotionMode == 3)
        {
            Died(LastHitBy, Class'DamageType', Location);            
        }
        else
        {
            if(bIsSprinting && FRand() < 0.25)
            {
                Knockdown(Velocity, vect(1, 1, 1));
            }
        }
        if(IsAliveAndWell() && MyKFAIC != none)
        {
            if((SpecialMove == 0) || !SpecialMoves[SpecialMove].bCanOnlyWanderAtEnd)
            {
                MyKFAIC.DoHeadlessWander();
            }
        }
        if(BleedOutTime > float(0))
        {
            SetTimer(BleedOutTime, false, 'BleedOutTimer');
        }
    }
}

function OnStackingAfflictionChanged(byte Id)
{
    local bool bShouldBeWandering, bWasWandering;

    bWasWandering = bPlayShambling || bPlayPanicked;
    bPlayShambling = bEmpPanicked || bIsHeadless;
    bPlayPanicked = (bFirePanicked || bIsPoisoned) || bMicrowavePanicked;
    bShouldBeWandering = bPlayShambling || bPlayPanicked;
    if(!bWasWandering && bShouldBeWandering)
    {
        CausePanicWander();        
    }
    else
    {
        if(bWasWandering)
        {
            EndPanicWander();
        }
    }
}

function CausePanicWander()
{
    if(!bIsHeadless && !bPlayedDeath)
    {
        if((SpecialMove != 0) && SpecialMoves[SpecialMove].bCanOnlyWanderAtEnd)
        {
            return;
        }
        if(MyKFAIC != none)
        {
            MyKFAIC.SetSprintingDisabled(true);
        }
        if(IsAliveAndWell() && MyKFAIC != none)
        {
            MyKFAIC.DoPanicWander();
        }
    }
}

function EndPanicWander()
{
    if(MyKFAIC != none)
    {
        MyKFAIC.SetSprintingDisabled(false);
    }
    if(IsAliveAndWell() && MyKFAIC != none)
    {
        MyKFAIC.EndPanicWander();
    }
}

simulated function bool ShouldBeWandering()
{
    return bPlayShambling || bPlayPanicked;
}

simulated function bool IsHeadless()
{
    return bIsHeadless;
}

simulated function bool IsImpaired()
{
    return (bPlayShambling || bPlayPanicked) || bEmpDisrupted;
}

simulated function UpdateGameplayMICParams()
{
    if(AfflictionHandler != none)
    {
        AfflictionHandler.ToggleEffects(6, bIsPoisoned);
        if(bIsGoreMesh)
        {
            AfflictionHandler.UpdateMaterialParameter(9, 0);
        }
    }
    super.UpdateGameplayMICParams();
}

function bool NotifyAttackParried(Pawn InstigatedBy, byte InParryStrength)
{
    if(InParryStrength < ParryResistance)
    {
        return false;
    }
    return super.NotifyAttackParried(InstigatedBy, InParryStrength);
}

function SetCloaked(bool bNewCloaking)
{
    if(bNewCloaking)
    {
        ClearBloodDecals();
    }
}

function CallOutCloaking(optional KFPlayerController CallOutController);

function MeleeSpecialMoveEnded();

function ANIMNOTIFY_Knockdown()
{
    if(SpecialMove == 10)
    {
        KFSM_Emerge(SpecialMoves[10]).bDoKnockdown = true;
    }
}

function NotifyAnimInterrupt(optional AnimNodeSequence SeqNode);

function msg(string MsgTxt)
{
    MessagePlayer(MsgTxt);
}

function float GetCircleStrafeDuration()
{
    return 0;
}

function float GetStepBackInCombatOdds()
{
    return 0.12;
}

function Pawn GetPawnToLookAt(optional bool bRequireLOS)
{
    local Pawn P;
    local array<Pawn> InterestingPawns;

    P = WorldInfo.PawnList;
    J0x29:

    if(P != none)
    {
        if(((P != self) && P.IsAliveAndWell()) && !bRequireLOS || LineOfSightTo(P))
        {
            InterestingPawns.AddItem(P;
        }
        P = P.NextPawn;
        goto J0x29;
    }
    if(InterestingPawns.Length > 0)
    {
        return InterestingPawns[Rand(InterestingPawns.Length)];
    }
    return none;
}

simulated function bool LookAtPawn(optional Pawn P, optional float Strength)
{
    Strength = 0.5;
    if(IK_Look_Head == none)
    {
        IK_Look_Head = SkelControlLookAt(Mesh.FindSkelControl('HeadLook'));
    }
    if(IK_Look_Head != none)
    {
        if(P == none)
        {
            P = GetPawnToLookAt(true);
        }
        if(P != none)
        {
            bIsHeadTrackingActive = true;
            if(MyKFAIC != none)
            {
                MyKFAIC.AILog_Internal(string(GetFuncName()) @ string(P), 'HeadTracking');
            }
            SetHeadTrackTarget(P, vect(0, 0, 1) * P.BaseEyeHeight, Strength, false);
            return true;
        }
    }
    return false;
}

simulated function StopLookingAtPawn(optional Pawn P)
{
    if((bCanHeadTrack && bIsHeadTrackingActive) && MyLookAtInfo.LookAtTarget != none)
    {
        if(P == none)
        {
            P = Pawn(MyLookAtInfo.LookAtTarget);
        }
        if(P != none)
        {
            if(MyKFAIC != none)
            {
                MyKFAIC.AILog_Internal(string(GetFuncName()) @ string(P), 'HeadTracking');
            }
            ClearHeadTrackTarget(P);
        }
    }
}

// Export UKFPawn_Monster::execSwitchToGoreMesh(FFrame&, void* const)
native final simulated function bool SwitchToGoreMesh();

simulated event NotifyGoreMeshActive()
{
    UpdateGameplayMICParams();
    if(SpecialMove != 0)
    {
        SpecialMoves[SpecialMove].OnGoreMeshSwap();
    }
}

simulated function GetClosestHitBones(int NumBones, Vector TestLocation, out array<name> OutHitBoneList)
{
    local int I;
    local array<name> SearchList;

    I = 0;
    J0x0B:

    if(I < Mesh.PhysicsAsset.BodySetup.Length)
    {
        SearchList.AddItem(Mesh.PhysicsAsset.BodySetup[I].BoneName;
        ++ I;
        goto J0x0B;
    }
    Mesh.FindClosestBones(TestLocation, NumBones, OutHitBoneList, SearchList);
}

simulated event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex)
{
    local int I;
    local KFGoreManager GoreManager;
    local RigidBodyContactInfo ContactInfo;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && (WorldInfo.TimeSeconds - LastGibCollisionTime) > GoreManager.GetTimeBetweenGibBloodSplats())
    {
        LastGibCollisionTime = WorldInfo.TimeSeconds;
        if(((OtherComponent != none) && OtherComponent.Owner != none) && !OtherComponent.Owner.IsA('KFPawn'))
        {
            SoundGroupArch.PlayRigidBodyCollisionSound(self, RigidCollisionData.ContactInfos[ContactIndex].ContactPosition);
            I = 0;
            J0x18C:

            if(I < RigidCollisionData.ContactInfos.Length)
            {
                ContactInfo = RigidCollisionData.ContactInfos[I];
                GoreManager.LeaveAPersistentBloodSplat(ContactInfo.ContactPosition, -ContactInfo.ContactNormal);
                ++ I;
                goto J0x18C;
            }
        }
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation)
{
    local class<KFDamageType> dmgType;
    local name HitZoneName, HitBoneName;
    local int HitZoneIndex;

    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitFxInfo.HitBoneIndex = 0;
    }
    dmgType = HitFxInfo.DamageType;
    HitZoneIndex = HitFxInfo.HitBoneIndex;
    if(HitZoneIndex != 255)
    {
        HitZoneName = HitZones[HitZoneIndex].ZoneName;
        HitBoneName = HitZones[HitZoneIndex].BoneName;
    }
    if(dmgType != none)
    {
        if(bTearOff && !bPlayedDeath)
        {
            PlayDying(HitDamageType, TakeHitLocation);
        }
        if(bPlayedDeath)
        {
            PlayDeadHitEffects(HitLocation, HitDirection, HitZoneIndex, HitZoneName, HitBoneName, dmgType);            
        }
        else
        {
            PlayLivingHitEffects(HitLocation, HitDirection, HitZoneIndex, HitZoneName, HitBoneName, dmgType);
        }
    }
    super.PlayTakeHitEffects(HitDirection, HitLocation);
}

simulated function PlayDeadHitEffects(Vector HitLocation, Vector HitDirection, int HitZoneIndex, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType)
{
    local class<KFProj_PinningBullet> PinProjectileClass;
    local KFPawn DeadPawn;
    local KFGoreManager GoreManager;
    local bool bIsDismemberingHit, bWasObliterated;

    if(bAllowRagdollAndGoreOnDeadBodies || (WorldInfo.TimeSeconds - TimeOfDeath) <= 3)
    {
        if(((InjuredHitZones & (1 << HitZoneIndex)) > 0) && !HitZones[HitZoneIndex].bPlayedInjury)
        {
            bIsDismemberingHit = PlayDismemberment(HitZoneIndex, dmgType, HitDirection);
            if(!bIsDismemberingHit && (InjuredHitZones & (1 << 0)) > 0)
            {
                PlayHeadAsplode();
                bIsDismemberingHit = true;
            }
        }
        GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
        if((GoreManager.AllowMutilation() && HitFxInfo.bObliterated) && (WorldInfo.TimeSeconds - TimeOfDeath) < 0.25)
        {
            bWasObliterated = true;
            bIsDismemberingHit = true;
            HandlePartialGoreAndGibs(dmgType, HitLocation, HitDirection, HitBoneName, true);
            GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
            GoreManager.SpawnObliterationBloodEffect(self);            
        }
        else
        {
            PinProjectileClass = dmgType.static.GetPinProjectileClass();
            if(PinProjectileClass != none)
            {
                DeadPawn = self;
                PinProjectileClass.static.CreatePin(DeadPawn, HitLocation, HitDirection, HitBoneName);
            }
            HandlePartialGoreAndGibs(dmgType, HitLocation, HitDirection, HitBoneName, false);
        }
        HandleRagdollImpulseEffects(HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, bIsDismemberingHit);
    }
    ApplyBloodDecals(HitZoneIndex, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, bIsDismemberingHit, bWasObliterated);
}

simulated function HandleRagdollImpulseEffects(Vector HitLocation, Vector HitDirection, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, bool bIsDismemberingHit)
{
    local Vector ImpulseDir, ParentImpulseDir;
    local float ImpulseScale, ParentImpulseScale;
    local name RBBoneName, HitBoneParentName;

    ImpulseDir = HitDirection;
    ParentImpulseDir = HitDirection;
    ImpulseScale = 1;
    ParentImpulseScale = 1;
    if(bIsDismemberingHit)
    {
        dmgType.static.ModifyDismembermentHitImpulse(self, HitZoneName, ImpulseDir, HitDirection, ParentImpulseDir, ImpulseScale, ParentImpulseScale);
    }
    if(HitBoneName != 'None')
    {
        RBBoneName = GetRBBoneFromBoneName(HitBoneName);
    }
    ApplyRagdollImpulse(dmgType, HitLocation, ImpulseDir, RBBoneName, ImpulseScale);
    if(bIsDismemberingHit && ParentImpulseScale > float(0))
    {
        HitBoneParentName = Mesh.GetParentBone(HitBoneName);
        if(((HitBoneName == 'head') || HitBoneParentName == 'neck') && dmgType != none)
        {
            ParentImpulseScale *= dmgType.default.HeadDestructionImpulseForceScale;
        }
        HitBoneParentName = GetRBBoneFromBoneName(HitBoneParentName);
        if((RBBoneName != HitBoneParentName) && Mesh.PhysicsAsset.FindBodyIndex(HitBoneParentName) != -1)
        {
            ApplyRagdollImpulse(dmgType, HitLocation, ParentImpulseDir, HitBoneParentName, ParentImpulseScale);
        }
    }
}

simulated function PlayLivingHitEffects(Vector HitLocation, Vector HitDirection, int HitZoneIndex, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType)
{
    if((!TryPlayHitReactionAnim(HitDirection, dmgType, byte(HitZoneIndex)) && PawnAnimInfo.bCanPlayPhysicsHitReactions) && ActorEffectIsRelevant(HitFxInstigator, false))
    {
        PlayPhysicsBodyImpact(HitLocation, HitDirection, dmgType, HitBoneName);
    }
    if((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).bNVAlwaysHeadshot)
    {
        HitZoneIndex = 0;
    }
    if(HitZoneIndex == 0)
    {
        if((Mesh.PhysicsWeight == 1) && bIsHeadless)
        {
            ApplyRagdollImpulse(dmgType, HitLocation, HitDirection, HeadBoneName, 1);
        }
        ApplyHeadChunkGore(dmgType, HitLocation, HitDirection);
    }
    ApplyBloodDecals(HitZoneIndex, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType, false, false);
}

simulated function PlayDyingSound()
{
    if(ClassIsChildOf(HitDamageType, Class'KFDT_Bleeding'))
    {
        SoundGroupArch.PlayBleedoutDyingSound(self);        
    }
    else
    {
        if(bHasBrokenConstraints && !HasMouth())
        {
            SoundGroupArch.PlayMouthlessDyingSound(self);            
        }
        else
        {
            super.PlayDyingSound();
        }
    }
}

simulated function PlayHitZoneGoreSounds(name HitBoneName, Vector HitLocation)
{
    if(SoundGroupArch.ShouldPlayCleaveSound(HitBoneName))
    {
        SoundGroupArch.PlayCleaveSound(self, HitLocation);        
    }
    else
    {
        SoundGroupArch.PlayDismembermentSounds(self, HitLocation);
    }
}

simulated function bool HeadBoneAlreadyBroken(name BoneName)
{
    if(BrokenHeadBones.Find(BoneName != -1)
    {
        return true;
    }
    return false;
}

simulated function AddBrokenHeadBone(name BoneName)
{
    if(BrokenHeadBones.Find(BoneName == -1)
    {
        BrokenHeadBones.AddItem(BoneName;
    }
    return;
}

simulated function bool ShouldAllowHeadBoneToBreak(name BoneName)
{
    if((!bPlayedDeath && !bIsHeadless) && !bTearOff)
    {
        if(NumHeadChunksRemoved >= MaxHeadChunkGoreWhileAlive)
        {
            return false;
        }
        if((((((BoneName == 'Gore_FrontL') && BrokenHeadBones.Find('Gore_FrontR' != -1) || (BoneName == 'Gore_FrontR') && BrokenHeadBones.Find('Gore_FrontL' != -1) || ((BoneName == 'Gore_BackL') && BrokenHeadBones.Find('gore_jaw' != -1) && BrokenHeadBones.Find('Gore_BackR' != -1) || ((BoneName == 'Gore_BackR') && BrokenHeadBones.Find('gore_jaw' != -1) && BrokenHeadBones.Find('Gore_BackL' != -1) || ((BoneName == 'gore_jaw') && BrokenHeadBones.Find('Gore_BackR' != -1) && BrokenHeadBones.Find('Gore_BackL' != -1)
        {
            return false;
        }
    }
    return true;
}

simulated function UpdateGoreChunkData(name BoneName)
{
    if((((BoneName == 'Gore_FrontL') || BoneName == 'Gore_FrontR') || BoneName == 'Gore_BackL') || BoneName == 'Gore_BackR')
    {
        ++ NumHeadChunksRemoved;
    }
}

simulated function bool ShouldAttachSkullChunk()
{
    return NumHeadChunksRemoved < 3;
}

simulated function bool ShouldDetachSkullChunk()
{
    return (NumHeadChunksRemoved >= 3) && (bPlayedDeath || bIsHeadless) || bTearOff;
}

simulated function HandleGoreChunkAttachments(name DismemberedBone)
{
    local int AttachmentIndex, ChunkRef;
    local editinline StaticMeshComponent AttachComp;
    local KFCharacterInfo_Monster MonsterInfo;
    local AttachedGoreChunkInfo ChunkInfo;
    local KFGoreChunkAttachmentInfo CurrentChunk;

    UpdateGoreChunkData(DismemberedBone);
    MonsterInfo = GetCharacterMonsterInfo();
    if(MonsterInfo != none)
    {
        AttachmentIndex = 0;
        J0x41:

        if(AttachmentIndex < MonsterInfo.GoreChunkAttachments.Length)
        {
            CurrentChunk = MonsterInfo.GoreChunkAttachments[AttachmentIndex];
            if(CurrentChunk.DismemberedBoneList.Find(DismemberedBone != -1)
            {
                ChunkRef = AttachedGoreChunks.Find('AttachmentIndex', AttachmentIndex;
                if(CurrentChunk.ShouldAttachGoreChunk(self) && ChunkRef == -1)
                {
                    AttachComp = new (self) Class'StaticMeshComponent';
                    AttachComp.SetStaticMesh(CurrentChunk.StaticMesh);
                    AttachComp.SetLightingChannels(PawnLightingChannel);
                    AttachComp.CastShadow = true;
                    AttachComp.bCastDynamicShadow = true;
                    AttachComp.bAllowPerObjectShadowBatching = true;
                    AttachComp.SetCullDistance(1000);
                    AttachComp.SetShadowParent(Mesh);
                    AttachComp.bAllowApproximateOcclusion = true;
                    AttachComp.SetTraceBlocking(false, false);
                    AttachComp.SetActorCollision(false, false);
                    Mesh.AttachComponentToSocket(AttachComp, CurrentChunk.SocketName);
                    ChunkInfo.AttachmentIndex = AttachmentIndex;
                    ChunkInfo.AttachedComponent = AttachComp;
                    AttachedGoreChunks.AddItem(ChunkInfo;                    
                }
                else
                {
                    if(CurrentChunk.ShouldDetachGoreChunk(self) && ChunkRef != -1)
                    {
                        AttachComp = AttachedGoreChunks[ChunkRef].AttachedComponent;
                        Mesh.DetachComponent(AttachComp);
                        AttachedGoreChunks.Remove(ChunkRef, 1;
                    }
                }
            }
            ++ AttachmentIndex;
            goto J0x41;
        }
    }
}

simulated function bool TryPlayHitReactionAnim(Vector HitDirection, class<KFDamageType> DamageType, byte HitZoneIdx)
{
    local KFPawn.EPawnOctant AnimDir;
    local KFPawnAnimInfo.EHitReactionAnimType HitReactionType;
    local KFAfflictionManager.EHitZoneBodyPart BodyPart;
    local bool bOnlyAdditiveHits;

    if((DamageType == none) || ActorTimeSince(NextHitReactionAnim_ActorTime) < float(0))
    {
        return false;
    }
    if(IsDoingSpecialMove())
    {
        bOnlyAdditiveHits = true;
        if(!SpecialMoves[SpecialMove].bAllowHitReactions)
        {
            return false;
        }
    }
    BodyPart = ((HitZoneIdx != 255) ? HitZones[HitZoneIdx].Limb : 0);
    HitReactionType = 0;
    bOnlyAdditiveHits = bOnlyAdditiveHits || VSizeSq(Velocity) > 50;
    if(!bOnlyAdditiveHits)
    {
        HitReactionType = AfflictionHandler.GetPredictedHitReaction(DamageType, BodyPart);
    }
    switch(BodyPart)
    {
        case 2:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 4;                
            }
            else
            {
                AnimDir = 6;
            }
            break;
        case 3:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            if(((AnimDir == 0) || AnimDir == 4) || AnimDir == 5)
            {
                AnimDir = 5;                
            }
            else
            {
                AnimDir = 7;
            }
            break;
        default:
            AnimDir = CalcOctagonRegion(Rotation, -HitDirection);
            break;
            break;
    }
    return PawnAnimInfo.PlayHitReactionAnim(self, HitReactionType, AnimDir);
}

simulated function ApplyBloodDecals(int HitZoneIndex, Vector HitLocation, Vector HitDirection, name HitZoneName, name HitBoneName, class<KFDamageType> dmgType, bool bIsDismemberingHit, bool bWasObliterated)
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(!bWasObliterated && !bIsCloaking)
        {
            GoreManager.LeaveABodyWoundDecal(self, HitLocation, HitDirection, HitZoneName, HitBoneName, dmgType);
        }
        if(dmgType.default.bShouldSpawnBloodSplat)
        {
            GoreManager.LeaveABloodSplatterDecal(self, HitLocation, HitDirection);
        }
        if(dmgType.default.bShouldSpawnPersistentBlood)
        {
            GoreManager.CausePersistentBlood(self, dmgType, HitLocation, HitDirection, HitZoneIndex, bIsDismemberingHit, bWasObliterated);
        }
    }
}

simulated function HandlePartialGoreAndGibs(class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection, name HitBoneName, bool ObliterateGibs)
{
    local KFGoreManager GoreManager;
    local KFCharacterInfo_Monster MonsterInfo;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(GoreManager.AllowMutilation())
        {
            if(!bIsGoreMesh)
            {
                SwitchToGoreMesh();
            }
            if(bIsGoreMesh)
            {
                MonsterInfo = GetCharacterMonsterInfo();
                if(ObliterateGibs)
                {
                    ApplyObliterationFxGore(GoreManager, MonsterInfo, dmgType);                    
                }
                else
                {
                    if(HitFxInfo.bRadialDamage)
                    {
                        ApplyRadialFxGore(GoreManager, MonsterInfo, dmgType);                        
                    }
                    else
                    {
                        ApplyTakeHitFxGore(GoreManager, MonsterInfo, dmgType, HitLocation, HitDirection, HitBoneName);
                    }
                }
            }
        }
    }
}

simulated function ApplyRadialFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType)
{
    local array<name> OutGibBoneList;
    local float NormalizedDistanceScale;
    local Vector ExplosionOrigin;
    local int NumGibs;

    if(dmgType.default.bCanGib)
    {
        ExplosionOrigin = HitFxRadialInfo.RadiusHurtOrigin;
        NormalizedDistanceScale = VSize(Location - ExplosionOrigin) / 1000;
        NumGibs = FCeil(FMax(1 - NormalizedDistanceScale, 0) * float(Rand(10))) + Rand(3);
        NumGibs *= MonsterInfo.ExplosionGibScale;
        GetClosestHitBones(NumGibs, ExplosionOrigin, OutGibBoneList);
        GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ExplosionOrigin, OutGibBoneList, MonsterInfo.ExplosionEffectTemplate, Mesh.GetBoneLocation(Mesh.GetBoneName(0)));
    }
}

simulated function ApplyObliterationFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType)
{
    local array<name> OutGibBoneList;
    local Vector ObliterationLocation;
    local int MaxNumGibs;

    MaxNumGibs = 100;
    if(dmgType.default.bCanGib)
    {
        if(HitFxInfo.bRadialDamage == true)
        {
            ObliterationLocation = HitFxRadialInfo.RadiusHurtOrigin;            
        }
        else
        {
            ObliterationLocation = self.Location;
        }
        GetClosestHitBones(MaxNumGibs, ObliterationLocation, OutGibBoneList);
        GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ObliterationLocation, OutGibBoneList, MonsterInfo.ExplosionEffectTemplate, Mesh.GetBoneLocation(Mesh.GetBoneName(0)));
    }
}

simulated function ApplyTakeHitFxGore(KFGoreManager GoreManager, KFCharacterInfo_Monster MonsterInfo, class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection, name HitBoneName)
{
    local array<name> OutGibBoneList;
    local int JointIndex, ExplosionBreakIdx, BoneIdx;
    local Vector ExplosionOrigin;
    local name GibBone;

    GoreManager.ConditionalApplyPartialGore(self, dmgType, HitLocation, HitDirection, HitBoneName);
    JointIndex = 0;
    J0x50:

    if(JointIndex < MonsterInfo.GoreJointSettings.Length)
    {
        if(MonsterInfo.GoreJointSettings[JointIndex].HitBoneName == HitBoneName)
        {
            ExplosionBreakIdx = 0;
            J0xD3:

            if(ExplosionBreakIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore.Length)
            {
                if(((MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Length == 0) || MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Find(0 != -1) || MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ConstrainToDamageGroups.Find(dmgType.default.GoreDamageGroup != -1)
                {
                    ExplosionOrigin = Mesh.GetBoneLocation(HitBoneName);
                    BoneIdx = 0;
                    J0x2B2:

                    if(BoneIdx < MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones.Length)
                    {
                        GibBone = MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].BreakBones[BoneIdx].BoneName;
                        if(!Mesh.IsBrokenConstraint(GibBone))
                        {
                            OutGibBoneList.AddItem(GibBone;
                        }
                        ++ BoneIdx;
                        goto J0x2B2;
                    }
                    GoreManager.CauseGibsAndApplyImpulse(self, dmgType, ExplosionOrigin, OutGibBoneList, MonsterInfo.GoreJointSettings[JointIndex].HitExplosionGore[ExplosionBreakIdx].ParticleSystemTemplate, ExplosionOrigin, HitBoneName);
                }
                ++ ExplosionBreakIdx;
                goto J0xD3;
            }
        }
        ++ JointIndex;
        goto J0x50;
    }
}

simulated function ApplyHeadChunkGore(class<KFDamageType> dmgType, Vector HitLocation, Vector HitDirection)
{
    local KFGoreManager GoreManager;

    if(bCanCloak && IsAliveAndWell())
    {
        return;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((dmgType != none) && GoreManager != none)
    {
        if(GoreManager.AllowMutilation())
        {
            if(!bIsGoreMesh)
            {
                SwitchToGoreMesh();
            }
            if(!bPlayedDeath)
            {
                dmgType = Class'KFDT_Ballistic';
                GoreManager.ConditionalApplyPartialGore(self, dmgType, HitLocation, HitDirection, HitZones[0].BoneName);
            }
        }
    }
}

simulated function HitZoneInjured(optional int HitZoneIdx)
{
    HitZoneIdx = -1;
    if((Role == ROLE_Authority) && HitZoneIdx != -1)
    {
        if(HitZoneIdx == 0)
        {
            CauseHeadTrauma();
        }
        InjuredHitZones = InjuredHitZones | (1 << HitZoneIdx);
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && !bTearOff && !bPlayedDeath)
    {
        if((InjuredHitZones & (1 << 0)) > 0)
        {
            if((WorldInfo.TimeSeconds - CreationTime) > 1)
            {
                PlayDismemberment(0, HitFxInfo.DamageType);
            }
            if(!HitZones[0].bPlayedInjury)
            {
                PlayHeadAsplode();
            }
        }
    }
}

simulated function PlayHeadAsplode()
{
    local KFGoreManager GoreManager;
    local name BoneName;

    if(HitZones[0].bPlayedInjury)
    {
        return;
    }
    if(((bTearOff || bPlayedDeath) && TimeOfDeath > float(0)) && (WorldInfo.TimeSeconds - TimeOfDeath) > 0.75)
    {
        return;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowHeadless())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
    }
    if(bIsGoreMesh && GoreManager != none)
    {
        BoneName = HitZones[0].BoneName;
        GoreManager.CrushBone(self, BoneName);
        SoundGroupArch.PlayHeadPopSounds(self, Mesh.GetBoneLocation(BoneName));
        HitZones[0].bPlayedInjury = true;
    }
}

simulated function bool PlayDismemberment(int InHitZoneIndex, class<KFDamageType> InDmgType, optional Vector HitDirection)
{
    local KFGoreManager GoreManager;
    local name BreakBoneName;

    if(HitZones[InHitZoneIndex].bPlayedInjury)
    {
        return false;
    }
    if(!InDmgType.static.CanDismemberHitZone(HitZones[InHitZoneIndex].ZoneName))
    {
        return false;
    }
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
    }
    if(bIsGoreMesh && GoreManager != none)
    {
        BreakBoneName = HitZones[InHitZoneIndex].BoneName;
        if((Health <= 0) && !IsZero(HitDirection))
        {
            InDmgType.static.GetBoneToDismember(self, HitDirection, HitZones[InHitZoneIndex].ZoneName, BreakBoneName);
        }
        GoreManager.CauseDismemberment(self, BreakBoneName, InDmgType);
        PlayHitZoneGoreSounds(BreakBoneName, Mesh.GetBoneLocation(BreakBoneName));
        HitZones[InHitZoneIndex].bPlayedInjury = true;
        if((Health > 0) && bHasBrokenConstraints)
        {
            InitPartialKinematics();
        }
        return true;
    }
    return false;
}

function TakeHitZoneDamage(float Damage, class<DamageType> DamageType, int HitZoneIdx, Vector InstigatorLocation)
{
    local float HeadHealthPercentage;

    super.TakeHitZoneDamage(Damage, DamageType, HitZoneIdx, InstigatorLocation);
    if((HitZones[HitZoneIdx].GoreHealth <= 0) && CanInjureHitZone(DamageType, HitZoneIdx))
    {
        HitZoneInjured(HitZoneIdx);
    }
    if(HitZoneIdx == 0)
    {
        if((!bPlayedDeath && !bIsHeadless) && !bTearOff)
        {
            HeadHealthPercentage = GetHeadHealthPercent();
            if(HeadHealthPercentage > 0.5)
            {
                MaxHeadChunkGoreWhileAlive = 1;                
            }
            else
            {
                if(HeadHealthPercentage > 0.25)
                {
                    MaxHeadChunkGoreWhileAlive = 2;                    
                }
                else
                {
                    if(HeadHealthPercentage > 0)
                    {
                        MaxHeadChunkGoreWhileAlive = 3;
                    }
                }
            }
        }
    }
}

function float GetHeadHealthPercent()
{
    local KFGameInfo KFGI;
    local float HeadHealth, HeadHealthMax, HealthMod, HeadHealthMod;

    HeadHealth = float(HitZones[0].GoreHealth);
    HeadHealthMax = float(default.HitZones[0].GoreHealth);
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.DifficultyInfo.GetAIHealthModifier(CharacterMonsterArch, KFGI.GameDifficulty, byte(KFGI.GetLivingPlayerCount()), HealthMod, HeadHealthMod);
        HeadHealthMax *= HeadHealthMod;
    }
    return HeadHealth / HeadHealthMax;
}

simulated function bool ShouldPlayHeadlessMeleeAnims()
{
    return bIsHeadless || bEmpPanicked;
}

simulated event bool HasMouth()
{
    if(!bHasBrokenConstraints)
    {
        return true;
    }
    return !Mesh.IsBrokenConstraint('head') && !Mesh.IsBoneHidden(Mesh.MatchRefBone('gore_jaw'));
}

simulated function ForceBreakAllConstraints()
{
    local int I;
    local KFGoreManager GoreManager;

    bHasBrokenConstraints = true;
    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if(GoreManager == none)
    {
        return;
    }
    if(GoreManager.AllowMutilation())
    {
        if(!bIsGoreMesh)
        {
            SwitchToGoreMesh();
        }
        I = 0;
        J0x94:

        if(I < CharacterMonsterArch.GoreJointSettings.Length)
        {
            if(!CharacterMonsterArch.GoreJointSettings[I].bNonBreakableJoint)
            {
                GoreManager.BreakConstraint(self, CharacterMonsterArch.GoreJointSettings[I].HitBoneName);
            }
            ++ I;
            goto J0x94;
        }
    }
}

function NotifyMeleeAttackFinished();

simulated function ChokePointTimer()
{
    if(!IsTimerActive('ChokePointTimer'))
    {
        SetTimer(0.3, true, 'ChokePointTimer', self);
    }
    if(CurrentChokePointTrigger != none)
    {
        if(CurrentChokePointTrigger.CanRestoreChokeCollision(self))
        {
            if((CylinderComponent.CollisionRadius < CylinderComponent.default.CollisionRadius) && !CheckEncroachingWorldGeometry())
            {
                SetChokePointCollision(false);
            }            
        }
        else
        {
            if(CylinderComponent.CollisionRadius > CurrentChokePointTrigger.MaxCollisionRadius)
            {
                SetChokePointCollision(true);
            }
        }        
    }
    else
    {
        if(!CheckEncroachingWorldGeometry())
        {
            if(CylinderComponent.CollisionRadius < CylinderComponent.default.CollisionRadius)
            {
                SetChokePointCollision(false);
            }
            ClearTimer('ChokePointTimer', self);
        }
    }
}

static function bool IsLargeZed()
{
    return default.bLargeZed;
}

static function bool IsABoss()
{
    return false;
}

simulated event UpdateSpottedStatus();

static function bool IsStalkerClass()
{
    return default.bIsStalkerClass;
}

static function bool IsCrawlerClass()
{
    return default.bIsCrawlerClass;
}

static function bool IsFleshpoundClass()
{
    return default.bIsFleshpoundClass;
}

static function bool IsBloatClass()
{
    return default.bIsBloatClass;
}

function float GetPerkDoTScaler(optional Controller InstigatedBy, optional class<KFDamageType> KFDT)
{
    local KFPlayerController KFPC;
    local KFPerk InstigatorPerk;
    local float DoTScaler;

    DoTScaler = 1;
    if(InstigatedBy != none)
    {
        KFPC = KFPlayerController(InstigatedBy);
        if(KFPC != none)
        {
            InstigatorPerk = KFPC.GetPerk();
            if(InstigatorPerk != none)
            {
                InstigatorPerk.ModifyDoTScaler(DoTScaler, KFDT);
            }
        }
    }
    return DoTScaler;
}

function SetDebugTextRendering(bool bTurnOn)
{
    local PlayerController PC;
    local KFHUDBase KFHud;

    bDebug_DrawOverheadInfo = bTurnOn;
    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        KFHud = KFHUDBase(PC.myHUD);        
    }    
    if(KFHud != none)
    {
        KFHud.SetPostRenderingFor(bTurnOn, self);
    }
}

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir)
{
    local KFHUDBase PCHUD;
    local bool bShowAllCategories;
    local Vector2D ScreenPos;

    PCHUD = KFHUDBase(PC.myHUD);
    if(PCHUD.ShouldDisplayDebug('All') || PCHUD.ShouldDisplayDebug('AllVerbose'))
    {
        bShowAllCategories = true;
    }
    if(MyKFAIC != none)
    {
        if((bShowAllCategories || PCHUD.ShouldDisplayDebug('AIMovement')) || PCHUD.ShouldDisplayDebug('AIPathing'))
        {
            MyKFAIC.DrawDebugOverheadMovementPhaseData(PCHUD, ScreenPos);
        }
        if(bShowAllCategories || PCHUD.ShouldDisplayDebug('BehaviorTree'))
        {
            MyKFAIC.DrawBehaviorTreeIconOverhead(PCHUD);
        }
    }
    if(((PC != none) && PC.myHUD != none) && bDebug_DrawOverheadInfo)
    {
        PCHUD = KFHUDBase(PC.myHUD);
        if(PCHUD != none)
        {
            DrawDebugOverheadText(PCHUD, ScreenPos);
        }        
    }
    else
    {
        if(((PC != none) && PC.myHUD != none) && bDebug_DrawSprintingOverheadInfo)
        {
            PCHUD = KFHUDBase(PC.myHUD);
            if(PCHUD != none)
            {
                DrawDebugOverheadSprintingText(PCHUD);
            }
        }
    }
}

function DrawDebugOverheadText(KFHUDBase HUD, out Vector2D ScreenPos)
{
    local Texture2D Icon;
    local PlayerController PC;
    local Canvas Canvas;
    local Vector CameraLoc, ScreenLoc;
    local Rotator CameraRot;
    local float X, Y, Dot;
    local array<string> OverheadTexts;
    local array<Color> OverheadColors;
    local int I;

    if(!IsAliveAndWell())
    {
        return;
    }
    Canvas = HUD.Canvas;
    ScreenLoc = Canvas.Project(Location + ((vect(0, 0, 1) * (GetCollisionHeight())) * 1.5));
    if(((ScreenLoc.X < float(0)) || ScreenLoc.X >= HUD.Canvas.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    PC = HUD.PlayerOwner;
    Canvas.SetDrawColor(0, 255, 64);
    OverheadColors[OverheadColors.Length] = MakeColor(0, 255, 64);
    PC.GetPlayerViewPoint(CameraLoc, CameraRot);
    Dot = vector(CameraRot) Dot (Location - CameraLoc);
    if(Dot < 0.5)
    {
        return;
    }
    Icon = Texture2D'S_AI';
    if(Icon != none)
    {
        Canvas.SetPos(ScreenLoc.X - float(Icon.SizeX / 2), ScreenLoc.Y - float(Icon.SizeY / 2), ScreenLoc.Z);
        Canvas.DrawTexture(Icon, 1);
        X = (ScreenLoc.X + float(Icon.SizeX / 2)) + float(5);
        Y = ScreenLoc.Y - float(Icon.SizeY / 2);        
    }
    else
    {
        X = ScreenLoc.X;
        Y = ScreenLoc.Y;
    }
    if((ScreenPos.X == float(0)) && ScreenPos.Y == float(0))
    {
        Canvas.SetPos(X, Y);        
    }
    else
    {
        Canvas.SetPos(ScreenPos.X, ScreenPos.Y);
    }
    Canvas.Font = Class'Engine'.static.GetSmallFont();
    GetOverheadDebugText(HUD, OverheadTexts, OverheadColors);
    if(MyKFAIC != none)
    {
        MyKFAIC.GetCommandStack(HUD, OverheadTexts, OverheadColors);
    }
    I = 0;
    J0x5F3:

    if(I < OverheadTexts.Length)
    {
        if(OverheadColors[I] != MakeColor(0, 0, 0, 0))
        {
            Canvas.SetDrawColor(OverheadColors[I].R, OverheadColors[I].G, OverheadColors[I].B, 255);            
        }
        else
        {
            Canvas.SetDrawColor(0, 255, 64, 255);
        }
        Canvas.DrawText(OverheadTexts[I]);
        ++ I;
        goto J0x5F3;
    }
    ScreenPos.X = Canvas.CurX;
    ScreenPos.Y = Canvas.CurY;
    if(HUD.ShouldDisplayDebug('AIMovement'))
    {
        DrawDebugSphere(Location - (vect(0, 0, 1) * ((GetCollisionHeight()) - MaxStepHeight)), 8, 10, 255, 255, 0, false);
        DrawDebugSphere(Location + (vect(0, 0, 1) * MaxJumpHeight), 15, 10, 0, 255, 0, false);
    }
}

function DrawDebugOverheadSprintingText(KFHUDBase HUD)
{
    local Texture2D moveTypeIcon;
    local PlayerController plyCtrl;
    local Canvas displayCanvas;
    local Vector plyCameraLoc, plyScreenLoc;
    local Rotator plyCameraRot;
    local string displayStr;
    local float displayX, displayY, infrontDOT;
    local Color newTextColor;

    if(!IsAliveAndWell())
    {
        return;
    }
    displayCanvas = HUD.Canvas;
    plyScreenLoc = displayCanvas.Project(Location + ((vect(0, 0, 1) * (GetCollisionHeight())) * 1.5));
    if(((plyScreenLoc.X < float(0)) || plyScreenLoc.X >= HUD.Canvas.ClipX) || (plyScreenLoc.Y < float(0)) && plyScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    plyCtrl = HUD.PlayerOwner;
    displayCanvas.SetDrawColor(255, 255, 255);
    plyCtrl.GetPlayerViewPoint(plyCameraLoc, plyCameraRot);
    infrontDOT = vector(plyCameraRot) Dot (Location - plyCameraLoc);
    if(infrontDOT < 0.5)
    {
        return;
    }
    if(bDebug_UseIconForShowingSprintingOverheadInfo)
    {
        if(bIsSprinting)
        {
            moveTypeIcon = MyKFAIC.MyAIDirector.GetDebugIsSprintingIcon();            
        }
        else
        {
            moveTypeIcon = MyKFAIC.MyAIDirector.GetDebugIsWalkingIcon();
        }        
    }
    else
    {
        moveTypeIcon = none;
        if(bIsSprinting)
        {
            displayStr = "S";
            newTextColor = Class'HUD'.default.RedColor;            
        }
        else
        {
            displayStr = "W";
            newTextColor = Class'HUD'.default.GreenColor;
        }
    }
    if(moveTypeIcon != none)
    {
        displayCanvas.SetPos(plyScreenLoc.X - float(moveTypeIcon.SizeX / 2), plyScreenLoc.Y - float(moveTypeIcon.SizeY / 2), plyScreenLoc.Z);
        displayCanvas.DrawTexture(moveTypeIcon, 1);
        displayX = (plyScreenLoc.X + float(moveTypeIcon.SizeX / 2)) + float(5);
        displayY = plyScreenLoc.Y - float(moveTypeIcon.SizeY / 2);        
    }
    else
    {
        displayX = plyScreenLoc.X - (GetCollisionRadius());
        displayY = plyScreenLoc.Y;
    }
    displayCanvas.SetPos(displayX, displayY);
    if(Len(displayStr) > 0)
    {
        displayCanvas.Font = MyKFAIC.MyAIDirector.GetAiDebugScreenLargeFont();
        Class'KFAIController'.static.DrawDebugText(HUD, displayStr, newTextColor);
    }
}

simulated function GetOverheadDebugText(KFHUDBase HUD, out array<string> OverheadTexts, out array<Color> OverheadColors)
{
    local string DebugText;
    local KFGameInfo KFGI;
    local float HealthMod, HeadHealthMod;
    local bool bShowAll, bShowAllVerbose;

    if(HUD.ShouldDisplayDebug('All'))
    {
        bShowAll = true;
    }
    if(HUD.ShouldDisplayDebug('AllVerbose'))
    {
        bShowAll = true;
        bShowAllVerbose = true;
    }
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.DifficultyInfo.GetAIHealthModifier(CharacterMonsterArch, KFGI.GameDifficulty, byte(KFGI.GetLivingPlayerCount()), HealthMod, HeadHealthMod);
        if(bShowAllVerbose || HUD.ShouldDisplayDebug('ZedHealthVerbose'))
        {
            DebugText = ((((((((((((((" Health: " $ string(Health)) $ " HeadHealth: ") $ string(HitZones[0].GoreHealth)) $ "
") $ " Starting Health: ") $ string(HealthMod * float(default.Health))) $ " Starting HeadHealth: ") $ string(HeadHealthMod * float(default.HitZones[0].GoreHealth))) $ "
") $ " Health Modifier: ") $ string(HealthMod)) $ " Default Health: ") $ string(default.Health)) $ " Default HeadHealth: ") $ string(default.HitZones[0].GoreHealth);            
        }
        else
        {
            if(bShowAll || HUD.ShouldDisplayDebug('ZedHealth'))
            {
                DebugText = ((((" Health: " $ string(Health)) $ " HeadHealth: ") $ string(HitZones[0].GoreHealth)) $ " HeadHealth %: ") $ string((float(HitZones[0].GoreHealth) / (HeadHealthMod * float(default.HitZones[0].GoreHealth))) * float(100));
            }
        }
    }
    OverheadTexts[OverheadTexts.Length] = DebugText;
    if(bShowAll || HUD.ShouldDisplayDebug('AITargeting'))
    {
        if(MyKFAIC != none)
        {
            DebugText = "---------- AI Targeting ----------
";
            if(MyKFAIC.Enemy != none)
            {
                DebugText = ((((DebugText @ "ENEMY: ") $ MyKFAIC.Enemy.GetHumanReadableName()) $ " Enemy Dist: ") $ string(VSize(MyKFAIC.Enemy.Location - Location))) $ "
";                
            }
            else
            {
                DebugText = (DebugText @ "ENEMY: NO Enemy ") $ "
";
            }
            if(MyKFAIC.Focus != none)
            {
                DebugText = ((DebugText @ "FOCUS: ") $ string(MyKFAIC.Focus)) $ "
";
                DrawDebugLine(Mesh.GetBoneLocation(HeadBoneName), MyKFAIC.Focus.Location, 255, 255, 0, false);
            }
            if(MyKFAIC.GetFocalPoint() != vect(0, 0, 0))
            {
                DrawDebugLine(Mesh.GetBoneLocation(HeadBoneName), MyKFAIC.GetFocalPoint(), 255, 255, 0, false);
            }
            OverheadTexts[OverheadTexts.Length] = DebugText;
        }
    }
    if(bShowAll || HUD.ShouldDisplayDebug('AIMovement'))
    {
        DebugText = "---------- AI MOVEMENT ----------
";
        DebugText = ((((((((((DebugText $ "Velocity: ") $ string(VSize(Velocity))) $ " X: ") $ string(Velocity.X)) $ " Y: ") $ string(Velocity.Y)) $ " Z: ") $ string(Velocity.Z)) $ " UU/S, ") $ string(VSize(Velocity) / float(100))) $ "
";
        DebugText = ((((((((((DebugText $ "Acceleration: ") $ string(VSize(Acceleration))) $ " X: ") $ string(Acceleration.X)) $ " Y: ") $ string(Acceleration.Y)) $ " Z: ") $ string(Acceleration.Z)) $ " Physics: ") $ (GetPhysicsName())) $ "
";
        DebugText = ((((((DebugText $ "SuperSpeed: ") $ string(IsUsingSuperSpeed())) $ " LastLOSOrRelevantTime: ") $ string(WorldInfo.TimeSeconds - LastLOSOrRelevantTime)) $ " LastRenderTime: ") $ string(WorldInfo.TimeSeconds - LastRenderTime)) $ "
";
        if(MyKFAIC != none)
        {
            if(MyKFAIC.bPreparingMove)
            {
                DebugText = (DebugText @ "bPreparingMove:") $ string(MyKFAIC.bPreparingMove);
            }
        }
        OverheadTexts[OverheadTexts.Length] = DebugText;
    }
}

function int GetKillerDialogID()
{
    return 65;
}

function int GetSpotterDialogID()
{
    return 125;
}

function UpdateDeadHorseStreak(bool bStillActive)
{
    if(bStillActive)
    {
        ++ DeadHorseHitStreakAmt;        
    }
    else
    {
        DeadHorseHitStreakAmt = 1;
    }
    LastDeadHorseHitTime = WorldInfo.TimeSeconds;
}

static function int GetTraderAdviceID()
{
    return -1;
}

function PlayLeapedDialog();

function PlayLandedDialog();

function MotivatePlayerToAttack(float Percentage, class<DamageType> AntiGriefDamageTypeClass)
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    if((PC != none) && (WorldInfo.TimeSeconds - LastAttackHumanWarningTime) > float(9))
    {
        PC.ReceiveLocalizedMessage(Class'KFLocalMessage_Priority', 14);
        LastAttackHumanWarningTime = WorldInfo.TimeSeconds;
    }
    TakeDamage(int(float(HealthMax) * 0.05), none, Location + (VRand() * 5), VRand(), AntiGriefDamageTypeClass);
}

function string GetLocalizedName()
{
    local string MonsterName;

    MonsterName = Localize("Zeds", string(LocalizationKey), "KFGame");
    return MonsterName;
}

// Export UKFPawn_Monster::execShouldGrandOnDeathAchievement(FFrame&, void* const)
protected native function bool ShouldGrandOnDeathAchievement();

// Export UKFPawn_Monster::execGetZedOnDeathAchievement(FFrame&, void* const)
protected native function int GetZedOnDeathAchievement();

// Export UKFPawn_Monster::execDisablebOnDeathAchivement(FFrame&, void* const)
native function DisablebOnDeathAchivement();

state Dying
{
    event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
    {
        local KFPawn_Human KFPH;

        super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
        if((InstigatedBy != none) && InstigatedBy.Pawn != none)
        {
            KFPH = KFPawn_Human(InstigatedBy.Pawn);
            if(KFPH != none)
            {
                if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
                {
                    KFGameInfo(WorldInfo.Game).DialogManager.PlayBeatDeadHorseDialog(KFPH, self);
                }
            }
        }
    }

    simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
    {
        local PlayerController PC;
        local Matrix HeadMatrix;
        local Vector HeadLoc;

        PC = GetALocalPlayerController();
        if(((PC != none) && !PC.IsSpectating()) && PC.ViewTarget == self)
        {
            HeadMatrix = Mesh.GetBoneMatrix(Mesh.MatchRefBone('head'));
            HeadLoc = MatrixGetOrigin(HeadMatrix);
            out_CamRot = RInterpTo(out_CamRot, rotator(HeadLoc - out_CamLoc), fDeltaTime, 10);
            return true;
        }
        return global.CalcCamera(fDeltaTime, out_CamLoc, out_CamRot, out_FOV);
    }
    stop;    
}

defaultproperties
{
    bCanMeleeAttack=true
    bDebug_UseIconForShowingSprintingOverheadInfo=true
    DifficultyDamageMod=1
    HeadlessBleedOutTime=5
    ParryResistance=1
    MinSpawnSquadSizeType=ESquadType.EST_Small
    begin object name=MeleeHelper class=KFMeleeHelperAI
        BaseDamage=6
        MaxHitRange=180
    object end
    // Reference: KFMeleeHelperAI'Default__KFPawn_Monster.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    WeakSpotSocketNames(0)=FX_Dazed
    LiveDamageTypeModifiers(0)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(1)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(2)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(3)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(4)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(5)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(6)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(7)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(8)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(9)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(10)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(11)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(12)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(13)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(14)=(DamageType=none,DamageScale=(1))
    LiveDamageTypeModifiers(15)=(DamageType=none,DamageScale=(1))
    ZedBumpDamageScale=1
    BlockingDamageModifier=0.4
    MeleeBlockingDamageModifier=0.15
    PlayerRallyBuffTime=10
    PlayerRallyBuffPowerBoostPct=1.2
    RandomGroundSpeedModifier=1
    MatchEnemySpeedAtDistance=200
    MinimumEnemySpeedToMatch=280
    PursuitSpeedScale=1
    ReachedEnemyThresholdScale=1
    BumpFrequency=0.5
    BumpDamageType=Class'KFDT_NPCBump'
    SpeedAdjustTransitionRate=100
    CollisionRadiusForReducedZedOnZedPinchPointCollisionState=1
    OnDeathAchievementID=-1
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_Monster.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bCanHeadTrack=true
    HitZones(0)=(ZoneName=head,BoneName=head,GoreHealth=20,DmgScale=1.1,Limb=EHitZoneBodyPart.BP_Head,SkinID=1,bPlayedInjury=false)
    HitZones(1)=(ZoneName=neck,BoneName=neck,GoreHealth=20,DmgScale=1,Limb=EHitZoneBodyPart.BP_Head,SkinID=0,bPlayedInjury=false)
    HitZones(2)=(ZoneName=chest,BoneName=Spine2,GoreHealth=150,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(3)=(ZoneName=heart,BoneName=Spine2,GoreHealth=150,DmgScale=1,Limb=EHitZoneBodyPart.BP_Special,SkinID=0,bPlayedInjury=false)
    HitZones(4)=(ZoneName=lupperarm,BoneName=LeftArm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(5)=(ZoneName=lforearm,BoneName=LeftForearm,GoreHealth=15,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(6)=(ZoneName=lhand,BoneName=LeftForearm,GoreHealth=20,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftArm,SkinID=0,bPlayedInjury=false)
    HitZones(7)=(ZoneName=rupperarm,BoneName=RightArm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(8)=(ZoneName=rforearm,BoneName=RightForearm,GoreHealth=15,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(9)=(ZoneName=rhand,BoneName=RightForearm,GoreHealth=20,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightArm,SkinID=0,bPlayedInjury=false)
    HitZones(10)=(ZoneName=stomach,BoneName=Spine1,GoreHealth=150,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(11)=(ZoneName=abdomen,BoneName=Hips,GoreHealth=150,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(12)=(ZoneName=lthigh,BoneName=LeftUpLeg,GoreHealth=75,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(13)=(ZoneName=lcalf,BoneName=LeftLeg,GoreHealth=25,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(14)=(ZoneName=lfoot,BoneName=LeftLeg,GoreHealth=15,DmgScale=1,Limb=EHitZoneBodyPart.BP_LeftLeg,SkinID=0,bPlayedInjury=false)
    HitZones(15)=(ZoneName=rthigh,BoneName=RightUpLeg,GoreHealth=75,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    HitZones(16)=(ZoneName=rcalf,BoneName=RightLeg,GoreHealth=25,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    HitZones(17)=(ZoneName=rfoot,BoneName=RightLeg,GoreHealth=15,DmgScale=1,Limb=EHitZoneBodyPart.BP_RightLeg,SkinID=0,bPlayedInjury=false)
    AfflictionHandler=KFAfflictionManager'Default__KFPawn_Monster.Afflictions'
    IncapSettings(0)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(1)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(2)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(3)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(4)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(5)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(6)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(7)=(Duration=5,Cooldown=0,Vulnerability=none)
    IncapSettings(8)=(Duration=5,Cooldown=5,Vulnerability=none)
    IncapSettings(9)=(Duration=5,Cooldown=5,Vulnerability=none)
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    ArmPhysicsBoneList(0)=RightShoulder
    ArmPhysicsBoneList(1)=RightArm
    ArmPhysicsBoneList(2)=RightForearm
    ArmPhysicsBoneList(3)=RightHand
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses(0)=none
        SpecialMoveClasses(1)=class'KFSM_MeleeAttack'
        SpecialMoveClasses(2)=class'KFSM_DoorMeleeAttack'
        SpecialMoveClasses(3)=class'KFSM_GrappleCombined'
        SpecialMoveClasses(4)=class'KFSM_Stumble'
        SpecialMoveClasses(5)=class'KFSM_RecoverFromRagdoll'
        SpecialMoveClasses(6)=class'KFSM_RagdollKnockdown'
        SpecialMoveClasses(7)=class'KFSM_DeathAnim'
        SpecialMoveClasses(8)=class'KFSM_Stunned'
        SpecialMoveClasses(9)=class'KFSM_Frozen'
        SpecialMoveClasses(10)=none
        SpecialMoveClasses(11)=none
        SpecialMoveClasses(12)=class'KFSM_Zed_Taunt'
        SpecialMoveClasses(13)=class'KFSM_Zed_WalkingTaunt'
        SpecialMoveClasses(14)=none
        SpecialMoveClasses(15)=none
        SpecialMoveClasses(16)=none
        SpecialMoveClasses(17)=none
        SpecialMoveClasses(18)=none
        SpecialMoveClasses(19)=none
        SpecialMoveClasses(20)=none
        SpecialMoveClasses(21)=none
        SpecialMoveClasses(22)=none
        SpecialMoveClasses(23)=none
        SpecialMoveClasses(24)=none
        SpecialMoveClasses(25)=none
        SpecialMoveClasses(26)=none
        SpecialMoveClasses(27)=class'KFSM_GrappleVictim'
        SpecialMoveClasses(28)=class'KFSM_HansGrappleVictim'
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_Monster.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_Monster.WeaponAmbientEchoHandler'
    FootstepAkComponent=AkComponent'Default__KFPawn_Monster.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_Monster.DialogAkSoundComponent'
    MaxTurningRadius=64
    AccelConvergeFalloffDistance=400
    HiddenGroundSpeed=600
    LedgeCheckThreshold=350
    bCanCrouch=false
    bCanStrafe=true
    bCanLeap=true
    bModifyReachSpecCost=true
    PathSearchType=EPathSearchType.PST_Constraint
    Alertness=1
    SightRadius=16384
    PeripheralVision=-1
    JumpZ=750
    ControllerClass=Class'KFAIController_Monster'
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        WireframeColor=(B=0,G=255,R=255,A=255)
        ReplacementPrimitive=none
        bUseAsOccluder=false
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_Monster.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_Monster.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        WireframeColor=(B=0,G=255,R=255,A=255)
        ReplacementPrimitive=none
        bUseAsOccluder=false
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Monster.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_Monster.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_Monster.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_Monster.DialogAkSoundComponent'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Monster.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}