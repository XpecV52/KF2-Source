/*******************************************************************************
 * KFTargetingWeaponComponent generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFTargetingWeaponComponent extends Actor
    abstract
    notplaceable
    hidecategories(Navigation);

const DEFAULT_FIREMODE = 0;
const ALTFIRE_FIREMODE = 1;

var KFWeapon KFW;
var byte TargetingEnabled[2];
var byte TargetZeds[2];
var byte TargetPlayers[2];
var float LockRange[2];
var float LockAcquireTime[2];
var float LockAcquireTime_Large[2];
var float LockAcquireTime_Boss[2];
var float LockAcquireTime_Versus[2];
var float LockTolerance[2];
var KFPawn LockedTarget;
var int LockedHitZone;
var KFPawn PendingLockedTarget;
var int PendingHitZone;
var float LockAim[2];
var float LockTargetingSoundInterval;
var AkBaseSoundObject LockAcquiredSoundFirstPerson;
var AkBaseSoundObject LockLostSoundFirstPerson;
var AkBaseSoundObject LockTargetingSoundFirstPerson;
var float PendingLockAcquireTimeLeft;
var float PendingLockTimeout;
var float LockedOnTimeout;
var Vector LockedAimLocation;
var array<name> HumanTargetableBoneNames;
var array<Vector> TargetVulnerableLocations;
var float TargetLocationReplicationInterval;
var bool bTargetingUpdated;

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    SetTickIsDisabled(true);
}

simulated function Init()
{
    KFW = KFWeapon(Owner);
    Instigator = KFW.Instigator;
}

simulated event Tick(float DeltaTime)
{
    super.Tick(DeltaTime);
    if(KFW == none)
    {
        KFW = KFWeapon(Owner);
        if(KFW == none)
        {
            return;
        }
        Instigator = KFW.Instigator;
    }
    if(Owner.bPendingDelete && !bPendingDelete)
    {
        Destroy();
        return;
    }
    if(((Instigator != none) && Instigator.Controller != none) && Instigator.IsLocallyControlled())
    {
        CheckTargetLock(DeltaTime);
    }
}

simulated function CheckTargetLock(float DeltaTime)
{
    local Actor BestTarget;

    bTargetingUpdated = false;
    if((((Instigator == none) || Instigator.Controller == none) || KFW != Instigator.Weapon) || KFPlayerController(Instigator.Controller) == none)
    {
        return;
    }
    TargetVulnerableLocations.Length = 0;
    if(!AllowTargetLockOn())
    {
        AdjustLockTarget(none);
        PendingLockedTarget = none;
        LockedAimLocation = vect(0, 0, 0);
        ClearTimer('PlayTargetingBeepTimer');
        return;
    }
    BestTarget = DetermineBestTarget();
    UpdateLockTargets(DeltaTime, BestTarget);
    SetupAimLock(DeltaTime);
    bTargetingUpdated = true;
}

simulated function bool AllowTargetLockOn()
{
    return (!Instigator.bNoWeaponFiring && KFW.bUsingSights) && TargetingIsEnabled();
}

simulated function AdjustLockTarget(KFPawn NewLockTarget)
{
    if(LockedTarget == NewLockTarget)
    {
        return;
    }
    if(NewLockTarget == none)
    {
        if(LockedTarget != none)
        {
            LockedTarget = none;
            TargetVulnerableLocations.Length = 0;
            LockedAimLocation = vect(0, 0, 0);
            ServerSetTargetingLocation(LockedAimLocation);
            if((Instigator != none) && Instigator.IsHumanControlled())
            {
                KFW.PlaySoundBase(LockLostSoundFirstPerson, true);
            }
        }        
    }
    else
    {
        LockedTarget = NewLockTarget;
        if((Instigator != none) && Instigator.IsHumanControlled())
        {
            KFW.PlaySoundBase(LockAcquiredSoundFirstPerson, true);
        }
    }
}

simulated function PlayTargetingBeepTimer()
{
    if((Instigator != none) && Instigator.IsHumanControlled())
    {
        KFW.PlaySoundBase(LockTargetingSoundFirstPerson, true);
    }
}

simulated function Actor PickTarget(Vector Aim, Vector StartTrace)
{
    local float bestAim, bestDist;

    bestAim = GetLockAim();
    bestDist = 0;
    return KFPlayerController(Instigator.Controller).GetPickedAimAtTarget(bestAim, bestDist, Aim, StartTrace, GetLockRange(), false);
}

simulated function Actor DetermineBestTarget()
{
    local Vector StartTrace;
    local Rotator ViewRotation;
    local Vector X, Y, Z;
    local Actor BestTarget, HitActor, TA;
    local Vector EndTrace, Aim, HitLocation, HitNormal;
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Instigator.Controller);
    StartTrace = Instigator.GetWeaponStartTraceLocation();
    ViewRotation = Instigator.GetViewRotation();
    ViewRotation += KFPC.WeaponBufferRotation;
    GetAxes(ViewRotation, X, Y, Z);
    BestTarget = none;
    Aim = vector(ViewRotation);
    EndTrace = StartTrace + (Aim * (GetLockRange()));
    HitActor = KFW.Trace(HitLocation, HitNormal, EndTrace, StartTrace, true,,, 1);
    if((HitActor == none) || !CanLockOnTo(HitActor))
    {
        TA = PickTarget(Aim, StartTrace);
        if((TA != none) && CanLockOnTo(TA))
        {
            HitActor = Trace(HitLocation, HitNormal, TA.Location, StartTrace, true,,, 1);
            if((KFFracturedMeshActor(HitActor) != none) || KFDestructibleActor(HitActor) != none)
            {
                BestTarget = none;                
            }
            else
            {
                BestTarget = TA;
            }
        }        
    }
    else
    {
        BestTarget = HitActor;
    }
    return BestTarget;
}

simulated function bool CanLockOnTo(Actor TA)
{
    local KFPawn PawnTarget;

    PawnTarget = KFPawn(TA);
    if((((((((TA == none) || !TA.bProjTarget) || TA.bDeleteMe) || PawnTarget == none) || TA == Instigator) || PawnTarget.Health <= 0) || !KFW.bUseAltFireMode && !KFW.HasAmmo(0)) || KFW.bUseAltFireMode && !KFW.HasAmmo(1))
    {
        return false;
    }
    return WorldInfo.GRI.OnSameTeam(Instigator, TA) == KFW.bUseAltFireMode;
}

simulated function UpdateLockTargets(float DeltaTime, Actor BestTarget)
{
    if(LockedTarget != none)
    {
        if(LockedTarget.bDeleteMe)
        {
            AdjustLockTarget(none);
        }
    }
    if(BestTarget != none)
    {
        if(BestTarget == LockedTarget)
        {
            UpdateTargetLocked();            
        }
        else
        {
            if(PendingLockedTarget != BestTarget)
            {
                UpdatePendingLockTarget(BestTarget);
            }
        }
        AcquireLockTarget(DeltaTime, BestTarget);        
    }
    else
    {
        TimeoutPendingLockTarget(DeltaTime);
    }
    TimeoutLockTarget(DeltaTime, BestTarget);
}

simulated function SetupAimLock(float DeltaTime)
{
    local Vector Aim, StartTrace, BestZoneLocation;
    local int OldHitZone;

    Aim = vector(Instigator.GetViewRotation());
    StartTrace = Instigator.GetWeaponStartTraceLocation();
    if(LockedTarget != none)
    {
        OldHitZone = LockedHitZone;
        LockedHitZone = AddTargetingZones(LockedTarget, StartTrace, Aim, BestZoneLocation);
        if(OldHitZone != LockedHitZone)
        {
            if((Instigator != none) && Instigator.IsHumanControlled())
            {
                KFW.PlaySoundBase(LockTargetingSoundFirstPerson, true);
            }
        }
        TargetLocationReplicationInterval -= DeltaTime;
        if((TargetLocationReplicationInterval <= float(0)) || IsZero(LockedAimLocation))
        {
            TargetLocationReplicationInterval = default.TargetLocationReplicationInterval;
            ServerSetTargetingLocation(LockedAimLocation);
        }
        LockedAimLocation = BestZoneLocation;        
    }
    else
    {
        LockedHitZone = -1;
    }
    if(PendingLockedTarget != none)
    {
        PendingHitZone = AddTargetingZones(PendingLockedTarget, StartTrace, Aim, BestZoneLocation);        
    }
    else
    {
        PendingHitZone = -1;
    }
}

simulated function int AddTargetingZones(KFPawn KFPTarget, Vector StartTrace, Vector Aim, out Vector BestZoneLocation)
{
    local KFPawn_Monster KFPM;
    local KFPawn_Human KFPH;

    KFPM = KFPawn_Monster(KFPTarget);
    if((CanTargetZeds()) && KFPM != none)
    {
        return GetZedVulnerableLocations(KFPM, Aim, StartTrace, BestZoneLocation);
    }
    KFPH = KFPawn_Human(KFPTarget);
    if((CanTargetPlayers()) && KFPH != none)
    {
        return GetHumanVulnerableLocations(KFPH, Aim, StartTrace, BestZoneLocation);
    }
    return -1;
}

simulated function int GetZedVulnerableLocations(KFPawn_Monster Zed, Vector Aim, Vector StartTrace, out Vector BestZoneLocation)
{
    local Vector ZoneLocation;
    local int BestZoneIndex;
    local float BestZoneDot;
    local Vector DirToZone;
    local float DotToZone;
    local int I;

    I = 0;
    J0x0B:

    if(I < Zed.WeakSpotSocketNames.Length)
    {
        Zed.Mesh.GetSocketWorldLocationAndRotation(Zed.WeakSpotSocketNames[I], ZoneLocation);
        if(!IsZero(ZoneLocation))
        {
            TargetVulnerableLocations.AddItem(ZoneLocation;
            DirToZone = ZoneLocation - StartTrace;
            DotToZone = Normal(Aim) Dot Normal(DirToZone);
            if(DotToZone > BestZoneDot)
            {
                BestZoneIndex = TargetVulnerableLocations.Length - 1;
                BestZoneDot = DotToZone;
                BestZoneLocation = ZoneLocation;
            }
        }
        ++ I;
        goto J0x0B;
    }
    return BestZoneIndex;
}

simulated function int GetHumanVulnerableLocations(KFPawn_Human Human, Vector Aim, Vector StartTrace, out Vector BestZoneLocation)
{
    local Vector ZoneLocation;
    local int BestZoneIndex;
    local float BestZoneDot;
    local Vector DirToZone;
    local float DotToZone;
    local int I;

    I = 0;
    J0x0B:

    if(I < HumanTargetableBoneNames.Length)
    {
        ZoneLocation = Human.Mesh.GetBoneLocation(HumanTargetableBoneNames[I]);
        if(!IsZero(ZoneLocation))
        {
            TargetVulnerableLocations.AddItem(ZoneLocation;
            DirToZone = ZoneLocation - StartTrace;
            DotToZone = Normal(Aim) Dot Normal(DirToZone);
            if(DotToZone > BestZoneDot)
            {
                BestZoneIndex = TargetVulnerableLocations.Length - 1;
                BestZoneDot = DotToZone;
                BestZoneLocation = ZoneLocation;
            }
        }
        ++ I;
        goto J0x0B;
    }
    return BestZoneIndex;
}

private reliable server final function ServerSetTargetingLocation(Vector NewTargetingLocation)
{
    LockedAimLocation = NewTargetingLocation;
}

simulated function TimeoutLockTarget(float DeltaTime, Actor BestTarget)
{
    if((LockedTarget != none) && BestTarget != LockedTarget)
    {
        LockedOnTimeout -= DeltaTime;
        if((LockedOnTimeout <= 0) || !CanLockOnTo(LockedTarget))
        {
            AdjustLockTarget(none);
        }
    }
}

simulated function TimeoutPendingLockTarget(float DeltaTime)
{
    if(PendingLockedTarget != none)
    {
        PendingLockTimeout -= DeltaTime;
        if((PendingLockTimeout <= float(0)) || !CanLockOnTo(PendingLockedTarget))
        {
            PendingLockedTarget = none;
            ClearTimer('PlayTargetingBeepTimer');
        }
    }
}

simulated function AcquireLockTarget(float DeltaTime, Actor BestTarget)
{
    if(PendingLockedTarget != none)
    {
        PendingLockAcquireTimeLeft -= DeltaTime;
        if((PendingLockedTarget == BestTarget) && PendingLockAcquireTimeLeft <= float(0))
        {
            AdjustLockTarget(PendingLockedTarget);
            PendingLockedTarget = none;
            ClearTimer('PlayTargetingBeepTimer');
        }
    }
}

simulated function UpdatePendingLockTarget(Actor BestTarget)
{
    local KFPawn_Monster KFP;
    local KFPawn_Human KFH;

    KFP = KFPawn_Monster(BestTarget);
    KFH = KFPawn_Human(BestTarget);
    if(((KFP != none) && CanTargetZeds()) || (KFH != none) && CanTargetPlayers())
    {
        PendingLockedTarget = KFPawn(BestTarget);
        PendingLockTimeout = GetLockTolerance();
        PendingLockAcquireTimeLeft = GetLockAcquireTime();
        if(KFP != none)
        {
            if(KFP.IsABoss())
            {
                PendingLockAcquireTimeLeft = GetLockAcquireTime_Boss();                
            }
            else
            {
                if(KFP.bVersusZed)
                {
                    PendingLockAcquireTimeLeft = GetLockAcquireTime_Versus();                    
                }
                else
                {
                    if(KFP.IsLargeZed())
                    {
                        PendingLockAcquireTimeLeft = GetLockAcquireTime_Large();
                    }
                }
            }
        }
        SetTimer(LockTargetingSoundInterval, true, 'PlayTargetingBeepTimer');
        if((Instigator != none) && Instigator.IsHumanControlled())
        {
            PlaySoundBase(LockTargetingSoundFirstPerson, true);
        }
    }
}

simulated function UpdateTargetLocked()
{
    LockedOnTimeout = GetLockTolerance();
    if(PendingLockedTarget != none)
    {
        ClearTimer('PlayTargetingBeepTimer');
        PendingLockedTarget = none;
    }
}

simulated function OnWeaponAttachedTo()
{
    SetTickIsDisabled(false);
}

simulated function OnWeaponDetached()
{
    SetTickIsDisabled(true);
}

simulated function bool TargetingIsEnabled()
{
    return TargetingEnabled[((KFW.bUseAltFireMode) ? 1 : 0)] == 1;
}

simulated function bool CanTargetZeds()
{
    return TargetZeds[((KFW.bUseAltFireMode) ? 1 : 0)] == 1;
}

simulated function bool CanTargetPlayers()
{
    return TargetPlayers[((KFW.bUseAltFireMode) ? 1 : 0)] == 1;
}

simulated function float GetLockRange()
{
    return LockRange[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockAim()
{
    return LockAim[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockAcquireTime()
{
    return LockAcquireTime[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockAcquireTime_Large()
{
    return LockAcquireTime_Large[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockAcquireTime_Boss()
{
    return LockAcquireTime_Boss[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockAcquireTime_Versus()
{
    return LockAcquireTime_Versus[((KFW.bUseAltFireMode) ? 1 : 0)];
}

simulated function float GetLockTolerance()
{
    return LockTolerance[((KFW.bUseAltFireMode) ? 1 : 0)];
}

defaultproperties
{
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bHidden=true
    bAlwaysRelevant=true
}