/*******************************************************************************
 * KFZedArmorInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFZedArmorInfo extends Object within KFPawn_Monster
    abstract;

const HeadBit = 0x1;
const FrontBit = 0x2;
const BackBit = 0x4;

struct ArmorZoneInfo
{
    /** List of zones of armor (similar to hit zones) */
    var() name ArmorZoneName;
    /** Name of the armor zone */
    var() name SocketName;
    /** Name of the socket explosion FX play from */
    var() int ArmorHealth;
    /** Amount of health the armor absorbs before it blows off */
    var() int ArmorHealthMax;
    /** Amount of health the armor absorbs before it blows off */
    var() ParticleSystem ExplosionTemplate;
    /** Amount of health the armor absorbs before it blows off */
    var() AkEvent ExplosionSFXTemplate;
    /** Amount of health the armor absorbs before it blows off */
    var() Texture2D ZoneIcon;

    structdefaultproperties
    {
        ArmorZoneName=None
        SocketName=None
        ArmorHealth=0
        ArmorHealthMax=0
        ExplosionTemplate=none
        ExplosionSFXTemplate=none
        ZoneIcon=none
    }
};

var array<name> ArmorHitzoneNames;
var array<ArmorZoneInfo> ArmorZones;
var float ArmorScale;

function InitArmor()
{
    local KFGameInfo KFGI;
    local float HealthMod, HeadHealthMod;
    local int I;

    KFGI = KFGameInfo(Outer.WorldInfo.Game);
    if(KFGI != none)
    {
        HealthMod = 1;
        HeadHealthMod = 1;
        KFGI.DifficultyInfo.GetAIHealthModifier(Outer, float(KFGI.GetModifiedGameDifficulty()), byte(KFGI.GetLivingPlayerCount()), HealthMod, HeadHealthMod);
        I = 0;
        J0x110:

        if(I < ArmorZones.Length)
        {
            ArmorZones[I].ArmorHealth *= HealthMod;
            ArmorZones[I].ArmorHealthMax = ArmorZones[I].ArmorHealth;
            Outer.RepArmorPct[I] = FloatToByte(float(ArmorZones[I].ArmorHealth) / float(ArmorZones[I].ArmorHealthMax));
            ++ I;
            goto J0x110;
        }
    }
    UpdateArmorUI();
}

function ExplodeArmor(int ArmorZoneIdx, name ArmorZoneName);

simulated function UpdateArmorPieces();

simulated function UpdateArmorUI();

function SetShieldScale(float InScale)
{
    local int I;

    ArmorScale = InScale;
    I = 0;
    J0x1E:

    if(I < ArmorZones.Length)
    {
        ArmorZones[I].ArmorHealth *= InScale;
        ArmorZones[I].ArmorHealthMax = ArmorZones[I].ArmorHealth;
        Outer.RepArmorPct[I] = FloatToByte(float(ArmorZones[I].ArmorHealth) / float(ArmorZones[I].ArmorHealthMax));
        ++ I;
        goto J0x1E;
    }
}

function AdjustBoneDamage(out int InDamage, name BoneName, Vector DamagerSource)
{
    local int HitZoneIdx, ArmorZoneIdx;
    local name IntendedArmorZoneName;
    local int ArmorDamage;

    HitZoneIdx = Outer.HitZones.Find('ZoneName', BoneName;
    if(HitZoneIdx >= 0)
    {
        ArmorZoneIdx = -1;
        if(ArmorHitzoneNames.Find(Outer.HitZones[HitZoneIdx].ZoneName != -1)
        {
            IntendedArmorZoneName = 'None';
            switch(Outer.HitZones[HitZoneIdx].ZoneName)
            {
                case 'head':
                    IntendedArmorZoneName = 'head';
                    break;
                default:
                    IntendedArmorZoneName = ((((DamagerSource - Outer.Location) Dot vector(Outer.Rotation)) > float(0)) ? 'Front' : 'back');
                    break;
                    break;
            }
            ArmorZoneIdx = ArmorZones.Find('ArmorZoneName', IntendedArmorZoneName;
        }
        if((ArmorZoneIdx != -1) && ArmorZones[ArmorZoneIdx].ArmorHealth > 0)
        {
            ArmorDamage = Clamp(InDamage, 0, ArmorZones[ArmorZoneIdx].ArmorHealth);
            InDamage -= ArmorDamage;
            ArmorZones[ArmorZoneIdx].ArmorHealth -= ArmorDamage;
            Outer.RepArmorPct[ArmorZoneIdx] = FloatToByte(float(ArmorZones[ArmorZoneIdx].ArmorHealth) / float(ArmorZones[ArmorZoneIdx].ArmorHealthMax));
            if(ArmorZones[ArmorZoneIdx].ArmorHealth <= 0)
            {
                Outer.ZedExplodeArmor(ArmorZoneIdx, IntendedArmorZoneName);
            }
            UpdateArmorUI();
        }
    }
}

function AdjustNonBoneDamage(out int InDamage)
{
    local int ValidArmorZones, ArmorReduction, ArmorRemainder, ArmorDamage, Idx;

    ValidArmorZones = 0;
    Idx = 0;
    J0x16:

    if(Idx < ArmorZones.Length)
    {
        if(ArmorZones[Idx].ArmorHealth > 0)
        {
            ++ ValidArmorZones;
        }
        ++ Idx;
        goto J0x16;
    }
    if(ValidArmorZones > 0)
    {
        ArmorReduction = InDamage / ValidArmorZones;
        ArmorRemainder = InDamage % ValidArmorZones;
        Idx = 0;
        J0xC9:

        if(Idx < ArmorZones.Length)
        {
            if(ArmorZones[Idx].ArmorHealth > 0)
            {
                ArmorDamage = Clamp(ArmorReduction, 0, ArmorZones[Idx].ArmorHealth);
                if(ArmorDamage < ArmorReduction)
                {
                    ArmorRemainder += (ArmorReduction - ArmorDamage);
                }
                InDamage -= ArmorDamage;
                ArmorZones[Idx].ArmorHealth -= ArmorDamage;
                Outer.RepArmorPct[Idx] = FloatToByte(float(ArmorZones[Idx].ArmorHealth) / float(ArmorZones[Idx].ArmorHealthMax));
                if(ArmorZones[Idx].ArmorHealth <= 0)
                {
                    Outer.ZedExplodeArmor(Idx, ArmorZones[Idx].ArmorZoneName);
                }
                UpdateArmorUI();
            }
            ++ Idx;
            goto J0xC9;
        }
        Idx = 0;
        J0x2E7:

        if((Idx < ArmorZones.Length) && ArmorRemainder > 0)
        {
            if(ArmorZones[Idx].ArmorHealth > 0)
            {
                ArmorDamage = Clamp(ArmorRemainder, 0, ArmorZones[Idx].ArmorHealth);
                InDamage -= ArmorDamage;
                ArmorRemainder -= ArmorDamage;
                ArmorZones[Idx].ArmorHealth -= ArmorDamage;
                Outer.RepArmorPct[Idx] = FloatToByte(float(ArmorZones[Idx].ArmorHealth) / float(ArmorZones[Idx].ArmorHealthMax));
                if(ArmorZones[Idx].ArmorHealth <= 0)
                {
                    Outer.ZedExplodeArmor(Idx, ArmorZones[Idx].ArmorZoneName);
                }
                UpdateArmorUI();
            }
            ++ Idx;
            goto J0x2E7;
        }
    }
}
