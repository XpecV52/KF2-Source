/*******************************************************************************
 * AICommand_Wander generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Wander extends AICommand within KFAIController;

var Vector WanderDestination;
var float MaxWanderDist;
var float WanderDuration;
var float RandomCoef;
var float WanderEnvelopeInner;
var float WanderWaitMin;
var float WanderWaitMax;
var Actor WanderGoal;
var bool bWanderAroundGoal;
var bool bCanUsePartialPath;
var bool bWasSprinting;

static function bool BeginWander(KFAIController AI, optional float InWanderDuration, optional Actor InWanderGoal, optional bool inWanderAroundGoal, optional float InMaxWanderDist)
{
    local AICommand_Wander Cmd;

    InMaxWanderDist = 10000;
    if(AI != none)
    {
        Cmd = new (AI) default.Class;
        if(Cmd != none)
        {
            Cmd.WanderDuration = InWanderDuration;
            Cmd.MaxWanderDist = InMaxWanderDist;
            Cmd.bWanderAroundGoal = inWanderAroundGoal;
            Cmd.WanderGoal = InWanderGoal;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    bWasSprinting = Outer.MyKFPawn.bIsSprinting;
    Outer.MyKFPawn.bIsSprinting = false;
    Outer.MyKFPawn.bCanUseHiddenSpeed = false;
    if(WanderDuration > 0)
    {
        Outer.SetTimer(WanderDuration, false, 'Timer_WanderDurationExpired', self);
    }
    Outer.Enemy = none;
    GotoState('Wandering');
}

function Paused(GameAICommand NewCommand)
{
    super.Paused(NewCommand);
    Outer.AIZeroMovementVariables(true);
    Outer.StopAllLatentMovement();
    Outer.MyKFPawn.bCanUseHiddenSpeed = Outer.MyKFPawn.default.bCanUseHiddenSpeed;
}

function Resumed(name OldCommandName)
{
    Outer.MyKFPawn.bIsSprinting = bWasSprinting;
    super.Resumed(OldCommandName);
    Outer.MyKFPawn.bCanUseHiddenSpeed = false;
}

function Popped()
{
    super.Popped();
    Outer.ClearTimer('Timer_WanderDurationExpired', self);
    Outer.AIZeroMovementVariables(true);
    Outer.StopAllLatentMovement();
    if(Outer.MyKFPawn != none)
    {
        Outer.MyKFPawn.bCanUseHiddenSpeed = Outer.MyKFPawn.default.bCanUseHiddenSpeed;
    }
}

function Timer_WanderDurationExpired()
{
    Status = 'Success';
    Outer.AIZeroMovementVariables(true);
    Outer.StopAllLatentMovement();
    Status = 'Success';
    Outer.PopCommand(self);
}

function Vector GetMoveDir()
{
    return (vector(Outer.Pawn.Rotation) / RandomCoef) + (RandomCoef * VRand());
}

function bool IsPawnVisibleViaTrace(Pawn PawnToCheck)
{
    local Vector TestLocation;
    local Rotator Rot;

    Rot = Outer.Pawn.Rotation;
    TestLocation = PawnToCheck.GetPawnViewLocation();
    Rot = rotator(PawnToCheck.Location - Outer.Pawn.Location);
    return (CanSeePawn(PawnToCheck)) && Outer.CanSeeByPoints(Outer.Pawn.Location, TestLocation, Rot);
}

function bool CanSeePawn(Pawn Seen)
{
    return true;
}

state Wandering
{
    function Actor GenerateWanderPath(Actor Goal, optional bool bAllowPartialPath)
    {
        local float DistToGoal;
        local Actor Ret;

        bCanUsePartialPath = bAllowPartialPath;
        if(Goal == none)
        {
            return none;
        }
        DistToGoal = VSize(Outer.Pawn.Location - Goal.Location);
        if(bWanderAroundGoal && VSize(Goal.Location - Outer.Pawn.Location) < MaxWanderDist)
        {
            Class'Path_AlongLine'.static.AlongLine(Outer.Pawn, -Normal(Goal.Location - Outer.Pawn.Location));
            Class'Path_WithinTraversalDist'.static.DontExceedMaxDist(Outer.Pawn, MaxWanderDist, false);
            Class'Goal_Random'.static.FindRandom(Outer.Pawn, 1024, -1);            
        }
        else
        {
            Class'Path_TowardGoal'.static.TowardGoal(Outer.Pawn, Goal);
            Class'Path_WithinTraversalDist'.static.DontExceedMaxDist(Outer.Pawn, MaxWanderDist, false);
            Class'Path_WithinDistanceEnvelope'.static.StayWithinEnvelopeToLoc(Outer.Pawn, Goal.Location, MaxWanderDist, float(Min(int(DistToGoal), int(WanderEnvelopeInner))), false,, true);
            Class'Goal_Null'.static.GoUntilBust(Outer.Pawn, 1024);
        }
        Ret = Outer.FindPathToward(Goal,,, bAllowPartialPath);
        Outer.Pawn.ClearConstraints();
        return Ret;
    }

    function bool Wander()
    {
        local Actor Path;

        Outer.RouteGoal = none;
        Path = none;
        Path = GenerateWanderPath(WanderGoal, true);
        if(Path != none)
        {
            return true;
        }
        return false;
    }
Begin:

    if(WanderGoal == none)
    {
        if(Outer.SuggestNewWanderPoint(WanderDestination, GetMoveDir(), MaxWanderDist))
        {
            Outer.SetMovePoint(WanderDestination,, false, 128, false);
        }
        Outer.Sleep(1 + (float(2) * FRand()));
        goto 'Begin';
    }
    Outer.AILog_Internal("Wandering toward enemy...");
    if(!Wander())
    {
        Outer.AILog_Internal("Failed to find Wander location for " $ string(Outer.Enemy));
        Outer.Sleep(1.5);
        goto 'Begin';        
    }
    else
    {
        if(Outer.RouteGoal != none)
        {
            Outer.SetMoveGoal(Outer.RouteGoal,, false, 128, true,,,, bCanUsePartialPath);
            Outer.Sleep(RandRange(WanderWaitMin, WanderWaitMax));
            goto 'FinishedMove';
        }
    }
    Outer.Sleep(0);
    goto 'Begin';
FinishedMove:


    Outer.AILog_Internal("Done Wandering");
    Outer.AILog_Internal("Enemy was visible, rotating toward him");
    Outer.AILog_Internal("Finished rotating, waiting a bit to let our driver pwn his arse");
    Outer.Sleep(RandRange(WanderWaitMin, WanderWaitMax));
    goto 'Begin';
    stop;            
}

defaultproperties
{
    MaxWanderDist=10000
    RandomCoef=1.05
    WanderEnvelopeInner=1500
    WanderWaitMin=0.25
    WanderWaitMax=1.33
}