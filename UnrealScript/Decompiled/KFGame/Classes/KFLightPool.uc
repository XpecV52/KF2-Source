/*******************************************************************************
 * KFLightPool generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFLightPool extends Actor
    native(Effect)
    notplaceable
    hidecategories(Navigation);

enum LightPoolPriority
{
    LPP_Low,
    LPP_High,
    LPP_GameplayUsed,
    LPP_MAX
};

struct native LightPoolInfo
{
    var export editinline PointLightComponent Component;
    var int Priority;
    var bool bAllowReenable;

    structdefaultproperties
    {
        Component=none
        Priority=0
        bAllowReenable=false
    }
};

var private array<LightPoolInfo> ActiveComponents;
/** maximum allowed active components */
var() int MaxOnScreenLights;
var transient int CurrentOnScreenLights;
var transient int CurrentLowestPriority;

event PreBeginPlay()
{
    switch(WorldInfo.GetDetailMode())
    {
        case 0:
            MaxOnScreenLights = 5;
            break;
        case 1:
            MaxOnScreenLights = 10;
            break;
        case 2:
            MaxOnScreenLights = 20;
            break;
        default:
            break;
    }
    super.PreBeginPlay();
}

function bool RegisterPointLight(PointLightComponent LightComp, optional KFLightPool.LightPoolPriority PriorityType, optional bool bForceAllowReenable)
{
    local LightPoolInfo NewLight;
    local int I;

    PriorityType = 0;    
    if((LightComp.Owner == none) || !LightComp.bAttached)
    {
        LogInternal(string(GetFuncName()) @ "failed because light has not been attached");
        LightComp.SetEnabled(false);
        return false;
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        LogInternal((string(GetFuncName()) @ "perf warning: dedicated server shouldn't be playing with lights on") @ string(LightComp.Owner));
        LightComp.DetachFromAny();
        return false;
    }
    if(!LightComp.bEnabled && bForceAllowReenable)
    {
        LogInternal(string(GetFuncName()) @ "failed because bEnabled == FALSE.  Unsupported with bForceAllowReenable");
        LightComp.DetachFromAny();
        return false;
    }
    NewLight.Component = LightComp;
    NewLight.Priority = 100 * PriorityType;
    NewLight.bAllowReenable = LightComp.bEnabled && ((Owner.LifeSpan == float(0)) || PriorityType == 2) || bForceAllowReenable;
    if((LightComp.Owner.Instigator != none) && LightComp.Owner.Instigator.IsLocallyControlled())
    {
        NewLight.Priority += int(50);
    }
    if((CurrentOnScreenLights >= MaxOnScreenLights) && NewLight.Priority < CurrentLowestPriority)
    {
        if(bDebug)
        {
            LogInternal((((((string(GetFuncName()) @ "disabling incoming light for Owner:") $ string(LightComp.Owner)) @ "Priority:") $ string(NewLight.Priority)) @ "Total:") $ string(ActiveComponents.Length));
        }
        LightComp.SetEnabled(false);
        if(!NewLight.bAllowReenable)
        {
            LightComp.DetachFromAny();
            return false;
        }
    }
    I = 0;
    J0x502:

    if(I < ActiveComponents.Length)
    {
        if(ActiveComponents[I].Priority > NewLight.Priority)
        {
            goto J0x572;
        }
        ++ I;
        goto J0x502;
    }
    J0x572:

    if(bDebug)
    {
        LogInternal((((((string(GetFuncName()) @ "adding light for Owner:") $ string(LightComp.Owner)) @ "Priority:") $ string(NewLight.Priority)) @ "Total:") $ string(ActiveComponents.Length));
    }
    ActiveComponents.InsertItem(I, NewLight;
    SetTickIsDisabled(false);
    return true;
}

defaultproperties
{
    MaxOnScreenLights=20
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bTickIsDisabled=true
}