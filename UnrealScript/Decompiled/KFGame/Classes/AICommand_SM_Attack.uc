/*******************************************************************************
 * AICommand_SM_Attack generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_SM_Attack extends AICommand_SpecialMove within KFAIController
    abstract
    native(AI);

var KFPawn.ESpecialMove AttackSpecialMove;
var byte SMFlags;
var Actor AttackTarget;
var bool bSingleAttack;
var bool bCanBeAborted;
var bool bAttackAborted;
var bool bLockDownAI;
var bool bZeroPawnAccelWhenPopped;
var bool bFinishRotationBeforeAttack;
var float PostSpecialMoveSleepTime;
var float PostSpecialMoveAbortedSleepTime;
var protected float TimePlayed;

function Pushed()
{
    super.Pushed();
    if(bLockDownAI)
    {
        LockdownAI();
    }
    Outer.DisableMeleeRangeEventProbing();
    GotoState(DefaultStartState);
}

function Paused(GameAICommand NewCommand)
{
    super(AICommand).Paused(NewCommand);
}

function Popped()
{
    if(!Outer.bHasDebugCommand)
    {
        Outer.ResetProbingMeleeRangeEvents();
    }
    if(bLockDownAI)
    {
        UnlockAI();
    }
    if(bZeroPawnAccelWhenPopped && Outer.MyKFPawn != none)
    {
        Outer.MyKFPawn.Acceleration = vect(0, 0, 0);
    }
    super.Popped();
}

function bool AllowTransitionTo(class<GameAICommand> AttemptCommand)
{
    Outer.AILog_Internal(((string(self) $ " AllowTransitionTo: ") $ string(AttemptCommand)) $ " called", 'Command_Attack');
    if(ChildCommand != none)
    {
        return ChildCommand.AllowTransitionTo(AttemptCommand);
    }
    return IsSpecialMoveComplete();
}

function bool ShouldSelectTarget()
{
    Outer.AILog_Internal(((string(self) $ " ") $ string(GetFuncName())) $ "() returning false", 'Command_Attack');
    return false;
}

function bool ShouldIgnoreTimeTransitions()
{
    Outer.AILog_Internal(string(GetFuncName()) $ " returning TRUE - ignoring time transitions", 'Command_Attack');
    return true;
}

function KFPawn.ESpecialMove GetSpecialMove()
{
    return AttackSpecialMove;
}

function bool IsSpecialMoveComplete()
{
    return true;
}

state Command_SpecialMove
{
    function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(!Outer.bHasDebugCommand)
        {
            if((AttackTarget != none) && AttackTarget != Outer.Pawn)
            {
                Outer.Focus = AttackTarget;
                Outer.SetDesiredRotation(rotator(AttackTarget.Location - Outer.Pawn.Location));                
            }
            else
            {
                if(Outer.Enemy != none)
                {
                    Outer.Focus = Outer.Enemy;
                }
            }
        }
        TimePlayed = 0;
    }

    function bool ShouldFinishRotation()
    {
        return bFinishRotationBeforeAttack;
    }

    function KFPawn.ESpecialMove GetSpecialMove()
    {
        return AttackSpecialMove;
    }

    function float GetPostSpecialMoveSleepTime()
    {
        if(bAttackAborted)
        {
            return PostSpecialMoveAbortedSleepTime;            
        }
        else
        {
            return PostSpecialMoveSleepTime;
        }
    }

    function bool IsSpecialMoveComplete()
    {
        if(((Outer.MyKFPawn == none) || !Outer.MyKFPawn.IsAliveAndWell()) || !Outer.MyKFPawn.IsDoingSpecialMove(GetSpecialMove()))
        {
            return true;
        }
        return super.IsSpecialMoveComplete();
    }

    function FinishedSpecialMove()
    {
        Status = 'Success';
        super.FinishedSpecialMove();
    }
    stop;    
}

defaultproperties
{
    AttackSpecialMove=ESpecialMove.SM_MeleeAttack
    bSingleAttack=true
    bLockDownAI=true
    bIgnoreNotifies=true
}