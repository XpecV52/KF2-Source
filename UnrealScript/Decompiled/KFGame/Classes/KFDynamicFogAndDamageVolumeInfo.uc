/*******************************************************************************
 * KFDynamicFogAndDamageVolumeInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDynamicFogAndDamageVolumeInfo extends FogVolumeConstantDensityInfo
    hidecategories(Navigation,Collision)
    autoexpandcategories(FogVolumeDensityInfo);

/** This property allows the fog volume to damage a player as long as they are within it. Using a negative value will allow the volume to have a regenerative effect. NB. bPainCausing must be set to TRUE to activate this */
var() float DamagePerSec;
/** When damage is applied to an object, it is done so using a specific DamageType. Each available DamageType has a KDamageImpulse property which controls the magnitude of the impulse to be applied along the momentum vector. */
var() class<DamageType> DamageType<AllowAbstract=>;
/** This property activates the ability to cause damage. Used in conjunction with DamagePerSecond and PainInterval */
var() bool bPainCausing;
/** True if this volume should damage zeds */
var() bool bDamageZeds;
var bool bBlendingFogIn;
var bool bBlendingFogOut;
var bool bOldEnabled;
/** Amount of time, in seconds, between damage applications. NB. bPainCausing must be set to TRUE to activate this */
var() float PainInterval;
/** How long to take to blend fog in/out. Note: Damage blends in/out with the fading */
var() float FogBlendTime;
var float FogBlendTimeRemaining;
var repnotify byte FogBlendAmountRep;
var float InitialDensity;
var float CurrentDensity;
/** Temp message to play when this volume activates */
var() string ActivateMessage;
/** Temp message to play when this volume deactivates */
var() string DeactivateMessage;

replication
{
     if(Role == ROLE_Authority)
        FogBlendAmountRep;
}

simulated event PostBeginPlay()
{
    super(FogVolumeDensityInfo).PostBeginPlay();
    InitialDensity = FogVolumeConstantDensityComponent(DensityComponent).Density;
    CurrentDensity = InitialDensity;
    if(!bEnabled)
    {
        FogVolumeConstantDensityComponent(DensityComponent).Density = 0;
        ReattachComponent(DensityComponent);
    }
    if(Role < ROLE_Authority)
    {
        return;
    }
    if(bPainCausing)
    {
        SetTimer(PainInterval, true, 'TimerPop');
    }
}

simulated event ReplicatedEvent(name VarName)
{
    local float BlendedFogAmount;

    if(VarName == 'FogBlendAmountRep')
    {
        BlendedFogAmount = float(FogBlendAmountRep) / 255;
        SetFogDensity(BlendedFogAmount);        
    }
    else
    {
        if(VarName != 'bEnabled')
        {
            super(FogVolumeDensityInfo).ReplicatedEvent(VarName);
        }
    }
}

simulated function OnToggle(SeqAct_Toggle Action)
{
    if(Action.InputLinks[0].bHasImpulse)
    {
        StartBlendIn();        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            StartBlendOut();            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                if(bEnabled)
                {
                    StartBlendOut();                    
                }
                else
                {
                    StartBlendIn();
                }
            }
        }
    }
}

simulated function SetFogDensity(float NewDensity)
{
    if(Role < ROLE_Authority)
    {
        if(NewDensity == float(0))
        {
            if(bOldEnabled)
            {
                DeActivate();
            }            
        }
        else
        {
            if(!bOldEnabled)
            {
                Activate();
            }
        }
    }
    FogVolumeConstantDensityComponent(DensityComponent).Density = NewDensity * InitialDensity;
    CurrentDensity = FogVolumeConstantDensityComponent(DensityComponent).Density;
    if(Role == ROLE_Authority)
    {
        FogBlendAmountRep = byte((CurrentDensity / InitialDensity) * float(255));
        bNetDirty = true;
        bForceNetUpdate = true;
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        ReattachComponent(DensityComponent);
    }
}

event Tick(float DeltaTime)
{
    if(Role < ROLE_Authority)
    {
        return;
    }
    if(bBlendingFogIn)
    {
        FogBlendTimeRemaining -= DeltaTime;
        if(FogBlendTimeRemaining <= float(0))
        {
            SetFogDensity(1);
            bBlendingFogIn = false;            
        }
        else
        {
            SetFogDensity(1 - (FogBlendTimeRemaining / FogBlendTime));
        }        
    }
    else
    {
        if(bBlendingFogOut)
        {
            FogBlendTimeRemaining -= DeltaTime;
            if(FogBlendTimeRemaining <= float(0))
            {
                SetFogDensity(0);
                bBlendingFogOut = false;
                DeActivate();                
            }
            else
            {
                SetFogDensity(FogBlendTimeRemaining / FogBlendTime);
            }
        }
    }
}

event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    super(Actor).Touch(Other, OtherComp, HitLocation, HitNormal);
    if((Other == none) || Other.bStatic)
    {
        return;
    }
    if(bPainCausing)
    {
        if(Other.bCanBeDamaged)
        {
            if(bEnabled)
            {
                CausePainTo(Other);
            }
        }
    }
}

function CausePainTo(Actor Other)
{
    if(!bDamageZeds && KFPawn_Monster(Other) != none)
    {
        return;
    }
    if(DamagePerSec > float(0))
    {
        if((DamageType == none) || DamageType == Class'DamageType')
        {
            LogInternal((("No valid damagetype (" $ string(DamageType)) $ ") specified for ") $ PathName(self));
        }
        Other.TakeDamage(int((DamagePerSec * PainInterval) * (CurrentDensity / InitialDensity)), none, Location, vect(0, 0, 1), DamageType,, self);        
    }
    else
    {
        Other.HealDamage(int((-DamagePerSec * PainInterval) * (CurrentDensity / InitialDensity)), none, DamageType);
    }
}

function TimerPop()
{
    local Actor A;

    if(!bEnabled)
    {
        return;
    }
    if(!bPainCausing)
    {
        return;
    }
    foreach TouchingActors(Class'Actor', A)
    {
        if(A.bCanBeDamaged && !A.bStatic)
        {
            CausePainTo(A);
        }        
    }    
}

simulated function Activate()
{
    SetEnabled(true);
    TempMessagePlayers(ActivateMessage);
}

simulated function DeActivate()
{
    if(bEnabled)
    {
        TempMessagePlayers(DeactivateMessage);
    }
    SetEnabled(false);
}

simulated function StartBlendIn()
{
    Activate();
    bBlendingFogIn = true;
    bBlendingFogOut = false;
    FogBlendTimeRemaining = FogBlendTime;
}

simulated function StartBlendOut()
{
    if(bEnabled)
    {
        bBlendingFogOut = true;
        bBlendingFogIn = false;
        FogBlendTimeRemaining = FogBlendTime;
    }
}

simulated function SetEnabled(bool bNewEnabled)
{
    DensityComponent.super(KFDynamicFogAndDamageVolumeInfo).SetEnabled(bNewEnabled);
    bEnabled = DensityComponent.bEnabled;
    bOldEnabled = bEnabled;
    ForceNetRelevant();
    SetForcedInitialReplicatedProperty(BoolProperty'bEnabled', bEnabled == default.bEnabled);
    NetUpdateFrequency = 5;
}

simulated function TempMessagePlayers(coerce string msg)
{
    local KFPlayerController KFPC;

    LogInternal(("!!!!" @ msg) @ "!!!!");
    foreach LocalPlayerControllers(Class'KFPlayerController', KFPC)
    {
        KFPC.myGfxHUD.ShowNonCriticalMessage(msg);        
    }    
}

defaultproperties
{
    DamageType=Class'Engine.DamageType'
    PainInterval=1
    FogBlendTime=3
    DensityComponent=FogVolumeConstantDensityComponent'Default__KFDynamicFogAndDamageVolumeInfo.FogVolumeComponent0'
    begin object name=AutomaticMeshComponent0 class=StaticMeshComponent
        ReplacementPrimitive=none
        BlockActors=false
        BlockZeroExtent=false
    object end
    // Reference: StaticMeshComponent'Default__KFDynamicFogAndDamageVolumeInfo.AutomaticMeshComponent0'
    AutomaticMeshComponent=AutomaticMeshComponent0
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFDynamicFogAndDamageVolumeInfo.Sprite'
    Components(0)=Sprite
    begin object name=AutomaticMeshComponent0 class=StaticMeshComponent
        ReplacementPrimitive=none
        BlockActors=false
        BlockZeroExtent=false
    object end
    // Reference: StaticMeshComponent'Default__KFDynamicFogAndDamageVolumeInfo.AutomaticMeshComponent0'
    Components(1)=AutomaticMeshComponent0
    Components(2)=FogVolumeConstantDensityComponent'Default__KFDynamicFogAndDamageVolumeInfo.FogVolumeComponent0'
    bCollideActors=true
}