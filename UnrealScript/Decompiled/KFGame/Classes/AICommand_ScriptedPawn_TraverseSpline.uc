/*******************************************************************************
 * AICommand_ScriptedPawn_TraverseSpline generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_ScriptedPawn_TraverseSpline extends AICommand within KFAIController;

var transient int SegmentGranularity;
var transient KFPawn_Scripted MyScriptedPawn;
var transient array<SplineActor> Route;
var transient int SegIdx;
var transient int SubSegIdx;
var transient Vector Direction;
var transient Vector SubSegEnd;
var export editinline transient SplineComponent SegSplineComp;
var transient float SegSplineLen;

static function bool TraverseSpline(KFAIController AI, SplineActor SplineStart, SplineActor SplineEnd, int Granularity)
{
    local AICommand_ScriptedPawn_TraverseSpline Cmd;

    if((AI != none) && SplineStart != none)
    {
        Cmd = new (AI) Class'AICommand_ScriptedPawn_TraverseSpline';
        if(Cmd != none)
        {
            SplineStart.FindSplinePathTo(SplineEnd, Cmd.Route);
            Cmd.SegmentGranularity = Granularity;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    local SplineActor SplineEnd;

    super.Pushed();
    MyScriptedPawn = KFPawn_Scripted(Outer.Pawn);
    SplineEnd = Route[Route.Length - 1];
    J0x5C:

    if(SplineEnd.Connections.Length > 0)
    {
        SplineEnd = SplineEnd.Connections[0].ConnectTo;
        Route.AddItem(SplineEnd;
        goto J0x5C;
    }
    GotoState('TraversingSpline');
}

function Paused(GameAICommand NewCommand)
{
    super.Paused(NewCommand);
}

function Resumed(name OldCommandName)
{
    super.Resumed(OldCommandName);
}

function Popped()
{
    super.Popped();
    Route.Length = 0;
    MyScriptedPawn.EndedRoute(Status == 'Success');
}

function bool PawnReachedDestination(Vector Dest)
{
    return VSize2D(MyScriptedPawn.Location - Dest) < float(10);
}

state TraversingSpline
{Begin:

    if(Route.Length == 0)
    {
        Status = 'Failure';        
    }
    else
    {
        MyScriptedPawn.ReachedRouteMarker(0, Route[0], 0);
        SegIdx = 1;
        J0x5D:

        SegSplineComp = Route[SegIdx - 1].FindSplineComponentTo(Route[SegIdx]);
        SegSplineLen = SegSplineComp.GetSplineLength();
        SubSegIdx = 1;
        J0xDA:

        SubSegEnd = ((SegSplineComp != none) ? SegSplineComp.GetLocationAtDistanceAlongSpline((float(SubSegIdx) / float(SegmentGranularity + 1)) * SegSplineLen) : Route[SegIdx].Location);
        J0x162:

        Direction = SubSegEnd - Outer.Pawn.Location;
        if(MyScriptedPawn.Physics == 1)
        {
            Direction.Z = 0;
        }
        Direction = Normal(Direction);
        MyScriptedPawn.Velocity = Direction * MyScriptedPawn.GroundSpeed;
        MyScriptedPawn.SetDesiredRotation(rotator(Direction),,, 0.1);
        Outer.Sleep(0);
        if(!(PawnReachedDestination(SubSegEnd)))
            goto J0x162;
        MyScriptedPawn.ReachedRouteMarker(SegIdx, ((SubSegIdx == (SegmentGranularity + 1)) ? Route[SegIdx] : none), SubSegIdx);
        ++ SubSegIdx;
        if(!((PawnReachedDestination(Route[SegIdx].Location)) && SubSegIdx == (SegmentGranularity + 2)))
            goto J0xDA;
        ++ SegIdx;
        if(!(SegIdx == Route.Length))
            goto J0x5D;
        MyScriptedPawn.Acceleration = vect(0, 0, 0);
        Status = 'Success';
    }
    Outer.PopCommand(self);
    stop;                    
}
