/*******************************************************************************
 * AICommand_MoveToGoal generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_MoveToGoal extends AICommand within KFAIController
    native(AI);

const bUseAsyncRaycastsForSkipAhead = 0;

var bool bCanPathfind;
var bool bValidRouteCache;
var bool bAllowPartialPath;
var bool bAllowedToAttackDuringMove;
var bool bSavedIgnoreStepAside;
var bool bEnableSkipAheadChecks;
var const bool bSkipAheadFail;
var bool bGoalChangedDueToSkipAhead;
var bool bGoalSurrounded;
var Actor IntermediateMoveGoal;
var BasedPosition LastPawnTargetPathLocation;
var Actor MoveToActor;
var int NumTimesGetNextMoveGoalReturnedSameNode;
var int Retries;
var int LoopFailSafeCounter;
var Vector LastMovePoint;
var float TimeOutTime;
var Actor TurnFocus;
var Vector TurnFocalPoint;
var int WallHitCount;
var BasedPosition SkipAheadLastUpdatePos;
var float SkipAheadUpdateThreshold;
var int SkipAheadMaxNodes;
var float SkipAheadMaxDist;
var float SkipAheadPitCheckInterval;
var float SkipAheadPitCheckHeight;
var const int SkipAheadNumActiveTests;
var int SkipAheadCurrentTestingIndex;
var native const transient map<0, 0> NonSkippableWaypoints;

// Export UAICommand_MoveToGoal::execClearNonSkippableWayPoints(FFrame&, void* const)
native function ClearNonSkippableWayPoints();

// Export UAICommand_MoveToGoal::execAddNonSkippableWayPoint(FFrame&, void* const)
native function AddNonSkippableWayPoint(NavigationPoint Point);

static function bool MoveToGoal(KFAIController AI, Actor NewMoveGoal, optional Actor NewMoveFocus, optional float NewMoveOffset, optional bool bIsValidCache, optional bool bInCanPathfind, optional bool bInAllowedToAttackDuringMove, optional bool bInAllowPartialPath)
{
    local AICommand_MoveToGoal Cmd;

    bInCanPathfind = true;
    bInAllowedToAttackDuringMove = true;
    bInAllowPartialPath = true;
    if((AI != none) && NewMoveGoal != none)
    {
        Cmd = new (AI) Class'AICommand_MoveToGoal';
        if(Cmd != none)
        {
            if(Controller(NewMoveGoal) != none)
            {
                NewMoveGoal = Controller(NewMoveGoal).Pawn;
            }
            AI.MoveGoal = NewMoveGoal;
            AI.MoveFocus = NewMoveFocus;
            AI.MoveOffset = NewMoveOffset;
            Cmd.MoveToActor = NewMoveGoal;
            Cmd.bValidRouteCache = bIsValidCache;
            Cmd.bCanPathfind = bInCanPathfind;
            Cmd.bAllowedToAttack = bInAllowedToAttackDuringMove;
            Cmd.bAllowPartialPath = bInAllowPartialPath;
            AI.SetBasedPosition(AI.MovePosition, vect(0, 0, 0));
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

static function bool MoveToPoint(KFAIController AI, Vector NewMovePoint, optional Actor NewMoveFocus, optional float NewMoveOffset, optional bool bIsValidCache, optional bool bInCanPathfind, optional bool bInAllowedToAttackDuringMove, optional bool bInAllowPartialPath)
{
    local AICommand_MoveToGoal Cmd;

    bInCanPathfind = true;
    bInAllowedToAttackDuringMove = true;
    bInAllowPartialPath = true;
    if((AI != none) && NewMovePoint != vect(0, 0, 0))
    {
        Cmd = new (AI) Class'AICommand_MoveToGoal';
        if(Cmd != none)
        {
            AI.MoveFocus = NewMoveFocus;
            AI.MoveOffset = NewMoveOffset;
            AI.MoveGoal = none;
            Cmd.MoveToActor = none;
            Cmd.bValidRouteCache = bIsValidCache;
            Cmd.bCanPathfind = bInCanPathfind;
            Cmd.bAllowedToAttackDuringMove = bInAllowedToAttackDuringMove;
            Cmd.bAllowPartialPath = bInAllowPartialPath;
            AI.SetBasedPosition(AI.MovePosition, NewMovePoint);
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    if(Outer.Steering != none)
    {
    }
    super.Pushed();
    Outer.StartingMovement();
    bSavedIgnoreStepAside = bIgnoreStepAside;
    Outer.bMovingToGoal = true;
    Outer.bReachedMoveGoal = false;
    Outer.bReevaluatePath = false;
    Outer.MoveTarget = none;
    LastMovePoint = vect(0, 0, 0);
    Outer.SetDestinationPosition(Outer.Pawn.Location, true);
    ClearNonSkippableWayPoints();
    GotoState('MovingToGoal');
}

function Popped()
{
    if(Outer.Steering != none)
    {
        Outer.Steering.DisableDefaultAcceleration();
    }
    super.Popped();
    Outer.bDirectMoveToGoal = false;
    Outer.bMovingToGoal = false;
    Outer.bReachedMoveGoal = Status == 'Success';
    Outer.MoveTarget = none;
    Retries = 0;
    bIgnoreStepAside = bSavedIgnoreStepAside;
    Outer.LastNavGoalReached = none;
    Outer.bReachedLatentMoveGoal = false;
    Outer.StoppingMovement();
    Outer.RouteCache_Empty();
    if(Outer.Pawn != none)
    {
        Outer.Pawn.ZeroMovementVariables();
        Outer.Pawn.DestinationOffset = 0;
    }
    Outer.ClearTimer('MoveToGoalTimedOut', self);
    Outer.ClearTimer('TimedAbortMove');
    ReachedMoveGoal();
}

function Paused(GameAICommand NewCommand)
{
    local Vector OldVelocity;
    local bool bWasFalling;

    super.Paused(NewCommand);
    Retries = 0;
    Outer.PauseTimer(true, 'MoveToGoalTimedOut', self);
    Outer.PauseTimer(false, 'TimedAbortMove');
    if(Outer.Steering != none)
    {
    }
    if((Outer.Pawn != none) && Outer.Pawn.Physics == 2)
    {
        OldVelocity = Outer.Pawn.Velocity;
        bWasFalling = true;
    }
    Outer.Pawn.ZeroMovementVariables();
    if((Outer.Pawn != none) && bWasFalling)
    {
        Outer.Pawn.Velocity = OldVelocity;
    }
}

function Resumed(name OldCommandName)
{
    Outer.AILog_Internal(((string(self) $ " Resumed (oldCommand: ") $ string(OldCommandName)) $ ")", 'Command_MoveToGoal');
    Retries = 0;
    super.Resumed(OldCommandName);
    if(Outer.Steering != none)
    {
    }
    NumTimesGetNextMoveGoalReturnedSameNode = 0;
    Retries = 0;
    if((ChildStatus == 'Success') || ((Outer.Enemy != none) && Outer.MyKFPawn.IsPawnMovingAwayFromMe(Outer.Enemy)) && Outer.MyKFPawn.bIsSprinting)
    {
        Outer.PauseTimer(false, 'MoveToGoalTimedOut', self);
        Outer.PauseTimer(false, 'TimedAbortMove');
        Outer.bMovingToGoal = true;
        Outer.bReachedMoveGoal = false;
        if(OldCommandName != 'AICommand_Crawler_LeapToWall')
        {
            IntermediateMoveGoal = none;
        }
        if((Outer.RouteCache.Length > 0) && Outer.Enemy != none)
        {
            Outer.bReevaluatePath = true;
            ReEvaluatePath();
        }        
    }
    else
    {
        UpdateHistoryString("Failure!");
        Status = 'Failure';
        Outer.AbortCommand(self);
    }
}

event bool EnemyIsSurrounded()
{
    return false;
}

function ReEvaluatePath()
{
    local NavigationPoint BestAnchor;
    local float Dist;

    Outer.AILog_Internal((string(GetFuncName()) $ "() bReEvaluatePath: ") $ string(Outer.bReevaluatePath), 'Command_MoveToGoal');
    WallHitCount = 0;
    Outer.LastHitWall = none;
    if((Outer.bReevaluatePath && Outer.Pawn != none) && (MoveGoalIsValid()) || MovePointIsValid())
    {
        Outer.AILog_Internal((((((string(self) $ " ") $ string(GetFuncName())) $ "() ... Goal") @ string(Outer.MoveGoal)) @ "Anchor") @ string(Outer.Pawn.Anchor), 'Command_MoveToGoal');
        Outer.RouteCache_Empty();
        if(!Outer.Pawn.ValidAnchor() && !Outer.bDirectMoveToGoal)
        {
            BestAnchor = Outer.Pawn.GetBestAnchor(Outer.Pawn, Outer.Pawn.Location, true, false, Dist);
            Outer.AILog_Internal((string(GetFuncName()) $ "- ValidAnchor() returned false, new anchor:") @ string(BestAnchor), 'Command_MoveToGoal');
            if(BestAnchor == none)
            {
                BestAnchor = Class'NavigationPoint'.static.GetNearestNavToActor(Outer.MyKFPawn);
                Outer.AILog_Internal("-dd teleport anchor:" @ string(BestAnchor), 'Command_MoveToGoal');
                if((BestAnchor != none) && BestAnchor.IsUsableAnchorFor(Outer.MyKFPawn))
                {
                    Outer.Pawn.SetLocation(BestAnchor.Location);
                }
            }
            if(BestAnchor != none)
            {
                Outer.Pawn.SetAnchor(BestAnchor);
            }
        }
        Outer.RouteCache_Empty();
        Outer.AILog_Internal(string(GetFuncName()) @ "disabling bReevaluatePath and restarting the move", 'Command_MoveToGoal');
        Outer.bReevaluatePath = false;
        bValidRouteCache = false;
        GotoState('MovingToGoal', 'Begin');        
    }
    else
    {
        if(HasReachedMoveGoal())
        {
            Status = 'Success';
            Outer.PopCommand(self);
        }
    }
}

function Actor FindPathToward(Actor anActor)
{
    local Engine.Pawn.EPathSearchType OldSearchType;
    local Actor Result;
    local int I;

    OldSearchType = Outer.Pawn.PathSearchType;
    Outer.Pawn.PathSearchType = 3;
    Outer.AILog_Internal((("Generating path toward " $ string(anActor)) $ " Partial allowed? ") $ string(bAllowPartialPath), 'Command_MoveToGoal');
    I = 0;
    J0xF3:

    if(I < Outer.BlockedPathList.Length)
    {
        if((Outer.BlockedPathList[I].BlockedTime > 0) && (Outer.WorldInfo.TimeSeconds - Outer.BlockedPathList[I].BlockedTime) > Outer.MaxBlockedPathDuration)
        {
            Outer.BlockedPathList.RemoveItem(Outer.BlockedPathList[I];            
        }
        else
        {
            NavigationPoint(Outer.BlockedPathList[I].BlockedReachSpec.End.Actor).bBlocked = true;
        }
        ++ I;
        goto J0xF3;
    }
    Result = Outer.GeneratePathTo(anActor,, bAllowPartialPath);
    I = 0;
    J0x321:

    if(I < Outer.BlockedPathList.Length)
    {
        NavigationPoint(Outer.BlockedPathList[I].BlockedReachSpec.End.Actor).bBlocked = false;
        ++ I;
        goto J0x321;
    }
    Outer.Pawn.PathSearchType = OldSearchType;
    if(Result == none)
    {
        Outer.AIActionStatus = "Failed Path toward " $ string(anActor);
        Outer.CurrentMovementPhase = 6;
        Outer.AILog_Internal("** FAILED TO BUILD PATH TO " $ string(anActor), 'PathWarning');
        if(Outer.Pawn.Anchor != none)
        {
            if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIPathFailure(Outer, Outer.Pawn.Anchor, Outer.MoveGoal, "MoveToGoal");
            }            
        }
        else
        {
            if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIPathFailure(Outer, none, Outer.MoveGoal, "MoveToGoal");
            }
        }        
    }
    else
    {
        if(Outer.bDebug_DrawPath)
        {
            Outer.KFDebug_DrawMyPath();
        }
    }
    return Result;
}

function Actor FindPathTo(Vector aPoint)
{
    local Engine.Pawn.EPathSearchType OldSearchType;
    local Actor Result;

    if(!bCanPathfind)
    {
        Outer.AILog_Internal("Not allowed to pathfind - aborting move", 'Command_MoveToGoal');
        Status = 'Failure';
        UpdateHistoryString("Failure- !bCanPathfind");
        Outer.AbortCommand(self);        
    }
    else
    {
        OldSearchType = Outer.Pawn.PathSearchType;
        Outer.Pawn.PathSearchType = 2;
        Result = Outer.FindPathTo(aPoint);
        Outer.Pawn.PathSearchType = OldSearchType;
        Outer.AILog_Internal((("Finding path to location " $ string(aPoint)) $ " Partial allowed? ") $ string(bAllowPartialPath), 'Command_MoveToGoal');
    }
    if(Result == none)
    {
        Outer.AIActionStatus = "Failed Path to " $ string(aPoint);
    }
    return Result;
}

function RouteCache_RemoveIndex(int Idx)
{
    SkipAheadCurrentTestingIndex = 0;
    Outer.RouteCache_RemoveIndex(Idx);
}

function MoveToGoalTimedOut()
{
    Outer.AILog_Internal(string(GetFuncName()), 'Command_MoveToGoal');
    Outer.AIActionStatus = "MoveToGoal TimedOut";
    if((Outer.Enemy != none) && Outer.Enemy.IsAliveAndWell())
    {
        if((Outer.NumberOfZedsTargetingPawn(Outer.Enemy, true, 350) > 2) && Outer.CanSee(Outer.Enemy))
        {
            Status = 'Success';
            Outer.PopCommand(self);
            return;
        }
        Outer.AILog_Internal(((((string(GetFuncName()) @ string(self)) $ " Timing out, but since my enemy is still alive I'm assuming I should keep trying? Anchor: ") $ string(Outer.Pawn.Anchor)) $ " MoveGoal: ") $ string(Outer.MoveGoal), 'Command_MoveToGoal');
        return;        
    }
    else
    {
        Outer.AILog_Internal((((string(GetFuncName()) $ "() Anchor: ") $ string(Outer.Pawn.Anchor)) $ " MoveGoal: ") $ string(Outer.MoveGoal), 'Command_MoveToGoal');
        Outer.Pawn.SetAnchor(Outer.GetFallbackAnchor());
        Outer.AbortCommand(self);
    }
}

function bool MoveGoalIsValid(optional Actor Goal)
{
    if(Goal == none)
    {
        Goal = Outer.MoveGoal;
    }
    return Goal != none;
}

function bool MovePointIsValid(optional Vector Point)
{
    if(Point == vect(0, 0, 0))
    {
        Point = Outer.GetBasedPosition(Outer.MovePosition);
    }
    return Point != vect(0, 0, 0);
}

function bool HasReachedMoveGoal(optional Actor Goal)
{
    local bool bReached;
    local float TempDist;
    local bool bEnemyCheck;

    if(Outer.Pawn == none)
    {
        return true;
    }
    if((KFPawn(Goal) != none) && KFPawn(Goal) == Outer.Enemy)
    {
        Outer.AILog_Internal((((string(GetFuncName()) $ "() for ENEMY goal, current distance: ") $ string(VSize(Outer.Enemy.Location - Outer.Pawn.Location))) $ " MoveOffset: ") $ string(Outer.MoveOffset), 'Command_MoveToGoal');
        bEnemyCheck = true;
    }
    if(Goal == none)
    {
        Goal = Outer.MoveGoal;
    }
    Outer.Pawn.DestinationOffset = Outer.MoveOffset;
    if(MoveGoalIsValid(Goal))
    {
        if(Outer.Pawn.Anchor == Goal)
        {
            return true;
        }
        if(DynamicAnchor(Outer.Pawn.Anchor) != none)
        {
            return false;
        }
        bReached = (Outer.bReachedLatentMoveGoal && (NavigationPoint(Goal) != none) && Outer.LastNavGoalReached == NavigationPoint(Goal)) || Outer.Pawn.ReachedDestination(Goal);
        Outer.AILog_Internal((((((((string(self) $ " HasReachedMoveGoal for goal: ") $ string(Goal)) $ " Dist: ") $ string(VSize(Goal.Location - Outer.Pawn.Location))) $ " bReachedLatentMoveGoal: ") $ string(Outer.bReachedLatentMoveGoal)) $ " LastNavGoalReached: ") $ string(Outer.LastNavGoalReached), 'Command_MoveToGoal');
        TempDist = VSize(Goal.Location - Outer.Pawn.Location);
        if(!bReached)
        {
            Outer.AILog_Internal(((("NOT REACHED " $ string(Goal)) $ " (Dist: ") $ string(TempDist)) $ ")", 'Command_MoveToGoal');
        }
        return bReached;        
    }
    else
    {
        if(Outer.GetBasedPosition(Outer.MovePosition) != vect(0, 0, 0))
        {
            if(bEnemyCheck)
            {
                Outer.AILog_Internal((((string(GetFuncName()) $ "() ") $ string(VSize(Outer.GetBasedPosition(Outer.MovePosition) - Outer.Pawn.Location))) $ " versus MoveOffset ") $ string(Outer.MoveOffset), 'Command_MoveToGoal');
            }
            if(VSize(Outer.GetBasedPosition(Outer.MovePosition) - Outer.Pawn.Location) < Outer.MoveOffset)
            {
                if(bEnemyCheck)
                {
                    Outer.AILog_Internal(string(GetFuncName()) $ "() Returning TRUE, position < MoveOffset", 'Command_MoveToGoal');
                }
                return true;
            }
            bReached = Outer.Pawn.ReachedPoint(Outer.GetBasedPosition(Outer.MovePosition), none);
            if(bEnemyCheck)
            {
                Outer.AILog_Internal((string(GetFuncName()) $ "() ReachedPoint reaturned ") $ string(bReached), 'Command_MoveToGoal');
            }
            if(bReached)
            {
                return true;
            }
            return bReached;
        }
    }
    if(bEnemyCheck)
    {
        Outer.AILog_Internal(string(GetFuncName()) $ "() Returning false", 'Command_MoveToGoal');
    }
    return false;
}

function bool MoveUnreachable(Vector AttemptedDest, Actor AttemptedTarget)
{
    if(AttemptedTarget != none)
    {
        if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIMoveFailure(Outer, Outer.Pawn.Location, Outer.Pawn.Rotation, AttemptedTarget, "2 MoveUnreachable to " $ string(AttemptedTarget));
        }
        Outer.AILog_Internal((((string(self) $ " MoveUnreachable() while moving to goal! Target: ") $ string(AttemptedTarget)) $ " Dest: ") $ string(AttemptedDest), 'Command_MoveToGoal');        
    }
    else
    {
        if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
        {
            KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIMoveFailure(Outer, Outer.Pawn.Location, Outer.Pawn.Rotation, Outer.MoveTarget, "3 MoveUnreachable to " $ string(Outer.MoveTarget));
        }
        Outer.AILog_Internal((string(self) $ " MoveUnreachable() while moving to goal! Dest: ") $ string(AttemptedDest), 'Command_MoveToGoal');
    }
    UpdateHistoryString("[F] MoveUnreachable " $ string(Outer.Pawn.Location));
    Status = 'Failure';
    if(AttemptedTarget == none)
    {
        Outer.AIActionStatus = "Move Unreachable: " $ string(AttemptedDest);        
    }
    else
    {
        Outer.AIActionStatus = "Move Unreachable: " $ string(AttemptedTarget);
    }
    bValidRouteCache = false;
    Outer.bReevaluatePath = true;
    NotifyNeedRepath();
    return true;
}

function ReachedMoveGoal()
{
    if((Outer.MoveGoal != none) && Outer.Pawn != none)
    {
        Outer.AIActionStatus = (("Reached MoveGoal Dist: " $ string(VSize(Outer.MoveGoal.Location - Outer.Pawn.Location))) $ " MoveGoal: ") $ string(Outer.MoveGoal);
        Outer.AILog_Internal((((string(self) $ " Reached MoveGoal: ") $ string(Outer.MoveGoal)) $ " Dist: ") $ string(VSize(Outer.MoveGoal.Location - Outer.Pawn.Location)), 'Command_MoveToGoal');
    }
}

function ReachedIntermediateMoveGoal()
{
    local KFDoorMarker DM;

    if(!Outer.bUseNavMesh)
    {
        Outer.AIActionStatus = "Reached Intermediate Goal " $ string(IntermediateMoveGoal);
        Outer.AILog_Internal((string(self) $ " ReachedIntermediateMoveGoal: ") $ string(IntermediateMoveGoal), 'PathWarning');
        DM = KFDoorMarker(IntermediateMoveGoal);
        if(((DM != none) && DM.MyKFDoor != none) && !DM.MyKFDoor.IsCompletelyOpen())
        {
            if(Outer.MyKFPawn.HandleAIDoorBump(DM.MyKFDoor))
            {
                return;
            }
            Outer.AILog_Internal((((string(GetFuncName()) $ " Reached IntermediateMoveGoal DoorMarker ") $ string(DM)) $ " for closed door Dist: ") $ string(VSize(DM.Location - Outer.Pawn.Location)), 'Doors');
            if(DM.MyKFDoor.WeldIntegrity <= 0)
            {
                Outer.AIActionStatus = ("Waiting for " $ string(DM.MyKFDoor)) $ " to open";
                Outer.AILog_Internal(string(GetFuncName()) $ " Calling WaitForDoor and UseDoor", 'Doors');
                Outer.WaitForDoor(DM.MyKFDoor);
                DM.MyKFDoor.UseDoor(Outer.Pawn);                
            }
            else
            {
                Outer.AILog_Internal((((string(GetFuncName()) $ " calling NotifyAttackDoor for ") $ string(DM.MyKFDoor)) $ " with weld integrity ") $ string(DM.MyKFDoor.WeldIntegrity), 'Doors');
                Outer.AIActionStatus = "Wants to attack door " $ string(DM.MyKFDoor);
                Outer.NotifyAttackDoor(DM.MyKFDoor);
            }
        }
    }
}

function bool HandlePathObstruction(Actor BlockedBy)
{
    local Pawn BlockPawn;

    Outer.AIActionStatus = "Path obstructed by " $ string(BlockedBy);
    Outer.AILog_Internal((((string(GetFuncName()) $ " - Blocked by : ") $ string(BlockedBy)) $ " Time since previous obstruction: ") $ string(Outer.WorldInfo.TimeSeconds - Outer.LastObstructionTime), 'HandlePathObstruction');
    Outer.LastObstructionTime = Outer.WorldInfo.TimeSeconds;
    BlockPawn = Pawn(BlockedBy);
    if(BlockPawn != none)
    {
        Outer.AILog_Internal(("- blocked anchor:" @ string(BlockPawn.Anchor)) @ string(BlockPawn.ReachedDestination(Outer.MoveGoal)));
        if(BlockPawn.ReachedDestination(Outer.MoveGoal))
        {
            Outer.AILog_Internal("- they're touching my goal, finishing the move", 'HandlePathObstruction');
            Outer.bReachedMoveGoal = true;
            Status = 'Success';
            Outer.PopCommand(self);
            return true;
        }        
    }
    else
    {
        if(KFDestructibleActor(BlockedBy) != none)
        {
            bValidRouteCache = false;
            Outer.bReevaluatePath = true;
            Outer.StopAllLatentMovement();
            Outer.AILog_Internal(string(GetFuncName()) $ "() calling ZeroMovementVariables", 'HandlePathObstruction');
            Outer.Pawn.ZeroMovementVariables();
            if(KFPathnode(IntermediateMoveGoal) != none)
            {
                if(Outer.CreateTemporaryBlockedPath(KFPathnode(IntermediateMoveGoal)))
                {
                }
            }
            Obstruction_Repath(BlockedBy);
            NotifyNeedRepath();
            return false;
        }
    }
    Obstruction_Fail(BlockedBy);
    return false;
}

function Obstruction_Repath(Actor Obstruction)
{
    if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIPathObstruction(2114, Outer, Obstruction, "MoveTarget:" $ string(Outer.MoveTarget));
    }
}

function Obstruction_Fail(Actor Obstruction)
{
    if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
    {
        KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIPathObstruction(2113, Outer, Obstruction, "MoveTarget:" $ string(Outer.MoveTarget));
    }
}

function StartingMove(bool bDirectMove, float Distance, int PathLength, Actor Dest)
{
    if(Outer.MyKFPawn.IsDoingMeleeAttack())
    {
        Outer.StopAllLatentMovement();
        GotoState('MovingToGoal', 'ReachedGoal');
        return;
    }
    if(((Outer.Enemy != none) && Dest != none) && Outer.Enemy == Dest)
    {
        if(VSize(Dest.Location - Outer.Pawn.Location) <= Outer.Pawn.MeleeRange)
        {
            Outer.StopAllLatentMovement();
            GotoState('MovingToGoal', 'ReachedGoal');
            return;
        }
    }
    if(bDirectMove)
    {
        Outer.AILog_Internal((((((string(self) $ " Starting *DIRECT* move, Distance: ") $ string(Distance)) $ " PathLength: ") $ string(PathLength)) $ " Dest: ") $ string(Dest), 'Command_MoveToGoal');
        Outer.bDirectMoveToGoal = true;
        Outer.RouteCache_Empty();        
    }
    else
    {
        Outer.AILog_Internal((((((string(self) $ " Starting *PATHFINDING* move, Distance: ") $ string(Distance)) $ " PathLength: ") $ string(PathLength)) $ " Dest: ") $ string(Dest), 'Command_MoveToGoal');
        Outer.bDirectMoveToGoal = false;
    }
}

function bool NotifyPlayerBecameVisible(Pawn VisiblePlayer)
{
    Outer.AILog_Internal((string(GetFuncName()) $ " ") $ string(VisiblePlayer), 'SeePlayer');
    if((((Outer.Enemy != none) && Outer.bMovingToGoal) && !Outer.bDirectMoveToGoal) && Outer.InLatentExecution(Outer.503))
    {
        if((VisiblePlayer == Outer.MoveGoal) || VisiblePlayer == IntermediateMoveGoal)
        {
            if(Outer.ActorReachable(VisiblePlayer))
            {
                Outer.AILog_Internal(((string(GetFuncName()) $ " My MoveGoal (") $ string(Outer.MoveGoal)) $ ") is visible and reachable - calling stop latent execution and re-evaluate path", 'Move_DirectPath');
                Outer.bReevaluatePath = true;
                Outer.bDirectMoveToGoal = true;
                Outer.SetDestinationPosition(Outer.Enemy.Location);
                ReEvaluatePath();
                Outer.StopLatentExecution();
                return true;
            }
        }
    }
    return false;
}

event string GetDumpString()
{
    if(Outer.GetBasedPosition(Outer.MovePosition) != vect(0, 0, 0))
    {
        return (((((((((((((super(GameAICommand).GetDumpString() @ "Point:") @ string(Outer.GetBasedPosition(Outer.MovePosition))) @ "MoveFocus:") @ string(Outer.MoveFocus)) @ "Offset:") @ string(Outer.MoveOffset)) @ "IMG:") @ string(IntermediateMoveGoal)) @ "Focus:") @ string(Outer.Focus)) @ "MoveTarget:") @ string(Outer.MoveTarget)) @ "MySpeed:") @ string(VSize(Outer.Pawn.Velocity));        
    }
    else
    {
        return (((((((((((((super(GameAICommand).GetDumpString() @ "Destination:") @ string(Outer.MoveGoal)) @ "MoveFocus:") @ string(Outer.MoveFocus)) @ "Offset:") @ string(Outer.MoveOffset)) @ "IMG:") @ string(IntermediateMoveGoal)) @ "Focus:") @ string(Outer.Focus)) @ "MoveTarget:") @ string(Outer.MoveTarget)) @ "MySpeed:") @ string(VSize(Outer.Pawn.Velocity));
    }
}

function NotifyNeedRepath()
{
    Outer.AILog_Internal((((string(GetFuncName()) $ "() MoveTarget: ") $ ((Outer.MoveTarget != none) ? string(Outer.MoveTarget) : "none")) $ " Dist: ") $ string(((Outer.MoveTarget != none) ? VSize(Outer.MoveTarget.Location - Outer.Pawn.Location) : 0)), 'PathWarning');
    Outer.bReevaluatePath = true;
    Outer.StopLatentExecution();
    ReEvaluatePath();
}

function Timer_DelayMoveTimeOut()
{
    if((Outer.MyKFPawn != none) && Outer.MyKFPawn.IsAliveAndWell())
    {
        Outer.AILog_Internal(("************* " $ string(Outer.MyKFPawn)) $ " DELAYING MOVE FOR OVER 20 SECONDS");
    }
}

function bool AdjustAround(Actor Other, Vector HitNormal)
{
    local Vector VelDir, OtherDir, SideDir, HitLocation, Adj;

    local float CollisionRad, CollisionHeight;

    if(!Outer.IsDoingLatentMove() || Outer.MoveTarget == none)
    {
        return false;
    }
    VelDir = Normal(Outer.MoveTarget.Location - Outer.Pawn.Location);
    OtherDir = Other.Location - Outer.Pawn.Location;
    VelDir.Z = 0;
    OtherDir.Z = 0;
    OtherDir = Normal(OtherDir);
    if(((Pawn(Other) != none) && Other.Physics == 8) && Pawn(Other).Floor.Z < -0.7)
    {
        Other.SetPhysics(2);
    }
    if((VelDir Dot OtherDir) > 0.7)
    {
        SideDir.X = VelDir.Y;
        SideDir.Y = -1 * VelDir.X;
        if((SideDir Dot OtherDir) > 0)
        {
            SideDir *= float(-1);
        }
        if(Pawn(Other) == none)
        {
            Other.GetBoundingCylinder(CollisionRad, CollisionHeight);
            Adj = Outer.Pawn.Location + ((3.5 * CollisionRad) * ((0.5 * VelDir) + SideDir));            
        }
        else
        {
            Adj = Outer.Pawn.Location + ((3.5 * Pawn(Other).GetCollisionRadius()) * ((0.5 * VelDir) + SideDir));
        }
        if(Outer.Trace(HitLocation, HitNormal, Adj, Outer.Pawn.Location, false) != none)
        {
            Adj = HitLocation;
        }
        Outer.AILog_Internal((string(GetFuncName()) $ "() in MoveToGoal, SettingAdjustLocation to ") $ string(Adj), 'HitWall');
        Outer.SetAdjustLocation(Adj, true, true);
        return true;        
    }
    else
    {
        return false;
    }
}

function bool NotifyBump(Actor Other, Vector HitNormal)
{
    local KFPawn KFP;

    if(Outer.IsDoingLatentMove() && Outer.MyKFPawn.Physics != 2)
    {
        KFP = KFPawn(Other);
        if(KFP != none)
        {
            Outer.AILog_Internal((("NotifyBump in MoveToGoal, Other: " $ string(Other)) $ " HitNormal: ") $ string(HitNormal), 'BumpEvent');
            Outer.DisableBump(0.12);
            if(!KFP.IsAliveAndWell() || !Outer.Pawn.IsSameTeam(KFP))
            {
                return false;
            }
            if(KFDoorMarker(Outer.MoveTarget) != none)
            {
                if(((Outer.PendingDoor == none) && !KFDoorMarker(Outer.MoveTarget).MyKFDoor.IsCompletelyOpen()) && VSize(Outer.MoveTarget.Location - Outer.MyKFPawn.Location) < 350)
                {
                    Outer.WaitForDoor(KFDoorMarker(Outer.MoveTarget).MyKFDoor);
                    return true;
                }
            }
            if((((((KFP.MyKFAIC != none) && KFP.MyKFAIC.Enemy != none) && Outer.Enemy != none) && KFP.MyKFAIC.Enemy == Outer.Enemy) && KFP.MyKFAIC.IsDoingLatentMove()) && VSizeSq(Outer.Enemy.Location - KFP.Location) < 160000)
            {
                return false;
            }
        }
        AdjustAround(Other, HitNormal);
        return true;
    }
    return false;
}

state MovingToGoal
{
    ignores SetBestAnchor;

    function bool NotifyHitWall(Vector HitNormal, Actor Wall)
    {
        local KFDoorActor door;

        Outer.DisableNotifyHitWall(0.2);
        Outer.AILog_Internal((((((((("NotifyHitWall() while in MoveToGoal, HitNormal: " $ string(HitNormal)) $ " Wall: ") $ string(Wall)) $ " LastHitWall: ") $ string(Outer.LastHitWall)) $ " WallHitCount: ") $ string(WallHitCount)) $ " MoveTarget: ") $ string(Outer.MoveTarget), 'PathWarning');
        Outer.AIActionStatus = "Received NotifyHitWall event";
        if(!Wall.bStatic)
        {
            door = KFDoorActor(Wall);
            if(door == none)
            {
                Outer.AILog_Internal((((string(GetFuncName()) $ "() Wall: ") $ string(Wall)) $ " HitNormal: ") $ string(HitNormal), 'HitWall');                
            }
            else
            {
                if(Outer.MyKFPawn.HandleAIDoorBump(door))
                {
                    return true;
                }
                if(((door.WeldIntegrity <= 0) && KFDoorMarker(door.MyMarker) != none) && !door.IsCompletelyOpen())
                {
                    Outer.DisableNotifyHitWall(0.25);
                    Outer.WaitForDoor(door);
                    Outer.AILog_Internal(("NotifyHitWall() while in MoveToGoal, Wall: " $ string(Wall)) $ " Using door and waiting for it to open", 'Doors');
                    door.UseDoor(Outer.Pawn);
                    return true;
                }
                Outer.AILog_Internal(((((string(GetFuncName()) $ "() Wall: ") $ string(Wall)) $ " HitNormal: ") $ string(HitNormal)) $ " ran into a door!", 'Doors');
                if((!door.IsCompletelyOpen() && door.WeldIntegrity > 0) && (Outer.Pawn.Anchor == door.MyMarker) || (Outer.DoorEnemy != none) && (Outer.DoorEnemy == door) || Outer.PendingDoor == door)
                {
                    Outer.DisableNotifyHitWall(0.25);
                    Outer.AILog_Internal((string(GetFuncName()) $ "() calling NotifyAttackDoor for ") $ string(Wall), 'Doors');
                    Outer.NotifyAttackDoor(door);
                    return true;
                }
            }
            if(Outer.Pawn.Physics == 2)
            {
                return true;
            }
        }
        if((Outer.LastHitWall != none) && Wall != Outer.LastHitWall)
        {
            Outer.LastHitWall = none;
            WallHitCount = 0;
        }
        Outer.LastHitWall = Wall;
        if(WallHitCount > 26)
        {
            if(IntermediateMoveGoal.IsA('KFPathnode'))
            {
                Outer.AILog_Internal(((((((string(GetFuncName()) $ "() Wall: ") $ string(Wall)) $ " WallHitCount: ") $ string(WallHitCount)) $ " Hit Wall > 3 times, setting ") $ string(IntermediateMoveGoal)) $ " to be a blocked path and forcing a repath!", 'PathWarning');
                ++ WallHitCount;
                Outer.LastHitWall = Wall;
                if(((Outer.WorldInfo.Game != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
                {
                    KFGameInfo(Outer.WorldInfo.Game).GameplayEventsWriter.LogAIWall(2107, Outer, Outer.Pawn.Location, Outer.Pawn.Rotation, Wall, "SuperSpeed: " $ string(Outer.MyKFPawn.IsUsingSuperSpeed()));
                }
                Outer.ForcePauseAndRepath(Wall);
                WallHitCount = 0;
                Outer.DisableNotifyHitWall(3);
                return true;
            }
        }
        return false;
    }

    function bool ShouldDelayMove()
    {
        if(Outer.bPreparingMove || Outer.MyKFPawn.IsDoingMeleeAttack())
        {
            bGoalSurrounded = false;
            Outer.AILog_Internal("ShouldDelayMove returning TRUE because bPreparingMove", 'Command_MoveToGoal');
            Outer.AIActionStatus = "Delaying Move";
            return true;
        }
        return false;
    }

    function NotifyEnemyChanged(optional Pawn OldEnemy)
    {
        if(CachedChildCommand != none)
        {
            CachedChildCommand.NotifyEnemyChanged(OldEnemy);
        }
        if(((Outer.MoveGoal != none) && OldEnemy == Outer.MoveGoal) || (IntermediateMoveGoal == none) && IntermediateMoveGoal == OldEnemy)
        {
            Outer.AILog_Internal(string(GetFuncName()) $ "() Stopping latent execution, resetting destination position to new enemy location, and calling ReEvaluatePath()", 'SetEnemy');
            Outer.MoveGoal = Outer.Enemy;
            Outer.StopLatentExecution();
            Outer.SetDestinationPosition(Outer.Enemy.Location);
            ReEvaluatePath();
        }
    }

    function NotifyDoorOpened()
    {
        if(CachedChildCommand != none)
        {
            CachedChildCommand.NotifyDoorOpened();
        }
        if(!Outer.MyKFPawn.IsDoingSpecialMove() || !Outer.MyKFPawn.SpecialMoves[Outer.MyKFPawn.SpecialMove].bDisableMovement)
        {
            Outer.bPreparingMove = false;
        }
    }

    function FindDirectPath()
    {
        if(((Outer.Enemy != none) && !Outer.bDirectMoveToGoal) && Outer.Pawn.Physics != 8)
        {
            Outer.AILog_Internal((string(GetFuncName()) $ " event received, checking for direct reachability to enemy ") $ string(Outer.Enemy), 'Move_DirectPath');
            if((Outer.InLatentExecution(Outer.503) && Outer.MyKFPawn.Physics != 2) && Outer.ActorReachable(Outer.Enemy))
            {
                Outer.AILog_Internal(string(GetFuncName()) $ " can directly reach enemy, stopping and resetting MoveTimer and resetting my move", 'Move_DirectPath');
                Outer.bDirectMoveToGoal = true;
                Outer.bReevaluatePath = true;
                Outer.StopLatentExecution();
                Outer.SetDestinationPosition(Outer.Enemy.Location);
                ReEvaluatePath();
            }
        }
    }

    protected final function bool GetNextMoveTarget(out Actor CurrentMoveTarget)
    {
        local bool bDone, bReachedDynamicAnchor;
        local Actor OldMoveTarget;

        Outer.AILog_Internal((((((string(GetFuncName()) @ "current movetarget:") @ string(CurrentMoveTarget)) @ "routecache length:") @ string(Outer.RouteCache.Length)) @ "anchor") @ string(Outer.Pawn.Anchor), 'Command_MoveToGoal');
        bGoalChangedDueToSkipAhead = false;
        OldMoveTarget = CurrentMoveTarget;
        J0xF4:

        if((!bDone && Outer.RouteCache.Length > 0) && Outer.RouteCache[0] != none)
        {
            if((Outer.bReachedLatentMoveGoal && Outer.LastNavGoalReached == Outer.RouteCache[0]) || Outer.Pawn.ReachedDestination(Outer.RouteCache[0]))
            {
                Outer.bReachedLatentMoveGoal = false;
                Outer.AILog_Internal((("Pawn has Reached route cache 0:" @ string(Outer.RouteCache[0])) $ " DIST: ") $ string(VSize(Outer.RouteCache[0].Location - Outer.Pawn.Location)), 'Command_MoveToGoal');
                if(Outer.RouteCache[0] == Outer.MoveGoal)
                {
                    bDone = true;
                    CurrentMoveTarget = none;
                }
                Outer.AILog_Internal(("Setting anchor to RouteCache 0 (" $ string(Outer.RouteCache[0])) $ ")", 'Command_MoveToGoal');
                Outer.Pawn.SetAnchor(Outer.RouteCache[0]);
                bReachedDynamicAnchor = DynamicAnchor(Outer.RouteCache[0]) != none;
                Outer.AILog_Internal(("Remove from route:" @ string(Outer.RouteCache[0])) @ string(bReachedDynamicAnchor), 'Command_MoveToGoal');
                RouteCache_RemoveIndex(0);                
            }
            else
            {
                Outer.AILog_Internal((("I Did NOT reach route cache 0:" @ string(Outer.RouteCache[0])) $ " Dist: ") $ string(VSize(Outer.RouteCache[0].Location - Outer.Pawn.Location)), 'Command_MoveToGoal');
                goto J0x5E8;
            }
            goto J0xF4;
        }
        J0x5E8:

        if(!bDone)
        {
            Outer.LastNavGoalReached = none;
            Outer.bReachedLatentMoveGoal = false;
            if(Outer.RouteCache.Length > 0)
            {
                CurrentMoveTarget = Outer.RouteCache[0];
                Outer.AILog_Internal((((string(GetFuncName()) $ " setting CurrentMoveTarget to ") $ string(CurrentMoveTarget)) $ " (RouteCache[0] ) OldMoveTarget was ") $ string(OldMoveTarget), 'Command_MoveToGoal');                
            }
            else
            {
                if((((Outer.MoveGoal != none) && CurrentMoveTarget != Outer.MoveGoal) && NavigationPoint(Outer.MoveGoal) == none) && Outer.ActorReachable(Outer.MoveGoal))
                {
                    CurrentMoveTarget = Outer.MoveGoal;
                    Outer.AILog_Internal((((string(GetFuncName()) $ " Set CurrentMoveTarget to MoveGoal ") $ string(Outer.MoveGoal)) $ " because move goal is now directly reachable. OldMoveTarget was ") $ string(OldMoveTarget), 'Command_MoveToGoal');                    
                }
                else
                {
                    Outer.AILog_Internal(string(GetFuncName()) $ " setting CurrentMoveTarget to none!", 'Command_MoveToGoal');
                    CurrentMoveTarget = none;
                }
            }
        }
        return bReachedDynamicAnchor || OldMoveTarget != CurrentMoveTarget;
    }

    function bool ShouldTurnToGoal(Vector TurnToLocation)
    {
        if((Outer.Pawn == none) || !Outer.Pawn.IsAliveAndWell())
        {
            return false;
        }
        return Outer.Pawn.NeedToTurn(TurnToLocation);
    }

    function bool CanDirectlyReach(Actor Goal)
    {
        return Outer.ActorReachable(Goal);
    }
CheckMove:

    Outer.ClearTimer('MoveToGoalTimedOut', self);
    if(HasReachedMoveGoal())
    {
        Outer.AILog_Internal("CheckMove label, I've reached my goal ", 'Command_MoveToGoal');
        goto 'ReachedGoal';
    }
Begin:


    Outer.Sleep(0);
    Outer.CurrentMovementPhase = 0;
    if(Outer.MyKFPawn.Physics == 2)
    {
        Outer.WaitForLanding();
    }
    Outer.bReachedLatentMoveGoal = false;
    if(Outer.IsTimerActive('Timer_DelayMoveTimeOut', self))
    {
        Outer.ClearTimer('Timer_DelayMoveTimeOut', self);
    }
    if((Outer.Pawn == none) || Outer.Pawn.Health <= 0)
    {
        Status = 'Aborted';
        Outer.AbortMovementCommands(true, "Dead!");
        Outer.AbortMovementPlugIns(true, "Dead");
        stop;
    }
    Outer.AILog_Internal((((((((((("Attempting move to goal " $ string(Outer.MoveGoal)) $ " Valid? ") $ string(MoveGoalIsValid())) $ " MovePosition: ") $ string(Outer.MovePosition.Position)) $ " BasedPosition: ") $ string(Outer.GetBasedPosition(Outer.MovePosition))) $ " MovePointIsValid? ") $ string(MovePointIsValid())) $ " bValidRouteCache? ") $ string(bValidRouteCache), 'Command_MoveToGoal');
    if(MoveGoalIsValid())
    {
        if((!bValidRouteCache && CanDirectlyReach(Outer.MoveGoal)) && !Outer.Pawn.bCrawler || Abs(Outer.Pawn.Location.Z - Outer.MoveGoal.Location.Z) < 700)
        {
DirectMoveToActor:


            Outer.CurrentMovementPhase = 8;
            Outer.AIActionStatus = "Moving Direct Path to " $ string(Outer.MoveGoal);
            StartingMove(true, VSize(Outer.Pawn.Location - Outer.MoveGoal.Location), 0, Outer.MoveGoal);
            TimeOutTime = Outer.GetMoveTimeOutDuration(Outer.MoveGoal.GetDestination(Outer), false);
            Outer.SetTimer(TimeOutTime, false, 'MoveToGoalTimedOut', self);
            LoopFailSafeCounter = 0;
            J0x696:

            Outer.AILog_Internal(((((((("Moving directly to move goal:" @ string(Outer.MoveGoal)) @ "from") @ string(Outer.Pawn.Anchor)) @ "Focus") @ string(Outer.MoveFocus)) @ "Offset") @ string(Outer.MoveOffset)) @ string(Outer.CurrentPath), 'Move_DirectPath');
            IntermediateMoveGoal = Outer.MoveGoal;
            if((((Outer.Pawn.Physics != 2) && !Outer.bMovingToGoal) && !Outer.IsDoingLatentMove()) && Outer.MoveGoal != none)
            {
                if(((Outer.WorldInfo.TimeSeconds - Outer.LastMoveFinishTime) > 5) && ShouldTurnToGoal(IntermediateMoveGoal.Location))
                {
                    TurnFocus = IntermediateMoveGoal;
                    PushState('RotateToFocus');
                }
            }
            Outer.AIActionStatus = "Moving directly toward " $ string(IntermediateMoveGoal);
            Outer.MoveToward(IntermediateMoveGoal, Outer.MoveFocus, Outer.MoveOffset, false, false);
            if((Outer.bReachedLatentMoveGoal && Outer.LastNavGoalReached == IntermediateMoveGoal) || Outer.Pawn.ReachedDestination(IntermediateMoveGoal))
            {
                ReachedIntermediateMoveGoal();
            }
            if(Outer.MyKFPawn.Physics == 2)
            {
                Outer.WaitForLanding();
            }
            if(!(((HasReachedMoveGoal()) || !Outer.ActorReachable(Outer.MoveGoal)) || ++ LoopFailSafeCounter > 50))
                goto J0x696;
            Outer.CurrentMovementPhase = 0;
            goto 'CheckMove';            
        }
        else
        {
            if(bValidRouteCache && Outer.RouteCache.Length > 0)
            {
                IntermediateMoveGoal = ((Outer.RouteCache.Length > 0) ? Outer.RouteCache[0] : none);
                bValidRouteCache = false;                
            }
            else
            {
                bValidRouteCache = false;
                IntermediateMoveGoal = FindPathToward(Outer.MoveGoal);
                if(IntermediateMoveGoal == none)
                {
                    Outer.InvalidateAnchor(Outer.Pawn.Anchor);
                }
            }
        }        
    }
    else
    {
        if(MovePointIsValid())
        {
            if(Outer.PointReachable(Outer.GetBasedPosition(Outer.MovePosition)))
            {
DirectMoveToPosition:


                Outer.CurrentMovementPhase = 3;
                StartingMove(true, VSize(Outer.Pawn.Location - Outer.GetBasedPosition(Outer.MovePosition)), 0, none);
                TimeOutTime = Outer.GetMoveTimeOutDuration(Outer.GetBasedPosition(Outer.MovePosition), false);
                Outer.SetTimer(TimeOutTime, false, 'MoveToGoalTimedOut', self);
                J0xE39:

                Outer.AILog_Internal(((((("Moving directly to move point:" @ string(Outer.GetBasedPosition(Outer.MovePosition))) @ "from") @ string(Outer.Pawn.Anchor)) @ "Focus") @ string(Outer.MoveFocus)) @ string(Outer.Pawn.Location), 'Move_Path');
                Outer.EnableSeePlayer();
                if(((Outer.WorldInfo.TimeSeconds - Outer.LastMoveFinishTime) > 5) && ShouldTurnToGoal(Outer.GetBasedPosition(Outer.MovePosition)))
                {
                    TurnFocalPoint = Outer.GetBasedPosition(Outer.MovePosition);
                    PushState('RotateToFocus');
                }
                Outer.MoveTo(Outer.GetBasedPosition(Outer.MovePosition), Outer.MoveFocus,, false);
                if(Outer.MyKFPawn.Physics == 2)
                {
                    Outer.WaitForLanding();
                }
                if(!((HasReachedMoveGoal()) || !Outer.PointReachable(Outer.GetBasedPosition(Outer.MovePosition))))
                    goto J0xE39;
                Outer.CurrentMovementPhase = 0;
                goto 'CheckMove';                
            }
            else
            {
                if(bValidRouteCache)
                {
                    IntermediateMoveGoal = ((Outer.RouteCache.Length > 0) ? Outer.RouteCache[0] : none);
                    bValidRouteCache = false;                    
                }
                else
                {
                    IntermediateMoveGoal = FindPathTo(Outer.GetBasedPosition(Outer.MovePosition));
                    if(IntermediateMoveGoal == none)
                    {
                        Outer.AILog_Internal((string(self) $ " IntermediateMoveGoal is null, so calling InvalidateAnchor for nav ") $ string(Outer.Pawn.Anchor), 'PathWarning');
                        Outer.InvalidateAnchor(Outer.Pawn.Anchor);
                    }
                }
            }
        }
    }
    J0x13B9:

    if(IntermediateMoveGoal != none)
    {
        if(Outer.MoveGoal != none)
        {
            Outer.AILog_Internal((("Following path to move goal:" @ string(Outer.MoveGoal)) @ "from") @ string(Outer.Pawn.Anchor), 'Move_Path');            
        }
        else
        {
            Outer.AILog_Internal((("Following path to move point:" @ string(Outer.GetBasedPosition(Outer.MovePosition))) @ "from") @ string(Outer.Pawn.Anchor), 'Move_Path');
        }
        GetNextMoveTarget(IntermediateMoveGoal);
        if(((IntermediateMoveGoal == Outer.Pawn.Anchor) && Outer.RouteCache.Length > 1) && Outer.ActorReachable(Outer.RouteCache[1]))
        {
            Outer.AILog_Internal(("Already at anchor, move to next..." @ string(Outer.Pawn.Anchor)) @ string(Outer.RouteCache[1]), 'Move_Path');
            RouteCache_RemoveIndex(0);
            GetNextMoveTarget(IntermediateMoveGoal);
        }
        if(IntermediateMoveGoal == none)
        {
            Outer.AILog_Internal("Failed to acquire move target, sleeping for 0.5 seconds and going to CheckMove label", 'Move_Path');
            Outer.Sleep(0.5);
            goto 'CheckMove';
        }
        Outer.ClearTimer('MoveToGoalTimedOut', self);
        J0x17C3:

        if(IntermediateMoveGoal != none)
        {
            Outer.AILog_Internal(((("Still moving to" @ string(IntermediateMoveGoal)) $ " which is ") $ string(VSize(Outer.Pawn.Location - IntermediateMoveGoal.Location))) $ " units away", 'Move_Path');
            Outer.CheckInterruptCombatTransitions();
            if(!Outer.Pawn.bCanStrafe)
            {
                Outer.AILog_Internal("Pushing RotateToFocus state", 'Move_Path');
                PushState('RotateToFocus');
            }
            Outer.LastDetourCheckTime = Outer.WorldInfo.TimeSeconds;
            if(ShouldDelayMove())
            {
                Outer.SetTimer(20, false, 'Timer_DelayMoveTimeOut', self);
            }
            J0x19CC:

            if(ShouldDelayMove())
            {
                Outer.CurrentMovementPhase = 4;
                Outer.AIActionStatus = "Delaying move";
                Outer.bDirectMoveToGoal = false;
                Outer.AILog_Internal("Delaying move, LastDetourCheckTime: " $ string(Outer.WorldInfo.TimeSeconds - Outer.LastDetourCheckTime), 'Move_Path');
                Outer.AIZeroMovementVariables();
                if((Outer.WorldInfo.TimeSeconds - Outer.LastDetourCheckTime) > 5)
                {
                    Outer.AILog_Internal("Attempting to restart move after delaying", 'Move_Path');
                    Outer.LastDetourCheckTime = Outer.WorldInfo.TimeSeconds;
                    bValidRouteCache = false;
                    goto 'CheckMove';
                }
                if((Outer.Pawn != none) && Outer.Pawn.Physics != 8)
                {
                    Outer.Focus = IntermediateMoveGoal;
                }
                if((((Outer.PendingDoor != none) && Outer.bPreparingMove) && Outer.PendingDoor.WeldIntegrity > 0) && !Outer.PendingDoor.IsCompletelyOpen())
                {
                    if(!Outer.Pawn.FastTrace(Outer.PendingDoor.Location, Outer.Pawn.Location))
                    {
                        Outer.AIActionStatus = "Wants to attack door " $ string(Outer.PendingDoor);
                        Outer.NotifyAttackDoor(Outer.PendingDoor);
                    }
                }
                Outer.Sleep(0.1);
                goto J0x19CC;
            }
            Outer.CurrentMovementPhase = 0;
PathingTowardActor:


            Outer.CurrentMovementPhase = 2;
            Outer.ClearTimer('Timer_DelayMoveTimeOut', self);
            StartingMove(false, Outer.GetRouteCacheDistance(), Outer.RouteCache.Length, IntermediateMoveGoal);
            if(bGoalChangedDueToSkipAhead)
            {
                Outer.AILog_Internal("RouteCache changed out from under us.. calling GetNextMoveTarget again!", 'Move_Path');
                if(!GetNextMoveTarget(IntermediateMoveGoal))
                {
                    Outer.AILog_Internal("GetNextMoveTarget FAILED after skipahead changed the route cache.. Aborting move", 'PathWarning');
                    IntermediateMoveGoal = none;
                    goto J0x2BFD;
                }
            }
            Outer.SetDirectPathCheckTime();
            Outer.EnableSeePlayer();
            if((((Outer.Pawn.Physics != 2) && !Outer.bMovingToGoal) && !Outer.IsDoingLatentMove()) && Outer.MoveGoal != none)
            {
                if(((Outer.WorldInfo.TimeSeconds - Outer.LastMoveFinishTime) > 5) && ShouldTurnToGoal(IntermediateMoveGoal.Location))
                {
                    TurnFocus = IntermediateMoveGoal;
                    PushState('RotateToFocus');
                }
            }
            Outer.AIActionStatus = "Moving toward " $ string(IntermediateMoveGoal);
            Outer.MoveToward(IntermediateMoveGoal, Outer.MoveFocus, ((IntermediateMoveGoal == Outer.MoveGoal) ? Outer.MoveOffset : 0), false, false);
            Outer.CurrentMovementPhase = 0;
            if((Outer.bReachedLatentMoveGoal && Outer.LastNavGoalReached == IntermediateMoveGoal) || Outer.Pawn.ReachedDestination(IntermediateMoveGoal))
            {
                Outer.AILog_Internal(((("MoveToward finished and I reached my intermediate goal (" $ string(IntermediateMoveGoal)) $ ") which is ") $ string(VSize(IntermediateMoveGoal.Location - Outer.Pawn.Location))) $ " units away", 'Move_Path');
                ReachedIntermediateMoveGoal();
            }
            if(Outer.MyKFPawn.Physics == 2)
            {
                Outer.WaitForLanding();
                Outer.bReevaluatePath = true;
            }
            if(Outer.bReevaluatePath)
            {
                ReEvaluatePath();                
            }
            else
            {
                if(bGoalChangedDueToSkipAhead)
                {
                    Outer.AILog_Internal("path was changed during movetoward", 'Move_Path');
                    IntermediateMoveGoal = none;
                }
            }
            if(((Pawn(Outer.MoveGoal) != none) && Outer.Pawn.ReachedDestination(IntermediateMoveGoal)) && VSizeSq(Outer.MoveGoal.Location - Outer.GetBasedPosition(LastPawnTargetPathLocation)) > 589824)
            {
                ReachedIntermediateMoveGoal();
                Outer.SetBasedPosition(LastPawnTargetPathLocation, Outer.MoveGoal.Location);
                Outer.AILog_Internal("Repathing because MoveGoal is a Pawn:" @ string(Outer.MoveGoal), 'Command_MoveToGoal');
                goto 'CheckMove';                
            }
            else
            {
                if((IntermediateMoveGoal == Outer.MoveGoal) && HasReachedMoveGoal())
                {
                    goto 'CheckMove';                    
                }
                else
                {
                    if(GetNextMoveTarget(IntermediateMoveGoal))
                    {
                        NumTimesGetNextMoveGoalReturnedSameNode = 0;                        
                    }
                    else
                    {
                        ++ NumTimesGetNextMoveGoalReturnedSameNode;
                        SetBestAnchor();
                        Outer.Sleep(0.1);
                    }
                    if((IntermediateMoveGoal == none) || (NumTimesGetNextMoveGoalReturnedSameNode > 20) && VSize(Outer.Velocity) < 8)
                    {
                        Outer.AILog_Internal((("Failed to get valid movetarget, Got Same result " $ string(NumTimesGetNextMoveGoalReturnedSameNode)) $ " time(s). has reached move goal? ") @ string(HasReachedMoveGoal()), 'PathWarning');
                        if((NumTimesGetNextMoveGoalReturnedSameNode > 20) && VSize(Outer.Velocity) < 8)
                        {
                            Outer.AILog_Internal("Got same result too many times.. bailing! Anchor: " $ string(Outer.Pawn.Anchor), 'PathWarning');
                            bValidRouteCache = false;
                            Outer.bReevaluatePath = true;
                            NumTimesGetNextMoveGoalReturnedSameNode = 0;
                            if((Outer.Pawn.Anchor != none) && (Outer.LastHitWall != none) && !Outer.LastHitWall.IsA('Pawn'))
                            {
                                if(Outer.CreateTemporaryBlockedReach(KFPathnode(IntermediateMoveGoal), Outer.CurrentPath))
                                {                                    
                                }
                            }
                            UpdateHistoryString((("[F] [GNM] " $ string(IntermediateMoveGoal)) $ " ") $ string(Outer.Pawn.Location));
                            goto 'FailedMove';
                        }
                        IntermediateMoveGoal = none;                        
                    }
                    else
                    {
                        Outer.AILog_Internal((("NextMoveTarget" @ string(IntermediateMoveGoal)) @ "MoveGoal:") @ string(Outer.MoveGoal), 'Move_Path');
                    }
                }
            }
            goto J0x17C3;
        }
        J0x2BFD:

        if(Outer.GetBasedPosition(Outer.MovePosition) != vect(0, 0, 0))
        {
            J0x2C4C:

            if(!HasReachedMoveGoal())
            {
                Outer.CurrentMovementPhase = 3;
                if(!Outer.PointReachable(Outer.GetBasedPosition(Outer.MovePosition)))
                {
                    UpdateHistoryString("[F] [!POINTREACHABLE] " $ string(Outer.Pawn.Location));
                    Outer.Sleep(0.25);
                    goto 'FailedMove';
                }
                Outer.AILog_Internal("Finishing direct move, calling MoveTo " $ string(Outer.GetBasedPosition(Outer.MovePosition)), 'Move_DirectPath');
                if(((Outer.WorldInfo.TimeSeconds - Outer.LastMoveFinishTime) > 5) && ShouldTurnToGoal(Outer.GetBasedPosition(Outer.MovePosition)))
                {
                    TurnFocalPoint = Outer.GetBasedPosition(Outer.MovePosition);
                    PushState('RotateToFocus');
                }
                Outer.MoveTo(Outer.GetBasedPosition(Outer.MovePosition), Outer.MoveFocus,, false);
                Outer.CurrentMovementPhase = 0;
                if(Outer.MyKFPawn.Physics == 2)
                {
                    Outer.WaitForLanding();
                }
                goto J0x2C4C;
            }
        }        
    }
    else
    {
        if(!HasReachedMoveGoal())
        {
            UpdateHistoryString((("[F] [NO PATH TO " $ string(Outer.MoveGoal)) $ "] ") $ string(Outer.Pawn.Location));
            if(Outer.MoveGoal != none)
            {
                Outer.AILog_Internal("Failed to find path to:" @ string(Outer.MoveGoal), 'Command_MoveToGoal');                
            }
            else
            {
                Outer.AILog_Internal("Failed to find path to:" @ string(Outer.GetBasedPosition(Outer.MovePosition)), 'PathWarning');
            }
            Outer.Sleep(0.25);
            goto 'FailedMove';
        }
    }
    goto 'CheckMove';
FailedMove:


    Outer.AILog_Internal("FailedMove Label", 'PathWarning');
    UpdateHistoryString("Failure - FailedMove Label");
    if((Outer.Pawn.bCrawler && Outer.Pawn.Floor != vect(0, 0, 1)) && Outer.Pawn.Physics == 8)
    {
        if(Retries < 5)
        {
            Outer.Pawn.SetPhysics(2);
            Outer.WaitForLanding();
            bValidRouteCache = false;
            if((Outer.bPreparingMove && Outer.PendingDoor == none) && !Outer.MyKFPawn.IsDoingSpecialMove() || !Outer.MyKFPawn.SpecialMoves[Outer.MyKFPawn.SpecialMove].bDisableMovement)
            {
                Outer.bPreparingMove = false;
            }
            Outer.bReevaluatePath = true;
            Outer.Sleep(0);
            IntermediateMoveGoal = none;
            ++ Retries;
            ReEvaluatePath();
        }        
    }
    else
    {
        if(Retries < 5)
        {
            bValidRouteCache = false;
            if((Outer.bPreparingMove && Outer.PendingDoor == none) && !Outer.MyKFPawn.IsDoingSpecialMove() || !Outer.MyKFPawn.SpecialMoves[Outer.MyKFPawn.SpecialMove].bDisableMovement)
            {
                Outer.bPreparingMove = false;
            }
            Outer.bReevaluatePath = true;
            Outer.Sleep(0);
            IntermediateMoveGoal = none;
            ++ Retries;
            ReEvaluatePath();
            Outer.Sleep(0);            
        }
        else
        {
            if((Retries >= 5) && Retries < 10)
            {
                bValidRouteCache = false;
                if((Outer.bPreparingMove && Outer.PendingDoor == none) && !Outer.MyKFPawn.IsDoingSpecialMove() || !Outer.MyKFPawn.SpecialMoves[Outer.MyKFPawn.SpecialMove].bDisableMovement)
                {
                    Outer.bPreparingMove = false;
                }
                Outer.bReevaluatePath = true;
                Outer.Sleep(0);
                if((IntermediateMoveGoal != none) && IntermediateMoveGoal.IsA('NavigationPoint'))
                {
                    if(Outer.CreateTemporaryBlockedReach(KFPathnode(IntermediateMoveGoal), Outer.CurrentPath))
                    {
                        IntermediateMoveGoal = none;
                        ++ Retries;
                        ReEvaluatePath();
                        Outer.Sleep(0);                        
                    }
                    else
                    {
                        Retries = 0;
                        Status = 'Failure';
                        GotoState('DelayFailure');
                        stop;
                    }
                }                
            }
            else
            {
                Retries = 0;
                Status = 'Failure';
                GotoState('DelayFailure');
                stop;
            }
        }
    }
    J0x3940:

    if(Outer.MoveGoal != none)
    {
        Outer.AILog_Internal(("Reached move goal:" @ string(Outer.MoveGoal)) @ string(VSize(Outer.Pawn.Location - Outer.MoveGoal.Location)), 'Command_MoveToGoal');        
    }
    else
    {
        Outer.AILog_Internal(("Reached move point:" @ string(Outer.GetBasedPosition(Outer.MovePosition))) @ string(VSize(Outer.Pawn.Location - Outer.GetBasedPosition(Outer.MovePosition))), 'Command_MoveToGoal');
    }
    Status = 'Success';
    Outer.PopCommand(self);
    stop;        
}

state DelayFailure
{Begin:

    Outer.CurrentMovementPhase = 6;
    Outer.Sleep(0.5);
    Status = 'Failure';
    Outer.CurrentMovementPhase = 0;
    Outer.PopCommand(self);
    stop;        
}

state RotateToFocus
{Begin:

    Outer.CurrentMovementPhase = 5;
    if(Outer.Pawn.Physics == 2)
    {
        Outer.WaitForLanding();
    }
    if(TurnFocalPoint != vect(0, 0, 0))
    {
        Outer.Focus = none;
        Outer.SetFocalPoint(TurnFocalPoint);        
    }
    else
    {
        Outer.SetFocalPoint(vect(0, 0, 0));
        Outer.Focus = TurnFocus;
    }
    Outer.FinishRotation();
    Outer.MyKFPawn.ResetDesiredRotation();
    TurnFocalPoint = vect(0, 0, 0);
    Outer.CurrentMovementPhase = 0;
    PopState();
    stop;                    
}

defaultproperties
{
    bCanPathfind=true
    SkipAheadUpdateThreshold=500
    SkipAheadMaxNodes=15
    SkipAheadMaxDist=4096
    SkipAheadPitCheckInterval=300
    SkipAheadPitCheckHeight=250
}