/*******************************************************************************
 * KFDominantDirectionalLightning generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDominantDirectionalLightning extends DominantDirectionalLight
    hidecategories(Navigation)
    classgroup(Lights,DirectionalLights);

var repnotify int TriggerCount;

replication
{
     if(bNetDirty)
        TriggerCount;
}

event PostBeginPlay()
{
    super(Light).PostBeginPlay();
    if(AnimationType != 4)
    {
        WarnInternal(string(self) $ ": forcing AnimationType to LightAnim_ChaoticFlicker!");
    }
    if(LightComponent != none)
    {
        LightComponent.AnimationType = 0;
        LightComponent.SetLightProperties(LightComponent.MinBrightness);
    }
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'TriggerCount')
    {
        TriggerAnimation();        
    }
    else
    {
        super(Light).ReplicatedEvent(VarName);
    }
}

simulated function TriggerAnimation()
{
    local float StartPct, StopPct, StartTime, StopTime, Duration, Pct,
	    Time, DeltaTime;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        ++ TriggerCount;        
    }
    else
    {
        LightComponent.AnimationType = 4;
        Duration = 1 / FClamp(LightComponent.AnimationFrequency, 0.01, 20);
        Time = WorldInfo.TimeSeconds % Duration;
        Pct = Time / Duration;
        DeltaTime = WorldInfo.DeltaSeconds;
        StartPct = WorldInfo.ChaoticFlickerCurve.Points[1].InVal - (DeltaTime * 2);
        StopPct = WorldInfo.ChaoticFlickerCurve.Points[WorldInfo.ChaoticFlickerCurve.Points.Length - 1].InVal + (DeltaTime * 2);
        LightComponent.AnimationTimeOffset = (StartPct - Pct) * Duration;
        StartTime = StartPct * Duration;
        StopTime = StopPct * Duration;
        Duration = StopTime - StartTime;
        Class'WorldInfo'.static.GetWorldInfo().TimerHelper.SetTimer(Duration, false, 'Timer_CleanupAnimation', self);
    }
}

function Timer_CleanupAnimation()
{
    CleanupAnimation();
}

simulated function CleanupAnimation()
{
    LightComponent.AnimationType = 0;
    LightComponent.SetLightProperties(LightComponent.MinBrightness);
}

defaultproperties
{
    LightComponent=DominantDirectionalLightComponent'Default__KFDominantDirectionalLightning.DominantDirectionalLightComponent0'
    AnimationType=ELightAnimationTechnique.LightAnim_ChaoticFlicker
    begin object name=LightMeshComponent0 class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFDominantDirectionalLightning.LightMeshComponent0'
    LightMesh=LightMeshComponent0
    begin object name=LensFlareComponent0 class=LensFlareComponent
        NextTraceTime=0.0 // Ka v oh
        ReplacementPrimitive=none
    object end
    // Reference: LensFlareComponent'Default__KFDominantDirectionalLightning.LensFlareComponent0'
    LensFlareComp=LensFlareComponent0
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFDominantDirectionalLightning.Sprite'
    Components(0)=Sprite
    begin object name=ArrowComponent0 class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFDominantDirectionalLightning.ArrowComponent0'
    Components(1)=ArrowComponent0
    Components(2)=DominantDirectionalLightComponent'Default__KFDominantDirectionalLightning.DominantDirectionalLightComponent0'
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bAlwaysRelevant=true
    begin object name=LightMeshComponent0 class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFDominantDirectionalLightning.LightMeshComponent0'
    CollisionComponent=LightMeshComponent0
}