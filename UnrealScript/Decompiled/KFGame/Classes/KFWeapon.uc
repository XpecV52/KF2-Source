/*******************************************************************************
 * KFWeapon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeapon extends Weapon
    abstract
    native
    nativereplication
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const DEFAULT_FIREMODE = 0;
const ALTFIRE_FIREMODE = 1;
const RELOAD_FIREMODE = 2;
const BASH_FIREMODE = 3;
const GRENADE_FIREMODE = 4;
const FIREMODE_NONE = 255;
const PRIMARY_AMMO = 0;
const SECONDARY_AMMO = 1;
const ReloadEmptyMagAnim = 'Reload_Empty';
const ReloadNonEmptyMagAnim = 'Reload_Half';
const ReloadEmptyMagEliteAnim = 'Reload_Empty_Elite';
const ReloadNonEmptyMagEliteAnim = 'Reload_Half_Elite';
const ReloadOpenAnim = 'Reload_Open';
const ReloadSingleAnim = 'Reload_Insert';
const ReloadOpenInsertAnim = 'Reload_Open_Shell';
const ReloadCloseAnim = 'Reload_Close';
const ReloadOpenEliteAnim = 'Reload_Open_Elite';
const ReloadSingleEliteAnim = 'Reload_Insert_Elite';
const ReloadOpenInsertEliteAnim = 'Reload_Open_Shell_Elite';
const ReloadCloseEliteAnim = 'Reload_Close_Elite';
const GrenadeThrowAnim = 'Nade_Throw';
const SprintStartAnim = 'Sprint_In';
const SprintLoopAnim = 'Sprint_Loop';
const SprintEndAnim = 'Sprint_Out';
const FireOneHandAnim = 'Shoot_OneHand';
const FireOneHandLastAnim = 'Shoot_OneHand_Last';
const BloodParamName = 'Scalar_Blood_Contrast';
const MinBloodParamValue = 0.20f;
const MaxAimAdjust_Angle = 0.1f;
const MaxAimAdjust_Cos = 0.995f;

enum EInventoryGroup
{
    IG_Primary,
    IG_Secondary,
    IG_Melee,
    IG_Equipment,
    IG_None,
    IG_MAX
};

enum EReloadStatus
{
    RS_None,
    RS_OpeningBolt,
    RS_Reloading,
    RS_ClosingBolt,
    RS_Complete,
    RS_MAX
};

struct native WeaponFireSndInfo
{
    var() AkEvent DefaultCue;
    var() AkEvent FirstPersonCue;

    structdefaultproperties
    {
        DefaultCue=none
        FirstPersonCue=none
    }
};

struct native ImpactRepInfo
{
    var Actor HitActor;
    var Vector HitLocation;
    var Vector RayDir;
    var name HitInfo_BoneName;

    structdefaultproperties
    {
        HitActor=none
        HitLocation=(X=0,Y=0,Z=0)
        RayDir=(X=0,Y=0,Z=0)
        HitInfo_BoneName=None
    }
};

struct native WeaponUpgradeInfo
{
    /** @name Weapon Upgrade System */
    var() int IncrementWeight;
    /** @name Weapon Upgrade System */
    var() float IncrementDamage;
    /** @name Weapon Upgrade System */
    var() float IncrementHeal;
    /** @name Weapon Upgrade System */
    var() float IncrementHealFullRecharge;

    structdefaultproperties
    {
        IncrementWeight=1
        IncrementDamage=1
        IncrementHeal=1
        IncrementHealFullRecharge=1
    }
};

var protected export editinline MeshComponent OverlayMesh;
var export editinline KFSkeletalMeshComponent MySkelMesh;
var const string PackageKey;
var const string FirstPersonMeshName;
var const array<string> FirstPersonAnimSetNames;
var const string FirstPersonAnimTree;
var const string PickupMeshName;
var const string AttachmentArchetypeName;
var const string MuzzleFlashTemplateName;
var bool AttachOnContentLoad;
var bool SetOnContentLoad;
var bool WeaponContentLoaded;
var bool bUseAltFireMode;
var transient bool bStopAltFireOnNextRelease;
var bool bGamepadFireEntry;
/** Target friction enabled? */
var() bool bTargetFrictionEnabled;
/** Target adhesion enabled? */
var() bool bTargetAdhesionEnabled;
var bool bUsingSights;
/** This weapon has sights to aim */
var(IronSight) bool bHasIronSights;
var bool bIronSightOnBringUp;
var bool bForceHidden;
var bool bZoomingIn;
var bool bZoomingOut;
/** Doing a "quick down" zoom */
var(IronSight) bool bDoingQuickDownZoom;
/** Don't use the ZoomInRotation for this zoom */
var(IronSight) bool bSkipZoomInRotation;
var bool bZoomInInterrupted;
var bool bZoomOutInterrupted;
var bool bFastZoomOut;
var bool bHasScopePosition;
var bool bUsingScopePosition;
var(DepthOfField) bool DOF_bOverrideEnvironmentDOF;
/** The weapon is using the sights to aim */
var(Positioning) bool bWeaponNeedsServerPosition;
/** If true, weapon position should follow camera anims played on the weapon AnimSeq */
var(Positioning) bool bFollowAnimSeqCamera;
/** If TRUE, will use system to warn AI when a player has been aiming at them for too long */
var(IronSight) protected const bool bWarnAIWhenAiming;
/** The path that locates the image for this weapon */
var(Inventory) bool bCanRefillSecondaryAmmo;
var bool bGivenAtStart;
/** Is this a no magazine/clip weapon e.g. the hunting shotgun? */
var(Inventory) bool bNoMagazine;
var(Inventory) bool bCanBeReloaded;
var(Inventory) bool bReloadFromMagazine;
var const bool bInfiniteSpareAmmo;
var bool bInfiniteAmmo;
var const bool bAllowClientAmmoTracking;
var bool bPlayingLoopingFireSnd;
var bool bPlayingLoopingFireAnim;
/** Use the animation sequence length to get equip times */
var(Animations) bool bUseAnimLenEquipTime;
/** If set, this weapon has unique shoot anims for the last round */
var(Animations) bool bHasFireLastAnims;
/** Special idle anims */
var(Animations) bool bUseAdditiveMoveAnim;
var bool bEnableTiltSkelControl;
var transient bool bCheckBoltLockPostReload;
/** @name Sounds */
var(Sounds) bool bSuppressSounds;
/** If set to true, attempting to reload will switch to best available weapon */
var() bool bPendingAutoSwitchOnDryFire;
var bool bPendingShow;
var deprecated bool bHasFlashlight;
/** Whether the weapon supports laser sights or not */
var(Attachments) bool bHasLaserSight;
var bool bIsBackupWeapon;
var config bool bLogAnimation;
var config bool bLogStates;
var bool bPauseWithPlayersOnly;
var bool bDebugRecoilPosition;
var config bool bLogAmmo;
var config bool bLogWeaponUpgrade;
var array<Texture2D> FireModeIconPaths;
var byte SingleFireSoundIndex;
/** Number of shots to fire per burst. */
var(Weapon) byte BurstAmount;
/** Determines which group a weapon falls into in weapon select */
var(Inventory) KFWeapon.EInventoryGroup InventoryGroup;
/** Inventory (In blocks) cost */
var(Inventory) byte InventorySize;
var byte AmmoCount[2];
/** Size of the weapon magazine, i.e. how many rounds it can hold */
var(Inventory) byte MagazineCapacity[2];
var KFWeapon.EReloadStatus ReloadStatus;
var byte ReloadAmountLeft;
var byte InitialReloadAmount;
var float MinFiringPutDownPct;
/** How much penetration power does this fire mode have */
var(Weapon) array<float> PenetrationPower;
/** How scale the penetration power this fire mode loses based on the percentage of penetration power left */
var(Weapon) array<InterpCurveFloat> PenetrationDamageReductionCurve;
var transient float PenetrationPowerRemaining;
var const transient float ZedTimeResistance;
/**  
 *How long after we toss a grenade before a zed can grab us.
 *  Prevents us from blowing ourselves up on grenades that we
 *  were in the middle of tossing when we got grabbed
 */
var(Weapon) float GrenadeTossWeakZedGrabCooldown;
/** Time after we are grabbed by a zed to prevent nade throwing so we don't blow ourselvs up */
var(Weapon) float ZedGrabGrenadeTossCooldown;
/** Max distance allow for friction */
var() float TargetFrictionDistanceMax;
/** Max distance to allow adhesion to still kick in */
var() float TargetAdhesionDistanceMax;
/** Adhesion scalar curve based on distance */
var() InterpCurveFloat TargetAdhesionOffsetScaleCurve;
/** Adhesion scalar curve based on angle offset to center of zed cylinder */
var() InterpCurveFloat TargetAdhesionDistanceScaleCurve;
/** Friction scalar curve based on distance */
var() InterpCurveFloat TargetFrictionOffsetScaleCurve;
/** Friction scalar curve based on angle offset to center of zed cylinder */
var() InterpCurveFloat TargetFrictionDistanceScaleCurve;
/** Aim correction - headshot offset */
var() const float AimCorrectionSize;
var KFPlayerController KFPlayer;
var Vector HiddenWeaponsOffset;
/** The default FOV to use for this weapon when not in ironsights */
var(Camera) float MeshFOV;
/** The fov to use for this weapon when in ironsights */
var(Camera) float MeshIronSightFOV;
/** The fov to use for the player when in ironsights */
var(Camera) float PlayerIronSightFOV;
/** The fov to use while in the weapon sprinting state */
var(Camera) float PlayerSprintFOV;
/** The position of the weapon when in standard ironsights position */
var(Positioning) Vector IronSightPosition;
var float ZoomTime;
/** How long the transition to iron sights should take */
var(IronSight) float ZoomInTime;
/** How long the transition from iron sights should take */
var(IronSight) float ZoomOutTime;
/** Amount to rotate to when zooming in to give the feeling of an animation playing */
var(IronSight) Rotator ZoomInRotation;
/** Amount to rotate to when doing a quick weapon put down */
var(IronSight) Rotator QuickWeaponDownRotation;
/** How long the transition to quick weapon down should take */
var(IronSight) float QuickWeaponDownTime;
/** How long the transition from quick weapon down should take */
var(IronSight) float QuickWeaponDownFinishTime;
var Rotator ZoomRotInterp;
var Vector ZoomStartOffset;
var float ZoomPartialTime;
var Rotator ZoomRotStartOffset;
var float ZoomWeaponFOVStart;
var float LastZoomOutTime;
/** How long to take to zoom out when we're doing a fast zoom out (i.e. when an action like reloading interupts ironsights) */
var(IronSight) float FastZoomOutTime;
var Vector ZoomTargetOffset;
/** The position of the weapon when looking through the scope */
var(Positioning) Vector ScopePosition;
var(DepthOfField) float DOF_SharpRadius;
var(DepthOfField) float DOF_FocalRadius;
var(DepthOfField) float DOF_MinBlurSize;
var(DepthOfField) float DOF_MaxNearBlurSize;
var(DepthOfField) float DOF_MaxFarBlurSize;
var(DepthOfField) float DOF_ExpFalloff;
var(DepthOfField) float DOF_MaxFocalDistance;
var(DepthOfField) float DOF_BlendInSpeed;
var(DepthOfField) float DOF_BlendOutSpeed;
var(DepthOfField) float DOF_FG_SharpRadius;
var(DepthOfField) float DOF_FG_FocalRadius;
var(DepthOfField) float DOF_FG_MinBlurSize;
var(DepthOfField) float DOF_FG_MaxNearBlurSize;
var(DepthOfField) float DOF_FG_ExpFalloff;
/** Holds an offest for spawning grenades. */
var(Positioning) Vector GrenadeFireOffset;
/** The maximum distance at which to warn AI, squared */
var(IronSight) protected const float MaxAIWarningDistSQ;
/** The maximum distance from the danger point that AI should be warned */
var(IronSight) protected const float MaxAIWarningDistFromPointSQ;
/** How long the weapon needs to be relatively settled before warning AI. X=MinDuration, Y=MaxDuration */
var(IronSight) protected const Vector2D AimWarningDelay;
/** How long to wait after a warning before checking if AI should be warned again */
var(IronSight) protected const float AimWarningCooldown;
var private transient Rotator LastAimRotation;
var private transient float LastAimWarningTime;
var private transient float CurrentAimSettledTime;
/** Used to place this weapon in the inventory */
var(Inventory) float GroupPriority;
/** The UI image for this weapon */
var(Inventory) Texture2D WeaponSelectTexture;
/** The path that locates the image for this weapon */
var(Inventory) Texture2D SecondaryAmmoTexture;
var float EquipAbortTime;
var class<KFWeap_DualBase> DualClass;
/** How much ammo does it take to fire this firemode? */
var(Inventory) protected array<byte> AmmoCost;
var repnotify int SpareAmmoCount[2];
/** Maximum amount of amount that can be carried for this gun, not counting what is in the magazine. Total amount this weapon can carry is SpareAmmoCapacity + MagazineCapacity */
var(Inventory) int SpareAmmoCapacity[2];
var int InitialSpareMags[2];
/** What percentage of a full single magazine capacity to give when resupplying this weapon from an ammo pickup */
var(Inventory) float AmmoPickupScale[2];
var int InitialReloadSpareAmmo;
var transient float LastReloadAbortTime;
/** How long to wait after firing to force reload */
var() float ForceReloadTimeOnEmpty;
var array<CameraAnim> FireCameraAnim;
/** How much to scale the FireCameraAnim when in ironsights */
var(Camera) float ShakeScaleSighted;
/** Controller rumble to play when firing. */
var(Camera) float ShakeScaleStandard;
var ForceFeedbackWaveform WeaponFireWaveForm;
var KFAnimSeq_Tween WeaponAnimSeqNode;
var AnimNodeAdditiveBlending IdleBobBlendNode;
var AnimNodeBlendPerBone EmptyMagBlendNode;
/** Loop settings per firemode */
var(Animations) array<bool> bLoopingFireAnim;
var(Sounds) array<bool> bLoopingFireSnd;
/** How much tweening to use on fire animations */
var(Animations) float FireTweenTime;
/** Animations to play when the weapon is fired */
var(Animations) const editconst name FireAnim;
/** Animation to play when the weapon is fired and bLoopingFireAnim is true */
var(Animations) const editconst name FireLoopAnim;
/** Animation to play when the last shot if fired */
var(Animations) const editconst name FireLastAnim;
/** Animation to play when the weapon is Put Down */
var(Animations) const editconst name PutDownAnim;
/** Animation to play when the weapon is Equipped */
var(Animations) const editconst name EquipAnim;
/** Animation to play when the weapon is idle */
var(Animations) const editconst array<editconst name> IdleAnims;
var(Animations) const editconst array<editconst name> IdleFidgetAnims;
var transient float LastIdleFidgetAnimTime;
/** Animation to play when the weapon is fired */
var(Animations) const editconst array<editconst name> FireSightedAnims;
/** Animation to play when the weapon is fired and bLoopingFireAnim is true */
var(Animations) const editconst name FireLoopSightedAnim;
/** Animation to play when the last shot if fired */
var(Animations) const editconst name FireLastSightedAnim;
/** Animation to play when idling */
var(Animations) editconst array<editconst name> IdleSightedAnims;
/** Animation to play at the end of a looping fire anim */
var(Animations) const editconst name FireLoopStartAnim;
/** Animation to play at the end of a looping fire anim */
var(Animations) const editconst name FireLoopStartSightedAnim;
/** Animation to play at the end of a looping fire anim */
var(Animations) const editconst name FireLoopEndAnim;
/** Animation to play at the end of a looping fire anim */
var(Animations) const editconst name FireLoopEndSightedAnim;
/** Animation to play when the weapon is fired */
var(Animations) const editconst name FireScopedAnim;
/** Animation to play when the weapon is fired and bLoopingFireAnim is true */
var(Animations) const editconst name FireLoopScopedAnim;
/** Animation to play when the last shot if fired */
var(Animations) const editconst name FireLastScopedAnim;
var array<name> MeleeAttackAnims;
/** Camera anim played when sprinting */
var(Camera) CameraAnim SprintCameraAnim;
var transient CameraAnimInst SprintCameraAnimInst;
var transient float SprintAnimRate;
var array<name> BonesToLockOnEmpty;
/** Sound to play when the weapon is fired */
var(Sounds) array<WeaponFireSndInfo> WeaponFireSnd;
/** sound to play when the weapon stops fired. Used for high ROF weapons that have a looping fire sound */
var(Sounds) array<WeaponFireSndInfo> WeaponFireLoopEndSnd;
/** sound to play when the weapon is dry fired */
var(Sounds) array<AkBaseSoundObject> WeaponDryFireSnd;
/** How much to damp view bob */
var(Motion) float BobDamping;
/** How much to damp jump and land bob */
var(Motion) float JumpDamping;
/** Offset from view center */
var(Positioning) Vector PlayerViewOffset;
var array<MaterialInstanceConstant> WeaponMICs;
var int NumBloodMapMaterials;
var float BloodParamValue;
var const config int SkinItemId;
var Vector WeaponLag;
var float LagHorizontal;
var float LagVertical;
var float LagVelocityHorizontal;
var float LagVelocityVertical;
/** Weapon Lag calculations for when the pawn's accelleration changes, or the pawn turns. Affects spring LagTensionHorizontal and dampening. */
var(Motion) float LagTensionHorizontal;
var(Motion) float LagVerticalTension;
/** Weapon LagResistanceHorizontal/Vertical represents how much the gun does not want to move at all, affects dampening. */
var(Motion) float LagResistanceHorizontal;
var(Motion) float LagResistanceVertical;
/** the maximum offset/lag that the weapon should lag when moving around */
var(Motion) float LagLimit;
/** A constant that converts yaw velocity to linear velocity to be used in calculating weapon-lag */
var(Motion) float LagYawCoefficient;
/** Weapon Lag State Properties Dynamic Lag tension modifiers. Effectively, these Strength values are multiplied into the tension based on the pawn's state. */
var(Motion) float LagStrengthIronSights;
var(Motion) float LagStrengthCrouch;
var(Motion) float LagStrengthWalk;
var(Motion) float LagStrengthJog;
var(Motion) float LagStrengthSprint;
var float StrafeLag;
var float StrafeLagVelocity;
/** The maximum horizontal offset from center */
var(Motion) float StrafeLagLimit;
/** Rate at which momentum changes should affect Strafe lagging */
var(Motion) float StrafeLagRate;
/** Rate at which weapon should return to normal after straffing. */
var(Motion) float StrafeLagReturnRate;
var int AimYawSpeed;
var int AimPitchSpeed;
/** The class of the third person attachment to spawn */
var(Attachments) KFWeaponAttachment AttachmentArchetype;
/** Object within weapon that manages melee attacks */
var(Weapon) export editinline KFMeleeHelperWeapon MeleeAttackHelper;
var KFMuzzleFlash MuzzleFlash;
/** A reference to the muzzle flash template */
var(Attachments) const KFMuzzleFlash MuzzleFlashTemplate;
/** How long ejected shells should stay in the foreground until changing to world depth */
var(Attachments) const float EjectedShellForegroundDuration;
var transient KFLaserSightAttachment LaserSight;
/** A reference to the laser sight template */
var(Attachments) const KFLaserSightAttachment LaserSightTemplate;
var float LastPelletFireTime;
/** Amount to scale spread when moving and shooting. Set this to something greater than 1.0 if you want to have added spread while moving. KF1 did not have this */
var(Weapon) float MovingSpreadMod;
/** Amount to scale spread when using ironsights */
var(Weapon) float IronSightsSpreadMod;
/** Amount to scale spread when Crouched */
var(Weapon) float CrouchSpreadMod;
/** max vertical units a weapon muzzle will climb from recoil */
var(Recoil) int maxRecoilPitch;
/** min vertical units a weapon muzzle will climb from recoil */
var(Recoil) int minRecoilPitch;
/** max horizontal units a weapon muzzle will move from recoil */
var(Recoil) int maxRecoilYaw;
/** min horizontal units a weapon muzzle will move from recoil */
var(Recoil) int minRecoilYaw;
/** Time in seconds each recoil should take to be applied. Must be less than the fire rate or the full recoil wont be applied */
var(Recoil) float RecoilRate;
/** What percentage of the RecoilSpeed it will take to blend recoil out */
var(Recoil) float RecoilBlendOutRatio;
/** What percentage of recoil to apply to the view rotation when firing */
var(Recoil) float RecoilViewRotationScale;
/** Scales how much effect the players rotation input (from mouse/gamepad) has on reducing the total recoil (the first person weapon model's recoil) */
var(Recoil) float RecoilCompensationScale;
/** At what percentage the weapon is recoiled torwards the Max or Min Pitch limit to start blending to full view rotation recoil */
var(Recoil) float FullRecoilPitchPct;
/** At what percentage the weapon is recoiled torwards the Max or Min Yaw limit to start blending to full view rotation recoil */
var(Recoil) float FullRecoilYawPct;
/** Maximum yaw rotation of the weapon from recoil before the player's view moves */
var(Recoil) int RecoilMaxYawLimit;
/** Minimum yaw rotation of the weapon from recoil before the player's view moves */
var(Recoil) int RecoilMinYawLimit;
/** Maximum pitch rotation of the weapon from recoil before the player's view moves */
var(Recoil) int RecoilMaxPitchLimit;
/** Minimum pitch rotation of the weapon from recoil before the player's view moves */
var(Recoil) int RecoilMinPitchLimit;
/** Maximum yaw rotation of the weapon from recoil before the player's view moves when using Iron sights */
var(Recoil) int RecoilISMaxYawLimit;
/** Minimum yaw rotation of the weapon from recoil before the player's view moves when using Iron sights */
var(Recoil) int RecoilISMinYawLimit;
/** Maximum pitch rotation of the weapon from recoil before the player's view moves when using Iron sights */
var(Recoil) int RecoilISMaxPitchLimit;
/** Minimum pitch rotation of the weapon from recoil before the player's view moves when using Iron sights */
var(Recoil) int RecoilISMinPitchLimit;
var Rotator RecoilRotator;
var Rotator TotalRecoilRotator;
var float RecoilTimeLeft;
var float RecoilSpeed;
var int RecoilYawBlendOutRate;
var int RecoilPitchBlendOutRate;
var float RecoilPitchPercentage;
var float RecoilYawPercentage;
var Rotator SuppressRecoilRotator;
var float SuppressRecoilTimeLeft;
/** The amount of time it will take to process this suppression recoil */
var(Recoil) float SuppressRecoilSpeed;
/** The percentage of the suppression recoil to apply to the player's view */
var(Recoil) float SuppressRecoilViewRotationScale;
/** Recoil modifier for when the player is holding the weapon in the hipped position */
var(Recoil) float HippedRecoilModifier;
/** Recoil modifier for when the player is jogging and shooting */
var(Recoil) float JoggingRecoilModifier;
/** Recoil modifier for when the player is walking and shooting */
var(Recoil) float WalkingRecoilModifier;
/** Recoil modifier for falling player stance */
var(Recoil) float FallingRecoilModifier;
/** Recoil modifier for crouched */
var(Recoil) float StanceCrouchedRecoilModifier;
var float LastRecoilModifier;
/**  
 *Used to compensate for weapons that have an ironsight mesh FOV that is different
 * Than the player's world FOV. When these mismatch, it causes the recoil
 * rotation to mismatch as well. Use this value to get them back in sync.
 */
var(Recoil) float IronSightMeshFOVCompensationScale;
var(Weapon) protected array< class<KFPerk> > AssociatedPerkClasses;
var array<WeaponUpgradeInfo> WeaponUpgrades;
var int CurrentWeaponUpgradeIndex;

replication
{
     if(bNetDirty && bNetInitial || !bAllowClientAmmoTracking)
        AmmoCount;

     if(bNetDirty)
        CurrentWeaponUpgradeIndex, MagazineCapacity, 
        SpareAmmoCapacity, SpareAmmoCount, 
        bGivenAtStart;
}

// Export UKFWeapon::execEnsureWeaponOverlayComponentLast(FFrame&, void* const)
native function EnsureWeaponOverlayComponentLast();

// Export UKFWeapon::execWeaponProcessViewRotation(FFrame&, void* const)
native function WeaponProcessViewRotation(PlayerController PC, float DeltaTime, out Rotator DeltaRot);

// Export UKFWeapon::execGetPerk(FFrame&, void* const)
native function KFPerk GetPerk();

// Export UKFWeapon::execSetZedTimeResist(FFrame&, void* const)
native function SetZedTimeResist(float ResistPct);

// Export UKFWeapon::execClearZedTimeResist(FFrame&, void* const)
native function ClearZedTimeResist();

simulated function bool HasAlwaysOnZedTimeResist()
{
    return false;
}

simulated event PreBeginPlay()
{
    super(Actor).PreBeginPlay();
    MySkelMesh = KFSkeletalMeshComponent(Mesh);
    if(MySkelMesh == none)
    {
        WarnInternal("A Invalid KFSkeletalMeshComponent(Mesh) cast!!!");
    }
    WeaponAnimSeqNode = KFAnimSeq_Tween(GetWeaponAnimNodeSeq());
    InitializeAmmo();
    InitializeEquipTime();
    if((RecoilRate > float(0)) && RecoilBlendOutRatio > float(0))
    {
        RecoilYawBlendOutRate = int((float(maxRecoilYaw) / RecoilRate) * RecoilBlendOutRatio);
        RecoilPitchBlendOutRate = int((float(maxRecoilPitch) / RecoilRate) * RecoilBlendOutRatio);
    }
}

function SetShownInInventory(bool bValue);

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    WeaponAnimSeqNode = KFAnimSeq_Tween(SkelComp.FindAnimNode('WeaponSeq'));
    if(WeaponAnimSeqNode == none)
    {
        WeaponAnimSeqNode = KFAnimSeq_Tween(GetWeaponAnimNodeSeq());
    }
    IdleBobBlendNode = AnimNodeAdditiveBlending(SkelComp.FindAnimNode('IdleBobAdditiveBlend'));
    ToggleAdditiveBobAnim(false, 0);
    EmptyMagBlendNode = AnimNodeBlendPerBone(SkelComp.FindAnimNode('EmptyMagBlend'));
    if((EmptyMagBlendNode != none) && BonesToLockOnEmpty.Length > 0)
    {
        BuildEmptyMagNodeWeightList(EmptyMagBlendNode, BonesToLockOnEmpty);
    }
    if(bHasLaserSight)
    {
        AttachLaserSight();
    }
}

// Export UKFWeapon::execBuildEmptyMagNodeWeightList(FFrame&, void* const)
native function BuildEmptyMagNodeWeightList(AnimNodeBlendPerBone EmptyNode, const out array<name> BonesToLock);

simulated event InitializeEquipTime()
{
    EquipTime = ((EquipTime > float(0)) ? EquipTime : 0.01);
    PutDownTime = ((PutDownTime > float(0)) ? PutDownTime : 0.01);
    if(bUseAnimLenEquipTime && WeaponContentLoaded)
    {
        EquipTime = MySkelMesh.GetAnimInterruptTime(EquipAnim);
        PutDownTime = MySkelMesh.GetAnimLength(PutDownAnim);
    }
}

simulated function InitFOV(float SizeX, float SizeY, float DefaultPlayerFOV)
{
    local float DummyParam;

    MeshFOV = Class'KFPlayerController'.static.CalcFOVForAspectRatio(default.MeshFOV, SizeX, SizeY, DummyParam);
    MeshIronSightFOV = Class'KFPlayerController'.static.CalcFOVForAspectRatio(default.MeshIronSightFOV, SizeX, SizeY, DummyParam);
    PlayerIronSightFOV = Class'KFPlayerController'.static.CalcFOVForAspectRatio(default.PlayerIronSightFOV, SizeX, SizeY, DummyParam);
    PlayerSprintFOV = Class'KFPlayerController'.static.CalcFOVForAspectRatio(default.PlayerSprintFOV, SizeX, SizeY, DummyParam);
    if(DefaultPlayerFOV > PlayerSprintFOV)
    {
        PlayerSprintFOV = DefaultPlayerFOV;
    }
    if(bUsingSights)
    {
        SetFOV(MeshIronSightFOV);        
    }
    else
    {
        SetFOV(MeshFOV);
    }
    if(bLogAnimation)
    {
        LogInternal((("PlayerIronSightFOV = " $ string(PlayerIronSightFOV)) $ " default POV = ") $ string(default.PlayerIronSightFOV));
    }
    if(bLogAnimation)
    {
        LogInternal((("SprintFOV = " $ string(PlayerSprintFOV)) $ " default POV = ") $ string(default.PlayerSprintFOV));
    }
}

// Export UKFWeapon::execClientSetFirstPersonSkin(FFrame&, void* const)
private reliable client native final simulated function ClientSetFirstPersonSkin(int ItemId);

// Export UKFWeapon::execServerUpdateWeaponSkin(FFrame&, void* const)
private reliable server native final event ServerUpdateWeaponSkin(int ItemId);

// Export UKFWeapon::execClearSkinItemId(FFrame&, void* const)
private native final function ClearSkinItemId();

// Export UKFWeapon::execTriggerAsyncContentLoad(FFrame&, void* const)
native static simulated function TriggerAsyncContentLoad();

// Export UKFWeapon::execStartLoadWeaponContent(FFrame&, void* const)
private native final function StartLoadWeaponContent();

// Export UKFWeapon::execLoadWeaponContent(FFrame&, void* const)
private native final function LoadWeaponContent();

function GivenTo(Pawn thisPawn, optional bool bDoNotActivate)
{
    super(Inventory).GivenTo(thisPawn, bDoNotActivate);
    if(!Instigator.IsLocallyControlled())
    {
        ClearSkinItemId();
    }
    if((Role == ROLE_Authority) && !WeaponContentLoaded)
    {
        StartLoadWeaponContent();
    }
    KFInventoryManager(InvManager).AddCurrentCarryBlocks(GetModifiedWeightValue());
    KFPawn(Instigator).NotifyInventoryWeightChanged();
}

reliable client simulated function ClientGivenTo(Pawn NewOwner, bool bDoNotActivate)
{
    if((Role != ROLE_Authority) && !WeaponContentLoaded)
    {
        StartLoadWeaponContent();
    }
    super.ClientGivenTo(NewOwner, bDoNotActivate);
}

function ItemRemovedFromInvManager()
{
    local KFInventoryManager KFIM;

    super.ItemRemovedFromInvManager();
    KFIM = KFInventoryManager(InvManager);
    if(KFIM == none)
    {
        return;
    }
    if(KFIM.bLogInventory)
    {
        LogInternal((((((string(self) @ "-") @ string(GetFuncName())) @ "- CurrentCarryBlocks:") @ string(KFIM.CurrentCarryBlocks)) @ "ModifiedWeightValue:") @ string(GetModifiedWeightValue()));
    }
    KFIM.AddCurrentCarryBlocks(-GetModifiedWeightValue());
    KFPawn(Instigator).NotifyInventoryWeightChanged();
}

reliable client simulated function ClientWeaponSet(bool bOptionalSet, optional bool bDoNotActivate)
{
    if(WeaponContentLoaded)
    {
        SetWeapon();
    }
    SetOnContentLoad = true;
    super.ClientWeaponSet(bOptionalSet, bDoNotActivate);
}

simulated event SetWeapon()
{
    local PlayerController PC;
    local int I;

    if(((Instigator != none) && InvManager != none) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        PC = PlayerController(Instigator.Controller);
        if((PC != none) && PC.myHUD != none)
        {
            InitFOV(PC.myHUD.SizeX, PC.myHUD.SizeY, PC.DefaultFOV);
        }
        if(SkinItemId > 0)
        {
            ClientSetFirstPersonSkin(SkinItemId);
        }
        I = 0;
        J0x16C:

        if(I < NumBloodMapMaterials)
        {
            WeaponMICs.AddItem(Mesh.CreateAndSetMaterialInstanceConstant(I);
            ++ I;
            goto J0x16C;
        }
    }
}

simulated event TriggerAttachment()
{
    Activate();
}

simulated function AttachWeaponTo(SkeletalMeshComponent MeshCpnt, optional name SocketName)
{
    local KFPawn KFP;
    local int I;

    if(!WeaponContentLoaded)
    {
        return;
    }
    KFP = KFPawn(Instigator);
    if((KFP != none) && KFP.ArmsMesh != none)
    {
        KFP.ArmsMesh.SetParentAnimComponent(MySkelMesh);
        KFP.ArmsMesh.SetFOV(MySkelMesh.FOV);
        I = 0;
        J0xFD:

        if(I < 3)
        {
            if(KFP.FirstPersonAttachments[I] != none)
            {
                if(SkeletalMeshComponent(KFP.FirstPersonAttachments[I]) != none)
                {
                    SkeletalMeshComponent(KFP.FirstPersonAttachments[I]).SetParentAnimComponent(MySkelMesh);
                    SkeletalMeshComponent(KFP.FirstPersonAttachments[I]).SetLODParent(MySkelMesh);
                }
                if(KFSkeletalMeshComponent(KFP.FirstPersonAttachments[I]) != none)
                {
                    KFSkeletalMeshComponent(KFP.FirstPersonAttachments[I]).SetFOV(MySkelMesh.FOV);
                }
            }
            ++ I;
            goto J0xFD;
        }
    }
    if(Instigator.IsFirstPerson())
    {
        if(KFP.AllowFirstPersonPreshadows())
        {
            Mesh.bAllowPerObjectShadows = true;            
        }
        else
        {
            Mesh.bAllowPerObjectShadows = false;
        }
        AttachComponent(Mesh);
        EnsureWeaponOverlayComponentLast();
        SetHidden(true);
        bPendingShow = true;
        if(KFP != none)
        {
            SetMeshLightingChannels(KFP.PawnLightingChannel);
            if(KFP.ArmsMesh != none)
            {
                Mesh.SetShadowParent(KFP.ArmsMesh);
                AttachComponent(KFP.ArmsMesh);
                I = 0;
                J0x444:

                if(I < 3)
                {
                    if(KFP.FirstPersonAttachments[I] != none)
                    {
                        AttachComponent(KFP.FirstPersonAttachments[I]);
                    }
                    ++ I;
                    goto J0x444;
                }
            }
        }        
    }
    else
    {
        if(bWeaponNeedsServerPosition && (WorldInfo.NetMode == NM_DedicatedServer) || (WorldInfo.NetMode == NM_ListenServer) && !Instigator.IsLocallyControlled())
        {
            AttachComponent(Mesh);
            EnsureWeaponOverlayComponentLast();
            SetHidden(true);
            bPendingShow = true;            
        }
        else
        {
            SetHidden(true);
            if(KFP != none)
            {
                KFP.ArmsMesh.SetHidden(true);
                I = 0;
                J0x5DF:

                if(I < 3)
                {
                    if(KFP.FirstPersonAttachments[I] != none)
                    {
                        KFP.FirstPersonAttachments[I].SetHidden(true);
                    }
                    ++ I;
                    goto J0x5DF;
                }
            }
        }
    }
    if(KFP != none)
    {
        AttachThirdPersonWeapon(KFP);
    }
}

function AttachThirdPersonWeapon(KFPawn P)
{
    if(Role == ROLE_Authority)
    {
        P.WeaponAttachmentTemplate = AttachmentArchetype;
        if(P.IsHumanControlled())
        {
            ServerUpdateWeaponSkin(SkinItemId);
        }
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            P.WeaponAttachmentChanged();
        }
    }
}

simulated function DetachWeapon()
{
    local KFPawn KFP;
    local int I;

    DetachComponent(Mesh);
    if(OverlayMesh != none)
    {
        DetachComponent(OverlayMesh);
    }
    KFP = KFPawn(Instigator);
    if((Role == ROLE_Authority) && KFP != none)
    {
        if(KFP.WeaponAttachmentTemplate == AttachmentArchetype)
        {
            KFP.WeaponAttachmentTemplate = none;
            if(WorldInfo.NetMode != NM_DedicatedServer)
            {
                KFP.WeaponAttachmentChanged();
            }
        }
    }
    if((KFP != none) && KFP.ArmsMesh != none)
    {
        DetachComponent(KFP.ArmsMesh);
        I = 0;
        J0x173:

        if(I < 3)
        {
            if(KFP.FirstPersonAttachments[I] != none)
            {
                DetachComponent(KFP.FirstPersonAttachments[I]);
            }
            ++ I;
            goto J0x173;
        }
    }
    SetBase(none);
    SetHidden(true);
    DetachMuzzleFlash();
}

simulated function DetachMuzzleFlash()
{
    if((MySkelMesh != none) && MuzzleFlash != none)
    {
        MuzzleFlash.DetachMuzzleFlash(MySkelMesh);
        MuzzleFlash = none;
    }
}

simulated function AttachLaserSight()
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if((((MySkelMesh != none) && LaserSight == none) && bHasLaserSight) && LaserSight == none)
    {
        LaserSight = new (self) Class'KFLaserSightAttachment' (LaserSightTemplate);
        LaserSight.AttachLaserSight(MySkelMesh, true);
    }
}

function DropFrom(Vector StartLocation, Vector StartVelocity)
{
    local DroppedPickup P;

    StartLocation.Z += (Instigator.BaseEyeHeight / float(2));
    if(!CanThrow())
    {
        return;
    }
    if((DroppedPickupClass == none) || DroppedPickupMesh == none)
    {
        Destroy();
        return;
    }
    P = Spawn(DroppedPickupClass,,, StartLocation,,, true);
    if(P == none)
    {
        PlayerController(Instigator.Controller).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 21);
        return;
    }
    if((Instigator != none) && Instigator.InvManager != none)
    {
        Instigator.InvManager.RemoveFromInventory(self);
        if(Instigator.IsAliveAndWell() && !Instigator.InvManager.bPendingDelete)
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayDropWeaponDialog(KFPawn(Instigator));
            }
        }
    }
    SetupDroppedPickup(P, StartVelocity);
    Instigator = none;
    GotoState('None');
    AIController = none;
}

function SetupDroppedPickup(out DroppedPickup P, Vector StartVelocity)
{
    P.SetPhysics(2);
    P.Inventory = self;
    P.InventoryClass = Class;
    P.Velocity = StartVelocity;
    P.Instigator = Instigator;
    P.SetPickupMesh(DroppedPickupMesh);
    P.SetPickupParticles(DroppedPickupParticles);
}

function SetOriginalValuesFromPickup(KFWeapon PickedUpWeapon)
{
    local byte I;
    local KFWeapon KFWInv;

    if(PickedUpWeapon.CurrentWeaponUpgradeIndex > -1)
    {
        SetWeaponUpgradeLevel(PickedUpWeapon.CurrentWeaponUpgradeIndex);
        KFInventoryManager(InvManager).AddCurrentCarryBlocks(WeaponUpgrades[CurrentWeaponUpgradeIndex].IncrementWeight);
        KFPawn(Instigator).NotifyInventoryWeightChanged();
    }
    I = 0;
    J0xD2:

    if(I < 2)
    {
        AmmoCount[I] = PickedUpWeapon.AmmoCount[I];
        ++ I;
        goto J0xD2;
    }
    SpareAmmoCount[0] = PickedUpWeapon.SpareAmmoCount[0];
    if(DualClass != none)
    {
        foreach KFInventoryManager(InvManager).InventoryActors(Class'KFWeapon', KFWInv)
        {
            if(KFWInv.Class == DualClass)
            {
                KFWInv.AmmoCount[0] -= byte(default.MagazineCapacity[0] - AmmoCount[0]);
                KFWInv.AmmoCount[1] -= byte(default.MagazineCapacity[1] - AmmoCount[1]);
                KFWInv.SpareAmmoCount[0] -= ((default.InitialSpareMags[0] * default.MagazineCapacity[0]) - SpareAmmoCount[0]);
                KFWInv.SpareAmmoCount[0] = Min(KFWInv.SpareAmmoCount[0], KFWInv.SpareAmmoCapacity[0]);
                KFWInv.ClientForceAmmoUpdate(KFWInv.AmmoCount[0], KFWInv.SpareAmmoCount[0]);
                KFWInv.ClientForceSecondaryAmmoUpdate(KFWInv.AmmoCount[1]);
                KFWInv.bGivenAtStart = PickedUpWeapon.bGivenAtStart;                
                return;
            }            
        }        
    }
    if(PickedUpWeapon.SkinItemId > 0)
    {
        ClientSetFirstPersonSkin(PickedUpWeapon.SkinItemId);
    }
    ClientForceAmmoUpdate(AmmoCount[0], SpareAmmoCount[0]);
    ClientForceSecondaryAmmoUpdate(AmmoCount[1]);
    bGivenAtStart = PickedUpWeapon.bGivenAtStart;
}

function bool DenyPickupQuery(class<Inventory> ItemClass, Actor Pickup)
{
    local bool bDenyPickUp;
    local KFPlayerController KFPC;

    if(ItemClass == Class)
    {
        if((CanRefillSecondaryAmmo()) && !Pickup.IsA('Projectile'))
        {
            bDenyPickUp = ((SpareAmmoCount[0] + MagazineCapacity[0]) >= (GetMaxAmmoAmount(0))) && AmmoCount[1] >= MagazineCapacity[1];            
        }
        else
        {
            bDenyPickUp = (SpareAmmoCount[0] + MagazineCapacity[0]) >= (GetMaxAmmoAmount(0));
        }
        if(bDenyPickUp)
        {
            KFPC = KFPlayerController(Instigator.Controller);
            if(KFPC != none)
            {
                KFPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', ((MagazineCapacity[0] == 0) ? 16 : 14));
            }
        }
    }
    return bDenyPickUp;
}

function NotifyPickedUp()
{
    ClientNotifyPickedUp();
}

reliable client simulated function ClientNotifyPickedUp()
{
    local KFPlayerController KFPC;
    local KFGFxMenu_Trader TraderMenu;

    KFPC = KFPlayerController(Instigator.Controller);
    if(KFPC != none)
    {
        if(KFPC.MyGFxManager != none)
        {
            TraderMenu = KFGFxMenu_Trader(KFPC.MyGFxManager.CurrentMenu);
            if(TraderMenu != none)
            {
                TraderMenu.GiveExternalWeapon(self);
            }
        }
    }
}

static simulated function bool DenyPerkResupply()
{
    return default.InventoryGroup >= 3;
}

static simulated function bool IsMeleeWeapon()
{
    return default.bMeleeWeapon;
}

simulated function float GetWeaponRating()
{
    if(!Instigator.IsHumanControlled() || !HasAnyAmmo())
    {
        return super.GetWeaponRating();
    }
    return GroupPriority;
}

simulated event Tick(float DeltaTime)
{
    if(LaserSight != none)
    {
        LaserSight.Update(DeltaTime, self);
    }
}

simulated event SetFOV(float NewFOV)
{
    local KFPawn KFP;
    local int I;

    if(MySkelMesh != none)
    {
        MySkelMesh.super(KFWeapon).SetFOV(NewFOV);
    }
    if(MuzzleFlash != none)
    {
        MuzzleFlash.SetFOV(NewFOV);
    }
    KFP = KFPawn(Instigator);
    if((KFP != none) && KFP.ArmsMesh.ParentAnimComponent == MySkelMesh)
    {
        if(KFP.ArmsMesh != none)
        {
            KFP.ArmsMesh.super(KFWeapon).SetFOV(NewFOV);
            I = 0;
            J0x148:

            if(I < 3)
            {
                if(KFP.FirstPersonAttachments[I] != none)
                {
                    if(KFSkeletalMeshComponent(KFP.FirstPersonAttachments[I]) != none)
                    {
                        KFSkeletalMeshComponent(KFP.FirstPersonAttachments[I]).super(KFWeapon).SetFOV(NewFOV);
                    }
                }
                ++ I;
                goto J0x148;
            }
        }
    }
    if(bHasLaserSight && LaserSight != none)
    {
        LaserSight.SetMeshFOV(NewFOV);
    }
}

simulated function SetIronSights(bool bNewIronSights)
{
    if(bUsingSights == bNewIronSights)
    {
        return;
    }
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    if(bUsingSights)
    {
        PerformZoom(false);        
    }
    else
    {
        if(AllowIronSights())
        {
            PerformZoom(true);
        }
    }
}

simulated function bool AllowIronSights()
{
    if(!bHasIronSights)
    {
        return false;
    }
    return true;
}

simulated function EnableIronSightsDoF(bool bEnableDOF)
{
    local KFPlayerController PC;

    if(Instigator != none)
    {
        PC = KFPlayerController(Instigator.Controller);
        if(PC != none)
        {
            PC.EnableIronSights(bEnableDOF);
            PC.EnableDepthOfField(bEnableDOF);
        }
    }
}

simulated function EnablePlayerZoom(bool bEnableZoom)
{
    local KFPlayerController PC;

    if(Instigator != none)
    {
        PC = KFPlayerController(Instigator.Controller);
        if(PC != none)
        {
            if(bEnableZoom)
            {
                PC.StartAutoTargeting();
                PC.HandleTransitionFOV(PlayerIronSightFOV, ZoomTime);                
            }
            else
            {
                PC.HandleTransitionFOV(PC.DefaultFOV, ZoomTime);
            }
        }
    }
}

simulated function PerformZoom(bool bZoomStatus, optional bool bAnimateTransition)
{
    bAnimateTransition = true;
    if(bZoomStatus)
    {
        if(Instigator.Physics == 2)
        {
            return;
        }
        ZoomIn(bAnimateTransition, default.ZoomInTime);
        if(bUsingSights && Role < ROLE_Authority)
        {
            ServerZoomIn(bAnimateTransition);
        }        
    }
    else
    {
        ZoomOut(bAnimateTransition, default.ZoomOutTime);
        if(!bUsingSights && Role < ROLE_Authority)
        {
            ServerZoomOut(bAnimateTransition);
        }
    }
}

simulated function ZoomIn(bool bAnimateTransition, float ZoomTimeToGo)
{
    if(bAnimateTransition)
    {
        ZoomInTime = ZoomTimeToGo;
        if(bZoomingOut)
        {
            bZoomingOut = false;
            bZoomOutInterrupted = true;
            ZoomTime = ZoomInTime - ZoomTime;
            ZoomPartialTime = ZoomTime;
            ZoomStartOffset = PlayerViewOffset;
            ZoomRotStartOffset = ZoomRotInterp;            
        }
        else
        {
            ZoomTime = ZoomInTime;
            ZoomStartOffset = PlayerViewOffset;
        }
        if(bHasScopePosition && bUsingScopePosition)
        {
            ZoomTargetOffset = ScopePosition;            
        }
        else
        {
            ZoomTargetOffset = IronSightPosition;
        }
        if(MySkelMesh != none)
        {
            ZoomWeaponFOVStart = MySkelMesh.FOV;            
        }
        else
        {
            ZoomWeaponFOVStart = MeshFOV;
        }
        bZoomingIn = true;
    }
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        EnablePlayerZoom(true);
        EnableIronSightsDoF(true);
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayIronsightsDialog(KFPawn(Instigator));
        }
    }
    if((bWarnAIWhenAiming && Instigator != none) && WorldInfo.NetMode != NM_Client)
    {
        LastAimWarningTime = 0;
        CurrentAimSettledTime = 0;
        LastAimRotation = GetAdjustedAim(Instigator.GetWeaponStartTraceLocation());
        SetTimer(0.1, true, 'Timer_CheckForAIWarning');
    }
    bUsingSights = true;
}

private reliable server final function ServerZoomIn(bool bAnimateTransition)
{
    ZoomIn(bAnimateTransition, default.ZoomInTime);
}

simulated function ZoomOut(bool bAnimateTransition, float ZoomTimeToGo)
{
    if(bAnimateTransition)
    {
        ZoomOutTime = ZoomTimeToGo;
        if(bZoomingIn)
        {
            bZoomingIn = false;
            bZoomInInterrupted = true;
            ZoomTime = ZoomOutTime - ZoomTime;
            ZoomPartialTime = ZoomTime;
            ZoomStartOffset = PlayerViewOffset;
            ZoomRotStartOffset = ZoomRotInterp;            
        }
        else
        {
            ZoomTime = ZoomOutTime;
            ZoomStartOffset = PlayerViewOffset;
        }
        bZoomingOut = true;        
    }
    else
    {
        bFastZoomOut = true;
        if(bZoomingIn)
        {
            bZoomingIn = false;
            bZoomInInterrupted = true;
            ZoomTime = default.ZoomOutTime - ZoomTime;
            ZoomPartialTime = ZoomTime;
            ZoomStartOffset = PlayerViewOffset;
            ZoomRotStartOffset = ZoomRotInterp;            
        }
        else
        {
            ZoomTime = FastZoomOutTime;
            ZoomStartOffset = PlayerViewOffset;
        }
        bZoomingOut = true;
        LastZoomOutTime = WorldInfo.TimeSeconds + ZoomTime;
    }
    ZoomTargetOffset = default.PlayerViewOffset;
    if(MySkelMesh != none)
    {
        ZoomWeaponFOVStart = MySkelMesh.FOV;        
    }
    else
    {
        ZoomWeaponFOVStart = MeshIronSightFOV;
    }
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        EnableIronSightsDoF(false);
        EnablePlayerZoom(false);
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.StopBreathingDialog(KFPawn(Instigator));
        }
    }
    if(bWarnAIWhenAiming && WorldInfo.NetMode != NM_Client)
    {
        ClearTimer('Timer_CheckForAIWarning');
    }
    bUsingSights = false;
}

private reliable server final function ServerZoomOut(bool bAnimateTransition)
{
    ZoomOut(bAnimateTransition, default.ZoomOutTime);
}

simulated event OnZoomInFinished()
{
    OnAnimEnd(none, 0, 0);
}

simulated event OnZoomOutFinished()
{
    OnAnimEnd(none, 0, 0);
}

function bool IsWarningAI()
{
    return bWarnAIWhenAiming && bUsingSights;
}

function Timer_CheckForAIWarning()
{
    local Vector Direction, DangerPoint, TraceStart, Projection;
    local Rotator NewAimRotation;
    local Pawn P;
    local KFPawn_Monster HitMonster;

    TraceStart = Instigator.GetWeaponStartTraceLocation();
    NewAimRotation = Instigator.GetBaseAimRotation();
    if(RSize(Normalize(LastAimRotation - NewAimRotation)) < 400)
    {
        CurrentAimSettledTime += 0.1;
    }
    if((CurrentAimSettledTime >= RandRange(AimWarningDelay.X, AimWarningDelay.Y)) && (WorldInfo.TimeSeconds - LastAimWarningTime) > AimWarningCooldown)
    {
        Direction = vector(NewAimRotation);
        foreach WorldInfo.AllPawns(Class'Pawn', P)
        {
            if(((P.GetTeamNum() != Instigator.GetTeamNum()) && !P.IsHumanControlled()) && P.IsAliveAndWell())
            {
                Projection = P.Location - TraceStart;
                if(VSizeSq(Projection) < MaxAIWarningDistSQ)
                {
                    PointDistToLine(P.Location, Direction, TraceStart, DangerPoint);
                    if(VSizeSq(DangerPoint - P.Location) < MaxAIWarningDistFromPointSQ)
                    {
                        HitMonster = KFPawn_Monster(P);
                        if((HitMonster != none) && HitMonster.MyKFAIC != none)
                        {
                            HitMonster.MyKFAIC.ReceiveLocationalWarning(DangerPoint, TraceStart, self);
                        }
                    }
                }
            }            
        }        
        LastAimWarningTime = WorldInfo.TimeSeconds;
        CurrentAimSettledTime = 0;
    }
    LastAimRotation = NewAimRotation;
}

simulated function bool ShouldOwnerWalk()
{
    return bUsingSights;
}

function bool IsGrappleBlocked(Pawn InstigatedBy)
{
    return false;
}

simulated function SetWeaponSprint(bool bNewSprintStatus)
{
    if(bNewSprintStatus)
    {
        if(bUsingSights)
        {
            SetIronSights(false);
        }
        if((CurrentFireMode < GetPendingFireLength()) && PendingFire(CurrentFireMode))
        {
            StopFire(CurrentFireMode);
        }
        GotoWeaponSprinting();
    }
}

simulated function StopPawnSprint(bool bClearPlayerInput)
{
    local KFPawn KFP;
    local PlayerController PC;
    local KFPlayerInput Input;

    KFP = KFPawn(Instigator);
    if(KFP != none)
    {
        KFP.SetSprinting(false);
        if(KFP.IsLocallyControlled())
        {
            PC = PlayerController(Instigator.Controller);
            if(PC != none)
            {
                if(bClearPlayerInput)
                {
                    PC.bRun = 0;
                }
                Input = KFPlayerInput(PC.PlayerInput);
                if((Input != none) && Input.bExtendedSprinting)
                {
                    PC.bRun = 0;
                    Input.bExtendedSprinting = false;
                }
            }
        }
    }
}

simulated function bool AllowSprinting()
{
    return true;
}

simulated function GotoWeaponSprinting();

function AdjustDamage(out int InDamage, class<DamageType> DamageType, Actor DamageCauser);

simulated function PlayTakeHitEffects(Vector HitLocation, Actor DamageCauser);

simulated function PlayAnimation(name Sequence, optional float fDesiredDuration, optional bool bLoop, optional float BlendInTime, optional float BlendOutTime)
{
    BlendInTime = 0.1;
    BlendOutTime = 0;
    if(((Sequence == 'None') || Instigator == none) || WeaponAnimSeqNode == none)
    {
        return;
    }
    if(bLogAnimation)
    {
        LogInternal((((("PlayAnimation Sequence=" @ string(Sequence)) @ "Length=") @ string(fDesiredDuration)) @ "bLoop=") @ string(bLoop));
    }
    if(Instigator.IsFirstPerson())
    {
        BlendInTime *= (WorldInfo.TimeDilation * CustomTimeDilation);
        WeaponAnimSeqNode.SetTweenTime(BlendInTime);
    }
    PlayWeaponAnimation(Sequence, fDesiredDuration, bLoop);
    if(!bLoop)
    {
        if(fDesiredDuration > float(0))
        {
            SetTimer(fDesiredDuration - BlendOutTime, false, 'OnAnimEnd');            
        }
        else
        {
            SetTimer((MySkelMesh.GetAnimLength(Sequence) * DefaultAnimSpeed) - BlendOutTime, false, 'OnAnimEnd');
        }        
    }
    else
    {
        ClearTimer('OnAnimEnd');
    }
}

simulated function PlayWeaponAnimation(name Sequence, float fDesiredDuration, optional bool bLoop, optional SkeletalMeshComponent SkelMesh)
{
    local float DesiredRate;

    if(((Mesh != none) && Instigator != none) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(WeaponAnimSeqNode != none)
        {
            if((WeaponAnimSeqNode.AnimSeq == none) || WeaponAnimSeqNode.AnimSeq.SequenceName != Sequence)
            {
                WeaponAnimSeqNode.SetAnim(Sequence);
            }
            if((fDesiredDuration > 0) && WeaponAnimSeqNode.AnimSeq.RateScale > 0)
            {
                DesiredRate = WeaponAnimSeqNode.AnimSeq.SequenceLength / (fDesiredDuration * WeaponAnimSeqNode.AnimSeq.RateScale);
                WeaponAnimSeqNode.PlayAnim(bLoop, DesiredRate);                
            }
            else
            {
                WeaponAnimSeqNode.PlayAnim(bLoop, DefaultAnimSpeed);
            }
        }
    }
}

simulated function AnimNodeSequence GetWeaponAnimNodeSeq()
{
    if(WeaponAnimSeqNode != none)
    {
        return WeaponAnimSeqNode;
    }
    return super.GetWeaponAnimNodeSeq();
}

simulated function bool WeaponIsAnimating()
{
    if((MySkelMesh == none) || (GetWeaponAnimNodeSeq()) == none)
    {
        return false;
    }
    return WeaponAnimSeqNode.bPlaying;
}

function CameraAnimInst PlayCameraAnim(CameraAnim AnimToPlay, optional float Scale, optional float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLoop, optional bool bRandomStartTime, optional Engine.Camera.ECameraAnimPlaySpace Space, optional Rotator CustomPlaySpace)
{
    local PlayerController PC;
    local CameraAnimInst AnimInst;

    Scale = 1;
    Rate = 1;                
    Space = 0;    
    PC = PlayerController(Instigator.Controller);
    if(PC.PlayerCamera != none)
    {
        AnimInst = PC.PlayerCamera.PlayCameraAnim(AnimToPlay, Rate, Scale, BlendInTime, BlendOutTime, bLoop, bRandomStartTime);
        if((AnimInst != none) && Space != 0)
        {
            AnimInst.SetPlaySpace(Space, CustomPlaySpace);
        }
    }
    return AnimInst;
}

simulated function bool ShouldPlayFireLast(byte FireModeNum)
{
    if(bHasFireLastAnims)
    {
        if(((!bAllowClientAmmoTracking && Role < ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] <= 1) || (bAllowClientAmmoTracking || Role == ROLE_Authority) && AmmoCount[GetAmmoType(FireModeNum)] == 0)
        {
            return true;
        }
    }
    return false;
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    local bool bPlayFireLast;

    bPlayFireLast = ShouldPlayFireLast(FireModeNum);
    if(bUsingScopePosition)
    {
        if(bPlayFireLast && FireLastScopedAnim != 'None')
        {
            return FireLastScopedAnim;            
        }
        else
        {
            return FireScopedAnim;
        }        
    }
    else
    {
        if(bUsingSights)
        {
            if(bPlayFireLast && FireLastSightedAnim != 'None')
            {
                return FireLastSightedAnim;                
            }
            else
            {
                return FireSightedAnims[Rand(FireSightedAnims.Length)];
            }            
        }
        else
        {
            if(!bReloadFromMagazine && LastReloadAbortTime == WorldInfo.TimeSeconds)
            {
                return ((bPlayFireLast) ? 'Shoot_OneHand_Last' : 'Shoot_OneHand');
            }
            return ((bPlayFireLast && FireLastAnim != 'None') ? FireLastAnim : FireAnim);
        }
    }
}

simulated function name GetLoopingFireAnim(byte FireModeNum)
{
    if(bUsingScopePosition)
    {
        return FireLoopScopedAnim;        
    }
    else
    {
        if(bUsingSights)
        {
            return FireLoopSightedAnim;
        }
    }
    return FireLoopAnim;
}

simulated function name GetLoopStartFireAnim(byte FireModeNum)
{
    if(bUsingSights)
    {
        return FireLoopStartSightedAnim;
    }
    return FireLoopStartAnim;
}

simulated function name GetLoopEndFireAnim(byte FireModeNum)
{
    if(bUsingSights)
    {
        return FireLoopEndSightedAnim;
    }
    return FireLoopEndAnim;
}

simulated function name GetMeleeAnimName(KFPawn.EPawnOctant AtkDir, KFMeleeHelperWeapon.EMeleeAttackType AtkType)
{
    local int Idx;

    if(MeleeAttackAnims.Length > 0)
    {
        Idx = Rand(MeleeAttackAnims.Length);
        return MeleeAttackAnims[Idx];
    }
}

simulated function AnimNodeSequence GetArmAnimNodeSeq()
{
    local KFPawn P;

    P = KFPawn(Instigator);
    if((P != none) && P.ArmsMesh != none)
    {
        return AnimNodeSequence(P.ArmsMesh.Animations);
    }
    return none;
}

simulated function ANIMNOTIFY_LockBolt()
{
    if(bAllowClientAmmoTracking)
    {
        if(AmmoCount[0] == 0)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
        }        
    }
    else
    {
        if(((Role < ROLE_Authority) && AmmoCount[0] <= 1) || (Role == ROLE_Authority) && AmmoCount[0] == 0)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
        }
    }
}

simulated function ANIMNOTIFY_UnLockBolt()
{
    bCheckBoltLockPostReload = true;
    EmptyMagBlendNode.SetBlendTarget(0, 0);
}

simulated function ToggleAdditiveBobAnim(bool bOn, optional float BlendTime)
{
    BlendTime = 0.1;
    if(IdleBobBlendNode != none)
    {
        IdleBobBlendNode.SetBlendTarget(((bOn && bUseAdditiveMoveAnim) ? 1 : 0), BlendTime);
    }
}

simulated function UpdateOutOfAmmoEffects(float BlendTime)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EmptyMagBlendNode != none)
    {
        if(AmmoCount[0] == 0)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
        }
    }
}

// Export UKFWeapon::execGetAnimSeqCameraPosition(FFrame&, void* const)
native final function bool GetAnimSeqCameraPosition(out Vector OutPos, out Rotator OutRot);

simulated event SetPosition(KFPawn Holder)
{
    local Vector DrawOffset, ViewOffset, FinalLocation;
    local Rotator NewRotation, FinalRotation, SpecRotation;
    local PlayerController PC;
    local KFPlayerController KFPC;
    local Vector SpecViewLoc;
    local Rotator DebugRotationOffset, UsedBufferRotation;
    local Vector CamLoc;
    local Rotator CamRot;
    local int I;
    local KFPawn KFP;

    if(!Holder.IsFirstPerson() && !bWeaponNeedsServerPosition)
    {
        return;
    }
    if(bForceHidden)
    {
        Mesh.SetHidden(true);
        Holder.ArmsMesh.SetHidden(true);
        KFP = KFPawn(Instigator);
        if(KFP != none)
        {
            I = 0;
            J0xCF:

            if(I < 3)
            {
                if(KFP.FirstPersonAttachments[I] != none)
                {
                    KFP.FirstPersonAttachments[I].SetHidden(true);
                }
                ++ I;
                goto J0xCF;
            }
        }
        NewRotation = Holder.GetViewRotation();
        SetLocation(Instigator.GetPawnViewLocation() + (HiddenWeaponsOffset >> NewRotation));
        SetRotation(NewRotation);
        SetBase(Instigator);
        return;
    }
    if(bPendingShow)
    {
        SetHidden(false);
        bPendingShow = false;
    }
    Mesh.SetHidden(false);
    PC = GetALocalPlayerController();
    ViewOffset = PlayerViewOffset;
    if(Class'Engine'.static.IsRealDStereoEnabled())
    {
        ViewOffset.X -= float(30);
    }
    if((Holder.Controller == none) && KFDemoRecSpectator(PC) != none)
    {
        PC.GetPlayerViewPoint(SpecViewLoc, SpecRotation);
        DrawOffset = ViewOffset >> SpecRotation;
        DrawOffset += Holder.WeaponBob(BobDamping, JumpDamping);
        FinalLocation = SpecViewLoc + DrawOffset;
        SetLocation(FinalLocation);
        SetBase(Holder);
        SetRotation(SpecRotation);
        return;
    }
    NewRotation = ((Holder.Controller == none) ? Holder.GetBaseAimRotation() : Holder.Controller.Rotation);
    NewRotation += ZoomRotInterp;
    KFPC = KFPlayerController(Holder.Controller);
    if(KFPC != none)
    {
        if(bDebugRecoilPosition)
        {
            DebugRotationOffset.Pitch = RecoilISMaxPitchLimit;
            KFPC.WeaponBufferRotation = DebugRotationOffset;
        }
        if(KFPC.WeaponBufferRotation.Pitch < 32768)
        {
            UsedBufferRotation.Pitch = int(float(KFPC.WeaponBufferRotation.Pitch) / IronSightMeshFOVCompensationScale);            
        }
        else
        {
            UsedBufferRotation.Pitch = int(float(65535) - (float(65535 - KFPC.WeaponBufferRotation.Pitch) / IronSightMeshFOVCompensationScale));
        }
        if(KFPC.WeaponBufferRotation.Yaw < 32768)
        {
            UsedBufferRotation.Yaw = int(float(KFPC.WeaponBufferRotation.Yaw) / IronSightMeshFOVCompensationScale);            
        }
        else
        {
            UsedBufferRotation.Yaw = int(float(65535) - (float(65535 - KFPC.WeaponBufferRotation.Yaw) / IronSightMeshFOVCompensationScale));
        }
        NewRotation += UsedBufferRotation;
    }
    if(bFollowAnimSeqCamera && GetAnimSeqCameraPosition(CamLoc, CamRot))
    {
        ViewOffset += CamLoc;
        NewRotation += CamRot;
    }
    FinalRotation = NewRotation;
    DrawOffset.Z += Holder.GetEyeHeight();
    DrawOffset += Holder.WeaponBob(BobDamping, JumpDamping);
    DrawOffset += ((WeaponLag + ViewOffset) >> FinalRotation);
    FinalLocation = Holder.Location + DrawOffset;
    SetLocation(FinalLocation);
    SetRotation(FinalRotation);
    SetBase(Holder);
}

simulated function ChangeVisibility(bool bIsVisible)
{
    local KFPawn KFP;
    local editinline SkeletalMeshComponent SkelMesh;
    local editinline PrimitiveComponent Primitive;
    local int I;

    if(Mesh != none)
    {
        if(bIsVisible && !Mesh.bAttached)
        {
            AttachComponent(Mesh);
            EnsureWeaponOverlayComponentLast();
            PlayIdleAnim();
        }
        SetHidden(!bIsVisible);
        SkelMesh = SkeletalMeshComponent(Mesh);
        if(SkelMesh != none)
        {
            foreach SkelMesh.AttachedComponents(Class'PrimitiveComponent', Primitive)
            {
                Primitive.SetHidden(!bIsVisible);                
            }            
        }
    }
    KFP = KFPawn(Instigator);
    if((KFP != none) && KFP.ArmsMesh != none)
    {
        if(bIsVisible)
        {
            AttachComponent(KFP.ArmsMesh);            
        }
        else
        {
            DetachComponent(KFP.ArmsMesh);
        }
        KFP.ArmsMesh.SetHidden(!bIsVisible);
        I = 0;
        J0x207:

        if(I < 3)
        {
            if(KFP.FirstPersonAttachments[I] != none)
            {
                if(bIsVisible)
                {
                    AttachComponent(KFP.FirstPersonAttachments[I]);                    
                }
                else
                {
                    DetachComponent(KFP.FirstPersonAttachments[I]);
                }
                KFP.FirstPersonAttachments[I].SetHidden(!bIsVisible);
            }
            ++ I;
            goto J0x207;
        }
    }
    if(OverlayMesh != none)
    {
        OverlayMesh.SetHidden(!bIsVisible);
    }
}

simulated function PlayFireEffects(byte FireModeNum, optional Vector HitLocation)
{
    local name WeaponFireAnimName;
    local KFPerk CurrentPerk;
    local float TempTweenTime, AdjustedAnimLength;

    if(((FireModeNum < bLoopingFireSnd.Length) && bLoopingFireSnd[FireModeNum]) && !bPlayingLoopingFireSnd)
    {
        StartLoopingFireSound(FireModeNum);
    }
    PlayFiringSound(CurrentFireMode);
    if(Instigator != none)
    {
        UpdateWeaponAttachmentAnimRate(GetThirdPersonAnimRate());
        if(Instigator.IsLocallyControlled())
        {
            if(Instigator.IsFirstPerson())
            {
                if(!bPlayingLoopingFireAnim)
                {
                    WeaponFireAnimName = GetWeaponFireAnim(FireModeNum);
                    if(WeaponFireAnimName != 'None')
                    {
                        AdjustedAnimLength = MySkelMesh.GetAnimLength(WeaponFireAnimName);
                        TempTweenTime = FireTweenTime;
                        CurrentPerk = GetPerk();
                        if(CurrentPerk != none)
                        {
                            CurrentPerk.ModifyRateOfFire(AdjustedAnimLength, self);
                            if((((EmptyMagBlendNode != none) && BonesToLockOnEmpty.Length > 0) && AmmoCount[GetAmmoType(FireModeNum)] == 0) && CurrentPerk.GetIsUberAmmoActive(self))
                            {
                                EmptyMagBlendNode.SetBlendTarget(0, 0);
                                TempTweenTime = 0;
                            }
                        }
                        PlayAnimation(WeaponFireAnimName, AdjustedAnimLength,, TempTweenTime);
                    }
                }
                CauseMuzzleFlash(FireModeNum);
            }
            HandleRecoil();
            ShakeView();
            if((AmmoCount[0] == 0) && ForceReloadTimeOnEmpty > float(0))
            {
                SetTimer(ForceReloadTimeOnEmpty, false, 'ForceReload');
            }
        }
    }
}

simulated function StopFireEffects(byte FireModeNum)
{
    if(MuzzleFlash != none)
    {
        MuzzleFlash.StopMuzzleFlash();
    }
}

simulated function StartLoopingFireEffects(byte FireModeNum, optional bool bForceAnim)
{
    local name WeaponFireAnimName;

    if(bForceAnim || (FireModeNum < bLoopingFireAnim.Length) && bLoopingFireAnim[FireModeNum])
    {
        WeaponFireAnimName = GetLoopStartFireAnim(FireModeNum);
        if(WeaponFireAnimName != 'None')
        {
            PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName), false, FireTweenTime, 0);            
        }
        else
        {
            WeaponFireAnimName = GetLoopingFireAnim(FireModeNum);
            PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName), true, FireTweenTime);
        }
        bPlayingLoopingFireAnim = true;
    }
    StartLoopingFireSound(FireModeNum);
}

simulated function StopLoopingFireEffects(byte FireModeNum)
{
    local name LoopEndFireAnim;

    if(bPlayingLoopingFireAnim)
    {
        LoopEndFireAnim = GetLoopEndFireAnim(FireModeNum);
        if(LoopEndFireAnim != 'None')
        {
            PlayAnimation(LoopEndFireAnim, MySkelMesh.GetAnimLength(LoopEndFireAnim));            
        }
        else
        {
            ClearTimer('OnAnimEnd');
        }
        bPlayingLoopingFireAnim = false;
    }
    StopLoopingFireSound(FireModeNum);
}

simulated function bool ShouldForceSingleFireSound()
{
    if((self.WorldInfo.TimeDilation < 1) && SingleFireSoundIndex != 255)
    {
        return true;
    }
    return false;
}

simulated function StartLoopingFireSound(byte FireModeNum)
{
    if(((FireModeNum < bLoopingFireSnd.Length) && bLoopingFireSnd[FireModeNum]) && !ShouldForceSingleFireSound())
    {
        bPlayingLoopingFireSnd = true;
        KFPawn(Instigator).SetWeaponAmbientSound(WeaponFireSnd[FireModeNum].DefaultCue, WeaponFireSnd[FireModeNum].FirstPersonCue);
    }
}

simulated function StopLoopingFireSound(byte FireModeNum)
{
    if(bPlayingLoopingFireSnd)
    {
        KFPawn(Instigator).SetWeaponAmbientSound(none);
        if(FireModeNum < WeaponFireLoopEndSnd.Length)
        {
            WeaponPlayFireSound(WeaponFireLoopEndSnd[FireModeNum].DefaultCue, WeaponFireLoopEndSnd[FireModeNum].FirstPersonCue);
        }
        bPlayingLoopingFireSnd = false;
    }
}

simulated function PlayFiringSound(byte FireModeNum)
{
    local byte UsedFireModeNum;

    MakeNoise(1, 'PlayerFiring');
    if(!bPlayingLoopingFireSnd)
    {
        UsedFireModeNum = FireModeNum;
        if(((FireModeNum < bLoopingFireSnd.Length) && bLoopingFireSnd[FireModeNum]) && ShouldForceSingleFireSound())
        {
            UsedFireModeNum = SingleFireSoundIndex;
        }
        if(UsedFireModeNum < WeaponFireSnd.Length)
        {
            WeaponPlayFireSound(WeaponFireSnd[UsedFireModeNum].DefaultCue, WeaponFireSnd[UsedFireModeNum].FirstPersonCue);
        }
    }
}

simulated function WeaponPlayFireSound(AkBaseSoundObject DefaultSound, AkBaseSoundObject FirstPersonSound)
{
    local Vector SoundLocation;

    if((Instigator != none) && !bSuppressSounds)
    {
        SoundLocation = Instigator.GetPawnViewLocation();
        if(((FirstPersonSound != none) && Instigator.IsLocallyControlled()) && Instigator.IsFirstPerson())
        {
            Instigator.PlaySoundBase(FirstPersonSound, true, false, false);
            if(WorldInfo.NetMode == NM_ListenServer)
            {
                KFPawn(Instigator).ReplicateSound(DefaultSound, false, false, false, SoundLocation);
            }            
        }
        else
        {
            if(DefaultSound != none)
            {
                Instigator.PlaySoundBase(DefaultSound, false, true, false, SoundLocation);
            }
        }
    }
}

simulated function WeaponPlaySound(AkBaseSoundObject Sound, optional float NoiseLoudness)
{
    if(((Sound != none) && Instigator != none) && !bSuppressSounds)
    {
        Instigator.PlaySoundBase(Sound, false, true);
    }
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if(MuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(MuzzleFlash != none)
    {
        MuzzleFlash.CauseMuzzleFlash(FireModeNum);
        if(MuzzleFlash.bAutoActivateShellEject)
        {
            MuzzleFlash.CauseShellEject();
            SetShellEjectsToForeground();
        }
    }
}

simulated function ANIMNOTIFY_ShellEject()
{
    if(MuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(MuzzleFlash != none)
    {
        MuzzleFlash.CauseShellEject();
        SetShellEjectsToForeground();
    }
}

simulated function AttachMuzzleFlash()
{
    if(MySkelMesh != none)
    {
        if(MuzzleFlashTemplate != none)
        {
            MuzzleFlash = new (self) Class'KFMuzzleFlash' (MuzzleFlashTemplate);
            MuzzleFlash.AttachMuzzleFlash(MySkelMesh);
        }
    }
}

simulated function SetShellEjectsToForeground()
{
    if(((MuzzleFlash != none) && MuzzleFlash.ShellEjectPSC != none) && EjectedShellForegroundDuration > 0)
    {
        MuzzleFlash.ShellEjectPSC.SetDepthPriorityGroup(2);
        MuzzleFlash.ShellEjectPSC.bDepthTestEnabled = true;
        SetTimer(EjectedShellForegroundDuration, false, 'Timer_RestoreShellEjectDepth');
    }
}

simulated function Timer_RestoreShellEjectDepth()
{
    if((MuzzleFlash != none) && MuzzleFlash.ShellEjectPSC != none)
    {
        MuzzleFlash.ShellEjectPSC.SetDepthPriorityGroup(1);
        MuzzleFlash.ShellEjectPSC.bDepthTestEnabled = false;
    }
}

simulated function ShakeView()
{
    local PlayerController PC;
    local float ShakeViewScale;

    PC = PlayerController(Instigator.Controller);
    if((PC == none) || LocalPlayer(PC.Player) == none)
    {
        return;
    }
    if((CurrentFireMode < FireCameraAnim.Length) && FireCameraAnim[CurrentFireMode] != none)
    {
        ShakeViewScale = ShakeScaleStandard;
        if(bUsingSights)
        {
            ShakeViewScale *= ShakeScaleSighted;
        }
        PC.ClientPlayCameraAnim(FireCameraAnim[CurrentFireMode], ShakeViewScale, 1, 0, 0.1);
    }
    PC.ClientPlayForceFeedbackWaveform(WeaponFireWaveForm);
}

simulated function AddBlood(float MinAmount, float MaxAmount)
{
    local float NewBlood;
    local int I;

    if((WorldInfo.NetMode != NM_DedicatedServer) && WeaponMICs.Length > 0)
    {
        NewBlood = RandRange(MinAmount, MaxAmount);
        BloodParamValue = FMax(BloodParamValue + NewBlood, 0.2);
        I = 0;
        J0x91:

        if(I < WeaponMICs.Length)
        {
            if(WeaponMICs[I] != none)
            {
                WeaponMICs[I].SetScalarParameterValue('Scalar_Blood_Contrast', BloodParamValue);
            }
            ++ I;
            goto J0x91;
        }
    }
}

simulated function StartFire(byte FireModeNum)
{
    if((FireModeNum == 0) || FireModeNum == 1)
    {
        if(IsMeleeing())
        {
            return;
        }
        if(ShouldAutoReload(FireModeNum))
        {
            FireModeNum = 2;
        }
    }
    bStopAltFireOnNextRelease = false;
    if(((FireModeNum == 0) && bUseAltFireMode) && !bGamepadFireEntry)
    {
        FireModeNum = 1;
        bStopAltFireOnNextRelease = true;
    }
    if(FireModeNum == 2)
    {
        BeginFire(FireModeNum);
        return;
    }
    super.StartFire(FireModeNum);
}

simulated function BeginFire(byte FireModeNum)
{
    local KFPerk_Gunslinger GunslingerPerk;

    super.BeginFire(FireModeNum);
    if(Role == ROLE_Authority)
    {
        GunslingerPerk = KFPerk_Gunslinger(GetPerk());
        if(((GunslingerPerk != none) && !IsMeleeWeapon()) && !GunslingerPerk.IsWeaponOnPerk(self,, GunslingerPerk.Class))
        {
            GunslingerPerk.ResetHeadShotCombo();
        }
    }
}

simulated function StopFire(byte FireModeNum)
{
    if((FireModeNum == 0) && bStopAltFireOnNextRelease)
    {
        bStopAltFireOnNextRelease = false;
        FireModeNum = 1;
    }
    super.StopFire(FireModeNum);
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    if((FiringStatesArray[1] == 'None') || WeaponFireTypes[1] == 3)
    {
        return;
    }
    if(bUseAltFireMode)
    {
        StopFire(1);
        bUseAltFireMode = false;        
    }
    else
    {
        StopFire(0);
        bUseAltFireMode = true;
    }
    Instigator.PlaySoundBase(KFInventoryManager(InvManager).SwitchFireModeEvent);
}

simulated function AltFireModeRelease()
{
    if(PendingFire(1))
    {
        StopFire(1);
    }
}

simulated function SendToFiringState(byte FireModeNum)
{
    local KFPawn_Human KFPH;

    if((FireModeNum == 4) && !static.GetPerk().GetGrenadeClass().default.bAllowTossDuringZedGrabRotation)
    {
        if((WorldInfo.TimeSeconds - ZedGrabGrenadeTossCooldown) < float(0))
        {
            return;
        }
    }
    if((FireModeNum == 2) && Instigator.IsLocallyControlled())
    {
        InitializeReload();
    }
    KFPH = KFPawn_Human(Instigator);
    if(KFPH != none)
    {
        KFPH.CheckAndEndActiveEMoteSpecialMove();
    }
    super.SendToFiringState(FireModeNum);
}

simulated event Vector GetMuzzleLoc()
{
    local Vector X, Y, Z;
    local Rotator ViewRotation;

    if(Instigator != none)
    {
        if(bUsingSights)
        {
            ViewRotation = Instigator.GetViewRotation();
            if(KFPlayerController(Instigator.Controller) != none)
            {
                ViewRotation += KFPlayerController(Instigator.Controller).WeaponBufferRotation;
            }
            GetAxes(ViewRotation, X, Y, Z);
            return Instigator.GetWeaponStartTraceLocation() + (X * FireOffset.X);            
        }
        else
        {
            ViewRotation = Instigator.GetViewRotation();
            if(KFPlayerController(Instigator.Controller) != none)
            {
                ViewRotation += KFPlayerController(Instigator.Controller).WeaponBufferRotation;
            }
            return Instigator.GetPawnViewLocation() + (FireOffset >> ViewRotation);
        }
    }
    return Location;
}

simulated function byte GetCurrentMuzzleID()
{
    return 0;
}

simulated function CacheKFPlayerController()
{
    if(Instigator == none)
    {
        KFPlayer = none;        
    }
    else
    {
        KFPlayer = KFPlayerController(Instigator.Controller);
    }
}

simulated function FireAmmunition()
{
    HandleWeaponShotTaken(CurrentFireMode);
    switch(WeaponFireTypes[CurrentFireMode])
    {
        case 0:
            if((self.WorldInfo.TimeDilation < 1) && WeaponProjectiles[CurrentFireMode] != none)
            {
                ProjectileFire();                
            }
            else
            {
                InstantFireClient();
            }
            break;
        case 1:
            ProjectileFire();
            break;
        case 2:
            CustomFire();
            break;
        default:
            break;
    }
    ConsumeAmmo(CurrentFireMode);
    NotifyWeaponFired(CurrentFireMode);
    PlayFireEffects(CurrentFireMode, vect(0, 0, 0));
}

function HandleWeaponShotTaken(byte FireMode)
{
    if(KFPlayer != none)
    {
        KFPlayer.AddShotsFired(1);
    }
}

simulated function ImpactInfo CalcWeaponFire(Vector StartTrace, Vector EndTrace, optional out array<ImpactInfo> ImpactList, optional Vector Extent)
{
    local ImpactInfo CurrentImpact;
    local int I;
    local Actor HitActor;
    local bool bFirst;

    bFirst = ImpactList.Length == 0;
    CurrentImpact = super.CalcWeaponFire(StartTrace, EndTrace, ImpactList, Extent);
    if(bFirst)
    {
        TraceImpactHitZones(StartTrace, EndTrace, ImpactList);
        I = 0;
        J0x8F:

        if(I < ImpactList.Length)
        {
            HitActor = ImpactList[I].HitActor;
            if(((HitActor != none) && !HitActor.bBlockActors) && HitActor.IsA('KFWaterMeshActor'))
            {
                return ImpactList[I];
            }
            ++ I;
            goto J0x8F;
        }
    }
    return CurrentImpact;
}

simulated function TraceImpactHitZones(Vector StartTrace, Vector EndTrace, out array<ImpactInfo> ImpactList)
{
    local int I;
    local array<ImpactInfo> HitZoneImpactList;

    I = 0;
    J0x0B:

    if(I < ImpactList.Length)
    {
        if(((ImpactList[I].HitActor != none) && ImpactList[I].HitActor.bCanBeDamaged) && ImpactList[I].HitActor.IsA('KFPawn'))
        {
            TraceAllPhysicsAssetInteractions(SkeletalMeshComponent(ImpactList[I].HitInfo.HitComponent), EndTrace, StartTrace, HitZoneImpactList, vect(0, 0, 0), true);
            if(HitZoneImpactList.Length > 0)
            {
                HitZoneImpactList[0].RayDir = ImpactList[I].RayDir;
                ImpactList[I] = HitZoneImpactList[0];
            }
        }
        ++ I;
        goto J0x0B;
    }
}

simulated function bool PassThroughDamage(Actor HitActor)
{
    local KFPawn KFP;

    if(HitActor.bBlockActors)
    {
        KFP = KFPawn(HitActor);
        if((PenetrationPowerRemaining > float(0)) && KFP != none)
        {
            PenetrationPowerRemaining -= KFP.PenetrationResistance;
            return true;
        }
    }
    return !HitActor.bBlockActors && ((HitActor.IsA('Trigger') || HitActor.IsA('TriggerVolume')) || HitActor.IsA('InteractiveFoliageActor')) || HitActor.IsA('KFWaterMeshActor');
}

simulated function Rotator AddSpread(Rotator BaseAim)
{
    local Vector X, Y, Z;
    local float CurrentSpread, RandY, RandZ;

    if(CurrentFireMode >= Spread.Length)
    {
        return BaseAim;
    }
    CurrentSpread = Spread[CurrentFireMode];
    if(bUsingSights)
    {
        CurrentSpread *= IronSightsSpreadMod;        
    }
    else
    {
        if((MovingSpreadMod > 1) && VSizeSq(Instigator.Velocity) > float(0))
        {
            CurrentSpread *= MovingSpreadMod;
        }
    }
    if(Instigator.bIsCrouched)
    {
        CurrentSpread *= CrouchSpreadMod;
    }
    if(CurrentSpread == float(0))
    {
        return BaseAim;        
    }
    else
    {
        if((GetPerk()) != none)
        {
            GetPerk().ModifySpread(CurrentSpread);
        }
        GetAxes(BaseAim, X, Y, Z);
        RandY = FRand() - 0.5;
        RandZ = Sqrt(0.5 - Square(RandY)) * (FRand() - 0.5);
        return rotator((X + ((RandY * CurrentSpread) * Y)) + ((RandZ * CurrentSpread) * Z));
    }
}

simulated function ModifyRecoil(out float CurrentRecoilModifier)
{
    GetPerk().ModifyRecoil(CurrentRecoilModifier, self);
}

simulated event HandleRecoil()
{
    local Rotator NewRecoilRotation;
    local float CurrentRecoilModifier;
    local KFPawn KFP;

    if((Instigator == none) || !Instigator.IsFirstPerson())
    {
        return;
    }
    CurrentRecoilModifier = 1;
    NewRecoilRotation.Pitch = int(RandRange(float(minRecoilPitch), float(maxRecoilPitch)));
    NewRecoilRotation.Yaw = int(RandRange(float(minRecoilYaw), float(maxRecoilYaw)));
    if(Instigator.Physics == 2)
    {
        CurrentRecoilModifier *= FallingRecoilModifier;
    }
    KFP = KFPawn(Instigator);
    if(KFP != none)
    {
        if(VSizeSq(Instigator.Velocity) > float(50))
        {
            if(Instigator.bIsWalking)
            {
                CurrentRecoilModifier *= WalkingRecoilModifier;                
            }
            else
            {
                CurrentRecoilModifier *= JoggingRecoilModifier;
            }
        }
        if(Instigator.bIsCrouched)
        {
            CurrentRecoilModifier *= StanceCrouchedRecoilModifier;
        }
        if(!bUsingSights)
        {
            CurrentRecoilModifier *= HippedRecoilModifier;
        }
    }
    ModifyRecoil(CurrentRecoilModifier);
    NewRecoilRotation *= CurrentRecoilModifier;
    LastRecoilModifier = CurrentRecoilModifier;
    SetRecoil(NewRecoilRotation, RecoilRate);
}

simulated function SetRecoil(Rotator NewRecoilRotation, float NewRecoilSpeed)
{
    local float UsedRecoilScale;

    if(RecoilTimeLeft > float(0))
    {
        UsedRecoilScale = RecoilTimeLeft / RecoilSpeed;        
    }
    else
    {
        UsedRecoilScale = 0;
    }
    RecoilRotator *= UsedRecoilScale;
    RecoilRotator += NewRecoilRotation;
    RecoilSpeed = NewRecoilSpeed;
    RecoilTimeLeft = NewRecoilSpeed;
}

simulated function class<KFProjectile> GetKFProjectileClass()
{
    if(CurrentFireMode == 4)
    {
        return GetPerk().GetGrenadeClass();        
    }
    else
    {
        return ((CurrentFireMode < WeaponProjectiles.Length) ? class<KFProjectile>(WeaponProjectiles[CurrentFireMode]) : none);
    }
}

simulated function Projectile ProjectileFire()
{
    local Vector StartTrace, EndTrace, RealStartLoc, AimDir;
    local ImpactInfo TestImpact;
    local Vector DirA, DirB;
    local Quat Q;
    local class<KFProjectile> MyProjectileClass;

    if(ShouldIncrementFlashCountOnFire())
    {
        IncrementFlashCount();
    }
    MyProjectileClass = GetKFProjectileClass();
    if((Role == ROLE_Authority) || ((MyProjectileClass.default.bUseClientSideHitDetection && MyProjectileClass.default.bNoReplicationToInstigator) && Instigator != none) && Instigator.IsLocallyControlled())
    {
        StartTrace = GetSafeStartTraceLocation();
        AimDir = vector(GetAdjustedAim(StartTrace));
        RealStartLoc = GetPhysicalFireStartLoc(AimDir);
        if(StartTrace != RealStartLoc)
        {
            EndTrace = StartTrace + (AimDir * (GetTraceRange()));
            TestImpact = CalcWeaponFire(StartTrace, EndTrace);
            DirB = AimDir;
            AimDir = Normal(TestImpact.HitLocation - RealStartLoc);
            DirA = AimDir;
            if((DirA Dot DirB) < 0.995)
            {
                Q = QuatFromAxisAndAngle(Normal(DirB Cross DirA), 0.1);
                AimDir = QuatRotateVector(Q, DirB);
            }
        }
        return SpawnProjectile(MyProjectileClass, RealStartLoc, AimDir);
    }
    return none;
}

simulated function bool ShouldIncrementFlashCountOnFire()
{
    return CurrentFireMode != 4;
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProjectile SpawnedProjectile;
    local int ProjDamage;

    SpawnedProjectile = Spawn(KFProjClass, self,, RealStartLoc);
    if((SpawnedProjectile != none) && !SpawnedProjectile.bDeleteMe)
    {
        if((InstantHitDamage.Length > CurrentFireMode) && InstantHitDamageTypes.Length > CurrentFireMode)
        {
            ProjDamage = GetModifiedDamage(CurrentFireMode);
            SpawnedProjectile.Damage = float(ProjDamage);
            SpawnedProjectile.MyDamageType = InstantHitDamageTypes[CurrentFireMode];
        }
        SpawnedProjectile.InitialPenetrationPower = GetInitialPenetrationPower(CurrentFireMode);
        SpawnedProjectile.PenetrationPower = SpawnedProjectile.InitialPenetrationPower;
        SpawnedProjectile.UpgradeDamageMod = GetUpgradeDamageMod(CurrentWeaponUpgradeIndex);
        SpawnedProjectile.Init(AimDir);
    }
    return SpawnedProjectile;
}

simulated event float GetInitialPenetrationPower(byte FiringMode)
{
    local KFPerk InstigatorPerk;
    local float UsedPenetrationPower;
    local KFPlayerController KFPC;

    if((PenetrationPower.Length > FiringMode) && PenetrationPower[FiringMode] > float(0))
    {
        UsedPenetrationPower = default.PenetrationPower[FiringMode];
    }
    InstigatorPerk = GetPerk();
    if(((InstigatorPerk != none) && InstantHitDamageTypes.Length > FiringMode) && Instigator != none)
    {
        KFPC = KFPlayerController(Instigator.Controller);
        if(KFPC != none)
        {
            UsedPenetrationPower += InstigatorPerk.GetPenetrationModifier(KFPC.GetLevel(), class<KFDamageType>(InstantHitDamageTypes[FiringMode]));
        }
    }
    return UsedPenetrationPower;
}

simulated function ProcessInstantHitEx(byte FiringMode, ImpactInfo Impact, optional int NumHits, optional out float out_PenetrationVal, optional int ImpactNum)
{
    local int TotalDamage;
    local KActorFromStatic NewKActor;
    local editinline StaticMeshComponent HitStaticMesh;
    local InterpCurveFloat PenetrationCurve;
    local KFPawn KFP;
    local float InitialPenetrationPower, OriginalPenetrationVal;
    local KFPerk CurrentPerk;
    local bool bNoPenetrationDmgReduction;

    if(Impact.HitActor != none)
    {
        OriginalPenetrationVal = out_PenetrationVal;
        NumHits = Max(NumHits, 1);
        TotalDamage = (GetModifiedDamage(FiringMode)) * NumHits;
        if(Impact.HitActor.bWorldGeometry)
        {
            HitStaticMesh = StaticMeshComponent(Impact.HitInfo.HitComponent);
            if(((!WorldInfo.bDropDetail && WorldInfo.GetDetailMode() != 0) && HitStaticMesh != none) && HitStaticMesh.CanBecomeDynamic())
            {
                NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitStaticMesh);
                if(NewKActor != none)
                {
                    Impact.HitActor = NewKActor;
                }
            }            
        }
        else
        {
            if(Impact.HitActor.bCanBeDamaged && (GetInitialPenetrationPower(FiringMode)) > float(0))
            {
                if(out_PenetrationVal <= float(0))
                {
                    return;                    
                }
                else
                {
                    CurrentPerk = GetPerk();
                    if(CurrentPerk != none)
                    {
                        bNoPenetrationDmgReduction = CurrentPerk.IgnoresPenetrationDmgReduction();
                    }
                    PenetrationCurve = PenetrationDamageReductionCurve[FiringMode];
                    if(!bNoPenetrationDmgReduction)
                    {
                        TotalDamage *= EvalInterpCurveFloat(PenetrationCurve, out_PenetrationVal / (GetInitialPenetrationPower(FiringMode)));
                    }
                    KFP = KFPawn(Impact.HitActor);
                    if(KFP != none)
                    {
                        out_PenetrationVal -= KFP.PenetrationResistance;
                    }
                }
            }
        }
        if((KFPlayer != none) && KFPawn_Monster(Impact.HitActor) != none)
        {
            InitialPenetrationPower = GetInitialPenetrationPower(FiringMode);
            if((InitialPenetrationPower <= float(0)) || OriginalPenetrationVal == InitialPenetrationPower)
            {
                KFPlayer.AddShotsHit(1);
            }
        }
        Impact.HitActor.TakeDamage(TotalDamage, Instigator.Controller, Impact.HitLocation, InstantHitMomentum[FiringMode] * Impact.RayDir, InstantHitDamageTypes[FiringMode], Impact.HitInfo, self);
    }
}

simulated function HandleProjectileImpact(byte ProjectileFireMode, ImpactInfo Impact, optional float PenetrationValue)
{
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        if(Instigator.Role < ROLE_Authority)
        {
            SendClientProjectileImpact(ProjectileFireMode, Impact, PenetrationValue);
        }
        ProcessInstantHitEx(ProjectileFireMode, Impact,, PenetrationValue, 0);
    }
}

event RecieveClientFragmentImpact(const out ImpactInfo Impact, class<KFProjectile> Fragment)
{
    ProcessGrenadeProjectileImpact(Impact, Fragment);
}

simulated function HandleGrenadeProjectileImpact(ImpactInfo Impact, class<KFProjectile> Fragment)
{
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        if(Instigator.Role < ROLE_Authority)
        {
            SendClientFragmentImpact(Impact, Fragment);
        }
        ProcessGrenadeProjectileImpact(Impact, Fragment);
    }
}

simulated function ProcessGrenadeProjectileImpact(ImpactInfo Impact, class<KFProjectile> Fragment)
{
    local int TotalDamage;
    local KActorFromStatic NewKActor;
    local editinline StaticMeshComponent HitStaticMesh;

    if(Impact.HitActor != none)
    {
        TotalDamage = int(Fragment.default.Damage);
        if(Impact.HitActor.bWorldGeometry)
        {
            HitStaticMesh = StaticMeshComponent(Impact.HitInfo.HitComponent);
            if((HitStaticMesh != none) && HitStaticMesh.CanBecomeDynamic())
            {
                NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitStaticMesh);
                if(NewKActor != none)
                {
                    Impact.HitActor = NewKActor;
                }
            }
        }
        Impact.HitActor.TakeDamage(TotalDamage, Instigator.Controller, Impact.HitLocation, Fragment.default.MomentumTransfer * Impact.RayDir, Fragment.default.MyDamageType, Impact.HitInfo, Instigator);
    }
}

simulated function bool IsHeavyWeapon();

// Export UKFWeapon::execServerRegisterImpact1(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact1(byte FiringMode, ImpactRepInfo NetImpact);

// Export UKFWeapon::execServerRegisterImpact2(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact2(byte FiringMode, ImpactRepInfo NetImpacts[2]);

// Export UKFWeapon::execServerRegisterImpact3(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact3(byte FiringMode, ImpactRepInfo NetImpacts[3]);

// Export UKFWeapon::execServerRegisterImpact4(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact4(byte FiringMode, ImpactRepInfo NetImpacts[4]);

// Export UKFWeapon::execServerRegisterImpact5(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact5(byte FiringMode, ImpactRepInfo NetImpacts[5]);

// Export UKFWeapon::execServerRegisterImpact6(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact6(byte FiringMode, ImpactRepInfo NetImpacts[6]);

// Export UKFWeapon::execServerRegisterImpact7(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact7(byte FiringMode, ImpactRepInfo NetImpacts[7]);

// Export UKFWeapon::execServerRegisterImpact8(FFrame&, void* const)
private reliable server native final event ServerRegisterImpact8(byte FiringMode, ImpactRepInfo NetImpacts[8]);

// Export UKFWeapon::execServerRegisterProjectileImpact(FFrame&, void* const)
private reliable server native final event ServerRegisterProjectileImpact(byte FiringMode, ImpactRepInfo NetImpact, optional byte PenetrationByte);

// Export UKFWeapon::execServerRegisterProjectileExplosion(FFrame&, void* const)
private reliable server native final event ServerRegisterProjectileExplosion(Vector ExplosionLocation, KFProjectile ExplodingProjectile);

// Export UKFWeapon::execServerRegisterFragmentImpact(FFrame&, void* const)
private reliable server native final event ServerRegisterFragmentImpact(ImpactRepInfo NetImpact, class<KFProjectile> FragmentClass);

// Export UKFWeapon::execSendClientImpactList(FFrame&, void* const)
protected native simulated function int SendClientImpactList(byte FiringMode, const array<ImpactInfo> ImpactList);

// Export UKFWeapon::execSendClientProjectileImpact(FFrame&, void* const)
protected native simulated function int SendClientProjectileImpact(byte FiringMode, const out ImpactInfo Impact, float PenetrationFloat);

// Export UKFWeapon::execSendClientProjectileExplosion(FFrame&, void* const)
protected native simulated function int SendClientProjectileExplosion(Vector ExplosionLocation, KFProjectile ExplodingProjectile);

// Export UKFWeapon::execSendClientFragmentImpact(FFrame&, void* const)
protected native simulated function int SendClientFragmentImpact(const out ImpactInfo Impact, class<KFProjectile> FragmentClass);

// Export UKFWeapon::execGetSafeStartTraceLocation(FFrame&, void* const)
protected native simulated function Vector GetSafeStartTraceLocation();

simulated function InstantFireClient_AddImpacts(Vector StartTrace, Rotator Aim, out array<ImpactInfo> ImpactList);

simulated function InstantFireClient()
{
    local Vector StartTrace, EndTrace;
    local Rotator AimRot;
    local array<ImpactInfo> ImpactList;
    local int Idx;
    local ImpactInfo RealImpact;
    local float CurPenetrationValue;

    bInstantHit = true;
    StartTrace = GetSafeStartTraceLocation();
    AimRot = GetAdjustedAim(StartTrace);
    EndTrace = StartTrace + (vector(AimRot) * (GetTraceRange()));
    bInstantHit = false;
    PenetrationPowerRemaining = GetInitialPenetrationPower(CurrentFireMode);
    CurPenetrationValue = PenetrationPowerRemaining;
    RealImpact = CalcWeaponFire(StartTrace, EndTrace, ImpactList);
    if(Instigator != none)
    {
        Instigator.SetFlashLocation(self, CurrentFireMode, RealImpact.HitLocation);
    }
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        InstantFireClient_AddImpacts(StartTrace, AimRot, ImpactList);
        Idx = 0;
        J0x18C:

        if(Idx < ImpactList.Length)
        {
            ProcessInstantHitEx(CurrentFireMode, ImpactList[Idx],, CurPenetrationValue, Idx);
            ++ Idx;
            goto J0x18C;
        }
        if(Instigator.Role < ROLE_Authority)
        {
            SendClientImpactList(CurrentFireMode, ImpactList);
        }
    }
}

event RecieveClientImpact(byte FiringMode, const out ImpactInfo Impact, optional out float PenetrationValue, optional int ImpactNum)
{
    if(FiringMode == 3)
    {
        MeleeAttackHelper.ProcessMeleeHit(FiringMode, Impact);        
    }
    else
    {
        if((KFPawn_Monster(Impact.HitActor) != none) && PenetrationValue < (GetInitialPenetrationPower(FiringMode)))
        {
            ImpactNum = 1;
        }
        ProcessInstantHitEx(FiringMode, Impact,, PenetrationValue, ImpactNum);
    }
}

event RecieveClientProjectileExplosion(Vector ExplosionLocation, KFProjectile ExplodingProjectile)
{
    ExplodingProjectile.CallExplode(ExplosionLocation, vect(0, 0, 1));
}

simulated function HandleClientProjectileExplosion(Vector ExplosionLocation, KFProjectile ExplodingProjectile)
{
    SendClientProjectileExplosion(ExplosionLocation, ExplodingProjectile);
}

event RecieveClientImpactList(byte FiringMode, array<ImpactInfo> ImpactList);

simulated function int GetAmmoType(byte FiringMode)
{
    if((FiringMode == 1) && UsesSecondaryAmmo())
    {
        return 1;        
    }
    else
    {
        return 0;
    }
}

static simulated event bool UsesAmmo()
{
    return default.SpareAmmoCapacity[0] > 0;
}

static simulated event bool UsesSecondaryAmmo()
{
    return default.MagazineCapacity[1] > 0;
}

static simulated event bool CanRefillSecondaryAmmo()
{
    return (UsesSecondaryAmmo()) && default.bCanRefillSecondaryAmmo;
}

function InitializeAmmo()
{
    local KFPerk CurrentPerk;

    CurrentPerk = GetPerk();
    if(CurrentPerk != none)
    {
        CurrentPerk.ModifyMagSizeAndNumber(self, MagazineCapacity[0]);
        CurrentPerk.ModifyMagSizeAndNumber(self, MagazineCapacity[1],, true);
        CurrentPerk.ModifyMaxSpareAmmoAmount(self, SpareAmmoCapacity[0]);
        CurrentPerk.ModifyMaxSpareAmmoAmount(self, SpareAmmoCapacity[1],, true);
    }
    AmmoCount[0] = MagazineCapacity[0];
    AmmoCount[1] = MagazineCapacity[1];
    AddAmmo(InitialSpareMags[0] * default.MagazineCapacity[0]);
    if(CurrentPerk != none)
    {
        CurrentPerk.ModifySpareAmmoAmount(self, SpareAmmoCount[0]);
        CurrentPerk.ModifySpareAmmoAmount(self, SpareAmmoCount[1],, true);
    }
    AddAmmo(0);
    bForceNetUpdate = true;
}

function ReInitializeAmmoCounts(KFPerk CurrentPerk)
{
    if(CurrentPerk != none)
    {
        MagazineCapacity[0] = default.MagazineCapacity[0];
        MagazineCapacity[1] = default.MagazineCapacity[1];
        SpareAmmoCapacity[0] = default.SpareAmmoCapacity[0];
        SpareAmmoCapacity[1] = default.SpareAmmoCapacity[1];
        CurrentPerk.ModifyMagSizeAndNumber(self, MagazineCapacity[0]);
        CurrentPerk.ModifyMagSizeAndNumber(self, MagazineCapacity[1],, true);
        CurrentPerk.ModifyMaxSpareAmmoAmount(self, SpareAmmoCapacity[0]);
        CurrentPerk.ModifyMaxSpareAmmoAmount(self, SpareAmmoCapacity[1],, true);
        AddAmmo(0);
    }
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    local byte AmmoType;
    local KFPerk InstigatorPerk;

    AmmoType = byte(GetAmmoType(FireModeNum));
    InstigatorPerk = GetPerk();
    if((InstigatorPerk != none) && InstigatorPerk.GetIsUberAmmoActive(self))
    {
        return;
    }
    if((Role == ROLE_Authority) || bAllowClientAmmoTracking)
    {
        if((MagazineCapacity[AmmoType] > 0) && AmmoCount[AmmoType] > 0)
        {
            AmmoCount[AmmoType] = byte(Max(AmmoCount[AmmoType] - AmmoCost[FireModeNum], 0));
        }
    }
}

function int AddAmmo(int Amount)
{
    local int OldSpareAmmo;

    if((GetMaxAmmoAmount(0)) <= 0)
    {
        return 0;
    }
    if(bLogAmmo)
    {
        LogInternal((string(self) @ "Add Amount =") @ string(Amount));
    }
    if(bLogAmmo)
    {
        LogInternal((string(self) @ "SpareAmmoCapacity[0] =") @ string(GetMaxAmmoAmount(0)));
    }
    if(bLogAmmo)
    {
        LogInternal((string(self) @ "SpareAmmoCount[0] =") @ string(SpareAmmoCount[0]));
    }
    if(bLogAmmo)
    {
        LogInternal((string(self) @ "AmmoCount[0] =") @ string(AmmoCount[0]));
    }
    OldSpareAmmo = SpareAmmoCount[0];
    SpareAmmoCount[0] = Min(SpareAmmoCount[0] + Amount, (GetMaxAmmoAmount(0)) - AmmoCount[0]);
    bForceNetUpdate = true;
    if(bLogAmmo)
    {
        LogInternal((string(self) @ "SpareAmmoCount[0] AFTER =") @ string(SpareAmmoCount[0]));
    }
    if(bLogAmmo)
    {
        LogInternal(((string(self) @ "Added") @ string(SpareAmmoCount[0] - OldSpareAmmo)) @ "Ammo");
    }
    return SpareAmmoCount[0] - OldSpareAmmo;
}

function AddTransactionAmmo(int TransactionPrimaryAmmo, int TransactionSecondaryAmmo)
{
    local int SpareAmmoToAdd, ExtraTransactionAmmo;

    if(TransactionPrimaryAmmo >= 0)
    {
        AddAmmo(TransactionPrimaryAmmo);        
    }
    else
    {
        SpareAmmoToAdd = Max(-SpareAmmoCount[0], TransactionPrimaryAmmo);
        ExtraTransactionAmmo = TransactionPrimaryAmmo - SpareAmmoToAdd;
        AddAmmo(SpareAmmoToAdd);
        AmmoCount[0] = byte(Max(0, AmmoCount[0] + ExtraTransactionAmmo));
        ClientForceAmmoUpdate(AmmoCount[0], SpareAmmoCount[0]);
    }
    AddSecondaryAmmo(TransactionSecondaryAmmo);
}

function int AddSecondaryAmmo(int Amount)
{
    local int OldAmmo;

    if(!CanRefillSecondaryAmmo())
    {
        return 0;
    }
    OldAmmo = AmmoCount[1];
    AmmoCount[1] = byte(Min(AmmoCount[1] + Amount, MagazineCapacity[1]));
    bForceNetUpdate = true;
    if(bAllowClientAmmoTracking)
    {
        ClientForceSecondaryAmmoUpdate(AmmoCount[1]);
    }
    return AmmoCount[1] - OldAmmo;
}

reliable client simulated function ClientForceAmmoUpdate(byte NewAmmoCount, int NewSpareAmmoCount, optional bool bAmmoSync)
{
    if(Role < ROLE_Authority)
    {
        if(bAmmoSync)
        {
            if(bDebug)
            {
                LogInternal(((((((((string(self) @ string(GetFuncName())) @ "ServerAmmo Primary:") $ string(NewAmmoCount)) @ "ClientAmmo Primary:") $ string(AmmoCount[0])) @ "ServerSpareAmmo Primary:") $ string(NewSpareAmmoCount)) @ "ClientSpareAmmo Primary:") $ string(SpareAmmoCount[0]));
            }
            if(NewAmmoCount != AmmoCount[0])
            {
                LogInternal(((((string(self) @ string(GetFuncName())) @ "Primary Ammo mismatch Server:") $ string(NewAmmoCount)) @ "Client:") $ string(AmmoCount[0]));
            }
            if(NewSpareAmmoCount != SpareAmmoCount[0])
            {
                LogInternal(((((string(self) @ string(GetFuncName())) @ "Primary SpareAmmo mismatch Server:") $ string(NewSpareAmmoCount)) @ "Client:") $ string(SpareAmmoCount[0]));
            }
            AmmoCount[0] = byte(Min(NewAmmoCount, AmmoCount[0]));
            SpareAmmoCount[0] = Min(NewSpareAmmoCount, SpareAmmoCount[0]);            
        }
        else
        {
            AmmoCount[0] = NewAmmoCount;
            SpareAmmoCount[0] = NewSpareAmmoCount;
        }
        NotifyHUDofWeapon(Pawn(Owner));
    }
}

reliable client simulated function ClientForceSecondaryAmmoUpdate(byte NewSecondaryAmmoCount)
{
    if(Role < ROLE_Authority)
    {
        if(bDebug)
        {
            LogInternal(((((string(self) @ string(GetFuncName())) @ "ServerAmmo Secondary:") $ string(NewSecondaryAmmoCount)) @ "ClientAmmo Secondary:") $ string(AmmoCount[1]));
        }
        if(NewSecondaryAmmoCount != AmmoCount[1])
        {
            LogInternal(((((string(self) @ string(GetFuncName())) @ "Secondary Ammo mismatch Server:") $ string(NewSecondaryAmmoCount)) @ "Client:") $ string(AmmoCount[1]));
        }
        AmmoCount[1] = NewSecondaryAmmoCount;
        NotifyHUDofWeapon(Pawn(Owner));
    }
}

unreliable client simulated function NotifyHUDofWeapon(Pawn P)
{
    local KFPlayerController KFPC;

    if(Role < ROLE_Authority)
    {
        KFPC = KFPlayerController(P.Owner);
        if((KFPC != none) && KFPC.myGfxHUD != none)
        {
            KFPC.myGfxHUD.NotifyHUDofWeapon();
        }
    }
}

simulated event bool HasAmmo(byte FireModeNum, optional int Amount)
{
    local KFPerk InstigatorPerk;

    if(FireModeNum == 3)
    {
        return true;        
    }
    else
    {
        if(FireModeNum == 2)
        {
            return CanReload();            
        }
        else
        {
            if(FireModeNum == 4)
            {
                if(KFInventoryManager(InvManager) != none)
                {
                    return KFInventoryManager(InvManager).HasGrenadeAmmo(Amount);
                }
            }
        }
    }
    InstigatorPerk = GetPerk();
    if((InstigatorPerk != none) && InstigatorPerk.GetIsUberAmmoActive(self))
    {
        return true;
    }
    if(Amount == 0)
    {
        Amount = AmmoCost[FireModeNum];
    }
    return AmmoCount[GetAmmoType(FireModeNum)] >= Amount;
}

simulated function bool HasAnyAmmo()
{
    if((HasSpareAmmo()) || HasAmmo(0))
    {
        return true;
    }
    if((UsesSecondaryAmmo()) && (HasSpareAmmo(1)) || HasAmmo(1))
    {
        return true;
    }
    return false;
}

simulated event bool HasSpareAmmo(optional byte FireModeNum)
{
    return bInfiniteSpareAmmo || SpareAmmoCount[GetAmmoType(FireModeNum)] > 0;
}

simulated event int GetTotalAmmoAmount(byte FiringMode)
{
    return AmmoCount[GetAmmoType(FiringMode)] + SpareAmmoCount[GetAmmoType(FiringMode)];
}

simulated event int GetMaxAmmoAmount(byte FiringMode)
{
    return SpareAmmoCapacity[GetAmmoType(FiringMode)] + MagazineCapacity[GetAmmoType(FiringMode)];
}

simulated event int GetMissingSpareAmmoAmount(byte FiringMode)
{
    return SpareAmmoCapacity[GetAmmoType(FiringMode)] - SpareAmmoCount[GetAmmoType(FiringMode)];
}

simulated function float GetAmmoPercentage(optional byte FiringMode)
{
    if(SpareAmmoCapacity[GetAmmoType(FiringMode)] == 0)
    {
        return -1;
    }
    return float(GetTotalAmmoAmount(FiringMode)) / float(GetMaxAmmoAmount(FiringMode));
}

simulated function int GetSpareAmmoForHUD()
{
    return SpareAmmoCount[0];
}

simulated function int GetSecondaryAmmoForHUD()
{
    return AmmoCount[1] + SpareAmmoCount[1];
}

simulated function bool ForceReload()
{
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        if(CanReload())
        {
            StartFire(2);
            return true;
        }
    }
    return false;
}

simulated function bool CanReload(optional byte FireModeNum)
{
    local KFPawn P;
    local bool bInstigatorCanReload;
    local byte AmmoType;

    P = KFPawn(Instigator);
    AmmoType = byte(GetAmmoType(FireModeNum));
    bInstigatorCanReload = (P != none) && P.CanReloadWeapon();
    return ((bCanBeReloaded && bInstigatorCanReload) && AmmoCount[AmmoType] < MagazineCapacity[AmmoType]) && HasSpareAmmo(AmmoType);
}

simulated function bool ShouldAutoReload(byte FireModeNum)
{
    local bool bHasAmmo;

    bHasAmmo = HasAmmo(FireModeNum);
    if((!bHasAmmo && Instigator != none) && Instigator.IsLocallyControlled())
    {
        if(bPendingAutoSwitchOnDryFire)
        {
            if(CanSwitchWeapons())
            {
                if(!HasAnyAmmo())
                {
                    Instigator.Controller.ClientSwitchToBestWeapon(false);
                }
            }
            bPendingAutoSwitchOnDryFire = false;            
        }
        else
        {
            WeaponPlaySound(WeaponDryFireSnd[FireModeNum]);
            if(Role < ROLE_Authority)
            {
                ServerPlayDryFireSound(FireModeNum);
            }
            bPendingAutoSwitchOnDryFire = !HasAnyAmmo();
        }
    }
    return !bHasAmmo && CanReload();
}

simulated function bool ShouldAutoReloadGunslinger(byte FireModeNum)
{
    local KFPerk InstigatorPerk;
    local KFWeapon NewWeapon;
    local KFInventoryManager KFIM;
    local bool bHasAmmo;

    bHasAmmo = HasAmmo(FireModeNum);
    InstigatorPerk = GetPerk();
    if(((!bHasAmmo && CanSwitchWeapons()) && InstigatorPerk != none) && InstigatorPerk.ShouldInstantlySwitchWeapon(self))
    {
        KFIM = KFInventoryManager(InvManager);
        if(KFIM != none)
        {
            NewWeapon = KFIM.GetBestPerkWeaponWithAmmo(InstigatorPerk.Class, true);
            if(NewWeapon != none)
            {
                KFIM.SetCurrentWeapon(NewWeapon);
                return false;
            }
        }
    }
    if((!bHasAmmo && Instigator != none) && Instigator.IsLocallyControlled())
    {
        if(bPendingAutoSwitchOnDryFire)
        {
            if(CanSwitchWeapons())
            {
                if(!HasAnyAmmo())
                {
                    Instigator.Controller.ClientSwitchToBestWeapon(false);
                }
            }
            bPendingAutoSwitchOnDryFire = false;            
        }
        else
        {
            WeaponPlaySound(WeaponDryFireSnd[FireModeNum]);
            if(Role < ROLE_Authority)
            {
                ServerPlayDryFireSound(FireModeNum);
            }
            bPendingAutoSwitchOnDryFire = !HasAnyAmmo();
        }
    }
    return !bHasAmmo && CanReload();
}

protected reliable server function ServerPlayDryFireSound(byte FireModeNum)
{
    WeaponPlaySound(WeaponDryFireSnd[FireModeNum]);
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    Mesh.SetLightingChannels(NewLightingChannels);
    if(LaserSight != none)
    {
        LaserSight.SetMeshLightingChannels(NewLightingChannels);
    }
}

simulated function GetWeaponDebug(out array<string> DebugInfo)
{
    super.GetWeaponDebug(DebugInfo);
    DebugInfo[DebugInfo.Length] = (("AmmoCount Primary:" $ string(AmmoCount[0])) @ "MagazineSize Primary:") $ string(MagazineCapacity[0]);
    DebugInfo[DebugInfo.Length] = (("SpareAmmoCount Primary:" $ string(SpareAmmoCount[0])) @ "SpareAmmoCapacity Primary:") $ string(GetMaxAmmoAmount(0));
    DebugInfo[DebugInfo.Length] = (("AmmoCount Secondary:" $ string(AmmoCount[1])) @ "MagazineSize Secondary:") $ string(MagazineCapacity[1]);
    if(KFInventoryManager(InvManager) != none)
    {
        DebugInfo[DebugInfo.Length] = (("GrenadeCount:" $ string(KFInventoryManager(InvManager).GrenadeCount)) @ "MaxGrenades:") $ string(GetPerk().MaxGrenadeCount);
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local string CurAnim, CurHandAnim;
    local Vector FADebugLineStart, FADebugLineEnd, FADebugLineUL, FADebugLineUR, FADebugLineLL, FADebugLineLR;

    local Rotator FADebugLineRot, FADebugViewRotation;
    local int UsedMaxYawLimit, UsedMaxPitchLimit, UsedMinYawLimit, UsedMinPitchLimit;
    local Rotator AimRotation, WeaponBufferRot;

    super.DisplayDebug(HUD, out_YL, out_YPos);
    if(HUD.ShouldDisplayDebug('Camera'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: Camera ----------");
        out_YPos += out_YL;
        HUD.Canvas.DrawText((((((("WEAPONCAMERA MeshFOV=" $ string(MeshFOV)) @ "MeshIronSightFOV=") $ string(MeshIronSightFOV)) @ "CameraIronSightFOV=") $ string(PlayerIronSightFOV)) @ " CurrentMeshFOV = ") $ string(MySkelMesh.FOV));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Zooming'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: Zooming ----------");
        out_YPos += out_YL;
        HUD.Canvas.DrawText((((((((("ZOOMING ZoomRotInterp=" $ string(ZoomRotInterp)) @ "bDoingQuickDownZoom=") $ string(bDoingQuickDownZoom)) @ "QuickWeaponDownRotation=") $ string(QuickWeaponDownRotation)) @ " ZoomInRotation = ") $ string(ZoomInRotation)) $ " PlayerViewOffset= ") $ string(PlayerViewOffset));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('FireOffset'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: FireOffset ----------");
        out_YPos += out_YL;
        HUD.Canvas.DrawText("PROJECTILE SPAWNING FireOffset=" $ string(FireOffset));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        if(Instigator.IsFirstPerson())
        {
            HUD.DrawDebugSphere(GetMuzzleLoc(), 3, 6, 255, 0, 0);            
        }
        else
        {
            if(CurrentFireMode == 4)
            {
                HUD.DrawDebugSphere(Instigator.GetPawnViewLocation() + (GrenadeFireOffset >> Instigator.Rotation), 3, 6, 0, 255, 0);                
            }
            else
            {
                HUD.DrawDebugSphere(Instigator.GetPawnViewLocation() + (FireOffset >> Instigator.Rotation), 3, 6, 255, 0, 0);
            }
        }
    }
    if(HUD.ShouldDisplayDebug('animation'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: animation ----------");
        out_YPos += out_YL;
        if((GetWeaponAnimNodeSeq()) != none)
        {
            CurAnim = string(GetWeaponAnimNodeSeq().AnimSeqName);
            HUD.Canvas.DrawText((((("WEAPON WeaponAnim=" $ CurAnim) $ " Rate: ") $ string(GetWeaponAnimNodeSeq().Rate)) $ " Position: ") $ string(GetWeaponAnimNodeSeq().CurrentTime));
            out_YPos += out_YL;
            HUD.Canvas.SetPos(4, out_YPos);
        }
        if((GetArmAnimNodeSeq()) != none)
        {
            CurHandAnim = string(GetArmAnimNodeSeq().AnimSeqName);
            HUD.Canvas.DrawText((((("WEAPON HandAnim=" $ CurHandAnim) $ " Rate: ") $ string(GetArmAnimNodeSeq().Rate)) $ " Position: ") $ string(GetArmAnimNodeSeq().CurrentTime));
            out_YPos += out_YL;
            HUD.Canvas.SetPos(4, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('aim3d'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: aim3d ----------");
        out_YPos += out_YL;
        if(KFPlayerController(Instigator.Controller) != none)
        {
            KFPlayerController(Instigator.Controller).GetPlayerViewPoint(FADebugLineStart, AimRotation);
        }
        if(bDebugRecoilPosition)
        {
            WeaponBufferRot.Pitch = RecoilISMaxPitchLimit;
            WeaponBufferRot.Yaw += TotalRecoilRotator.Yaw;
            WeaponBufferRot.Pitch += TotalRecoilRotator.Pitch;            
        }
        else
        {
            WeaponBufferRot = KFPlayerController(Instigator.Controller).WeaponBufferRotation;
        }
        FADebugLineRot.Yaw = AimRotation.Yaw + WeaponBufferRot.Yaw;
        FADebugLineRot.Pitch = AimRotation.Pitch + WeaponBufferRot.Pitch;
        FADebugLineEnd = FADebugLineStart + (float(400) * vector(FADebugLineRot));
        DrawDebugSphere(FADebugLineEnd, 5, 8, 0, 255, 0, false);
    }
    if(HUD.ShouldDisplayDebug('recoil3d'))
    {
        HUD.Canvas.SetPos(4, out_YPos);
        HUD.Canvas.DrawText("---------- KFWeapon: recoil3d ----------");
        out_YPos += out_YL;
        if(KFPlayerController(Instigator.Controller) != none)
        {
            KFPlayerController(Instigator.Controller).GetPlayerViewPoint(FADebugLineStart, FADebugViewRotation);
        }
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw + TotalRecoilRotator.Yaw;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch + TotalRecoilRotator.Pitch;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        DrawDebugBox(FADebugLineEnd, vect(0.1, 0.1, 0.1), 255, 255, 0, false);
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        DrawDebugBox(FADebugLineEnd, vect(0.1, 0.1, 0.1), 255, 0, 128, false);
        if(bUsingSights)
        {
            UsedMaxYawLimit = RecoilISMaxYawLimit;
            UsedMinYawLimit = RecoilISMinYawLimit;
            UsedMaxPitchLimit = RecoilISMaxPitchLimit;
            UsedMinPitchLimit = RecoilISMinPitchLimit;            
        }
        else
        {
            UsedMaxYawLimit = RecoilMaxYawLimit;
            UsedMinYawLimit = RecoilMinYawLimit;
            UsedMaxPitchLimit = RecoilMaxPitchLimit;
            UsedMinPitchLimit = RecoilMinPitchLimit;
        }
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw + UsedMinYawLimit;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch + UsedMaxPitchLimit;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineUL = FADebugLineEnd;
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw + UsedMaxYawLimit;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch + UsedMaxPitchLimit;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineUR = FADebugLineEnd;
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw + UsedMinYawLimit;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch + UsedMinPitchLimit;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineLL = FADebugLineEnd;
        FADebugLineRot.Yaw = FADebugViewRotation.Yaw + UsedMaxYawLimit;
        FADebugLineRot.Pitch = FADebugViewRotation.Pitch + UsedMinPitchLimit;
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineLR = FADebugLineEnd;
        DrawDebugLine(FADebugLineUL, FADebugLineUR, 255, 0, 255, false);
        DrawDebugLine(FADebugLineUR, FADebugLineLR, 255, 0, 255, false);
        DrawDebugLine(FADebugLineLR, FADebugLineLL, 255, 0, 255, false);
        DrawDebugLine(FADebugLineLL, FADebugLineUL, 255, 0, 255, false);
        FADebugLineRot.Yaw = int(float(FADebugViewRotation.Yaw) + (float(UsedMinYawLimit) + (float(65535 - UsedMinYawLimit) * (1 - FullRecoilYawPct))));
        FADebugLineRot.Pitch = int(float(FADebugViewRotation.Pitch) + (float(UsedMaxPitchLimit) * FullRecoilPitchPct));
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineUL = FADebugLineEnd;
        FADebugLineRot.Yaw = int(float(FADebugViewRotation.Yaw) + (float(UsedMaxYawLimit) * FullRecoilYawPct));
        FADebugLineRot.Pitch = int(float(FADebugViewRotation.Pitch) + (float(UsedMaxPitchLimit) * FullRecoilPitchPct));
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineUR = FADebugLineEnd;
        FADebugLineRot.Yaw = int(float(FADebugViewRotation.Yaw) + (float(UsedMinYawLimit) + (float(65535 - UsedMinYawLimit) * (1 - FullRecoilYawPct))));
        FADebugLineRot.Pitch = int(float(FADebugViewRotation.Pitch) + (float(UsedMinPitchLimit) + (float(65535 - UsedMinPitchLimit) * (1 - FullRecoilYawPct))));
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineLL = FADebugLineEnd;
        FADebugLineRot.Yaw = int(float(FADebugViewRotation.Yaw) + (float(UsedMaxYawLimit) * FullRecoilYawPct));
        FADebugLineRot.Pitch = int(float(FADebugViewRotation.Pitch) + (float(UsedMinPitchLimit) + (float(65535 - UsedMinPitchLimit) * (1 - FullRecoilYawPct))));
        FADebugLineEnd = FADebugLineStart + (float(20) * vector(FADebugLineRot));
        FADebugLineLR = FADebugLineEnd;
        DrawDebugLine(FADebugLineUL, FADebugLineUR, 128, 255, 255, false);
        DrawDebugLine(FADebugLineUR, FADebugLineLR, 128, 255, 255, false);
        DrawDebugLine(FADebugLineLR, FADebugLineLL, 128, 255, 255, false);
        DrawDebugLine(FADebugLineLL, FADebugLineUL, 128, 255, 255, false);
    }
}

static simulated event class<KFPerk> GetWeaponPerkClass(class<KFPerk> InstigatorPerkClass)
{
    if(default.AssociatedPerkClasses.Length > 1)
    {
        if(default.AssociatedPerkClasses.Find(InstigatorPerkClass != -1)
        {
            return InstigatorPerkClass;
        }
    }
    return default.AssociatedPerkClasses[0];
}

static simulated function bool AllowedForAllPerks()
{
    return false;
}

static event array< class<KFPerk> > GetAssociatedPerkClasses()
{
    return default.AssociatedPerkClasses;
}

static simulated event class<KFPerk> GetWeaponPerkClassByIndex(int Index)
{
    return default.AssociatedPerkClasses[Index];
}

static simulated function bool IsMultiPerkWeapn()
{
    return default.AssociatedPerkClasses.Length > 1;
}

simulated function byte GetWeaponStateId()
{
    return 0;
}

simulated function float GetThirdPersonAnimRate()
{
    return 1;
}

simulated function UpdateWeaponAttachmentAnimRate(float Rate)
{
    local KFPawn_Human KFPH;

    KFPH = KFPawn_Human(Instigator);
    if(KFPH != none)
    {
        KFPH.SetWeaponAttachmentAnimRateByte(Rate);
    }
}

simulated function NotifyBeginState()
{
    UpdateWeaponAttachmentAnimRate(GetThirdPersonAnimRate());
    KFPawn(Instigator).WeaponStateChanged(GetWeaponStateId());
}

simulated function NotifyEndState()
{
    UpdateWeaponAttachmentAnimRate(1);
    KFPawn(Instigator).WeaponStateChanged(0);
}

function bool CanUpgradeWeapon()
{
    if(bLogWeaponUpgrade)
    {
        LogInternal((((((string(self) @ "-") @ string(GetFuncName())) @ "- CurrentWeaponUpgradeIndex + 1:") @ string(CurrentWeaponUpgradeIndex + 1)) @ "WeaponUpgrades.length:") @ string(WeaponUpgrades.Length));
    }
    return (CurrentWeaponUpgradeIndex + 1) < WeaponUpgrades.Length;
}

simulated function UpgradeWeapon()
{
    if(CanUpgradeWeapon())
    {
        SetWeaponUpgradeLevel(CurrentWeaponUpgradeIndex + 1);
    }
}

simulated function SetWeaponUpgradeLevel(int WeaponUpgradeLevel)
{
    if(bLogWeaponUpgrade)
    {
        LogInternal((((string(self) @ "-") @ string(GetFuncName())) @ "- Setting Upgrade Index to") @ string(WeaponUpgradeLevel));
    }
    CurrentWeaponUpgradeIndex = WeaponUpgradeLevel;
    bNetDirty = true;
}

simulated function int GetModifiedWeightValue()
{
    return InventorySize + WeaponUpgrades[CurrentWeaponUpgradeIndex].IncrementWeight;
}

static simulated function int GetUpgradeWeight(int UpgradeIndex)
{
    if((UpgradeIndex < 0) || UpgradeIndex >= default.WeaponUpgrades.Length)
    {
        return 0;
    }
    return default.WeaponUpgrades[UpgradeIndex].IncrementWeight;
}

static simulated function float GetUpgradeDamageMod(int UpgradeIndex)
{
    if((UpgradeIndex < 0) || UpgradeIndex >= default.WeaponUpgrades.Length)
    {
        return 1;
    }
    return FMax(default.WeaponUpgrades[UpgradeIndex].IncrementDamage, 1);
}

static simulated function float GetUpgradeHealMod(int UpgradeIndex)
{
    if((UpgradeIndex < 0) || UpgradeIndex >= default.WeaponUpgrades.Length)
    {
        return 1;
    }
    return default.WeaponUpgrades[UpgradeIndex].IncrementHeal;
}

static simulated function float GetUpgradeHealRechargeMod(int UpgradeIndex)
{
    if((UpgradeIndex < 0) || UpgradeIndex >= default.WeaponUpgrades.Length)
    {
        return 1;
    }
    return default.WeaponUpgrades[UpgradeIndex].IncrementHealFullRecharge;
}

reliable server function ServerSyncReload(int ClientSpareAmmoCount)
{
    local int ClientReloadAmount;

    if(bAllowClientAmmoTracking && ClientSpareAmmoCount < InitialReloadSpareAmmo)
    {
        ClientReloadAmount = Min(InitialReloadSpareAmmo - ClientSpareAmmoCount, InitialReloadSpareAmmo);
        SpareAmmoCount[0] -= ClientReloadAmount;
        AmmoCount[0] = byte(Min(AmmoCount[0] + ClientReloadAmount, MagazineCapacity[0]));
    }
}

simulated function Activate()
{
    if(!WeaponContentLoaded)
    {
        AttachOnContentLoad = true;
        return;
    }
    if(bUseAltFireMode)
    {
        ClearPendingFire(0);        
    }
    else
    {
        ClearPendingFire(1);
    }
    AttachWeaponTo(Instigator.Mesh);
    if((((MySkelMesh != none) && MySkelMesh.bAnimTreeInitialised) && WeaponAnimSeqNode == none) && Len(FirstPersonAnimTree) > 0)
    {
        PostInitAnimTree(MySkelMesh);
    }
    super.Activate();
}

simulated function PlayIdleAnim();

simulated function StartIdleFidgetTimer();

simulated function IdleFidgetTimer();

simulated function bool CanPlayIdleFidget(optional bool bOnReload);

simulated function bool PlayIdleFidgetAnim();

simulated function ANIMNOTIFY_EnableAdditiveBob();

simulated function CheckPendingIronsights()
{
    local PlayerController PC;

    if(Instigator.IsLocallyControlled())
    {
        PC = PlayerController(Instigator.Controller);
        if((PC != none) && PC.PlayerInput != none)
        {
            if(KFPlayerInput(PC.PlayerInput).bIronsightsHeld)
            {
                SetIronSights(true);
            }
        }
    }
}

simulated function TimeWeaponEquipping()
{
    local KFPerk InstigatorPerk;
    local float ModifiedEquipTime;

    if(!WeaponContentLoaded)
    {
        return;
    }
    ModifiedEquipTime = MySkelMesh.GetAnimLength(EquipAnim);
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.ModifyWeaponSwitchTime(ModifiedEquipTime);
    }
    PlayWeaponEquip(ModifiedEquipTime);
    SetTimer(((EquipTime > float(0)) ? EquipTime : 0.01), false, 'WeaponEquipped');
}

simulated function WeaponEquipped();

simulated function PlayWeaponEquip(float ModifiedEquipTime)
{
    PlayAnimation(GetEquipAnimName(), ModifiedEquipTime);
}

simulated function name GetEquipAnimName()
{
    return EquipAnim;
}

simulated function SetSimplePutDown(bool bPutDownWeapon)
{
    if(bPutDownWeapon)
    {
        GotoState('WeaponDownSimple');
    }
}

simulated function bool CanSwitchWeapons()
{
    return true;
}

simulated function TimeWeaponPutDown()
{
    local KFPerk InstigatorPerk;
    local float ModifiedPutDownTime;

    ModifiedPutDownTime = PutDownTime;
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.ModifyWeaponSwitchTime(ModifiedPutDownTime);
    }
    SetTimer(((ModifiedPutDownTime > float(0)) ? ModifiedPutDownTime : 0.01), false, 'WeaponIsDown');
    if(Instigator.IsFirstPerson())
    {
        PlayWeaponPutDown(ModifiedPutDownTime);
    }
}

simulated function PlayWeaponPutDown(float ModifiedPutDownTime)
{
    PlayAnimation(GetWeaponPutDownAnimName(), ModifiedPutDownTime);
}

simulated function name GetWeaponPutDownAnimName()
{
    return PutDownAnim;
}

simulated function bool TryPutDown()
{
    local float MinTimerTarget, TimerCount;

    bWeaponPutDown = true;
    if(!IsTimerActive('RefireCheckTimer'))
    {
        PutDownWeapon();        
    }
    else
    {
        MinTimerTarget = GetTimerRate('RefireCheckTimer') * MinFiringPutDownPct;
        TimerCount = GetTimerCount('RefireCheckTimer');
        if(TimerCount >= MinTimerTarget)
        {
            PutDownWeapon();            
        }
        else
        {
            SetTimer(MinTimerTarget - TimerCount, false, 'FiringPutDownWeapon');
        }
    }
    return true;
}

simulated function FiringPutDownWeapon()
{
    if(bWeaponPutDown)
    {
        PutDownWeapon();
    }
}

simulated function TimeWeaponFiring(byte FireModeNum)
{
    local float AdjustedFireInterval;
    local KFPerk CurrentPerk;

    if(!IsTimerActive('RefireCheckTimer'))
    {
        AdjustedFireInterval = GetFireInterval(FireModeNum);
        CurrentPerk = GetPerk();
        if(CurrentPerk != none)
        {
            CurrentPerk.ModifyRateOfFire(AdjustedFireInterval, self);
        }
        SetTimer(AdjustedFireInterval, true, 'RefireCheckTimer');
    }
}

simulated function int GetBurstAmount()
{
    return 1;
}

private reliable server final function ServerGotoGrenadeFiring()
{
    if(HasAmmo(4))
    {
        SendToFiringState(4);
    }
}

function SetWeakZedGrabCooldownOnPawn(float WeakZedGrabCooldown)
{
    local KFPawn KFP;

    if(Role == ROLE_Authority)
    {
        KFP = KFPawn(Instigator);
        if(KFP != none)
        {
            KFP.SetWeakGrabCoolDown(WeakZedGrabCooldown);
        }
    }
}

simulated function PlayGrenadeThrow()
{
    local name WeaponFireAnimName;

    PlayFiringSound(CurrentFireMode);
    if((Instigator != none) && Instigator.IsFirstPerson())
    {
        WeaponFireAnimName = GetGrenadeThrowAnim();
        if(WeaponFireAnimName != 'None')
        {
            PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName),, FireTweenTime);
        }
    }
}

simulated function name GetGrenadeThrowAnim()
{
    return 'Nade_Throw';
}

simulated function ReloadStatusTimer();

simulated function ReloadAmmoTimer();

simulated function ReloadComplete();

simulated function AbortReload();

simulated function InitializeReload()
{
    ReloadAmountLeft = byte(Min(MagazineCapacity[0] - AmmoCount[0], SpareAmmoCount[0]));
    InitialReloadAmount = ReloadAmountLeft;
    InitialReloadSpareAmmo = SpareAmmoCount[0];
    if(Role < ROLE_Authority)
    {
        ServerSendToReload(ReloadAmountLeft);
    }
}

reliable server function ServerSendToReload(byte ClientReloadAmount)
{
    ReloadAmountLeft = ClientReloadAmount;
    InitialReloadAmount = ReloadAmountLeft;
    InitialReloadSpareAmmo = SpareAmmoCount[0];
    SendToFiringState(2);
}

simulated function bool CanOverrideMagReload(byte FireModeNum)
{
    if((FireModeNum == 3) || FireModeNum == 4)
    {
        return true;
    }
    return false;
}

simulated function TimeWeaponReloading()
{
    local name AnimName;
    local float AnimLength, AnimRate, AmmoTimer, StatusTimer;

    ReloadStatus = GetNextReloadStatus();
    if((ReloadStatus == 4) || MySkelMesh == none)
    {
        ReloadComplete();
        return;
    }
    AnimName = GetReloadAnimName(UseTacticalReload());
    AnimRate = GetReloadRateScale();
    AnimLength = AnimRate * MySkelMesh.GetAnimLength(AnimName);
    if(AnimLength > 0)
    {
        MakeNoise(0.5, 'PlayerReload');
        if(Instigator.IsFirstPerson())
        {
            PlayAnimation(AnimName, AnimLength);
        }
        if(ReloadStatus == 2)
        {
            AmmoTimer = AnimRate * MySkelMesh.GetReloadAmmoTime(AnimName);
            SetTimer(AmmoTimer, false, 'ReloadAmmoTimer');
        }
        if(bReloadFromMagazine || ReloadStatus == 3)
        {
            StatusTimer = AnimRate * MySkelMesh.GetAnimInterruptTime(AnimName);            
        }
        else
        {
            StatusTimer = AnimLength;
        }
        SetTimer(StatusTimer, false, 'ReloadStatusTimer');        
    }
    else
    {
        WarnInternal((("Reload duration is zero! Anim=" $ string(AnimName)) @ "Rate:") $ string(AnimRate));
        ReloadComplete();
    }
}

simulated function float GetReloadRateScale()
{
    local float Rate;
    local KFPerk MyPerk;

    Rate = 1;
    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        Rate = MyPerk.GetReloadRateScale(self);
    }
    return Rate;
}

simulated function bool UseTacticalReload()
{
    local KFPerk MyPerk;

    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        return MyPerk.GetUsingTactialReload(self);
    }
    return false;
}

simulated function KFWeapon.EReloadStatus GetNextReloadStatus(optional byte FireModeNum)
{
    if(bReloadFromMagazine)
    {
        if(ReloadStatus < 2)
        {
            return 2;
        }
        return 4;
    }
    switch(ReloadStatus)
    {
        case 0:
            return 1;
        case 1:
            return 2;
        case 2:
            if((HasSpareAmmo(FireModeNum)) && ReloadAmountLeft > 0)
            {
                return 2;
            }
            return 3;
        default:
            return 4;
            break;
    }
}

simulated function name GetReloadAnimName(bool bTacticalReload)
{
    if(!bReloadFromMagazine)
    {
        switch(ReloadStatus)
        {
            case 1:
                if(AmmoCount[0] == 0)
                {
                    ReloadStatus = GetNextReloadStatus();
                    return ((bTacticalReload) ? 'Reload_Open_Shell_Elite' : 'Reload_Open_Shell');
                }
                return ((bTacticalReload) ? 'Reload_Open_Elite' : 'Reload_Open');
            case 3:
                return ((bTacticalReload) ? 'Reload_Close_Elite' : 'Reload_Close');
            default:
                return ((bTacticalReload) ? 'Reload_Insert_Elite' : 'Reload_Insert');
                break;
        }
    }
    if(AmmoCount[0] > 0)
    {
        return ((bTacticalReload) ? 'Reload_Half_Elite' : 'Reload_Half');        
    }
    else
    {
        return ((bTacticalReload) ? 'Reload_Empty_Elite' : 'Reload_Empty');
    }
}

simulated function PerformReload(optional byte FireModeNum)
{
    local int ReloadAmount, AmmoType;

    AmmoType = GetAmmoType(FireModeNum);
    if(bInfiniteSpareAmmo)
    {
        AmmoCount[AmmoType] = MagazineCapacity[AmmoType];
        ReloadAmountLeft = 0;
        return;
    }
    if(((Role == ROLE_Authority) && !bAllowClientAmmoTracking) || Instigator.IsLocallyControlled() && bAllowClientAmmoTracking)
    {
        if(((GetMaxAmmoAmount(byte(AmmoType))) > 0) && SpareAmmoCount[AmmoType] > 0)
        {
            if(bReloadFromMagazine)
            {
                ReloadAmount = Min(ReloadAmountLeft, SpareAmmoCount[AmmoType]);                
            }
            else
            {
                ReloadAmount = 1;
            }
            AmmoCount[AmmoType] = byte(Min(AmmoCount[AmmoType] + ReloadAmount, MagazineCapacity[AmmoType]));
            SpareAmmoCount[AmmoType] -= ReloadAmount;
        }
    }
    if(bReloadFromMagazine)
    {
        ReloadAmountLeft = 0;        
    }
    else
    {
        if(ReloadAmountLeft > 0)
        {
            -- ReloadAmountLeft;
        }
    }
}

simulated function CheckBoltLockPostReload()
{
    if(bCheckBoltLockPostReload)
    {
        if(ReloadStatus < 4)
        {
            UpdateOutOfAmmoEffects(0);
        }
        bCheckBoltLockPostReload = false;
    }
}

simulated function SprintLoopTimer();

simulated function SprintRetryTimer();

simulated function PlaySprintStart()
{
    local KFPlayerController KFPC;
    local name AnimName;
    local float AnimDuration;

    if(bZoomingOut)
    {
        SetTimer(0.1, false, 'SprintRetryTimer');
        return;
    }
    AnimName = GetSprintStartAnimName();
    if(Instigator.IsLocallyControlled())
    {
        KFPC = KFPlayerController(Instigator.Controller);
        if(KFPC != none)
        {
            KFPC.HandleTransitionFOV(PlayerSprintFOV, 0.25);
        }
        PlayAnimation(AnimName);
    }
    AnimDuration = MySkelMesh.GetAnimLength(AnimName);
    if(AnimDuration > 0)
    {
        SetTimer(AnimDuration, false, 'SprintLoopTimer');        
    }
    else
    {
        SprintLoopTimer();
    }
}

simulated function name GetSprintStartAnimName()
{
    return 'Sprint_In';
}

simulated function PlaySprintLoop()
{
    local name AnimName;

    if(Instigator.IsLocallyControlled())
    {
        AnimName = GetSprintLoopAnimName();
        SprintAnimRate = GetSprintAnimRate();
        if(SprintCameraAnimInst != none)
        {
            SprintCameraAnimInst.Stop(true);
        }
        if(SprintCameraAnim != none)
        {
            SprintCameraAnimInst = PlayCameraAnim(SprintCameraAnim, SprintAnimRate, SprintAnimRate, 0.3, 0.5, true, true);
        }
        PlayAnimation(AnimName, MySkelMesh.GetAnimLength(AnimName) / SprintAnimRate, true);
    }
}

simulated function name GetSprintLoopAnimName()
{
    return 'Sprint_Loop';
}

simulated function PlaySprintEnd()
{
    local KFPlayerController KFPC;
    local name AnimName;

    if(Instigator.IsLocallyControlled())
    {
        AnimName = GetSprintEndAnimName();
        KFPC = KFPlayerController(Instigator.Controller);
        if((KFPC != none) && !bUsingSights)
        {
            KFPC.HandleTransitionFOV(KFPC.DefaultFOV, 0.25);
        }
        PlayAnimation(AnimName);
    }
}

simulated function name GetSprintEndAnimName()
{
    return 'Sprint_Out';
}

simulated function float GetSprintAnimRate()
{
    return 1;
}

simulated function bool IsMeleeing();

simulated function bool ShouldContinueMelee(optional int ChainCount);

simulated function NotifyMeleeCollision(Actor HitActor, optional Vector HitLocation);

simulated function PlayMeleeAnimation(name AnimName, out float out_Rate, float BlendTime)
{
    local KFPerk InstigatorPerk;
    local float Duration;

    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.ModifyMeleeAttackSpeed(out_Rate, self);
    }
    Duration = MySkelMesh.GetAnimLength(AnimName);
    Duration *= out_Rate;
    PlayAnimation(AnimName, Duration,, BlendTime);
}

simulated function int GetModifiedDamage(byte FireModeNum, optional Vector RayDir)
{
    return int(InstantHitDamage[FireModeNum] * FMax(WeaponUpgrades[CurrentWeaponUpgradeIndex].IncrementDamage, 1));
}

simulated function int GetMeleeDamage(byte FireModeNum, optional Vector RayDir)
{
    return int(InstantHitDamage[FireModeNum]);
}

simulated function float GetForceReloadDelay();

private reliable server final function ServerSyncWeaponFiring(byte FireModeNum)
{
    local bool bNeedsToSync;

    if(IsInState('Reloading'))
    {
        if((ReloadStatus == 2) && IsTimerActive('ReloadAmmoTimer'))
        {
            PerformReload();
            ClearTimer('ReloadAmmoTimer');
        }
        ReloadStatus = 4;
        if(bAllowClientAmmoTracking && !HasAmmo(FireModeNum))
        {
            ServerSyncReload(InitialReloadSpareAmmo - 1);
        }
        bNeedsToSync = true;        
    }
    else
    {
        if((IsInState('WeaponEquipping') || IsInState('MeleeAttackBasic')) || IsInState('WeaponSprinting'))
        {
            bNeedsToSync = true;
        }
    }
    if(bNeedsToSync)
    {
        if(HasAmmo(FireModeNum))
        {
            SendToFiringState(FireModeNum);            
        }
        else
        {
            WarnInternal(("KFWeapon::ServerSyncWeaponFiring()." $ string(GetStateName())) $ " - Failed to sync weapon ammo.");
        }
    }
}

static simulated event SetTraderWeaponStats(out array<STraderItemWeaponStats> WeaponStats)
{
    WeaponStats.Length = 4;
    WeaponStats[0].StatType = 0;
    WeaponStats[0].StatValue = CalculateTraderWeaponStatDamage();
    WeaponStats[1].StatType = 2;
    WeaponStats[1].StatValue = default.PenetrationPower[0];
    WeaponStats[2].StatType = 1;
    WeaponStats[3].StatType = 3;
    WeaponStats[3].StatValue = CalculateTraderWeaponStatFireRate();
}

static simulated function float CalculateTraderWeaponStatDamage()
{
    local float CalculatedDamage;
    local class<KFDamageType> DamageType;

    CalculatedDamage = default.InstantHitDamage[0];
    DamageType = class<KFDamageType>(default.InstantHitDamageTypes[0]);
    if((DamageType != none) && DamageType.default.DoT_Type != 0)
    {
        CalculatedDamage += ((DamageType.default.DoT_Duration / DamageType.default.DoT_Interval) * (CalculatedDamage * DamageType.default.DoT_DamageScale));
    }
    return CalculatedDamage;
}

static simulated function float CalculateTraderWeaponStatFireRate()
{
    return 60 / default.FireInterval[0];
}

static simulated event KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter();

static simulated event KFGFxObject_TraderItems.EFilterTypeUI GetAltTraderFilter()
{
    return 10;
}

auto state Inactive
{
    ignores ForceReload, ShouldAutoReload, AllowIronSights;

    simulated function BeginState(name PreviousStateName)
    {
        if(bUsingSights)
        {
            if(Instigator.IsLocallyControlled())
            {
                SetIronSights(false);
            }            
        }
        else
        {
            if(!bHasIronSights)
            {
                ClearPendingFire(1);
            }
        }
        ClearPendingFire(2);
        if((bAllowClientAmmoTracking && Role == ROLE_Authority) && WorldInfo.TimeSeconds > CreationTime)
        {
            ClientForceAmmoUpdate(AmmoCount[0], SpareAmmoCount[0], true);
            ClientForceSecondaryAmmoUpdate(AmmoCount[1]);
        }
        bPendingAutoSwitchOnDryFire = false;
        super.BeginState(PreviousStateName);
    }

    simulated function Activate()
    {
        global.Activate();
        UpdateOutOfAmmoEffects(0);
    }
    stop;    
}

simulated state Active
{
    simulated event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
    {
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            PlayIdleAnim();
        }
    }

    simulated function PlayIdleAnim()
    {
        local int IdleIndex;

        if(Instigator.IsLocallyControlled())
        {
            if(bUsingSights && IdleSightedAnims.Length > 0)
            {
                IdleIndex = Rand(IdleSightedAnims.Length);
                PlayAnimation(IdleSightedAnims[IdleIndex], 0, true, 0.1);                
            }
            else
            {
                if(IdleAnims.Length > 0)
                {
                    IdleIndex = Rand(IdleAnims.Length);
                    PlayAnimation(IdleAnims[IdleIndex], 0, true, 0.2);
                }
            }
            StartIdleFidgetTimer();
            ToggleAdditiveBobAnim(!bUsingSights);
        }
    }

    simulated function GotoWeaponSprinting()
    {
        GotoState('WeaponSprinting');
    }

    simulated event BeginState(name PreviousStateName)
    {
        if(Role == ROLE_Authority)
        {
            CacheKFPlayerController();
        }
        bIronSightOnBringUp = false;
        if((RecoilRate > float(0)) && RecoilBlendOutRatio > float(0))
        {
            RecoilYawBlendOutRate = int((float(maxRecoilYaw) / RecoilRate) * RecoilBlendOutRatio);
            RecoilPitchBlendOutRate = int((float(maxRecoilPitch) / RecoilRate) * RecoilBlendOutRatio);
        }
        if(!WeaponIsAnimating() || !IsTimerActive('OnAnimEnd'))
        {
            OnAnimEnd(none, 0, 0);
        }
        bEnableTiltSkelControl = true;
        if((InvManager != none) && InvManager.LastAttemptedSwitchToWeapon != none)
        {
            if(InvManager.LastAttemptedSwitchToWeapon != self)
            {
                InvManager.LastAttemptedSwitchToWeapon.ClientWeaponSet(true);
            }
            InvManager.LastAttemptedSwitchToWeapon = none;
        }
        CheckPendingIronsights();
        super.BeginState(PreviousStateName);
    }

    simulated event EndState(name NextStateName)
    {
        ClearTimer('IdleFidgetTimer');
        ToggleAdditiveBobAnim(false);
        super(Object).EndState(NextStateName);
    }

    simulated function StartIdleFidgetTimer()
    {
        if(IdleFidgetAnims.Length > 0)
        {
            SetTimer(RandRange(1, 10), false, 'IdleFidgetTimer');
        }
    }

    simulated function IdleFidgetTimer()
    {
        local bool bIsPlaying;

        if(CanPlayIdleFidget())
        {
            bIsPlaying = PlayIdleFidgetAnim();
        }
        if(!bIsPlaying)
        {
            SetTimer(20, false, 'IdleFidgetTimer');
        }
    }

    simulated function bool CanPlayIdleFidget(optional bool bOnReload)
    {
        local Pawn P;

        if(Instigator == none)
        {
            return false;
        }
        if(bCanBeReloaded && !HasAmmo(0))
        {
            return false;
        }
        if(bUsingSights)
        {
            return false;
        }
        if(!bOnReload)
        {
            if((WorldInfo.TimeSeconds - LastIdleFidgetAnimTime) < 20)
            {
                return false;
            }
            if((WorldInfo.TimeSeconds - Instigator.LastPainTime) < 10)
            {
                return false;
            }
            if((WorldInfo.TimeSeconds - KFPawn(Instigator).LastWeaponFireTime) < 10)
            {
                return false;
            }
            foreach WorldInfo.AllPawns(Class'Pawn', P)
            {
                if(((WorldInfo.TimeSeconds - P.LastRenderTime) < 1) && P.GetTeamNum() != Instigator.GetTeamNum())
                {                    
                    return false;
                }                
            }                        
        }
        else
        {
            if((WorldInfo.TimeSeconds - LastIdleFidgetAnimTime) < 1)
            {
                return false;
            }
            if(!Instigator.IsLocallyControlled())
            {
                return false;
            }
        }
        return true;
    }

    simulated function bool PlayIdleFidgetAnim()
    {
        local name AnimName;

        AnimName = IdleFidgetAnims[Rand(IdleFidgetAnims.Length)];
        if(MySkelMesh.FindAnimSequence(AnimName) != none)
        {
            ToggleAdditiveBobAnim(false);
            PlayAnimation(AnimName);
            LastIdleFidgetAnimTime = WorldInfo.TimeSeconds;
            return true;
        }
        return false;
    }

    simulated function bool CanReload(optional byte FireModeNum)
    {
        if(global.CanReload(FireModeNum))
        {
            return true;
        }
        if(PendingFire(2) && CanPlayIdleFidget(true))
        {
            PlayIdleFidgetAnim();
        }
        return false;
    }

    simulated function ANIMNOTIFY_EnableAdditiveBob()
    {
        if(!bUsingSights)
        {
            ToggleAdditiveBobAnim(true, 0.3);            
        }
    }

    reliable server function ServerSyncReload(int ClientSpareAmmoCount)
    {
        local int I;

        global.ServerSyncReload(ClientSpareAmmoCount);
        I = 0;
        J0x1E:

        if(I < GetPendingFireLength())
        {
            if(PendingFire(I))
            {
                BeginFire(byte(I));
            }
            ++ I;
            goto J0x1E;
        }
    }

    simulated function WeaponEmpty()
    {
        if(PendingFire(4) && HasAmmo(4))
        {
            BeginFire(4);            
        }
        else
        {
            if(PendingFire(3) && HasAmmo(3))
            {
                BeginFire(3);
            }
        }
    }
    stop;    
}

simulated state WeaponEquipping
{
    simulated function byte GetWeaponStateId()
    {
        return 26;
    }

    simulated function bool TryPutDown()
    {
        bWeaponPutDown = true;
        if(!IsTimerActive('WeaponEquipped'))
        {
            PutDownWeapon();            
        }
        else
        {
            EquipAbortTime = (PutDownTime * GetTimerCount('WeaponEquipped')) / GetTimerRate('WeaponEquipped');
            GotoState('WeaponAbortEquip');
        }
        return true;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;
        local float PerkZedTimeResist;

        super.BeginState(PreviousStateName);
        if(bIronSightOnBringUp && bHasIronSights)
        {
            bIronSightOnBringUp = false;
            SetIronSights(true);            
        }
        else
        {
            CheckPendingIronsights();
        }
        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            PerkZedTimeResist = InstigatorPerk.GetZedTimeModifier(self);
        }
        SetZedTimeResist(0.375 + PerkZedTimeResist);
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        ClearTimer('WeaponEquipped');
        ClearZedTimeResist();
        NotifyEndState();
    }

    simulated function float GetThirdPersonAnimRate()
    {
        local KFPerk CurrentPerk;
        local float ScaledRate;

        ScaledRate = 1;
        CurrentPerk = GetPerk();
        if(CurrentPerk != none)
        {
            CurrentPerk.ModifyWeaponSwitchTime(ScaledRate);
        }
        return 1 / ScaledRate;
    }
    stop;    
}

simulated state WeaponPuttingDown
{
    ignores Activate;

    simulated function byte GetWeaponStateId()
    {
        return 27;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;
        local float PerkZedTimeResist;

        TimeWeaponPutDown();
        bWeaponPutDown = false;
        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            PerkZedTimeResist = InstigatorPerk.GetZedTimeModifier(self);
        }
        SetZedTimeResist(0.375 + PerkZedTimeResist);
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        ClearZedTimeResist();
        NotifyEndState();
    }

    simulated function float GetThirdPersonAnimRate()
    {
        local KFPerk CurrentPerk;
        local float ScaledRate;

        ScaledRate = 1;
        CurrentPerk = GetPerk();
        if(CurrentPerk != none)
        {
            CurrentPerk.ModifyWeaponSwitchTime(ScaledRate);
        }
        return 1 / ScaledRate;
    }
    stop;    
}

simulated state WeaponDownSimple
{
    ignores CanTransitionToIronSights, CanReload, SetIronSights, OnAnimEnd, CanSwitchWeapons;

    simulated function bool DenyClientWeaponSet()
    {
        return true;
    }

    simulated function bool CanThrow()
    {
        return (Instigator == none) || Instigator.Health <= 0;
    }

    exec function SimplePutDown()
    {
        SetSimplePutDown(false);
    }

    simulated function BeginState(name PreviousStateName)
    {
        super(Object).BeginState(PreviousStateName);
        bDoingQuickDownZoom = true;
        if(Instigator.IsLocallyControlled())
        {
            ZoomDown(true, QuickWeaponDownTime);
        }
        if(Instigator.IsFirstPerson())
        {
            PlayAnimation(IdleAnims[0], 0, true, 0.2);
        }
        StopFire(CurrentFireMode);
    }

    simulated function ZoomDown(bool bAnimateTransition, float ZoomTimeToGo)
    {
        if(bAnimateTransition)
        {
            ZoomInTime = ZoomTimeToGo;
            if(bZoomingOut)
            {
                bZoomingOut = false;
                bZoomOutInterrupted = true;
                ZoomTime = ZoomInTime - ZoomTime;
                ZoomPartialTime = ZoomTime;
                ZoomStartOffset = PlayerViewOffset;
                ZoomRotStartOffset = ZoomRotInterp;                
            }
            else
            {
                ZoomTime = ZoomInTime;
                ZoomStartOffset = PlayerViewOffset;
            }
            ZoomTargetOffset = default.PlayerViewOffset;
            if(MySkelMesh != none)
            {
                ZoomWeaponFOVStart = MySkelMesh.FOV;                
            }
            else
            {
                ZoomWeaponFOVStart = MeshFOV;
            }
            if((WorldInfo.NetMode != NM_DedicatedServer) && Instigator != none)
            {
                EnableIronSightsDoF(false);
                EnablePlayerZoom(false);
            }
            bZoomingIn = true;
        }
    }

    simulated function EndState(name NextStateName)
    {
        super(Object).EndState(NextStateName);
        ClearTimer('EndWeaponDownSimpleTimer');
        bDoingQuickDownZoom = false;
    }

    simulated function EndWeaponDownSimpleTimer()
    {
        GotoState('Active');
    }

    simulated function SetSimplePutDown(bool bPutDownWeapon)
    {
        if(!bPutDownWeapon)
        {
            if((WorldInfo.NetMode == NM_DedicatedServer) || (WorldInfo.NetMode == NM_ListenServer) && !Instigator.IsLocallyControlled())
            {
                EndWeaponDownSimpleTimer();                
            }
            else
            {
                SetTimer(QuickWeaponDownFinishTime, false, 'EndWeaponDownSimpleTimer');
                if(Instigator.IsLocallyControlled())
                {
                    ZoomOut(true, QuickWeaponDownFinishTime);
                }
            }            
        }
        else
        {
            ClearTimer('EndWeaponDownSimpleTimer');
            if(Instigator.IsLocallyControlled())
            {
                ZoomDown(true, QuickWeaponDownTime);
            }
            StopFire(CurrentFireMode);
        }
    }
    stop;    
}

simulated state WeaponAbortEquip extends WeaponPuttingDown
{
    simulated function TimeWeaponPutDown()
    {
        local AnimNodeSequence AnimNode;
        local float Rate;

        SetTimer(FMax(EquipAbortTime, 0.01),, 'WeaponIsDown');
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            AnimNode = GetWeaponAnimNodeSeq();
            if((AnimNode != none) && AnimNode.AnimSeq != none)
            {
                AnimNode.SetAnim(PutDownAnim);
                Rate = AnimNode.AnimSeq.SequenceLength / PutDownTime;
                AnimNode.PlayAnim(false, Rate, AnimNode.AnimSeq.SequenceLength - (EquipAbortTime * Rate));
            }
        }
    }
    stop;    
}

simulated state WeaponFiring
{
    ignores AllowSprinting;

    simulated function BeginState(name PrevStateName)
    {
        local KFPerk InstigatorPerk;

        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        if((bLoopingFireAnim.Length > 0) || bLoopingFireSnd.Length > 0)
        {
            StartLoopingFireEffects(CurrentFireMode);
        }
        super.BeginState(PrevStateName);
    }

    simulated event Tick(float DeltaTime)
    {
        global.Tick(DeltaTime);
        if(bPlayingLoopingFireSnd && ShouldForceSingleFireSound())
        {
            StopLoopingFireSound(CurrentFireMode);
        }
    }

    simulated function RefireCheckTimer()
    {
        local KFPerk InstigatorPerk;

        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        super.RefireCheckTimer();
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        ClearZedTimeResist();
        if(WorldInfo.NetMode == NM_Client)
        {
            Instigator.WeaponStoppedFiring(self, false);
        }
        if(bPlayingLoopingFireAnim || bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
    }

    simulated event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
    {
        local name WeaponFireAnimName;

        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(bPlayingLoopingFireAnim)
            {
                WeaponFireAnimName = GetLoopingFireAnim(CurrentFireMode);
                if(WeaponFireAnimName != 'None')
                {
                    PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName), true, 0);
                }
            }
        }
    }

    simulated function bool DenyClientWeaponSet()
    {
        return true;
    }

    simulated function float GetThirdPersonAnimRate()
    {
        local KFPerk CurrentPerk;
        local float ScaledRate;

        ScaledRate = 1;
        CurrentPerk = GetPerk();
        if(CurrentPerk != none)
        {
            CurrentPerk.ModifyRateOfFire(ScaledRate, self);
        }
        return 1 / ScaledRate;
    }
    stop;    
}

simulated state WeaponSingleFiring extends WeaponFiring
{
    simulated function FireAmmunition()
    {
        super(KFWeapon).FireAmmunition();
        ClearPendingFire(CurrentFireMode);
    }
    stop;    
}

simulated state WeaponBurstFiring extends WeaponFiring
{
    simulated function BeginState(name PrevStateName)
    {
        BurstAmount = byte(GetBurstAmount());
        super.BeginState(PrevStateName);
    }

    simulated function int GetBurstAmount()
    {
        return Min(default.BurstAmount, AmmoCount[GetAmmoType(CurrentFireMode)]);
    }

    simulated function bool ShouldRefire()
    {
        if(0 >= BurstAmount)
        {
            return false;            
        }
        else
        {
            if(!HasAmmo(CurrentFireMode))
            {
                return false;                
            }
            else
            {
                return true;
            }
        }
    }

    simulated function FireAmmunition()
    {
        super(KFWeapon).FireAmmunition();
        -- BurstAmount;
    }

    simulated event EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        EndFire(CurrentFireMode);
    }
    stop;    
}

simulated state GrenadeFiring extends WeaponSingleFiring
{
    simulated function byte GetWeaponStateId()
    {
        return 28;
    }

    simulated event BeginState(name PreviousStateName)
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PreviousStateName:") @ string(PreviousStateName), 'Inventory');
        if(bUsingSights)
        {
            ZoomOut(false, default.ZoomOutTime);
        }
        SetWeakZedGrabCooldownOnPawn(GrenadeTossWeakZedGrabCooldown);
        PlayGrenadeThrow();
        TimeWeaponFiring(CurrentFireMode);
        ClearPendingFire(CurrentFireMode);
        if((Role == ROLE_Authority) && KFInventoryManager(InvManager) != none)
        {
            KFInventoryManager(InvManager).ConsumeGrenades();            
        }
        else
        {
            if((Role < ROLE_Authority) && Instigator.IsLocallyControlled())
            {
                ServerGotoGrenadeFiring();
            }
        }
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        local byte FireModeSwap;

        super(WeaponFiring).EndState(NextStateName);
        NotifyEndState();
        FireModeSwap = CurrentFireMode;
        CurrentFireMode = 4;
        ProjectileFire();
        CurrentFireMode = FireModeSwap;
    }

    simulated event Vector GetMuzzleLoc()
    {
        local Rotator ViewRotation;

        if(Instigator != none)
        {
            ViewRotation = Instigator.GetViewRotation();
            if(KFPlayerController(Instigator.Controller) != none)
            {
                ViewRotation += KFPlayerController(Instigator.Controller).WeaponBufferRotation;
            }
            return Instigator.GetPawnViewLocation() + (GrenadeFireOffset >> ViewRotation);
        }
        return Location;
    }

    simulated function bool ShouldRefire()
    {
        return false;
    }
    stop;    
}

simulated state Reloading
{
    ignores ForceReload, ShouldAutoReload, AllowSprinting;

    simulated function byte GetWeaponStateId()
    {
        local KFPerk Perk;
        local bool bTacticalReload;

        Perk = GetPerk();
        bTacticalReload = (Perk != none) && Perk.GetUsingTactialReload(self);
        if(!bReloadFromMagazine)
        {
            if(bTacticalReload)
            {
                return byte(((AmmoCount[0] > 0) ? 7 : 8));
            }
            return byte(((AmmoCount[0] > 0) ? 5 : 6));            
        }
        else
        {
            if(bTacticalReload)
            {
                return byte(((AmmoCount[0] > 0) ? 3 : 4));
            }
            return byte(((AmmoCount[0] > 0) ? 1 : 2));
        }
    }

    simulated event ReplicatedEvent(name VarName)
    {
        local int ClientsideAmmoReloaded;

        if(VarName == 'SpareAmmoCount')
        {
            ClientsideAmmoReloaded = InitialReloadAmount - ReloadAmountLeft;
            if(((Role < ROLE_Authority) && ClientsideAmmoReloaded > 0) && bAllowClientAmmoTracking)
            {
                SpareAmmoCount[0] -= Max(ClientsideAmmoReloaded, 0);
            }            
        }
        else
        {
            global.ReplicatedEvent(VarName);
        }
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;

        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        if(bUsingSights)
        {
            ZoomOut(false, default.ZoomOutTime);
        }
        bEnableTiltSkelControl = false;
        bPendingAutoSwitchOnDryFire = false;
        ReloadStatus = 0;
        TimeWeaponReloading();
        NotifyBeginState();
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayReloadDialog(KFPawn(Instigator));
        }
    }

    simulated function EndState(name NextStateName)
    {
        local int ActualReloadAmount;

        ClearZedTimeResist();
        ClearTimer('ReloadStatusTimer');
        ClearTimer('ReloadAmmoTimer');
        ClearPendingFire(2);
        if(bAllowClientAmmoTracking && Role < ROLE_Authority)
        {
            ActualReloadAmount = InitialReloadAmount - ReloadAmountLeft;
            ServerSyncReload(InitialReloadSpareAmmo - ActualReloadAmount);
        }
        CheckBoltLockPostReload();
        NotifyEndState();
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayAmmoDialog(KFPawn(Instigator), float(SpareAmmoCount[0]) / float(GetMaxAmmoAmount(0)));
        }
    }

    simulated function BeginFire(byte FireModeNum)
    {
        global.BeginFire(FireModeNum);
        if(FireModeNum != 2)
        {
            if(!bReloadFromMagazine || CanOverrideMagReload(FireModeNum))
            {
                if(PendingFire(FireModeNum) && HasAmmo(FireModeNum))
                {
                    AbortReload();
                }
            }
        }
    }

    simulated function ZoomIn(bool bAnimateTransition, float ZoomTimeToGo)
    {
        if(!bReloadFromMagazine)
        {
            global.ZoomIn(bAnimateTransition, ZoomTimeToGo);
            AbortReload();            
        }
        else
        {
            if((Role == ROLE_Authority) && !Instigator.IsLocallyControlled())
            {
                global.ZoomIn(bAnimateTransition, ZoomTimeToGo);
            }
        }
    }

    simulated function bool TryPutDown()
    {
        PutDownWeapon();
        return true;
    }

    simulated function ReloadStatusTimer()
    {
        if((ReloadStatus == 2) && IsTimerActive('ReloadAmmoTimer'))
        {
            PerformReload();
            ClearTimer('ReloadAmmoTimer');
        }
        TimeWeaponReloading();
    }

    simulated function ReloadAmmoTimer()
    {
        PerformReload();
    }

    simulated function ReloadComplete()
    {
        GotoState('Active');
    }

    simulated function AbortReload()
    {
        LastReloadAbortTime = WorldInfo.TimeSeconds;
        GotoState('Active');
    }

    simulated function float GetThirdPersonAnimRate()
    {
        return 1 / (GetReloadRateScale());
    }
    stop;    
}

simulated state WeaponSprinting
{
    ignores ForceReload;

    simulated function BeginState(name PreviousStateName)
    {
        PlaySprintStart();
    }

    simulated function EndState(name NextStateName)
    {
        if(!bUsingSights)
        {
            PlaySprintEnd();
        }
    }

    simulated function SprintLoopTimer()
    {
        PlaySprintLoop();
    }

    simulated function SprintRetryTimer()
    {
        PlaySprintStart();
    }

    simulated function SetWeaponSprint(bool bNewSprintStatus)
    {
        if(!bNewSprintStatus)
        {
            GotoState('Active');
        }
    }

    simulated function SetIronSights(bool bNewIronSights)
    {
        global.SetIronSights(bNewIronSights);
        if(bUsingSights)
        {
            StopPawnSprint(true);
        }
    }

    simulated function BeginFire(byte FireModeNum)
    {
        if(!bDeleteMe && Instigator != none)
        {
            global.BeginFire(FireModeNum);
            if(PendingFire(FireModeNum) && HasAmmo(FireModeNum))
            {
                StopPawnSprint(false);
            }
        }
    }
    stop;    
}

simulated state MeleeAttackBasic
{
    ignores AllowSprinting, AllowIronSights;

    simulated function bool IsMeleeing()
    {
        return true;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;

        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        if(bUsingSights)
        {
            ZoomOut(false, default.ZoomOutTime);
        }
        TimeWeaponFiring(CurrentFireMode);
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        ClearZedTimeResist();
        ClearTimer('RefireCheckTimer');
        NotifyEndState();
    }

    simulated function BeginFire(byte FireModeNum)
    {
        if(!bDeleteMe && Instigator != none)
        {
            global.BeginFire(FireModeNum);
            if(PendingFire(FireModeNum) && HasAmmo(FireModeNum))
            {
                SendToFiringState(FireModeNum);
            }
        }
    }

    simulated function TimeWeaponFiring(byte FireModeNum)
    {
        MeleeAttackHelper.BeginMeleeAttack();
        if(PendingFire(CurrentFireMode) && !ShouldContinueMelee())
        {
            ClearPendingFire(CurrentFireMode);
        }
    }

    simulated function byte GetWeaponStateId()
    {
        return 13;
    }

    simulated function float GetThirdPersonAnimRate()
    {
        local KFPerk CurrentPerk;
        local float ScaledRate;

        ScaledRate = 1;
        CurrentPerk = GetPerk();
        if(CurrentPerk != none)
        {
            CurrentPerk.ModifyMeleeAttackSpeed(ScaledRate, self);
        }
        return 1 / ScaledRate;
    }
    stop;    
}

simulated state WeaponSingleFireAndReload extends WeaponSingleFiring
{
    ignores ServerSyncReload;

    simulated function FireAmmunition()
    {
        local float ReloadDelay;

        super.FireAmmunition();
        if(Instigator.IsLocallyControlled())
        {
            if(HasSpareAmmo())
            {
                ReloadDelay = GetForceReloadDelay();
                if(ReloadDelay > 0)
                {
                    SetTimer(ReloadDelay + (GetFireInterval(CurrentFireMode)), false, 'ForceReload');                    
                }
                else
                {
                    StartFire(2);
                }
            }
            if(Instigator.Role < ROLE_Authority)
            {
                ServerSyncWeaponFiring(CurrentFireMode);
            }
        }
    }
    stop;    
}

defaultproperties
{
    bTargetFrictionEnabled=true
    bTargetAdhesionEnabled=true
    DOF_bOverrideEnvironmentDOF=true
    bCanRefillSecondaryAmmo=true
    bAllowClientAmmoTracking=true
    bUseAnimLenEquipTime=true
    bUseAdditiveMoveAnim=true
    FireModeIconPaths(0)=Texture2D'ui_firemodes_tex.UI_FireModeSelect_BulletSingle'
    FireModeIconPaths(1)=none
    SingleFireSoundIndex=255
    MinFiringPutDownPct=0.8
    PenetrationPower(0)=0
    PenetrationPower(1)=0
    PenetrationDamageReductionCurve(0)=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    PenetrationDamageReductionCurve(1)=(InVal=1,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    GrenadeTossWeakZedGrabCooldown=1
    TargetFrictionDistanceMax=4000
    TargetAdhesionDistanceMax=2000
    TargetAdhesionOffsetScaleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    TargetAdhesionDistanceScaleCurve=(Points=/* Array type was not detected. */,InVal=0.1,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    TargetFrictionOffsetScaleCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    TargetFrictionDistanceScaleCurve=(Points=/* Array type was not detected. */,InVal=0.5,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_CurveAuto)
    MeshFOV=86
    MeshIronSightFOV=75
    PlayerIronSightFOV=75
    PlayerSprintFOV=95
    ZoomInTime=0.15
    ZoomOutTime=0.15
    ZoomInRotation=(Pitch=-910,Yaw=0,Roll=2910)
    QuickWeaponDownRotation=(Pitch=-8192,Yaw=0,Roll=16384)
    QuickWeaponDownTime=0.4
    QuickWeaponDownFinishTime=0.2
    FastZoomOutTime=0.1
    DOF_SharpRadius=500
    DOF_FocalRadius=1000
    DOF_MaxNearBlurSize=2
    DOF_ExpFalloff=1
    DOF_MaxFocalDistance=2000
    DOF_BlendInSpeed=1
    DOF_BlendOutSpeed=1
    DOF_FG_FocalRadius=50
    DOF_FG_MaxNearBlurSize=3
    DOF_FG_ExpFalloff=1
    GrenadeFireOffset=(X=25,Y=-15,Z=0)
    MaxAIWarningDistSQ=6250000
    MaxAIWarningDistFromPointSQ=5625
    WeaponSelectTexture=Texture2D'ui_weaponselect_tex.UI_WeaponSelect_AR15'
    SecondaryAmmoTexture=Texture2D'UI_SecondaryAmmo_TEX.GasTank'
    AmmoCost(0)=1
    AmmoCost(1)=1
    AmmoPickupScale[0]=1
    AmmoPickupScale[1]=1
    ShakeScaleSighted=0.4
    ShakeScaleStandard=1
    WeaponFireWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Default_Recoil'
    FireTweenTime=0.05
    FireAnim=Shoot
    FireLoopAnim=ShootLoop
    FireLastAnim=Shoot_Last
    PutDownAnim=PutAway
    EquipAnim=Equip
    IdleAnims(0)=Idle
    IdleFidgetAnims(0)=Guncheck_v1
    IdleFidgetAnims(1)=Guncheck_v2
    IdleFidgetAnims(2)=Guncheck_v3
    FireSightedAnims(0)=Shoot_Iron
    FireLoopSightedAnim=ShootLoop_Iron
    FireLastSightedAnim=Shoot_Iron_Last
    IdleSightedAnims(0)=Idle_Iron
    FireLoopStartAnim=ShootLoop_Start
    FireLoopStartSightedAnim=ShootLoop_Iron_Start
    FireLoopEndAnim=ShootLoop_End
    FireLoopEndSightedAnim=ShootLoop_Iron_End
    MeleeAttackAnims(0)=Bash
    BonesToLockOnEmpty(0)=RW_Bolt
    WeaponFireSnd(0)=(DefaultCue=none,FirstPersonCue=none)
    BobDamping=0.85
    JumpDamping=1
    PlayerViewOffset=(X=1,Y=9,Z=-3)
    NumBloodMapMaterials=1
    LagTensionHorizontal=0.8
    LagVerticalTension=0.8
    LagResistanceHorizontal=0.2
    LagResistanceVertical=0.2
    LagLimit=5
    LagYawCoefficient=5E-05
    LagStrengthIronSights=3
    LagStrengthCrouch=1.5
    LagStrengthWalk=0.7
    LagStrengthJog=0.6
    LagStrengthSprint=0.5
    StrafeLagLimit=4
    StrafeLagRate=0.025
    StrafeLagReturnRate=10
    begin object name=MeleeHelper class=KFMeleeHelperWeapon
        MaxHitRange=175
    object end
    // Reference: KFMeleeHelperWeapon'Default__KFWeapon.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    LaserSightTemplate=KFLaserSightAttachment'FX_LaserSight_ARCH.Default_LaserSight_1P'
    MovingSpreadMod=1
    IronSightsSpreadMod=0.5
    CrouchSpreadMod=0.75
    RecoilRate=0.09
    RecoilBlendOutRatio=1.25
    RecoilViewRotationScale=0.4
    RecoilCompensationScale=1.5
    FullRecoilPitchPct=0.75
    FullRecoilYawPct=0.75
    RecoilMaxYawLimit=2000
    RecoilMinYawLimit=63535
    RecoilMaxPitchLimit=1500
    RecoilMinPitchLimit=64035
    RecoilISMaxYawLimit=500
    RecoilISMinYawLimit=65035
    RecoilISMaxPitchLimit=350
    RecoilISMinPitchLimit=65185
    SuppressRecoilSpeed=0.08
    SuppressRecoilViewRotationScale=0.5
    HippedRecoilModifier=1.75
    JoggingRecoilModifier=1.5
    WalkingRecoilModifier=1.25
    FallingRecoilModifier=1
    StanceCrouchedRecoilModifier=0.75
    LastRecoilModifier=1
    IronSightMeshFOVCompensationScale=1
    WeaponUpgrades(0)=(IncrementWeight=0,IncrementDamage=1,IncrementHeal=1,IncrementHealFullRecharge=1)
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitMomentum=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    EquipTime=0.45
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        AnimTreeTemplate=AnimTree'CHR_1P_Arms_ARCH.WEP_1stP_Animtree_Master'
        bOverrideAttachmentOwnerVisibility=true
        bAllowBooleanPreshadows=false
        ReplacementPrimitive=none
        DepthPriorityGroup=ESceneDepthPriorityGroup.SDPG_Foreground
        bOnlyOwnerSee=true
        LightingChannels=(bInitialized=true,Outdoor=true)
        bAllowPerObjectShadows=true
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeapon.FirstPersonMesh'
    Mesh=FirstPersonMesh
    bDropOnDeath=true
    DroppedPickupClass=Class'KFDroppedPickup'
    begin object name=StaticPickupComponent class=StaticMeshComponent
        StaticMesh=StaticMesh'EngineMeshes.Cube'
        ReplacementPrimitive=none
        CastShadow=false
    object end
    // Reference: StaticMeshComponent'Default__KFWeapon.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        StaticMesh=StaticMesh'EngineMeshes.Cube'
        ReplacementPrimitive=none
        CastShadow=false
    object end
    // Reference: StaticMeshComponent'Default__KFWeapon.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
    bIgnoreBaseRotation=true
}