/*******************************************************************************
 * KFPawnAnimInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawnAnimInfo extends Object
    editinlinenew
    hidecategories(Object);

enum EAttackRating
{
    AR_Weak,
    AR_Medium,
    AR_Strong,
    AR_MAX
};

enum EHitReactionAnimType
{
    HIT_Light,
    HIT_Medium,
    HIT_Heavy,
    HIT_MAX
};

struct AttackAnimInfo
{
    /** Optional attack name for quick reference */
    var() const name Tag;
    /** Animation names/variants */
    var() const array<name> Anims;
    /** If set, enable root motion for this attack */
    var() const bool bUseRootMotion;
    /** If set, play on the upper body (note: UpperBody and RootMotion are exclusive) */
    var() const bool bPlayUpperBodyOnly;
    /** If set, can be canceled by other actions (e.g. stumble).  Use with caution if RootMotion is enabled! */
    var() const bool bIsInterruptible;
    /** If Interruptible, is this attack affected by parry stumble */
    var() const bool bCannotBeParried<EditCondition=bIsInterruptible>;
    /** If set, only perform this attack while sprinting */
    var() const bool bOnlyWhileSprinting;
    /** If set, only perform this attack while not sprinting */
    var() const bool bOnlyWhileNotSprinting;
    /** If set, only perform this attack when enemy is moving */
    var() const bool bOnlyWhileEnemyMoving;
    /** If set, only perform this attack when enemy is stationary */
    var() const bool bOnlyWhileEnemyNotMoving;
    /** If set, only perform this attack when surrounded */
    var() const bool bOnlyWhileSurrounded;
    /** If set, this pawn has cloaking */
    var() const bool bHasCloaking;
    /** If set, only performs this attack when cloaked */
    var() const bool bOnlyWhileCloaked<EditCondition=bHasCloaking>;
    /** If set, only perform this attack when uncloaked */
    var() const bool bOnlyWhileDeCloaked<EditCondition=bHasCloaking>;
    /** The radius around the AI pawn to determine if surrounded */
    var() const float SurroundedRadius<EditCondition=bOnlyWhileSurrounded|ClampMin=1>;
    /** The minimum number of players that need to surround AI pawn for this attack to be considered */
    var() const int MinSurroundedBy<EditCondition=bOnlyWhileSurrounded|ClampMin=2>;
    /** If set, attack only usable when AI using custom mode/ability ("e.g, FleshPound rage, siren cloak, etc.") */
    var() const bool bOnlyWhileInSpecializedMode;
    /** If set, attack only usable when AI NOT using custom mode/ability ("e.g, FleshPound rage, siren cloak, etc.") */
    var() const bool bOnlyWhileNotInSpecializedMode;
    /** If set, use this EXCLUSIVELY when headless */
    var() const bool bOnlyWhileHeadless;
    /** If set, attack requires a clear path to enemy (no leg obstructions) to perform this anim */
    var() const bool bOnlyWhilePathClear;
    /** If set along with BattlePhaseMinimum, determines the battle phases this attack is allowed in (Bosses only) */
    var() const bool bIsBattlePhaseAttack;
    /** The minimum battle phase a boss must be at for this attack to be allowed */
    var() const int BattlePhaseMinimum<EditCondition=bIsBattlePhaseAttack|ClampMin=1>;
    /** The maximum battle phase a boss can be at to use this attack */
    var() const int BattlePhaseMaximum<EditCondition=bIsBattlePhaseAttack>;
    /** Chance this attack will be considered */
    var() const float Chance<ClampMin=0.0>;
    /** If > 0, will not target distance enemies */
    var() const float MaxDistance<ClampMin=0.0>;
    /** If > 0 and bUseRootMotion, will not target nearby enemies */
    var() const float MinDistance<ClampMin=0.0>;
    /** If > 0, no characters of this type can perform this attack */
    var() const float GlobalCooldown<ClampMin=0.0>;
    var const float InstancedCooldown<ClampMin=0.0>;
    /** Attack rating that can be filtered by difficulty */
    var() const KFPawnAnimInfo.EAttackRating DifficultyRating;
    /** example: If DiffultyRating is weak and GameDifficulty allows medium attacks then ignore */
    var() const bool bSkipIfDifficultyIsExceeded;
    var transient float LastTimePlayed;

    structdefaultproperties
    {
        Tag=None
        Anims=none
        bUseRootMotion=false
        bPlayUpperBodyOnly=false
        bIsInterruptible=false
        bCannotBeParried=false
        bOnlyWhileSprinting=false
        bOnlyWhileNotSprinting=false
        bOnlyWhileEnemyMoving=false
        bOnlyWhileEnemyNotMoving=false
        bOnlyWhileSurrounded=false
        bHasCloaking=false
        bOnlyWhileCloaked=false
        bOnlyWhileDeCloaked=false
        SurroundedRadius=200
        MinSurroundedBy=3
        bOnlyWhileInSpecializedMode=false
        bOnlyWhileNotInSpecializedMode=false
        bOnlyWhileHeadless=false
        bOnlyWhilePathClear=false
        bIsBattlePhaseAttack=false
        BattlePhaseMinimum=1
        BattlePhaseMaximum=4
        Chance=1
        MaxDistance=0
        MinDistance=0
        GlobalCooldown=0
        InstancedCooldown=0
        DifficultyRating=EAttackRating.AR_Weak
        bSkipIfDifficultyIsExceeded=false
        LastTimePlayed=0
    }
};

struct sTheatricAnimInfo
{
    var() const name AnimationName;
    var() const CameraAnim CameraAnimation;
    var() const Vector CameraAnimOffset;

    structdefaultproperties
    {
        AnimationName=None
        CameraAnimation=none
        CameraAnimOffset=(X=0,Y=0,Z=0)
    }
};

struct native AnimVariants
{
    var() array<name> Anims;

    structdefaultproperties
    {
        Anims=none
    }
};

struct native DeathAnimInfo
{
    /** Bone name to use these anims with */
    var() const name BoneName;
    /** Animation names/variants */
    var() const array<name> Anims_F;
    /** Animation names/variants */
    var() const array<name> Anims_B;
    /** Animation names/variants */
    var() const array<name> Anims_L;
    /** Animation names/variants */
    var() const array<name> Anims_R;
    /** Animation names/variants */
    var() const array<name> DismemberedAnims;
    /** Chance no death animation will be selected */
    var() const float RagdollChance<ClampMin=0.0>;
    /** (Body Part Death) Chance the generic death will be selected */
    var() const float IgnoreChance<ClampMin=0.0>;

    structdefaultproperties
    {
        BoneName=None
        Anims_F=none
        Anims_B=none
        Anims_L=none
        Anims_R=none
        DismemberedAnims=none
        RagdollChance=0
        IgnoreChance=0.1
    }
};

var(Attacks) array<AttackAnimInfo> Attacks<DisplayName=MeleeAttacks>;
/** list of attack anim variants used on doors */
var(Attacks) array<name> DoorAttacks;
/** If checked, allow game difficulty to modify attack selection */
var(Attacks) bool bEnableDifficultyScaling;
var(Debug) bool bDebugLog;
var(HitReaction) bool bCanPlayAnimHitReactions;
/** If Pawn can or cannot play physics hit reactions. */
var(HitReaction) editconst bool bCanPlayPhysicsHitReactions;
/** If set, this actor can play death animations */
var(Death) const bool bCanPlayDeathAnimations;
var transient float WeakAttackChance;
var transient float MediumAttackChance;
var transient float HardAttackChance;
/** array entry for each HitZoneGruop */
var(HitReaction) const array<AnimVariants> LightHitAnims;
var(HitReaction) const array<AnimVariants> MediumHitAnims<DisplayName=GunHitAnims>;
var(HitReaction) const array<AnimVariants> HeavyHitAnims<DisplayName=MeleeHitAnims>;
var(HitReaction) const array<name> DmgOverTimeHitAnims;
/**  
 *Anims for stumble special move
 *       0: Body_Forward,
 *       1: Body_Backward,
 *       2: Body_Left,
 *       3: Body_Right,
 *       4: Leg_L_Forward,
 *       5: Leg_L_Backward,
 *       6: Leg_L_Left,
 *       7: Leg_L_Right,
 *       8: Leg_R_Forward,
 *       9: Leg_R_Backward,
 *       10: Leg_R_Left,
 *       11: Leg_R_Right,
 *       12: Parry
 */
var(HitReaction) editfixedsize array<AnimVariants> StumbleAnims;
/** Default death animation list */
var(Death) const DeathAnimInfo DefaultDeathAnims;
/** Death animas used by weapons with high kickback (explosives) */
var(Death) const DeathAnimInfo ExplosiveDeathAnims;
/** Death anims used when shot in specific location */
var(Death) const array<DeathAnimInfo> BodyPartDeathAnims;
var transient byte LastDeathAnimIndex;
/** temp */
var(Death) const Vector2D DeathPhysMotorStrength;
/** List of randomly selected taunt anims */
var(Taunt) array<name> TauntAnims;
var(Taunt) array<name> TauntKillAnims;
var(Taunt) array<name> TauntEnragedAnims;
/** @name  Theatric Boss Animations */
var(BossTheatrics) array<sTheatricAnimInfo> TheatricBossEntranceAnimInfos;
var(BossTheatrics) array<sTheatricAnimInfo> TheatricBossVictoryAnimInfos;

function name InitMeleeSpecialMove(KFSM_MeleeAttack InSpecialMove, int Index, int Variant)
{
    local name AnimName;

    AnimName = Attacks[Index].Anims[Variant];
    if(AnimName == 'None')
    {
        LogInternal((string(self) @ string(GetFuncName())) @ "failed to find a valid attack");
    }
    if(InSpecialMove != none)
    {
        InSpecialMove.bUseRootMotion = Attacks[Index].bUseRootMotion;
        InSpecialMove.bCanBeInterrupted = Attacks[Index].bIsInterruptible;
        InSpecialMove.bCannotBeParried = Attacks[Index].bCannotBeParried;
    }
    return AnimName;
}

function name ChooseAttackByName(name AttackName, optional KFPawn_Monster Instigator, optional Actor Target, optional out byte outFlags)
{
    local int Idx, Variant;

    Idx = Attacks.Find('Tag', AttackName;
    if(Idx != -1)
    {
        if((Instigator != none) && !CanDoAttackAnim(Idx, Instigator, Target))
        {
            return 'None';
        }
        Variant = Rand(Attacks[Idx].Anims.Length);
        if(Attacks[Idx].GlobalCooldown > float(0))
        {
            Attacks[Idx].LastTimePlayed = Class'Engine'.static.GetCurrentWorldInfo().TimeSeconds;
        }
        outFlags = byte(Idx + (Variant << 4));
        return Attacks[Idx].Anims[Variant];
    }
    LogInternal((string(self) @ string(GetFuncName())) @ "failed to find a valid attack");
    return 'None';
}

function int ChooseNextStrike(KFPawn Instigator, optional Actor Target)
{
    local int I;
    local array<int> IndexList;

    I = 0;
    J0x0C:

    if(I < Attacks.Length)
    {
        if(CanDoAttackAnim(I, Instigator, Target))
        {
            IndexList.AddItem(I;
        }
        ++ I;
        goto J0x0C;
    }
    if(IndexList.Length > 0)
    {
        return IndexList[Rand(IndexList.Length)];
    }
    return 255;
}

function UpdateAttackCooldown(KFAIController KFAIC, byte DesiredStrikeIndex)
{
    if(Attacks[DesiredStrikeIndex].GlobalCooldown > float(0))
    {
        Attacks[DesiredStrikeIndex].LastTimePlayed = Class'Engine'.static.GetCurrentWorldInfo().TimeSeconds;
    }
    if(Attacks[DesiredStrikeIndex].InstancedCooldown > float(0))
    {
        KFAIC.AddCooldownTimer(Attacks[DesiredStrikeIndex].Tag, Attacks[DesiredStrikeIndex].InstancedCooldown);
    }
    if(((KFAIC != none) && KFGameInfo(KFAIC.WorldInfo.Game) != none) && KFGameInfo(KFAIC.WorldInfo.Game).GameConductor != none)
    {
        KFGameInfo(KFAIC.WorldInfo.Game).GameConductor.UpdateOverallAttackCoolDowns(KFAIC);
    }
}

function float GetAttackRange(KFAIController KFAIC)
{
    local int TagIdx;
    local float MaxAttackRange;

    TagIdx = 0;
    J0x0B:

    if(TagIdx < Attacks.Length)
    {
        if(Attacks[TagIdx].Tag == 'None')
        {            
        }
        else
        {
            if((MaxAttackRange == float(0)) || Attacks[TagIdx].MaxDistance > MaxAttackRange)
            {
                MaxAttackRange = Attacks[TagIdx].MaxDistance;
            }
        }
        ++ TagIdx;
        goto J0x0B;
    }
    return MaxAttackRange;
}

function float GetMedianStrikeRange(byte MeleeAttackIndex, float StrikeRangePercentage, float CollisionRadius)
{
    local float MinMeleeRange, MaxMeleeRange;

    MaxMeleeRange = Attacks[MeleeAttackIndex].MaxDistance;
    MinMeleeRange = Attacks[MeleeAttackIndex].MinDistance;
    if(MinMeleeRange < CollisionRadius)
    {
        MinMeleeRange = CollisionRadius;
    }
    return MinMeleeRange + ((MaxMeleeRange - MinMeleeRange) * StrikeRangePercentage);
}

function int GetAttackIndexByTag(name AttackTag)
{
    return Attacks.Find('Tag', AttackTag;
}

function name GetAttackAnimName(int AttackIndex, byte VariantIndex)
{
    return Attacks[AttackIndex].Anims[VariantIndex];
}

function byte GetStrikeFlags(int DesiredStrikeIndex)
{
    local int Variant;

    if(DesiredStrikeIndex > Attacks.Length)
    {
        return 255;
    }
    Variant = Rand(Attacks[DesiredStrikeIndex].Anims.Length);
    return byte(DesiredStrikeIndex + (Variant << 4));
}

function CheckForValidCooldown(int AtkIdx)
{
    if(Class'WorldInfo'.static.GetWorldInfo().TimeSeconds < Attacks[AtkIdx].LastTimePlayed)
    {
        LogInternal("[ANIMINFO] WorldInfo.TimeSeconds mismatch! Resetting cooldowns.");
        Attacks[AtkIdx].LastTimePlayed = 0;
    }
}

function bool CanDoAttackAnim(int Idx, KFPawn P, optional Actor Target)
{
    local AttackAnimInfo Attack;

    CheckForValidCooldown(Idx);
    Attack = Attacks[Idx];
    if(Attack.Anims.Length <= 0)
    {
        LogInternal((string(self) @ "CanDoAttackAnim missing attack anim names for") @ string(Attacks[Idx].Tag));
        return false;
    }
    if(Attack.bOnlyWhilePathClear && P.MyKFAIC.bIsBodyBlocked)
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhilePathClear is true but Pawn is blocked");
        }
        return false;
    }
    if((Attack.bHasCloaking && Attack.bOnlyWhileCloaked && !P.bIsCloaking) || Attack.bOnlyWhileDeCloaked && P.bIsCloaking)
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because it is not allowed in this cloaking state");
        }
        return false;
    }
    if(Attack.bIsBattlePhaseAttack && (P.GetCurrentBattlePhase() < Attack.BattlePhaseMinimum) || P.GetCurrentBattlePhase() > Attack.BattlePhaseMaximum)
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because not allowed in this Battle Phase");
        }
        return false;
    }
    if((P.MyKFAIC != none) && !P.MyKFAIC.CheckOverallCooldownTimer())
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging && P.MyKFAIC != none)
        {
            P.MyKFAIC.AILog_Internal(((string(GetFuncName()) $ "() PREVENTING attack ") $ string(Attack.Tag)) $ " because Overall Cooldown is active", 'Command_Attack_Melee');
        }
        return false;
    }
    if(((Attack.GlobalCooldown > float(0)) && Attack.LastTimePlayed > 0) && (P.WorldInfo.TimeSeconds - Attack.LastTimePlayed) < Attack.GlobalCooldown)
    {
        if(bDebugLog)
        {
            LogInternal(((((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because GlobalCooldown (") $ string(Attack.GlobalCooldown)) $ ") LastTimePlayed:") $ string(P.WorldInfo.TimeSeconds - Attack.LastTimePlayed));
        }
        return false;
    }
    if((Attack.Chance < 1) && FRand() > Attack.Chance)
    {
        if(bDebugLog)
        {
            LogInternal((((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because random chance missed (Chance:") $ string(Attack.Chance)) $ ")");
        }
        return false;
    }
    if(!AllowAttackByMovement(byte(Idx), P))
    {
        return false;
    }
    if(Attack.bOnlyWhileHeadless != P.ShouldPlayHeadlessMeleeAnims())
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhileHeadless is true but Pawn has a head");
        }
        return false;
    }
    if((Attack.InstancedCooldown > float(0)) && IsAttackOnCooldown(P, Attack.Tag, Attack.InstancedCooldown))
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because Cooldown is still active");
        }
        return false;
    }
    if(Attack.bOnlyWhileSurrounded && !P.IsSurrounded(true, Attack.MinSurroundedBy, Attack.SurroundedRadius))
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because pawn is not surrounded");
        }
        return false;
    }
    if(Target != none)
    {
        if(Attack.bOnlyWhileEnemyMoving && IsZero(Target.Velocity))
        {
            if(bDebugLog)
            {
                LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because target velocity is 0");
            }
            return false;            
        }
        else
        {
            if(Attack.bOnlyWhileEnemyNotMoving && !IsZero(Target.Velocity))
            {
                if(bDebugLog)
                {
                    LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because target velocity is not 0");
                }
                return false;
            }
        }
        if((Attack.MaxDistance > float(0)) && VSizeSq(P.Location - Target.Location) > Square(Attack.MaxDistance))
        {
            if(bDebugLog)
            {
                LogInternal(((((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because target dist (") $ string(VSize(P.Location - Target.Location))) $ ") is greater than ") $ string(Attack.MaxDistance));
            }
            return false;
        }
        if((Attack.MinDistance > float(0)) && VSizeSq(P.Location - Target.Location) < Square(Attack.MinDistance))
        {
            if(bDebugLog)
            {
                LogInternal(((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because target dist is less than ") $ string(Attack.MinDistance));
            }
            return false;
        }
    }
    if(!AllowAttackByDifficulty(byte(Idx)))
    {
        if(P.MyKFAIC != none)
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging && P.MyKFAIC != none)
            {
                P.MyKFAIC.AILog_Internal((((string(GetFuncName()) $ "() PREVENTING attack ") $ string(Attack.Tag)) $ " because it has a DifficultyRating of ") $ string(Attack.DifficultyRating), 'Command_Attack_Melee');
            }
        }
        return false;
    }
    return true;
}

function bool IsAttackOnCooldown(KFPawn P, name CooldownTag, float CoolDownTime)
{
    if(P.MyKFAIC != none)
    {
        return !P.MyKFAIC.CheckCooldownTimer(CooldownTag);
    }
    return false;
}

function Vector2D GetAttackRangeByName(name AttackName)
{
    local int Idx;

    Idx = Attacks.Find('Tag', AttackName;
    if(Idx != -1)
    {
        return vect2d(Attacks[Idx].MinDistance, Attacks[Idx].MaxDistance);
    }
    return vect2d(0, 0);
}

function Vector2D GetAttackRangeExtent(name AttackName)
{
    local int I;
    local float MinRange, MaxRange;

    MinRange = 2.147484E+09;
    I = 0;
    J0x1A:

    if(I < Attacks.Length)
    {
        if(Attacks[I].Chance > 0)
        {
            MinRange = float(Min(int(MinRange), int(Attacks[I].MinDistance)));
            MaxRange = float(Max(int(MaxRange), int(Attacks[I].MaxDistance)));
        }
        ++ I;
        goto J0x1A;
    }
    return vect2d(MinRange, MaxRange);
}

function SetDifficultyValues(KFGameDifficultyInfo DifficultyInfo)
{
    WeakAttackChance = DifficultyInfo.GetWeakAttackChance();
    MediumAttackChance = DifficultyInfo.GetMediumAttackChance();
    HardAttackChance = DifficultyInfo.GetHardAttackChance();
}

function bool AllowAttackByMovement(byte Idx, KFPawn P)
{
    if(Attacks[Idx].bOnlyWhileSprinting && !P.bIsSprinting)
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhileSprinting is true but Pawn is not sprinting");
        }
        return false;        
    }
    else
    {
        if(Attacks[Idx].bOnlyWhileNotSprinting && P.bIsSprinting)
        {
            if(bDebugLog)
            {
                LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhileNotSprinting is true but Pawn is sprinting");
            }
            return false;
        }
    }
    if(Attacks[Idx].bOnlyWhileInSpecializedMode && !P.ShouldPlaySpecialMeleeAnims())
    {
        if(bDebugLog)
        {
            LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhileInSpecializedMode is true but Pawn not in SpecializedMode");
        }
        return false;        
    }
    else
    {
        if(Attacks[Idx].bOnlyWhileNotInSpecializedMode && P.ShouldPlaySpecialMeleeAnims())
        {
            if(bDebugLog)
            {
                LogInternal((((string(P) @ string(GetFuncName())) $ "() rejecting attack idx ") $ string(Idx)) $ " because bOnlyWhileNotInSpecializedMode is true but Pawn is in SpecializedMode");
            }
            return false;
        }
    }
    return true;
}

function bool AllowAttackByDifficulty(byte Index)
{
    if(bEnableDifficultyScaling)
    {
        switch(Attacks[Index].DifficultyRating)
        {
            case 0:
                if((MediumAttackChance >= WeakAttackChance) && Attacks[Index].bSkipIfDifficultyIsExceeded)
                {
                    return false;
                }
                return (WeakAttackChance >= 1) || FRand() < WeakAttackChance;
            case 1:
                if((HardAttackChance >= MediumAttackChance) && Attacks[Index].bSkipIfDifficultyIsExceeded)
                {
                    return false;
                }
                return (MediumAttackChance >= 1) || FRand() < MediumAttackChance;
            case 2:
                return (HardAttackChance >= 1) || FRand() < HardAttackChance;
            default:
                break;
            }
    }
    else
    {
        return true;
    }
}

function name ChooseDeathAnimation(KFPawn P, class<DamageType> DamageType, Vector HitDir, optional name HitBoneName)
{
    local int Idx;

    if(ClassIsChildOf(DamageType, Class'KFDT_Explosive'))
    {
        return EvaulateDeathAnimList(ExplosiveDeathAnims, P, HitDir);
    }
    Idx = BodyPartDeathAnims.Find('BoneName', HitBoneName;
    if(Idx != -1)
    {
        if((BodyPartDeathAnims[Idx].IgnoreChance > 0) && FRand() < BodyPartDeathAnims[Idx].IgnoreChance)
        {
            return EvaulateDeathAnimList(DefaultDeathAnims, P, HitDir);
        }
        return EvaulateDeathAnimList(BodyPartDeathAnims[Idx], P, HitDir);
    }
    return EvaulateDeathAnimList(DefaultDeathAnims, P, HitDir);
}

function name EvaulateDeathAnimList(const out DeathAnimInfo DeathAnims, KFPawn P, Vector HitDir)
{
    local KFPawn.EPawnOctant Region;

    if((DeathAnims.RagdollChance > 0) && FRand() < DeathAnims.RagdollChance)
    {
        return 'None';
    }
    if(((DeathAnims.DismemberedAnims.Length > 0) && P.bHasBrokenConstraints) && P.Mesh.IsBrokenConstraint(DeathAnims.BoneName))
    {
        LastDeathAnimIndex = byte(Rand(DeathAnims.DismemberedAnims.Length));
        return DeathAnims.DismemberedAnims[LastDeathAnimIndex];
    }
    if(DeathAnims.Anims_B.Length > 0)
    {
        Region = P.CalcQuadRegion(P.Rotation, -HitDir);
        switch(Region)
        {
            case 1:
                if(DeathAnims.Anims_B.Length > 0)
                {
                    LastDeathAnimIndex = byte(Rand(DeathAnims.Anims_B.Length));
                    return DeathAnims.Anims_B[LastDeathAnimIndex];
                }
                break;
            case 2:
                if(DeathAnims.Anims_L.Length > 0)
                {
                    LastDeathAnimIndex = byte(Rand(DeathAnims.Anims_L.Length));
                    return DeathAnims.Anims_L[LastDeathAnimIndex];
                }
                break;
            case 3:
                if(DeathAnims.Anims_R.Length > 0)
                {
                    LastDeathAnimIndex = byte(Rand(DeathAnims.Anims_R.Length));
                    return DeathAnims.Anims_R[LastDeathAnimIndex];
                }
                break;
            default:
                break;
        }
    }
    else
    {
        LastDeathAnimIndex = byte(Rand(DeathAnims.Anims_F.Length));
        return DeathAnims.Anims_F[LastDeathAnimIndex];
    }
}

function bool PlayHitReactionAnim(KFPawn P, KFPawnAnimInfo.EHitReactionAnimType Type, KFPawn.EPawnOctant Dir)
{
    local name AnimName;
    local float Duration;

    if(!bCanPlayAnimHitReactions)
    {
        return false;
    }
    if((Dir == 8) && DmgOverTimeHitAnims.Length > 0)
    {
        AnimName = DmgOverTimeHitAnims[Rand(DmgOverTimeHitAnims.Length)];
        Duration = P.PlayBodyAnim(AnimName, 3, 1, 0.1);
        P.NextHitReactionAnim_ActorTime = P.GetActorTimeSeconds() + RandRange(0.15, 0.33);        
    }
    else
    {
        if((Type == 0) && LightHitAnims[Dir].Anims.Length > 0)
        {
            AnimName = LightHitAnims[Dir].Anims[Rand(LightHitAnims[Dir].Anims.Length)];
            Duration = P.PlayBodyAnim(AnimName, 3, 1, 0.1);
            P.NextHitReactionAnim_ActorTime = P.GetActorTimeSeconds() + RandRange(0.15, 0.33);            
        }
        else
        {
            if((Type == 1) && MediumHitAnims[Dir].Anims.Length > 0)
            {
                AnimName = MediumHitAnims[Dir].Anims[Rand(MediumHitAnims[Dir].Anims.Length)];
                Duration = P.PlayBodyAnim(AnimName, 1);
                P.NextHitReactionAnim_ActorTime = P.GetActorTimeSeconds() + 0.33;
                P.SoundGroupArch.PlayPainSound(P);                
            }
            else
            {
                if((Type == 2) && HeavyHitAnims[Dir].Anims.Length > 0)
                {
                    AnimName = HeavyHitAnims[Dir].Anims[Rand(HeavyHitAnims[Dir].Anims.Length)];
                    Duration = P.PlayBodyAnim(AnimName, 1);
                    P.NextHitReactionAnim_ActorTime = P.GetActorTimeSeconds() + 0.33;
                    P.SoundGroupArch.PlayPainSound(P);
                }
            }
        }
    }
    return Duration > float(0);
}

defaultproperties
{
    bEnableDifficultyScaling=true
    bCanPlayAnimHitReactions=true
    bCanPlayDeathAnimations=true
    WeakAttackChance=1
    MediumAttackChance=1
    HardAttackChance=1
    LightHitAnims(0)=(Anims=(ADD_Bullet_F_V1,ADD_Bullet_F_V2,ADD_Bullet_F_V3))
    LightHitAnims(1)=(Anims=(ADD_Bullet_B_V1,ADD_Bullet_B_V2,ADD_Bullet_B_V3))
    LightHitAnims(2)=(Anims=(ADD_Bullet_L_V1,ADD_Bullet_L_V2,ADD_Bullet_L_V3))
    LightHitAnims(3)=(Anims=(ADD_Bullet_R_V1,ADD_Bullet_R_V2,ADD_Bullet_R_V3))
    LightHitAnims(4)=(Anims=(ADD_Bullet_FL_V1,ADD_Bullet_FL_V2,ADD_Bullet_FL_V3))
    LightHitAnims(5)=(Anims=(ADD_Bullet_FR_V1,ADD_Bullet_FR_V2,ADD_Bullet_FR_V3))
    LightHitAnims(6)=(Anims=(ADD_Bullet_BL_V1,ADD_Bullet_BL_V2,ADD_Bullet_BL_V3))
    LightHitAnims(7)=(Anims=(ADD_Bullet_BR_V1,ADD_Bullet_BR_V2,ADD_Bullet_BR_V3))
    MediumHitAnims(0)=(Anims=(Hit_F_V1,Hit_F_V2,Hit_F_V3))
    MediumHitAnims(1)=(Anims=(Hit_B_V1,Hit_B_V2,Hit_B_V3))
    MediumHitAnims(2)=(Anims=(Hit_L_V1,Hit_L_V2,Hit_L_V3))
    MediumHitAnims(3)=(Anims=(Hit_R_V1,Hit_R_V2,Hit_R_V3))
    MediumHitAnims(4)=(Anims=(Hit_FL_V1,Hit_FL_V2,Hit_FL_V3))
    MediumHitAnims(5)=(Anims=(Hit_FR_V1,Hit_FR_V2,Hit_FR_V3))
    MediumHitAnims(6)=(Anims=(Hit_BL_V1,Hit_BL_V2,Hit_BL_V3))
    MediumHitAnims(7)=(Anims=(Hit_BR_V1,Hit_BR_V2,Hit_BR_V3))
    HeavyHitAnims(0)=(Anims=(Hit_Hard_F_V1,Hit_Hard_F_V2,Hit_Hard_F_V3))
    HeavyHitAnims(1)=(Anims=(Hit_Hard_B_V1,Hit_Hard_B_V2,Hit_Hard_B_V3))
    HeavyHitAnims(2)=(Anims=(Hit_Hard_L_V1,Hit_Hard_L_V2,Hit_Hard_L_V3))
    HeavyHitAnims(3)=(Anims=(Hit_Hard_R_V1,Hit_Hard_R_V2,Hit_Hard_R_V3))
    HeavyHitAnims(4)=(Anims=(Hit_Hard_FL_V1,Hit_Hard_FL_V2,Hit_Hard_FL_V3))
    HeavyHitAnims(5)=(Anims=(Hit_Hard_FR_V1,Hit_Hard_FR_V2,Hit_Hard_FR_V3))
    HeavyHitAnims(6)=(Anims=(Hit_Hard_BL_V1,Hit_Hard_BL_V2,Hit_Hard_BL_V3))
    HeavyHitAnims(7)=(Anims=(Hit_Hard_BR_V1,Hit_Hard_BR_V2,Hit_Hard_BR_V3))
    DmgOverTimeHitAnims(0)=ADD_Bullet_F_V1
    DmgOverTimeHitAnims(1)=ADD_Bullet_F_V2
    DmgOverTimeHitAnims(2)=ADD_Bullet_F_V3
    DmgOverTimeHitAnims(3)=ADD_Bullet_FL_V1
    DmgOverTimeHitAnims(4)=ADD_Bullet_FL_V2
    DmgOverTimeHitAnims(5)=ADD_Bullet_FL_V3
    DmgOverTimeHitAnims(6)=ADD_Bullet_FR_V1
    DmgOverTimeHitAnims(7)=ADD_Bullet_FR_V2
    DmgOverTimeHitAnims(8)=ADD_Bullet_FR_V3
    StumbleAnims(0)=(Anims=(Stumble_F_V1,Stumble_F_V2,Stumble_F_V3,Stumble_F_V4))
    StumbleAnims(1)=(Anims=(Stumble_B_V1,Stumble_B_V2,Stumble_B_V3,Stumble_B_V4))
    StumbleAnims(2)=(Anims=(Stumble_L_V1,Stumble_L_V2,Stumble_L_V3,Stumble_L_V4))
    StumbleAnims(3)=(Anims=(Stumble_R_V1,Stumble_R_V2,Stumble_R_V3,Stumble_R_V4))
    StumbleAnims(4)=(Anims=(Stumble_L_Leg_F_V1,Stumble_L_Leg_F_V2))
    StumbleAnims(5)=(Anims=(Stumble_L_Leg_B_V1,Stumble_L_Leg_B_V2))
    StumbleAnims(6)=(Anims=(Stumble_L_Leg_L_V1,Stumble_L_Leg_L_V2))
    StumbleAnims(7)=(Anims=(Stumble_L_Leg_R_V1,Stumble_L_Leg_R_V2))
    StumbleAnims(8)=(Anims=(Stumble_R_Leg_F_V1,Stumble_R_Leg_F_V2))
    StumbleAnims(9)=(Anims=(Stumble_R_Leg_B_V1,Stumble_R_Leg_B_V2))
    StumbleAnims(10)=(Anims=(Stumble_R_Leg_L_V1,Stumble_R_Leg_L_V2))
    StumbleAnims(11)=(Anims=(Stumble_R_Leg_R_V1,Stumble_R_Leg_R_V2))
    StumbleAnims(12)=(Anims=(Stumble_F_V1,Stumble_F_V2,Stumble_F_V3,Stumble_F_V4))
    DefaultDeathAnims=(BoneName=None,Anims_F=(Death_F_V1,Death_F_V2,Death_F_V3,Death_F_V4,Death_F_V5,Death_F_V6,Death_F_V7,Death_F_V8),Anims_B=(Death_B_V1,Death_B_V2,Death_B_V3,Death_B_V4,Death_B_V5,Death_B_V6),Anims_L=(Death_L_V1,Death_L_V2,Death_L_V3,Death_L_V4,Death_L_V5,Death_L_V6),Anims_R=(Death_R_V1,Death_R_V2,Death_R_V3,Death_R_V4,Death_R_V5,Death_R_V6),DismemberedAnims=none,RagdollChance=0,IgnoreChance=0)
    ExplosiveDeathAnims=(BoneName=None,Anims_F=(DeathEXP_F_V1,DeathEXP_F_V2,DeathEXP_F_V3,DeathEXP_F_V4,DeathEXP_Up_V1,DeathEXP_Up_V2),Anims_B=(DeathEXP_B_V1,DeathEXP_B_V2,DeathEXP_B_V3,DeathEXP_Up_V1,DeathEXP_Up_V2),Anims_L=(DeathEXP_L_V1,DeathEXP_L_V2,DeathEXP_L_V3,DeathEXP_L_V4),Anims_R=(DeathEXP_R_V1,DeathEXP_R_V2,DeathEXP_R_V3,DeathEXP_R_V4),DismemberedAnims=none,RagdollChance=0,IgnoreChance=0)
    BodyPartDeathAnims(0)=(BoneName=head,Anims_F=(Death_Head_V1,Death_Head_V2,Death_Head_V3,Death_Head_V4,Death_Head_V5,Death_Head_V6,Death_Head_V7,Death_Head_V8,Death_Convulsion_V1,Death_Convulsion_V2,Death_Neck_V4,Death_Neck_V5,Death_Neck_V6),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0.25,IgnoreChance=0.1)
    BodyPartDeathAnims(1)=(BoneName=neck,Anims_F=(Death_Neck_V1,Death_Neck_V2,Death_Neck_V3,Death_Neck_V4,Death_Neck_V5,Death_Neck_V6,Death_Neck_V7),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(2)=(BoneName=Hips,Anims_F=(Death_Stomach_V1,Death_Stomach_V2,Death_Stomach_V3,Death_Stomach_V4,Death_Stomach_V5,Death_Stomach_V6,Death_Stomach_V7,Death_Neck_V1,Death_Neck_V2,Death_Neck_V7),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0.2,IgnoreChance=0.1)
    BodyPartDeathAnims(3)=(BoneName=Spine1,Anims_F=(Death_Stomach_V1,Death_Stomach_V2,Death_Stomach_V3,Death_Stomach_V4,Death_Stomach_V5,Death_Stomach_V6,Death_Stomach_V7,Death_Neck_V1,Death_Neck_V2,Death_Neck_V7),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0.2,IgnoreChance=0.1)
    BodyPartDeathAnims(4)=(BoneName=Spine2,Anims_F=(Death_FL_V5,Death_FL_V6,Death_FR_V6,Death_Head_V5,Death_Head_V7,Death_Head_V8,Death_Neck_V5,Death_Neck_V6,Death_Neck_V7,Death_Stomach_V5,Death_Convulsion_V2,Death_Convulsion_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0.1,IgnoreChance=0.5)
    BodyPartDeathAnims(5)=(BoneName=LeftUpLeg,Anims_F=(Death_LegL_V1,Death_LegL_V2,Death_LegL_V3,Death_LegL_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(6)=(BoneName=LeftLeg,Anims_F=(Death_LegL_V1,Death_LegL_V2,Death_LegL_V3,Death_LegL_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(7)=(BoneName=LeftFoot,Anims_F=(Death_LegL_V1,Death_LegL_V2,Death_LegL_V3,Death_LegL_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(8)=(BoneName=RightUpLeg,Anims_F=(Death_LegR_V1,Death_LegR_V2,Death_LegR_V3,Death_LegR_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(9)=(BoneName=RightLeg,Anims_F=(Death_LegR_V1,Death_LegR_V2,Death_LegR_V3,Death_LegR_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(10)=(BoneName=RightFoot,Anims_F=(Death_LegR_V1,Death_LegR_V2,Death_LegR_V3,Death_LegR_V4),Anims_B=none,Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(11)=(BoneName=LeftShoulder,Anims_F=(Death_FL_V1,Death_FL_V2,Death_FL_V3,Death_LegL_V2,Death_LegR_V1),Anims_B=(Death_BL_V1,Death_BL_V2,Death_BL_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(12)=(BoneName=RightShoulder,Anims_F=(Death_FR_V1,Death_FR_V2,Death_FR_V3,Death_LegL_V1),Anims_B=(Death_BR_V1,Death_BR_V2,Death_BR_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(13)=(BoneName=LeftArm,Anims_F=(Death_FL_V1,Death_FL_V2,Death_FL_V3,Death_FL_V4,Death_FL_V5),Anims_B=(Death_BL_V1,Death_BL_V2,Death_BL_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(14)=(BoneName=LeftForearm,Anims_F=(Death_FL_V1,Death_FL_V2,Death_FL_V3,Death_FL_V4,Death_FL_V5),Anims_B=(Death_BL_V1,Death_BL_V2,Death_BL_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(15)=(BoneName=LeftHand,Anims_F=(Death_FL_V1,Death_FL_V2,Death_FL_V3,Death_FL_V4,Death_FL_V5),Anims_B=(Death_BL_V1,Death_BL_V2,Death_BL_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(16)=(BoneName=RightArm,Anims_F=(Death_FR_V1,Death_FR_V2,Death_FR_V3,Death_FR_V4),Anims_B=(Death_BR_V1,Death_BR_V2,Death_BR_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(17)=(BoneName=RightForearm,Anims_F=(Death_FR_V1,Death_FR_V2,Death_FR_V3,Death_FR_V4),Anims_B=(Death_BR_V1,Death_BR_V2,Death_BR_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    BodyPartDeathAnims(18)=(BoneName=RightHand,Anims_F=(Death_FR_V1,Death_FR_V2,Death_FR_V3,Death_FR_V4),Anims_B=(Death_BR_V1,Death_BR_V2,Death_BR_V3),Anims_L=none,Anims_R=none,DismemberedAnims=none,RagdollChance=0,IgnoreChance=0.1)
    DeathPhysMotorStrength=(X=70000,Y=2000)
    TauntAnims(0)=Taunt_V1
    TauntAnims(1)=Taunt_V2
    TauntKillAnims(0)=Taunt_Kill_V1
    TauntKillAnims(1)=Taunt_Kill_V2
}