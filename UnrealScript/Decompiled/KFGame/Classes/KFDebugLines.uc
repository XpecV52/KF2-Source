/*******************************************************************************
 * KFDebugLines generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDebugLines extends Actor
    native
    notplaceable
    hidecategories(Navigation);

struct native DebugDrawInfo
{
    var byte R;
    var byte G;
    var byte B;
    var bool bPersistent;
    var int PersistentFrameCounter;
    var float Duration;
    var name OwnerName;
    var int DDID;
    var bool bHidden;

    structdefaultproperties
    {
        R=0
        G=0
        B=0
        bPersistent=false
        PersistentFrameCounter=0
        Duration=0
        OwnerName=None
        DDID=0
        bHidden=false
    }
};

struct native DebugLine extends DebugDrawInfo
{
    var Vector Start;
    var Vector End;
    var bool bDrawFromOwner;
    var bool bDrawToOwner;
};

struct native PawnDebugLine extends DebugLine
{
    var bool bDrawViewRotation;
    var bool bDrawDesiredRotation;
};

struct native DebugSphere extends DebugDrawInfo
{
    var Vector Center;
    var float Radius;
    var int Segments;
};

struct native DebugText3D extends DebugDrawInfo
{
    var Vector WorldPos;
    var Vector ScreenPos;
    var string Text;
    var bool bUseDropShadow;
    var float WorldTime;
    var float ZVelocity;
    var float ZOffset;
    var Actor Base;
};

var array<DebugLine> ActiveLines;
var int MaxLines;
var array<DebugSphere> ActiveSpheres;
var int MaxSpheres;
var array<DebugText3D> ActiveText3D;
var int MaxText3D;

// Export UKFDebugLines::execNativePostRenderFor(FFrame&, void* const)
native simulated function NativePostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir);

// Export UKFDebugLines::execAddPawnDebugLine(FFrame&, void* const)
native simulated function AddPawnDebugLine(bool bDrawViewRotation, bool bDrawDesiredRotation, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional name InOwnerName, optional int DDID);

// Export UKFDebugLines::execAddDebugLine(FFrame&, void* const)
native simulated function AddDebugLine(Vector Start, Vector End, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional name InOwnerName, optional int DDID, optional bool bDrawFromOwner, optional bool bDrawToOwner, optional bool bDrawDesiredRotation)
{
    bDrawFromOwner = false;
    bDrawToOwner = false;                                                            
}

// Export UKFDebugLines::execAddDebugLineFromOwner(FFrame&, void* const)
native simulated function AddDebugLineFromOwner(name InOwner, Vector End, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional int DDID);

// Export UKFDebugLines::execAddDebugLineToOwner(FFrame&, void* const)
native simulated function AddDebugLineToOwner(Vector Start, name InOwner, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional int DDID);

// Export UKFDebugLines::execAddDebugSphere(FFrame&, void* const)
native simulated function AddDebugSphere(Vector Center, float Radius, int Segments, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional name InOwnerName, optional int DDID);

// Export UKFDebugLines::execAddDebugText3D(FFrame&, void* const)
native simulated function AddDebugText3D(Vector WorldPos, string Text, bool bUseDropShadow, byte R, byte G, byte B, optional bool bPersistent, optional float InDuration, optional Actor InBase, optional float InZVelocity, optional name InOwnerName, optional int DDID)
{
    InZVelocity = 0;                                                                
}

// Export UKFDebugLines::execRemoveOwnedDebugLines(FFrame&, void* const)
native simulated function RemoveOwnedDebugLines(name InOwnerName, optional int DDID);

// Export UKFDebugLines::execRemoveOwnedDebugSpheres(FFrame&, void* const)
native simulated function RemoveOwnedDebugSpheres(name InOwnerName, optional int DDID);

// Export UKFDebugLines::execRemoveOwnedDebugText3D(FFrame&, void* const)
native simulated function RemoveOwnedDebugText3D(name InOwnerName, optional int DDID);

// Export UKFDebugLines::execClearAll(FFrame&, void* const)
native simulated function ClearAll();

event PostBeginPlay()
{
    super.PostBeginPlay();
    AddToPostRenderList();
}

function AddToPostRenderList()
{
    local PlayerController PC;
    local HUD iHUD;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        iHUD = PC.myHUD;
        if(iHUD != none)
        {
            iHUD.AddPostRenderedActor(self);
            iHUD.bShowOverlays = true;
        }        
    }    
}

function RemoveFromPostRenderList()
{
    local PlayerController PC;
    local HUD iHUD;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        iHUD = PC.myHUD;
        if(iHUD != none)
        {
            iHUD.RemovePostRenderedActor(self);
            if(iHUD.PostRenderedActors.Length == 0)
            {
                iHUD.bShowOverlays = iHUD.default.bShowOverlays;
            }
        }        
    }    
}

event Destroyed()
{
    RemoveFromPostRenderList();
}

static function NewDebugLineFromOwner(name InOwner, Vector End, optional Color InColor, optional bool bPersistent, optional float InDuration, optional int DDID)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.AddDebugLineFromOwner(InOwner, End, InColor.R, InColor.G, InColor.B, bPersistent, InDuration, DDID);
    }
}

static function NewDebugLineToOwner(Vector Start, name InOwner, optional Color InColor, optional bool bPersistent, optional float InDuration, optional int DDID)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.AddDebugLineToOwner(Start, InOwner, InColor.R, InColor.G, InColor.B, bPersistent, InDuration, DDID);
    }
}

static function NewDebugSphere(Vector Center, float Radius, int Segments, optional Color InColor, optional bool bPersistent, optional float InDuration, optional name InOwnerName, optional int DDID)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.AddDebugSphere(Center, Radius, Segments, InColor.R, InColor.G, InColor.B, bPersistent, InDuration, InOwnerName, DDID);
    }
}

static function KFDebugLines GetDebugLines()
{
    local KFGameEngine KFGEngine;

    KFGEngine = KFGameEngine(Class'KFGameEngine'.static.GetEngine());
    if(KFGEngine != none)
    {
        return KFGEngine.GetDebugLines();
    }
    return none;
}

static function KFDebug_ClearLines(name InName, optional int Id)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.RemoveOwnedDebugLines(InName, Id);
    }
}

static function KFDebug_ClearSpheres(name InName, optional int Id)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.RemoveOwnedDebugSpheres(InName, Id);
    }
}

static function KFDebug_ClearText(name InName, optional int Id)
{
    local KFDebugLines KFDL;

    KFDL = GetDebugLines();
    if(KFDL != none)
    {
        KFDL.RemoveOwnedDebugText3D(InName, Id);
    }
}

defaultproperties
{
    MaxLines=1000
    MaxSpheres=1000
    MaxText3D=100
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bKillDuringLevelTransition=true
    bPostRenderIfNotVisible=true
}