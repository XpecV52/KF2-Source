/*******************************************************************************
 * KFPawn generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn extends BaseAIPawn
    abstract
    native(Pawn)
    nativereplication
    config(Game)
    hidecategories(Navigation);

const MAX_ADDED_HITFX = 7;
const MAX_GET_RBBONE_CHECKS = 3;
const AIAirControl = 0.35;

enum EHitZoneIndex
{
    HZI_HEAD,
    HZI_MAX
};

enum EPawnOctant
{
    DIR_Forward,
    DIR_Backward,
    DIR_Left,
    DIR_Right,
    DIR_ForwardLeft,
    DIR_ForwardRight,
    DIR_BackwardLeft,
    DIR_BackwardRight,
    DIR_None,
    DIR_MAX
};

enum EAnimSlotStance
{
    EAS_FullBody,
    EAS_UpperBody,
    EAS_LowerBody,
    EAS_Additive,
    EAS_CH_UpperBody,
    EAS_CH_LowerBody,
    EAS_Face,
    EAS_MAX
};

enum ESpecialMove
{
    SM_None,
    SM_MeleeAttack,
    SM_MeleeAttackDoor,
    SM_GrappleAttack,
    SM_Stumble,
    SM_RecoverFromRagdoll,
    SM_Knockdown,
    SM_DeathAnim,
    SM_Stunned,
    SM_Frozen,
    SM_GorgeZedVictim,
    SM_Emerge,
    SM_Jump,
    SM_Taunt,
    SM_WalkingTaunt,
    SM_Evade,
    SM_Evade_Fear,
    SM_Block,
    SM_Heal,
    SM_Rally,
    SM_SprintStart,
    SM_SonicAttack,
    SM_StandAndShootAttack,
    SM_HoseWeaponAttack,
    SM_Suicide,
    SM_PlayerZedMove_LMB,
    SM_PlayerZedMove_RMB,
    SM_PlayerZedMove_V,
    SM_PlayerZedMove_MMB,
    SM_PlayerZedMove_Q,
    SM_PlayerZedMove_G,
    SM_GrappleVictim,
    SM_DisabledGrappleVictim,
    SM_HansGrappleVictim,
    SM_SirenVortexVictim,
    SM_Emote,
    SM_DARGrappleVictim,
    SM_BloatKingGorgeVictim,
    SM_BossTheatrics,
    SM_ChangeStance,
    SM_Hans_ThrowGrenade,
    SM_Hans_GrenadeHalfBarrage,
    SM_Hans_GrenadeBarrage,
    SM_ScriptedPawnStateChange,
    SM_Custom1,
    SM_Custom2,
    SM_Custom3,
    SM_Custom4,
    SM_Custom5,
    ESpecialMove_Blank,
    ESpecialMove_MAX
};

struct native HitZoneInfo
{
    /** The name of this hitzone */
    var() name ZoneName;
    /** The name of this hitzone */
    var() name BoneName;
    /** Name of the bone that corresponds to this hitzone */
    var() int GoreHealth;
    /** The base amount of health for this hitzone, and stores health this zone has left (Not Replicated) */
    var() int MaxGoreHealth;
    /** Max for this hit zone.  Copied from GoreHealth if it isn't initialized at runtime */
    var() float DmgScale;
    /** Damage multiplier for damage taken on this hitzone */
    var() KFAfflictionManager.EHitZoneBodyPart Limb;
    /** Group zones together for hit reactions */
    var() byte SkinID;
    var transient bool bPlayedInjury;

    structdefaultproperties
    {
        ZoneName=None
        BoneName=None
        GoreHealth=50
        MaxGoreHealth=-1
        DmgScale=1
        Limb=EHitZoneBodyPart.BP_Torso
        SkinID=0
        bPlayedInjury=false
    }
};

struct native DamageOverTimeInfo
{
    var transient int Damage;
    var transient class<KFDamageType> DamageType;
    var transient byte DoT_Type;
    var transient float Duration;
    var transient float interval;
    var transient float TimeUntilNextDamage;
    var transient Controller InstigatedBy;

    structdefaultproperties
    {
        Damage=0
        DamageType=none
        DoT_Type=0
        Duration=0
        interval=0
        TimeUntilNextDamage=0
        InstigatedBy=none
    }
};

struct native ExplosiveStackInfo
{
    var GameExplosionActor Explosion;
    var float LastHitTime;

    structdefaultproperties
    {
        Explosion=none
        LastHitTime=0
    }
};

struct native DamageInfo
{
    var Controller DamagerController;
    var PlayerReplicationInfo DamagerPRI;
    var float Damage;
    var float TotalDamage;
    var float LastTimeDamaged;
    var array< class<KFPerk> > DamagePerks;
    var array< class<Actor> > DamageCausers;
    var array< class<KFDamageType> > DamageTypes;

    structdefaultproperties
    {
        DamagerController=none
        DamagerPRI=none
        Damage=0
        TotalDamage=0
        LastTimeDamaged=0
        DamagePerks=none
        DamageCausers=none
        DamageTypes=none
    }
};

struct native KFHitFxInfo
{
    var Vector HitLocation;
    var Vector EncodedHitDirection;
    var class<KFDamageType> DamageType;
    var byte HitBoneIndex;
    var bool bRadialDamage;
    var bool bObliterated;
    var PlayerReplicationInfo DamagerPRI;

    structdefaultproperties
    {
        HitLocation=(X=0,Y=0,Z=0)
        EncodedHitDirection=(X=0,Y=0,Z=0)
        DamageType=none
        HitBoneIndex=0
        bRadialDamage=false
        bObliterated=false
        DamagerPRI=none
    }
};

struct native KFRadialHitFxInfo
{
    var byte RadiusDamageScale;
    var Vector RadiusHurtOrigin;

    structdefaultproperties
    {
        RadiusDamageScale=0
        RadiusHurtOrigin=(X=0,Y=0,Z=0)
    }
};

struct native KnockdownImpulseInfo
{
    var Vector LinearVelocity;
    var Vector AngularVelocity;
    var Vector ImpulsePosition;
    var Vector ImpulseStrength;
    var byte PointImpulseHitZone;
    var bool bIsRadialImpulse;

    structdefaultproperties
    {
        LinearVelocity=(X=0,Y=0,Z=0)
        AngularVelocity=(X=0,Y=0,Z=0)
        ImpulsePosition=(X=0,Y=0,Z=0)
        ImpulseStrength=(X=0,Y=0,Z=0)
        PointImpulseHitZone=0
        bIsRadialImpulse=false
    }
};

struct native ReplicatedRootPosInfo
{
    var Vector Position;
    var bool bNewData;

    structdefaultproperties
    {
        Position=(X=0,Y=0,Z=0)
        bNewData=false
    }
};

struct native LookAtInfo
{
    var Actor LookAtTarget;
    var bool bUseSpine;
    var float BlendIn;
    var float BlendOut;
    var Vector TargetOffset;
    var float LookAtPct;
    var Vector ForcedLookAtLocation;

    structdefaultproperties
    {
        LookAtTarget=none
        bUseSpine=false
        BlendIn=0
        BlendOut=0
        TargetOffset=(X=0,Y=0,Z=0)
        LookAtPct=0
        ForcedLookAtLocation=(X=0,Y=0,Z=0)
    }
};

struct native KFSpecialMoveStruct
{
    var KFPawn.ESpecialMove SpecialMove;
    var Pawn InteractionPawn;
    var byte Flags;

    structdefaultproperties
    {
        SpecialMove=ESpecialMove.SM_None
        InteractionPawn=none
        Flags=0
    }
};

struct native PowerUpAmbientSoundInfo
{
    var AkEvent FirstPersonPowerUpAmbientSound;
    var AkEvent ThirdPersonPowerUpAmbientSound;
    var AkEvent FirstPersonStopPowerUpAmbientSound;
    var AkEvent ThirdPersonStopPowerUpAmbientSound;
    var byte Count;

    structdefaultproperties
    {
        FirstPersonPowerUpAmbientSound=none
        ThirdPersonPowerUpAmbientSound=none
        FirstPersonStopPowerUpAmbientSound=none
        ThirdPersonStopPowerUpAmbientSound=none
        Count=0
    }
};

struct native ExtraVFXInfo
{
    /**  
     *@name  ExtraVFX
     *// Particle effect to play
     */
    var() ParticleSystem VFX;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)

     */
    var() name SocketName;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)

     */
    var() name Label;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)
// Audio event to play when vfx start

     */
    var() AkEvent SFXStartEvent;
    /**  
     *@name  ExtraVFX
     *// Particle effect to play// Socket to attach it to (if applicable)
// Label to use for code logic (if applicable)
// Audio event to play when vfx start
// Audio event to play when vfx stop

     */
    var() AkEvent SFXStopEvent;

    structdefaultproperties
    {
        VFX=none
        SocketName=None
        Label=None
        SFXStartEvent=none
        SFXStopEvent=none
    }
};

struct native ExtraVFXAttachmentInfo
{
    var export editinline ParticleSystemComponent VFXComponent;
    var ExtraVFXInfo Info;

    structdefaultproperties
    {
        VFXComponent=none
        Info=(VFX=none,SocketName=None,Label=None,SFXStartEvent=none,SFXStopEvent=none)
    }
};

var KFCharacterInfoBase CharacterArch;
var KFPawnSoundGroup SoundGroupArch;
var class<KFPawnVoiceGroup> VoiceGroupArch;
var KFPawnAnimInfo PawnAnimInfo;
var name LocalizationKey;
var Texture2D CharacterPortrait;
var transient LightingChannelContainer PawnLightingChannel;
var export editinline SkeletalMeshComponent ThirdPersonHeadMeshComponent;
var name ThirdPersonAttachmentSocketNames[3];
var export editinline MeshComponent ThirdPersonAttachments[3];
var name FirstPersonAttachmentSocketNames[3];
var export editinline MeshComponent FirstPersonAttachments[3];
var array<MaterialInstanceConstant> CharacterMICs;
var globalconfig bool bAllowAlwaysOnPhysics;
var const bool bIsGoreMesh;
var transient bool bTakingRadiusDamage;
var bool bNeedsProcessHitFx;
var bool bHasBrokenConstraints;
var globalconfig bool bAllowRagdollAndGoreOnDeadBodies;
var bool bReinitPhysAssetOnDeath;
var bool bAllowDeathSM;
var bool bCanBePinned;
var repnotify bool bEmpDisrupted;
var repnotify bool bEmpPanicked;
var repnotify bool bFirePanicked;
/** If Pawn can or cannot play physics hit reactions. */
var(Physics) bool bCanPlayPhysicsHitReactions;
var bool bIsSprinting;
var bool bAllowSprinting;
var bool bIgnoreTeamCollision;
var bool bUnaffectedByZedTime;
var bool bMovesFastInZedTime;
var bool bJumping;
var const bool bWeaponBob;
var bool bUpdateEyeheight;
var bool bJustLanded;
var bool bLandRecovery;
var bool bWeaponAttachmentVisible;
var bool bNeedsCrosshair;
var bool bEnableAimOffset;
/** If set, turns off KFAnim_TurnInPlace (and related) nodes */
var(animation) bool bDisableTurnInPlace;
var bool bCanHeadTrack;
var bool bIsHeadTrackingActive;
/** If this pawn does zed grabs, they are weak zed grabs */
var(Grab) bool bWeakZedGrab;
var const bool bDoFloorConformBlend;
var const bool bUseQuadrupedFloorConform;
/** if TRUE, disable mesh offset steps smoothing */
var() protected bool bDisableMeshSmoothing;
/** if TRUE, disable mesh replicated rotation smoothing */
var() protected bool bDisableMeshRotationSmoothing;
var globalconfig bool bAllowFootstepSounds;
var const bool bUseHiddenSpeed;
var bool bCanUseHiddenSpeed;
var bool bAllowAccelSmoothing;
var bool bAIZedsIgnoreMe;
var bool bCanCloak;
var repnotify bool bIsCloaking;
var bool bLogTakeDamage;
var bool bLogPhysicsBodyImpact;
var bool bLogSpecialMove;
var bool bLogCustomAnim;
var repnotify bool bHasStartedFire;
var transient float LastHeadShotReceivedTime;
var() array<HitZoneInfo> HitZones;
var transient float TimeOfDeath;
/**  
 *How much resistance this pawn has to penetration. Whenever a projectile or
 * weapon traces passes through this pawn and damages it, that projectile
 * or weapon trace's PenetrationPower will be reduced by this amount.
 * Additionally a weapon trace or projectile won't penetrate this pawn if the
 * PenetrationPower is not greater than this resistance.
 */
var() float PenetrationResistance;
var array<DamageOverTimeInfo> DamageOverTimeArray;
var array<ExplosiveStackInfo> RecentExplosiveStacks;
var transient float LastTimeDamageHappened;
var float CrushScale;
var float VolumeDamageScale;
var array<DamageInfo> DamageHistory;
var repnotify KFHitFxInfo HitFxInfo;
var KFRadialHitFxInfo HitFxRadialInfo;
var Pawn HitFxInstigator;
var Vector HitFxAddedRelativeLocs[7];
var byte HitFxAddedHitCount;
var byte LastRadiusDamageScale;
var byte DeathFireStackedPower;
var repnotify byte RepFireBurnedAmount;
var const byte RagdollWarningLevel;
var KFPawn.ESpecialMove SpecialMove;
var byte SpecialMoveFlags;
var transient byte CurrDialogPriority;
var float LastTakeHitTimeout;
var Vector LastRadiusHurtOrigin;
var array<MaterialInstance> BloodSplatterDecalMaterials;
var array<MaterialInstance> BloodPoolDecalMaterials;
var const name BattleBloodParamName;
var const float MinBattleBloodValue;
var const float BattleBloodRangeSq;
var transient float BattleBloodParamValue;
var name LeftFootBoneName;
var name RightFootBoneName;
var name LeftHandBoneName;
var name RightHandBoneName;
var name HeadBoneName;
var name TorsoBoneName;
var name PelvisBoneName;
var transient float LastGibCollisionTime;
var float IntendedBodyScale;
var float CurrentBodyScale;
var float BodyScaleChangePerSecond;
var repnotify float IntendedHeadScale;
var float CurrentHeadScale;
var export editinline KFAfflictionManager AfflictionHandler;
var array<IncapSettingsInfo> IncapSettings;
var repnotify int InjuredHitZones;
var float LastImpactParticleEffectTime;
var float LastImpactSoundTime;
var KnockdownImpulseInfo KnockdownImpulse;
var ReplicatedRootPosInfo ReplicatedRootBodyPos;
/** Scale impulses by this amount for Physics Hit Reactions. */
var(Physics) float PhysicsHitReactionImpulseScale;
/** List of RB bone names which should be UnFixed when playing a Physics Body Impact. */
var(Physics) editinline array<editinline name> PhysicsBodyImpactBoneList;
/** List of RidigBodies where a spring should be attached to animation. */
var(Physics) editinline array<editinline name> PhysicsImpactSpringList;
/** Time it takes to blend back to animations after being turned into physics. */
var(Physics) float PhysicsImpactBlendOutTime;
var float PhysicsImpactBlendTimeToGo;
/** Artifically scale impulses, to counter mass, for ragdoll hit reactions. */
var(Physics) float PhysRagdollImpulseScale;
/** As above, but applied to living (aka knockdown) impulse */
var(Physics) float KnockdownImpulseScale;
var const float NextRagdollFailsafeTime;
var const Vector LastRootRigidBodyTestLoc;
var float SprintSpeed;
var float SprintStrafeSpeed;
var repnotify Vector ReplicatedFloor;
var float TeammateCollisionRadiusPercent;
var protected float ZedTimeSpeedScale;
var float AfflictionSpeedModifier;
var float AttackSpeedModifier;
var int NumJumpsAllowed;
var int NumJumpsRemaining;
/** Base crouched eye height from bottom of the collision cylinder. */
var(Camera) float BaseCrouchEyeHeight;
var const float Bob<ClampMin=-0.05|ClampMax=0.05>;
var float OldZ;
var float LandBob;
var float JumpBob;
var float AppliedBob;
var float BobTime;
var Vector WalkBob;
var() array< class<Inventory> > DefaultInventory;
var() array<Inventory> DefaultInventoryArchetypes;
var KFWeaponAttachment WeaponAttachmentTemplate;
var repnotify class<KFWeapon> WeaponClassForAttachmentTemplate;
var KFWeaponAttachment WeaponAttachment;
var export editinline KFSkeletalMeshComponent ArmsMesh;
var name WeaponAttachmentSocket;
var KFWeapon MyKFWeapon;
var transient float LastWeaponFireTime;
var transient array<AnimNodeAimOffset> AimOffsetNodes;
var() transient array<AnimNodeSlot> BodyStanceNodes;
/** List of RB bone names which should be UnFixed when playing a Physics Body Impact. */
var(animation) editinline array<editinline name> ArmPhysicsBoneList;
/**  
 *2d vector, representing a rotation offset percentage from actor's rotation. Used by Aim anim nodes.
 * Range used (-1,-1) to (+1,+1) (angle equivalent : (-90d,-90d) to (+90d,+90d))
 */
var() Vector2D AimOffsetPct;
var Rotator ReplicatedAimOffsetPct;
var float TurnInPlaceAnimRate;
var float NextHitReactionAnim_ActorTime;
var const transient float LastMeleeNotify_ActorTime;
var transient array<GameSkelCtrl_Recoil> RecoilNodes;
var transient SkelControlLookAt IK_Look_Head;
var transient SkelControlLookAt IK_Look_Spine;
var transient SkelControlSingleBone HeadScaleControl;
var transient LookAtInfo MyLookAtInfo;
var transient KFSkelControl_FootPlacement IKFootLeft;
var transient KFSkelControl_FootPlacement IKFootRight;
var KFPawn InteractionPawn;
/** Array of instanced special moves */
var(SpecialMoves) editconst editinline transient array<editconst editinline KFSpecialMove> SpecialMoves;
var repnotify repretry KFSpecialMoveStruct ReplicatedSpecialMove;
/** Helper object (within pawn) that implements special moves */
var(SpecialMoves) export editinline KFSpecialMoveHandler SpecialMoveHandler;
/** If this is greater than zero, we can't be grabbed by clots or other weak zeds until this time is hit */
var(Grab) float WeakZedGrabCooldown;
var float BaseTranslationOffset;
var const Vector MTO_PhysSmoothOffset;
var Vector MTO_SpecialMoveOffset;
var Vector MTO_SpecialMoveInterp;
var float MTO_SpecialMoveSpeed;
var const Vector MTO_IKFloorConform;
var const Vector MeshFloorConformNormal;
var const Rotator FloorConformLastPawnRotation;
var const int FloorConformMeshRotationYaw;
var const float LastPhysSmoothDeltaZ;
var const transient float MeshYawOffset;
var float MeshRotSmoothingInterpSpeed;
var repnotify AkEvent AmbientSound;
var protected export editinline AkComponent AmbientAkComponent;
var repnotify AkEvent WeaponAmbientSound;
var protected export editinline AkComponent WeaponAkComponent;
var export editinline KFWeaponAmbientEchoHandler WeaponAmbientEchoHandler;
var repnotify AkEvent SecondaryWeaponAmbientSound;
var protected export editinline AkComponent SecondaryWeaponAkComponent;
var protected export editinline AkComponent FootstepAkComponent;
var protected export editinline AkComponent DialogAkComponent;
var repnotify PowerUpAmbientSoundInfo PowerUpAmbientSound;
var protected export editinline AkComponent PowerUpAkComponent;
var float LastReplicateTime;
var KFAIController MyKFAIC;
var const float ExtraCostForPath;
var float MaxTurningRadius;
var transient float CurrentTurningRadius;
var float AccelConvergeFalloffDistance;
var transient Vector OldAcceleration;
var float DamageRecoveryTimeHeavy;
var float DamageRecoveryTimeMedium;
var float HiddenGroundSpeed;
var Controller ExclusiveTargetingController;
var float AIIgnoreEndTime;
var transient int CurrDialogEventID;
var transient array<ExtraVFXAttachmentInfo> ExtraVFXAttachments;
var Texture2D DebugRadarTexture;

replication
{
     if(bNetDirty)
        AmbientSound, AttackSpeedModifier, 
        InjuredHitZones, IntendedBodyScale, 
        IntendedHeadScale, KnockdownImpulse, 
        PowerUpAmbientSound, RepFireBurnedAmount, 
        ReplicatedSpecialMove, WeaponClassForAttachmentTemplate, 
        bEmpDisrupted, bEmpPanicked, 
        bFirePanicked, bHasStartedFire, 
        bIsSprinting, bMovesFastInZedTime, 
        bUnaffectedByZedTime;

     if(bNetDirty && WorldInfo.TimeSeconds < LastTakeHitTimeout)
        HitFxAddedHitCount, HitFxAddedRelativeLocs, 
        HitFxInfo, HitFxInstigator, 
        HitFxRadialInfo;

     if((Physics == 10) && !bTearOff)
        ReplicatedRootBodyPos;

     if(Physics == 8)
        ReplicatedFloor;

     if(bNetDirty && bTearOff)
        DeathFireStackedPower;

     if(bNetDirty && bNetOwner)
        AfflictionSpeedModifier, NumJumpsAllowed, 
        SprintSpeed, bAllowSprinting, 
        bJumping;

     if((bNetDirty && bNetOwner) && bNetInitial)
        bIgnoreTeamCollision;

     if(bNetDirty && !bNetOwner || bDemoRecording)
        SecondaryWeaponAmbientSound, WeaponAmbientSound;

     if(bEnableAimOffset && !bNetOwner || bDemoRecording)
        ReplicatedAimOffsetPct;

     if(bNetDirty && bCanCloak)
        bIsCloaking;
}

// Export UKFPawn::execFitCollision(FFrame&, void* const)
native final simulated function bool FitCollision();

reliable client simulated function ForceOpenActorChannel();

// Export UKFPawn::execGetCharacterInfo(FFrame&, void* const)
native simulated function KFCharacterInfoBase GetCharacterInfo();

// Export UKFPawn::execGetPerk(FFrame&, void* const)
native simulated function KFPerk GetPerk();

// Export UKFPawn::execAllowFirstPersonPreshadows(FFrame&, void* const)
native function bool AllowFirstPersonPreshadows();

// Export UKFPawn::execClearBloodDecals(FFrame&, void* const)
native function ClearBloodDecals();

// Export UKFPawn::execForceUnCrouch(FFrame&, void* const)
native function ForceUnCrouch();

simulated event PreBeginPlay()
{
    local MapInfo MapInfo;

    BaseTranslationOffset = Mesh.default.Translation.Z;
    if(LightingVolumeEnterCount == 0)
    {
        MapInfo = WorldInfo.GetMapInfo();
        if((MapInfo != none) && MapInfo.bDefaultPawnsToOutdoor)
        {
            PawnLightingChannel.Indoor = false;
            PawnLightingChannel.Outdoor = true;
            PawnLightingChannel.bInitialized = true;            
        }
        else
        {
            PawnLightingChannel.Indoor = true;
            PawnLightingChannel.Outdoor = false;
            PawnLightingChannel.bInitialized = true;
        }
        SetMeshLightingChannels(PawnLightingChannel);
    }
    InitRBSettings();
    super(Pawn).PreBeginPlay();
}

event PostBeginPlay()
{
    super(Pawn).PostBeginPlay();
    SoundGroupArch.PlayEntranceSound(self);
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        Mesh.bPauseAnims = true;
    }
}

event PostAddPawn()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.UpdateAIRemaining();
    }
}

function Reset()
{
    DetachFromController(true);
    Destroy();
    super(Actor).Reset();
}

simulated event Destroyed()
{
    if((SpecialMove != 0) && SpecialMoves[SpecialMove] != none)
    {
        EndSpecialMove();
    }
    TerminateEffectsOnDeath();
    super(Pawn).Destroyed();
}

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'WeaponClassForAttachmentTemplate':
            SetWeaponAttachmentFromWeaponClass(WeaponClassForAttachmentTemplate);
            break;
        case 'AmbientSound':
            SetPawnAmbientSound(AmbientSound);
            break;
        case 'WeaponAmbientSound':
            SetWeaponAmbientSound(WeaponAmbientSound);
            break;
        case 'PowerUpAmbientSound':
            SetReplicatedPowerUpAmbientSound(PowerUpAmbientSound);
            break;
        case 'SecondaryWeaponAmbientSound':
            SetSecondaryWeaponAmbientSound(SecondaryWeaponAmbientSound);
            break;
        case 'HitFxInfo':
            bNeedsProcessHitFx = true;
            break;
        case 'InjuredHitZones':
            HitZoneInjured();
            break;
        case 'ReplicatedSpecialMove':
            if(bLogSpecialMove)
            {
                LogInternal("Received replicated special move:" @ string(ReplicatedSpecialMove.SpecialMove));
            }
            DoSpecialMove(ReplicatedSpecialMove.SpecialMove, true, ReplicatedSpecialMove.InteractionPawn, ReplicatedSpecialMove.Flags);
            break;
        case 'ReplicatedFloor':
            Floor = ReplicatedFloor;
            break;
        case 'bEmpDisrupted':
            AfflictionHandler.ToggleEffects(0, bEmpDisrupted, bEmpPanicked);
            break;
        case 'bEmpPanicked':
            AfflictionHandler.ToggleEffects(0, bEmpDisrupted, bEmpPanicked);
            break;
        case 'bFirePanicked':
            AfflictionHandler.ToggleEffects(1, bFirePanicked);
            break;
        case 'RepFireBurnedAmount':
            AfflictionHandler.UpdateMaterialParameter(1, ByteToFloat(RepFireBurnedAmount));
            break;
        case 'IntendedHeadScale':
            SetHeadScale(IntendedHeadScale, CurrentHeadScale);
            break;
        case 'bHasStartedFire':
            if(bHasStartedFire)
            {
                OnStartFire();
            }
            break;
        default:
            break;
    }
    super(Pawn).ReplicatedEvent(VarName);
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super.PossessedBy(C, bVehicleTransition);
    NotifyTeamChanged();
}

function UnPossessed()
{
    super.UnPossessed();
    bUnaffectedByZedTime = false;
}

simulated event bool IsSameTeam(Pawn Other)
{
    if((Other != none) && Other.GetTeamNum() == GetTeamNum())
    {
        return true;
    }
    return super(Pawn).IsSameTeam(Other);
}

simulated function InitRBSettings()
{
    if((Mesh != none) && Mesh.PhysicsAssetInstance != none)
    {
        if(Physics != 10)
        {
            Mesh.PhysicsAssetInstance.SetAllBodiesFixed(true);
            Mesh.PhysicsAssetInstance.SetFullAnimWeightBonesFixed(false, Mesh);
        }
    }
    if(!Mesh.bUpdateKinematicBonesFromAnimation)
    {
        Mesh.SetRBChannel(1);
        Mesh.SetRBCollidesWithChannel(2, false);
    }
    UpdateMeshForFleXCollision();
}

simulated function OnCharacterMeshChanged();

simulated function SetCharacterArchAnimationInfo()
{
    SetCharacterAnimationInfo();
}

simulated function SetCharacterArch(KFCharacterInfoBase Info, optional bool bForce)
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if((Info != CharacterArch) || bForce)
    {
        CharacterArch = Info;
        CharacterArch.SetCharacterFromArch(self, KFPRI);
        CharacterArch.SetCharacterMeshFromArch(self, KFPRI);
        SetCharacterArchAnimationInfo();
        SoundGroupArch = Info.SoundGroupArch;
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(WeaponAttachmentTemplate != none)
            {
                WeaponAttachmentChanged(true);
            }
        }
        if((HeadBoneName != 'None') && Mesh.MatchRefBone(HeadBoneName) == -1)
        {
            WarnInternal("CharacterInfo HeadBone is invalid for" @ string(self));
        }
        if((LeftFootBoneName != 'None') && Mesh.MatchRefBone(LeftFootBoneName) == -1)
        {
            WarnInternal("CharacterInfo LeftFootBone is invalid for" @ string(self));
        }
        if((RightFootBoneName != 'None') && Mesh.MatchRefBone(RightFootBoneName) == -1)
        {
            WarnInternal("CharacterInfo RightFootBone is invalid for" @ string(self));
        }
        if((TorsoBoneName != 'None') && Mesh.MatchRefBone(TorsoBoneName) == -1)
        {
            WarnInternal("CharacterInfo TorsoBone is invalid for" @ string(self));
        }
    }
    if(CharacterArch != none)
    {
        if(CharacterArch.VoiceGroupArchName != "")
        {
            VoiceGroupArch = class<KFPawnVoiceGroup>(DynamicLoadObject(CharacterArch.VoiceGroupArchName, Class'Class'));
        }
    }
}

simulated function ProcessViewRotation(float DeltaTime, out Rotator out_ViewRotation, out Rotator out_DeltaRot)
{
    super(Pawn).ProcessViewRotation(DeltaTime, out_ViewRotation, out_DeltaRot);
    if((SpecialMove != 0) && SpecialMoves[SpecialMove] != none)
    {
        SpecialMoves[SpecialMove].ProcessViewRotation(DeltaTime, out_ViewRotation, out_DeltaRot);
    }
}

simulated function SetCharacterAnimationInfo()
{
    if(CharacterArch.PhysAsset != Mesh.PhysicsAsset)
    {
        Mesh.bEnableFullAnimWeightBodies = false;
        Mesh.SetPhysicsAsset(CharacterArch.PhysAsset);
        if(Physics != 10)
        {
            Mesh.PhysicsAssetInstance.SetAllBodiesFixed(true);
            if(bAllowAlwaysOnPhysics)
            {
                Mesh.PhysicsAssetInstance.SetFullAnimWeightBonesFixed(false, Mesh);
            }
        }
    }
    CharacterArch.SetCharacterAnimFromArch(self);
    if(CharacterArch.AnimArchetype != none)
    {
        PawnAnimInfo = CharacterArch.AnimArchetype;
    }
}

simulated function UpdateGameplayMICParams()
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        AfflictionHandler.ToggleEffects(0, bEmpDisrupted, bEmpPanicked);
        AfflictionHandler.UpdateMaterialParameter(1, ByteToFloat(RepFireBurnedAmount));
    }
}

simulated event bool UsePlayerControlledZedSkin();

simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
{
    return false;
}

event BaseChange()
{
    super(Pawn).BaseChange();
    if(KFDoorActor(Base) != none)
    {
        Velocity = KFDoorActor(Base).GetPushDirection(Location);
        SetPhysics(2);
    }
}

simulated function SetBaseEyeheight()
{
    if(!bIsCrouched)
    {
        BaseEyeHeight = default.BaseEyeHeight * CurrentBodyScale;        
    }
    else
    {
        BaseEyeHeight = default.BaseCrouchEyeHeight * CurrentBodyScale;
    }
}

event UpdateEyeHeight(float DeltaTime)
{
    local float MaxEyeHeight;
    local Actor HitActor;
    local Vector HitLocation, HitNormal;

    if(bTearOff)
    {
        EyeHeight = BaseEyeHeight;
        bUpdateEyeheight = false;
        return;
    }
    if(Abs(Location.Z - OldZ) > float(15))
    {
        bJustLanded = false;
        bLandRecovery = false;
    }
    SmoothEyeHeight(DeltaTime);
    UpdateWalkBob(DeltaTime);
    if(((CylinderComponent.CollisionHeight - EyeHeight) < float(12)) && IsFirstPerson())
    {
        if(bCollideWorld)
        {
            HitActor = Trace(HitLocation, HitNormal, (Location + WalkBob) + ((MaxStepHeight + CylinderComponent.CollisionHeight) * vect(0, 0, 1)), Location + WalkBob, true, vect(12, 12, 12),, 8);
            MaxEyeHeight = ((HitActor == none) ? CylinderComponent.CollisionHeight + MaxStepHeight : HitLocation.Z - Location.Z);
            EyeHeight = FMin(EyeHeight, MaxEyeHeight);
        }
    }
}

private final function SmoothEyeHeight(float DeltaTime)
{
    local float smooth, OldEyeHeight;

    if(!bJustLanded)
    {
        smooth = FMin(0.9, (10 * DeltaTime) / CustomTimeDilation);
        LandBob *= (float(1) - smooth);
        if(((Physics == 1) || Physics == 8) || Controller.IsInState('PlayerSwimming'))
        {
            OldEyeHeight = EyeHeight;
            EyeHeight = FMax((((EyeHeight - Location.Z) + OldZ) * (float(1) - smooth)) + (BaseEyeHeight * smooth), -0.5 * CylinderComponent.CollisionHeight);            
        }
        else
        {
            EyeHeight = (EyeHeight * (float(1) - smooth)) + (BaseEyeHeight * smooth);
        }        
    }
    else
    {
        if(bLandRecovery)
        {
            smooth = FMin(0.9, 9 * DeltaTime);
            OldEyeHeight = EyeHeight;
            LandBob *= (float(1) - smooth);
            if(EyeHeight > (0.9 * BaseEyeHeight))
            {
                EyeHeight = EyeHeight + ((0.15 * BaseEyeHeight) * smooth);                
            }
            else
            {
                EyeHeight = (EyeHeight * (float(1) - (0.6 * smooth))) + ((BaseEyeHeight * 0.6) * smooth);
            }
            if(EyeHeight >= BaseEyeHeight)
            {
                bJustLanded = false;
                bLandRecovery = false;
                EyeHeight = BaseEyeHeight;
            }            
        }
        else
        {
            smooth = FMin(0.65, 8 * DeltaTime);
            OldEyeHeight = EyeHeight;
            EyeHeight = EyeHeight * (float(1) - (1.5 * smooth));
            LandBob += (0.08 * (OldEyeHeight - EyeHeight));
            if((EyeHeight < ((0.25 * BaseEyeHeight) + float(1))) || LandBob > 2.4)
            {
                bLandRecovery = true;
                EyeHeight = (0.25 * BaseEyeHeight) + float(1);
            }
        }
    }
    OldZ = Location.Z;
}

private final function UpdateWalkBob(float DeltaTime)
{
    local float Speed2D;
    local Vector X, Y, Z;

    if(bJustLanded || !bUpdateEyeheight)
    {
        BobTime = 0;
        WalkBob = vect(0, 0, 0);        
    }
    else
    {
        if(Velocity.Z > 0)
        {
            JumpBob = FMax(-1.5, JumpBob - ((0.03 * DeltaTime) * FMin(Velocity.Z, 300)));            
        }
        else
        {
            JumpBob *= (1 - FMin(1, 8 * DeltaTime));
        }
        if(Physics == 1)
        {
            GetAxes(Rotation, X, Y, Z);
            Speed2D = VSize2D(Velocity);
            if(Speed2D < 10)
            {
                BobTime += (0.2 * DeltaTime);                
            }
            else
            {
                BobTime += (DeltaTime * (0.3 + ((0.7 * Speed2D) / GroundSpeed)));
            }
            WalkBob = ((Y * Bob) * Speed2D) * Sin(8 * BobTime);
            AppliedBob = AppliedBob * (1 - FMin(1, 16 * DeltaTime));
            WalkBob.Z = AppliedBob;
            if(Speed2D > 10)
            {
                WalkBob.Z = WalkBob.Z + (((0.75 * Bob) * Speed2D) * Sin(16 * BobTime));
            }            
        }
        else
        {
            if(Physics == 3)
            {
                GetAxes(Rotation, X, Y, Z);
                BobTime += DeltaTime;
                Speed2D = VSize2D(Velocity);
                WalkBob = (((Y * Bob) * 0.5) * Speed2D) * Sin(4 * BobTime);
                WalkBob.Z = ((Bob * 1.5) * Speed2D) * Sin(8 * BobTime);                
            }
            else
            {
                BobTime = 0;
                WalkBob = WalkBob * (1 - FMin(1, 8 * DeltaTime));
            }
        }
    }
}

simulated function Vector GetPawnViewLocation()
{
    local PlayerController MyPC;

    if(Controller != none)
    {
        if(bUpdateEyeheight)
        {
            return (Location + (EyeHeight * vect(0, 0, 1))) + WalkBob;
        }
        return Location + (BaseEyeHeight * vect(0, 0, 1));        
    }
    else
    {
        if((((Role < ROLE_Authority) && Mesh != none) && Mesh.SkeletalMesh != none) && Mesh.bAnimTreeInitialised)
        {
            MyPC = WorldInfo.GetALocalPlayerController();
            if(MyPC != none)
            {
                return Mesh.GetPosition() + ((CylinderComponent.CollisionHeight + MyPC.TargetEyeHeight) * vect(0, 0, 1));
            }
            return Mesh.GetPosition() + ((CylinderComponent.CollisionHeight + BaseEyeHeight) * vect(0, 0, 1));
        }
        return Location + (BaseEyeHeight * vect(0, 0, 1));
    }
}

simulated function float GetEyeHeight()
{
    if(bUpdateEyeheight)
    {
        return EyeHeight;        
    }
    else
    {
        return BaseEyeHeight;
    }
}

simulated event BecomeViewTarget(PlayerController PC)
{
    super(Pawn).BecomeViewTarget(PC);
    if(LocalPlayer(PC.Player) != none)
    {
        if(AllowFirstPersonPreshadows())
        {
            ArmsMesh.bAllowPerObjectShadows = true;            
        }
        else
        {
            ArmsMesh.bAllowPerObjectShadows = false;
        }
        SetMeshVisibility(!PC.UsingFirstPersonCamera());
        bUpdateEyeheight = true;
    }
}

simulated event EndViewTarget(PlayerController PC)
{
    if(LocalPlayer(PC.Player) != none)
    {
        SetMeshVisibility(true);
    }
}

simulated event EndCrouch(float HeightAdjust)
{
    super(Pawn).EndCrouch(HeightAdjust);
    OldZ += HeightAdjust;
    if(Mesh != none)
    {
        BaseTranslationOffset -= HeightAdjust;
        Mesh.SetTranslation(Mesh.Translation - (vect(0, 0, 1) * HeightAdjust));
    }
}

simulated event StartCrouch(float HeightAdjust)
{
    HeightAdjust = default.CylinderComponent.CollisionHeight - CrouchHeight;
    super(Pawn).StartCrouch(HeightAdjust);
    OldZ -= HeightAdjust;
    if(Mesh != none)
    {
        BaseTranslationOffset += HeightAdjust;
        Mesh.SetTranslation(Mesh.Translation + (vect(0, 0, 1) * HeightAdjust));
    }
}

// Export UKFPawn::execSetWeaponAttachmentVisibility(FFrame&, void* const)
native function SetWeaponAttachmentVisibility(bool bAttachmentVisible);

// Export UKFPawn::execIsDoingMeleeAttack(FFrame&, void* const)
native function bool IsDoingMeleeAttack();

simulated function MeleeImpactNotify(KFAnimNotify_MeleeImpact Notify);

simulated function WeaponStateChanged(byte NewState, optional bool bViaReplication);

function UpdateGroundSpeed();

function SetAfflictionSpeedModifier()
{
    AfflictionSpeedModifier = AfflictionHandler.GetAfflictionSpeedModifier();
}

function SetAttackSpeedModifier()
{
    AttackSpeedModifier = AfflictionHandler.GetAfflictionAttackSpeedModifier();
}

simulated function ToggleEquipment();

function NotifyInventoryWeightChanged()
{
    UpdateGroundSpeed();
}

simulated function PlayWeaponSwitch(Weapon OldWeapon, Weapon NewWeapon)
{
    MyKFWeapon = KFWeapon(Weapon);
}

function AddDefaultInventory()
{
    local KFInventoryManager KFIM;
    local class<Inventory> InvClass;
    local Inventory Inv;

    foreach DefaultInventory(InvClass,)
    {
        Inv = FindInventoryType(InvClass);
        if(Inv == none)
        {
            Inv = CreateInventory(InvClass, Weapon != none);
            if(KFWeapon(Inv) != none)
            {
                KFWeapon(Inv).bGivenAtStart = true;
            }
        }        
    }    
    KFIM = KFInventoryManager(InvManager);
    foreach DefaultInventoryArchetypes(Inv,)
    {
        KFIM.CreateInventoryArchetype(Inv, Weapon != none);        
    }    
    if(Role == ROLE_Authority)
    {
        KFIM.ShowAllHUDGroups();
    }
}

simulated function SetFirstPersonVisibility(bool bWeaponVisible)
{
    local int AttachmentIdx;

    if((MyKFWeapon != none) && MyKFWeapon.Instigator == self)
    {
        MyKFWeapon.ChangeVisibility(bWeaponVisible);        
    }
    else
    {
        if(ArmsMesh != none)
        {
            ArmsMesh.SetHidden(!bWeaponVisible);
            AttachmentIdx = 0;
            J0xA6:

            if(AttachmentIdx < 3)
            {
                if(FirstPersonAttachments[AttachmentIdx] != none)
                {
                    FirstPersonAttachments[AttachmentIdx].SetHidden(!bWeaponVisible);
                }
                ++ AttachmentIdx;
                goto J0xA6;
            }
        }
    }
}

simulated function WeaponAttachmentChanged(optional bool bForceReattach)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(WeaponAttachment != none)
    {
        if((WeaponAttachment.ObjectArchetype != WeaponAttachmentTemplate) || bForceReattach)
        {
            WeaponAttachment.DetachFrom(self);
            WeaponAttachment.Destroy();
            WeaponAttachment = none;
        }
    }
    if(WeaponAttachment == none)
    {
        if((Mesh.SkeletalMesh != none) && WeaponAttachmentTemplate != none)
        {
            WeaponAttachment = Spawn(WeaponAttachmentTemplate.Class, self,,,, WeaponAttachmentTemplate);
            if(WeaponAttachment != none)
            {
                WeaponAttachment.Instigator = self;
                WeaponAttachment.AttachTo(self);
                WeaponAttachment.ChangeVisibility(bWeaponAttachmentVisible);
                WeaponAttachment.SetMeshLightingChannels(PawnLightingChannel);
            }
        }
    }
}

simulated function SetWeaponAttachmentFromWeaponClass(class<KFWeapon> WeaponClass)
{
    if(WeaponClass == none)
    {
        WeaponAttachmentTemplate = none;
        WeaponAttachmentChanged();        
    }
    else
    {
        if(WeaponClass.default.AttachmentArchetype == none)
        {
            WeaponClass.static.TriggerAsyncContentLoad(WeaponClass);            
        }
        else
        {
            WeaponAttachmentTemplate = WeaponClass.default.AttachmentArchetype;
            WeaponAttachmentChanged();
        }
    }
}

simulated function OnStartFire()
{
    if(Role == ROLE_Authority)
    {
        bHasStartedFire = true;
        bNetDirty = true;
    }
    if(WeaponAttachment != none)
    {
        WeaponAttachment.StartFire();
    }
}

simulated function WeaponFired(Weapon InWeapon, bool bViaReplication, optional Vector HitLocation)
{
    local KFWeapon KFW;
    local class<KFProjectile> KFProj;
    local KFImpactEffectInfo ImpactFX;
    local Vector HitNormal;

    HitNormal = Normal(Location - HitLocation);
    if((Role == ROLE_AutonomousProxy) && bViaReplication)
    {
        return;
    }
    LastWeaponFireTime = WorldInfo.TimeSeconds;
    if(IsFirstPerson())
    {
        if(WeaponAttachment != none)
        {
            WeaponAttachment.FirstPersonFireEffects(Weapon, HitLocation);
        }        
    }
    else
    {
        if(WeaponAttachment != none)
        {
            WeaponAttachment.ThirdPersonFireEffects(HitLocation, self, GetWeaponAttachmentAnimRateByte());
        }
    }
    if((HitLocation != vect(0, 0, 0)) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(WorldInfo.MyImpactEffectManager != none)
        {
            KFW = KFWeapon(InWeapon);
            if(KFW != none)
            {
                KFProj = KFW.GetKFProjectileClass();                
            }
            else
            {
                KFProj = WeaponClassForAttachmentTemplate.static.GetKFProjectileClassByFiringMode(FiringMode, GetPerk());
            }
            if(KFProj != none)
            {
                ImpactFX = KFProj.default.ImpactEffects;
                KFProj.static.PlayAddedImpactEffect(HitLocation, HitNormal);
            }
            KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, self,, ImpactFX);
        }
    }
    if(((Role == ROLE_Authority) && bUnaffectedByZedTime) && WorldInfo.TimeDilation < 1)
    {
        StopPartialZedTime();
    }
}

simulated function WeaponStoppedFiring(Weapon InWeapon, bool bViaReplication)
{
    if(WeaponAttachment != none)
    {
        WeaponAttachment.StopThirdPersonFireEffects();
        WeaponAttachment.StopFirstPersonFireEffects(Weapon);
    }
}

simulated function byte GetWeaponAttachmentAnimRateByte()
{
    return 0;
}

simulated function Vector WeaponBob(float BobDamping, float JumpDamping)
{
    local Vector V;
    local KFPerk OwnerPerk;

    OwnerPerk = GetPerk();
    if(((OwnerPerk != none) && MyKFWeapon != none) && MyKFWeapon.bUsingSights)
    {
        OwnerPerk.ModifyWeaponBopDamping(BobDamping, MyKFWeapon);
    }
    V = BobDamping * WalkBob;
    V.Z = (0.45 + (0.55 * BobDamping)) * WalkBob.Z;
    if(!bWeaponBob)
    {
        V = WalkBob;
    }
    V.Z += (JumpDamping * (LandBob - JumpBob));
    return V;
}

final simulated function bool CanReloadWeapon()
{
    if(Physics == 10)
    {
        return false;
    }
    return true;
}

function KFWeapon FindBestWeapon()
{
    local float BestPrimaryRating, BestSecondaryRating, BestMeleeRating;
    local KFWeapon BestWeapon, BestPrimary, BestSecondary, BestMelee, TempWeapon;

    foreach InvManager.InventoryActors(Class'KFWeapon', TempWeapon)
    {
        if(!TempWeapon.bDropOnDeath || !TempWeapon.CanThrow())
        {
            continue;            
        }
        if(TempWeapon.InventoryGroup == 0)
        {
            if((BestPrimaryRating == 0) || TempWeapon.GroupPriority > BestPrimaryRating)
            {
                BestPrimary = TempWeapon;
                BestPrimaryRating = TempWeapon.GroupPriority;
            }
            continue;
        }
        if(TempWeapon.InventoryGroup == 1)
        {
            if((BestSecondaryRating == 0) || TempWeapon.GroupPriority > BestSecondaryRating)
            {
                BestSecondary = TempWeapon;
                BestSecondaryRating = TempWeapon.GroupPriority;
            }
            continue;
        }
        if(TempWeapon.InventoryGroup == 2)
        {
            if((BestMeleeRating == 0) || TempWeapon.GroupPriority > BestMeleeRating)
            {
                BestMelee = TempWeapon;
                BestMeleeRating = TempWeapon.GroupPriority;
            }
        }        
    }    
    BestWeapon = ((BestPrimary != none) ? BestPrimary : ((BestSecondary != none) ? BestSecondary : BestMelee));
    return BestWeapon;
}

function ThrowActiveWeapon(optional bool bDestroyWeap)
{
    local Inventory WeaponToThrow;
    local bool bIsHoldingCarryable;

    if(Role < ROLE_Authority)
    {
        return;
    }
    bIsHoldingCarryable = KFCarryableObject(Weapon) != none;
    if(((InvManager != none) && Health <= 0) && ((Weapon == none) || !Weapon.bDropOnDeath) || !Weapon.CanThrow())
    {
        WeaponToThrow = FindBestWeapon();        
    }
    else
    {
        if((Health <= 0) && bIsHoldingCarryable)
        {
            WeaponToThrow = FindBestWeapon();
        }
        super(Pawn).ThrowActiveWeapon(bDestroyWeap);
    }
    if(WeaponToThrow != none)
    {
        TossInventory(WeaponToThrow);
    }
    if(((Health <= 0) && KFCarryableObject(WeaponToThrow) == none) && !bIsHoldingCarryable)
    {
        WeaponToThrow = InvManager.FindInventoryType(Class'KFCarryableObject', true);
        TossInventory(WeaponToThrow);
    }
}

function bool ShouldPlayHeadlessMeleeAnims();

function bool ShouldPlaySpecialMeleeAnims();

function StopPartialZedTime()
{
    bUnaffectedByZedTime = false;
}

simulated function SetNightVisionLight(bool bEnabled);

simulated function ANIMNOTIFY_ShellEject()
{
    if(WeaponAttachment != none)
    {
        WeaponAttachment.ANIMNOTIFY_ShellEject();
    }
}

simulated function ANIMNOTIFY_SpawnedKActor(KFKActorSpawnable NewKActor, AnimNodeSequence AnimSeqInstigator);

simulated event Rotator GetBaseAimRotation()
{
    local Rotator AimRot;

    if(IsDoingSpecialMove() && SpecialMoves[SpecialMove].GetSMAimRotation(AimRot))
    {
        return AimRot;
    }
    return super(Pawn).GetBaseAimRotation();
}

simulated function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    if(Controller == none)
    {
        return GetBaseAimRotation();
    }
    return Controller.GetAdjustedAimFor(W, StartFireLoc);
}

simulated function bool GetAutoTargetBones(out array<name> WeakBones, out array<name> NormalBones)
{
    if(!IsHeadless())
    {
        WeakBones.AddItem(HeadBoneName;
    }
    NormalBones.AddItem('Spine1';
    NormalBones.AddItem(PelvisBoneName;
    return true;
}

simulated function Vector GetAutoLookAtLocation(Vector CamLoc, Pawn InstigatingPawn)
{
    local Vector HitLocation, HitNormal;
    local Actor HitActor;
    local TraceHitInfo HitInfo;
    local Vector HeadLocation, TorsoLocation, PelvisLocation;

    HeadLocation = Mesh.GetBoneLocation(HeadBoneName);
    HitActor = InstigatingPawn.Trace(HitLocation, HitNormal, HeadLocation, CamLoc, true, vect(0, 0, 0), HitInfo, 1);
    if((HitActor == none) || HitActor == self)
    {
        return HeadLocation + vect(0, 0, -10);
    }
    TorsoLocation = Mesh.GetBoneLocation(TorsoBoneName);
    HitActor = InstigatingPawn.Trace(HitLocation, HitNormal, TorsoLocation, CamLoc, true, vect(0, 0, 0), HitInfo, 1);
    if((HitActor == none) || HitActor == self)
    {
        return TorsoLocation;
    }
    PelvisLocation = Mesh.GetBoneLocation(PelvisBoneName);
    HitActor = InstigatingPawn.Trace(HitLocation, HitNormal, PelvisLocation, CamLoc, true, vect(0, 0, 0), HitInfo, 1);
    if((HitActor == none) || HitActor == self)
    {
        return PelvisLocation;
    }
    return Location + (BaseEyeHeight * vect(0, 0, 0.5));
}

function SetCloaked(bool bNewCloaking);

// Export UKFPawn::execIsUsingSuperSpeed(FFrame&, void* const)
native final function bool IsUsingSuperSpeed();

// Export UKFPawn::execIsPawnMovingAwayFromMe(FFrame&, void* const)
native function bool IsPawnMovingAwayFromMe(Pawn CheckPawn, optional float MinSpeed);

// Export UKFPawn::execIsPawnMovingTowardMe(FFrame&, void* const)
native function bool IsPawnMovingTowardMe(Pawn CheckPawn, optional float MinSpeed);

// Export UKFPawn::execIsSurrounded(FFrame&, void* const)
native function bool IsSurrounded(bool bOnlyEnemies, optional int MinNearbyPawns, optional float Radius)
{
    MinNearbyPawns = 2;
    Radius = 200;                    
}

event UpdateSprinting(Actor Goal);

function SetSprinting(bool bNewSprintStatus)
{
    if(bNewSprintStatus)
    {
        if(!bAllowSprinting)
        {
            bNewSprintStatus = false;            
        }
        else
        {
            if(bIsCrouched)
            {
                bNewSprintStatus = false;                
            }
            else
            {
                if((MyKFWeapon != none) && !MyKFWeapon.AllowSprinting())
                {
                    bNewSprintStatus = false;
                }
            }
        }
    }
    bIsSprinting = bNewSprintStatus;
    if(MyKFWeapon != none)
    {
        MyKFWeapon.SetWeaponSprint(bNewSprintStatus);
    }
}

function bool DoJump(bool bUpdating)
{
    if(super(Pawn).DoJump(bUpdating) && !IsDoingSpecialMove())
    {
        if(((MyKFWeapon != none) && MyKFWeapon.bUsingSights) && !MyKFWeapon.bKeepIronSightsOnJump)
        {
            MyKFWeapon.PerformZoom(false);
        }
        bJumping = true;
        NumJumpsRemaining = NumJumpsAllowed - 1;
        return true;        
    }
    else
    {
        if((NumJumpsRemaining > 0) && bJumping)
        {
            Velocity.Z = JumpZ;
            -- NumJumpsRemaining;
            return true;
        }
    }
    return false;
}

function bool CannotJumpNow()
{
    local PlayerController PC;
    local KFPlayerInput Input;

    if(bIsCrouched)
    {
        PC = PlayerController(Controller);
        if((PC != none) && PC.bDuck == 0)
        {
            Input = KFPlayerInput(PC.PlayerInput);
            if((Input != none) && (WorldInfo.TimeSeconds - Input.PressedJumpTime) < 0.05)
            {
                return true;
            }
        }
    }
    return false;
}

simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    local editinline StaticMeshComponent OtherSMC;

    if((Other.bWorldGeometry && !OtherComp.BlockActors) && Physics != 8)
    {
        if((!WorldInfo.bDropDetail && WorldInfo.GetDetailMode() > 0) && ActorEffectIsRelevant(self, false))
        {
            OtherSMC = StaticMeshComponent(OtherComp);
            if((OtherSMC != none) && OtherSMC.CanBecomeDynamic())
            {
                Class'KActorFromStatic'.static.MakeDynamic(OtherSMC);
            }
        }
    }
}

simulated function bool CanBeBaseForPawn(Pawn aPawn)
{
    return bCanBeBaseForPawns || InteractionPawn == aPawn;
}

function JumpOffPawn()
{
    local float Theta;

    if((Base == none) || Base.Location.Z > Location.Z)
    {
        return;
    }
    Theta = (2 * 3.141593) * FRand();
    SetPhysics(2);
    if((Controller != none) && !IsHumanControlled())
    {
        Velocity.X += (Cos(Theta) * (float(750) + CylinderComponent.CollisionRadius));
        Velocity.Y += (Sin(Theta) * (float(750) + CylinderComponent.CollisionRadius));
        if(VSize2D(Velocity) > (2 * FMax(500, GroundSpeed)))
        {
            Velocity = (2 * FMax(500, GroundSpeed)) * Normal(Velocity);
        }
        Velocity.Z = 400;
        AirControl = 0.05;
        SetTimer(1, false, 'RestoreAirControlTimer');        
    }
    else
    {
        Velocity.X += (Cos(Theta) * (float(150) + CylinderComponent.CollisionRadius));
        Velocity.Y += (Sin(Theta) * (float(150) + CylinderComponent.CollisionRadius));
        if(VSize2D(Velocity) > FMax(500, GroundSpeed))
        {
            Velocity = FMax(500, GroundSpeed) * Normal(Velocity);
        }
        Velocity.Z = 200;
    }
}

function RestoreAirControlTimer()
{
    if((Controller != none) && !IsHumanControlled())
    {
        AirControl = 0.35;
        return;
    }
    AirControl = default.AirControl;
}

function PostTeleport(Teleporter OutTeleporter)
{
    local array<SequenceObject> AllTeleportEvents;
    local KFSeqEvent_PawnTeleported TeleportEvt;
    local Sequence GameSeq;
    local int I;

    if(WorldInfo.NetMode == NM_Client)
    {
        return;
    }
    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(Class'KFSeqEvent_PawnTeleported', true, AllTeleportEvents);
        I = 0;
        J0xA0:

        if(I < AllTeleportEvents.Length)
        {
            TeleportEvt = KFSeqEvent_PawnTeleported(AllTeleportEvents[I]);
            if(TeleportEvt != none)
            {
                TeleportEvt.Reset();
                TeleportEvt.CheckActivate(self, self);
            }
            ++ I;
            goto J0xA0;
        }
    }
}

simulated function SetMeshVisibility(bool bVisible)
{
    if(Mesh != none)
    {
        Mesh.SetOwnerNoSee(!bVisible);
        Mesh.CastShadow = bVisible;
    }
    HideHead(!bVisible);
    SetWeaponAttachmentVisibility(bVisible);
    SetFirstPersonVisibility(!bVisible);
    SetEnableFleXCollision(bVisible);
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    local int AttachmentIdx;

    PawnLightingChannel = NewLightingChannels;
    if(Mesh != none)
    {
        Mesh.SetLightingChannels(NewLightingChannels);
    }
    if(ThirdPersonHeadMeshComponent != none)
    {
        ThirdPersonHeadMeshComponent.SetLightingChannels(NewLightingChannels);
    }
    AttachmentIdx = 0;
    J0x8C:

    if(AttachmentIdx < 3)
    {
        if(ThirdPersonAttachments[AttachmentIdx] != none)
        {
            ThirdPersonAttachments[AttachmentIdx].SetLightingChannels(NewLightingChannels);
        }
        ++ AttachmentIdx;
        goto J0x8C;
    }
    if(ArmsMesh != none)
    {
        ArmsMesh.SetLightingChannels(NewLightingChannels);
        AttachmentIdx = 0;
        J0x137:

        if(AttachmentIdx < 3)
        {
            if(FirstPersonAttachments[AttachmentIdx] != none)
            {
                FirstPersonAttachments[AttachmentIdx].SetLightingChannels(NewLightingChannels);
            }
            ++ AttachmentIdx;
            goto J0x137;
        }
    }
    if(WeaponAttachment != none)
    {
        WeaponAttachment.SetMeshLightingChannels(NewLightingChannels);
    }
    if(Weapon != none)
    {
        Weapon.SetMeshLightingChannels(NewLightingChannels);
    }
}

simulated function HideHead(bool bHide)
{
    if(ThirdPersonHeadMeshComponent != none)
    {
        ThirdPersonHeadMeshComponent.SetOwnerNoSee(bHide);
    }
    SetThirdPersonAttachmentVisibility(!bHide);
}

simulated function SetThirdPersonAttachmentVisibility(bool bVisible)
{
    local int AttachmentIdx;

    AttachmentIdx = 0;
    J0x0B:

    if(AttachmentIdx < 3)
    {
        if(ThirdPersonAttachments[AttachmentIdx] != none)
        {
            ThirdPersonAttachments[AttachmentIdx].SetOwnerNoSee(!bVisible);
        }
        ++ AttachmentIdx;
        goto J0x0B;
    }
}

function bool IsVulnerableTo(class<DamageType> DT, optional out float DamageMod);

function bool IsResistantTo(class<DamageType> DT, optional out float DamageMod);

final simulated function float GetHealthPercentage()
{
    return float(Health) / float(HealthMax);
}

simulated function bool CanBeHealed();

function HandleMomentum(Vector Momentum, Vector HitLocation, class<DamageType> DamageType, optional TraceHitInfo HitInfo)
{
    if((SpecialMove != 0) && !SpecialMoves[SpecialMove].bAllowMomentumPush)
    {
        return;
    }
    if(VSizeSq(Momentum) > Square(200))
    {
        AddVelocity(Momentum, HitLocation, DamageType, HitInfo);
    }
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bRepairArmor, optional bool bMessageHealer)
{
    local int I, OldHealth;
    local bool superResult;

    bRepairArmor = true;
    bMessageHealer = true;
    I = 0;
    J0x15:

    if(I < DamageOverTimeArray.Length)
    {
        if(DamageOverTimeArray[I].DoT_Type == 1)
        {
            DamageOverTimeArray[I].Duration *= 0.5;
            DamageOverTimeArray[I].Damage *= 0.5;
            goto J0xC6;
        }
        ++ I;
        goto J0x15;
    }
    J0xC6:

    OldHealth = Health;
    superResult = super(Pawn).HealDamage(Amount, Healer, DamageType);
    if((Health - OldHealth) > 0)
    {
        WorldInfo.Game.ScoreHeal(Health - OldHealth, OldHealth, Healer, self, DamageType);
    }
    return superResult;
}

function TakeFallingDamage()
{
    local float EffectiveSpeed;

    if(Velocity.Z < (-0.5 * MaxFallSpeed))
    {
        if(Role == ROLE_Authority)
        {
            MakeNoise(1);
            if(Velocity.Z < (float(-1) * MaxFallSpeed))
            {
                EffectiveSpeed = Velocity.Z;
                if(TouchingWaterVolume())
                {
                    EffectiveSpeed += float(100);
                }
                if(EffectiveSpeed < (float(-1) * MaxFallSpeed))
                {
                    TakeDamage(int((float(-100) * (EffectiveSpeed + MaxFallSpeed)) / MaxFallSpeed), none, Location, vect(0, 0, 0), Class'KFDT_Falling');
                }
            }
        }        
    }
    else
    {
        if(Velocity.Z < (-1.4 * JumpZ))
        {
            MakeNoise(0.5);            
        }
        else
        {
            if(Velocity.Z < (-0.8 * JumpZ))
            {
                MakeNoise(0.2);
            }
        }
    }
}

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    DamageFalloffExponent = 1;
    bTakingRadiusDamage = true;
    super(Actor).TakeRadiusDamage(InstigatedBy, BaseDamage, DamageRadius, DamageType, Momentum, HurtOrigin, bFullDamage, DamageCauser, DamageFalloffExponent);
    bTakingRadiusDamage = false;
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int OldHealth, actualDamage;
    local class<KFDamageType> KFDT;
    local KFGameInfo KFGI;
    local KFPlayerController KFPC;
    local KFPawn_Monster PawnMonster;
    local bool bAllowHeadshot;
    local KFPowerUp KFPowerUp;

    bAllowHeadshot = CanCountHeadshots();
    OldHealth = Health;
    super(Pawn).TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    actualDamage = OldHealth - Health;
    if(actualDamage > 0)
    {
        WorldInfo.Game.ScoreDamage(actualDamage, OldHealth, InstigatedBy, self, DamageType);
    }
    if((Health < OldHealth) && DamageCauser != none)
    {
        KFDT = class<KFDamageType>(DamageType);
        if(KFDT != none)
        {
            KFDT.static.ApplySecondaryDamage(self, Damage, InstigatedBy);
            if(Health <= 0)
            {
                KFDT.static.ApplyKillResults(self);
            }
        }
    }
    KFPC = KFPlayerController(InstigatedBy);
    if(KFPC != none)
    {
        KFPowerUp = KFPC.GetPowerUp();
        if((KFPowerUp != none) && KFPowerUp.default.SecondaryDamageType != DamageType)
        {
            KFPowerUp.ApplySecondaryDamage(self, Damage, InstigatedBy);
        }
    }
    if(((bAllowHeadshot && HitFxInfo.HitBoneIndex == 0) && OldHealth > 0) && WorldInfo.Game != none)
    {
        KFPC = KFPlayerController(InstigatedBy);
        KFGI = KFGameInfo(WorldInfo.Game);
        if((((KFPC != none) && KFGI != none) && (PlayerReplicationInfo == none) || PlayerReplicationInfo.GetTeamNum() == 255) && LastHeadShotReceivedTime != WorldInfo.TimeSeconds)
        {
            LastHeadShotReceivedTime = WorldInfo.TimeSeconds;
            KFPC.AddZedHeadshot(KFGI.GetModifiedGameDifficulty(), HitFxInfo.DamageType);
            if((KFPC != none) && HitFxInfo.DamageType != none)
            {
                Class'EphemeralMatchStats'.static.RecordWeaponHeadShot(KFPC, HitFxInfo.DamageType);
            }
        }
        if(bPlayedDeath)
        {
            KFGameInfo(WorldInfo.Game).NotifyHeadshotKill(InstigatedBy, self);
            PawnMonster = KFPawn_Monster(self);
            if(((PawnMonster != none) && KFPC != none) && KFGI != none)
            {
                KFPC.AddZedHeadshotKill(PawnMonster.Class, KFGI.GetModifiedGameDifficulty(), DamageType);
            }
        }
    }
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    local int HitZoneIdx;
    local KFPawn_Monster InstigatorMonster;
    local class<KFDamageType> KFDT;

    if(bLogTakeDamage)
    {
        LogInternal(((((((((string(self) @ string(GetFuncName())) @ "Starting Damage=") $ string(InDamage)) @ "Momentum=") $ string(Momentum)) @ "Zone=") $ string(HitInfo.BoneName)) @ "DamageType=") $ string(DamageType));
    }
    if(MyKFWeapon != none)
    {
        MyKFWeapon.AdjustDamage(InDamage, DamageType, DamageCauser);
    }
    InstigatorMonster = ((InstigatedBy == none) ? none : KFPawn_Monster(InstigatedBy.Pawn));
    if((InDamage > 0) && InstigatorMonster != none)
    {
        if(bLogTakeDamage)
        {
            LogInternal(((string(self) @ string(GetFuncName())) @ " Difficulty Damage Mod =") $ string(InstigatorMonster.DifficultyDamageMod));
        }
        InDamage = Max(int(float(InDamage) * InstigatorMonster.DifficultyDamageMod), 1);
        if(bLogTakeDamage)
        {
            LogInternal(((string(self) @ string(GetFuncName())) @ " Affliction Damage Mod = ") $ string(InstigatorMonster.AfflictionHandler.GetAfflictionDamageModifier()));
        }
        InDamage = Max(int(float(InDamage) * InstigatorMonster.AfflictionHandler.GetAfflictionDamageModifier()), 1);
    }
    HitZoneIdx = HitZones.Find('ZoneName', HitInfo.BoneName;
    if(HitZoneIdx != -1)
    {
        InDamage *= HitZones[HitZoneIdx].DmgScale;
    }
    InDamage *= VolumeDamageScale;
    KFDT = class<KFDamageType>(DamageType);
    if(((InDamage >= Health) && KFDT != none) && KFDT.default.bNonLethalDamage)
    {
        InDamage = Health - 1;
    }
    if(bLogTakeDamage)
    {
        LogInternal(((((((((string(self) @ string(GetFuncName())) @ " After KFPawn adjustment Damage=") $ string(InDamage)) @ "Momentum=") $ string(Momentum)) @ "Zone=") $ string(HitInfo.BoneName)) @ "DamageType=") $ string(DamageType));
    }
}

function UpdateLastTimeDamageHappened()
{
    LastTimeDamageHappened = WorldInfo.TimeSeconds;
}

function AdjustRadiusDamage(out float InBaseDamage, float DamageScale, Vector HurtOrigin)
{
    InBaseDamage *= (GetExposureTo(HurtOrigin));
    LastRadiusDamageScale = FloatToByte(DamageScale);
    LastRadiusHurtOrigin = HurtOrigin;
}

function bool CanCountHeadshots()
{
    return true;
}

function bool WeeklyShouldExplodeOnDeath()
{
    return true;
}

function int GetMostRecentDamageHistoryIndexFor(Pawn CheckKFP)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < DamageHistory.Length)
    {
        if(DamageHistory[I].DamagerController != none)
        {
            if(DamageHistory[I].DamagerController == CheckKFP.Controller)
            {
                return I;
            }
        }
        ++ I;
        goto J0x0B;
    }
    return -1;
}

function int RecentDamageFrom(Pawn CheckKFP, optional out int DamageAmount)
{
    local int I;

    I = 0;
    J0x0C:

    if(I < DamageHistory.Length)
    {
        if(DamageHistory[I].DamagerController != none)
        {
            if(DamageHistory[I].DamagerController == CheckKFP.Controller)
            {
                DamageAmount += int(DamageHistory[I].Damage);
            }
        }
        ++ I;
        goto J0x0C;
    }
    return DamageAmount;
}

function AddTakenDamage(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType)
{
    if(!DamagerController.bIsPlayer && !DamagerController.bIsPlayer)
    {
        NotifyFriendlyAIDamageTaken(DamagerController, Damage, DamageCauser, DamageType);        
    }
    else
    {
        if((Damage > 0) && DamagerController.GetTeamNum() != GetTeamNum())
        {
            UpdateDamageHistory(DamagerController, Damage, DamageCauser, DamageType);
        }
    }
}

function UpdateDamageHistory(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType)
{
    local DamageInfo Info;
    local Pawn BlockerPawn;
    local bool bChangedEnemies;
    local int HistoryIndex;
    local float DamageThreshold;
    local KFAIController KFAIC;

    if(!GetDamageHistory(DamagerController, Info, HistoryIndex))
    {
        DamageHistory.Insert(0, 1;
    }
    if((Controller != none) && !Controller.bIsPlayer)
    {
        KFAIC = KFAIController(Controller);
        if(KFAIC != none)
        {
            DamageThreshold = float(HealthMax) * KFAIC.AggroPlayerHealthPercentage;
            UpdateDamageHistoryValues(DamagerController, Damage, DamageCauser, KFAIC.AggroPlayerResetTime, Info, DamageType);
            if((WorldInfo.TimeSeconds - DamageHistory[KFAIC.CurrentEnemysHistoryIndex].LastTimeDamaged) > float(10))
            {
                DamageHistory[KFAIC.CurrentEnemysHistoryIndex].Damage = 0;
            }
            if(((KFAIC.IsAggroEnemySwitchAllowed() && DamagerController.Pawn != KFAIC.Enemy) && Info.Damage >= DamageThreshold) && Info.Damage > DamageHistory[KFAIC.CurrentEnemysHistoryIndex].Damage)
            {
                BlockerPawn = KFAIC.GetPawnBlockingPathTo(DamagerController.Pawn, true);
                if(BlockerPawn == none)
                {
                    bChangedEnemies = KFAIC.SetEnemy(DamagerController.Pawn);                    
                }
                else
                {
                    bChangedEnemies = KFAIC.SetEnemy(BlockerPawn);
                }
            }
        }        
    }
    else
    {
        UpdateDamageHistoryValues(DamagerController, Damage, DamageCauser, 0, Info, DamageType);
    }
    DamageHistory[HistoryIndex] = Info;
    if((KFAIC != none) && bChangedEnemies)
    {
        KFAIC.CurrentEnemysHistoryIndex = byte(HistoryIndex);
    }
}

function bool GetDamageHistory(Controller DamagerController, out DamageInfo InInfo, out int InHistoryIndex)
{
    InHistoryIndex = DamageHistory.Find('DamagerController', DamagerController;
    if(InHistoryIndex != -1)
    {
        InInfo = DamageHistory[InHistoryIndex];
        return true;
    }
    InHistoryIndex = 0;
    return false;
}

function UpdateDamageHistoryValues(Controller DamagerController, int Damage, Actor DamageCauser, float DamageResetTime, out DamageInfo InInfo, class<KFDamageType> DamageType)
{
    local class<KFPerk> WeaponPerk;

    InInfo.DamagerController = DamagerController;
    if((WorldInfo.TimeSeconds - InInfo.LastTimeDamaged) > DamageResetTime)
    {
        InInfo.Damage = 0;
    }
    InInfo.Damage += float(Damage);
    InInfo.TotalDamage += float(Damage);
    if(DamagerController.PlayerReplicationInfo != none)
    {
        InInfo.DamagerPRI = DamagerController.PlayerReplicationInfo;
    }
    WeaponPerk = GetUsedWeaponPerk(DamagerController, DamageCauser, DamageType);
    if((WeaponPerk != none) && InInfo.DamagePerks.Find(WeaponPerk == -1)
    {
        InInfo.DamagePerks.AddItem(WeaponPerk;
    }
    if((DamageCauser != none) && InInfo.DamageCausers.Find(DamageCauser.Class == -1)
    {
        InInfo.DamageCausers.AddItem(DamageCauser.Class;
    }
    if((DamageType != none) && InInfo.DamageTypes.Find(DamageType == -1)
    {
        InInfo.DamageTypes.AddItem(DamageType;
    }
}

function NotifyFriendlyAIDamageTaken(Controller DamagerController, int Damage, Actor DamageCauser, class<KFDamageType> DamageType);

function class<KFPerk> GetUsedWeaponPerk(Controller DamagerController, Actor DamageCauser, class<KFDamageType> DamageType)
{
    local class<KFPerk> WeaponPerk, InstigatorPerkClass;
    local KFPlayerController KFPC;
    local KFWeapon KFW;

    KFPC = KFPlayerController(DamagerController);
    if(KFPC == none)
    {
        return none;
    }
    InstigatorPerkClass = KFPC.GetPerk().GetPerkClass();
    if(InstigatorPerkClass == none)
    {
        return none;
    }
    WeaponPerk = Class'KFPerk'.static.GetPerkFromDamageCauser(DamageCauser, InstigatorPerkClass);
    if(WeaponPerk == none)
    {
        KFW = KFWeapon(DamageCauser);
        if(((KFW == none) && DamageType != none) && DamageType.static.IsNotPerkBound())
        {
            KFW = KFWeapon(KFPC.Pawn.Weapon);
            if(KFW != none)
            {
                WeaponPerk = Class'KFPerk'.static.GetPerkFromDamageCauser(KFW, InstigatorPerkClass);
            }
        }
    }
    if(((WeaponPerk == none) && KFW != none) && Class'KFPerk'.static.IsBackupWeapon(KFW))
    {
        WeaponPerk = InstigatorPerkClass;
    }
    return WeaponPerk;
}

function Pawn GetBestAggroEnemy()
{
    local int I, DamageThreshold;
    local DamageInfo DamageHistoryInfo;

    DamageThreshold = int(float(HealthMax) * KFAIController(Controller).AggroZedHealthPercentage);
    I = 0;
    J0x4B:

    if(I < DamageHistory.Length)
    {
        DamageHistoryInfo = DamageHistory[I];
        if((((DamageHistoryInfo.DamagerController != none) && DamageHistoryInfo.DamagerController.Pawn != none) && DamageHistoryInfo.Damage >= float(DamageThreshold)) && (WorldInfo.TimeSeconds - DamageHistory[I].LastTimeDamaged) < 5)
        {
            return DamageHistoryInfo.DamagerController.Pawn;
        }
        ++ I;
        goto J0x4B;
    }
    return none;
}

function float GetExposureTo(Vector TraceStart)
{
    local float PercentExposed;

    if(FastTrace(Mesh.GetBoneLocation(HeadBoneName), TraceStart,, true))
    {
        PercentExposed += 0.4;
    }
    PercentExposed += 0.3;
    if(FastTrace(Mesh.GetBoneLocation(LeftFootBoneName), TraceStart,, true))
    {
        PercentExposed += 0.15;
    }
    if(FastTrace(Mesh.GetBoneLocation(RightFootBoneName), TraceStart,, true))
    {
        PercentExposed += 0.15;
    }
    return PercentExposed;
}

simulated function PrepareRagdoll()
{
    if(PhysicsImpactBlendTimeToGo > 0)
    {
        StopPhysicsBodyImpact();
    }
    Mesh.MinDistFactorForKinematicUpdate = 0;
    Mesh.bUpdateSkelWhenNotRendered = true;
    if(Mesh.bNotUpdatingKinematicDueToDistance)
    {
        Mesh.ForceSkelUpdate();
        Mesh.UpdateRBBonesFromSpaceBases(true, true);
        Mesh.SetBlockRigidBody(true);        
    }
    else
    {
        if(!Mesh.bUpdateKinematicBonesFromAnimation)
        {
            Mesh.UpdateRBBonesFromSpaceBases(true, true);            
        }
        else
        {
            if(!bPlayedDeath && Role < ROLE_Authority)
            {
                Mesh.UpdateRBBonesFromSpaceBases(true, true);
            }
        }
    }
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    TerminateEffectsOnDeath();
    if(!bTearOff)
    {
        HitDamageType = DamageType;
        TakeHitLocation = HitLoc;
    }
    if(IsDoingSpecialMove())
    {
        SpecialMoveHandler.EndSpecialMove();
    }
    if((bCanHeadTrack && bIsHeadTrackingActive) && MyLookAtInfo.LookAtTarget != none)
    {
        ClearHeadTrackTarget(MyLookAtInfo.LookAtTarget);
    }
    if(ShouldRagdollOnDeath())
    {
        PlayRagdollDeath(DamageType, HitLoc);        
    }
    else
    {
        HideMeshOnDeath();
    }
    CylinderComponent.SetTraceBlocking(false, false);
    if(TimeOfDeath == 0)
    {
        TimeOfDeath = WorldInfo.TimeSeconds;
    }
    bTearOff = true;
    super(Pawn).PlayDying(DamageType, HitLoc);
    Velocity -= TearOffMomentum;
}

simulated function bool ShouldRagdollOnDeath()
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return false;
    }
    if((WorldInfo.bDropDetail || WorldInfo.GetDetailMode() == 0) && !ActorEffectIsRelevant(((LastHitBy != none) ? LastHitBy.Pawn : none), false, 50000))
    {
        return false;
    }
    return true;
}

simulated function PlayRagdollDeath(class<DamageType> DamageType, Vector HitLoc)
{
    local TraceHitInfo HitInfo;
    local Vector HitDirection;

    if((bReinitPhysAssetOnDeath && CharacterArch != none) && CharacterArch.PhysAsset != none)
    {
        Mesh.SetPhysicsAsset(CharacterArch.PhysAsset,, true);
    }
    PrepareRagdoll();
    if(InitRagdoll())
    {
        Mesh.SetTickGroup(2);
        SetTickGroup(2);
        Mesh.SetRBChannel(16);
        Mesh.SetRBCollidesWithChannel(16, ShouldCorpseCollideWithDead());
        Mesh.SetRBCollidesWithChannel(15, false);
        HitDirection = Normal(TearOffMomentum);
        CheckHitInfo(HitInfo, Mesh, HitDirection, HitLoc);
        if((bAllowDeathSM && CanDoSpecialMove(7)) && ClassIsChildOf(DamageType, Class'KFDamageType'))
        {
            DoSpecialMove(7, true,,, true);
            KFSM_DeathAnim(SpecialMoves[7]).PlayDeathAnimation(DamageType, HitDirection, HitInfo.BoneName);            
        }
        else
        {
            StopAllAnimations();
        }
    }
}

simulated event HideMeshOnDeath()
{
    if(!Mesh.HiddenGame)
    {
        Mesh.SetHidden(true);
        Mesh.SetTraceBlocking(false, false);
        if(ThirdPersonHeadMeshComponent.bAttached)
        {
            ThirdPersonHeadMeshComponent.SetHidden(true);
            ThirdPersonHeadMeshComponent.SetTraceBlocking(false, false);
        }
        StopAllAnimations();
        Mesh.SetOnlyOwnerSee(true);
        LifeSpan = 2;
    }
}

simulated function PlayDyingSound()
{
    SoundGroupArch.PlayDyingSound(self);
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    if(super.Died(Killer, DamageType, HitLocation))
    {
        bBlocksNavigation = false;
        return true;
    }
    return false;
}

event EncroachedBy(Actor Other);

function CrushedBy(Pawn OtherPawn)
{
    TakeDamage(int((((float(1) - (OtherPawn.Velocity.Z / float(400))) * OtherPawn.Mass) / Mass) * CrushScale), OtherPawn.Controller, Location, vect(0, 0, 0), Class'DmgType_Crushed');
}

function bool NotifyAttackParried(Pawn InstigatedBy, byte InParryStrength)
{
    local KFPawn InstigatorPawn;
    local KFPerk InstigatorPerk;

    if(IsDoingSpecialMove() && SpecialMoves[SpecialMove].CanInterruptWithParry())
    {
        if((CanDoSpecialMove(4)) || CanDoSpecialMove(6))
        {
            InstigatorPawn = KFPawn(InstigatedBy);
            if(InstigatorPawn != none)
            {
                InstigatorPerk = InstigatorPawn.GetPerk();
            }
            if(((CanDoSpecialMove(6)) && InstigatorPerk != none) && InstigatorPerk.ShouldKnockdown())
            {
                Knockdown(,, vect(1, 1, 20),,,, float(1000) * Normal(Location - InstigatorPawn.Location), Location);                
            }
            else
            {
                DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackParrySMFlags(self, Location - InstigatedBy.Location));
            }
            return true;
        }
    }
    return false;
}

simulated function bool IsCombatCapable()
{
    return ((IsAliveAndWell() && !IsHeadless()) && !IsImpaired()) && !IsIncapacitated();
}

simulated function bool IsImpaired();

simulated function bool IsIncapacitated()
{
    return (((IsDoingSpecialMove(4) || IsDoingSpecialMove(8)) || IsDoingSpecialMove(9)) || IsDoingSpecialMove(6)) || IsDoingSpecialMove(5);
}

simulated function bool IsHeadless();

simulated function TerminateEffectsOnDeath()
{
    if((WeaponAttachment != none) && !WeaponAttachment.bPendingDelete)
    {
        WeaponAttachment.DetachFrom(self);
        WeaponAttachment.Destroy();
    }
    SetWeaponAmbientSound(none);
    SetSecondaryWeaponAmbientSound(none);
    SetPawnAmbientSound(none);
    WeaponAmbientEchoHandler.StopAllEchoes(bPendingDelete);
    DialogAkComponent.StopEvents();
    SetPowerUpAmbientSound(none, none, none, none);
    AfflictionHandler.ShutDown();
    if(SoundGroupArch.OnDeathStopEvent != none)
    {
        PostAkEvent(SoundGroupArch.OnDeathStopEvent);
    }
}

// Export UKFPawn::execCalcOctagonRegion(FFrame&, void* const)
native static function KFPawn.EPawnOctant CalcOctagonRegion(Rotator R, Vector V);

// Export UKFPawn::execCalcQuadRegion(FFrame&, void* const)
native static function KFPawn.EPawnOctant CalcQuadRegion(Rotator R, Vector V);

// Export UKFPawn::execDamagedHitZones(FFrame&, void* const)
native final iterator function DamagedHitZones(out int Idx);

// Export UKFPawn::execPlayPhysicsBodyImpact(FFrame&, void* const)
native simulated function PlayPhysicsBodyImpact(Vector HitLocation, Vector Momentum, class<DamageType> DamageType, name HitBoneName);

// Export UKFPawn::execStartPhysicsBodyImpact(FFrame&, void* const)
native simulated function StartPhysicsBodyImpact(name HitBoneName, bool bUseMotors, class<DamageType> DamageType);

// Export UKFPawn::execStopPhysicsBodyImpact(FFrame&, void* const)
native simulated function StopPhysicsBodyImpact();

// Export UKFPawn::execGetImpactPhysicsImpulse(FFrame&, void* const)
native simulated function Vector GetImpactPhysicsImpulse(class<DamageType> DamageType, Vector HitLoc, Vector Momentum, name HitBoneName);

// Export UKFPawn::execInitPartialKinematics(FFrame&, void* const)
native simulated function InitPartialKinematics();

simulated function HitZoneInjured(optional int HitZoneIdx)
{
    HitZoneIdx = -1;
}

function NotifyMeleeTakeHit(Controller InstigatedBy, Vector HitLocation);

function Vector EncodeUnitVector(Vector V)
{
    return Normal(V) * 256;
}

simulated function Vector DecodeUnitVector(Vector V)
{
    return Normal(V / 256);
}

static function bool IsLargeZed()
{
    return false;
}

function int GetHitZoneIndex(name BoneName)
{
    return HitZones.Find('ZoneName', BoneName;
}

function PlayHit(float Damage, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, Vector Momentum, TraceHitInfo HitInfo)
{
    local int HitZoneIdx;
    local class<KFDamageType> KFDT;

    if((Damage <= float(0)) || (Controller != none) && Controller.bGodMode)
    {
        return;
    }
    HitZoneIdx = GetHitZoneIndex(HitInfo.BoneName);
    KFDT = class<KFDamageType>(DamageType);
    AddHitFX(int(Damage), InstigatedBy, HitZoneIdx, HitLocation, Momentum, KFDT);
    if(HitZoneIdx != -1)
    {
        if(InstigatedBy != none)
        {
            if((HitZoneIdx == 0) && KFPlayerController(InstigatedBy) != none)
            {
                KFPlayerController(InstigatedBy).AddHeadHit(1);
            }
            TakeHitZoneDamage(Damage, HitFxInfo.DamageType, HitZoneIdx, InstigatedBy.Pawn.Location);            
        }
        else
        {
            TakeHitZoneDamage(Damage, HitFxInfo.DamageType, HitZoneIdx, vect(0, 0, 0));
        }
    }
    LastPainTime = WorldInfo.TimeSeconds;
    if(KFDT != none)
    {
        Class'EphemeralMatchStats'.static.RecordWeaponDamage(InstigatedBy, KFDT, KFDT.default.WeaponDef, int(Damage), self, HitZoneIdx);
    }
}

function AddHitFX(int Damage, Controller InstigatedBy, int HitZoneIdx, Vector HitLocation, Vector Momentum, class<KFDamageType> KFDT)
{
    local bool bHasNewHitEffect;

    bHasNewHitEffect = true;
    if(bNeedsProcessHitFx)
    {
        if((((InstigatedBy != none) && InstigatedBy.Pawn == HitFxInstigator) && KFDT != none) && KFDT == HitFxInfo.DamageType)
        {
            if((HitFxAddedHitCount < 7) && !bTakingRadiusDamage)
            {
                HitFxAddedRelativeLocs[HitFxAddedHitCount] = HitLocation - HitFxInfo.HitLocation;
                ++ HitFxAddedHitCount;
            }
            bHasNewHitEffect = false;            
        }
        else
        {
            if(!bTakingRadiusDamage && HitFxInfo.bRadialDamage)
            {
                bHasNewHitEffect = false;
            }
        }
    }
    if(bHasNewHitEffect)
    {
        HitFxInstigator = ((InstigatedBy != none) ? InstigatedBy.Pawn : none);
        HitFxInfo.HitLocation = HitLocation;
        HitFxInfo.EncodedHitDirection = ((((KFDT != none) && KFDT.default.bPointImpulseTowardsOrigin) && InstigatedBy.Pawn != none) ? EncodeUnitVector(Normal(Location - InstigatedBy.Pawn.Location)) : EncodeUnitVector(Normal(Momentum)));
        HitFxInfo.HitBoneIndex = byte(HitZoneIdx);
        HitFxInfo.bRadialDamage = bTakingRadiusDamage;
        HitFxInfo.DamageType = KFDT;
        if(InstigatedBy != none)
        {
            HitFxInfo.DamagerPRI = InstigatedBy.PlayerReplicationInfo;
        }
        LastTakeHitTimeout = WorldInfo.TimeSeconds + 0.5;
        if(bTakingRadiusDamage && !IsZero(LastRadiusHurtOrigin))
        {
            HitFxRadialInfo.RadiusDamageScale = LastRadiusDamageScale;
            LastRadiusDamageScale = 255;
            HitFxRadialInfo.RadiusHurtOrigin = LastRadiusHurtOrigin;
            LastRadiusHurtOrigin = vect(0, 0, 0);
            HitFxInfo.HitLocation.Z += FRand();
        }
        if((bPlayedDeath && KFDT != none) && KFDT.default.bCanObliterate)
        {
            HitFxInfo.bObliterated = KFDT.static.CheckObliterate(self, Damage);            
        }
        else
        {
            HitFxInfo.bObliterated = false;
        }
        HitFxAddedHitCount = 0;
    }
    bNeedsProcessHitFx = true;
}

function PlayHeal(class<KFDamageType> DamageType, optional TraceHitInfo HitInfo)
{
    HitFxInfo.HitLocation = Location;
    HitFxInfo.HitLocation.Z += FRand();
    HitFxInfo.DamageType = DamageType;
    HitFxInfo.HitBoneIndex = byte(HitZones.Find('ZoneName', HitInfo.BoneName);
    LastTakeHitTimeout = WorldInfo.TimeSeconds + 0.5;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        PlayHealEffects(DamageType);
    }
}

function TakeHitZoneDamage(float Damage, class<DamageType> DamageType, int HitZoneIdx, Vector InstigatorLocation)
{
    local float GoreDamage;
    local class<KFDamageType> dmgType;

    GoreDamage = Damage;
    dmgType = class<KFDamageType>(DamageType);
    if(dmgType != none)
    {
        if(!IsZero(InstigatorLocation))
        {
            GoreDamage *= dmgType.static.GetGoreDamageScale(Location, InstigatorLocation);
        }
        if(bPlayedDeath && TimeOfDeath == WorldInfo.TimeSeconds)
        {
            GoreDamage *= dmgType.static.GetOnDeathGoreScale();
        }
    }
    HitZones[HitZoneIdx].GoreHealth -= int(GoreDamage);
}

function bool CanInjureHitZone(class<DamageType> DamageType, int HitZoneIdx)
{
    local class<KFDamageType> KFDmgType;
    local name HitZoneName;

    if(HitZoneIdx > HitZones.Length)
    {
        return false;
    }
    KFDmgType = class<KFDamageType>(DamageType);
    HitZoneName = HitZones[HitZoneIdx].ZoneName;
    if((!bPlayedDeath || WorldInfo.TimeSeconds == TimeOfDeath) && HitZoneIdx == 0)
    {
        if(KFDmgType.static.CanDismemberHitZoneWhileAlive(HitZoneName))
        {
            return true;
        }
    }
    if(bPlayedDeath)
    {
        if((KFDmgType != none) && KFDmgType.static.CanDismemberHitZone(HitZoneName))
        {
            return true;
        }
    }
    return false;
}

simulated function bool HasInjuredHitZones()
{
    return InjuredHitZones > 0;
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation, optional bool bUseHitImpulse)
{
    local KFPlayerController KFPC;
    local class<KFDamageType> dmgType;
    local KFPawn InstigatedBy;

    bUseHitImpulse = true;
    dmgType = HitFxInfo.DamageType;
    if(IsLocallyControlled() && !Controller.bGodMode)
    {
        KFPC = KFPlayerController(Controller);
        if((KFPC != none) && dmgType != none)
        {
            KFPC.PlayScreenHitFX(dmgType, true);
            if(dmgType.default.RadialDamageImpulse > float(0))
            {
                KFPC.PlayEarRingEffect(ByteToFloat(HitFxRadialInfo.RadiusDamageScale));
            }
        }
        if(MyKFWeapon != none)
        {
            MyKFWeapon.PlayTakeHitEffects(HitFxInfo.HitLocation, HitFxInstigator);
        }
    }
    if(HitFxInfo.DamageType != none)
    {
        HitFxInfo.DamageType.static.PlayImpactHitEffects(self, HitLocation, HitDirection, HitFxInfo.HitBoneIndex, HitFxInstigator);
    }
    if(HitFxInstigator != none)
    {
        InstigatedBy = KFPawn(HitFxInstigator);
        InstigatedBy.PlayDamageInstigatorHitEffects(self);
    }
    LastPainTime = WorldInfo.TimeSeconds;
}

simulated function PlayHealEffects(class<KFDamageType> DamageType)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Controller);
    if(KFPC != none)
    {
        KFPC.PlayScreenHitFX(DamageType, false);
    }
    if(DamageType != none)
    {
        DamageType.static.PlayImpactHitEffects(self, Location, vect(0, 0, 1), HitFxInfo.HitBoneIndex, HitFxInstigator);
    }
}

simulated event UpdateBodyScale(float NewScale)
{
    if(!IsAliveAndWell() || Physics == 10)
    {
        return;
    }
    bReinitPhysAssetOnDeath = true;
    CurrentBodyScale = NewScale;
    Mesh.SetScale(CurrentBodyScale);
    PitchAudio(CurrentBodyScale);
    SetBaseEyeheight();
}

simulated function PitchAudio(float NewScale)
{
    SetRTPCValue('Visual_Scale', NewScale);
    DialogAkComponent.SetRTPCValue("Visual_Scale", NewScale);
}

simulated function PlayDamageInstigatorHitEffects(KFPawn Victim);

simulated function ApplyRagdollImpulse(class<KFDamageType> DamageType, Vector HitLoc, Vector HitDirection, name HitBoneName, optional float GoreImpulseScale)
{
    local Vector Impulse, LinearVelocity;

    GoreImpulseScale = 1;
    if((DamageType == none) || Mesh.PhysicsWeight == 0)
    {
        return;
    }
    if(GoreImpulseScale == 0)
    {
        return;
    }
    if(!bHasBrokenConstraints && DamageType.default.KDeathVel > float(0))
    {
        LinearVelocity += (HitDirection * DamageType.default.KDeathVel);
        if(!IsZero(LinearVelocity))
        {
            if(bLogPhysicsBodyImpact)
            {
                LogInternal((("ApplyRagdollImpulse RBLinearVelocity:" @ string(VSize(LinearVelocity))) @ "KDeathVel:") @ string(DamageType.default.KDeathVel));
            }
            Mesh.SetRBLinearVelocity(LinearVelocity, true);
        }
    }
    if(DamageType.default.KDamageImpulse > 0)
    {
        Impulse += (HitDirection * DamageType.default.KDamageImpulse);
    }
    if(DamageType.default.KDeathUpKick > float(0))
    {
        Impulse += (vect(0, 0, 1) * DamageType.default.KDeathUpKick);
    }
    if(DamageType.default.RadialDamageImpulse > 0)
    {
        Impulse += (HitDirection * DamageType.default.RadialDamageImpulse);
        if(HitFxInfo.bRadialDamage && HitFxRadialInfo.RadiusDamageScale < 255)
        {
            Impulse *= ByteToFloat(HitFxRadialInfo.RadiusDamageScale);
        }
    }
    if(bHasBrokenConstraints && Mesh.IsBrokenConstraint(HitBoneName))
    {
        GoreImpulseScale *= DamageType.default.GibImpulseScale;
    }
    Impulse *= (PhysRagdollImpulseScale * GoreImpulseScale);
    if(!IsZero(Impulse))
    {
        if(bLogPhysicsBodyImpact)
        {
            LogInternal((((((("ApplyRagdollImpulse Impulse:" @ string(VSize(Impulse))) @ "Bone:") $ string(HitBoneName)) @ "KDamageImpulse:") $ string(DamageType.default.KDamageImpulse)) @ "RadialDamageImpulse:") $ string(DamageType.default.RadialDamageImpulse));
        }
        Mesh.AddImpulse(Impulse, HitLoc, HitBoneName);
    }
}

simulated function name GetRBBoneFromBoneName(name BoneName)
{
    local int BodyIndex;
    local byte RBBoneCheckCount;
    local name OriginalBoneName;

    OriginalBoneName = BoneName;
    BodyIndex = Mesh.PhysicsAsset.FindBodyIndex(BoneName);
    J0x5A:

    if(BodyIndex == -1)
    {
        BoneName = Mesh.GetParentBone(BoneName);
        if(BoneName == 'None')
        {
            return 'None';
        }
        BodyIndex = Mesh.PhysicsAsset.FindBodyIndex(BoneName);
        if(++ RBBoneCheckCount >= 3)
        {
            LogInternal((((((string(self) @ string(GetFuncName())) @ "Rigidbody bone ") @ string(OriginalBoneName)) @ " not found after") @ string(3)) @ "Checks");
            return 'None';
        }
        goto J0x5A;
    }
    return BoneName;
}

simulated function RagdollArm(bool bUseMotors)
{
    if(PhysicsImpactBlendTimeToGo > 0)
    {
        StopPhysicsBodyImpact();
        bCanPlayPhysicsHitReactions = false;
    }
    Mesh.PhysicsAssetInstance.SetNamedBodiesFixed(false, ArmPhysicsBoneList, Mesh, false, true);
    if(Mesh.PhysicsWeight < 1)
    {
        InitPartialKinematics();
    }
}

event OnRigidBodyLinearConstraintViolated(name StretchedBoneName)
{
    LogInternal("Linear constraint violated, hiding bone " @ string(StretchedBoneName));
}

event OnRigidBodyRefusedToSleep()
{
    local KFGoreManager GM;

    GM = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if(GM != none)
    {
        GM.RemoveAndDeleteCorpse(GM.CorpsePool.Find(self);
    }
}

// Export UKFPawn::execSetRagdollWarningLevel(FFrame&, void* const)
native function SetRagdollWarningLevel(byte WarningLevel);

function Knockdown(optional Vector RBLinearVelocity, optional Vector RBAngularVelocity, optional Vector RadialOrigin, optional float RadialRadius, optional float RadialStrength, optional Vector PointImpulse, optional Vector PointImpulsePosition, optional byte HitZoneIdx)
{
    HitZoneIdx = 255;
    if(Role < ROLE_Authority)
    {
        return;
    }
    if(IsZero(RBLinearVelocity) && IsZero(RBAngularVelocity))
    {
        WarnInternal("No linear or angular velocity - one or the other must be set for replication to work");
        ScriptTrace();
        return;
    }
    if(((Physics == 10) || bPlayedDeath) || DrivenVehicle != none)
    {
        return;
    }
    if(CanDoSpecialMove(6))
    {
        StopFiring();
        KnockdownImpulse.LinearVelocity = RBLinearVelocity;
        KnockdownImpulse.AngularVelocity = RBAngularVelocity;
        if(RadialStrength > float(0))
        {
            KnockdownImpulse.ImpulsePosition = RadialOrigin;
            KnockdownImpulse.ImpulseStrength.X = RadialRadius;
            KnockdownImpulse.ImpulseStrength.Y = RadialStrength;
            KnockdownImpulse.ImpulseStrength.Z = 0;
            KnockdownImpulse.bIsRadialImpulse = true;            
        }
        else
        {
            KnockdownImpulse.ImpulsePosition = PointImpulsePosition;
            KnockdownImpulse.ImpulseStrength = PointImpulse;
            KnockdownImpulse.PointImpulseHitZone = HitZoneIdx;
            KnockdownImpulse.bIsRadialImpulse = false;
        }
        DoSpecialMove(6, true);
    }
}

simulated function KFSkinTypeEffects GetHitZoneSkinTypeEffects(int HitZoneIdx)
{
    local int HitZoneSkinID;

    if(HitZoneIdx != 255)
    {
        HitZoneSkinID = HitZones[HitZoneIdx].SkinID;
    }
    if(HitZoneSkinID >= CharacterArch.ImpactSkins.Length)
    {
        return none;
    }
    return CharacterArch.ImpactSkins[HitZoneSkinID];
}

simulated function AdjustAffliction(out float AfflictionPower);

function HandleAfflictionsOnHit(Controller DamageInstigator, Vector HitDir, class<DamageType> DamageType, Actor DamageCauser)
{
    if(AfflictionHandler != none)
    {
        AfflictionHandler.NotifyTakeHit(DamageInstigator, HitDir, class<KFDamageType>(DamageType), DamageCauser);
    }
}

function ApplyDamageOverTime(int Damage, Controller InstigatedBy, class<KFDamageType> KFDT)
{
    local DamageOverTimeInfo DoTInfo;
    local int DoTIndex, NewDoTDamage, NewTotalDamage, RemainingTotalDamage;
    local float NewDoTDuration;

    DoTIndex = ((KFDT.default.bStackDoT) ? -1 : DamageOverTimeArray.Find('DoT_Type', KFDT.default.DoT_Type);
    NewDoTDamage = Round(float(Damage) * KFDT.default.DoT_DamageScale);
    NewDoTDuration = KFDT.default.DoT_Duration * (GetPerkDoTScaler(InstigatedBy, KFDT));
    if(DoTIndex < 0)
    {
        if(NewDoTDamage > 0)
        {
            DoTInfo.Damage = NewDoTDamage;
            DoTInfo.DamageType = KFDT;
            DoTInfo.DoT_Type = KFDT.default.DoT_Type;
            DoTInfo.Duration = NewDoTDuration;
            DoTInfo.interval = KFDT.default.DoT_Interval;
            DoTInfo.InstigatedBy = InstigatedBy;
            DoTInfo.TimeUntilNextDamage = KFDT.default.DoT_Interval;
            DamageOverTimeArray[DamageOverTimeArray.Length] = DoTInfo;
        }        
    }
    else
    {
        RemainingTotalDamage = int((DamageOverTimeArray[DoTIndex].Duration / DamageOverTimeArray[DoTIndex].interval) * float(DamageOverTimeArray[DoTIndex].Damage));
        NewTotalDamage = int((NewDoTDuration / KFDT.default.DoT_Interval) * float(NewDoTDamage));
        if(NewTotalDamage > RemainingTotalDamage)
        {
            DamageOverTimeArray[DoTIndex].Damage = NewDoTDamage;
            DamageOverTimeArray[DoTIndex].Duration = NewDoTDuration;
            DamageOverTimeArray[DoTIndex].DamageType = KFDT;
        }
    }
}

function float GetPerkDoTScaler(optional Controller InstigatedBy, optional class<KFDamageType> KFDT)
{
    return 1;
}

function TickDamageOverTime(float DeltaTime)
{
    local int I;

    if(DamageOverTimeArray.Length < 1)
    {
        return;
    }
    I = DamageOverTimeArray.Length - 1;
    J0x29:

    if(I >= 0)
    {
        DamageOverTimeArray[I].Duration -= DeltaTime;
        DamageOverTimeArray[I].TimeUntilNextDamage -= DeltaTime;
        if(DamageOverTimeArray[I].TimeUntilNextDamage <= 0)
        {
            DamageOverTimeArray[I].TimeUntilNextDamage = DamageOverTimeArray[I].interval;
            TakeDamage(DamageOverTimeArray[I].Damage, DamageOverTimeArray[I].InstigatedBy, Location, vect(0, 0, 0), DamageOverTimeArray[I].DamageType);
        }
        if((DamageOverTimeArray[I].Duration <= float(0)) || DamageOverTimeArray[I].Duration < DamageOverTimeArray[I].interval)
        {
            DamageOverTimeArray.Remove(I, 1;            
        }
        -- I;
        goto J0x29;
    }
}

simulated function int GetCurrentBattlePhase()
{
    return 0;
}

function AnimInterruptNotifyTimer();

// Export UKFPawn::execPlayBodyAnim(FFrame&, void* const)
native function float PlayBodyAnim(name AnimName, KFPawn.EAnimSlotStance BodyStance, optional float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional bool bOverride)
{
    Rate = 1;
    BlendInTime = 0.2;
    BlendOutTime = 0.2;    
    bOverride = true;                                    
}

// Export UKFPawn::execStopBodyAnim(FFrame&, void* const)
native function StopBodyAnim(KFPawn.EAnimSlotStance BodyStance, optional float BlendOutTime);

// Export UKFPawn::execUpdateMeshTranslationOffset(FFrame&, void* const)
native simulated function bool UpdateMeshTranslationOffset(Vector NewOffset, optional bool bForce);

// Export UKFPawn::execSetHeadTrackTarget(FFrame&, void* const)
native simulated function SetHeadTrackTarget(Actor NewHeadTrackTarget, optional Vector TargetOffset, optional float TargetTrackPct, optional bool bUseSpine, optional float BlendIn)
{
    TargetTrackPct = 1;
    bUseSpine = false;
    BlendIn = -1;                            
}

// Export UKFPawn::execClearHeadTrackTarget(FFrame&, void* const)
native simulated function ClearHeadTrackTarget(Actor HeadTrackTargetToClear, optional float BlendOut)
{
    BlendOut = -1;                
}

// Export UKFPawn::execCacheAnimNodes(FFrame&, void* const)
native simulated event CacheAnimNodes();

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    BodyStanceNodes[0] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_FullBody'));
    BodyStanceNodes[1] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_Upper'));
    BodyStanceNodes[2] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_Lower'));
    if(BodyStanceNodes[2] != none)
    {
        BodyStanceNodes[2].bNoNotifies = true;
    }
    BodyStanceNodes[3] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_Additive'));
    BodyStanceNodes[6] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_Face'));
    IKFootLeft = KFSkelControl_FootPlacement(SkelComp.FindSkelControl('FootIK_L'));
    IKFootRight = KFSkelControl_FootPlacement(SkelComp.FindSkelControl('FootIK_R'));
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        BodyStanceNodes[0].bTickDuringPausedAnims = true;
        BodyStanceNodes[1].bTickDuringPausedAnims = true;
    }
}

simulated event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    if(SpecialMove != 0)
    {
        if((Mesh.TickGroup == 1) && SpecialMoves[SpecialMove].bShouldDeferToPostTick)
        {
            SpecialMoves[SpecialMove].DeferredSeqName = SeqNode.AnimSeqName;
            TWDeferredWorkManager(WorldInfo.DeferredWorkManager).DeferSpecialMoveAnimEnd(SpecialMoves[SpecialMove]);            
        }
        else
        {
            SpecialMoves[SpecialMove].AnimEndNotify(SeqNode, PlayedTime, ExcessTime);
        }
    }
}

simulated function StopAllAnimations()
{
    Mesh.bPauseAnims = true;
    if(Physics == 10)
    {
        Mesh.PhysicsWeight = 1;
        Mesh.bUpdateKinematicBonesFromAnimation = false;
    }
}

final simulated function SetAimOffsetNodesProfile(name NewProfileName)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < AimOffsetNodes.Length)
    {
        AimOffsetNodes[I].SetActiveProfileByName(NewProfileName);
        ++ I;
        goto J0x0B;
    }
}

final simulated function SetDefaultAimOffsetNodesProfile()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < AimOffsetNodes.Length)
    {
        AimOffsetNodes[I].SetActiveProfileByIndex(0);
        ++ I;
        goto J0x0B;
    }
}

simulated function name GetSpecialMoveTag()
{
    local byte AtkIndex;

    if((IsDoingSpecialMove() && SpecialMoveFlags != 255) && PawnAnimInfo != none)
    {
        AtkIndex = byte(SpecialMoveFlags & 15);
        return PawnAnimInfo.Attacks[AtkIndex].Tag;
    }
    return 'None';
}

simulated function UpdateMeshForFleXCollision()
{
    local GameEngine Engine;

    if(bPlayedDeath || Physics == 10)
    {
        return;
    }
    Engine = GameEngine(Class'Engine'.static.GetEngine());
    if((Mesh.RBCollideWithChannels.FlexAsset && Class'Engine'.static.GetPhysXLevel() >= 2) && Engine.GetSystemSettingBool("FlexRigidBodiesCollisionAtHighLevel"))
    {
        Mesh.bUpdateKinematicBonesFromAnimation = true;
        Mesh.MinDistFactorForKinematicUpdate = 0;
    }
}

simulated function SetEnableFleXCollision(bool bEnabled)
{
    return;
}

simulated function OnAnimNotifyParticleSystemSpawned(const AnimNotify_PlayParticleEffect AnimNotifyData, ParticleSystemComponent PSC)
{
    if(IsDoingSpecialMove())
    {
        SpecialMoves[SpecialMove].OnAnimNotifyParticleSystemSpawned(AnimNotifyData, PSC);
    }
}

// Export UKFPawn::execSetHeadScale(FFrame&, void* const)
native simulated function SetHeadScale(float Scale, float OldScale);

// Export UKFPawn::execGetAKRotation(FFrame&, void* const)
native simulated function Rotator GetAKRotation();

// Export UKFPawn::execReplicateSound(FFrame&, void* const)
native simulated function ReplicateSound(AkBaseSoundObject InSoundCue, optional bool bNotReplicated, optional bool bNoRepToOwner, optional bool bStopWhenOwnerDestroyed, optional Vector SoundLocation, optional bool bNoRepToRelevant, optional Rotator SoundRotation);

event Landed(Vector HitNormal, Actor FloorActor)
{
    super(Pawn).Landed(HitNormal, FloorActor);
    if(Velocity.Z < float(-200))
    {
        OldZ = Location.Z;
        bJustLanded = (bUpdateEyeheight && Controller != none) && Controller.LandingShake();
    }
    if(Velocity.Z < -MaxFallSpeed)
    {
        SoundGroupArch.PlayFallingDamageLandSound(self);        
    }
    else
    {
        if(Velocity.Z < (MaxFallSpeed * -0.35))
        {
            SoundGroupArch.PlayLandSound(self);
        }
    }
    SetBaseEyeheight();
}

simulated event PlayFootStepSound(int FootDown)
{
    local Engine.PhysicalMaterialPropertyBase.EMaterialTypes MaterialType;
    local AkBaseSoundObject Sound;
    local Vector FootSoundLoc;

    if((((((WorldInfo.NetMode == NM_DedicatedServer) || Physics != 1) || Base == none) || WorldInfo.bDropDetail) || !bAllowFootstepSounds && Controller != GetALocalPlayerController()) || !ActorEffectIsRelevant(self, false, SoundGroupArch.MaxFootstepSoundRanges.X, SoundGroupArch.MaxFootstepSoundRanges.Y))
    {
        return;
    }
    switch(FootDown)
    {
        case 0:
            FootSoundLoc = Mesh.GetBoneLocation(LeftFootBoneName, 0);
            break;
        case 1:
            FootSoundLoc = Mesh.GetBoneLocation(RightFootBoneName, 0);
            break;
        case 2:
            FootSoundLoc = Mesh.GetBoneLocation(LeftHandBoneName, 0);
            break;
        case 3:
            FootSoundLoc = Mesh.GetBoneLocation(RightHandBoneName, 0);
            break;
        default:
            break;
    }
    MaterialType = GetMaterialBelowFeet(FootSoundLoc);
    if(bIsSprinting)
    {
        Sound = SoundGroupArch.GetSprintingFootstepSound(FootDown, MaterialType);        
    }
    else
    {
        Sound = SoundGroupArch.GetFootstepSound(FootDown, MaterialType);
    }
    if(AkEvent(Sound) != none)
    {
        FootstepAkComponent.PlayEvent(AkEvent(Sound), true);
    }
}

simulated function Engine.PhysicalMaterialPropertyBase.EMaterialTypes GetMaterialBelowFeet(const optional Vector FootSoundLoc)
{
    local Vector HitLocation, HitNormal;
    local TraceHitInfo HitInfo;
    local KFPhysicalMaterialProperty PhysicalProperty;
    local float TraceDist;
    local Vector TraceLoc;

    TraceDist = 1.5 * (GetCollisionHeight());
    TraceLoc = ((IsZero(FootSoundLoc)) ? Location : FootSoundLoc);
    Trace(HitLocation, HitNormal, TraceLoc - (TraceDist * vect(0, 0, 1)), TraceLoc, false,, HitInfo);
    if(HitInfo.PhysMaterial != none)
    {
        PhysicalProperty = KFPhysicalMaterialProperty(HitInfo.PhysMaterial.GetPhysicalMaterialProperty(Class'KFPhysicalMaterialProperty'));
        if(PhysicalProperty != none)
        {
            return PhysicalProperty.MaterialType;
        }
    }
    return 0;
}

simulated function SetPawnAmbientSound(AkEvent NewAmbientSound)
{
    if(NewAmbientSound == none)
    {
        AmbientAkComponent.StopEvents();
        AmbientSound = none;        
    }
    else
    {
        AmbientSound = NewAmbientSound;
        AmbientAkComponent.StopEvents();
        if(NewAmbientSound != none)
        {
            AmbientAkComponent.PlayEvent(AmbientSound, !IsPlayerPawn() || !IsLocallyControlled());
        }
    }
}

simulated function bool IsWeaponAmbientSoundPlaying(AkEvent AmbientSoundToCheck)
{
    return WeaponAkComponent.IsPlaying(AmbientSoundToCheck);
}

simulated function SetWeaponAmbientSound(AkEvent NewAmbientSound, optional AkEvent FirstPersonAmbientSound)
{
    if(NewAmbientSound == none)
    {
        WeaponAkComponent.StopEvents();
        WeaponAmbientSound = none;
        WeaponAmbientEchoHandler.HandleEchoes(none);        
    }
    else
    {
        if((!bPlayedDeath && !bPendingDelete) && !bDeleteMe)
        {
            WeaponAmbientSound = NewAmbientSound;
            WeaponAkComponent.StopEvents();
            if((FirstPersonAmbientSound != none) && IsFirstPerson())
            {
                WeaponAkComponent.OcclusionUpdateInterval = 0;
                WeaponAkComponent.PlayEvent(FirstPersonAmbientSound);
                if(FirstPersonAmbientSound.bUseAdvancedSoundFunctionality)
                {
                    WeaponAmbientEchoHandler.HandleEchoes(FirstPersonAmbientSound);
                }                
            }
            else
            {
                if(NewAmbientSound != none)
                {
                    WeaponAkComponent.OcclusionUpdateInterval = 0.001;
                    SetTimer(0.2, false, 'RestoreOcclusionUpdate');
                    WeaponAkComponent.PlayEvent(NewAmbientSound, false);
                    if(NewAmbientSound.bUseAdvancedSoundFunctionality)
                    {
                        WeaponAmbientEchoHandler.HandleEchoes(NewAmbientSound);
                    }
                }
            }
        }
    }
}

simulated function RestoreOcclusionUpdate()
{
    WeaponAkComponent.OcclusionUpdateInterval = 0.2;
}

simulated function SetSecondaryWeaponAmbientSound(AkEvent NewAmbientSound, optional AkEvent FirstPersonAmbientSound)
{
    if(NewAmbientSound == none)
    {
        SecondaryWeaponAkComponent.StopEvents();
        SecondaryWeaponAmbientSound = none;        
    }
    else
    {
        if((!bPlayedDeath && !bPendingDelete) && !bDeleteMe)
        {
            SecondaryWeaponAmbientSound = NewAmbientSound;
            SecondaryWeaponAkComponent.StopEvents();
            if((FirstPersonAmbientSound != none) && IsFirstPerson())
            {
                SecondaryWeaponAkComponent.OcclusionUpdateInterval = 0;
                SecondaryWeaponAkComponent.PlayEvent(FirstPersonAmbientSound);                
            }
            else
            {
                if(NewAmbientSound != none)
                {
                    SecondaryWeaponAkComponent.OcclusionUpdateInterval = 0.2;
                    SecondaryWeaponAkComponent.PlayEvent(NewAmbientSound, false);
                }
            }
        }
    }
}

simulated function SetPowerUpAmbientSound(AkEvent NewAmbientSound, optional AkEvent FirstPersonAmbientSound, optional AkEvent StopAmbientSound, optional AkEvent FirstPersonStopAmbientSound)
{
    if((((NewAmbientSound == none) && FirstPersonAmbientSound == none) && StopAmbientSound == none) && FirstPersonStopAmbientSound == none)
    {
        PowerUpAmbientSound.FirstPersonPowerUpAmbientSound = none;
        PowerUpAmbientSound.ThirdPersonPowerUpAmbientSound = none;
        PowerUpAmbientSound.FirstPersonStopPowerUpAmbientSound = none;
        PowerUpAmbientSound.ThirdPersonStopPowerUpAmbientSound = none;
        ++ PowerUpAmbientSound.Count;
        PowerUpAkComponent.StopEvents();        
    }
    else
    {
        if((!bPlayedDeath && !bPendingDelete) && !bDeleteMe)
        {
            PowerUpAmbientSound.FirstPersonPowerUpAmbientSound = FirstPersonAmbientSound;
            PowerUpAmbientSound.ThirdPersonPowerUpAmbientSound = NewAmbientSound;
            PowerUpAmbientSound.FirstPersonStopPowerUpAmbientSound = StopAmbientSound;
            PowerUpAmbientSound.ThirdPersonStopPowerUpAmbientSound = FirstPersonStopAmbientSound;
            ++ PowerUpAmbientSound.Count;
            if((FirstPersonAmbientSound != none) && IsFirstPerson())
            {
                PowerUpAkComponent.StopEvents();
                PowerUpAkComponent.OcclusionUpdateInterval = 0;
                PowerUpAkComponent.PlayEvent(FirstPersonAmbientSound);                
            }
            else
            {
                if(NewAmbientSound != none)
                {
                    PowerUpAkComponent.StopEvents();
                    PowerUpAkComponent.OcclusionUpdateInterval = 0.2;
                    PowerUpAkComponent.PlayEvent(NewAmbientSound, false);                    
                }
                else
                {
                    if(FirstPersonStopAmbientSound != none)
                    {
                        PowerUpAkComponent.PlayEvent(FirstPersonStopAmbientSound, IsFirstPerson());
                    }
                    if(StopAmbientSound != none)
                    {
                        PowerUpAkComponent.PlayEvent(StopAmbientSound, IsFirstPerson());
                    }
                }
            }
        }
    }
}

simulated function SetReplicatedPowerUpAmbientSound(PowerUpAmbientSoundInfo PowerUpReplicatedAmbientSound)
{
    if((((PowerUpReplicatedAmbientSound.FirstPersonPowerUpAmbientSound == none) && PowerUpReplicatedAmbientSound.ThirdPersonPowerUpAmbientSound == none) && PowerUpReplicatedAmbientSound.FirstPersonStopPowerUpAmbientSound == none) && PowerUpReplicatedAmbientSound.ThirdPersonStopPowerUpAmbientSound == none)
    {
        PowerUpAkComponent.StopEvents();        
    }
    else
    {
        if((!bPlayedDeath && !bPendingDelete) && !bDeleteMe)
        {
            if((PowerUpReplicatedAmbientSound.FirstPersonPowerUpAmbientSound != none) && IsFirstPerson())
            {
                PowerUpAkComponent.StopEvents();
                PowerUpAkComponent.OcclusionUpdateInterval = 0;
                PowerUpAkComponent.PlayEvent(PowerUpReplicatedAmbientSound.FirstPersonPowerUpAmbientSound);                
            }
            else
            {
                if(PowerUpReplicatedAmbientSound.ThirdPersonPowerUpAmbientSound != none)
                {
                    PowerUpAkComponent.StopEvents();
                    PowerUpAkComponent.OcclusionUpdateInterval = 0.2;
                    PowerUpAkComponent.PlayEvent(PowerUpReplicatedAmbientSound.ThirdPersonPowerUpAmbientSound, false);                    
                }
                else
                {
                    if(PowerUpReplicatedAmbientSound.FirstPersonStopPowerUpAmbientSound != none)
                    {
                        PowerUpAkComponent.PlayEvent(PowerUpReplicatedAmbientSound.FirstPersonStopPowerUpAmbientSound, IsFirstPerson());
                    }
                    if(PowerUpReplicatedAmbientSound.ThirdPersonStopPowerUpAmbientSound != none)
                    {
                        PowerUpAkComponent.PlayEvent(PowerUpReplicatedAmbientSound.ThirdPersonStopPowerUpAmbientSound, IsFirstPerson());
                    }
                }
            }
        }
    }
}

function SetWeaponComponentRTPCValue(string InRTPC, float targetvalue)
{
    WeaponAkComponent.SetRTPCValue(InRTPC, targetvalue);
}

simulated function PlayWeaponSoundEvent(AkEvent NewSoundEvent)
{
    WeaponAkComponent.PlayEvent(NewSoundEvent, true, true);
}

simulated function SetSecondaryWeaponComponentRTPCValue(string InRTPC, float targetvalue)
{
    SecondaryWeaponAkComponent.SetRTPCValue(InRTPC, targetvalue);
}

simulated function PlaySecondaryWeaponSoundEvent(AkEvent NewSoundEvent)
{
    SecondaryWeaponAkComponent.PlayEvent(NewSoundEvent, true, true);
}

simulated function PlayPowerUpSoundEvent(AkEvent NewSoundEvent)
{
    PowerUpAkComponent.PlayEvent(NewSoundEvent, true, true);
}

simulated event Tick(float DeltaTime)
{
    if(Role == ROLE_Authority)
    {
        if(DamageOverTimeArray.Length > 0)
        {
            TickDamageOverTime(DeltaTime);
        }
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(bNeedsProcessHitFx)
        {
            ProcessHitFx();
            bNeedsProcessHitFx = false;
        }
        if(WeaponAmbientEchoHandler.EchoSets.Length > 0)
        {
            WeaponAmbientEchoHandler.TickEchoes();
        }
    }
    if((SpecialMove != 0) && SpecialMoves[SpecialMove] != none)
    {
        SpecialMoves[SpecialMove].Tick(DeltaTime);
    }
    bNeedsProcessHitFx = false;
}

simulated function ProcessHitFx()
{
    local Vector HitDirection;

    if(bPlayedDeath && Mesh.HiddenGame)
    {
        bNeedsProcessHitFx = false;
        return;
    }
    if((HitFxInfo.DamageType != none) && HitFxInfo.DamageType.default.bNoPain)
    {
        PlayHealEffects(HitFxInfo.DamageType);        
    }
    else
    {
        HitDirection = DecodeUnitVector(HitFxInfo.EncodedHitDirection);
        PlayTakeHitEffects(HitDirection, HitFxInfo.HitLocation);
        if(HitFxAddedHitCount > 0)
        {
            ProcessAdditionalHitFx(HitDirection);
        }
    }
    bNeedsProcessHitFx = false;
}

simulated function ProcessAdditionalHitFx(Vector HitDirection)
{
    local byte I, MaxAddedHits;
    local int InjuredHitZone;
    local Vector HitStartLoc, NewHitLocation, NewHitDir;

    MaxAddedHits = byte(Min(HitFxAddedHitCount, 7));
    I = 0;
    J0x27:

    if(I < MaxAddedHits)
    {
        NewHitLocation = HitFxAddedRelativeLocs[I] + HitFxInfo.HitLocation;
        if(HitFxInstigator != none)
        {
            HitStartLoc = HitFxInfo.HitLocation - (HitDirection * VSize(HitFxInfo.HitLocation - HitFxInstigator.Location));
            NewHitDir = Normal(NewHitLocation - HitStartLoc);            
        }
        else
        {
            NewHitDir = HitDirection;
        }
        PlayTakeHitEffects(NewHitDir, NewHitLocation, false);
        ++ I;
        goto J0x27;
    }
    if(bPlayedDeath)
    {
        foreach DamagedHitZones(InjuredHitZone)
        {
            if(!HitZones[InjuredHitZone].bPlayedInjury)
            {
                HitFxInfo.HitBoneIndex = byte(InjuredHitZone);
                PlayTakeHitEffects(HitDirection, HitFxInfo.HitLocation, false);
            }            
        }        
    }
}

function OnStackingAfflictionChanged(byte Id);

// Export UKFPawn::execPlayDialog(FFrame&, void* const)
native function PlayDialog(optional AkEvent DialogEvent, optional byte bCanBeMinimized);

function StopDialog()
{
    PlayDialog();
}

function bool IsSpeaking()
{
    return CurrDialogEventID >= 0;
}

function bool IsPlayingDialogEvent(int EventID)
{
    return (IsSpeaking()) && CurrDialogEventID == EventID;
}

simulated function PlayDialogEvent(AkEvent DialogEvent)
{
    if(VoiceGroupArch == none)
    {
        return;
    }
    DialogAkComponent.StopEvents();
    if(DialogEvent != none)
    {
        DialogAkComponent.PlayEvent(DialogEvent, (Controller != GetALocalPlayerController()) || !PlayerController(Controller).UsingFirstPersonCamera());
    }
}

function HandleDialogResponse();

function bool HasValidVoiceEventData()
{
    return (VoiceGroupArch != none) && VoiceGroupArch.default.EventDataClass != none;
}

function class<KFPawnVoiceGroupEventData> GetVoiceGroupEventDataClass()
{
    if(HasValidVoiceEventData())
    {
        return VoiceGroupArch.default.EventDataClass;
    }
    return none;
}

function EndOfDialogTimer()
{
    HandleDialogResponse();
    CurrDialogEventID = -1;
}

// Export UKFPawn::execIsDoingSpecialMove(FFrame&, void* const)
native final simulated function bool IsDoingSpecialMove(optional KFPawn.ESpecialMove AMove);

simulated event DoSpecialMove(KFPawn.ESpecialMove NewMove, optional bool bForceMove, optional Pawn InInteractionPawn, optional int InSpecialMoveFlags, optional bool bSkipReplication)
{
    if(!bForceMove && Role < ROLE_Authority)
    {
        WarnInternal(((string(self) @ string(GetFuncName())) @ "initiated from client!") @ string(NewMove));
    }
    if(((NewMove == 35) && MyKFWeapon != none) && MyKFWeapon.IsInState('WeaponFiring'))
    {
        return;
    }
    if(SpecialMoveHandler != none)
    {
        SpecialMoveHandler.DoSpecialMove(NewMove, bForceMove, InInteractionPawn, InSpecialMoveFlags, bSkipReplication);
    }
}

reliable server final function ServerDoSpecialMove(KFPawn.ESpecialMove NewMove, optional bool bForceMove, optional Pawn InInteractionPawn, optional byte InSpecialMoveFlags, optional bool bSkipReplication)
{
    DoSpecialMove(NewMove, bForceMove, InInteractionPawn, InSpecialMoveFlags, bSkipReplication);
}

final simulated event EndSpecialMove(optional KFPawn.ESpecialMove SpecialMoveToEnd, optional bool bForceNetSync)
{
    if(SpecialMoveHandler != none)
    {
        SpecialMoveHandler.super(KFPawn).EndSpecialMove(SpecialMoveToEnd, bForceNetSync);
    }
}

simulated event bool CanDoSpecialMove(KFPawn.ESpecialMove AMove, optional bool bForceCheck)
{
    return SpecialMoveHandler.super(KFPawn).CanDoSpecialMove(AMove, bForceCheck);
}

simulated function NotifySpecialMoveEnded(KFSpecialMove FinishedMove, KFPawn.ESpecialMove SMHandle);

simulated event bool IsMovementDisabledDuringSpecialMove()
{
    if(IsDoingSpecialMove())
    {
        return SpecialMoves[SpecialMove].bDisableMovement;
    }
    return false;
}

function bool CanBeGrabbed(KFPawn GrabbingPawn, optional bool bIgnoreFalling, optional bool bAllowSameTeamGrab)
{
    if((((Health <= 0) || (Physics == 2) && !bIgnoreFalling) || !bAllowSameTeamGrab && IsSameTeam(GrabbingPawn)) || IsDoingSpecialMove(31))
    {
        return false;
    }
    if((((GrabbingPawn.MyKFAIC != none) && GrabbingPawn.bWeakZedGrab) && WeakZedGrabCooldown > float(0)) && (WorldInfo.TimeSeconds - WeakZedGrabCooldown) < float(0))
    {
        return false;
    }
    return true;
}

function SetWeakGrabCoolDown(float CoolDownTime)
{
    WeakZedGrabCooldown = FMax(WorldInfo.TimeSeconds + CoolDownTime, WeakZedGrabCooldown);
}

function CausePanicWander();

simulated function bool ShouldBeWandering();

function bool CanAITargetThisPawn(Controller TargetingController)
{
    if(bAIZedsIgnoreMe)
    {
        return false;
    }
    if((ExclusiveTargetingController != none) && ExclusiveTargetingController != TargetingController)
    {
        return false;
    }
    if((AIIgnoreEndTime > float(0)) && (WorldInfo.TimeSeconds - AIIgnoreEndTime) < float(0))
    {
        return false;
    }
    return true;
}

final event KFMessagePlayer(coerce string msg, optional name Type, optional float MsgLifeTime);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Canvas Canvas;

    super(Pawn).DisplayDebug(HUD, out_YL, out_YPos);
    Canvas = HUD.Canvas;
    if(HUD.ShouldDisplayDebug('Camera'))
    {
        HUD.DrawDebugSphere(Instigator.GetPawnViewLocation(), 10, 10, 0, 255, 0);
    }
    if(HUD.ShouldDisplayDebug('Movement'))
    {
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("---------- KFPawn: movement ----------");
        out_YPos += out_YL;
        Canvas.DrawText((("Velocity:" @ string(Velocity)) @ "Accel:") @ string(Acceleration), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Physics:" @ string(Physics), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((((("Walking: " $ string(bIsWalking)) $ " Sprinting: ") $ string(bIsSprinting)) $ " Crouched: ") $ string(bIsCrouched));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("GroundSpeed:" @ string(GroundSpeed), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((("Speed:" @ string(VSize(Velocity))) @ "Speed2D:") @ string(VSize2D(Velocity)), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Pawn state:" @ string(GetStateName()), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Controller state:" @ string(Controller.GetStateName()), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Physics'))
    {
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText(("Velocity:" @ string(VSize(Velocity) / float(100))) @ "Meters Per Second");
        out_YPos += out_YL;
    }
    if(HUD.ShouldDisplayDebug('Rendering'))
    {
        Canvas.SetDrawColor(0, 255, 0);
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("---------- KFPawn: rendering ----------");
        out_YPos += out_YL;
        Canvas.DrawText("Lighting Channels:");
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("-----------------------------");
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Mesh - " $ ((Mesh.LightingChannels.Indoor) ? ((Mesh.LightingChannels.Outdoor) ? "Both Indoor and Outdoor" : "Indoor") : "Outdoor"));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("ThirdPersonHeadMeshComponent - " $ ((ThirdPersonHeadMeshComponent.LightingChannels.Indoor) ? ((ThirdPersonHeadMeshComponent.LightingChannels.Outdoor) ? "Both Indoor and Outdoor" : "Indoor") : "Outdoor"));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("ArmsMesh0 - " $ ((ArmsMesh.LightingChannels.Indoor) ? ((ArmsMesh.LightingChannels.Outdoor) ? "Both Indoor and Outdoor" : "Indoor") : "Outdoor"));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        if(WeaponAttachment != none)
        {
            Canvas.DrawText("WeaponAttachment - " $ ((WeaponAttachment.HasIndoorLighting()) ? ((WeaponAttachment.HasOutdoorLighting()) ? "Both Indoor and Outdoor" : "Indoor") : "Outdoor"));
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);
        }
        if(Weapon != none)
        {
            Canvas.DrawText("Weapon - " $ ((Weapon.Mesh.LightingChannels.Indoor) ? ((Weapon.Mesh.LightingChannels.Outdoor) ? "Both Indoor and Outdoor" : "Indoor") : "Outdoor"));
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('animation'))
    {
        if((Mesh != none) && Mesh.Animations != none)
        {
            Canvas.DrawText("Left Hand IK:" @ string(Mesh.FindSkelControl('HandIK_L').GetControlMetadataWeight()));
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('Perk'))
    {
    }
}

// Export UKFPawn::execShouldCorpseCollideWithDead(FFrame&, void* const)
native static function bool ShouldCorpseCollideWithDead();

// Export UKFPawn::execShouldCorpseCollideWithLiving(FFrame&, void* const)
native static function bool ShouldCorpseCollideWithLiving();

// Export UKFPawn::execShouldCorpseCollideWithDeadAfterSleep(FFrame&, void* const)
native static function bool ShouldCorpseCollideWithDeadAfterSleep();

// Export UKFPawn::execShouldCorpseCollideWithLivingAfterSleep(FFrame&, void* const)
native static function bool ShouldCorpseCollideWithLivingAfterSleep();

static function string GetLocalizedName()
{
    return "";
}

simulated function DetachEmitter(out ParticleSystemComponent Emitter)
{
    if(Emitter != none)
    {
        Emitter.DeactivateSystem();
        DetachComponent(Emitter);
        WorldInfo.MyEmitterPool.OnParticleSystemFinished(Emitter);
        Emitter = none;
    }
}

simulated function ParticleSystemComponent SpawnExtraVFX(ExtraVFXInfo Info)
{
    local name SFXBoneName;
    local editinline ParticleSystemComponent VFXComponent;

    if(Info.SocketName == 'None')
    {
        if(Info.VFX != none)
        {
            VFXComponent = WorldInfo.MyEmitterPool.SpawnEmitter(Info.VFX, Location, Rotation, self);
        }
        if(Info.SFXStartEvent != none)
        {
            PostAkEvent(Info.SFXStartEvent, false, true, false);
        }        
    }
    else
    {
        if(Info.VFX != none)
        {
            VFXComponent = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(Info.VFX, Mesh, Info.SocketName, true);
        }
        if(Info.SFXStartEvent != none)
        {
            SFXBoneName = Mesh.GetSocketBoneName(Info.SocketName);
            if(SFXBoneName != 'None')
            {
                PostAkEventOnBone(Info.SFXStartEvent, SFXBoneName, false, true);                
            }
            else
            {
                PostAkEvent(Info.SFXStartEvent, false, true, false);
            }
        }
    }
    return VFXComponent;
}

simulated function PlayExtraVFX(name FXLabel)
{
    local int I;
    local ExtraVFXAttachmentInfo VFXAttachment;
    local bool bActivatedExistingSystem;

    if((WorldInfo.NetMode == NM_DedicatedServer) || FXLabel == 'None')
    {
        return;
    }
    I = 0;
    J0x4F:

    if(I < ExtraVFXAttachments.Length)
    {
        if(ExtraVFXAttachments[I].Info.Label == FXLabel)
        {
            if(ExtraVFXAttachments[I].VFXComponent != none)
            {
                ExtraVFXAttachments[I].VFXComponent.SetActive(false);
            }
            ExtraVFXAttachments[I].VFXComponent = SpawnExtraVFX(ExtraVFXAttachments[I].Info);
            bActivatedExistingSystem = true;
        }
        ++ I;
        goto J0x4F;
    }
    if(bActivatedExistingSystem)
    {
        return;
    }
    I = 0;
    J0x1A3:

    if(I < CharacterArch.ExtraVFX.Length)
    {
        if(CharacterArch.ExtraVFX[I].Label == FXLabel)
        {
            VFXAttachment.VFXComponent = SpawnExtraVFX(CharacterArch.ExtraVFX[I]);
            VFXAttachment.Info = CharacterArch.ExtraVFX[I];
            ExtraVFXAttachments.AddItem(VFXAttachment;
        }
        ++ I;
        goto J0x1A3;
    }
}

simulated function StopExtraVFX(name FXLabel)
{
    local int I;
    local name SFXBoneName;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    I = 0;
    J0x36:

    if(I < ExtraVFXAttachments.Length)
    {
        if((FXLabel == 'None') || ExtraVFXAttachments[I].Info.Label == FXLabel)
        {
            if(ExtraVFXAttachments[I].VFXComponent != none)
            {
                ExtraVFXAttachments[I].VFXComponent.SetActive(false);
            }
            if(ExtraVFXAttachments[I].Info.SFXStopEvent != none)
            {
                SFXBoneName = Mesh.GetSocketBoneName(ExtraVFXAttachments[I].Info.SocketName);
                if(SFXBoneName != 'None')
                {
                    PostAkEventOnBone(ExtraVFXAttachments[I].Info.SFXStopEvent, SFXBoneName, false, true);                    
                }
                else
                {
                    PostAkEvent(ExtraVFXAttachments[I].Info.SFXStopEvent, false, true, false);
                }
            }
        }
        ++ I;
        goto J0x36;
    }
}

state Dying
{
    ignores Bump, HitWall, HeadVolumeChange, PhysicsVolumeChange, Falling, BreathTimer, 
	    FellOutOfWorld, Timer;

    event OnSleepRBPhysics()
    {
        if(bLogPhysicsBodyImpact)
        {
            LogInternal((((string(self) @ "took") @ string(WorldInfo.TimeSeconds - float(Max(int(LastPainTime), int(TimeOfDeath))))) @ "for RB sleep. WarningLevel=") $ string(RagdollWarningLevel));
        }
        Mesh.bNoSkeletonUpdate = true;
        if(!ShouldCorpseCollideWithLivingAfterSleep())
        {
            Mesh.SetRBCollidesWithChannel(2, false);
        }
    }

    event OnWakeRBPhysics()
    {
        if(bLogPhysicsBodyImpact)
        {
            LogInternal(string(self) @ "wake RB physics");
        }
        SetRagdollWarningLevel(0);
        Mesh.bNoSkeletonUpdate = false;
        if(((TimeOfDeath < WorldInfo.TimeSeconds) && SpecialMove != 7) && !ShouldCorpseCollideWithDeadAfterSleep())
        {
            Mesh.SetRBCollidesWithChannel(16, false);
        }
    }

    event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
    {
        if(DamageType == none)
        {
            DamageType = Class'DamageType';
        }
        Health -= Damage;
        Momentum = Momentum / Mass;
        if((WorldInfo.NetMode != NM_DedicatedServer) || TimeOfDeath == WorldInfo.TimeSeconds)
        {
            SetRagdollWarningLevel(0);
            PlayHit(float(Damage), EventInstigator, HitLocation, DamageType, Momentum, HitInfo);
        }
        if(SpecialMove == 7)
        {
            SpecialMoves[SpecialMove].NotifyOwnerTakeHit(class<KFDamageType>(DamageType), HitLocation, Normal(TearOffMomentum), EventInstigator);
        }
    }

    simulated event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if((WorldInfo.NetMode != NM_DedicatedServer) && Physics == 10)
        {
            ClearTimer();
            bCallRigidBodyWakeEvents = true;
            if(!WorldInfo.bDropDetail && WorldInfo.GetDetailMode() != 0)
            {
                Mesh.SetNotifyRigidBodyCollision(true);
            }
            if(WorldInfo.MyGoreEffectManager != none)
            {
                KFGoreManager(WorldInfo.MyGoreEffectManager).AddCorpse(self);
            }            
        }
        else
        {
            HideMeshOnDeath();
        }
    }
    stop;    
}

defaultproperties
{
    SoundGroupArch=KFPawnSoundGroup'FX_Pawn_Sounds_ARCH.DefaultPawnSounds'
    PawnAnimInfo=KFPawnAnimInfo'ZED_Clot_Anim.AlphaClot_AnimGroup'
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
        bAcceptsDynamicDecals=true
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bAllowAlwaysOnPhysics=true
    bAllowRagdollAndGoreOnDeadBodies=true
    bAllowDeathSM=true
    bAllowSprinting=true
    bWeaponBob=true
    bWeaponAttachmentVisible=true
    bWeakZedGrab=true
    bAllowFootstepSounds=true
    bCanUseHiddenSpeed=true
    PenetrationResistance=1
    CrushScale=1
    VolumeDamageScale=1
    BloodSplatterDecalMaterials(0)=MaterialInstanceConstant'FX_Gore_MAT.FX_CH_BloodSplatter_01_Mic'
    BloodSplatterDecalMaterials(1)=MaterialInstanceConstant'FX_Gore_MAT.FX_CH_BloodSplatter_05_Mic'
    BloodPoolDecalMaterials(0)=MaterialInstanceTimeVarying'FX_Mat_Lib.FX_CH_Bloodpool_DM_TINST'
    LeftFootBoneName=LeftFoot
    RightFootBoneName=RightFoot
    LeftHandBoneName=LeftHand
    RightHandBoneName=RightHand
    HeadBoneName=head
    TorsoBoneName=Spine2
    PelvisBoneName=Spine
    IntendedBodyScale=1
    CurrentBodyScale=1
    BodyScaleChangePerSecond=0.5
    IntendedHeadScale=1
    CurrentHeadScale=1
    begin object name=Afflictions class=KFAfflictionManager
        FireFullyCharredDuration=2.5
        FireCharPercentThreshhold=0.25
    object end
    // Reference: KFAfflictionManager'Default__KFPawn.Afflictions'
    AfflictionHandler=Afflictions
    IncapSettings(0)=(Duration=5,Cooldown=5,ChildAfflictionCooldown=0,Vulnerability=none)
    IncapSettings(1)=(Duration=5,Cooldown=5,ChildAfflictionCooldown=0,Vulnerability=none)
    PhysicsHitReactionImpulseScale=1
    PhysicsImpactBlendOutTime=0.45
    PhysRagdollImpulseScale=1
    SprintSpeed=460
    TeammateCollisionRadiusPercent=0.8
    ZedTimeSpeedScale=1
    AfflictionSpeedModifier=1
    AttackSpeedModifier=1
    NumJumpsAllowed=1
    BaseCrouchEyeHeight=48
    Bob=0.01
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        bIgnoreControllersWhenNotRendered=true
        bOverrideAttachmentOwnerVisibility=true
        bAllowBooleanPreshadows=false
        ReplacementPrimitive=none
        DepthPriorityGroup=ESceneDepthPriorityGroup.SDPG_Foreground
        bOnlyOwnerSee=true
        bAllowPerObjectShadows=true
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    WeaponAttachmentSocket=RW_Weapon
    TurnInPlaceAnimRate=1
    SpecialMoveHandler=KFSpecialMoveHandler'Default__KFPawn.SpecialMoveHandler'
    MeshRotSmoothingInterpSpeed=30
    begin object name=AmbientAkSoundComponent_1 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPawn.AmbientAkSoundComponent_1'
    AmbientAkComponent=AmbientAkSoundComponent_1
    begin object name=AmbientAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.AmbientAkSoundComponent'
    WeaponAkComponent=AmbientAkSoundComponent
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn.WeaponAmbientEchoHandler'
    begin object name=SecondaryWeaponAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.SecondaryWeaponAkSoundComponent'
    SecondaryWeaponAkComponent=SecondaryWeaponAkSoundComponent
    begin object name=FootstepAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.FootstepAkSoundComponent'
    FootstepAkComponent=FootstepAkSoundComponent
    begin object name=DialogAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPawn.DialogAkSoundComponent'
    DialogAkComponent=DialogAkSoundComponent
    begin object name=PowerUpAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.PowerUpAkSoundComponent'
    PowerUpAkComponent=PowerUpAkSoundComponent
    DamageRecoveryTimeHeavy=1
    DamageRecoveryTimeMedium=1
    CurrDialogEventID=-1
    bRespondToExplosions=true
    MaxStepHeight=70
    MaxJumpHeight=128
    bCanCrouch=true
    bCanWalkOffLedges=true
    bLOSHearing=false
    bReplicateHealthToAll=true
    bCanJumpOverWalls=true
    CrouchHeight=60
    CrouchRadius=36
    HearingThreshold=4000
    Mass=65
    GroundSpeed=460
    AirSpeed=460
    JumpZ=650
    AirControl=0.15
    WalkingPct=0.4
    CrouchedPct=0.4
    MaxFallSpeed=1325
    BaseEyeHeight=68
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        MinDistFactorForKinematicUpdate=0.2
        bSkipAllUpdateWhenPhysicsAsleep=true
        bIgnoreControllersWhenNotRendered=true
        bHasPhysicsAssetInstance=true
        bUpdateKinematicBonesFromAnimation=false
        bPerBoneMotionBlur=true
        bOverrideAttachmentOwnerVisibility=true
        bChartDistanceFactor=true
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_Pawn
        RBDominanceGroup=20
        bOwnerNoSee=true
        bAcceptsDynamicDecals=true
        bUseOnePassLightingOnTranslucency=true
        CollideActors=true
        BlockZeroExtent=true
        BlockRigidBody=true
        RBCollideWithChannels=(Default=true,Pawn=true,Vehicle=true,BlockingVolume=true)
        Translation=(X=0,Y=0,Z=-86)
        ScriptRigidBodyCollisionThreshold=200
        PerObjectShadowCullDistance=2500
        bAllowPerObjectShadows=true
        TickGroup=ETickingGroup.TG_DuringAsyncWork
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=86
        CollisionRadius=36
        ReplacementPrimitive=none
        BlockZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFPawn.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    AlwaysRelevantDistanceSquared=1000000
    InventoryManagerClass=Class'KFInventoryManager'
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=86
        CollisionRadius=36
        ReplacementPrimitive=none
        BlockZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFPawn.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        MinDistFactorForKinematicUpdate=0.2
        bSkipAllUpdateWhenPhysicsAsleep=true
        bIgnoreControllersWhenNotRendered=true
        bHasPhysicsAssetInstance=true
        bUpdateKinematicBonesFromAnimation=false
        bPerBoneMotionBlur=true
        bOverrideAttachmentOwnerVisibility=true
        bChartDistanceFactor=true
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_Pawn
        RBDominanceGroup=20
        bOwnerNoSee=true
        bAcceptsDynamicDecals=true
        bUseOnePassLightingOnTranslucency=true
        CollideActors=true
        BlockZeroExtent=true
        BlockRigidBody=true
        RBCollideWithChannels=(Default=true,Pawn=true,Vehicle=true,BlockingVolume=true)
        Translation=(X=0,Y=0,Z=-86)
        ScriptRigidBodyCollisionThreshold=200
        PerObjectShadowCullDistance=2500
        bAllowPerObjectShadows=true
        TickGroup=ETickingGroup.TG_DuringAsyncWork
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    begin object name=AmbientAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.AmbientAkSoundComponent'
    Components(4)=AmbientAkSoundComponent
    begin object name=AmbientAkSoundComponent_1 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPawn.AmbientAkSoundComponent_1'
    Components(5)=AmbientAkSoundComponent_1
    begin object name=FootstepAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.FootstepAkSoundComponent'
    Components(6)=FootstepAkSoundComponent
    begin object name=DialogAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFPawn.DialogAkSoundComponent'
    Components(7)=DialogAkSoundComponent
    begin object name=PowerUpAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.PowerUpAkSoundComponent'
    Components(8)=PowerUpAkSoundComponent
    begin object name=SecondaryWeaponAkSoundComponent class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn.SecondaryWeaponAkSoundComponent'
    Components(9)=SecondaryWeaponAkSoundComponent
    bIgnoreRigidBodyPawns=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=86
        CollisionRadius=36
        ReplacementPrimitive=none
        BlockZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFPawn.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}