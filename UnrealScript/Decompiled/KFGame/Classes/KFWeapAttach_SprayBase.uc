/*******************************************************************************
 * KFWeapAttach_SprayBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeapAttach_SprayBase extends KFWeaponAttachment
    notplaceable
    hidecategories(Navigation,Object,Movement,Attachment,Collision,Physics,Advanced,Debug,Mobile);

struct PilotLight
{
    /** Optional dynamic pilot lights */
    var() export editinline PointLightComponent Light;
    /** Optional dynamic pilot lights */
    var() name LightAttachBone;
    /** Optional dynamic pilot lights */
    var() float FlickerIntensity;
    /** Optional dynamic pilot lights */
    var() float FlickerInterpSpeed;
    /** Optional dynamic pilot lights */
    var() float LastLightBrightness;

    structdefaultproperties
    {
        Light=none
        LightAttachBone=None
        FlickerIntensity=0
        FlickerInterpSpeed=0
        LastLightBrightness=0
    }
};

var protected transient bool bFireSpraying;
var protected bool bPilotLightOn;
var protected bool bInvertPilot;
var protected transient int NextFlamePoolIdx;
var protected transient KFSprayActor FlamePool[2];
var protected transient KFSprayActor ActiveFlameSpray;
/** The Archetype to spawn for our fire spray actors. */
var() protected const KFSprayActor FlameSprayArchetype;
var AkEvent PilotLightPlayEvent;
var AkEvent PilotLightStopEvent;
var protected export editinline KFParticleSystemComponent PSC_PilotLight;
var name PilotLightSocketName;
/** Dynamic light component */
var() KFExplosionLight PilotLightTemplate;
var export editinline transient KFExplosionLightComponent PilotLightComponent;
/** Emitter to play when firing stops. */
var() const export editinline ParticleSystemComponent PSC_EndSpray;
var float BarrelHeat;
var float LastBarrelHeat;
var(PilotLights) transient array<PilotLight> PilotLights;

simulated function SetFlameDebugDamage(bool bDebugDirectDamage, bool bDebugSplashDamage, bool bDebugShowSplashRadius, bool bDebugShowCollision);

simulated function SetFlameDebugFX(bool bDebugShowSeeds, bool bDebugShowBones, bool bDebugForceNonPlayerParticles);

simulated event PreBeginPlay()
{
    super.PreBeginPlay();
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if((WeaponMIC == none) && WeapMesh != none)
    {
        WeaponMIC = WeapMesh.CreateAndSetMaterialInstanceConstant(0);
    }
}

protected simulated function TurnOnPilot()
{
    local Vector MuzzleLoc;
    local Rotator Aim;
    local int Idx;

    if(bPilotLightOn)
    {
        return;
    }
    StartPilotSound();
    if(PSC_PilotLight != none)
    {
        WeapMesh.AttachComponentToSocket(PSC_PilotLight, PilotLightSocketName);
        PSC_PilotLight.ActivateSystem();
        PSC_PilotLight.SetFloatParameter('Pilotlow', 1);
        PSC_PilotLight.SetFloatParameter('Pilothigh', 0);
    }
    if(Class'KFWeap_FlameBase'.default.bArePilotLightsAllowed)
    {
        Idx = 0;
        J0x100:

        if(Idx < PilotLights.Length)
        {
            WeapMesh.AttachComponentToSocket(PilotLights[Idx].Light, PilotLights[Idx].LightAttachBone);
            ++ Idx;
            goto J0x100;
        }        
    }
    else
    {
        PilotLights.Remove(0, PilotLights.Length;
    }
    SetPilotDynamicLightEnabled(true);
    GetFlameSocketLocAndRot(MuzzleLoc, Aim);
    if(FlamePool[0] == none)
    {
        FlamePool[0] = Spawn(FlameSprayArchetype.Class, Instigator,, MuzzleLoc, Aim, FlameSprayArchetype, true);
    }
    if(FlamePool[1] == none)
    {
        FlamePool[1] = Spawn(FlameSprayArchetype.Class, Instigator,, MuzzleLoc, Aim, FlameSprayArchetype, true);
    }
    FlamePool[0].AttachToMesh(self, WeapMesh, FlamePool[0].SpraySocketName);
    FlamePool[1].AttachToMesh(self, WeapMesh, FlamePool[1].SpraySocketName);
    FlamePool[0].bVisualOnly = true;
    FlamePool[1].bVisualOnly = true;
    if(PSC_EndSpray != none)
    {
        PSC_EndSpray.SetTemplate(FlamePool[0].SprayEndEffect);
        WeapMesh.AttachComponentToSocket(PSC_EndSpray, FlamePool[0].SpraySocketName);
    }
    bPilotLightOn = true;
}

simulated function GetFlameSocketLocAndRot(out Vector out_Loc, out Rotator out_Rot)
{
    if((WeapMesh != none) && FlameSprayArchetype.Class.default.SpraySocketName != 'None')
    {
        WeapMesh.GetSocketWorldLocationAndRotation(FlameSprayArchetype.Class.default.SpraySocketName, out_Loc, out_Rot);        
    }
    else
    {
        out_Loc = Instigator.Location;
        out_Rot = Instigator.Rotation;
    }
}

protected simulated function TurnOffPilot()
{
    if(PSC_PilotLight != none)
    {
        PSC_PilotLight.DeactivateSystem();
    }
    StopPilotSound();
    SetPilotDynamicLightEnabled(false);
    bPilotLightOn = false;
}

protected simulated function KFSprayActor GetFlameSprayFromPool()
{
    local KFSprayActor Ret;

    Ret = FlamePool[NextFlamePoolIdx];
    ++ NextFlamePoolIdx;
    if(NextFlamePoolIdx >= 2)
    {
        NextFlamePoolIdx = 0;
    }
    return Ret;
}

simulated function StartPilotSound()
{
    if((Instigator != none) && !Instigator.IsFirstPerson())
    {
        if(PilotLightPlayEvent != none)
        {
            Instigator.PlaySoundBase(PilotLightPlayEvent, true, true, true,, true);
        }
    }
}

simulated function StopPilotSound()
{
    if(PilotLightStopEvent != none)
    {
        Instigator.PlaySoundBase(PilotLightStopEvent, true, true, true,, true);
    }
}

simulated function SetPilotDynamicLightEnabled(bool bLightEnabled)
{
    local int Idx;
    local bool doEnable;

    doEnable = bLightEnabled;
    if(bInvertPilot)
    {
        doEnable = bLightEnabled == false;
    }
    if(doEnable && (Instigator != none) && Instigator.IsFirstPerson())
    {
        return;
    }
    Idx = 0;
    J0x89:

    if(Idx < PilotLights.Length)
    {
        PilotLights[Idx].Light.SetEnabled(doEnable);
        ++ Idx;
        goto J0x89;
    }
}

protected simulated function TurnOnFireSpray()
{
    if(!bDeleteMe && !bFireSpraying)
    {
        ActiveFlameSpray = GetFlameSprayFromPool();
        if(ActiveFlameSpray != none)
        {
            ActiveFlameSpray.BeginSpray();            
        }
        else
        {
            WarnInternal(string(GetFuncName()) @ "ActiveFlameSpray is NONE!!!");
        }
        StopPilotSound();
        SetPilotDynamicLightEnabled(false);
        bFireSpraying = true;
    }
}

protected simulated function TurnOffFireSpray()
{
    if(PSC_EndSpray != none)
    {
        PSC_EndSpray.ActivateSystem();
    }
    if(ActiveFlameSpray != none)
    {
        ActiveFlameSpray.DetachAndFinish();
    }
    if(!bDeleteMe)
    {
        StartPilotSound();
        SetPilotDynamicLightEnabled(true);
    }
    bFireSpraying = false;
}

simulated function bool ThirdPersonFireEffects(Vector HitLocation, KFPawn P, byte ThirdPersonAnimRateByte)
{
    local bool bResult;

    bResult = super.ThirdPersonFireEffects(HitLocation, P, ThirdPersonAnimRateByte);
    if((P.FiringMode != 1) && P.ActorEffectIsRelevant(P, false, 15000, 2000))
    {
        TurnOnFireSpray();
        bResult = true;
    }
    return bResult;
}

simulated function StopThirdPersonFireEffects(optional bool bForce)
{
    TurnOffFireSpray();
    super.StopThirdPersonFireEffects(bForce);
}

simulated function AttachTo(KFPawn P)
{
    super.AttachTo(P);
    TurnOnPilot();
}

simulated function DetachFrom(KFPawn P)
{
    if(bFireSpraying)
    {
        TurnOffFireSpray();
    }
    TurnOffPilot();
    super.DetachFrom(P);
}

simulated function Destroyed()
{
    local int Idx;

    if(bFireSpraying)
    {
        TurnOffFireSpray();
    }
    Idx = 0;
    J0x22:

    if(Idx < 2)
    {
        if(FlamePool[Idx] != none)
        {
            FlamePool[Idx].Destroy();
            FlamePool[Idx] = none;
        }
        ++ Idx;
        goto J0x22;
    }
    StopPilotSound();
    super(Actor).Destroyed();
}

simulated function float GetFlickerVal(float BaseVal, float Intensity, float Last, float DeltaTime, float InterpSpeed)
{
    local float GoalVal;

    GoalVal = BaseVal + RandRange(-Intensity, Intensity);
    return FInterpTo(Last, GoalVal, DeltaTime, InterpSpeed);
}

simulated event Tick(float DeltaTime)
{
    local int Idx;
    local float FlameHeat;

    super.Tick(DeltaTime);
    if((WorldInfo.NetMode != NM_DedicatedServer) && WeaponMIC != none)
    {
        if(bFireSpraying && ActiveFlameSpray != none)
        {
            FlameHeat = GetRangeValueByPct(ActiveFlameSpray.MaterialHeatRange, FMin(ActiveFlameSpray.CurrentAge / ActiveFlameSpray.MaterialHeatRampTime, 1)) * 3.5;
            if(BarrelHeat < FlameHeat)
            {
                BarrelHeat += (DeltaTime * 2);                
            }
            else
            {
                BarrelHeat = FlameHeat;
            }            
        }
        else
        {
            if(BarrelHeat > float(0))
            {
                BarrelHeat -= (DeltaTime * 0.5);
                if(BarrelHeat < float(0))
                {
                    BarrelHeat = 0;
                }
            }
        }
        ChangeMaterial();
        LastBarrelHeat = BarrelHeat;
    }
    Idx = 0;
    J0x1A8:

    if(Idx < PilotLights.Length)
    {
        if(PilotLights[Idx].Light != none)
        {
            PilotLights[Idx].LastLightBrightness = FMax(0, GetFlickerVal(default.PilotLights[Idx].Light.Brightness, PilotLights[Idx].FlickerIntensity, PilotLights[Idx].LastLightBrightness, DeltaTime, PilotLights[Idx].FlickerInterpSpeed));
            PilotLights[Idx].Light.SetLightProperties(PilotLights[Idx].LastLightBrightness, PilotLights[Idx].Light.LightColor, PilotLights[Idx].Light.Function);
        }
        ++ Idx;
        goto J0x1A8;
    }
}

simulated function ChangeMaterial()
{
    if(BarrelHeat != LastBarrelHeat)
    {
        WeaponMIC.SetScalarParameterValue('Glow_Intensity', BarrelHeat);
    }
}

simulated event ChangeVisibility(bool bIsVisible)
{
    super.ChangeVisibility(bIsVisible);
    if(bIsVisible)
    {
        TurnOnPilot();        
    }
    else
    {
        TurnOffPilot();
    }
}

defaultproperties
{
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
        TickGroup=ETickingGroup.TG_PostUpdateWork
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeapAttach_SprayBase.PilotLight0'
    PSC_PilotLight=PilotLight0
    begin object name=FlameEndSpray0 class=ParticleSystemComponent
        bAutoActivate=false
        ReplacementPrimitive=none
        TickGroup=ETickingGroup.TG_PostUpdateWork
    object end
    // Reference: ParticleSystemComponent'Default__KFWeapAttach_SprayBase.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__KFWeapAttach_SprayBase.SkeletalMeshComponent0.MeshSequenceA'
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFWeapAttach_SprayBase.SkeletalMeshComponent0'
    WeapMesh=SkeletalMeshComponent0
    CollisionType=ECollisionType.COLLIDE_CustomDefault
}