/*******************************************************************************
 * KFGFxHUD_TraderCompass generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGFxHUD_TraderCompass extends GFxObject within GFxMoviePlayer;

const TraderPing_LeftSide = -1.0f;
const TraderPing_RightSide = 1.0f;
const PingMinRenderDistSq = 100000.f;

var PlayerController MyPC;
var KFGameReplicationInfo MyKFGRI;
var private GFxObject TraderPing;
var float LastDistToTrader;
var byte LastArrowDirection;
var float LastViewAngleDotProduct;
var const localized string TraderString;

event bool WidgetInitialized(name WidgetName, name WidgetPath, GFxObject Widget)
{
    super.WidgetInitialized(WidgetName, WidgetPath, Widget);
    switch(WidgetName)
    {
        case 'CompassPingAnimContainer':
            if(TraderPing == none)
            {
                TraderPing = Widget;
            }
            break;
        default:
            break;
    }
    return true;
}

function InitializeHUD()
{
    MyPC = Outer.GetPC();
    SetString("traderText", TraderString);
}

function TickHud(float DeltaTime)
{
    UpdateTraderCompassPosition();
    UpdateDistanceToTrader();
}

function Vector GetCurrentTraderLocation()
{
    local Vector TraderLoc;

    if(MyPC == none)
    {
        return vect(0, 0, 0);
    }
    if(MyKFGRI == none)
    {
        MyKFGRI = KFGameReplicationInfo(MyPC.WorldInfo.GRI);
    }
    if((MyKFGRI != none) && (MyKFGRI.OpenedTrader != none) || MyKFGRI.NextTrader != none)
    {
        TraderLoc = ((MyKFGRI.OpenedTrader != none) ? MyKFGRI.OpenedTrader.Location : MyKFGRI.NextTrader.Location);
    }
    return TraderLoc;
}

function UpdateDistanceToTrader()
{
    local float CurrentDistToTrader;
    local Vector TraderLoc;
    local Actor LocActor;

    if(MyPC != none)
    {
        LocActor = ((MyPC.ViewTarget != none) ? MyPC.ViewTarget : MyPC);
        TraderLoc = GetCurrentTraderLocation();
        CurrentDistToTrader = ((IsZero(TraderLoc)) ? -1 : VSize(TraderLoc - LocActor.Location) / 100);
        if(CurrentDistToTrader != LastDistToTrader)
        {
            SetInt("distanceToTrader", int(CurrentDistToTrader));
            LastDistToTrader = CurrentDistToTrader;
        }
    }
}

function UpdateTraderCompassPosition()
{
    local Vector CameraLoc;
    local Rotator CameraRot;
    local Vector TraderLocation;
    local float TraderAngle;
    local Vector NormalizedViewDir;
    local float ViewAngleDotProduct;
    local bool ShowPing;
    local byte CurrentArrowdirection;

    if(MyPC != none)
    {
        TraderLocation = GetCurrentTraderLocation();
        if(IsZero(TraderLocation))
        {
            return;
        }
        MyPC.GetPlayerViewPoint(CameraLoc, CameraRot);
        CameraRot.Yaw = CameraRot.Yaw & 65535;
        CameraRot.Roll = 0;
        CameraRot.Pitch = 0;
        CurrentArrowdirection = 0;
        NormalizedViewDir = Normal((TraderLocation - CameraLoc) << CameraRot);
        ViewAngleDotProduct = Normal(TraderLocation - CameraLoc) Dot vector(CameraRot);
        if(ViewAngleDotProduct != LastViewAngleDotProduct)
        {
            LastViewAngleDotProduct = ViewAngleDotProduct;
            if(NormalizedViewDir.Y > float(0))
            {
                if(ViewAngleDotProduct < 0)
                {
                    TraderAngle = 1;
                    CurrentArrowdirection = 4;                    
                }
                else
                {
                    TraderAngle = 1 * (1 - ViewAngleDotProduct);
                }                
            }
            else
            {
                if(ViewAngleDotProduct < 0)
                {
                    TraderAngle = -1;
                    CurrentArrowdirection = 3;                    
                }
                else
                {
                    TraderAngle = -1 * (1 - ViewAngleDotProduct);
                }
            }
            if(TraderPing != none)
            {
                ShowPing = VSizeSq(TraderLocation - CameraLoc) > 100000;
                TraderPing.SetVisible(ShowPing);
                if(ShowPing)
                {
                    SetFloat("traderAngle", TraderAngle);
                }
            }
        }
        if(Abs(TraderLocation.Z - CameraLoc.Z) > 86)
        {
            CurrentArrowdirection = ((TraderLocation.Z > CameraLoc.Z) ? 1 : 2);
        }
        if(CurrentArrowdirection != LastArrowDirection)
        {
            SetInt("arrowDirection", CurrentArrowdirection);
            LastArrowDirection = CurrentArrowdirection;
        }
    }
}

defaultproperties
{
    TraderString="TRADER"
}