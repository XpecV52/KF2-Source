/*******************************************************************************
 * KFSM_GrappleStart generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_GrappleStart extends KFSM_PlaySingleAnim;

var float MaxGrabDistance;
var bool bCanBeBlocked;

function bool CanOverrideMoveWith(name NewMove)
{
    if(!bUseRootMotion && (NewMove == 'KFSM_Stunned') || NewMove == 'KFSM_Stumble')
    {
        return true;
    }
    return false;
}

function PlayAnimation()
{
    local float GrabCheckTime;

    if((PawnOwner.Role == ROLE_Authority) && AIOwner != none)
    {
        GrabCheckTime = KFSkeletalMeshComponent(PawnOwner.Mesh).GetAnimInterruptTime(AnimName);
        if(GrabCheckTime <= float(0))
        {
            WarnInternal((((("Failed to play" @ string(AnimName)) @ "on special move") @ string(self)) @ "on Pawn") @ string(PawnOwner));
            PawnOwner.SetTimer(0.25, false, 'AbortSpecialMove', self);
            return;
        }
        PawnOwner.SetTimer(GrabCheckTime, false, 'CheckGrapple', self);
    }
    super.PlayAnimation();
}

function CheckGrapple()
{
    local Vector ToEnemy, HitLocation, HitNormal;
    local Actor HitActor;
    local KFPawn Victim;
    local byte SpecialMoveFlags;

    if(((AIOwner != none) && AIOwner.Enemy != none) && AIOwner.Enemy.IsAliveAndWell())
    {
        ToEnemy = PawnOwner.Location - AIOwner.Enemy.Location;
        Victim = KFPawn(AIOwner.Enemy);
        if(((Victim != none) && (bCanBeBlocked && Victim.MyKFWeapon != none) && Victim.MyKFWeapon.IsGrappleBlocked(PawnOwner)) || !Victim.CanBeGrabbed(KFPOwner, true))
        {
            return;
        }
        if(VSizeSq(ToEnemy) <= Square(MaxGrabDistance))
        {
            HitActor = PawnOwner.Trace(HitLocation, HitNormal, AIOwner.Enemy.Location, PawnOwner.Location, true);
            if((HitActor == none) || HitActor == AIOwner.Enemy)
            {
                SpecialMoveFlags = Class'KFSM_GrappleAttack'.static.PackSMFlags();
                KFPOwner.DoSpecialMove(4, true, AIOwner.Enemy, SpecialMoveFlags);
            }
        }
    }
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    PawnOwner.ClearTimer('CheckGrapple', self);
    super.SpecialMoveEnded(PrevMove, NextMove);
}

function NotifyOwnerTakeHit(class<KFDamageType> DamageType, Vector HitLoc, Vector HitDir, Controller InstigatedBy)
{
    if(bCanBeInterrupted && IsAnInterruptHit(PawnOwner, DamageType))
    {
        if(KFPOwner.CanDoSpecialMove(5))
        {
            KFPOwner.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(KFPOwner, HitDir));
        }
    }
}

defaultproperties
{
    MaxGrabDistance=210
    bCanBeBlocked=true
    AnimName=Grab
    bCanBeInterrupted=true
    bLockPawnRotation=true
}