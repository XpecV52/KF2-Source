/*******************************************************************************
 * KFGFxMenu_Perks generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGFxMenu_Perks extends KFGFxObject_Menu within GFxMoviePlayer;

var KFGFxPerksContainer_Selection SelectionContainer;
var KFGFxPerksContainer_Header HeaderContainer;
var KFGFxPerksContainer_Details DetailsContainer;
var KFGFxPerksContainer_Skills SkillsContainer;
var KFGFxPerksContainer_SkillsSummary SkillsSummaryContainer;
var KFPlayerController KFPC;
var const string LockIconPath;
var byte LastPerkIndex;
var byte LastPerkLevel;
var byte SelectedSkillsHolder[5];
var class<KFPerk> PreviousPerk;
var const localized string TierUnlockedText;
var const localized string TierUnlockedSecondaryText;
var bool bModifiedSkills;
var bool bModifiedPerk;
var bool bChangesMadeDuringLobby;
var name PerkLevelupSound;

event bool WidgetInitialized(name WidgetName, name WidgetPath, GFxObject Widget)
{
    local class<KFPerk> PerkClass;

    PerkClass = KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass;
    switch(WidgetName)
    {
        case 'HeaderContainer':
            if(HeaderContainer == none)
            {
                HeaderContainer = KFGFxPerksContainer_Header(Widget);
                HeaderContainer.Initialize(self);
            }
            break;
        case 'SelectionContainer':
            if(SelectionContainer == none)
            {
                SelectionContainer = KFGFxPerksContainer_Selection(Widget);
                SelectionContainer.Initialize(self);
            }
            break;
        case 'DetailsContainer':
            if(DetailsContainer == none)
            {
                DetailsContainer = KFGFxPerksContainer_Details(Widget);
                DetailsContainer.Initialize(self);
                DetailsContainer.UpdateDetails(PerkClass);
                DetailsContainer.UpdatePassives(PerkClass);
            }
            break;
        case 'SkillsContainer':
            if(SkillsContainer == none)
            {
                SkillsContainer = KFGFxPerksContainer_Skills(Widget);
                SkillsContainer.Initialize(self);
                SkillsContainer.UpdateSkills(PerkClass, SelectedSkillsHolder);
            }
        case 'NextRankContainer':
            break;
        case 'SelectedPerkSummaryContainer':
            if(SkillsSummaryContainer == none)
            {
                SkillsSummaryContainer = KFGFxPerksContainer_SkillsSummary(Widget);
                SkillsSummaryContainer.Initialize(self);
                SkillsSummaryContainer.UpdateSkills(PerkClass, SelectedSkillsHolder);
            }
            break;
        default:
            break;
    }
    return true;
}

function OnOpen()
{
    if(KFPC == none)
    {
        KFPC = KFPlayerController(Outer.GetPC());
    }
    LastPerkIndex = KFPC.SavedPerkIndex;
    UpdateSkillsHolder(KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass);
    UpdateContainers(KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass);
    UpdateLock();
    CheckTiersForPopup();
}

function CheckTiersForPopup()
{
    local array<string> UnlockedPerkNames;
    local byte bTierUnlocked;
    local string SecondaryPopupText;
    local byte I;
    local class<KFPerk> PerkClass;
    local int UnlockedPerkLevel;

    I = 0;
    J0x0C:

    if(I < KFPC.PerkList.Length)
    {
        PerkClass = KFPC.PerkList[I].PerkClass;
        Class'KFPerk'.static.LoadTierUnlockFromConfig(PerkClass, bTierUnlocked, UnlockedPerkLevel);
        if(bool(bTierUnlocked) && KFPC.PerkList[I].PerkLevel >= UnlockedPerkLevel)
        {
            UnlockedPerkNames.AddItem(PerkClass.default.PerkName;
        }
        ++ I;
        goto J0x0C;
    }
    if(UnlockedPerkNames.Length > 0)
    {
        I = 0;
        J0x16E:

        if(I < UnlockedPerkNames.Length)
        {
            if(I > 0)
            {
                SecondaryPopupText = (SecondaryPopupText $ ",") @ UnlockedPerkNames[I];                
            }
            else
            {
                SecondaryPopupText = TierUnlockedSecondaryText @ UnlockedPerkNames[I];
            }
            ++ I;
            goto J0x16E;
        }
        KFPC.MyGFxManager.OpenPopup(2, TierUnlockedText, SecondaryPopupText, Class'KFCommon_LocalizedStrings'.default.OKString,,,,,, PerkLevelupSound);
    }
}

event OnClose()
{
    if(KFPC != none)
    {
        if(bModifiedPerk || bModifiedSkills)
        {
            SavePerkData();
            if(KFPC.CanUpdatePerkInfo())
            {
                if(!bChangesMadeDuringLobby)
                {
                    KFPC.NotifyPerkUpdated();
                }
            }
            if(IsMatchStarted())
            {
                KFPC.SetHaveUpdatePerk(true);
            }
            bModifiedPerk = false;
            bModifiedSkills = false;
        }
    }
    super.OnClose();
}

event OnTraderTimeStart()
{
    UpdateLock();
}

function bool IsMatchStarted()
{
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(Outer.GetPC().WorldInfo.GRI);
    return (KFGRI != none) && KFGRI.bMatchHasBegun;
}

function PerkChanged(byte NewPerkIndex, bool bClickedIndex)
{
    if(KFPC != none)
    {
        if(bClickedIndex)
        {
            SavePerkData();
        }
        UpdateSkillsHolder(KFPC.PerkList[NewPerkIndex].PerkClass);
        LastPerkIndex = NewPerkIndex;
        bChangesMadeDuringLobby = !IsMatchStarted();
        bModifiedPerk = true;
        if(bClickedIndex)
        {
            SelectionContainer.SavePerk(NewPerkIndex);
        }
        UpdateContainers(KFPC.PerkList[NewPerkIndex].PerkClass, bClickedIndex);
    }
}

function OneSecondLoop()
{
    if(KFPC != none)
    {
        if((PreviousPerk == KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass) && LastPerkLevel != KFPC.PerkList[KFPC.SavedPerkIndex].PerkLevel)
        {
            UpdateContainers(KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass);
            PreviousPerk = KFPC.PerkList[KFPC.SavedPerkIndex].PerkClass;
            LastPerkLevel = KFPC.PerkList[KFPC.SavedPerkIndex].PerkLevel;
            return;
        }
    }
}

function UpdateLock()
{
    local WorldInfo TempWorldInfo;
    local KFGameReplicationInfo KFGRI;

    TempWorldInfo = Class'WorldInfo'.static.GetWorldInfo();
    if((TempWorldInfo != none) && TempWorldInfo.GRI != none)
    {
        KFGRI = KFGameReplicationInfo(TempWorldInfo.GRI);
        if((KFGRI != none) && KFPC != none)
        {
            SetBool("locked", KFGRI.bTraderIsOpen && KFPC.bPlayerUsedUpdatePerk);
        }
    }
}

function UpdateContainers(class<KFPerk> PerkClass, optional bool bClickedIndex)
{
    bClickedIndex = true;
    if(KFPC != none)
    {
        if(HeaderContainer != none)
        {
            HeaderContainer.UpdatePerkHeader(PerkClass);
        }
        if(DetailsContainer != none)
        {
            DetailsContainer.UpdateDetails(PerkClass);
            DetailsContainer.UpdatePassives(PerkClass);
        }
        if((SelectionContainer != none) && bClickedIndex)
        {
            SelectionContainer.UpdatePerkSelection(KFPC.SavedPerkIndex);
        }
        UpdateSkillsUI(PerkClass);
    }
}

function UpdateSkillsUI(class<KFPerk> PerkClass)
{
    if(SkillsContainer != none)
    {
        SkillsContainer.UpdateSkills(PerkClass, SelectedSkillsHolder);
    }
    if(SkillsSummaryContainer != none)
    {
        SkillsSummaryContainer.UpdateSkills(PerkClass, SelectedSkillsHolder);
    }
}

function UpdateSkillsHolder(class<KFPerk> PerkClass)
{
    local int PerkBuild;

    if(KFPC == none)
    {
        KFPC = KFPlayerController(Outer.GetPC());
    }
    PerkBuild = KFPC.GetPerkBuildByPerkClass(PerkClass);
    KFPC.GetPerk().GetUnpackedSkillsArray(PerkClass, PerkBuild, SelectedSkillsHolder);
}

function SavePerkData()
{
    if(KFPC != none)
    {
        if(bModifiedSkills)
        {
            KFPC.CurrentPerk.UpdatePerkBuild(SelectedSkillsHolder, KFPC.PerkList[LastPerkIndex].PerkClass);
            if(!KFPC.CanUpdatePerkInfo())
            {
                KFPC.NotifyPendingPerkChanges();
            }
            bModifiedSkills = false;
        }
        KFPC.ClientWriteAndFlushStats();
    }
}

function Callback_ReadyClicked(bool bReady)
{
    SavePerkData();
    super.Callback_ReadyClicked(bReady);
}

function Callback_PerkSelected(byte NewPerkIndex, bool bClickedIndex)
{
    if((LastPerkIndex != NewPerkIndex) || bClickedIndex)
    {
        PerkChanged(NewPerkIndex, bClickedIndex);
    }
}

function Callback_SkillSelected(byte TierIndex, byte SkillIndex)
{
    if(KFPC != none)
    {
        bModifiedSkills = true;
        bChangesMadeDuringLobby = !IsMatchStarted();
        SelectedSkillsHolder[TierIndex] = SkillIndex;
        UpdateSkillsUI(KFPC.PerkList[LastPerkIndex].PerkClass);
    }
}

function Callback_SkillSelectionOpened()
{
    if(SkillsContainer != none)
    {
        SkillsContainer.UpdateTierUnlockState(KFPC.PerkList[LastPerkIndex].PerkClass);
    }
}

defaultproperties
{
    LockIconPath="ui_perktalent_tex.UI_PerkTalent_Locked"
    LastPerkIndex=255
    LastPerkLevel=255
    TierUnlockedText="New Tier Unlocked!"
    TierUnlockedSecondaryText="You have unlocked a new tier for the following perks:"
    PerkLevelupSound=LevelUp_Popup
    SubWidgetBindings=/* Array type was not detected. */
}