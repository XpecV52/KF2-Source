/*******************************************************************************
 * AICommand_Hide generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Hide extends AICommand within KFAIController;

var Actor HideTarget;
var float Dot;
var bool bLoop;
var bool bWasSprinting;
var int PathAttempts;
var float HideDuration;

static function bool HideFrom(KFAIController AI, Actor InHideTarget, optional float inHideDuration, optional bool bInLoop)
{
    local AICommand_Hide Cmd;

    bInLoop = true;
    if(AI != none)
    {
        Cmd = new (AI) default.Class;
        if(Cmd != none)
        {
            Cmd.HideDuration = inHideDuration;
            Cmd.HideTarget = InHideTarget;
            Cmd.bLoop = bInLoop;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    bWasSprinting = Outer.MyKFPawn.bIsSprinting;
    Outer.DisableMeleeRangeEventProbing();
    Outer.MoveTimer = -1;
    Outer.Pawn.ZeroMovementVariables();
    Outer.StopAllLatentMovement();
    if(HideDuration > 0)
    {
        Outer.SetTimer(HideDuration, false, 'Timer_HideDurationExpired', self);
    }
    Outer.SetTimer(0.1 + (0.4 * FRand()), false, 'StartHiding', self);
}

function Timer_HideDurationExpired()
{
    Status = 'Success';
    Outer.AIZeroMovementVariables(true);
    Outer.StopAllLatentMovement();
    GotoState('Hiding', 'HideComplete');
}

function StartHiding()
{
    GotoState('Hiding');
}

function Popped()
{
    super.Popped();
    Outer.MyKFPawn.bIsSprinting = bWasSprinting;
    Outer.MyKFPawn.ClearHeadTrackTarget(HideTarget);
    Outer.EnableMeleeRangeEventProbing();
}

state Hiding
{
    event BeginState(name PreviousStateName)
    {
        super(Object).BeginState(PreviousStateName);
        Outer.AIActionStatus = "In DebugHiding state";
        if(Outer.Enemy == none)
        {
            Outer.Enemy = Outer.GetClosestEnemy();
        }
    }

    function bool CheckRetreat()
    {
        if(HideTarget != none)
        {
            Class'Path_AlongLine'.static.AlongLine(Outer.Pawn, -Normal(HideTarget.Location - Outer.Pawn.Location));
            Class'Goal_AwayFromPosition'.static.FleeFrom(Outer.Pawn, HideTarget.Location, 1700);
            if(Outer.FindPathToward(HideTarget) != none)
            {
                PathAttempts = 0;
                Outer.AIActionStatus = (("Hiding from " $ string(HideTarget)) $ " at ") $ string(Outer.RouteGoal);
                Outer.Focus = none;
                return true;
            }
        }
        PathAttempts += 1;
        return false;
    }
Begin:

    if(Outer.Pawn.Physics == 2)
    {
        Outer.WaitForLanding();
    }
    Outer.MyKFPawn.bIsSprinting = true;
    Outer.Focus = HideTarget;
    if(CheckRetreat())
    {
        if(VSize(Outer.RouteGoal.Location - Outer.Pawn.Location) > 800)
        {
            Outer.MyKFPawn.bIsSprinting = true;
        }
        if(bLoop || VSize(HideTarget.Location - Outer.Pawn.Location) < 800)
        {
            goto 'Begin';
        }
        Outer.Sleep(0.15);
        Dot = Normal(Outer.Location - HideTarget.Location) Dot vector(HideTarget.Rotation);
        if(Dot > 0.78)
        {
            PushState('RotateToFocus');
            Status = 'Success';
            Outer.Sleep((FRand() * 1.3) + 0.5);
            Outer.PopCommand(self);            
        }
        else
        {
            goto 'Begin';
        }
    }
    J0x2FC:

    Status = 'Success';
    Outer.PopCommand(self);
    stop;                    
}

state RotateToFocus extends DebugState
{Begin:

    Outer.AIActionStatus = "Rotating to focus";
    Outer.SetFocalPoint(vect(0, 0, 0));
    Outer.Focus = HideTarget;
    Outer.FinishRotation();
    PopState();
    stop;        
}

defaultproperties
{
    bAllowedToAttack=false
}