/*******************************************************************************
 * KFProjectileStickHelper generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProjectileStickHelper extends Object within KFProjectile;

var transient Pawn PinPawn;
var transient name PinBoneName;
var transient RB_ConstraintActorSpawnable PinConstraint;
var AkEvent StickAkEvent;

simulated function TryStick(Vector HitNormal, optional Vector HitLocation, optional Actor HitActor)
{
    local TraceHitInfo HitInfo;

    if((Outer.Instigator == none) || !Outer.Instigator.IsLocallyControlled())
    {
        return;
    }
    if((HitActor != none) && (HitActor == Outer.StuckToActor) || HitActor == PinPawn)
    {
        return;
    }
    GetImpactInfo(Outer.Velocity, HitLocation, HitNormal, HitInfo);
    if(GetImpactResult(HitActor, HitInfo.HitComponent))
    {
        Stick(HitActor, HitLocation, HitNormal, HitInfo);
    }
}

simulated function GetImpactInfo(Vector in_Velocity, out Vector out_HitLocation, out Vector out_HitNormal, out TraceHitInfo out_HitInfo)
{
    local Vector VelNorm, VelScaled;

    VelNorm = Normal(in_Velocity);
    VelScaled = VelNorm * float(30);
    Outer.Trace(out_HitLocation, out_HitNormal, Outer.Location + VelScaled, Outer.Location - VelScaled,,, out_HitInfo, Outer.1);
}

simulated function bool GetImpactResult(Actor HitActor, PrimitiveComponent HitComp)
{
    local KFPawn_Human KFP;
    local KFDestructibleActor D;
    local editinline StaticMeshComponent StaticMeshComp;

    if(HitActor == none)
    {
        return true;
    }
    if((HitActor.RemoteRole == ROLE_None) && !HitActor.bWorldGeometry)
    {
        return false;
    }
    if(((HitActor.bTearOff || HitActor.bDeleteMe) || HitActor.bPendingDelete) || HitActor == Outer.PrevStuckToActor)
    {
        return false;
    }
    StaticMeshComp = StaticMeshComponent(HitComp);
    if(StaticMeshComp != none)
    {
        return !StaticMeshComp.CanBecomeDynamic();
    }
    KFP = KFPawn_Human(HitActor);
    if(KFP != none)
    {
        return false;
    }
    D = KFDestructibleActor(HitActor);
    if(D != none)
    {
        return D.ReplicationMode != 2;
    }
    return true;
}

simulated function Stick(Actor HitActor, Vector HitLocation, Vector HitNormal, const out TraceHitInfo HitInfo)
{
    local int BoneIdx;
    local KFPawn_Monster HitMonster;
    local array<ImpactInfo> HitZoneImpactList;
    local Vector StartTrace, EndTrace, Direction, ClosestBoneLocation;
    local name BoneName;

    BoneName = HitInfo.BoneName;
    HitMonster = KFPawn_Monster(HitActor);
    if(HitMonster != none)
    {
        StartTrace = HitLocation;
        Direction = Normal(Outer.Velocity);
        EndTrace = StartTrace + (Direction * (HitMonster.CylinderComponent.CollisionRadius * 6));
        Outer.TraceProjHitZones(HitMonster, EndTrace, StartTrace, HitZoneImpactList);
        ClosestBoneLocation = HitMonster.Mesh.GetClosestCollidingBoneLocation(HitLocation, true, false);
        BoneName = HitMonster.Mesh.FindClosestBone(ClosestBoneLocation, ClosestBoneLocation);
        if(KFWeapon(Outer.Owner) != none)
        {
            KFWeapon(Outer.Owner).HandleProjectileImpact(Outer.WeaponFireMode, HitZoneImpactList[0], Outer.PenetrationPower);
        }
    }
    if(!IsZero(HitLocation))
    {
        Outer.SetLocation(HitLocation);
    }
    Outer.SetStickOrientation(HitNormal);
    BoneIdx = -1;
    if(BoneName != 'None')
    {
        BoneIdx = GetBoneIndexFromActor(HitActor, BoneName);
    }
    StickToActor(HitActor, HitInfo.HitComponent, BoneIdx, true);
    if(Outer.Role < ROLE_Authority)
    {
        Outer.ServerStick(HitActor, BoneIdx, Outer.StuckToLocation, Outer.StuckToRotation);
    }
    if((Outer.WorldInfo.NetMode != NM_DedicatedServer) && StickAkEvent != none)
    {
        Outer.PlaySoundBase(StickAkEvent);
    }
}

simulated function StickToActor(Actor StickTo, PrimitiveComponent HitComp, int BoneIdx, optional bool bCalculateRelativeLocRot)
{
    local editinline SkeletalMeshComponent SkelMeshComp;
    local name BoneName;

    if(Outer.bCanPin)
    {
        if(Outer.Role == ROLE_Authority)
        {
            if((KFPawn(StickTo) != none) && !KFPawn(StickTo).IsAliveAndWell())
            {
                Pin(StickTo, BoneIdx);
                return;
            }
        }
        if((Outer.WorldInfo.NetMode != NM_DedicatedServer) && PinPawn != none)
        {
            PinPawn.Mesh.RetardRBLinearVelocity(vector(Outer.Rotation), 1);
            PinPawn.Mesh.SetRBPosition(Outer.Location, PinBoneName);
            PinConstraint = Outer.Spawn(Class'RB_ConstraintActorSpawnable',,, Outer.Location);
            PinConstraint.InitConstraint(PinPawn, none, PinBoneName, 'None');
            PinPawn = none;
        }
    }
    Outer.SetPhysics(0);
    Outer.PrevStuckToActor = Outer.StuckToActor;
    Outer.StuckToActor = StickTo;
    Outer.StuckToBoneIdx = BoneIdx;
    if(BoneIdx != -1)
    {
        SkelMeshComp = SkeletalMeshComponent(HitComp);
        BoneName = SkelMeshComp.GetBoneName(BoneIdx);
        if(bCalculateRelativeLocRot)
        {
            SkelMeshComp.TransformToBoneSpace(BoneName, Outer.Location, Outer.Rotation, Outer.StuckToLocation, Outer.StuckToRotation);
        }
        Outer.SetBase(StickTo,, SkelMeshComp, BoneName);
        Outer.SetRelativeLocation(Outer.StuckToLocation);
        Outer.SetRelativeRotation(Outer.StuckToRotation);        
    }
    else
    {
        if(bCalculateRelativeLocRot)
        {
            Outer.StuckToLocation = Outer.Location;
            Outer.StuckToRotation = Outer.Rotation;            
        }
        else
        {
            Outer.SetLocation(Outer.StuckToLocation);
            Outer.SetRotation(Outer.StuckToRotation);
        }
        Outer.SetBase(StickTo);
    }
}

simulated function Pin(Actor PinTo, int BoneIdx)
{
    if(Outer.Role == ROLE_Authority)
    {
        Outer.PinActor = PinTo;
        Outer.PinBoneIdx = BoneIdx;
    }
    PinPawn = Pawn(PinTo);
    PinBoneName = PinPawn.Mesh.GetBoneName(BoneIdx);
    Outer.StuckToActor = none;
    Outer.StuckToBoneIdx = -1;
    Outer.SetBase(none);
    Outer.SetPhysics(2);
    Outer.Velocity = Outer.Speed * vector(Outer.Rotation);
}

simulated function SkeletalMeshComponent GetActorSkeletalMesh(Actor StickActor)
{
    local Pawn P;
    local SkeletalMeshActor SM;

    P = Pawn(StickActor);
    if(P != none)
    {
        return P.Mesh;
    }
    SM = SkeletalMeshActor(StickActor);
    if(SM != none)
    {
        return SM.SkeletalMeshComponent;
    }
    return none;
}

function ServerStick(Actor StickTo, int BoneIdx, Vector StickLoc, Rotator StickRot)
{
    Outer.StuckToLocation = StickLoc;
    Outer.StuckToRotation = StickRot;
    Outer.bForceNetUpdate = true;
    ReplicatedStick(StickTo, BoneIdx);
}

simulated function ReplicatedStick(Actor StickTo, int BoneIdx)
{
    StickToActor(StickTo, GetActorSkeletalMesh(StickTo), BoneIdx);
}

simulated function int GetBoneIndexFromActor(Actor HitActor, name BoneName)
{
    local Pawn P;
    local SkeletalMeshActor SM;

    P = Pawn(HitActor);
    if(P != none)
    {
        return P.Mesh.MatchRefBone(BoneName);
    }
    SM = SkeletalMeshActor(HitActor);
    if(SM != none)
    {
        return SM.SkeletalMeshComponent.MatchRefBone(BoneName);
    }
    return -1;
}

simulated function UnStick()
{
    Outer.PrevStuckToActor = Outer.StuckToActor;
    Outer.StuckToActor = none;
    Outer.StuckToBoneIdx = -1;
    Outer.StuckToLocation = vect(0, 0, 0);
    Outer.StuckToRotation = rot(0, 0, 0);
    Outer.SetBase(none);
    Outer.SetPhysics(Outer.default.Physics);
}

simulated function UnPin()
{
    if(PinConstraint != none)
    {
        PinConstraint.TermConstraint();
    }
    PinConstraint = none;
    PinPawn = none;
}

simulated function Tick()
{
    local int I;
    local Pawn P;
    local KFFracturedMeshActor FracMesh;
    local KFDoorActor door;
    local KFDestructibleActor Destructible;
    local Actor StuckTo;
    local Vector HitLocation, HitNormal;
    local TraceHitInfo HitInfo;
    local Actor HitActor;

    if(PinPawn != none)
    {
        if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
        {
            PinPawn.Mesh.SetRBLinearVelocity(Outer.Velocity * 0.9);
            PinPawn.Mesh.SetRBPosition(Outer.Location, PinBoneName);
        }
        if((Outer.Instigator != none) && Outer.Instigator.IsLocallyControlled())
        {
            HitActor = Outer.Trace(HitLocation, HitNormal, Outer.Location, Outer.Location + (Normal(Outer.Velocity) * float(35)),,, HitInfo, Outer.1);
            if(((HitActor != none) && HitActor != Outer.PinActor) && GetImpactResult(HitActor, HitInfo.HitComponent))
            {
                Stick(HitActor, Outer.Location, HitNormal, HitInfo);
            }
        }
    }
    StuckTo = Outer.StuckToActor;
    if(StuckTo != none)
    {
        if(StuckTo.bTearOff && PinPawn == none)
        {
            UnStick();
            return;
        }
        P = Pawn(StuckTo);
        if(P != none)
        {
            if(P.Mesh.IsBoneHidden(Outer.StuckToBoneIdx))
            {
                UnStick();
            }
            return;
        }
        if(StuckTo.bDeleteMe || StuckTo.bPendingDelete)
        {
            UnStick();
            return;
        }
        FracMesh = KFFracturedMeshActor(StuckTo);
        if((FracMesh != none) && FracMesh.bHasLostChunk)
        {
            UnStick();
            return;
        }
        door = KFDoorActor(StuckTo);
        if((door != none) && !door.bDoorMoveCompleted || door.bIsDestroyed)
        {
            UnStick();
            return;
        }
        if(Outer.LastTouchComponent != none)
        {
            Destructible = KFDestructibleActor(StuckTo);
            if(Destructible != none)
            {
                I = 0;
                J0x556:

                if(I < Destructible.SubObjects.Length)
                {
                    if((Destructible.SubObjects[I].Mesh == Outer.LastTouchComponent) && Destructible.SubObjects[I].Health <= 0)
                    {
                        UnStick();
                        return;
                    }
                    ++ I;
                    goto J0x556;
                }
            }
        }
    }
}
