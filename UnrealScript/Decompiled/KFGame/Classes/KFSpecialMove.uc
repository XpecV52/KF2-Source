/*******************************************************************************
 * KFSpecialMove generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSpecialMove extends GameSpecialMove
    abstract
    native(SpecialMoves);

var KFPawn KFPOwner;
var PlayerController PCOwner;
var KFAIController AIOwner;
var transient Object AISpecialOwner;
var AnimNodeSlot ActiveSlotNode;
var bool bOverridePawnSpeedModifier;
var bool bAllowHitReactions;
var bool bAllowMomentumPush;
var bool bCanOnlyWanderAtEnd;
var bool bAllowThirdPersonWeaponAnims;
var bool bDisablesWeaponFiring;
var bool bOnlyInteractionPawnCanDamageMe;
var bool bCanModifyInteractionPawn;
var const bool bDisableHeadTracking;
var const bool bDisableAI;
var const bool bDisableMovement;
var bool bMovementDisabled;
var const bool bLockPawnRotation;
var bool bPawnRotationLocked;
var bool bDisableLook;
var bool bDisableWeaponInteraction;
var bool bDisableAIAttackRangeChecks;
var bool bDisableSteering;
var const bool bDisableTurnInPlace;
var const bool bDisablePhysics;
var bool bAllowFireAnims;
var float AITimeout;
var AICommand_PushedBySM AICommand;
var class<AICommand_PushedBySM> DefaultAICommandClass;

function bool NotifyBump(Actor Other, Vector HitNormal);

event byte PackFlags();

protected function bool InternalCanDoSpecialMove()
{
    return PawnOwner.Physics != 10;
}

function InitSpecialMove(Pawn inPawn, name InHandle)
{
    PawnOwner = inPawn;
    KFPOwner = KFPawn(inPawn);
    if(PawnOwner.Controller != none)
    {
        PCOwner = PlayerController(PawnOwner.Controller);
        if(PCOwner == none)
        {
            AIOwner = KFAIController(PawnOwner.Controller);
        }
    }
}

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    local AICommand AIOwnerActiveCommand;

    if(((AIOwner != none) && DefaultAICommandClass != none) && AIOwner.MyKFPawn != none)
    {
        AIOwnerActiveCommand == AICommand(AIOwner.GetActiveCommand());
        if((AIOwnerActiveCommand == none) || AIOwnerActiveCommand.AllowPushOfDefaultCommandForSpecialMove(KFPOwner.SpecialMove))
        {
            AICommand = DefaultAICommandClass.static.PushSpecialMoveCommand(AIOwner);
        }
    }
    if(PCOwner != none)
    {
        if(bDisableLook)
        {
            PCOwner.IgnoreLookInput(true);
        }
    }
    if(((bDisableWeaponInteraction && KFPOwner != none) && KFPOwner.Weapon != none) && KFWeapon(KFPOwner.Weapon) != none)
    {
        KFWeapon(KFPOwner.Weapon).SetSimplePutDown(true);
    }
    if(bDisableTurnInPlace)
    {
        KFPOwner.bDisableTurnInPlace = true;
    }
    if(bDisableMovement)
    {
        SetMovementLock(true);
    }
    if(bLockPawnRotation)
    {
        SetLockPawnRotation(true);
    }
    if(bDisablePhysics)
    {
        PawnOwner.ZeroMovementVariables();
        if((PawnOwner.Role == ROLE_Authority) || PawnOwner.IsLocallyControlled())
        {
            PawnOwner.SetPhysics(0);
        }
    }
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    PawnOwner.ClearTimer('AbortSpecialMove', self);
    if(((AIOwner != none) && DefaultAICommandClass != none) && AICommand != none)
    {
        if(AIOwner.GetActiveCommand() == AICommand)
        {
            AICommand.Status = 'Success';
            AIOwner.PopCommand(AICommand);
        }
        AICommand = none;
    }
    if(PCOwner != none)
    {
        if(bDisableLook)
        {
            PCOwner.IgnoreLookInput(false);
        }
    }
    if(((bDisableWeaponInteraction && KFPOwner != none) && KFPOwner.Weapon != none) && KFWeapon(KFPOwner.Weapon) != none)
    {
        KFWeapon(KFPOwner.Weapon).SetSimplePutDown(false);
    }
    if(bDisablePhysics && (PawnOwner.Role == ROLE_Authority) || PawnOwner.IsLocallyControlled())
    {
        PawnOwner.SetPhysics(2);
    }
    if(bMovementDisabled)
    {
        SetMovementLock(false);
    }
    if(AIOwner != none)
    {
        AIOwner.NotifySpecialMoveEnded(self);
    }
    AISpecialOwner = none;
    if(bPawnRotationLocked)
    {
        SetLockPawnRotation(false);
    }
    if(bDisableTurnInPlace)
    {
        KFPOwner.bDisableTurnInPlace = KFPOwner.default.bDisableTurnInPlace;
    }
    if(ActiveSlotNode != none)
    {
        ActiveSlotNode.SetActorAnimEndNotification(false);
        ActiveSlotNode = none;
    }
    if(bCanOnlyWanderAtEnd && KFPOwner != none)
    {
        if((AIOwner != none) && KFPOwner.IsHeadless())
        {
            AIOwner.DoHeadlessWander();            
        }
        else
        {
            if(KFPOwner.ShouldBeWandering())
            {
                KFPOwner.CausePanicWander();
            }
        }
    }
}

final function SetMovementLock(bool bEnable)
{
    if(bMovementDisabled != bEnable)
    {
        bMovementDisabled = bEnable;
        if(PCOwner != none)
        {
            PCOwner.IgnoreMoveInput(bEnable);
            if(PCOwner.PlayerInput != none)
            {
                PCOwner.PlayerInput.aForward = 0;
                PCOwner.PlayerInput.aStrafe = 0;
                PCOwner.PlayerInput.aUp = 0;
            }
        }
        if(bEnable)
        {
            PawnOwner.Acceleration = vect(0, 0, 0);
        }
    }
}

final function SetLockPawnRotation(bool bLock)
{
    if(bPawnRotationLocked != bLock)
    {
        bPawnRotationLocked = bLock;
        if(!bLock)
        {
        }
    }
}

function CameraAnimInst PlayCameraAnim(Pawn PawnToPlay, CameraAnim InCameraAnim, optional float Rate, optional float Scale, optional float BlendInTime, optional float BlendOutTime, optional bool bLoop, optional bool bRandomStartTime, optional float Duration, optional bool bSingleInstance, optional bool bSkipSpaceCheck)
{
    local KFPlayerController KFPC;

    Rate = 1;
    Scale = 1;                            
    KFPC = KFPlayerController(PawnToPlay.Controller);
    if((((KFPC == none) || !PawnToPlay.IsLocallyControlled()) || KFPC.PlayerCamera == none) || InCameraAnim == none)
    {
        return none;
    }
    if(!bSkipSpaceCheck && !KFPC.CameraAnimHasEnoughSpace(InCameraAnim, Scale))
    {
        LogInternal("PlayCameraAnim failed CameraAnimHasEnoughSpace:" @ string(KFPC.CameraAnimHasEnoughSpace(InCameraAnim, Scale)));
        return none;
    }
    if((PawnOwner != none) && PawnOwner.WorldInfo.GRI.bMatchIsOver)
    {
        return none;
    }
    return KFPC.PlayerCamera.PlayCameraAnim(InCameraAnim, Rate, Scale, BlendInTime, BlendOutTime, bLoop, bRandomStartTime, Duration, bSingleInstance);
}

simulated function float PlaySpecialMoveAnim(name AnimName, KFPawn.EAnimSlotStance AnimStance, optional float BlendInTime, optional float BlendOutTime, optional float Rate, optional bool bLooping)
{
    local float Duration;

    BlendInTime = 0.2;
    BlendOutTime = 0.2;
    Rate = 1;    
    if(KFPOwner.bLogCustomAnim)
    {
        LogInternal((((("PlaySpecialMoveAnim '" $ string(AnimName)) $ "' on") @ string(KFPOwner)) @ " SM=") $ string(self));
    }
    Duration = KFPOwner.PlayBodyAnim(AnimName, AnimStance, Rate, BlendInTime, BlendOutTime, bLooping);
    if((Duration <= float(0)) && KFPOwner.IsDoingSpecialMove())
    {
        WarnInternal((((("Failed to play" @ string(AnimName)) @ "on special move") @ string(self)) @ "on Pawn") @ string(PawnOwner));
        PawnOwner.SetTimer(0.25, false, 'AbortSpecialMove', self);
        return 0;
    }
    if(!bLooping)
    {
        ActiveSlotNode = KFPOwner.BodyStanceNodes[AnimStance];
        ActiveSlotNode.SetActorAnimEndNotification(true);
    }
    return Duration;
}

function AbortSpecialMove()
{
    KFPOwner.EndSpecialMove();
}

function AbortedByAICommand();

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    KFPOwner.EndSpecialMove();
}

function NotifyOwnerTakeHit(class<KFDamageType> DamageType, Vector HitLoc, Vector HitDir, Controller InstigatedBy);

event ModifyInteractionPawn(out KFPawn OtherPawn);

defaultproperties
{
    bDisableAIAttackRangeChecks=true
    bDisableSteering=true
    Handle=KFSpecialMove
}