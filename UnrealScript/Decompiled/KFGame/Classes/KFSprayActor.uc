/*******************************************************************************
 * KFSprayActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSprayActor extends Actor
    native(Effect)
    config(Game)
    placeable
    hidecategories(Navigation);

const MAX_SPRAY_FX_INFOS = 20;

struct native SprayBoneInfo
{
    /** Per-bone info for the spray's bone chain */
    var() name BoneName;
    var int BoneIndex;
    /** transient, filled in at startup */
    var() float MaterialParam;
    /** transient, filled in at startup */
    var() float BoneScale;
    /** transient, filled in at startup// per-bone effects info
 */
    var() float EffectScale;
    /** General Particle System Template. If a first person template exists, it will be used for first person, otherwise this standard template will be used */
    var() ParticleSystem ParticleSystemTemplate;
    /** First Person Particle System Template. If this is set it will override the standard ParticleSystemTemplate in first person */
    var() ParticleSystem ParticleSystemTemplate1P;
    var export editinline transient KFParticleSystemComponent BonePSC0;
    var export editinline transient KFParticleSystemComponent BonePSC1;
    var transient float SeedChainLoc;
    var transient Vector LastLoc;
    /** most recently known location */
    var() float ParticleActivationDelay;

    structdefaultproperties
    {
        BoneName=None
        BoneIndex=0
        MaterialParam=0
        BoneScale=0
        EffectScale=0
        ParticleSystemTemplate=none
        ParticleSystemTemplate1P=none
        BonePSC0=none
        BonePSC1=none
        SeedChainLoc=0
        LastLoc=(X=0,Y=0,Z=0)
        ParticleActivationDelay=0
    }
};

struct native SprayFxInfo
{
    var Vector Location;
    var float TimeStamp;

    structdefaultproperties
    {
        Location=(X=0,Y=0,Z=0)
        TimeStamp=0
    }
};

struct native SprayLight
{
    /** Optional spray lights */
    var() export editinline PointLightComponent Light;
    /** Optional spray lights */
    var() int BoneChainIndex;
    /** Optional spray lights */
    var() float FlickerIntensity;
    /** Optional spray lights */
    var() float FlickerInterpSpeed;
    /** Optional spray lights */
    var() float LastLightBrightness;

    structdefaultproperties
    {
        Light=none
        BoneChainIndex=0
        FlickerIntensity=0
        FlickerInterpSpeed=0
        LastLightBrightness=0
    }
};

struct native DamagedActorInfo
{
    var Actor HitActor;
    var float RemainingDamage;
    var float HitTime;

    structdefaultproperties
    {
        HitActor=none
        RemainingDamage=0
        HitTime=0
    }
};

struct native SprayMeshContact
{
    var int BoneChainIndex;
    var Actor Actor;
    var Vector ContactPosition;
    var Vector ContactNormal;
    var PhysicalMaterial PhysicalMaterial;
    var name BoneName;

    structdefaultproperties
    {
        BoneChainIndex=0
        Actor=none
        ContactPosition=(X=0,Y=0,Z=0)
        ContactNormal=(X=0,Y=0,Z=0)
        PhysicalMaterial=none
        BoneName=None
    }
};

struct native SpraySeed
{
    var Vector Location;
    var Vector Velocity;
    var float Age;

    structdefaultproperties
    {
        Location=(X=0,Y=0,Z=0)
        Velocity=(X=0,Y=0,Z=0)
        Age=0
    }
};

/** Editable SkeletalMesh set by the archetype */
var(SprayMesh) const SkeletalMesh SkelMesh;
/** Anim set to use for the spray anims */
var(SprayMesh) AnimSet SprayAnimSet;
/** Anim set to use for the spray anims */
var(SprayMesh) AnimTree SprayAnimTreeTemplate;
var export editinline transient KFSkeletalMeshComponent SkeletalSprayMesh;
var globalconfig bool bAllowSprayLights;
/** True to spawn the per-bone FX, false to skip it. */
var(SprayBoneChain) bool bDoPerBoneSprayFX;
var bool bDoFirstPersonFX;
/** The flame spray can touch/collide/hit teammates */
var(SprayDamage) bool bCollideWithTeammates;
/** This spray actor is for visuals only, so don't do any damage */
var(SprayDamage) bool bVisualOnly;
var private transient bool bSprayMeshCollidedThisTick;
var private transient bool bSprayMeshCollidedLastTick;
/** Enables per-poly collision, instead of simplified. */
var(SprayCollision) bool bDoCollideComplex;
/** Will always trace with Extent traces for the flame mesh collision checks. Slower, but will hit the collision cylinder of pawns making them easier to hit */
var(SprayCollision) bool bUseExtentTracing;
var transient bool bWaitingToDestroy;
var transient bool bDetached;
var transient bool bSkeletonHasBeenUpdated;
var transient bool bSplashActive;
/** Toggles bone rendering. For debugging. */
var(SprayDebug) bool bDebugShowBones;
/** Toggles collision rendering. For debugging. */
var(SprayDebug) bool bDebugShowCollision;
/** Toggles rendering of the splash damage radius. For debugging. */
var(SprayDebug) bool bDebugShowSplashRadius;
/** True to make player use third person particle systems. */
var(SprayDebug) bool bDebugForceNonPlayerParticles;
/** Toggles rendering of Spray seeds. For debugging. */
var(SprayDebug) bool bDebugShowSeeds;
/** Log out direct damage information */
var(SprayDebug) bool bDebugDirectDamage;
/** Log out splash damage information */
var(SprayDebug) bool bDebugSplashDamage;
/** Log out light information */
var(SprayDebug) bool bDebugSprayLights;
/** Socket to attach the spray actor to */
var(SprayMesh) name SpraySocketName;
/** Scales the gravity to apply to this object. X, Y define ramp-in range. */
var() const Vector2D GravityScaleRange;
/** How long it takes the gravity to fully ramp in. */
var() const float GravityScaleInTime;
/** Defines the main bone chain.  Should be sorted front to back. */
var(SprayBoneChain) array<SprayBoneInfo> BoneChain;
/** Easy parameter for scaling all per-bone fx. */
var(SprayBoneChain) float PerBoneSprayFXGlobalScale;
/** Effect to play when the flame is deflecting off a surface */
var(SpraySplash) ParticleSystem SplashGlancingEffect;
/** Effect to play when the flame hitting a surface directly */
var(SpraySplash) ParticleSystem SplashDirectEffect;
/** Effect to play when the flame hitting a pawn */
var(SpraySplash) ParticleSystem SplashPawnEffect;
/** Impact info (sfx, vfx, etc.), so that each flame type can have different effects if desired */
var(SpraySplash) KFImpactEffectInfo ImpactEffects;
var export editinline transient KFParticleSystemComponent CurrentSplashEffect;
var export editinline transient KFParticleSystemComponent SplashGlancingPSC;
var export editinline transient KFParticleSystemComponent SplashDirectPSC;
var export editinline transient KFParticleSystemComponent SplashPawnPSC;
var export editinline transient KFParticleSystemComponent SplashMaterialBasedPSC;
/** Looping sound to play when the spray hits a pawn. */
var(SpraySplash) AkEvent SplashPawnAKEvent;
/** Looping sound to play when the spray hits direct. */
var(SpraySplash) AkEvent SplashDirectAKEvent;
/** Looping sound to play when the spray hits a glancing shot. */
var(SpraySplash) AkEvent SplashGlancingAKEvent;
/** Event to play to stop the splash pawn looping sound. */
var(SpraySplash) AkEvent SplashPawnStopAKEvent;
/** Event to play to stop the splash direct looping sound. */
var(SpraySplash) AkEvent SplashDirectStopAKEvent;
/** Event to play to stop the splash glancing looping sound. */
var(SpraySplash) AkEvent SplashGlancingStopAKEvent;
var protected AkEvent CurrentSplashAKEvent;
var protected export editinline AkComponent CurrentSplashAKC;
var(SpraySplash) float SplashGlancingDotLimit;
var(SpraySplash) int LastBoneChainIndexThatCanSpawnSplashEffects;
/** The maximum distance in Unreal Units that "scorched" decals will be drawm from this spray actor "burning" or hitting things */
var(SpraySplash) float MaxDecalEffectDistance;
/** The maximum distance in Unreal Units that "scorched" decals will be drawm from this spray actor "burning" or hitting things */
var(SpraySplash) float ImpactProjectileInterval;
/** Class to spawn at the ImpactProjectileInterval when the spray is impacting something. Used for things like fire on the ground/walls */
var(SpraySplash) class<KFProjectile> ImpactProjectileClass;
var transient SprayFxInfo SprayFxInfos[20];
var transient int CurrSprayFxLocIdx;
/** Splash orientation smoothing */
var(SpraySplash) float SplashRotInterpSpeed;
var(SpraySplash) float SplashLocInterpSpeed;
var transient Rotator LastSplashRot;
var transient Vector LastSplashLoc;
var(SprayLights) array<SprayLight> SprayLights;
var MaterialInstanceConstant MIC_SprayMat0;
var MaterialInstanceConstant MIC_SprayMat1;
var MaterialInstanceConstant MIC_SprayMat2;
var(SprayMaterials) Vector2D MaterialHeatRange;
var(SprayMaterials) float MaterialHeatRampTime;
var(SprayMaterials) float MatFadePow;
var(SprayMaterials) float MaterialFadeOutTime;
var transient float MaterialCurrentFadeVal;
/** This emitter is spawned when firing starts, and is attached to the front bone. */
var(SprayFX) ParticleSystem SprayStartEffect;
var export editinline transient KFParticleSystemComponent SprayStartPSC;
/** Effect to play when the stopping firing. Functionality to play this must be implemented in the actor that this flame is attached to, since the sprayactor itself gets detached when firing stops. */
var(SprayFX) ParticleSystem SprayEndEffect;
/** How far the spray spawns should rotate */
var(SprayDamage) int AimAdjustYaw;
/** How often to apply spray or splash damage */
var(SprayDamage) float DamageInterval;
/** Damage amounts done at DamageInterval. X = damage closest to nozzle, Y = damage at far end of spray */
var(SprayDamage) Vector2D SprayDamage;
/** Range over which to scale the damage (see SprayDamageSec vars) */
var(SprayDamage) Vector2D SprayDamageScaleDistRange;
/** Damage type to deliver */
var(SprayDamage) class<KFDamageType> MyDamageType<AllowAbstract=>;
var(SprayDamage) float SplashDamageRadius;
var(SprayDamage) float SplashDamage;
var(SprayDamage) float SplashDamageFalloffExponent;
/** What percentage of splash damage should get applied to the instigator */
var(SprayDamage) float SplashDamageInstigatorDamageScale;
/** Scales the momentum for damage taken */
var(SprayDamage) float MomentumScale;
var array<DamagedActorInfo> RecentlyDamagedActors;
var private transient SprayMeshContact HighestSprayMeshContactThisTick;
var transient float bSprayMeshCollisionDuration;
var transient AnimNodeBlendList AnimBlendNode;
var transient AnimNodeSequence StartSpraySeqNode;
var transient AnimNodeSequence EndSpraySeqNode;
var transient KFSkelControl_SprayScaling ScalingSkelControl;
var transient array<SpraySeed> Seeds;
/** How fast the seeds are traveling at spawn.  Higher speeds == stiffer feeling spray. */
var(SpraySeed) float SeedSprayVel;
/** Seed deceleration as it travels.  Higher deceleration == softer spray at the far end. */
var(SpraySeed) float SeedDecel;
/** Seeds expire after this time.  Keep as short as is reasonable for memory/efficiency reasons. */
var(SpraySeed) float SeedMaxAge;
/** Don't expire any seeds if seed chain length is below this (set this to be longer than the Spray mesh). */
var(SpraySeed) float SeedMinChainLength;
/** Fixed-timestep simulation frequency for updating seed chain */
var(SpraySeed) float SeedSimFreq;
var transient float SeedSimTimeRemaining;
var(SpraySeed) float SeedWarmupTime;
/** Downward velocity if you want the spray to taper downward over a distance. */
var(SpraySeed) float VelocityScaleZ;
var transient KFPawn OwningKFPawn;
var transient Actor DummyFireParent;
var transient Controller InstigatorController;
var transient float CurrentAge;
var transient float RotationSpeed;
var private transient Rotator LastRotation;

// Export UKFSprayActor::execUpdateSeeds(FFrame&, void* const)
native final function UpdateSeeds(float DeltaTime);

// Export UKFSprayActor::execUpdatePerBoneSprayFX(FFrame&, void* const)
native simulated function UpdatePerBoneSprayFX(float DeltaTime);

// Export UKFSprayActor::execUpdateSplashes(FFrame&, void* const)
private native final simulated function UpdateSplashes(float DeltaTime);

// Export UKFSprayActor::execDestroyIfAllEmittersFinished(FFrame&, void* const)
private native final simulated function DestroyIfAllEmittersFinished();

// Export UKFSprayActor::execSetBoneSpawnParticlesActive(FFrame&, void* const)
protected native simulated function SetBoneSpawnParticlesActive(ParticleSystemComponent PSC, bool bActive);

// Export UKFSprayActor::execDebugRenderBones(FFrame&, void* const)
native final simulated function DebugRenderBones();

// Export UKFSprayActor::execGetDamage(FFrame&, void* const)
private native final function float GetDamage(float HitDist, Actor HitActor);

event PreBeginPlay()
{
    if(SkeletalSprayMesh != none)
    {
        if(SprayAnimSet != none)
        {
            SkeletalSprayMesh.AnimSets[0] = SprayAnimSet;
        }
        if(SkelMesh != none)
        {
            SkeletalSprayMesh.SkeletalMesh = SkelMesh;
        }
        if(SprayAnimTreeTemplate != none)
        {
            SkeletalSprayMesh.SetAnimTreeTemplate(SprayAnimTreeTemplate);
        }
    }
    super.PreBeginPlay();
}

simulated function PostBeginPlay()
{
    local bool bDebugDelayFX;

    super.PostBeginPlay();
    if(Instigator == none)
    {
        bDebugDelayFX = true;
    }
    OwningKFPawn = FindOwningKFPawn();
    if(OwningKFPawn != none)
    {
        InstigatorController = OwningKFPawn.Controller;
    }
    if(!bDebugDelayFX)
    {
        SetupFX();
    }
}

simulated function SetFOV(float NewFOV)
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < BoneChain.Length)
    {
        if(BoneChain[Idx].BonePSC0 != none)
        {
            BoneChain[Idx].BonePSC0.super(KFSprayActor).SetFOV(NewFOV);
        }
        if(BoneChain[Idx].BonePSC1 != none)
        {
            BoneChain[Idx].BonePSC1.super(KFSprayActor).SetFOV(NewFOV);
        }
        ++ Idx;
        goto J0x0B;
    }
    SprayStartPSC.super(KFSprayActor).SetFOV(NewFOV);
    if(CurrentSplashEffect != none)
    {
        CurrentSplashEffect.super(KFSprayActor).SetFOV(NewFOV);
    }
    SplashGlancingPSC.super(KFSprayActor).SetFOV(NewFOV);
    SplashDirectPSC.super(KFSprayActor).SetFOV(NewFOV);
    SplashPawnPSC.super(KFSprayActor).SetFOV(NewFOV);
    SplashMaterialBasedPSC.super(KFSprayActor).SetFOV(NewFOV);
    SprayStartPSC.super(KFSprayActor).SetFOV(NewFOV);
    SkeletalSprayMesh.super(KFSprayActor).SetFOV(NewFOV);
}

simulated function SetupFX()
{
    local int ChainIdx, Idx;

    CacheAnimNodes();
    SetupPerBoneFireFX();
    if(SplashDirectPSC != none)
    {
        SplashDirectPSC.SetTemplate(SplashDirectEffect);
        SplashDirectPSC.SetAbsolute(true, true, true);
    }
    if(SplashGlancingPSC != none)
    {
        SplashGlancingPSC.SetTemplate(SplashGlancingEffect);
        SplashGlancingPSC.SetAbsolute(true, true, true);
    }
    if(SplashPawnPSC != none)
    {
        SplashPawnPSC.SetTemplate(SplashPawnEffect);
        SplashPawnPSC.SetAbsolute(true, true, true);
    }
    if(SplashMaterialBasedPSC != none)
    {
        SplashMaterialBasedPSC.SetAbsolute(true, true, true);
    }
    MIC_SprayMat0 = SkeletalSprayMesh.CreateAndSetMaterialInstanceConstant(0);
    MIC_SprayMat1 = SkeletalSprayMesh.CreateAndSetMaterialInstanceConstant(1);
    MIC_SprayMat2 = SkeletalSprayMesh.CreateAndSetMaterialInstanceConstant(2);
    ChainIdx = 0;
    J0x1DA:

    if(ChainIdx < BoneChain.Length)
    {
        BoneChain[ChainIdx].BoneIndex = SkeletalSprayMesh.MatchRefBone(BoneChain[ChainIdx].BoneName);
        if(BoneChain[ChainIdx].BoneIndex == -1)
        {
            LogInternal(("Warning!  Main chain bone" @ string(BoneChain[ChainIdx].BoneName)) @ "not found in FlameThrowerSpray skeletal mesh!  Bad things may happen.  Bad things.");
        }
        ++ ChainIdx;
        goto J0x1DA;
    }
    if(SprayStartPSC != none)
    {
        SprayStartPSC.SetTemplate(SprayStartEffect);
        SkeletalSprayMesh.AttachComponent(SprayStartPSC, 'bone15');
    }
    if(bAllowSprayLights)
    {
        Idx = 0;
        J0x3BD:

        if(Idx < SprayLights.Length)
        {
            SkeletalSprayMesh.AttachComponent(SprayLights[Idx].Light, BoneChain[SprayLights[Idx].BoneChainIndex].BoneName);
            ++ Idx;
            goto J0x3BD;
        }        
    }
    else
    {
        SprayLights.Remove(0, SprayLights.Length;
    }
}

simulated function CacheAnimNodes()
{
    StartSpraySeqNode = AnimNodeSequence(SkeletalSprayMesh.FindAnimNode('StartSeqNode'));
    EndSpraySeqNode = AnimNodeSequence(SkeletalSprayMesh.FindAnimNode('EndSeqNode'));
    AnimBlendNode = AnimNodeBlendList(SkeletalSprayMesh.FindAnimNode('FlameBlendNode'));
    ScalingSkelControl = KFSkelControl_SprayScaling(SkeletalSprayMesh.FindSkelControl('FlameScale'));
    ScalingSkelControl.SetSkelControlActive(false);
}

private final simulated function ClearAnimNodes()
{
    AnimBlendNode = none;
    StartSpraySeqNode = none;
    EndSpraySeqNode = none;
}

simulated function BeginSpray()
{
    local int Idx;
    local float BlendTime;

    if(EndSpraySeqNode.bPlaying)
    {
        EndSpraySeqNode.bCauseActorAnimEnd = false;
        CleanupEndFire();
    }
    if(Base.bHidden)
    {
        return;
    }
    SkeletalSprayMesh.SetHidden(false);
    SetHidden(false);
    SetTickIsDisabled(false);
    bDetached = false;
    bSkeletonHasBeenUpdated = false;
    MaterialCurrentFadeVal = default.MaterialCurrentFadeVal;
    MIC_SprayMat0.SetScalarParameterValue('Fade', MaterialCurrentFadeVal);
    MIC_SprayMat1.SetScalarParameterValue('Fade', MaterialCurrentFadeVal);
    MIC_SprayMat2.SetScalarParameterValue('Fade', MaterialCurrentFadeVal);
    bSplashActive = false;
    bSprayMeshCollidedThisTick = false;
    bSprayMeshCollidedLastTick = false;
    HighestSprayMeshContactThisTick.BoneChainIndex = -1;
    bSprayMeshCollisionDuration = 0;
    Seeds.Length = 0;
    SeedSimTimeRemaining = 0;
    bWaitingToDestroy = false;
    ClearTimer('DestroyIfAllEmittersFinished');
    BlendTime = 0;
    if(EndSpraySeqNode.bPlaying)
    {
        BlendTime = 0.15;
    }
    StartSpraySeqNode.SetPosition(0, false);
    StartSpraySeqNode.bPlaying = true;
    AnimBlendNode.SetActiveChild(0, BlendTime);
    Idx = 0;
    J0x2AF:

    if(Idx < SprayLights.Length)
    {
        SprayLights[Idx].Light.SetEnabled(true);
        ++ Idx;
        goto J0x2AF;
    }
    if(SprayStartPSC != none)
    {
        SprayStartPSC.ActivateSystem(true);
    }
    if(Role == ROLE_Authority)
    {
        SetTimer(ImpactProjectileInterval, true, 'LeaveImpactProjectile');
    }
    if(SeedWarmupTime > 0)
    {
        UpdateSeeds(SeedWarmupTime);
    }
    CurrentAge = 0;
}

simulated function Destroyed()
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < BoneChain.Length)
    {
        if(BoneChain[Idx].BonePSC0 != none)
        {
            BoneChain[Idx].BonePSC0.DeactivateSystem();
        }
        if(BoneChain[Idx].BonePSC1 != none)
        {
            BoneChain[Idx].BonePSC1.DeactivateSystem();
        }
        ++ Idx;
        goto J0x0B;
    }
    if(SprayStartPSC != none)
    {
        SprayStartPSC.DeactivateSystem();
    }
    ClearAnimNodes();
    super.Destroyed();
}

simulated function DetachAndFinish()
{
    bDetached = true;
    if(!bSprayMeshCollidedLastTick && !bSprayMeshCollidedThisTick)
    {
        HighestSprayMeshContactThisTick.BoneChainIndex = -1;
    }
    EndSpraySeqNode.bPlaying = true;
    if(StartSpraySeqNode.bPlaying)
    {
        AnimBlendNode.SetActiveChild(1, 0.15);        
    }
    else
    {
        AnimBlendNode.SetActiveChild(1, 0);
    }
    EndSpraySeqNode.bCauseActorAnimEnd = true;
}

simulated function CleanupEndFire()
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < BoneChain.Length)
    {
        if(BoneChain[Idx].BonePSC0 != none)
        {
            BoneChain[Idx].BonePSC0.DeactivateSystem();
        }
        if(BoneChain[Idx].BonePSC1 != none)
        {
            BoneChain[Idx].BonePSC1.DeactivateSystem();
        }
        ++ Idx;
        goto J0x0B;
    }
    SetTimer(0.5, true, 'DestroyIfAllEmittersFinished');
    bWaitingToDestroy = true;
    if(CurrentSplashEffect != none)
    {
        CurrentSplashEffect.DeactivateSystem();
    }
    bSplashActive = false;
    Idx = 0;
    J0x165:

    if(Idx < SprayLights.Length)
    {
        SprayLights[Idx].Light.SetEnabled(false);
        ++ Idx;
        goto J0x165;
    }
    StartSpraySeqNode.SetPosition(0, false);
    SkeletalSprayMesh.SetHidden(true);
}

simulated event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    if(SeqNode == EndSpraySeqNode)
    {
        CleanupEndFire();
    }
    super.OnAnimEnd(SeqNode, PlayedTime, ExcessTime);
}

simulated function SetupPerBoneFireFX()
{
    local int Idx, NumChainBones;

    if(bDoPerBoneSprayFX && PerBoneSprayFXGlobalScale > 0)
    {
        NumChainBones = BoneChain.Length;
        Idx = 0;
        J0x41:

        if(Idx < NumChainBones)
        {
            if((BoneChain[Idx].EffectScale > 0) && BoneChain[Idx].BonePSC0 != none)
            {
                SkeletalSprayMesh.AttachComponent(BoneChain[Idx].BonePSC0, BoneChain[Idx].BoneName);
                BoneChain[Idx].BonePSC0.SetTemplate(BoneChain[Idx].ParticleSystemTemplate);
                BoneChain[Idx].BonePSC0.SetFloatParameter('FlameScale', BoneChain[Idx].EffectScale * PerBoneSprayFXGlobalScale);
            }
            if((BoneChain[Idx].EffectScale > 0) && BoneChain[Idx].BonePSC1 != none)
            {
                SkeletalSprayMesh.AttachComponent(BoneChain[Idx].BonePSC1, BoneChain[Idx].BoneName);
                BoneChain[Idx].BonePSC1.SetTemplate(BoneChain[Idx].ParticleSystemTemplate1P);
                BoneChain[Idx].BonePSC1.SetFloatParameter('FlameScale', BoneChain[Idx].EffectScale * PerBoneSprayFXGlobalScale);
            }
            ++ Idx;
            goto J0x41;
        }
    }
}

simulated function TempCreatePSC();

simulated function AttachToMesh(Actor BaseActor, SkeletalMeshComponent OwnerMesh, name SocketName)
{
    if(SocketName == 'None')
    {
        return;
    }
    if(KFWeapon(BaseActor) != none)
    {
        SetBase(BaseActor,, OwnerMesh, SocketName);        
    }
    else
    {
        SetBase(BaseActor.Owner,, OwnerMesh, SocketName);
    }
}

simulated event GetImpactEffect(PhysicalMaterial PhysMaterial, out ParticleSystem PS, out AkEvent ImpactSound, out AkEvent ImpactSoundStopEvent)
{
    local MaterialImpactEffect ImpactEffect;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    KFImpactEffectManager(WorldInfo.MyImpactEffectManager).GetImpactEffect(PhysMaterial, ImpactEffect, ImpactEffects);
    PS = ImpactEffect.ParticleTemplate;
    ImpactSound = AkEvent(ImpactEffect.Sound);
    ImpactSoundStopEvent = AkEvent(ImpactEffect.StopSoundEvent);
}

// Export UKFSprayActor::execParticleSystemCleanUp(FFrame&, void* const)
native simulated function ParticleSystemCleanUp();

// Export UKFSprayActor::execDoSprayCollisionDetection(FFrame&, void* const)
native final function DoSprayCollisionDetection(float DeltaTime);

protected simulated function KFPawn FindOwningKFPawn()
{
    if(Instigator != none)
    {
        return KFPawn(Instigator);
    }
    return KFPawn(Owner);
}

function LeaveImpactProjectile()
{
    local Vector DecalStartTrace, DecalEndTrace, NewHitLoc, HitNormal;
    local TraceHitInfo HitInfo;

    if(bSprayMeshCollidedLastTick && KFPawn(HighestSprayMeshContactThisTick.Actor) == none)
    {
        DecalStartTrace = HighestSprayMeshContactThisTick.ContactPosition + (HighestSprayMeshContactThisTick.ContactNormal * 4);
        DecalEndTrace = DecalStartTrace - (HighestSprayMeshContactThisTick.ContactNormal * 32);
        if(Trace(NewHitLoc, HitNormal, DecalEndTrace, DecalStartTrace, false,, HitInfo, 1) != none)
        {
            SpawnImpactProjectile(NewHitLoc, HitNormal);
        }
    }
}

function SpawnImpactProjectile(Vector SpawnLocation, Vector SpawnRotation)
{
    local KFProjectile SpawnedProjectile;
    local int I;

    I = 0;
    J0x0B:

    if(I < 20)
    {
        if(IsZero(SprayFxInfos[I].Location))
        {            
        }
        else
        {
            if((WorldInfo.TimeSeconds - SprayFxInfos[I].TimeStamp) > 10)
            {                
            }
            else
            {
                if(VSizeSq(SpawnLocation - SprayFxInfos[I].Location) > 625)
                {                    
                }
                else
                {
                    return;
                }
            }
        }
        ++ I;
        goto J0x0B;
    }
    SprayFxInfos[CurrSprayFxLocIdx].Location = SpawnLocation;
    SprayFxInfos[CurrSprayFxLocIdx].TimeStamp = WorldInfo.TimeSeconds;
    CurrSprayFxLocIdx = (CurrSprayFxLocIdx + 1) % 20;
    SpawnedProjectile = Spawn(ImpactProjectileClass, self,, SpawnLocation, rotator(SpawnRotation));
    if((SpawnedProjectile != none) && !SpawnedProjectile.bDeleteMe)
    {
        if(SpawnedProjectile != none)
        {
            SpawnedProjectile.ExplosionTemplate.ExplosionEffects = ImpactEffects;
        }
        SpawnedProjectile.Init(SpawnRotation);
    }
}

defaultproperties
{
    MaxDecalEffectDistance=5000
    ImpactProjectileInterval=0.2
    DamageInterval=0.07
    SprayDamageScaleDistRange=(X=300,Y=300)
    SplashDamageInstigatorDamageScale=1
    SeedSprayVel=5000
    SeedDecel=13000
    SeedMaxAge=0.4
    SeedSimFreq=60
    SeedWarmupTime=0.25
    bHidden=true
}