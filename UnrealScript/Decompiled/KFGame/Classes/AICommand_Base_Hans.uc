/*******************************************************************************
 * AICommand_Base_Hans generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AICommand_Base_Hans extends AICommand_Base_Boss within KFAIController_Hans;

state ZedBaseCommand
{
    ignores BeginState, EndState;
Begin:

    if(Outer.bFleeing)
    {
        Outer.Sleep(0);
        goto 'Begin';
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal(((string(self) $ " ") $ string(GetStateName())) $ " [Begin Label]", 'Command_Base');
    }
    if(Outer.Pawn.Physics == 2)
    {
        Outer.DisableMeleeRangeEventProbing();
        Outer.WaitForLanding();
    }
    Outer.EnableMeleeRangeEventProbing();
    Outer.CheckInterruptCombatTransitions();
    if(((Outer.Enemy == none) || Outer.Enemy.Health <= 0) || !Outer.IsValidAttackTarget(KFPawn(Outer.Enemy)))
    {
        Outer.SelectEnemy();
    }
    if(((Outer.Enemy == none) && Outer.DoorEnemy == none) || !Outer.bIsProbingMeleeRangeEvents)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal((((string(self) $ " Enemy: ") $ string(Outer.Enemy)) $ " bIsProbingMeleeRangeEvents: ") $ string(Outer.bIsProbingMeleeRangeEvents), 'Command_Base');
        }
        Outer.Sleep(0.1 + (FRand() * 0.3));
        goto 'Begin';
    }
    if((Outer.MyHansPawn != none) && Outer.MyHansPawn.IsThrowingGrenade())
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal((((string(self) $ " Enemy: ") $ string(Outer.Enemy)) $ " IsThrowingGrenade(): ") $ string(Outer.MyHansPawn.IsThrowingGrenade()), 'Command_Base');
        }
        Outer.Sleep(0.1);
        goto 'Begin';
    }
    if(((Outer.DoorEnemy != none) && Outer.DoorEnemy.Health > 0) && VSizeSq(Outer.DoorEnemy.Location - Outer.Pawn.Location) < (Outer.DoorMeleeDistance * Outer.DoorMeleeDistance))
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal(((string(self) $ " DoorEnemy: ") $ string(Outer.DoorEnemy)) $ " starting melee attack", 'Command_Base');
        }
        UpdateHistoryString(((("[Attacking : " $ string(Outer.DoorEnemy)) $ " at ") $ string(Outer.WorldInfo.TimeSeconds)) $ "]");
        Class'AICommand_Attack_Melee'.static.Melee(Outer, Outer.DoorEnemy);
    }
    if(Outer.IsValidAttackTarget(KFPawn(Outer.Enemy)))
    {
        if(!Outer.IsWithinAttackRange())
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal(((("Calling SetEnemyMoveGoal [Dist:" $ string(VSize(Outer.Enemy.Location - Outer.Pawn.Location))) $ "] using offset of ") $ string(Outer.AttackRange)) $ ", because IsWithinBasicMeleeRange() returned false ", 'Command_Base');
            }
            bWaitingOnMovementPlugIn = true;
            Outer.SetEnemyMoveGoal(self, true,,, ShouldAttackWhileMoving());
            J0x9C7:

            if(bWaitingOnMovementPlugIn && Outer.bUsePluginsForMovement)
            {
                Outer.Sleep(0.03);
                goto J0x9C7;
            }
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal("Back from waiting for the movement plug in!!!");
            }
        }
        if(Outer.Enemy == none)
        {
            Outer.Sleep(FRand() + 0.1);
            goto 'Begin';
        }        
    }
    else
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Enemy is invalid melee target" @ string(Outer.Enemy), 'Command_Base');
        }
        Outer.bFailedToMoveToEnemy = true;
    }
    Outer.CheckCombatTransition();
    if(Outer.bFailedToMoveToEnemy)
    {
        if(bFailedPathfind)
        {
            bFailedPathfind = false;
            Outer.Sleep(0);            
        }
        else
        {
            Outer.Sleep(0);
        }
        Outer.SetEnemy(Outer.GetClosestEnemy(Outer.Enemy));
        Outer.bFailedToMoveToEnemy = false;        
    }
    else
    {
        Outer.Sleep(0);
    }
    goto 'Begin';
    stop;                    
}
