/*******************************************************************************
 * KFProj_RicochetStickBullet generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProj_RicochetStickBullet extends KFProj_RicochetBullet
    hidecategories(Navigation);

struct StickInfo
{
    var Vector HitLocation;
    var Vector HitNormal;
    var Vector RayDir;
    var export editinline PrimitiveComponent HitComponent;

    structdefaultproperties
    {
        HitLocation=(X=0,Y=0,Z=0)
        HitNormal=(X=0,Y=0,Z=0)
        RayDir=(X=0,Y=0,Z=0)
        HitComponent=none
    }
};

var repnotify StickInfo RepStickInfo;
var StickInfo DelayedStickInfo;
/** The radius size of the pickup collision when the projectile stops moving */
var() float PickupRadius;
/** The height of the pickup collision when the projectile stops moving */
var() float PickupHeight;
var const name WeaponClassName;
var class<Weapon> WeaponClass;
/** Sound to play when picking up ammo */
var() AkEvent AmmoPickupSound;
var Vector LastLocation;
var bool bStuck;
/** This is the effect that is played while in flight */
var(Projectile) ParticleSystem ProjPickupTemplate;
var float LifeSpanAfterStick;

replication
{
     if(bNetDirty)
        RepStickInfo;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'RepStickInfo')
    {
        Stick(RepStickInfo, true);        
    }
    else
    {
        super(KFProjectile).ReplicatedEvent(VarName);
    }
}

event PreBeginPlay()
{
    super(KFProjectile).PreBeginPlay();
    if((Role == ROLE_Authority) && PickupRadius > float(0))
    {
        WeaponClass = Instigator.Weapon.Class;
        if(WeaponClass.Name != WeaponClassName)
        {
            WarnInternal((("Projectile pickup mismatch class:" $ string(WeaponClass)) @ "name:") $ string(WeaponClassName));
        }
    }
}

simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    local StickInfo MyStickInfo;
    local KActorFromStatic NewKActor;
    local KFDestructibleActor HitDestructible;
    local editinline StaticMeshComponent HitComponent;
    local TraceHitInfo HitInfo;

    SetRotation(rotator(Normal(Velocity)));
    SetPhysics(2);
    if(((bBounce && !Wall.bStatic) && Wall.bCanBeDamaged) && Wall.bProjTarget)
    {
        HitInfo.HitComponent = WallComp;
        HitInfo.Item = -1;
        Wall.TakeDamage(int(Damage), InstigatorController, Location, MomentumTransfer * -HitNormal, MyDamageType, HitInfo, self);
        if(!Wall.bBlockActors || (WallComp != none) && !WallComp.BlockActors)
        {
            BouncesLeft = 0;
            return;
        }
    }
    if(!Bounce(HitNormal, Wall))
    {
        if((WorldInfo.NetMode != NM_DedicatedServer) && ProjEffects != none)
        {
            ProjEffects.DeactivateSystem();
            ProjEffects.SetVectorParameter('Rotation', vect(0, 0, 0));
        }
        if(((!Wall.bStatic && Wall.bWorldGeometry) && Wall.bCanBeDamaged) && Wall.bProjTarget)
        {
            HitDestructible = KFDestructibleActor(Wall);
            if((HitDestructible != none) && HitDestructible.ReplicationMode >= 2)
            {
                return;
            }            
        }
        else
        {
            HitComponent = StaticMeshComponent(WallComp);
            if((HitComponent != none) && HitComponent.CanBecomeDynamic())
            {
                NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitComponent);
                if(NewKActor != none)
                {
                    NewKActor.TakeDamage(int(Damage), InstigatorController, Location, MomentumTransfer * -HitNormal, MyDamageType, HitInfo, self);
                }
                return;
            }
        }
        MyStickInfo.HitLocation = Location;
        MyStickInfo.HitNormal = HitNormal;
        MyStickInfo.HitComponent = WallComp;
        MyStickInfo.RayDir = EncodeSmallVector(Normal(Velocity));
        Stick(MyStickInfo, false);
        bBounce = false;
    }
}

simulated function Vector EncodeSmallVector(Vector V)
{
    return V * 256;
}

simulated function Vector DecodeSmallVector(Vector V)
{
    return V / 256;
}

simulated function SpawnFlightEffects()
{
    local KFWeapon W;
    local PlayerController PC;
    local bool bOwnsWeapon;

    super(KFProjectile).SpawnFlightEffects();
    if((WorldInfo.NetMode != NM_DedicatedServer) && ProjEffects != none)
    {
        ProjEffects.SetVectorParameter('Rotation', vect(0, 0, 1));
        PC = GetALocalPlayerController();
        if(PC.Pawn != none)
        {
            foreach PC.Pawn.InvManager.InventoryActors(Class'KFWeapon', W)
            {
                if(W.Class.Name == WeaponClassName)
                {
                    bOwnsWeapon = true;
                    break;
                }                
            }            
        }
        ProjEffects.SetFloatParameter('Icon', ((bOwnsWeapon) ? 1 : 0));
    }
}

simulated function Stick(StickInfo MyStickInfo, bool bReplicated)
{
    if((WorldInfo.NetMode != NM_DedicatedServer) && ProjEffects != none)
    {
        ProjEffects.DeactivateSystem();
        ProjEffects.SetTemplate(ProjPickupTemplate);
        ProjEffects.ActivateSystem();
        ProjEffects.SetVectorParameter('Rotation', vect(0, 0, 0));
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && !bStuck)
    {
        KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(Location, Instigator, MyStickInfo.HitNormal, ImpactEffects);
    }
    if(!IsZero(DecodeSmallVector(MyStickInfo.RayDir)))
    {
        SetRotation(rotator(DecodeSmallVector(MyStickInfo.RayDir)));        
    }
    else
    {
        SetRotation(rot(0, 0, 0));
    }
    SetPhysics(0);
    if(bReplicated)
    {
        SetLocation(MyStickInfo.HitLocation);
        bStuck = true;        
    }
    else
    {
        if(Role == ROLE_Authority)
        {
            bStuck = true;
            LifeSpan = LifeSpanAfterStick;
        }
    }
    if(bStopAmbientSoundOnExplode)
    {
        StopAmbientSound();
    }
    if((Role == ROLE_Authority) && !Instigator.IsLocallyControlled())
    {
        DelayedStickInfo = MyStickInfo;
        SetTimer(0.01, false, 'DelayedStick');        
    }
    else
    {
        if(Role == ROLE_Authority)
        {
            RepStickInfo = MyStickInfo;
            bForceNetUpdate = true;
            NetUpdateFrequency = 3;
        }
        GotoState('Pickup');
    }
}

simulated function DelayedStick()
{
    RepStickInfo = DelayedStickInfo;
    bForceNetUpdate = true;
    NetUpdateFrequency = 3;
    GotoState('Pickup');
}

simulated function Tick(float DeltaTime)
{
    super(Actor).Tick(DeltaTime);
    LastLocation = Location;
    if((Physics == 6) && VSizeSq(Velocity) < (Square(Speed) * 0.1))
    {
        SetPhysics(2);
        GravityScale = 1;
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && Physics != 0)
    {
        SetRotation(rotator(Velocity));
    }
}

simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
{
    local KFPawn KFP;
    local bool bPassThrough;

    if(((Other != Instigator) && Other.bCanBeDamaged) && !Other.bWorldGeometry || !Other.bStatic)
    {
        if(ShouldProcessBulletTouch())
        {
            KFP = KFPawn(Other);
            if(KFP != none)
            {
                if(CheckRepeatingTouch(Other))
                {
                    return;
                }
                ProcessBulletTouch(Other, HitLocation, HitNormal);
                if((PenetrationPower > float(0)) || PassThroughDamage(Other))
                {
                    PenetrationPower -= KFP.PenetrationResistance;
                    bPassThrough = true;
                }
                if(!bPassThrough)
                {
                    if((WorldInfo.NetMode != NM_DedicatedServer) && ProjEffects != none)
                    {
                        ProjEffects.DeactivateSystem();
                        ProjEffects.SetVectorParameter('Rotation', vect(0, 0, 0));
                    }
                    Velocity = vect(0, 0, 0);
                    BouncesLeft = 0;
                    SetPhysics(2);
                }
                return;                
            }
            else
            {
                ProcessDestructibleTouchOnBounce(Other, HitLocation, HitNormal);
                return;
            }
        }
    }
    super(KFProj_Bullet).ProcessTouch(Other, HitLocation, HitNormal);
}

simulated function bool ShouldProcessBulletTouch()
{
    return (Physics == 6) && BouncesLeft > 0;
}

state Pickup
{
    function GiveTo(Pawn P)
    {
        local KFWeapon W;

        foreach P.InvManager.InventoryActors(Class'KFWeapon', W)
        {
            if(W.Class == WeaponClass)
            {
                W.AddAmmo(1);
                PlayerController(P.Owner).ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 13,,, WeaponClass);
                P.PlaySoundBase(AmmoPickupSound);
                ShutDown();
            }            
        }        
    }

    function bool ValidTouch(Pawn Other)
    {
        local Vector PickupLocation;

        if(((Other == none) || !Other.bCanPickupInventory) || (Other.DrivenVehicle == none) && Other.Controller == none)
        {
            return false;
        }
        PickupLocation = Location - (vector(Rotation) * 15);
        if(!FastTrace(Other.Location, PickupLocation) && !FastTrace(Other.Location, PickupLocation,, true))
        {
            return false;
        }
        if(WorldInfo.Game.PickupQuery(Other, WeaponClass, self))
        {
            return true;
        }
        return false;
    }

    simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
    {
        local Pawn P;

        if(Role == ROLE_Authority)
        {
            P = Pawn(Other);
            if((P != none) && ValidTouch(P))
            {
                GiveTo(P);
            }
        }
    }

    function CheckTouching()
    {
        local Pawn P;

        foreach TouchingActors(Class'Pawn', P)
        {
            Touch(P, none, Location, Normal(Location - P.Location));            
        }        
    }

    function BeginState(name PreviousStateName)
    {
        SetCollisionSize(PickupRadius, PickupHeight);
        CylinderComponent.SetTraceBlocking(true, true);
        CylinderComponent.SetActorCollision(true, false);
        bCollideComplex = false;
        SetOwner(none);
    }

    simulated function Tick(float DeltaTime)
    {
        if(((Role == ROLE_Authority) && RepStickInfo.HitComponent != none) && RepStickInfo.HitComponent.HiddenGame)
        {
            Explode(RepStickInfo.HitLocation, RepStickInfo.HitNormal);
            ImpactedActor = none;
        }
    }
Begin:

    CheckTouching();
    stop;        
}

defaultproperties
{
    PickupRadius=200
    PickupHeight=100
    AmbientComponent=AkComponent'Default__KFProj_RicochetStickBullet.AmbientAkSoundComponent'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_RicochetStickBullet.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_RicochetStickBullet.CollisionCylinder'
    Components(0)=CollisionCylinder
    Components(1)=AkComponent'Default__KFProj_RicochetStickBullet.AmbientAkSoundComponent'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_RicochetStickBullet.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}