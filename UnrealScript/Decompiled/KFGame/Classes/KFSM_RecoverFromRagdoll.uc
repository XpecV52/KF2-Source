/*******************************************************************************
 * KFSM_RecoverFromRagdoll generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_RecoverFromRagdoll extends KFSpecialMove
    native(SpecialMoves);

/** Recovery anims */
var() name GetUpFrontAnim;
var() name GetUpBackAnim;
var bool bBlendToGetUp;
var() bool bInvertUpDownBoneAxis;
/** If TRUE, ignore pawns when looking for a spot to get up */
var() bool bIgnorePawnsOnRecover;
/** enable debugging */
var() bool bDebugSpecialMove;
var float GetUpBlendStartTime;
var() float GetUpBlendTime;
/** GetUp orientation */
var() name UpDownBoneName;
var() Core.Object.EAxis UpDownAxis;
var() Core.Object.EAxis OrientationAxis;
var() name OrientationBoneName;
var() int GetUpFromBackYawOffset;

protected function bool InternalCanDoSpecialMove()
{
    return PawnOwner.Physics == 10;
}

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    local Vector HitLocation, HitNormal, TraceStart, TraceEnd, Extent, HeightVec;

    local Actor HitActor;

    super.SpecialMoveStarted(bForced, PrevMove);
    PawnOwner.Mesh.bUpdateKinematicBonesFromAnimation = false;
    PawnOwner.Mesh.PhysicsWeight = 1;
    PawnOwner.Mesh.MinDistFactorForKinematicUpdate = PawnOwner.default.Mesh.MinDistFactorForKinematicUpdate;
    PawnOwner.Mesh.SetTickGroup(PawnOwner.default.Mesh.TickGroup);
    PawnOwner.SetTickGroup(0);
    PawnOwner.SetPhysics(0);
    PlayRecoveryAnim();
    Extent = vect(0, 0, 0);
    HeightVec = vect(0, 0, 1) * PawnOwner.CylinderComponent.CollisionHeight;
    TraceStart = PawnOwner.Location + (HeightVec * 1.1);
    TraceEnd = PawnOwner.Location - (HeightVec * 3);
    if(bIgnorePawnsOnRecover)
    {
        HitActor = PawnOwner.Trace(HitLocation, HitNormal, TraceEnd, TraceStart, false, Extent);        
    }
    else
    {
        HitActor = PawnOwner.Trace(HitLocation, HitNormal, TraceEnd, TraceStart, true, Extent);
    }
    if(HitActor != none)
    {
        MoveOffGeometry(HitLocation, HeightVec, Extent);        
    }
    else
    {
        if(bDebugSpecialMove)
        {
            LogInternal(string(Class) @ "Failed trace");
            PawnOwner.DrawDebugCylinder(TraceStart + (vect(0, 0, 1) * Extent.Z), TraceEnd - (vect(0, 0, 1) * Extent.Z), Extent.X, 4, 0, 255, 0, true);
            PawnOwner.DrawDebugLine(TraceStart, TraceEnd, 0, 0, 255, true);
        }
    }
    bBlendToGetUp = true;
    GetUpBlendStartTime = PawnOwner.WorldInfo.TimeSeconds;
    if(KFPOwner.bHasBrokenConstraints && KFPOwner.InjuredHitZones > 0)
    {
        PawnOwner.Mesh.PhysicsWeight = 0;
        FinishedBlendToGetUp();
    }
}

simulated function Actor TraceNoPawns(Pawn TraceOwner, Vector End, Vector Start, out Vector HitLocation)
{
    local Actor HitActor;
    local Vector HitLoc, HitNorm;

    foreach TraceOwner.TraceActors(Class'Actor', HitActor, HitLoc, HitNorm, End, Start, vect(0, 0, 0))
    {
        if(Pawn(HitActor) == none)
        {
            HitLocation = HitLoc;            
            return HitActor;
        }        
    }    
    return none;
}

simulated function MoveOffGeometry(Vector HitLocation, Vector HeightVec, Vector Extent)
{
    local editinline PrimitiveComponent BackupCollisionComponent;

    HitLocation += ((HeightVec - (vect(0, 0, 1) * Extent.Z)) + vect(0, 0, 1));
    Extent = (vect(1, 1, 0) * PawnOwner.CylinderComponent.CollisionRadius) + HeightVec;
    if(bDebugSpecialMove)
    {
        PawnOwner.DrawDebugSphere(HitLocation, 16, 8, 255, 0, 0, true);
        PawnOwner.DrawDebugBox(HitLocation, Extent, 255, 0, 0, true);
    }
    if(PawnOwner.FindSpot(Extent, HitLocation))
    {
        if(bDebugSpecialMove)
        {
            PawnOwner.DrawDebugSphere(HitLocation, 16, 8, 0, 255, 0, true);
            PawnOwner.DrawDebugBox(HitLocation, Extent, 0, 255, 0, true);
        }
        BackupCollisionComponent = PawnOwner.CollisionComponent;
        PawnOwner.CollisionComponent = PawnOwner.CylinderComponent;
        if(!PawnOwner.SetLocation(HitLocation))
        {
            if(bDebugSpecialMove)
            {
                WarnInternal(string(Class) @ "SetLocation failed!!!!!!!!!!");
            }
        }
        PawnOwner.CollisionComponent = BackupCollisionComponent;
        if(bDebugSpecialMove)
        {
            PawnOwner.DrawDebugSphere(PawnOwner.Location, 16, 8, 0, 0, 255, true);
            PawnOwner.DrawDebugBox(PawnOwner.Location, Extent, 0, 0, 255, true);
        }        
    }
    else
    {
        PawnOwner.SetLocation(HitLocation);
        if(bDebugSpecialMove)
        {
            LogInternal(string(Class) @ "Failed findspot");
            PawnOwner.DrawDebugCylinder(PawnOwner.Location - HeightVec, PawnOwner.Location + HeightVec, PawnOwner.CylinderComponent.CollisionRadius, 12, 255, 0, 0, true);
        }
    }
}

function PlayRecoveryAnim()
{
    local Rotator NewRotation;
    local int OrientationBodyIndex, UpDownBodyIndex;
    local Matrix BodyTM;
    local bool bGetUpFromBack;

    bGetUpFromBack = false;
    OrientationBodyIndex = PawnOwner.Mesh.PhysicsAsset.FindBodyIndex(OrientationBoneName);
    if(OrientationBodyIndex != -1)
    {
        BodyTM = PawnOwner.Mesh.PhysicsAssetInstance.Bodies[OrientationBodyIndex].GetUnrealWorldTM();
        NewRotation.Yaw = rotator(MatrixGetAxis(BodyTM, OrientationAxis)).Yaw;
        UpDownBodyIndex = PawnOwner.Mesh.PhysicsAsset.FindBodyIndex(UpDownBoneName);
        if(UpDownBodyIndex != -1)
        {
            BodyTM = PawnOwner.Mesh.PhysicsAssetInstance.Bodies[UpDownBodyIndex].GetUnrealWorldTM();
            bGetUpFromBack = MatrixGetAxis(BodyTM, UpDownAxis).Z > 0;
            if(bInvertUpDownBoneAxis)
            {
                bGetUpFromBack = !bGetUpFromBack;
            }
        }
        if(bGetUpFromBack)
        {
            NewRotation.Yaw += GetUpFromBackYawOffset;
            NewRotation = Normalize(NewRotation);
        }
        PawnOwner.SetRotation(NewRotation);        
    }
    else
    {
        NewRotation.Yaw = PawnOwner.Rotation.Yaw;
        PawnOwner.SetRotation(NewRotation);
    }
    PlaySpecialMoveAnim(GetRecoveryAnim(bGetUpFromBack), 0, 0, 0.33, 1);
    EnableRootMotion();
}

function name GetRecoveryAnim(bool bGetUpFromBack)
{
    return ((bGetUpFromBack) ? GetUpBackAnim : GetUpFrontAnim);
}

simulated event FinishedBlendToGetUp()
{
    bBlendToGetUp = false;
    Class'KFSM_RagdollKnockdown'.static.TermKnockdownRagdoll(KFPOwner);
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    if(bBlendToGetUp)
    {
        FinishedBlendToGetUp();
    }
    bBlendToGetUp = false;
    DisableRootMotion();
    super.SpecialMoveEnded(PrevMove, NextMove);
}

defaultproperties
{
    GetUpFrontAnim=Getup_F_V1
    GetUpBackAnim=Getup_B_V1
    bInvertUpDownBoneAxis=true
    bIgnorePawnsOnRecover=true
    GetUpBlendTime=0.42
    UpDownBoneName=Spine1
    UpDownAxis=EAxis.AXIS_Y
    OrientationAxis=EAxis.AXIS_X
    OrientationBoneName=Spine1
    GetUpFromBackYawOffset=32768
    bCanOnlyWanderAtEnd=true
    bDisablesWeaponFiring=true
    bDisableMovement=true
    bLockPawnRotation=true
    Handle=KFSM_RecoverFromRagdoll
}