/*******************************************************************************
 * KFPawnAfflictions generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawnAfflictions extends Object within KFPawn
    native(Pawn);

enum EHitZoneBodyPart
{
    BP_None,
    BP_Head,
    BP_Torso,
    BP_LeftArm,
    BP_RightArm,
    BP_LeftLeg,
    BP_RightLeg,
    BP_Special,
    BP_MAX
};

enum EInstantIncaps
{
    IAF_Knockdown,
    IAF_Stun,
    IAF_Stumble,
    IAF_LegStumble,
    IAF_MeleeHit,
    IAF_GunHit,
    IAF_Custom1,
    IAF_Custom2,
    IAF_Custom3,
    IAF_MAX
};

enum EStackingIncaps
{
    SAF_EMPPanic,
    SAF_FirePanic,
    SAF_Poison,
    SAF_Microwave,
    SAF_EMPDisrupt,
    SAF_Freeze,
    SAF_Custom1,
    SAF_Custom2,
    SAF_Custom3,
    SAF_MAX
};

struct native IncapResist
{
    /** Per hitzone incap effect resistances */
    var() const byte head;
    /** Per hitzone incap effect resistances */
    var() const byte Torso;
    /** Per hitzone incap effect resistances */
    var() const byte Leg;
    /** Per hitzone incap effect resistances */
    var() const byte Arm;
    /** Per hitzone incap effect resistances */
    var() const byte Special;
    /** Additional resist applied as health approaches zero */
    var() const byte LowHealthBonus;
    /** How long after this incap occurs can it happen again. Prevents pawns from getting spammed with incaps */
    var() const float Cooldown;
    var transient float LastStartTime;

    structdefaultproperties
    {
        head=255
        Torso=255
        Leg=255
        Arm=255
        Special=255
        LowHealthBonus=0
        Cooldown=2
        LastStartTime=-100
    }
};

struct native StackingIncapInfo
{
    /** The threshhold that must be crossed to activate this stacked incap */
    var() float Threshhold;
    /** How long this incap lasts once triggered */
    var() float Duration;
    /** How long after this incap is triggered til it can be triggered again */
    var() float Cooldown;
    /** Rate at which the StackedPower will dissipate. Default is 1.0 per second */
    var() float DissipationRate;
    var transient float LastStartTime;
    var transient float StackedPower;

    structdefaultproperties
    {
        Threshhold=1
        Duration=5
        Cooldown=0
        DissipationRate=1
        LastStartTime=0
        StackedPower=0
    }
};

var protected bool bDebugLog;
var protected bool bNoBurnedMatBeforeDeath;
var protected bool bSteamEffectActive;
var protected KFPawn_Monster MonsterOwner;
var protected float FireBurnedAmount;
var protected float FireFullyCharredDuration;
var protected float FireCharPercentThreshhold;
var protected float MicrowavedAmount;
var protected float UsedMicrowavedAmount;
var protected float MicrowaveBurnedAmount;
/** Interp curve that allows us to ramp up how charred a zed looks when hit with microwave */
var() InterpCurveFloat MicroWaveCharCurve;
var protected ParticleSystem SteamingTemplate;
var protected export editinline ParticleSystemComponent SteamingEffect;
var protected ParticleSystem BurningTemplate;
var protected export editinline ParticleSystemComponent BurningEffect;
var protected ParticleSystem EmpPanicTemplate;
var protected export editinline ParticleSystemComponent EMPPanicEffect;
var protected ParticleSystem EmpDisruptTemplate;
var protected export editinline ParticleSystemComponent EMPDisruptEffect;
var protected name EffectSocketName;
var protected name EMPDisruptSocketName;
var protected AkEvent OnFireSound;
var protected AkEvent OnFireEndSound;
var protected AkEvent OnSteamSound;
var protected AkEvent OnSteamEndSound;
var protected AkEvent OnEMPSound;
var protected AkEvent OnEMPEndSound;

function NotifyTakeHit(Controller DamageInstigator, Vector HitDir, class<KFDamageType> DamageType)
{
    local KFPerk InstigatorPerk;

    if(DamageType == none)
    {
        return;
    }
    if((DamageInstigator != none) && DamageInstigator.bIsPlayer)
    {
        InstigatorPerk = KFPlayerController(DamageInstigator).GetPerk();
    }
    if((Outer.GetTeamNum() > 254) && !Outer.bPlayedDeath)
    {
        CheckSpecialMoveAfflictions(InstigatorPerk, HitDir, DamageType);
        CheckHitReactionAfflictions(DamageType);
    }
    CheckStackingAfflictions(InstigatorPerk, DamageType);
}

function byte GetPredictedHitReaction(class<KFDamageType> DamageType, KFPawnAfflictions.EHitZoneBodyPart BodyPart)
{
    if((DamageType.default.MeleeHitPower > 0) && ShouldApply(4, BodyPart, DamageType.default.MeleeHitPower,, true))
    {
        return 2;        
    }
    else
    {
        if((DamageType.default.GunHitPower > 0) && ShouldApply(5, BodyPart, DamageType.default.GunHitPower,, true))
        {
            return 1;
        }
    }
    return 0;
}

protected function CheckSpecialMoveAfflictions(KFPerk InstigatorPerk, Vector HitDir, class<KFDamageType> DamageType)
{
    local KFPawnAfflictions.EHitZoneBodyPart BodyPart;
    local byte HitZoneIdx;
    local Vector HitLoc;
    local float KnockdownPowerModifier, StumblePowerModifier, StunPowerModifier, StumbleCooldownModifier;
    local bool bForceKnockdown, bForceStumble, bForceStun;

    if(IsZero(HitDir))
    {
        return;
    }
    HitZoneIdx = Outer.HitFxInfo.HitBoneIndex;
    HitLoc = Outer.HitFxInfo.HitLocation;
    BodyPart = ((HitZoneIdx != 255) ? Outer.HitZones[HitZoneIdx].Limb : 2);
    KnockdownPowerModifier = 1;
    StumblePowerModifier = 1;
    StumbleCooldownModifier = 1;
    StunPowerModifier = 1;
    if(InstigatorPerk != none)
    {
        KnockdownPowerModifier = InstigatorPerk.GetKnockdownPowerModifier(DamageType, BodyPart, Outer.bIsSprinting);
        StumblePowerModifier = InstigatorPerk.GetStumblePowerModifier(Outer, DamageType, StumbleCooldownModifier, BodyPart);
        StunPowerModifier = InstigatorPerk.GetStunPowerModifier(DamageType, HitZoneIdx);
    }
    if(KnockdownPowerModifier >= 255)
    {
        bForceKnockdown = true;
    }
    if(StumblePowerModifier >= 255)
    {
        bForceStumble = true;
    }
    if(StunPowerModifier >= 255)
    {
        bForceStun = true;
    }
    if(((bForceKnockdown || DamageType.default.KnockdownPower > 0) && Outer.CanDoSpecialMove(7)) && ShouldApply(0, BodyPart, ((bForceKnockdown) ? 256 : int(float(DamageType.default.KnockdownPower) * KnockdownPowerModifier))))
    {
        ActivateKnockdown(DamageType, HitLoc, HitDir, HitZoneIdx);        
    }
    else
    {
        if(((bForceStun || DamageType.default.StunPower > 0) && Outer.CanDoSpecialMove(9)) && ShouldApply(1, BodyPart, ((bForceStun) ? 256 : int(float(DamageType.default.StunPower) * StunPowerModifier))))
        {
            Outer.DoSpecialMove(9);            
        }
        else
        {
            if(((bForceStumble || DamageType.default.LegStumblePower > 0) && Outer.CanDoSpecialMove(5)) && ShouldApply(3, BodyPart, ((bForceStumble) ? 256 : int(float(DamageType.default.LegStumblePower) * StumblePowerModifier)), StumbleCooldownModifier))
            {
                Outer.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackLegHitSMFlags(Outer, HitDir, BodyPart == 5));                
            }
            else
            {
                if(((bForceStumble || DamageType.default.StumblePower > 0) && Outer.CanDoSpecialMove(5)) && ShouldApply(2, BodyPart, ((bForceStumble) ? 256 : int(float(DamageType.default.StumblePower) * StumblePowerModifier)), StumbleCooldownModifier))
                {
                    Outer.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(Outer, HitDir));
                }
            }
        }
    }
}

protected function CheckHitReactionAfflictions(class<KFDamageType> DamageType)
{
    local KFPawnAfflictions.EHitZoneBodyPart BodyPart;
    local byte HitZoneIdx;

    if((Outer.MyKFAIC != none) && Outer.SpecialMove == 0)
    {
        HitZoneIdx = Outer.HitFxInfo.HitBoneIndex;
        BodyPart = ((HitZoneIdx != 255) ? Outer.HitZones[HitZoneIdx].Limb : 2);
        if((DamageType.default.MeleeHitPower > 0) && ShouldApply(4, BodyPart, DamageType.default.MeleeHitPower))
        {
            Outer.MyKFAIC.DoPauseAI(Outer.DamageRecoveryTimeHeavy, true);
        }
        if(((HitZoneIdx == 0) && Outer.IsHeadless()) && Outer.GetTimerCount('BleedOutTimer', Outer) == 0)
        {
            Outer.MyKFAIC.DoPauseAI(Outer.DamageRecoveryTimeHeavy, true);            
        }
        else
        {
            if((DamageType.default.GunHitPower > 0) && ShouldApply(5, BodyPart, DamageType.default.GunHitPower))
            {
                Outer.MyKFAIC.DoPauseAI(Outer.DamageRecoveryTimeMedium, true);
            }
        }
    }
}

protected function CheckStackingAfflictions(KFPerk InstigatorPerk, class<KFDamageType> DamageType)
{
    local bool bCanCausePoisonPanic;

    if(Outer.bPlayedDeath && Outer.WorldInfo.TimeSeconds > Outer.TimeOfDeath)
    {
        if(DamageType.default.BurnPower > float(0))
        {
            AccrueStackingAffliction(1, DamageType.default.BurnPower);
        }
        return;
    }
    if(InstigatorPerk != none)
    {
        bCanCausePoisonPanic = InstigatorPerk.IsAcidicCompoundActive();
    }
    if((DamageType.default.EMPPower > float(0)) && AccrueStackingAffliction(0, DamageType.default.EMPPower))
    {
        SetEMPPanicked(true);
    }
    if((DamageType.default.BurnPower > float(0)) && AccrueStackingAffliction(1, DamageType.default.BurnPower))
    {
        SetFirePanicked(true);
    }
    if((bCanCausePoisonPanic && DamageType.default.PoisonPower > float(0)) && AccrueStackingAffliction(2, DamageType.default.PoisonPower))
    {
        SetPoisoned(true);
    }
    if((DamageType.default.MicrowavePower > float(0)) && AccrueStackingAffliction(3, DamageType.default.MicrowavePower))
    {
        SetMicrowavePanicked(true);
    }
    if((DamageType.default.FreezePower > float(0)) && AccrueStackingAffliction(5, DamageType.default.FreezePower))
    {
        SetFrozen(true);
    }
    if((DamageType.default.EMPPower > float(0)) && AccrueStackingAffliction(4, DamageType.default.EMPPower))
    {
        SetEMPDisrupted(true);
    }
}

protected function bool ShouldApply(KFPawnAfflictions.EInstantIncaps Id, KFPawnAfflictions.EHitZoneBodyPart BodyPart, int InPower, optional float CooldownModifier, optional bool bTestOnly)
{
    local byte BaseResistValue;
    local float PercentHealth;

    CooldownModifier = 1;    
    if(InPower <= 0)
    {
        return false;
    }
    if(Id >= Outer.InstantIncaps.Length)
    {
        return false;
    }
    switch(BodyPart)
    {
        case 1:
            BaseResistValue = Outer.InstantIncaps[Id].head;
            break;
        case 2:
            BaseResistValue = Outer.InstantIncaps[Id].Torso;
            break;
        case 3:
            BaseResistValue = Outer.InstantIncaps[Id].Arm;
            break;
        case 4:
            BaseResistValue = Outer.InstantIncaps[Id].Arm;
            break;
        case 5:
            BaseResistValue = Outer.InstantIncaps[Id].Leg;
            break;
        case 6:
            BaseResistValue = Outer.InstantIncaps[Id].Leg;
            break;
        case 7:
            BaseResistValue = Outer.InstantIncaps[Id].Special;
            break;
        default:
            return false;
            break;
    }
    if(BaseResistValue < 255)
    {
        if(bDebugLog)
        {
            LogInternal(((((((string(Id) @ string(self)) @ "Resistance is Base:") @ string(BaseResistValue)) @ "LowHealthBonus:") @ string(Outer.InstantIncaps[Id].LowHealthBonus)) @ "Power: ") $ string(InPower), 'StatusEffect');
        }
        if((Outer.WorldInfo.TimeSeconds - Outer.InstantIncaps[Id].LastStartTime) < (Outer.InstantIncaps[Id].Cooldown * CooldownModifier))
        {
            if(bDebugLog)
            {
                LogInternal(string(Id) @ "rejected because of cooldown", 'StatusEffect');
            }
            return false;
        }
        if(InPower < BaseResistValue)
        {
            if(bDebugLog)
            {
                LogInternal(string(Id) @ "resisted (regardless of health)", 'StatusEffect');
            }
            return false;
        }
        if(InPower < (BaseResistValue + Outer.InstantIncaps[Id].LowHealthBonus))
        {
            PercentHealth = GetOwnerHealthPercent();
            if(float(InPower) < (float(BaseResistValue) + ((1 - PercentHealth) * float(Outer.InstantIncaps[Id].LowHealthBonus))))
            {
                if(bDebugLog)
                {
                    LogInternal(((string(Id) @ "resisted because Health is at") @ string(PercentHealth)) $ "%", 'StatusEffect');
                }
                return false;
            }
        }
        if(!bTestOnly)
        {
            Outer.InstantIncaps[Id].LastStartTime = Outer.WorldInfo.TimeSeconds;
        }
        if(bDebugLog)
        {
            LogInternal(string(Id) @ "applied >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", 'StatusEffect');
        }
        return true;
    }
    return false;
}

function float GetOwnerHealthPercent()
{
    local KFPawn_Monster P;

    P = GetMonsterOwner();
    if(P != none)
    {
        return FMin(float(P.OldHealth) / float(Outer.HealthMax), 1);
    }
    return FMin(float(Outer.Health) / float(Outer.HealthMax), 1);
}

function bool AccrueStackingAffliction(KFPawnAfflictions.EStackingIncaps Id, float InPower)
{
    if(((Id >= Outer.StackingIncaps.Length) || InPower <= float(0)) || Outer.StackingIncaps[Id].Duration <= float(0))
    {
        return false;
    }
    if((Outer.WorldInfo.TimeSeconds - Outer.StackingIncaps[Id].LastStartTime) < Outer.StackingIncaps[Id].Cooldown)
    {
        if(bDebugLog)
        {
            LogInternal((string(GetFuncName()) @ "rejected because of cooldown:") $ string(Id));
        }
        return false;
    }
    Outer.StackingIncaps[Id].StackedPower += InPower;
    if(bDebugLog)
    {
        LogInternal(((((string(GetFuncName()) @ string(Id)) @ "Threshold:") $ string(Outer.StackingIncaps[Id].Threshhold)) @ "Power:") $ string(Outer.StackingIncaps[Id].StackedPower));
    }
    if(Outer.StackingIncaps[Id].Threshhold > Outer.StackingIncaps[Id].StackedPower)
    {
        if(bDebugLog)
        {
            LogInternal((string(GetFuncName()) @ "rejected because of threshold:") $ string(Id));
        }
        return false;
    }
    Outer.StackingIncaps[Id].LastStartTime = Outer.WorldInfo.TimeSeconds;
    if(bDebugLog)
    {
        LogInternal((string(GetFuncName()) @ "accepted:") $ string(Id));
    }
    return true;
}

function KFPawn_Monster GetMonsterOwner()
{
    if(MonsterOwner != none)
    {
        return MonsterOwner;
    }
    MonsterOwner = KFPawn_Monster(Outer);
    return MonsterOwner;
}

protected function ActivateKnockdown(class<DamageType> DamageType, Vector HitLoc, Vector HitDir, byte HitZoneIdx)
{
    local Vector Impulse;

    if((DamageType.default.RadialDamageImpulse > float(0)) && ClassIsChildOf(DamageType, Class'KFDT_Explosive'))
    {
        Impulse = DamageType.default.RadialDamageImpulse * HitDir;
        if(Outer.HitFxInfo.bRadialDamage && Outer.HitFxRadialInfo.RadiusDamageScale != 255)
        {
            Impulse *= ByteToFloat(Outer.HitFxRadialInfo.RadiusDamageScale);
        }
        Impulse += (vect(0, 0, 1) * DamageType.default.KDeathUpKick);
        Outer.Knockdown(,, vect(1, 1, 1),,,, Impulse);        
    }
    else
    {
        Outer.Knockdown(,, vect(1, 1, 1),,,, DamageType.default.KDamageImpulse * HitDir, HitLoc, HitZoneIdx);
    }
}

event SetEMPDisrupted(bool bEnabled)
{
    if(Outer.Role == ROLE_Authority)
    {
        if(Outer.bEmpDisrupted == bEnabled)
        {
            return;
        }
        Outer.bEmpDisrupted = bEnabled;
        if(Outer.IsDoingSpecialMove())
        {
            Outer.SpecialMoves[Outer.SpecialMove].OnEMPDisrupted();
        }
        Outer.OnStackingAfflictionChanged(4);
    }
    SetEMPEffects(Outer.bEmpDisrupted, Outer.bEmpPanicked);
}

event SetEMPPanicked(bool bEnabled)
{
    if(Outer.Role == ROLE_Authority)
    {
        if(Outer.bEmpPanicked == bEnabled)
        {
            return;
        }
        Outer.bEmpPanicked = bEnabled;
        Outer.OnStackingAfflictionChanged(0);
    }
    SetEMPEffects(Outer.bEmpDisrupted, Outer.bEmpPanicked);
}

function SetEMPEffects(bool bDisrupted, bool bPanicked)
{
    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(bDisrupted)
        {
            if(EMPDisruptEffect == none)
            {
                EMPDisruptEffect = Outer.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(EmpDisruptTemplate, Outer.Mesh, EMPDisruptSocketName, true);
            }            
        }
        else
        {
            if(EMPDisruptEffect != none)
            {
                Outer.DetachEmitter(EMPDisruptEffect);
            }
        }
        if(bPanicked && EMPPanicEffect == none)
        {
            Outer.PlaySoundBase(OnEMPSound, true, true, true);
            EMPPanicEffect = Outer.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(EmpPanicTemplate, Outer.Mesh, EffectSocketName, false);            
        }
        else
        {
            if(EMPPanicEffect != none)
            {
                Outer.PlaySoundBase(OnEMPEndSound, true, true);
                Outer.DetachEmitter(EMPPanicEffect);
            }
        }
        SetEMPMatParam(bDisrupted, bPanicked);
    }
}

protected function SetEMPMatParam(bool bDisrupted, bool bPanicked)
{
    local MaterialInstanceConstant MIC;

    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        MIC = ((Outer.GoreMIC != none) ? Outer.GoreMIC : Outer.BodyMIC);
        if(bPanicked)
        {
            MIC.SetScalarParameterValue('Scalar_EMP', 5);            
        }
        else
        {
            if(bDisrupted)
            {
                MIC.SetScalarParameterValue('Scalar_EMP', 1);                
            }
            else
            {
                MIC.SetScalarParameterValue('Scalar_EMP', 0);
            }
        }
    }
}

event SetFirePanicked(bool bEnabled)
{
    if(Outer.Role == ROLE_Authority)
    {
        if(Outer.bFirePanicked == bEnabled)
        {
            return;
        }
        Outer.bFirePanicked = bEnabled;
        Outer.OnStackingAfflictionChanged(1);        
    }
    else
    {
        if(bEnabled)
        {
            Outer.StackingIncaps[1].LastStartTime = Outer.WorldInfo.TimeSeconds;
        }
    }
    SetFirePanicEffects(bEnabled);
}

function SetBurnedParameter(float BurnedAmount, optional bool bViaReplication)
{
    local MaterialInstanceConstant MIC;

    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        MIC = ((Outer.GoreMIC != none) ? Outer.GoreMIC : Outer.BodyMIC);
        MIC.SetScalarParameterValue('Scalar_Burnt', BurnedAmount);
        if(bViaReplication)
        {
            FireBurnedAmount = BurnedAmount * FireFullyCharredDuration;
        }
    }
}

function TearOffFirePanic(byte ServerFirePct)
{
    Outer.StackingIncaps[1].StackedPower = ByteToFloat(ServerFirePct) * Outer.StackingIncaps[1].Threshhold;
}

protected function SetFirePanicEffects(bool bEnabled)
{
    if(Outer.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(bEnabled)
    {
        if(BurningEffect == none)
        {
            BurningEffect = new (self) Class'ParticleSystemComponent';
            BurningEffect.SetTemplate(BurningTemplate);
            Outer.Mesh.AttachComponentToSocket(BurningEffect, EffectSocketName);
            BurningEffect.ActivateSystem();            
        }
        else
        {
            BurningEffect.SetStopSpawning(-1, false);
        }
        Outer.PlaySoundBase(OnFireSound, true, true, true);        
    }
    else
    {
        if(BurningEffect != none)
        {
            BurningEffect.SetStopSpawning(-1, true);
        }
        Outer.PlaySoundBase(OnFireEndSound, true, true);
    }
}

protected event UpdateBurnedMatParam(float DeltaTime)
{
    local KFPawn_Monster P;
    local float MicrowaveParamValue, BurnedParam, FinalCharParam;

    if(bNoBurnedMatBeforeDeath && !Outer.bPlayedDeath)
    {
        return;
    }
    P = GetMonsterOwner();
    if(P != none)
    {
        MicrowaveParamValue = EvalInterpCurveFloat(MicroWaveCharCurve, ByteToFloat(P.RepInflateMatParam));
        if(MicrowaveParamValue > MicrowaveBurnedAmount)
        {
            MicrowaveBurnedAmount = MicrowaveParamValue;            
        }
        else
        {
            MicrowaveParamValue = MicrowaveBurnedAmount;
        }
    }
    if((Outer.bPlayedDeath || Outer.StackingIncaps[1].StackedPower > (Outer.StackingIncaps[1].Threshhold * FireCharPercentThreshhold)) && FireBurnedAmount < FireFullyCharredDuration)
    {
        FireBurnedAmount = FMin(FireBurnedAmount + DeltaTime, FireFullyCharredDuration);
        BurnedParam = FireBurnedAmount / FireFullyCharredDuration;
        if(MicrowaveParamValue > BurnedParam)
        {
            FinalCharParam = MicrowaveParamValue;
            MicrowaveBurnedAmount = FinalCharParam;            
        }
        else
        {
            FinalCharParam = BurnedParam;
        }
        Outer.RepFireBurnedAmount = FloatToByte(FinalCharParam);
        if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetBurnedParameter(FinalCharParam);
        }        
    }
    else
    {
        if(MicrowaveParamValue > float(0))
        {
            BurnedParam = FireBurnedAmount / FireFullyCharredDuration;
            if(MicrowaveParamValue > BurnedParam)
            {
                FinalCharParam = MicrowaveParamValue;                
            }
            else
            {
                FinalCharParam = BurnedParam;
            }
            Outer.RepFireBurnedAmount = FloatToByte(FinalCharParam);
            if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
            {
                SetBurnedParameter(FinalCharParam);
            }
        }
    }
    Outer.DeathFireStackedPower = FloatToByte(Outer.StackingIncaps[1].StackedPower / Outer.StackingIncaps[1].Threshhold);
}

event SetPoisoned(bool bEnabled)
{
    local KFPawn_Monster P;

    P = GetMonsterOwner();
    if(Outer.Role == ROLE_Authority)
    {
        if(P.bIsPoisoned == bEnabled)
        {
            return;
        }
        P.bIsPoisoned = bEnabled;
        Outer.OnStackingAfflictionChanged(2);
    }
    SetPoisonedOverlay(bEnabled);
}

function SetPoisonedOverlay(bool bEnabled)
{
    local MaterialInstanceConstant MIC;

    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        MIC = ((Outer.GoreMIC != none) ? Outer.GoreMIC : Outer.BodyMIC);
        if(bEnabled)
        {
            MIC.SetScalarParameterValue('Scalar_Poison', 1);            
        }
        else
        {
            MIC.SetScalarParameterValue('Scalar_Poison', 0);
        }
    }
}

event SetFrozen(bool bEnabled)
{
    if(!Outer.IsAliveAndWell())
    {
        return;
    }
    if(Outer.Role == ROLE_Authority)
    {
        Outer.OnStackingAfflictionChanged(5);
        Outer.DoSpecialMove(10, true);
    }
}

function SetFrozenParameter(float FreezeAmount)
{
    local MaterialInstanceConstant MIC;

    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        MIC = ((Outer.GoreMIC != none) ? Outer.GoreMIC : Outer.BodyMIC);
        MIC.SetScalarParameterValue('Scalar_Freeze', FreezeAmount);
    }
}

event SetMicrowavePanicked(bool bEnabled)
{
    local KFPawn_Monster P;

    if(Outer.Role == ROLE_Authority)
    {
        P = GetMonsterOwner();
        if(P.bMicrowavePanicked != bEnabled)
        {
            P.bMicrowavePanicked = bEnabled;
            Outer.OnStackingAfflictionChanged(3);
        }
    }
}

protected event UpdateMicrowaveMatParam(float DeltaTime)
{
    local KFPawn_Monster P;
    local float ParamValue;

    P = GetMonsterOwner();
    if(Outer.bPlayedDeath)
    {
        ParamValue = 0;        
    }
    else
    {
        if((P != none) && P.bMicrowavePanicked)
        {
            ParamValue = 1;            
        }
        else
        {
            ParamValue = FMin(Outer.StackingIncaps[3].StackedPower / Outer.StackingIncaps[3].Threshhold, 1);
        }
    }
    if(ParamValue < MicrowavedAmount)
    {
        if(Outer.bPlayedDeath)
        {
            MicrowavedAmount = FMax(MicrowavedAmount - (DeltaTime * 4), 0);            
        }
        else
        {
            MicrowavedAmount = FMax(MicrowavedAmount - (DeltaTime * 0.5), 0);
        }        
    }
    else
    {
        if(ParamValue > MicrowavedAmount)
        {
            MicrowavedAmount = FMin(MicrowavedAmount + (DeltaTime * 2), 1);            
        }
        else
        {
            MicrowavedAmount = ParamValue;
        }
    }
    if(UsedMicrowavedAmount >= 0.1)
    {
        UsedMicrowavedAmount = FMax(MicrowavedAmount, 0.1);        
    }
    else
    {
        UsedMicrowavedAmount = MicrowavedAmount;
    }
    P.RepInflateMatParam = FloatToByte(UsedMicrowavedAmount);
    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetMicrowaveParameter(UsedMicrowavedAmount);
    }
    if((Outer.StackingIncaps[1].StackedPower <= float(0)) && !Outer.bFirePanicked)
    {
        UpdateBurnedMatParam(DeltaTime);
    }
}

function SetMicrowaveParameter(float ParamValue)
{
    local MaterialInstanceConstant MIC;

    if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(ParamValue > 0.1)
        {
            if(!bSteamEffectActive)
            {
                SetMicrowaveSteamEffects(true);
            }            
        }
        else
        {
            if(bSteamEffectActive)
            {
                SetMicrowaveSteamEffects(false);
            }
        }
        MIC = ((Outer.GoreMIC != none) ? Outer.GoreMIC : Outer.BodyMIC);
        if(Outer.GoreMIC == none)
        {
            MIC.SetScalarParameterValue('Scalar_Inflate', ParamValue * 2);            
        }
        else
        {
            MIC.SetScalarParameterValue('Scalar_Inflate', 0);
        }
    }
}

protected function SetMicrowaveSteamEffects(bool bEnabled)
{
    if(Outer.WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    bSteamEffectActive = bEnabled;
    if(bEnabled)
    {
        if(SteamingEffect == none)
        {
            SteamingEffect = new (self) Class'ParticleSystemComponent';
            SteamingEffect.SetTemplate(SteamingTemplate);
            Outer.Mesh.AttachComponentToSocket(SteamingEffect, EffectSocketName);
            SteamingEffect.ActivateSystem();            
        }
        else
        {
            SteamingEffect.SetStopSpawning(-1, false);
        }
        Outer.PlaySoundBase(OnSteamSound, true, true, true);        
    }
    else
    {
        if(SteamingEffect != none)
        {
            SteamingEffect.SetStopSpawning(-1, true);
        }
        Outer.PlaySoundBase(OnSteamEndSound, true, true);
    }
}

function float GetAfflictionDuration(KFPawnAfflictions.EStackingIncaps AfflictionId)
{
    if(AfflictionId < Outer.StackingIncaps.Length)
    {
        return Outer.StackingIncaps[AfflictionId].Duration;
    }
}

simulated function ShutDown()
{
    if(Outer.bFirePanicked)
    {
        SetFirePanicked(false);
    }
    if(Outer.bEmpDisrupted)
    {
        SetEMPDisrupted(false);
    }
    if(Outer.bEmpPanicked)
    {
        SetEMPPanicked(false);
    }
    if(bSteamEffectActive)
    {
        SetMicrowaveParameter(0);
    }
}

defaultproperties
{
    MicroWaveCharCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    SteamingTemplate=ParticleSystem'FX_Impacts_EMIT.FX_Microwave_steam_01'
    BurningTemplate=ParticleSystem'FX_Gameplay_EMIT.Chr.FX_CHR_Fire'
    EmpPanicTemplate=ParticleSystem'FX_Gameplay_EMIT.FX_Char_Emp_clot'
    EmpDisruptTemplate=ParticleSystem'FX_Gameplay_EMIT.Chr.FX_CHR_Weapon_Disable_Emp'
    EffectSocketName=Hips
    EMPDisruptSocketName=EMPDisruptSocket
    OnFireSound=AkEvent'WW_WEP_SA_Flamethrower.Play_WEP_SA_Flamethrower_Fleshburn_Loop'
    OnFireEndSound=AkEvent'WW_WEP_SA_Flamethrower.Stop_WEP_SA_Flamethrower_Fleshburn_Loop'
    OnSteamSound=AkEvent'WW_WEP_SA_Microwave_Gun.Play_Microwave_Steam'
    OnSteamEndSound=AkEvent'WW_WEP_SA_Microwave_Gun.Stop_Microwave_Steam'
    OnEMPSound=AkEvent'WW_WEP_EXP_Grenade_EMP.Play_WEP_EXP_Grenade_EMP_Shock_LP'
    OnEMPEndSound=AkEvent'WW_WEP_EXP_Grenade_EMP.Stop_WEP_EXP_Grenade_EMP_Shock_LP'
}