/*******************************************************************************
 * KFAIController_Hans generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController_Hans extends KFAIController_ZedBoss
    native(AI)
    config(AI)
    hidecategories(Navigation);

struct native TrackedEnemyInfo
{
    var KFPawn TrackedEnemy;
    var float LastTimeVisible;
    var Vector LastVisibleLocation;
    var float LastTimeFiredOn;
    var float LastTimeGrenadeAttacked;
    var int NumTimesEngagedRecently;

    structdefaultproperties
    {
        TrackedEnemy=none
        LastTimeVisible=0
        LastVisibleLocation=(X=0,Y=0,Z=0)
        LastTimeFiredOn=0
        LastTimeGrenadeAttacked=0
        NumTimesEngagedRecently=0
    }
};

var transient KFPawn_ZedHansBase MyHansPawn;
var Vector RangedAttackMoveLoc;
var bool bFoundGrenadeThrowLocation;
var bool bWantsToThrowGrenade;
var Vector CalcedGreanadeTossVelForNavMeshLoc;
var float TimeCalcedGreanadeTossVelWasFound;
var Vector EnemysLocationWhenTossVelWasFound;
var float LostSightSprintDelay;
var float BarrageStartTime;
var float LastFireTime;
var float StartDrawGunsTime;
var float StartGunAttackTime;
var Actor LastTarget;
var float TimeFirstSawTarget;
var float LastStanceChangeTime;
/** Can't change stances more often than this */
var() float StanceChangeCooldown;
var float LastAttackMoveFinishTime;
/** Wait this long to do a gun attack after doing a melee attack */
var() float PostAttackMoveGunCooldown;
var array<TrackedEnemyInfo> RecentlySeenEnemyList;
var KFPawn LastRecentlySeenEnemyGunned;
var KFPawn LastRecentlySeenEnemyGrenaded;
/** How often to update RecentlySeenEnemyList */
var() float RecentSeenEnemyListUpdateInterval;
var float LastRecentSeenEnemyListUpdateTime;
/** Min length of a burst for this weapon when used by AI. Randomly used to calculate the BurstAmount */
var(Firing) int MinBurstAmount;
/** Max length of a burst for this weapon when used by AI. Randomly used to calculate the BurstAmount */
var(Firing) int MaxBurstAmount;
/** How long to wait between bursts when this weapon is used by AI */
var(Firing) float BurstWaitTime;
/** How long to wait between barrages (groups of bursts) when this weapon is used by AI */
var(Firing) float BarrageWaitTime;
/** Interp curve to scale how long Hans waits between barrages for different ranges */
var() InterpCurveFloat BarrageWaitDistanceCurve;
/** Interp curve to scale how long Hans waits between bursts for different ranges */
var() InterpCurveFloat BurstWaitDistanceCurve;
/** How long a barrage (groups of bursts) will last */
var(Firing) float BarrageLength;
var int BurstAmount;
/** How long to wait to stop firing after losing sight of an enemy */
var(Firing) float LostSightStopFireDelay;
var float LastFireMode;
/** How long to wait after starting to draw our guns to fire */
var(Firing) float DrawGunFireDelay;
/** How long to wait after staring to see an enemy to fire */
var(Firing) float TargetAquisitionDelay;
/** How long this gun attack should last at the max */
var(Firing) float MaxGunAttackLength;
/** How long to wait after drawing the guns before allowing a grenade toss to interrupt them */
var(Firing) float GrenadeGunInterruptDelay;
var float StartShootingRange;
var float MinShootingRange;
var float ShootingCooldown;
var KFPawn_ZedHansBase.EHansNadeType CurrentNadeAttackType;
/** How often to check if we want to do a grenade attack */
var() float GrenadeAttackEvalInterval;
var float LastGrenadeAttackEvalTime;

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    if(KFPawn_ZedHansBase(inPawn) != none)
    {
        MyHansPawn = KFPawn_ZedHansBase(inPawn);        
    }
    else
    {
        WarnInternal(((string(GetFuncName()) $ "() attempting to possess ") $ string(inPawn)) $ ", but it's not a KFPawn_ZedHansBase class! MyHansPawn variable will not be valid.");
    }
    super.Possess(inPawn, bVehicleTransition);
}

function PawnDied(Pawn inPawn)
{
    if(MyHansPawn != none)
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayBossDeathDialog(MyHansPawn);
        }
        MyHansPawn = none;
    }
    super(KFAIController).PawnDied(inPawn);
}

simulated event Destroyed()
{
    MyHansPawn = none;
    super(KFAIController).Destroyed();
}

function DoGrenadeThrow(optional bool bGrenadeBarrage)
{
    if(MyHansPawn != none)
    {
        MyHansPawn.SetActiveGrenadeClassGrenade();
    }
    if(Class'AICommand_ThrowGrenade'.static.ThrowGrenade(self, ((bGrenadeBarrage) ? 2 : 0)))
    {
        if(MyHansPawn != none)
        {
            MyHansPawn.BarrageTossCount = 0;
            MyHansPawn.bDoingBarrage = bGrenadeBarrage;
        }
    }
}

function DoSmokeGrenadeThrow(optional bool bGrenadeBarrage, optional bool bSpawnZeds)
{
    local bool bThrowSuccess;
    local int DifficultyIndex;
    local KFAIWaveInfo MinionWave;

    if(MyHansPawn != none)
    {
        MyHansPawn.SetActiveGrenadeClassSmoke();
    }
    if(!bSpawnZeds)
    {
        bThrowSuccess = Class'AICommand_ThrowGrenade'.static.ThrowGrenade(self, ((bGrenadeBarrage) ? 1 : 0));        
    }
    else
    {
        if(Skill == Class'KFDifficultyInfo'.static.GetDifficultyValue(0))
        {
            DifficultyIndex = 0;            
        }
        else
        {
            if(Skill <= Class'KFDifficultyInfo'.static.GetDifficultyValue(1))
            {
                DifficultyIndex = 1;                
            }
            else
            {
                if(Skill <= Class'KFDifficultyInfo'.static.GetDifficultyValue(2))
                {
                    DifficultyIndex = 2;                    
                }
                else
                {
                    DifficultyIndex = 3;
                }
            }
        }
        if(MyHansPawn == none)
        {
            return;
        }
        if(MyHansPawn.CurrentBattlePhase == 1)
        {
            MinionWave = MyHansPawn.SummonWaves[DifficultyIndex].PhaseOneWave;            
        }
        else
        {
            if(MyHansPawn.CurrentBattlePhase == 2)
            {
                MinionWave = MyHansPawn.SummonWaves[DifficultyIndex].PhaseTwoWave;                
            }
            else
            {
                if(MyHansPawn.CurrentBattlePhase == 3)
                {
                    MinionWave = MyHansPawn.SummonWaves[DifficultyIndex].PhaseThreeWave;
                }
            }
        }
        bThrowSuccess = Class'AICommand_ThrowGrenade'.static.ThrowGrenade(self, ((bGrenadeBarrage) ? 1 : 0),, MinionWave, MyHansPawn.NumMinionsToSpawn);
    }
    if(bThrowSuccess)
    {
        if(MyHansPawn != none)
        {
            MyHansPawn.bPendingSmokeGrenadeBarrage = false;
            MyHansPawn.BarrageTossCount = 0;
            MyHansPawn.bDoingBarrage = bGrenadeBarrage;
        }
    }
}

function NotifySpecialMoveEnded(KFSpecialMove SM)
{
    super(KFAIController).NotifySpecialMoveEnded(SM);
    if((MyHansPawn != none) && MyHansPawn.bPendingSmokeGrenadeBarrage)
    {
        DoSmokeGrenadeThrow(true, true);
    }
    if(((((SM.Handle == 'KFSM_MeleeAttack') || SM.Handle == 'SM_Hans_GrenadeBarrage') || SM.Handle == 'KFSM_Hans_ThrowGrenade') || SM.Handle == 'KFSM_Taunt') || SM.Handle == 'KFSM_WalkingTaunt')
    {
        LastAttackMoveFinishTime = WorldInfo.TimeSeconds;
    }
    EvaluateSprinting();
}

function EvaluateSprinting()
{
    if(((MyKFPawn != none) && MyKFPawn.IsAliveAndWell()) && Enemy != none)
    {
        if(ShouldSprint())
        {
            MyKFPawn.SetSprinting(true);            
        }
        else
        {
            MyKFPawn.SetSprinting(false);
        }
    }
}

event SeePlayer(Pawn Seen)
{
    local int EnemyListIndex;
    local TrackedEnemyInfo NewTrackedEnemy;
    local KFPawn KFP;

    super(KFAIController).SeePlayer(Seen);
    EvaluateSprinting();
    if((((((Seen == none) || !Seen.IsAliveAndWell()) || Pawn.IsSameTeam(Seen)) || Pawn == none) || !Pawn.IsAliveAndWell()) || !Seen.CanAITargetThisPawn(self))
    {
        return;
    }
    KFP = KFPawn(Seen);
    if(KFP != none)
    {
        EnemyListIndex = RecentlySeenEnemyList.Find('TrackedEnemy', KFP;
        if(EnemyListIndex == -1)
        {
            NewTrackedEnemy.TrackedEnemy = KFP;
            NewTrackedEnemy.LastTimeVisible = WorldInfo.TimeSeconds;
            NewTrackedEnemy.LastVisibleLocation = Seen.Location;
            RecentlySeenEnemyList[RecentlySeenEnemyList.Length] = NewTrackedEnemy;            
        }
        else
        {
            RecentlySeenEnemyList[EnemyListIndex].LastTimeVisible = WorldInfo.TimeSeconds;
            RecentlySeenEnemyList[EnemyListIndex].LastVisibleLocation = Seen.Location;
        }
    }
}

function DoNerveGasGrenadeThrow(optional bool bGrenadeBarrage)
{
    if(MyHansPawn != none)
    {
        MyHansPawn.SetActiveGrenadeClassNerveGas();
    }
    if(Class'AICommand_ThrowGrenade'.static.ThrowGrenade(self, ((bGrenadeBarrage) ? 1 : 0)))
    {
        if(MyHansPawn != none)
        {
            MyHansPawn.BarrageTossCount = 0;
            MyHansPawn.bDoingBarrage = bGrenadeBarrage;
        }
    }
}

function bool ShouldSprint()
{
    local float RangeToEnemy;

    if((((Enemy != none) && MyHansPawn != none) && !MyHansPawn.bIsHeadless) && !MyHansPawn.bEmpPanicked)
    {
        if(MyHansPawn.bInHuntAndHealMode)
        {
            return true;
        }
        if((LastEnemySightedTime == float(0)) || (WorldInfo.TimeSeconds - LastEnemySightedTime) > LostSightSprintDelay)
        {
            return true;
        }
        if(MyHansPawn.bGunsEquipped)
        {
            RangeToEnemy = VSize(Enemy.Location - Pawn.Location);
            if((RangeToEnemy > StartShootingRange) || RangeToEnemy < MinShootingRange)
            {
                return true;                
            }
            else
            {
                return false;
            }
        }
        return MyHansPawn.DesireSprintingInThisPhase();
    }
    return false;
}

function FireTimer()
{
    local float UsedBarrageWaitTime, UsedBurstWaitTime;

    if((Enemy == none) || Pawn == none)
    {
        ClearFireTiming();
        return;
    }
    if(!CanSee(Enemy) && (WorldInfo.TimeSeconds - LastEnemySightedTime) >= LostSightStopFireDelay)
    {
        ClearFireTiming();
        TimeFirstSawTarget = 0;
        BarrageStartTime = 0;
        return;
    }
    if(MyKFPawn.IsDoingMeleeAttack())
    {
        ClearFireTiming();
        return;
    }
    if((LastTarget == none) || TimeFirstSawTarget == float(0))
    {
        LastTarget = Enemy;
        TimeFirstSawTarget = WorldInfo.TimeSeconds;
    }
    if((TimeFirstSawTarget > float(0)) && (WorldInfo.TimeSeconds - TimeFirstSawTarget) < TargetAquisitionDelay)
    {
        SetTimer(TargetAquisitionDelay - (WorldInfo.TimeSeconds - TimeFirstSawTarget), false, 'FireTimer', self);
        Pawn.StopFiring();
        BarrageStartTime = 0;
        return;
    }
    if((BarrageStartTime > float(0)) && (WorldInfo.TimeSeconds - BarrageStartTime) > BarrageLength)
    {
        if((Enemy != none) && Pawn != none)
        {
            UsedBarrageWaitTime = BarrageWaitTime * EvalInterpCurveFloat(BarrageWaitDistanceCurve, VSize(Pawn.Location - Enemy.Location));            
        }
        else
        {
            UsedBarrageWaitTime = BarrageWaitTime;
        }
        SetTimer(UsedBarrageWaitTime, false, 'FireTimer', self);
        BarrageStartTime = 0;
        Pawn.StopFiring();
        return;        
    }
    else
    {
        if(BarrageStartTime == float(0))
        {
            BarrageStartTime = WorldInfo.TimeSeconds;
        }
    }
    if(BurstAmount == 0)
    {
        BurstAmount = int(RandRange(float(MinBurstAmount), float(MaxBurstAmount)));
        if(!CanPerformShotAttack())
        {
            ClearFireTiming();
            BarrageStartTime = 0;            
        }
        else
        {
            UsedBurstWaitTime = BurstWaitTime + (((FRand() * BurstWaitTime) * 0.15) - (BurstWaitTime * 0.3));
            if((Enemy != none) && Pawn != none)
            {
                UsedBurstWaitTime = UsedBurstWaitTime * EvalInterpCurveFloat(BurstWaitDistanceCurve, VSize(Pawn.Location - Enemy.Location));
            }
            SetTimer(UsedBurstWaitTime, false, 'FireTimer', self);
            Pawn.StopFiring();
            if(FRand() < 0.5)
            {
                SelectNewGunFireEnemy(KFPawn(Enemy));
            }
        }
        return;
    }
    if(!Pawn.NeedToTurn(GetAimingLocation()) && (WorldInfo.TimeSeconds - LastFireTime) > Pawn.Weapon.FireInterval[int(LastFireMode)])
    {
        Pawn.BotFire(true);
        LastFireMode = 0;
        LastFireTime = WorldInfo.TimeSeconds;
        SetTimer(Pawn.Weapon.FireInterval[int(LastFireMode)] * float(BurstAmount), false, 'FireTimer', self);
        BurstAmount = 0;
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayBeingShotAtDialog(KFPawn_Human(Enemy), MyKFPawn);
        }        
    }
    else
    {
        SetTimer(0.1, false, 'FireTimer', self);
    }
}

function ClearFireTiming()
{
    SetTimer(0, false, 'FireTimer', self);
    SetTimer(0, false, 'StartFireTiming', self);
    if(Pawn != none)
    {
        Pawn.StopFiring();
    }
}

event bool SetEnemy(Pawn NewEnemy)
{
    if(((((MyKFPawn != none) && MyKFPawn.IsDoingSpecialMove(4)) && Enemy != none) && Enemy.IsAliveAndWell()) && Enemy.CanAITargetThisPawn(self))
    {
        return false;
    }
    return super.SetEnemy(NewEnemy);
}

function SelectNewGunFireEnemy(KFPawn CurrentEnemy)
{
    local int RandIdx, I;
    local array<TrackedEnemyInfo> TargetCandidates;
    local int EnemyListIndex;

    if(RecentlySeenEnemyList.Length > 0)
    {
        I = RecentlySeenEnemyList.Length - 1;
        J0x27:

        if(I >= 0)
        {
            if(((RecentlySeenEnemyList[I].TrackedEnemy == none) || !RecentlySeenEnemyList[I].TrackedEnemy.IsAliveAndWell()) || !RecentlySeenEnemyList[I].TrackedEnemy.CanAITargetThisPawn(self))
            {
                RecentlySeenEnemyList.Remove(I, 1;
                goto J0x17B;                
            }
            else
            {
                if(!MyHansPawn.NeedToTurnEx(RecentlySeenEnemyList[I].LastVisibleLocation, 0))
                {
                    TargetCandidates[TargetCandidates.Length] = RecentlySeenEnemyList[I];
                }
            }
            J0x17B:

            -- I;
            goto J0x27;
        }
        I = TargetCandidates.Length - 1;
        J0x1A0:

        if(I >= 0)
        {
            if(((TargetCandidates.Length > 1) && TargetCandidates[I].TrackedEnemy == LastRecentlySeenEnemyGunned) && (WorldInfo.TimeSeconds - TargetCandidates[I].LastTimeFiredOn) < 3)
            {
                TargetCandidates.Remove(I, 1;
            }
            -- I;
            goto J0x1A0;
        }
        if(TargetCandidates.Length > 0)
        {
            RandIdx = Rand(TargetCandidates.Length);
            LastRecentlySeenEnemyGunned = TargetCandidates[RandIdx].TrackedEnemy;
            if(LastRecentlySeenEnemyGunned != none)
            {
                EnemyListIndex = RecentlySeenEnemyList.Find('TrackedEnemy', LastRecentlySeenEnemyGunned;
                if(EnemyListIndex != -1)
                {
                    RecentlySeenEnemyList[EnemyListIndex].LastTimeFiredOn = WorldInfo.TimeSeconds;
                }
            }
        }
    }
}

function Vector GetAimingLocation()
{
    local KFPawn KFP;
    local Vector AimingLocation;
    local int EnemyListIndex;

    KFP = KFPawn(Enemy);
    if(LastRecentlySeenEnemyGunned != none)
    {
        EnemyListIndex = RecentlySeenEnemyList.Find('TrackedEnemy', LastRecentlySeenEnemyGunned;
        if(EnemyListIndex != -1)
        {
            RecentlySeenEnemyList[EnemyListIndex].LastTimeFiredOn = WorldInfo.TimeSeconds;
            if((WorldInfo.TimeSeconds - RecentlySeenEnemyList[EnemyListIndex].LastTimeFiredOn) < 1)
            {
                KFP = LastRecentlySeenEnemyGunned;
            }
        }
    }
    if(KFP == none)
    {
        if(Focus != none)
        {
            AimingLocation = Focus.Location;            
        }
        else
        {
            if(Pawn != none)
            {
                AimingLocation = Pawn.Location + (vector(Pawn.Rotation) * float(128));
            }
        }        
    }
    else
    {
        AimingLocation = KFP.Location + ((vect(0, 0, 1) * KFP.BaseEyeHeight) * 0.5);
    }
    return AimingLocation;
}

function StartFireTiming()
{
    if((Pawn != none) && Pawn.Weapon != none)
    {
        if((WorldInfo.TimeSeconds - LastFireTime) > ((Pawn.Weapon.FireInterval[0] + BurstWaitTime) + (BurstWaitTime * 0.3)))
        {
            BurstAmount = int(RandRange(float(MinBurstAmount), float(MaxBurstAmount)));
            FireTimer();            
        }
    }
}

function bool CanPerformShotAttack(optional bool bStart)
{
    local float RangeToEnemy;

    if(bStart && (Pawn.IsFiring() || IsTimerActive('FireTimer', self)) || IsTimerActive('StartFireTiming', self))
    {
        return false;
    }
    if(bStart && (WorldInfo.TimeSeconds - LastAttackMoveFinishTime) < PostAttackMoveGunCooldown)
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - StartDrawGunsTime) < DrawGunFireDelay)
    {
        return false;
    }
    if((MyKFPawn != none) && MyKFPawn.bIsSprinting)
    {
        return false;
    }
    if(Enemy != none)
    {
        if((bStart && LastShotTime > float(0)) && (WorldInfo.TimeSeconds - LastShotTime) < ShootingCooldown)
        {
            return false;
        }
        if(MyKFPawn.IsImpaired())
        {
            return false;
        }
        RangeToEnemy = VSize(Enemy.Location - MyKFPawn.Location);
        if(((RangeToEnemy < StartShootingRange) && RangeToEnemy > MinShootingRange) && !MyKFPawn.IsDoingMeleeAttack())
        {
            if(CanSee(Enemy))
            {
                return true;                
            }
            else
            {
                if((WorldInfo.TimeSeconds - LastEnemySightedTime) >= LostSightStopFireDelay)
                {
                    TimeFirstSawTarget = 0;
                }
            }
        }
    }
    return false;
}

function bool CanStanceChange()
{
    return (LastStanceChangeTime == float(0)) || (WorldInfo.TimeSeconds - LastStanceChangeTime) > StanceChangeCooldown;
}

simulated function Tick(float DeltaTime)
{
    super(KFAIController).Tick(DeltaTime);
    if(Role == ROLE_Authority)
    {
        TickRangedCombatDecision();
    }
}

function TickRangedCombatDecision()
{
    local int I;

    if((LastRecentSeenEnemyListUpdateTime == float(0)) || (WorldInfo.TimeSeconds - LastRecentSeenEnemyListUpdateTime) > RecentSeenEnemyListUpdateInterval)
    {
        LastRecentSeenEnemyListUpdateTime = WorldInfo.TimeSeconds;
        I = RecentlySeenEnemyList.Length - 1;
        J0x89:

        if(I >= 0)
        {
            if((((RecentlySeenEnemyList[I].TrackedEnemy == none) || !RecentlySeenEnemyList[I].TrackedEnemy.IsAliveAndWell()) || !RecentlySeenEnemyList[I].TrackedEnemy.CanAITargetThisPawn(self)) || (WorldInfo.TimeSeconds - RecentlySeenEnemyList[I].LastTimeVisible) > 5)
            {
                RecentlySeenEnemyList.Remove(I, 1;                
            }
            else
            {
                if(CanSee(RecentlySeenEnemyList[I].TrackedEnemy))
                {
                    RecentlySeenEnemyList[I].LastVisibleLocation = RecentlySeenEnemyList[I].TrackedEnemy.Location;
                    RecentlySeenEnemyList[I].LastTimeVisible = WorldInfo.TimeSeconds;
                }
            }
            -- I;
            goto J0x89;
        }
    }
    if((LastGrenadeAttackEvalTime == float(0)) || (WorldInfo.TimeSeconds - LastGrenadeAttackEvalTime) > GrenadeAttackEvalInterval)
    {
        LastGrenadeAttackEvalTime = WorldInfo.TimeSeconds;
        if(SetupGrenadeAttack())
        {
            if(CurrentNadeAttackType == 1)
            {
                DoGrenadeThrow(false);                
            }
            else
            {
                if(CurrentNadeAttackType == 4)
                {
                    DoGrenadeThrow(true);                    
                }
                else
                {
                    if(CurrentNadeAttackType == 2)
                    {
                        DoNerveGasGrenadeThrow(false);                        
                    }
                    else
                    {
                        if(CurrentNadeAttackType == 5)
                        {
                            DoNerveGasGrenadeThrow(true);                            
                        }
                        else
                        {
                            if(CurrentNadeAttackType == 3)
                            {
                                DoSmokeGrenadeThrow(false);
                            }
                        }
                    }
                }
            }
        }
    }
    TickGunSystem();
}

function TickGunSystem()
{
    local KFPawn_ZedHansBase HansPawn;
    local KFSpecialMove curMove;
    local float RangeToEnemy;
    local bool bGrenadeAttackInterrupt;

    if(MyKFPawn.SpecialMoves.Length > MyKFPawn.SpecialMove)
    {
        curMove = MyKFPawn.SpecialMoves[MyKFPawn.SpecialMove];        
    }
    else
    {
        curMove = none;
    }
    if(Pawn.Physics == 1)
    {
        HansPawn = KFPawn_ZedHansBase(MyKFPawn);
        if((curMove != none) && curMove.bDisablesWeaponFiring)
        {
            if((Pawn.IsFiring() || IsTimerActive('FireTimer', self)) || IsTimerActive('StartFireTiming', self))
            {
                ClearFireTiming();
                BarrageStartTime = 0;
            }
            return;
        }
        if((HansPawn != none) && (curMove == none) || !MyKFPawn.IsDoingSpecialMove(22) && !MyKFPawn.IsDoingSpecialMove(21))
        {
            if((Pawn.IsFiring() || IsTimerActive('FireTimer', self)) || IsTimerActive('StartFireTiming', self))
            {
                Focus = none;
                SetFocalPoint(GetAimingLocation());                
            }
            else
            {
                if(Focus == none)
                {
                    Focus = Enemy;
                }
            }
            if(Enemy != none)
            {
                RangeToEnemy = VSize(Enemy.Location - MyKFPawn.Location);                
            }
            else
            {
                RangeToEnemy = 2.147484E+09;
            }
            bGrenadeAttackInterrupt = GrenadeAttackInterruptGuns();
            if((HansPawn.bGunsEquipped && ((((RangeToEnemy > StartShootingRange) || HansPawn.bInHuntAndHealMode) || !HansPawn.CanUseGunsInThisPhase()) || HansPawn.bPendingSmokeGrenadeBarrage) || bGrenadeAttackInterrupt) && CanStanceChange())
            {
                ClearFireTiming();
                Class'AICommand_Hans_GunStance'.static.SetGunStance(self, 0);                
            }
            else
            {
                if((((((!HansPawn.bGunsEquipped && (LastShotTime == float(0)) || (WorldInfo.TimeSeconds - LastShotTime) > ShootingCooldown) && RangeToEnemy < StartShootingRange) && !HansPawn.bInHuntAndHealMode) && HansPawn.CanUseGunsInThisPhase()) && CanStanceChange()) && !bGrenadeAttackInterrupt)
                {
                    Class'AICommand_Hans_GunStance'.static.SetGunStance(self, 1);
                    StartDrawGunsTime = WorldInfo.TimeSeconds;
                    BarrageStartTime = 0;
                    if((StartGunAttackTime == float(0)) || (WorldInfo.TimeSeconds - StartGunAttackTime) > MaxGunAttackLength)
                    {
                        StartGunAttackTime = WorldInfo.TimeSeconds;
                    }                    
                }
                else
                {
                    if(((StartGunAttackTime > float(0)) && ((WorldInfo.TimeSeconds - StartGunAttackTime) > MaxGunAttackLength) || !HansPawn.CanUseGunsInThisPhase()) && CanStanceChange())
                    {
                        if(HansPawn.bGunsEquipped)
                        {
                            ClearFireTiming();
                            LastShotTime = WorldInfo.TimeSeconds;
                            StartDrawGunsTime = 0;
                            Class'AICommand_Hans_GunStance'.static.SetGunStance(self, 0);
                        }                        
                    }
                    else
                    {
                        if((HansPawn.bGunsEquipped && HansPawn.CanUseGunsInThisPhase()) && CanPerformShotAttack(true))
                        {
                            StartFireTiming();
                        }
                    }
                }
            }
        }
    }
}

function DrawRangedAttackInfo(HUD HUD)
{
    local Canvas Canvas;
    local float UsedShootCooldown;
    local KFSpecialMove curMove;
    local bool bMoveDisablesFiring;
    local float UsedGunAttackCooldown, UsedGlobalNadeAttackCooldown, UsedHENadeTossCooldown, UsedHENadeBarrageCooldown, UsedNerveGasTossCooldown, UsedNerveGasBarrageCooldown,
	    UsedSmokeTossCooldown, UsedDrawGunsCooldown, UsedAttackMoveGunsCooldown, UsedGunTargetAquisitionCooldown;

    local int I;
    local Vector EyeLocation;

    if(MyKFPawn == none)
    {
        return;
    }
    if(MyKFPawn.SpecialMoves.Length > MyKFPawn.SpecialMove)
    {
        curMove = MyKFPawn.SpecialMoves[MyKFPawn.SpecialMove];        
    }
    else
    {
        curMove = none;
    }
    if((curMove != none) && curMove.bDisablesWeaponFiring)
    {
        bMoveDisablesFiring = true;
    }
    Canvas = HUD.Canvas;
    Canvas.Font = Class'Engine'.static.GetTinyFont();
    Canvas.SetPos(float(Canvas.SizeX) * 0.7, float(Canvas.SizeY) * 0.25);
    Canvas.SetDrawColor(0, 200, 50);
    DrawDebugText(HUD, "Ranged Combat for " $ string(MyKFPawn.Name));
    DrawDebugText(HUD, "--------------------------------------");
    DrawDebugText(HUD, "Battle Phase: " $ string(MyHansPawn.CurrentBattlePhase));
    DrawDebugText(HUD, "--Guns--");
    DrawDebugText(HUD, (("Guns Equipped: " $ string(MyHansPawn.bGunsEquipped)) $ " Can Use Guns In This Phase: ") $ string(MyHansPawn.CanUseGunsInThisPhase()));
    DrawDebugText(HUD, (((("Stance Changing: " $ string(MyKFPawn.IsDoingSpecialMove(22))) $ " CurrentMove: ") $ string(curMove)) $ " bDisablesWeaponFiring: ") $ string(bMoveDisablesFiring));
    if((WorldInfo.TimeSeconds - StartDrawGunsTime) > DrawGunFireDelay)
    {
        UsedDrawGunsCooldown = 0;        
    }
    else
    {
        UsedDrawGunsCooldown = DrawGunFireDelay - (WorldInfo.TimeSeconds - StartDrawGunsTime);
    }
    if((WorldInfo.TimeSeconds - LastAttackMoveFinishTime) > PostAttackMoveGunCooldown)
    {
        UsedAttackMoveGunsCooldown = 0;        
    }
    else
    {
        UsedAttackMoveGunsCooldown = PostAttackMoveGunCooldown - (WorldInfo.TimeSeconds - LastAttackMoveFinishTime);
    }
    if((WorldInfo.TimeSeconds - LastShotTime) > ShootingCooldown)
    {
        UsedShootCooldown = 0;        
    }
    else
    {
        UsedShootCooldown = ShootingCooldown - (WorldInfo.TimeSeconds - LastShotTime);
    }
    if((WorldInfo.TimeSeconds - StartGunAttackTime) > MaxGunAttackLength)
    {
        UsedGunAttackCooldown = 0;        
    }
    else
    {
        UsedGunAttackCooldown = MaxGunAttackLength - (WorldInfo.TimeSeconds - StartGunAttackTime);
    }
    if((WorldInfo.TimeSeconds - TimeFirstSawTarget) > TargetAquisitionDelay)
    {
        UsedGunTargetAquisitionCooldown = 0;        
    }
    else
    {
        UsedGunTargetAquisitionCooldown = TargetAquisitionDelay - (WorldInfo.TimeSeconds - TimeFirstSawTarget);
    }
    DrawDebugText(HUD, (("Time Til We Can Shoot : " $ string(UsedShootCooldown)) $ " Time Til We Must Stop Shooting: ") $ string(UsedGunAttackCooldown), ((UsedShootCooldown <= float(0)) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, "Draw Guns Delay Til We Can Shoot : " $ string(UsedDrawGunsCooldown), ((UsedDrawGunsCooldown <= float(0)) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, "Attack Move Delay Til We Can Shoot : " $ string(UsedAttackMoveGunsCooldown), ((UsedAttackMoveGunsCooldown <= float(0)) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, "Target Aquisition Delay Til We Can Shoot : " $ string(UsedGunTargetAquisitionCooldown), ((UsedGunTargetAquisitionCooldown <= float(0)) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("FireTimer : " $ string(GetRemainingTimeForTimer('FireTimer'))) $ " StartFireTiming: ") $ string(GetRemainingTimeForTimer('StartFireTiming')), MakeColor(0, 255, 0, 255));
    DrawDebugText(HUD, "--Grenades--");
    DrawDebugText(HUD, (("CurrentNadeAttackType: " $ string(CurrentNadeAttackType)) $ " IsThrowingGrenade: ") $ string(MyHansPawn.IsThrowingGrenade()));
    if(Enemy != none)
    {
        DrawDebugText(HUD, (("Good Line Of Site: " $ string(CanSeeByPoints(Pawn.GetPawnViewLocation(), Enemy.Location, rotator(Enemy.Location - Pawn.GetPawnViewLocation())))) $ " Too Close To Regular Nade: ") $ string(IsWithinAttackRange()));        
    }
    else
    {
        DrawDebugText(HUD, "Good Line Of Site: No Enemy, Too Close To Regular Nade: " $ string(IsWithinAttackRange()));
    }
    if((MyHansPawn.LastOffensiveNadeTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastOffensiveNadeTime) > MyHansPawn.GlobalOffensiveNadeCooldown)
    {
        UsedGlobalNadeAttackCooldown = 0;        
    }
    else
    {
        UsedGlobalNadeAttackCooldown = MyHansPawn.GlobalOffensiveNadeCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastOffensiveNadeTime);
    }
    if((MyHansPawn.LastHENadeTossTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastHENadeTossTime) > MyHansPawn.HENadeTossCooldown)
    {
        UsedHENadeTossCooldown = 0;        
    }
    else
    {
        UsedHENadeTossCooldown = MyHansPawn.HENadeTossCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastHENadeTossTime);
    }
    if((MyHansPawn.LastHENadeBarrageTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastHENadeBarrageTime) > MyHansPawn.HENadeBarrageCooldown)
    {
        UsedHENadeBarrageCooldown = 0;        
    }
    else
    {
        UsedHENadeBarrageCooldown = MyHansPawn.HENadeBarrageCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastHENadeBarrageTime);
    }
    if((MyHansPawn.LastNerveGasTossTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastNerveGasTossTime) > MyHansPawn.NerveGasTossCooldown)
    {
        UsedNerveGasTossCooldown = 0;        
    }
    else
    {
        UsedNerveGasTossCooldown = MyHansPawn.NerveGasTossCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastNerveGasTossTime);
    }
    if((MyHansPawn.LastNerveGasBarrageTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastNerveGasBarrageTime) > MyHansPawn.NerveGasBarrageCooldown)
    {
        UsedNerveGasBarrageCooldown = 0;        
    }
    else
    {
        UsedNerveGasBarrageCooldown = MyHansPawn.NerveGasBarrageCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastNerveGasBarrageTime);
    }
    if((MyHansPawn.LastSmokeTossTime == float(0)) || (WorldInfo.TimeSeconds - MyHansPawn.LastSmokeTossTime) > MyHansPawn.SmokeTossCooldown)
    {
        UsedSmokeTossCooldown = 0;        
    }
    else
    {
        UsedSmokeTossCooldown = MyHansPawn.SmokeTossCooldown - (WorldInfo.TimeSeconds - MyHansPawn.LastSmokeTossTime);
    }
    DrawDebugText(HUD, (("Global Nade Cooldown Complete: " $ string(MyHansPawn.OffensiveGrenadeCooldownComplete())) $ " GlobalNadeAttackCooldown: ") $ string(UsedGlobalNadeAttackCooldown), ((MyHansPawn.OffensiveGrenadeCooldownComplete()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("Can Smoke Toss: " $ string(MyHansPawn.CanSmokeTossInThisPhase())) $ " SmokeTossCooldown: ") $ string(UsedSmokeTossCooldown), ((MyHansPawn.CanSmokeTossInThisPhase()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("Can Nerve Gas Toss: " $ string(MyHansPawn.CanTossNerveGasInThisPhase())) $ " NerveGasTossCooldown: ") $ string(UsedNerveGasTossCooldown), ((MyHansPawn.CanTossNerveGasInThisPhase()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("Can HE Grenade Toss: " $ string(MyHansPawn.CanTossGrenadeInThisPhase())) $ " HENadeTossCooldown: ") $ string(UsedHENadeTossCooldown), ((MyHansPawn.CanTossGrenadeInThisPhase()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("Can Nerve Gas Barrage: " $ string(MyHansPawn.CanBarrageNerveGasInThisPhase())) $ " NerveGasBarrageCooldown: ") $ string(UsedNerveGasBarrageCooldown), ((MyHansPawn.CanBarrageNerveGasInThisPhase()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, (("Can HE Grenade Barrage: " $ string(MyHansPawn.CanGrenadeBarrageInThisPhase())) $ " HENadeBarrageCooldown: ") $ string(UsedHENadeBarrageCooldown), ((MyHansPawn.CanGrenadeBarrageInThisPhase()) ? MakeColor(0, 255, 0, 255) : MakeColor(255, 0, 0, 255)));
    DrawDebugText(HUD, "--RecentlySeenEnemyList--");
    I = 0;
    J0x15D4:

    if(I < RecentlySeenEnemyList.Length)
    {
        DrawDebugText(HUD, (("TrackedEnemy #" $ string(I)) $ ": ") $ string(RecentlySeenEnemyList[I].TrackedEnemy));
        EyeLocation = MyKFPawn.Location + (vect(0, 0, 1) * MyKFPawn.BaseEyeHeight);
        DrawDebugLine(EyeLocation, RecentlySeenEnemyList[I].LastVisibleLocation, 254, 89, 18, false);
        ++ I;
        goto J0x15D4;
    }
}

function bool GrenadeAttackInterruptGuns()
{
    if(MyHansPawn.bGunsEquipped && (WorldInfo.TimeSeconds - StartDrawGunsTime) < GrenadeGunInterruptDelay)
    {
        return false;
    }
    if(MyHansPawn.CanGrenadeBarrageInThisPhase())
    {
        return true;        
    }
    else
    {
        if(MyHansPawn.CanBarrageNerveGasInThisPhase())
        {
            return true;            
        }
        else
        {
            if(MyHansPawn.CanTossGrenadeInThisPhase())
            {
                return true;                
            }
            else
            {
                if(MyHansPawn.CanTossNerveGasInThisPhase())
                {
                    return true;
                }
            }
        }
    }
    return false;
}

function bool SetupGrenadeAttack()
{
    if(((((((MyHansPawn != none) && Enemy != none) && !MyHansPawn.IsDoingSpecialMove(22)) && !MyHansPawn.IsThrowingGrenade()) && !MyHansPawn.bGunsEquipped) && CanSeeByPoints(Pawn.GetPawnViewLocation(), Enemy.Location, rotator(Enemy.Location - Pawn.GetPawnViewLocation()))) && MyHansPawn.CacheGrenadeThrowLocation())
    {
        CurrentNadeAttackType = 0;
        if(!IsWithinAttackRange())
        {
            if(MyHansPawn.CanGrenadeBarrageInThisPhase())
            {
                CurrentNadeAttackType = 4;                
            }
            else
            {
                if(MyHansPawn.CanBarrageNerveGasInThisPhase())
                {
                    CurrentNadeAttackType = 5;                    
                }
                else
                {
                    if(MyHansPawn.CanTossGrenadeInThisPhase())
                    {
                        CurrentNadeAttackType = 1;                        
                    }
                    else
                    {
                        if(MyHansPawn.CanTossNerveGasInThisPhase())
                        {
                            CurrentNadeAttackType = 2;
                        }
                    }
                }
            }            
        }
        else
        {
            if(MyHansPawn.CanSmokeTossInThisPhase())
            {
                CurrentNadeAttackType = 3;
            }
        }
        if(CurrentNadeAttackType != 0)
        {
            return true;            
        }
        else
        {
            return false;
        }        
    }
    else
    {
        return false;
    }
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum)
{
    if(((MyHansPawn != none) && !MyHansPawn.bHealedThisPhase) && MyHansPawn.CurrentBattlePhase < 4)
    {
        if(GetHealthPercentage() < 0.35)
        {
            MyHansPawn.SetHuntAndHealMode(true);
            NextBattlePhase();
        }
    }
    super(Controller).NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
}

function DoStrike()
{
    local name AttackName;

    if((MyHansPawn != none) && MyHansPawn.PawnAnimInfo != none)
    {
        AttackName = MyHansPawn.PawnAnimInfo.Attacks[PendingAnimStrikeIndex].Tag;
        if(AttackName == 'Frenzy_Lunge')
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayHansFrenzyDialog(MyHansPawn);
            }
        }
    }
    super(KFAIController_Monster).DoStrike();
}

function NextBattlePhase()
{
    if(!MyHansPawn.bGunsEquipped)
    {
        DoSmokeGrenadeThrow(true, true);        
    }
    else
    {
        MyHansPawn.bPendingSmokeGrenadeBarrage = true;
    }
    MyHansPawn.IncrementBattlePhase(self);
}

function bool IsWithinAttackRange()
{
    local float DistSqToEnemy;

    if((MyHansPawn == none) || !bEnemyIsVisible)
    {
        return false;
    }
    if(!MyHansPawn.bInHuntAndHealMode)
    {
        return super(KFAIController).IsWithinAttackRange();
    }
    DistSqToEnemy = VSizeSq(Enemy.Location - Pawn.Location);
    if(DistSqToEnemy <= (MinDistanceToPerformGrabAttack * MinDistanceToPerformGrabAttack))
    {
        return true;
    }
    return false;
}

event bool CanGrabAttack()
{
    local KFPawn KFPawnEnemy;
    local float DistSq;
    local Vector HitLocation, HitNormal;
    local Actor HitActor;

    if((((Enemy == none) || MyKFPawn == none) || MyKFPawn.Health <= 0) || GetHealthPercentage() >= 1)
    {
        return false;
    }
    if((MyHansPawn != none) && !MyHansPawn.bInHuntAndHealMode || MyHansPawn.bPendingSmokeGrenadeBarrage)
    {
        return false;
    }
    if(((((MyKFPawn == none) || !MyKFPawn.bCanGrabAttack) || MyKFPawn.Health <= 0) || Enemy == none) || (Enemy != none) && Pawn.IsSameTeam(Enemy))
    {
        return false;
    }
    KFPawnEnemy = KFPawn(Enemy);
    if(((KFPawnEnemy != none) && KFPawnEnemy.IsDoingSpecialMove(19)) && VSizeSq(MyHansPawn.Location - Enemy.Location) < float(250000))
    {
        KFPawnEnemy.InteractionPawn.EndSpecialMove();
    }
    if((KFPawnEnemy == none) || !KFPawnEnemy.CanBeGrabbed(MyKFPawn))
    {
        return false;
    }
    if(((MyKFPawn.bIsHeadless || MyKFPawn.Physics == 2) || IsDoingAttackSpecialMove()) || IsInStumble())
    {
        return false;
    }
    if((LastAttackTime_Grab == 0) || (WorldInfo.TimeSeconds - LastAttackTime_Grab) > MinTimeBetweenGrabAttacks)
    {
        if(Abs(Enemy.Location.Z - Pawn.Location.Z) > Pawn.CylinderComponent.CollisionHeight)
        {
            return false;
        }
        DistSq = VSizeSq(Enemy.Location - Pawn.Location);
        if(DistSq > (MinDistanceToPerformGrabAttack * MinDistanceToPerformGrabAttack))
        {
            return false;
        }
        HitActor = Trace(HitLocation, HitNormal, Enemy.Location, Pawn.Location, true);
        if((HitActor != none) && HitActor != Enemy)
        {
            return false;
        }
        if(!CanTargetBeGrabbed(KFPawn(Enemy)))
        {
            return false;
        }
        if(!MyKFPawn.IsDoingMeleeAttack())
        {
            return true;
        }
    }
    AILog_Internal(string(GetFuncName()) $ "() returning FALSE", 'GrabAttack');
    return false;
}

function bool CanTargetBeGrabbed(KFPawn TargetKFP)
{
    local KFAIController OtherKFAIC;

    if((((TargetKFP == none) || TargetKFP.Health <= 0) || TargetKFP.IsDoingSpecialMove(19)) || TargetKFP.Physics == 2)
    {
        return false;
    }
    foreach WorldInfo.AllControllers(Class'KFAIController', OtherKFAIC)
    {
        if(OtherKFAIC == self)
        {
            continue;            
        }
        if(((OtherKFAIC.MyKFPawn != none) && OtherKFAIC.Enemy == TargetKFP) && OtherKFAIC.IsDoingGrabSpecialMove())
        {
            if(VSizeSq(MyHansPawn.Location - TargetKFP.Location) < float(250000))
            {
                OtherKFAIC.MyKFPawn.EndSpecialMove();
            }
        }        
    }    
    return true;
}

event DoGrabAttack(optional Pawn NewEnemy, optional Actor InTarget, optional float InPostSpecialMoveSleepTime)
{
    InPostSpecialMoveSleepTime = 0;
    if((CommandList == none) || AICommand(CommandList).bAllowedToAttack)
    {
        if(NewEnemy != none)
        {
            SetEnemy(NewEnemy);
        }
        ClearMovementInfo();
        AILog_Internal(string(GetFuncName()) $ "() Init AICommand_Attack_Grab", 'InitAICommand');
        Class'AICommand_Attack_Grab'.static.Grab(self, KFPawn(InTarget), InPostSpecialMoveSleepTime);        
    }
    else
    {
        if((CommandList != none) && !AICommand(CommandList).bAllowedToAttack)
        {
            AILog_Internal(((string(GetFuncName()) $ "() not doing grab attack because current command (") $ string(CommandList)) $ ") will not allow it", 'GrabAttack');
        }
    }
}

function bool DoHeavyZedBump(Actor Other, Vector HitNormal)
{
    local int BumpEffectDamage;
    local KFPawn_Monster BumpedMonster;

    if(Other.bCanBeDamaged && KFFracturedMeshGlass(Other) != none)
    {
        KFFracturedMeshGlass(Other).BreakOffAllFragments();
        return true;
    }
    if(((Other.IsA('KFDestructibleActor') && !GetActiveCommand().IsA('AICommand_Melee')) && Other.bCollideActors) && !MyKFPawn.IsDoingSpecialMove())
    {
        AIZeroMovementVariables();
        DisableBump(2);
        NotifyAttackActor(Other);
        return true;
    }
    BumpedMonster = KFPawn_Monster(Other);
    if(((BumpedMonster == none) || !BumpedMonster.IsAliveAndWell()) || BumpedMonster.ZedBumpDamageScale <= float(0))
    {
        return false;
    }
    if((MyKFPawn == none) || !MyKFPawn.IsAliveAndWell())
    {
        return false;
    }
    if((MyHansPawn.bInHuntAndHealMode && !IsZero(MyKFPawn.Velocity)) || MyKFPawn.bIsSprinting && !MyKFPawn.IsDoingSpecialMove())
    {
        BumpEffectDamage = int(float(ZedBumpEffectThreshold) * BumpedMonster.ZedBumpDamageScale);
        if((BumpedMonster.Health - BumpEffectDamage) <= 0)
        {
            if(FRand() < ZedBumpObliterationEffectChance)
            {
                BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());                
            }
            else
            {
                BumpedMonster.Knockdown(,, vect(1, 1, 1), Pawn.Location, 1000, 100);
            }
            return true;            
        }
        else
        {
            BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());
            BumpedMonster.DoSpecialMove(5,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(BumpedMonster, HitNormal));
            return true;
        }
    }
    return false;
}

function bool CanDoStrike()
{
    local bool bInGrabRange;
    local float DistSq;

    if(((((Enemy != none) && MyHansPawn != none) && MyHansPawn.bInHuntAndHealMode) && MyKFPawn != none) && MyKFPawn.Health > 0)
    {
        DistSq = VSizeSq(Enemy.Location - Pawn.Location);
        if(DistSq < (MinDistanceToPerformGrabAttack * MinDistanceToPerformGrabAttack))
        {
            bInGrabRange = true;
        }
    }
    if((MyHansPawn == none) || MyHansPawn.bInHuntAndHealMode && !bInGrabRange || CanGrabAttack())
    {
        return false;
    }
    return super(KFAIController_Monster).CanDoStrike();
}

event EdgeAndPolySubRegionRejectedDueToDist(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector SubRegionLocation, Vector PolyCenterRejected, float Dist)
{
    local KFDebugLines KFDL;

    if(Class'KFGameEngine'.default.bEnableAdvDebugLines)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(SubRegionLocation, 32, 8, 255, 0, 0, true);
        KFDL.AddDebugText3D(SubRegionLocation + (vect(0, 0, 1) * 72), "FAILED DUE TO Dist:" $ string(Dist), true, 100, 100, 0, true);
    }
}

event EdgeAndPolySubRegionRejectedDueToRating(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector SubRegionLocation, Vector PolyCenterRejected, int Rating)
{
    local KFDebugLines KFDL;

    if(Class'KFGameEngine'.default.bEnableAdvDebugLines)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(SubRegionLocation, 32, 8, 255, 255, 0, true);
        KFDL.AddDebugText3D(SubRegionLocation + (vect(0, 0, 1) * 72), "FAILED DUE TO RATING:" $ string(Rating), true, 100, 200, 0, true);
    }
}

event EntireEdgeAndPolyRejectedDueToRating(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector PolyCenterRejected, int Rating)
{
    local KFDebugLines KFDL;
    local Vector centerOfLineFromEdgeToPolyCenter;

    if(Class'KFGameEngine'.default.bEnableAdvDebugLines)
    {
        centerOfLineFromEdgeToPolyCenter = 0.5 * (PolyCenterRejected - EdgeCenterRejected);
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugLine(EdgeCenterRejected, PolyCenterRejected, 255, 0, 0, true);
        KFDL.AddDebugText3D((EdgeCenterRejected + centerOfLineFromEdgeToPolyCenter) + (vect(0, 0, 1) * 72), "Entire Edge FAILED DUE TO RATING:" $ string(Rating), true, 100, 200, 0, true);
    }
}

event EdgeAndPolySubRegionRejectedDueToLOS(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector SubRegionLocation, Vector PolyCenterRejected, Vector HitLocation, Actor HitActor)
{
    local KFDebugLines KFDL;

    if(Class'KFGameEngine'.default.bEnableAdvDebugLines)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(SubRegionLocation, 32, 8, 255, 0, 0, true);
        KFDL.AddDebugText3D(SubRegionLocation + (vect(0, 0, 1) * 72), "FAILED DUE TO LOS", true, 100, 100, 0, true);
    }
}

event EdgeAndPolySubRegionRejectedDueToAdjustToss(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector SubRegionLocation, Vector PolyCenterRejected, Vector HitLocation)
{
    local KFDebugLines KFDL;

    if(Class'KFGameEngine'.default.bEnableAdvDebugLines)
    {
        KFDL = Class'KFDebugLines'.static.GetDebugLines();
        KFDL.AddDebugSphere(SubRegionLocation, 32, 8, 255, 0, 0, true);
        KFDL.AddDebugText3D(SubRegionLocation + (vect(0, 0, 1) * 72), "FAILED DUE TO AdjustToss", true, 100, 100, 0, true);
    }
}

event EdgeAndPolySubRegionRejectedDueToProximityToTarget(Vector EdgeCenterRejected, Engine.Pylon.ENavMeshEdgeType EdgeTypeRecjted, Color EdgeTypeColorRejected, Vector SubRegionLocation, Vector PolyCenterRejected, float Range, Actor Target);

function bool AmIAllowedToSuicideWhenStuck()
{
    return false;
}

function InitalizeBaseCommand(class<AICommand> CmdClass)
{
    CmdClass.static.InitCommand(self);
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    if(self == Killer)
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayHansKilledDialog(MyHansPawn, DamageType);
        }
    }
}

function PlayDamagePlayerDialog(class<DamageType> dmgType)
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayHansDamagePlayerDialog(MyHansPawn, dmgType);
    }
}

function EnterZedVictoryState()
{
    ClearMovementInfo();
    if(CommandList != none)
    {
        AbortCommand(CommandList);
    }
    DisableMeleeRangeEventProbing();
    ChangeEnemy(none);
    MyKFPawn.SetSprinting(false);
    LockPawnRotationTo(MyKFPawn.Rotation);
    MyKFPawn.SetRemoteViewPitch(0);
    GotoState('ZedVictory', 'Begin');
}

state ZedVictory
{Begin:

    Class'AICommand_BossTheatrics'.static.DoTheatrics(self, 1, -1);
    stop;                    
}

defaultproperties
{
    LostSightSprintDelay=0.5
    StanceChangeCooldown=0.3
    PostAttackMoveGunCooldown=0.3
    LastRecentSeenEnemyListUpdateTime=0.1
    MinBurstAmount=3
    MaxBurstAmount=8
    BurstWaitTime=0.5
    BarrageWaitTime=1.5
    BarrageWaitDistanceCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1.25,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    BurstWaitDistanceCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=4,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    BarrageLength=3
    LostSightStopFireDelay=1.25
    DrawGunFireDelay=1
    TargetAquisitionDelay=0.25
    GrenadeGunInterruptDelay=5
    StartShootingRange=500000
    MinShootingRange=300
    GrenadeAttackEvalInterval=0.1
    MinDistanceToPerformGrabAttack=200
    MinTimeBetweenGrabAttacks=2.5
    bCanDoHeavyBump=true
    DefaultCommandClass=Class'AICommand_Base_Hans'
    MeleeCommandClass=Class'AICommand_Base_Hans'
    TeleportCooldown=15
    HiddenRelocateTeleportThreshold=12
}