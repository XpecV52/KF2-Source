/*******************************************************************************
 * KFDestructibleActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFDestructibleActor extends Actor
    native
    placeable
    hidecategories(Physics,Debug,Object,Mobile);

enum EDestructibleRepType
{
    RT_ServerDefault,
    RT_ServerOptimized,
    RT_ClientSide,
    RT_MAX
};

struct native ReplicatedDamageModInfo
{
    var byte ObjIdx;
    var byte ModIdx;
    var bool bPartial;

    structdefaultproperties
    {
        ObjIdx=255
        ModIdx=255
        bPartial=false
    }
};

struct native MaterialReplaceMod
{
    /** Material Mods */
    var() MaterialInterface NewMaterial;
    /** Index in the Materials array to replace with NewMaterial when this action is activated. */
    var() int MaterialIndex;

    structdefaultproperties
    {
        NewMaterial=none
        MaterialIndex=0
    }
};

struct native MaterialScalarParamMod
{
    var() MaterialInstanceConstant MatInst;
    var() name ParamName;
    var() float ScalarVal;

    structdefaultproperties
    {
        MatInst=none
        ParamName=None
        ScalarVal=0
    }
};

struct native MaterialTexParamMod
{
    var() MaterialInstanceConstant MatInst;
    var() name ParamName;
    var() Texture NewTexture;

    structdefaultproperties
    {
        MatInst=none
        ParamName=None
        NewTexture=none
    }
};

struct native MaterialVectorParamMod
{
    var() MaterialInstanceConstant MatInst;
    var() name ParamName;
    var() LinearColor VectorVal;

    structdefaultproperties
    {
        MatInst=none
        ParamName=None
        VectorVal=(R=0,G=0,B=0,A=1)
    }
};

struct native MaterialLightParamMod
{
    var() int MatID;
    var() name ParamName;
    var() Light LightActor;

    structdefaultproperties
    {
        MatID=0
        ParamName=BrightnessMultiplier
        LightActor=none
    }
};

struct native ActorSpawnParams
{
    /** Static mesh to use for physics object */
    var() StaticMesh RigidBodyMesh;
    /** Lower bound of random initial linear vel */
    var() Vector MinLinearVel;
    /** Upper bound of random initial linear vel */
    var() Vector MaxLinearVel;
    /** Lower bound of random initial angular vel */
    var() Vector MinAngularVel;
    /** Upper bound of random initial angular vel */
    var() Vector MaxAngularVel;
    /** Collision type to use for spawned rigid body */
    var() Engine.Actor.ECollisionType CollisionType;
    /** RBChannel to use for collision */
    var() Engine.PrimitiveComponent.ERBCollisionChannel RBChannel;
    /** Positional offset for actor spawn loc.  Note this is relative to the subobject */
    var() Vector RelativeOffset;
    /** Rotational offset for actor spawn loc.  Note this is relative to the subobject */
    var() Rotator RelativeRotation;
    /** How long before we forcibly destroy the spawned actor, in seconds.  <= 0 means don't destroy. */
    var() float LifeTimeSeconds;
    /** Do not spawn if no local players are within this range */
    var() float MaxSpawnDist<EditCondition=!bReplicated>;
    /** (PERF WARNING) If set, the spawned KActor is network replicated */
    var() bool bReplicated;
    /** Material changes */
    var() const array<MaterialReplaceMod> MaterialReplacements;

    structdefaultproperties
    {
        RigidBodyMesh=none
        MinLinearVel=(X=0,Y=0,Z=0)
        MaxLinearVel=(X=0,Y=0,Z=0)
        MinAngularVel=(X=0,Y=0,Z=0)
        MaxAngularVel=(X=0,Y=0,Z=0)
        CollisionType=ECollisionType.COLLIDE_NoCollision
        RBChannel=ERBCollisionChannel.RBCC_EffectPhysics
        RelativeOffset=(X=0,Y=0,Z=0)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        LifeTimeSeconds=30
        MaxSpawnDist=1500
        bReplicated=false
        MaterialReplacements=none
    }
};

struct native DestroyedEffectParams
{
    /** Emitters to spawn */
    var() ParticleSystem ParticleEffect;
    /** Position offset for detroyed effect.  Note this is relative to the subobject */
    var() Vector RelativeOffset;
    /** Rotational offset for destroyed effect.  Note this is relative to the subobject */
    var() Rotator RelativeRotation;
    /** Do not spawn if no local players are within this range */
    var() float MaxSpawnDist;
    var export editinline transient ParticleSystemComponent PSC;

    structdefaultproperties
    {
        ParticleEffect=none
        RelativeOffset=(X=0,Y=0,Z=0)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        MaxSpawnDist=4000
        PSC=none
    }
};

struct native ExplosionMod
{
    /** Explosion archetype to spawn */
    var() KFGameExplosion ExplosionTemplate;
    var float Damage;
    var float DamageRadius;
    /** Translation offset */
    var() Vector RelativeLocation;
    /** Rotation offset */
    var() Rotator RelativeRotation;
    var class<Actor> ActorClassToIgnoreForDamage;

    structdefaultproperties
    {
        ExplosionTemplate=none
        Damage=0
        DamageRadius=0
        RelativeLocation=(X=0,Y=0,Z=10)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        ActorClassToIgnoreForDamage=none
    }
};

struct native SplashDamageParams
{
    var() float BaseDamage;
    var() float DamageRadius;
    var() class<DamageType> DamageType<AllowAbstract=>;
    /** Translation offset - useful when other sub objects are in the way */
    var() Vector RelativeLocation;

    structdefaultproperties
    {
        BaseDamage=0
        DamageRadius=0
        DamageType=Class'KFDT_Explosive'
        RelativeLocation=(X=0,Y=0,Z=10)
    }
};

struct native ObjDamageModifierDependency
{
    /** which subobject we're talking about */
    var() name DependentSubObjName;
    /** If dependent subobject is above this health, it will be damaged to this level */
    var() int MaxHealthToAllow;
    var transient int DependentSubObjIdx;

    structdefaultproperties
    {
        DependentSubObjName=None
        MaxHealthToAllow=0
        DependentSubObjIdx=-1
    }
};

struct native LightDamageParams
{
    /** Placed light actors to recieve this mod */
    var() Light Light<DisplayName=LightActor>;
    /** New light animation settings */
    var() const float MaxBrightness<UIMin=0.0|ClampMin=0.0>;
    /** New light animation settings */
    var() const float MinBrightness<UIMin=0.0|ClampMin=0.0>;
    /** New light animation settings */
    var() Engine.Light.ELightAnimationTechnique AnimationType;
    /** New light animation settings */
    var() float AnimationFrequency<UIMin=0.01|ClampMin=0.01|UIMax=20.0|ClampMax=20.0>;
    /** If set, this light should be disabled */
    var() bool bDisabled;

    structdefaultproperties
    {
        Light=none
        MaxBrightness=0
        MinBrightness=0
        AnimationType=ELightAnimationTechnique.LightAnim_None
        AnimationFrequency=0
        bDisabled=false
    }
};

struct native ObjectDamageModifier
{
    /** Name that can use used to descriptively identify this mod. */
    var() const name DamageModName;
    /** apply this Modifier at or below this health */
    var() const float HealthThreshold;
    /** New static mesh to swap to, or None */
    var() StaticMesh NewMesh;
    /** Material changes */
    var() const array<MaterialReplaceMod> MaterialReplacements;
    /** Material changes */
    var() const array<MaterialScalarParamMod> MaterialScalarParams;
    /** Material changes */
    var() const array<MaterialTexParamMod> MaterialTexParams;
    /** Material changes */
    var() const array<MaterialVectorParamMod> MaterialVectorParams;
    /** Sounds to play when applying this modifier */
    var() const array<AkBaseSoundObject> Sounds;
    /** TRUE to kill the subobject at this stage */
    var() const bool bSelfDestruct;
    /** TRUE to kill the object (all subobjects) at this stage */
    var() const bool bSelfDestructAll;
    /** TRUE to stop any attached ambient sound */
    var() const bool bStopAmbientSound;
    /** TRUE to stop any attached ambient sound// maybe use this?  ParticleSystem'Effects_Level_SP_5.SP_Hospital.Effects.P_Wooden_Barrier_Split'
 */
    var() array<DestroyedEffectParams> ParticleEffects;
    /** Potential splash damage (if the subj explodes or something) */
    var() const SplashDamageParams SplashDamage;
    /** actors that will be spawned */
    var() const array<ActorSpawnParams> ActorsToSpawn;
    /** list of subobjects that are also affected by this modifier */
    var() const array<ObjDamageModifierDependency> DependentSubObjs;
    var transient bool bApplied;
    var transient int NextSpawnActorIdx;
    /** Explosion archetype to spawn */
    var() ExplosionMod ExploMod<DisplayName=ExplosionMod>;
    var deprecated array<deprecated StaticMeshActor> BecomeDynamicActors;
    /** light actors that are effected by this damage mod */
    var() const array<LightDamageParams> LightParams;
    var transient bool bMeshBlockActors;

    structdefaultproperties
    {
        DamageModName=None
        HealthThreshold=0
        NewMesh=none
        MaterialReplacements=none
        MaterialScalarParams=none
        MaterialTexParams=none
        MaterialVectorParams=none
        Sounds=none
        bSelfDestruct=false
        bSelfDestructAll=false
        bStopAmbientSound=false
        ParticleEffects=none
        SplashDamage=(BaseDamage=0,DamageRadius=0,DamageType=Class'KFDT_Explosive',RelativeLocation=(X=0,Y=0,Z=10))
        ActorsToSpawn=none
        DependentSubObjs=none
        bApplied=false
        NextSpawnActorIdx=0
        ExploMod=(ExplosionTemplate=none,Damage=0,DamageRadius=0,RelativeLocation=(X=0,Y=0,Z=10),RelativeRotation=(Pitch=0,Yaw=0,Roll=0),ActorClassToIgnoreForDamage=none)
        LightParams=none
        bMeshBlockActors=false
    }
};

struct native DestructibleSubobject
{
    /** name of the subobject.  should be unique, but not currently enforced */
    var() name SubObjName;
    /** the mesh */
    var() export editinline StaticMeshComponent Mesh;
    /** mods that can be applied to this subobject */
    var() array<ObjectDamageModifier> DamageMods;
    /** hit points this subobject has by default */
    var() float DefaultHealth;
    /** Light brightness material parameter for this subobject */
    var() array<MaterialLightParamMod> MaterialLightParams;
    var transient ObjectDamageModifier UndoMod;
    var transient int ActiveDamageModIdx;
    var transient class<DamageType> LastHitDamageType;
    var transient array<MaterialInstanceConstant> MICs;
    var int Health;

    structdefaultproperties
    {
        SubObjName=None
        Mesh=none
        DamageMods=none
        DefaultHealth=50
        MaterialLightParams=none
        UndoMod=(DamageModName=None,HealthThreshold=0,NewMesh=none,MaterialReplacements=none,MaterialScalarParams=none,MaterialTexParams=none,MaterialVectorParams=none,Sounds=none,bSelfDestruct=false,bSelfDestructAll=false,bStopAmbientSound=false,ParticleEffects=none,SplashDamage=(BaseDamage=0,DamageRadius=0,DamageType=Class'KFDT_Explosive',RelativeLocation=(X=0,Y=0,Z=10)),ActorsToSpawn=none,DependentSubObjs=none,bApplied=false,NextSpawnActorIdx=0,ExploMod=(ExplosionTemplate=none,Damage=0,DamageRadius=0,RelativeLocation=(X=0,Y=0,Z=10),RelativeRotation=(Pitch=0,Yaw=0,Roll=0),ActorClassToIgnoreForDamage=none),LightParams=none,bMeshBlockActors=false)
        ActiveDamageModIdx=-1
        LastHitDamageType=none
        MICs=none
        Health=50
    }
};

var() KFDestructibleActor.EDestructibleRepType ReplicationMode;
var transient byte ReplicatedDamageFlags;
var const byte VulnerableMultiplier;
/** SubObject array size limit based on ReplicationMode */
var(SubObjects) const editconst byte SubObjectLimit;
/** SubObject array size limit based on ReplicationMode */
var(SubObjects) const editconst byte DamageModLimit;
var repnotify ReplicatedDamageModInfo ReplicatedDamageMods[16];
var repnotify bool bShutDown;
/** If true, ignores all damage */
var() protected bool bIgnoreAllDamage;
/** If true, will ignore all damage done by players */
var() protected bool bIgnorePlayerDamage;
/** If true, will take bump damage from AI, in addition to just players */
var() protected bool bAllowBumpDamageFromAI;
var transient bool bComponentsSetUp;
var transient bool bInitRBPhysCalled;
var transient bool bIsRadiusDamage;
var transient bool bAnyDamageModApplied;
var protected const int INSTAKILL_DAMAGE;
/** List of damage types that instantly destroy this object */
var() array< class<DamageType> > InstaKillDamageType<AllowAbstract=>;
/** List of damage types to always ignore */
var() array< class<DamageType> > IgnoreDamageType<AllowAbstract=>;
var const array< class<DamageType> > VulnerableDamageType;
var transient float LastBumpCheckTime;
/** If bSelfDestructAll == TRUE for a damage mod, the object will be killed after this delay */
var() const float SelfDestructAllDelay;
/** When destroyed, disable collision on this blocking volume (MUST have bSelfDestructAll=TRUE) */
var() const BlockingVolume BlockingVolumeToDisable;
/** Force destroy these actors on SelfDestructAll.  Useful if we have nearby destructibles and need more precision than ExplosionMod */
var() const array<Actor> DamageOtherActors<DisplayName=ActorsToDamageOnDestruct>;
/** This sound is played all of the time the object is in the world.  (good for radios and such) */
var() protected AkBaseSoundObject AmbientSoundCue;
var protected export editinline AkComponent AmbientSoundComponent;
var transient float ClosestLocalPlayerSqDist;
/** Array of objects that comprise this destructible object (MAX: 8) */
var(SubObjects) array<DestructibleSubobject> SubObjects;
var init private native const array<init Pointer> DamagedSubObjects;
/** Helper object to display RelativeLocation and RelativeRotation */
var(SubObjects) editoronly transient Actor PreviewOffsetActor;
/** Last value from PreviewOffsetActor */
var(SubObjects) editoronly transient Vector PreviewRelativeLocation;
var(SubObjects) editoronly transient Rotator PreviewRelativeRotation;
var delegate<OnDestroyed> __OnDestroyed__Delegate;

replication
{
     if(Role == ROLE_Authority)
        ReplicatedDamageMods, bShutDown;
}

simulated event ReplicatedEvent(name VarName)
{
    local int Idx, ObjIdx, ModIdx;

    if(VarName == 'ReplicatedDamageMods')
    {
        Idx = 0;
        J0x22:

        if(Idx < 16)
        {
            if(ReplicatedDamageMods[Idx].ObjIdx != 255)
            {
                ObjIdx = ReplicatedDamageMods[Idx].ObjIdx;
                ModIdx = ReplicatedDamageMods[Idx].ModIdx;
                if(!SubObjects[ObjIdx].DamageMods[ModIdx].bApplied)
                {
                    ApplyDamageMod(ObjIdx, ModIdx, ReplicatedDamageMods[Idx].bPartial);
                }
            }
            ++ Idx;
            goto J0x22;
        }        
    }
    else
    {
        if(VarName == 'bShutDown')
        {
            if(bShutDown)
            {
                ShutDownObject();                
            }
            else
            {
                UnShutDownObject();
            }
        }
    }
}

event ReplicateDamageMod(int ObjIdx, int ModIdx, bool bPartial)
{
    local int Idx;

    if((((ObjIdx < 0) || ObjIdx > 255) || ModIdx < 0) || ModIdx > 255)
    {
        WarnInternal(((string(self) $ " replicatedamagemod out of bounds ") $ string(ObjIdx)) @ string(ModIdx));
        return;
    }
    Idx = 0;
    J0x96:

    if(Idx < 16)
    {
        if(ReplicatedDamageMods[Idx].ObjIdx == 255)
        {
            ReplicatedDamageMods[Idx].ObjIdx = byte(ObjIdx);
            ReplicatedDamageMods[Idx].ModIdx = byte(ModIdx);
            ReplicatedDamageMods[Idx].bPartial = bPartial;
            goto J0x17E;
        }
        ++ Idx;
        goto J0x96;
    }
    J0x17E:

    bForceNetUpdate = true;
}

function byte PackDamageMod(int ObjIdx, int ModIdx, bool bPartial)
{
    local byte DmgModFlags;

    DmgModFlags = byte(ObjIdx + (ModIdx << 4));
    if(bPartial)
    {
        DmgModFlags = byte(DmgModFlags | 128);
    }
    return DmgModFlags;
}

simulated function UnPackDamageMod(byte DmgModFlags, out int ObjIdx, out int ModIdx, out byte bPartial)
{
    ObjIdx = DmgModFlags & 15;
    ModIdx = DmgModFlags & 48;
    bPartial = byte(DmgModFlags & 128);
}

// Export UKFDestructibleActor::execSetupComponents(FFrame&, void* const)
private native final simulated function SetupComponents();

// Export UKFDestructibleActor::execOneTimeInit(FFrame&, void* const)
protected native simulated function OneTimeInit();

simulated event PostBeginPlay()
{
    OneTimeInit();
    if((AmbientSoundCue != none) && AmbientSoundComponent != none)
    {
        AttachComponent(AmbientSoundComponent);
        AmbientSoundComponent.OcclusionUpdateInterval = 0.2;
        AmbientSoundComponent.PlayEvent(AkEvent(AmbientSoundCue));
    }
    switch(ReplicationMode)
    {
        case 2:
            SetCollision(,, false);
            if(BlockingVolumeToDisable != none)
            {
                BlockingVolumeToDisable.SetCollision(false, false);
            }
            break;
        default:
            break;
    }
    if(WorldInfo.NetMode == NM_Client)
    {
        Role = ((ReplicationMode == 2) ? 3 : 1);        
    }
    else
    {
        RemoteRole = ((ReplicationMode == 2) ? 0 : 1);
    }
}

// Export UKFDestructibleActor::execDamageSubObject(FFrame&, void* const)
protected native function DamageSubObject(int ObjIdx, int Damage, Controller EventInstigator, class<DamageType> DamType);

// Export UKFDestructibleActor::execHasAnyHealth(FFrame&, void* const)
native function bool HasAnyHealth();

// Export UKFDestructibleActor::execGetCurrentHealth(FFrame&, void* const)
native function float GetCurrentHealth();

// Export UKFDestructibleActor::execGetMaxHealth(FFrame&, void* const)
native function float GetMaxHealth();

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    DamageFalloffExponent = 1;
    bIsRadiusDamage = true;
    super.TakeRadiusDamage(InstigatedBy, BaseDamage, DamageRadius, DamageType, Momentum, HurtOrigin, bFullDamage, DamageCauser, DamageFalloffExponent);
    bIsRadiusDamage = false;
}

event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int Idx;

    AdjustDamage(Damage, EventInstigator, DamageType);
    if(Damage <= 0)
    {
        return;
    }
    if((Damage >= INSTAKILL_DAMAGE) || bIsRadiusDamage)
    {
        Idx = 0;
        J0x69:

        if(Idx < SubObjects.Length)
        {
            if(float(Damage) > 0)
            {
                DamageSubObject(Idx, Damage, EventInstigator, DamageType);
            }
            ++ Idx;
            goto J0x69;
        }        
    }
    else
    {
        if(ValidateHitComponent(EventInstigator, HitInfo, HitLocation, Momentum))
        {
            Idx = 0;
            J0x111:

            if(Idx < SubObjects.Length)
            {
                if(SubObjects[Idx].Mesh != HitInfo.HitComponent)
                {                    
                }
                else
                {
                    if(float(SubObjects[Idx].Health) > 0)
                    {
                        DamageSubObject(Idx, Damage, EventInstigator, DamageType);
                    }
                    goto J0x1E4;
                }
                ++ Idx;
                goto J0x111;
            }
        }
    }
    J0x1E4:

    if((Role == ROLE_Authority) && !HasAnyHealth())
    {
    }
    super.TakeDamage(Damage, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
}

function AdjustDamage(out int InDamage, Controller EventInstigator, class<DamageType> DamageType)
{
    local int Idx;
    local KFAIController KFAIInstigator;

    if(bIgnoreAllDamage)
    {
        InDamage = 0;
        return;
    }
    Idx = 0;
    J0x25:

    if(Idx < InstaKillDamageType.Length)
    {
        if((DamageType == InstaKillDamageType[Idx]) || ClassIsChildOf(DamageType, InstaKillDamageType[Idx]))
        {
            InDamage = INSTAKILL_DAMAGE;
            return;
        }
        ++ Idx;
        goto J0x25;
    }
    Idx = 0;
    J0xB0:

    if(Idx < IgnoreDamageType.Length)
    {
        if((DamageType == IgnoreDamageType[Idx]) || ClassIsChildOf(DamageType, IgnoreDamageType[Idx]))
        {
            InDamage = 0;
            return;
        }
        ++ Idx;
        goto J0xB0;
    }
    if(EventInstigator != none)
    {
        if(bAllowBumpDamageFromAI && !EventInstigator.bIsPlayer)
        {
            KFAIInstigator = KFAIController(EventInstigator);
            if((KFAIInstigator != none) && KFAIInstigator.ActorEnemy == self)
            {
                InDamage = INSTAKILL_DAMAGE;
                return;
            }
        }
        if((bIgnorePlayerDamage && EventInstigator.bIsPlayer) && EventInstigator.GetTeamNum() == 0)
        {
            InDamage = 0;
            return;
        }
    }
    if(bIsRadiusDamage && IsVulnerableTo(DamageType))
    {
        InDamage *= float(VulnerableMultiplier);
    }
}

function bool IsVulnerableTo(class<DamageType> DT)
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < VulnerableDamageType.Length)
    {
        if(ClassIsChildOf(DT, VulnerableDamageType[Idx]))
        {
            return true;
        }
        ++ Idx;
        goto J0x0B;
    }
    return false;
}

event bool InstaKillFromLargeNPCBumpDamage()
{
    return InstaKillDamageType.Find(Class'KFDT_NPCBump_Large' != -1;
}

event bool InstaKillFromStandardNPCBumpDamage()
{
    return InstaKillDamageType.Find(Class'KFDT_NPCBump' != -1;
}

function bool ValidateHitComponent(Controller EventInstigator, out TraceHitInfo HitInfo, Vector HitLocation, Vector Momentum)
{
    local Actor TraceInstigator;
    local Vector NewHitLocation, HitNormal, Offset;

    if(HitInfo.HitComponent == none)
    {
        if(Momentum == vect(0, 0, 0))
        {
            Momentum = Location - HitLocation;
        }
        Offset = 8 * Normal(Momentum);
        if(EventInstigator != none)
        {
            TraceInstigator = (((EventInstigator.Pawn != none) && EventInstigator.Pawn.Weapon != none) ? EventInstigator.Pawn.Weapon : EventInstigator.Pawn);
        }
        if(TraceInstigator == none)
        {
            TraceInstigator = WorldInfo;
        }
        TraceInstigator.Trace(NewHitLocation, HitNormal, HitLocation + Offset, HitLocation - Offset, true,, HitInfo, 1);
    }
    return HitInfo.HitComponent != none;
}

event ApplySplashDamage(const out Vector Origin, const out SplashDamageParams DamageParams);

delegate OnDestroyed(KFDestructibleActor DActor);

protected event TriggerDestroyedEvent(Controller EventInstigator)
{
    OnDestroyed(self);
    TriggerEventClass(Class'SeqEvent_Destroyed', EventInstigator);
}

function BumpedByMonster(KFPawn_Monster P, Vector HitNormal)
{
    if(bAllowBumpDamageFromAI)
    {
        if((WorldInfo.TimeSeconds - LastBumpCheckTime) < 0.5)
        {
            return;
        }
        LastBumpCheckTime = WorldInfo.TimeSeconds;
        if(P.Controller != none)
        {
            TakeDamage(0, P.Controller, P.Location, vect(0, 0, 0), P.BumpDamageType,, P);
        }
    }
}

function int GetInstaKillDamage()
{
    return INSTAKILL_DAMAGE;
}

// Export UKFDestructibleActor::execSetSubObjectStaticMesh(FFrame&, void* const)
protected native simulated function SetSubObjectStaticMesh(int ObjIdx, int ModIdx);

// Export UKFDestructibleActor::execApplyDamageMod(FFrame&, void* const)
protected native simulated function ApplyDamageMod(int ObjIdx, int ModIdx, bool bPartial, optional Controller DamageInstigator);

// Export UKFDestructibleActor::execRemoveDecals(FFrame&, void* const)
protected native simulated function RemoveDecals();

simulated event Explosion(const out DestructibleSubobject SubObj, const out ObjectDamageModifier Mod)
{
    local Vector EffectLoc;
    local Rotator EffectRot;
    local GameExplosionActor ExplosionActor;
    local GameExplosion ExplosionTemplate;

    if(Mod.ExploMod.ExplosionTemplate != none)
    {
        EffectLoc = Location + (Mod.ExploMod.RelativeLocation >> Rotation);
        EffectRot = Rotation + RelativeRotation;
        ExplosionActor = Spawn(Class'KFExplosionActor', self,, EffectLoc, EffectRot);
        ExplosionTemplate = Mod.ExploMod.ExplosionTemplate;
        if(ExplosionActor != none)
        {
            ExplosionActor.Explode(ExplosionTemplate);
        }
    }
}

// Export UKFDestructibleActor::execUnDestroy(FFrame&, void* const)
native simulated function UnDestroy();

protected simulated event DelayedShutDownObject()
{
    local Actor Other;
    local StaticMeshActor OtherSM;

    SetCollision(false, false, bIgnoreEncroachers);
    if((ReplicationMode != 2) && BlockingVolumeToDisable != none)
    {
        BlockingVolumeToDisable.SetCollision(false, false);
    }
    foreach DamageOtherActors(Other,)
    {
        if(Other.bStatic && Other.bWorldGeometry)
        {
            OtherSM = StaticMeshActor(Other);
            if(OtherSM != none)
            {
                OtherSM.StaticMeshComponent.bNeverBecomeDynamic = false;
                if(OtherSM.StaticMeshComponent.CanBecomeDynamic())
                {
                    Other = Class'KActorFromStatic'.static.MakeDynamic(OtherSM.StaticMeshComponent);
                    if(Other == none)
                    {
                        continue;
                        goto J0x1E3;
                    }
                }
            }
        }
        Other.TakeRadiusDamage(none, 1000, 1000, Class'KFDT_Environment_KActorImpulse', 1, Location, true, self);        
    }
    J0x1E3:
    
    SetTimer(0.2, false, 'ShutDownObject');
}

simulated function ShutDownObject()
{
    local int Idx;

    bShutDown = true;
    Idx = 0;
    J0x17:

    if(Idx < SubObjects.Length)
    {
        SubObjects[Idx].Mesh.SetHidden(true);
        SubObjects[Idx].Mesh.SetTraceBlocking(false, false);
        SubObjects[Idx].Mesh.SetActorCollision(false, false);
        SubObjects[Idx].Mesh.SetBlockRigidBody(false);
        ++ Idx;
        goto J0x17;
    }
}

protected simulated event ShutDownSubObject(const out DestructibleSubobject SubObj)
{
    SubObj.Mesh.SetHidden(true);
    SubObj.Mesh.SetTraceBlocking(false, false);
    SubObj.Mesh.SetActorCollision(false, false);
    SubObj.Mesh.SetBlockRigidBody(false);
}

protected simulated event UnShutDownObject()
{
    local int SubObjIdx, DamageModIdx;

    bShutDown = false;
    SetCollision(default.bCollideActors, default.bBlockActors, bIgnoreEncroachers);
    SubObjIdx = 0;
    J0x38:

    if(SubObjIdx < SubObjects.Length)
    {
        SubObjects[SubObjIdx].Mesh.SetHidden(false);
        SubObjects[SubObjIdx].Mesh.SetTraceBlocking(true, true);
        SubObjects[SubObjIdx].Mesh.SetActorCollision(true, SubObjects[SubObjIdx].Mesh.BlockActors);
        SubObjects[SubObjIdx].Mesh.SetBlockRigidBody(true);
        SubObjects[SubObjIdx].ActiveDamageModIdx = -1;
        DamageModIdx = 0;
        J0x1B9:

        if(DamageModIdx < SubObjects[SubObjIdx].DamageMods.Length)
        {
            SubObjects[SubObjIdx].DamageMods[DamageModIdx].NextSpawnActorIdx = 0;
            ++ DamageModIdx;
            goto J0x1B9;
        }
        ++ SubObjIdx;
        goto J0x38;
    }
    if(Role == ROLE_Authority)
    {
        SetTimer(0.01, false, 'MoveCollidingPawns');
    }
}

function MoveCollidingPawns();

simulated function Reset()
{
    local int SubObjIdx;

    if(bShutDown)
    {
        UnShutDownObject();
    }
    SubObjIdx = 0;
    J0x22:

    if(SubObjIdx < SubObjects.Length)
    {
        SubObjects[SubObjIdx].Health = int(SubObjects[SubObjIdx].DefaultHealth);
        ++ SubObjIdx;
        goto J0x22;
    }
    if(!bAnyDamageModApplied)
    {
        return;
    }
    RemoveDecals();
    UnDestroy();
    bForceNetUpdate = true;
}

function ToggleAllDamage(bool bDamageOn)
{
    bIgnoreAllDamage = !bDamageOn;
}

defaultproperties
{
    VulnerableMultiplier=6
    ReplicatedDamageMods[0]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[1]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[2]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[3]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[4]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[5]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[6]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[7]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[8]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[9]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[10]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[11]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[12]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[13]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[14]=(ObjIdx=255,ModIdx=255,bPartial=false)
    ReplicatedDamageMods[15]=(ObjIdx=255,ModIdx=255,bPartial=false)
    bAllowBumpDamageFromAI=true
    INSTAKILL_DAMAGE=100000
    VulnerableDamageType(0)=class'KFDT_Sonic'
    SelfDestructAllDelay=0.2
    begin object name=AmbientSoundComponent0 class=AkComponent
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFDestructibleActor.AmbientSoundComponent0'
    AmbientSoundComponent=AmbientSoundComponent0
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__KFDestructibleActor.Sprite'
    Components(0)=Sprite
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bNoDelete=true
    bWorldGeometry=true
    bAlwaysRelevant=true
    bSkipActorPropertyReplication=true
    bOnlyDirtyReplication=true
    bGameRelevant=true
    bMovable=false
    bCanBeDamaged=true
    bBlocksNavigation=true
    bCollideActors=true
    bBlockActors=true
    bProjTarget=true
    bBlocksTeleport=true
    bNoEncroachCheck=true
    bEdShouldSnap=true
    bIgnoreNetRelevancyCollision=true
    NetUpdateFrequency=0.1
}