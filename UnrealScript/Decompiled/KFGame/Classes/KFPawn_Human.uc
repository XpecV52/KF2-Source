/*******************************************************************************
 * KFPawn_Human generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_Human extends KFPawn
    native(Pawn)
    nativereplication
    config(Game)
    hidecategories(Navigation);

struct native KFPowerUpFxInfo
{
    var class<KFPowerUp> PowerUpType;
    var byte Count;

    structdefaultproperties
    {
        PowerUpType=none
        Count=0
    }
};

struct native KFPowerUpCurrentFxInfo
{
    var class<KFPowerUp> PowerUpType;
    var export editinline ParticleSystemComponent ParticleEffect;

    structdefaultproperties
    {
        PowerUpType=none
        ParticleEffect=none
    }
};

struct native DialogResponseInfo
{
    var KFPawn Speaker;
    var KFPawn RespondingToPawn;
    var int EventID;
    var int RespondingToID;

    structdefaultproperties
    {
        Speaker=none
        RespondingToPawn=none
        EventID=0
        RespondingToID=0
    }
};

var float LowHealthSpeedPenalty;
var repnotify byte CurrentWeaponState;
var protected byte WeaponAttachmentAnimRateByte;
var byte ActivePerkMessageIdx;
var byte HealthToRegen;
var byte MaxArmor;
var byte Armor;
var byte IntegrityLevel_High;
var byte IntegrityLevel_Medium;
var byte IntegrityLevel_Low;
var byte MinEnemiesToTriggerSurrounded;
var private repnotify byte HealingSpeedBoost;
var private repnotify byte HealingDamageBoost;
var private repnotify byte HealingShield;
var repnotify const int WeaponSkinItemId;
var array<name> DeathFaceAnims;
var globalconfig float BloodPoolDelay;
var float PainSoundChanceOnHit;
var float PainSoundCoolDown;
var float PainSoundLastPlayedTime;
var string PerkFXEmitterPoolClassPath;
var transient EmitterPool PerkFXEmitterPool;
var const name DefaultDeathMaterialEffectParamName;
var const float DefaultDeathMaterialEffectDuration;
var transient float DeathMaterialEffectDuration;
var transient float DeathMaterialEffectTimeRemaining;
var transient name DeathMaterialEffectParamName;
var repnotify KFPowerUpFxInfo PowerUpFxInfo;
var repnotify KFPowerUpFxInfo PowerUpFxStopInfo;
var KFPowerUpCurrentFxInfo CurrentPowerUpEffect;
var transient KFFlashlightAttachment FlashLight;
var const KFFlashlightAttachment FlashLightTemplate;
var repnotify bool bFlashlightOn;
var repnotify bool bUsingIronSights;
var repnotify bool bUsingAltFireMode;
var bool bObjectivePlayer;
var bool bDisableTraderDialog;
var() float BatteryDrainRate;
var() float BatteryRechargeRate;
var float BatteryCharge;
var float NVGBatteryDrainRate;
/** @name Night Vision */
var() export editinline PointLightComponent NightVisionLightTemplate;
var export editinline transient PointLightComponent NightVisionLight;
var KFGFxMoviePlayer_PlayerInfo PlayerPartyInfo;
var float HealthRegenRate;
var float HealerRewardScaler;
var float ArmorAbsorbModifier_High;
var float ArmorAbsorbModifier_Medium;
var float ArmorAbsorbModifier_Low;
var float MinHealthPctToTriggerSurrounded;
var array<string> ActiveSkillIconPaths;
var transient KFExplosion_AirborneAgent AAExplosionActor;
var transient int DoshCaughtStreakAmt;
var transient float LastDoshCaughtTime;
var transient PlayerReplicationInfo LastDoshCaughtGiver;
var transient int ZedsKilledStreakAmt;
var transient float LastZedKilledTime;
var transient int DamageTakenStreakAmt;
var transient float LastDamageTakenStreakStartTime;
var transient float InitialContinousDamageTime;
var transient float IdleStartTime;
var transient int EnvironmentDialogEventID;
var transient float SprintTowardZedStartTime;
var transient float SprintStartTime;
var protected export editinline AkComponent TraderDialogAkComponent;
var DialogResponseInfo DlgRespInfo;
var delegate<OnFinishedDialog> __OnFinishedDialog__Delegate;

replication
{
     if(bNetDirty)
        Armor, HealingDamageBoost, 
        HealingShield, HealingSpeedBoost, 
        HealthToRegen, MaxArmor, 
        PowerUpFxInfo, PowerUpFxStopInfo, 
        WeaponSkinItemId, bObjectivePlayer;

     if(bNetDirty && bNetOwner)
        bDisableTraderDialog;

     if(bNetDirty && !bNetOwner || bDemoRecording)
        CurrentWeaponState, WeaponAttachmentAnimRateByte, 
        bFlashlightOn, bUsingAltFireMode, 
        bUsingIronSights;
}

// Export UKFPawn_Human::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

simulated event Tick(float DeltaTime)
{
    local float NewSpeedPenalty;

    super.Tick(DeltaTime);
    if(Role == ROLE_Authority)
    {
        if(Health < HealthMax)
        {
            NewSpeedPenalty = Lerp(0.15, 0, FMin(float(Health) / float(100), 1));            
        }
        else
        {
            NewSpeedPenalty = 0;
        }
        if(NewSpeedPenalty != LowHealthSpeedPenalty)
        {
            LowHealthSpeedPenalty = NewSpeedPenalty;
            UpdateGroundSpeed();
        }
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(DeathMaterialEffectTimeRemaining > float(0))
        {
            UpdateDeathMaterialEffect(DeltaTime);
        }
    }
}

simulated event PreBeginPlay()
{
    local class<EmitterPool> PoolClass;

    super.PreBeginPlay();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(PerkFXEmitterPoolClassPath != "")
        {
            PoolClass = class<EmitterPool>(DynamicLoadObject(PerkFXEmitterPoolClassPath, Class'Class'));
            if(PoolClass != none)
            {
                PerkFXEmitterPool = Spawn(PoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
    }
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super.PossessedBy(C, bVehicleTransition);
    ResetHealingSpeedBoost();
    ResetHealingDamageBoost();
    ResetHealingShield();
    ResetIdleStartTime();
    if(((IsAliveAndWell() && WorldInfo.Game != none) && WorldInfo.Game.NumPlayers == 1) && KFGameInfo(WorldInfo.Game).bOnePlayerAtStart)
    {
        SetTimer(1, true, 'Timer_CheckSurrounded');
    }
    KFGameInfo(WorldInfo.Game).OverrideHumanDefaults(self);
    SetTimer(0.5, false, 'ClientOverrideHumanDefaults', self);
}

simulated function NotifyTeamChanged()
{
    local KFPerk InstigatorPerk;

    if(PlayerReplicationInfo != none)
    {
        SetCharacterArch(GetCharacterInfo());
    }
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.NotifyPawnTeamChanged();
    }
}

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'CurrentWeaponState':
            WeaponStateChanged(CurrentWeaponState, true);
            break;
        case 'WeaponSkinItemId':
            if((WeaponAttachment != none) && WeaponSkinItemId > 0)
            {
                WeaponAttachment.SetWeaponSkin(WeaponSkinItemId);
            }
            break;
        case 'bFlashlightOn':
            SetFlashlight(bFlashlightOn, false);
            break;
        case 'bUsingIronSights':
            SetIronSights(bUsingIronSights, false);
            break;
        case 'bUsingAltFireMode':
            SetUsingAltFireMode(bUsingAltFireMode, false);
            break;
        case 'PowerUpFxInfo':
            PlayPowerUpEffect(PowerUpFxInfo);
            break;
        case 'PowerUpFxStopInfo':
            StopPowerUpEffect(PowerUpFxStopInfo);
            break;
        case 'HealingSpeedBoost':
            NotifyHealingSpeedBoostBuff(HealingSpeedBoost);
            break;
        case 'HealingDamageBoost':
            NotifyHealingDamageBoostBuff(HealingDamageBoost);
            break;
        case 'HealingShield':
            NotifyHealingShieldBoostBuff(HealingShield);
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

simulated event Destroyed()
{
    if(PlayerPartyInfo != none)
    {
        PlayerPartyInfo.SetVisible(false);
        PlayerPartyInfo.Close();
    }
    if(FlashLight != none)
    {
        FlashLight.DetachFlashlight();
    }
    if(AAExplosionActor != none)
    {
        AAExplosionActor.Destroy();
    }
    super.Destroyed();
}

simulated function SetCharacterArchAnimationInfo();

simulated function SetCharacterArch(KFCharacterInfoBase Info, optional bool bForce)
{
    super.SetCharacterArch(Info);
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if((FlashLight == none) && FlashLightTemplate != none)
        {
            FlashLight = new (self) Class'KFFlashlightAttachment' (FlashLightTemplate);
            FlashLight.AttachFlashlight(Mesh);            
        }
        else
        {
            if(FlashLight != none)
            {
                FlashLight.Reattach();
            }
        }
    }
}

simulated function OnCharacterMeshChanged()
{
    if(FlashLight != none)
    {
        FlashLight.Reattach();
    }
    SetCharacterAnimationInfo();
}

function AddDefaultInventory()
{
    local KFPerk MyPerk;
    local KFGameInfo GameInfo;

    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.AddDefaultInventory(self);
    }
    GameInfo = KFGameInfo(WorldInfo.Game);
    if((GameInfo.OutbreakEvent == none) || !GameInfo.OutbreakEvent.ActiveEvent.bCannotBeHealed)
    {
        DefaultInventory.AddItem(class<Weapon>(DynamicLoadObject("KFGameContent.KFWeap_Healer_Syringe", Class'Class'));
    }
    DefaultInventory.AddItem(class<Weapon>(DynamicLoadObject("KFGameContent.KFWeap_Welder", Class'Class'));
    DefaultInventory.AddItem(class<Inventory>(DynamicLoadObject("KFGameContent.KFInventory_Money", Class'Class'));
    super.AddDefaultInventory();
    if((GameInfo.OutbreakEvent != none) && GameInfo.OutbreakEvent.ActiveEvent.bGunGameMode)
    {
        if(KFPlayerController_WeeklySurvival(Controller) != none)
        {
            KFPlayerController_WeeklySurvival(Controller).UpdateInitialHeldWeapon();
        }
    }
}

simulated function PlayWeaponSwitch(Weapon OldWeapon, Weapon NewWeapon)
{
    super.PlayWeaponSwitch(OldWeapon, NewWeapon);
    if(Role == ROLE_Authority)
    {
        UpdateGroundSpeed();
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlaySwitchToFavoriteWeaponDialog(self);
        }
    }
}

simulated function bool CanThrowWeapon()
{
    local KFPlayerController KFPC;

    if((KFGameInfo(WorldInfo.Game).OutbreakEvent != none) && KFGameInfo(WorldInfo.Game).OutbreakEvent.ActiveEvent.bDisableThrowWeapon)
    {
        return false;
    }
    KFPC = KFPlayerController(Controller);
    if((((KFPC != none) && KFPC.MyGFxManager != none) && KFPC.MyGFxManager.TraderMenu != none) && KFPC.MyGFxManager.CurrentMenu == KFPC.MyGFxManager.TraderMenu)
    {
        return false;
    }
    return super(Pawn).CanThrowWeapon();
}

simulated event StartCrouch(float HeightAdjust)
{
    super.StartCrouch(HeightAdjust);
    UpdateGroundSpeed();
    if(WeaponAttachment != none)
    {
        WeaponAttachment.StartPawnCrouch();
    }
}

simulated event EndCrouch(float HeightAdjust)
{
    super.EndCrouch(HeightAdjust);
    UpdateGroundSpeed();
    if(WeaponAttachment != none)
    {
        WeaponAttachment.EndPawnCrouch();
    }
}

function UpdateGroundSpeed()
{
    local KFInventoryManager InvM;
    local float WeightMod, HealthMod, WeaponMod;
    local KFGameInfo KFGI;
    local KFWeapon CurrentWeapon;
    local KFPlayerController KFPC;

    if(Role < ROLE_Authority)
    {
        return;
    }
    CurrentWeapon = KFWeapon(Weapon);
    InvM = KFInventoryManager(InvManager);
    WeightMod = ((InvM != none) ? InvM.GetEncumbranceSpeedMod() : 1);
    HealthMod = GetHealthMod();
    WeaponMod = ((CurrentWeapon != none) ? CurrentWeapon.MovementSpeedMod : 1);
    GroundSpeed = default.GroundSpeed;
    SprintSpeed = default.SprintSpeed;
    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        KFGI.ModifyGroundSpeed(self, GroundSpeed);
        KFGI.ModifySprintSpeed(self, SprintSpeed);
    }
    GroundSpeed = ((GroundSpeed * WeightMod) * HealthMod) * WeaponMod;
    SprintSpeed = ((SprintSpeed * WeightMod) * HealthMod) * WeaponMod;
    if((GetPerk()) != none)
    {
        GetPerk().ModifySpeed(GroundSpeed);
        GetPerk().ModifySprintSpeed(SprintSpeed);
        GetPerk().FinalizeSpeedVariables();
    }
    KFPC = KFPlayerController(Controller);
    if((KFPC != none) && KFPC.GetPowerUp() != none)
    {
        KFPC.GetPowerUp().ModifySpeed(GroundSpeed);
        KFPC.GetPowerUp().ModifySprintSpeed(SprintSpeed);
        KFPC.GetPowerUp().FinalizeSpeedVariables();
    }
    if(CurrentWeapon != none)
    {
        if(CurrentWeapon.OverrideGroundSpeed >= 0)
        {
            GroundSpeed = CurrentWeapon.OverrideGroundSpeed;
        }
        if(CurrentWeapon.OverrideSprintSpeed >= 0)
        {
            SprintSpeed = CurrentWeapon.OverrideSprintSpeed;
        }
    }
}

function float GetHealthMod()
{
    return 1 - LowHealthSpeedPenalty;
}

simulated function WeaponStateChanged(byte NewState, optional bool bViaReplication)
{
    CurrentWeaponState = NewState;
    if((WorldInfo.TimeSeconds - CreationTime) < 1)
    {
        return;
    }
    if(IsDoingSpecialMove() && !SpecialMoves[SpecialMove].bAllowThirdPersonWeaponAnims)
    {
        return;
    }
    if(WeaponAttachment != none)
    {
        WeaponAttachment.UpdateThirdPersonWeaponAction(CurrentWeaponState, self, GetWeaponAttachmentAnimRateByte());
    }
}

function SetWeaponAttachmentAnimRateByte(float NewAnimRate)
{
    WeaponAttachmentAnimRateByte = FloatToByte(FClamp(NewAnimRate - 1, 0, 1));
}

simulated function byte GetWeaponAttachmentAnimRateByte()
{
    return WeaponAttachmentAnimRateByte;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    BodyStanceNodes[4] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_CH_Upper'));
    BodyStanceNodes[5] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_CH_Lower'));
    RecoilNodes[0] = GameSkelCtrl_Recoil(SkelComp.FindSkelControl('SpineRecoil'));
}

simulated function StopAllAnimations()
{
    local name FacePose;

    FacePose = DeathFaceAnims[Rand(DeathFaceAnims.Length)];
    PlayBodyAnim(FacePose, 6,,,, true);
    super.StopAllAnimations();
}

simulated function CheckAndEndActiveEMoteSpecialMove()
{
    if(IsDoingSpecialMove() && SpecialMove == 35)
    {
        SpecialMoveHandler.EndSpecialMove(35);
    }
}

simulated function bool CanBeHealed()
{
    return true;
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    local KFPlayerController KFPC;
    local KFPowerUp KFPowerUp;
    local KFGameInfo GameInfo;

    bCanRepairArmor = true;
    bMessageHealer = true;
    KFPC = KFPlayerController(Controller);
    if(KFPC != none)
    {
        KFPowerUp = KFPC.GetPowerUp();
        if((KFPowerUp != none) && !KFPowerUp.CanBeHealed())
        {
            return false;
        }
    }
    GameInfo = KFGameInfo(WorldInfo.Game);
    if((GameInfo.OutbreakEvent != none) && GameInfo.OutbreakEvent.ActiveEvent.bCannotBeHealed)
    {
        return false;
    }
    return HealDamageForce(Amount, Healer, DamageType, bCanRepairArmor, bMessageHealer);
}

event bool HealDamageForce(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    local int DoshEarned;
    local float UsedHealAmount;
    local KFPlayerReplicationInfo InstigatorPRI;
    local KFPlayerController InstigatorPC, KFPC;
    local KFPerk InstigatorPerk;
    local class<KFDamageType> KFDT;
    local int I;
    local bool bRepairedArmor;
    local int OldHealth;

    bCanRepairArmor = true;
    bMessageHealer = true;
    OldHealth = Health;
    InstigatorPC = KFPlayerController(Healer);
    InstigatorPerk = ((InstigatorPC != none) ? InstigatorPC.GetPerk() : none);
    if(InstigatorPerk != none)
    {
        if(bCanRepairArmor)
        {
            bRepairedArmor = InstigatorPerk.RepairArmor(self);
        }
        if(InstigatorPerk.GetHealingSpeedBoostActive())
        {
            UpdateHealingSpeedBoost();
        }
        if(InstigatorPerk.GetHealingDamageBoostActive())
        {
            UpdateHealingDamageBoost();
        }
        if(InstigatorPerk.GetHealingShieldActive())
        {
            UpdateHealingShield();
        }
    }
    if(((Amount > 0) && IsAliveAndWell()) && Health < HealthMax)
    {
        KFDT = class<KFDamageType>(DamageType);
        if((KFDT != none) && KFDT.default.bNoPain)
        {
            PlayHeal(KFDT);            
        }
        else
        {
            WarnInternal("No hit effects et for damagetype:" @ string(DamageType));
        }
        if(Role == ROLE_Authority)
        {
            if((InstigatorPC == none) || InstigatorPC.PlayerReplicationInfo == none)
            {
                return false;
            }
            InstigatorPRI = KFPlayerReplicationInfo(InstigatorPC.PlayerReplicationInfo);
            UsedHealAmount = float(Amount);
            if(InstigatorPerk != none)
            {
                if(InstigatorPerk.ModifyHealAmount(UsedHealAmount))
                {
                    if((Controller != Healer) && InstigatorPerk.IsHealingSurgeActive())
                    {
                        if(InstigatorPC.Pawn != none)
                        {
                            InstigatorPC.Pawn.HealDamage(int(float(InstigatorPC.Pawn.HealthMax) * InstigatorPerk.GetSelfHealingSurgePct()), InstigatorPC, Class'KFDT_Healing');
                        }
                    }
                }
            }
            if((float(Health + HealthToRegen) + UsedHealAmount) > float(HealthMax))
            {
                UsedHealAmount = float(HealthMax - (Health + HealthToRegen));
            }
            HealthToRegen += byte(UsedHealAmount);
            SetTimer(HealthRegenRate, true, 'GiveHealthOverTime');
            if((InstigatorPC.Pawn != none) && InstigatorPC.Pawn != self)
            {
                DoshEarned = int((UsedHealAmount / float(HealthMax)) * HealerRewardScaler);
                InstigatorPRI.AddDosh(Max(DoshEarned, 0), true);
                InstigatorPC.AddHealPoints(int(UsedHealAmount));
            }
            if(Healer.bIsPlayer)
            {
                if(Healer != Controller)
                {
                    InstigatorPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 7, PlayerReplicationInfo);
                    KFPC = KFPlayerController(Controller);
                    KFPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 6, Healer.PlayerReplicationInfo);
                    if((KFPC != none) && KFPC.MatchStats != none)
                    {
                        KFPC.MatchStats.RecordIntStat(5, int(UsedHealAmount));
                    }
                    if((InstigatorPC != none) && InstigatorPC.MatchStats != none)
                    {
                        InstigatorPC.MatchStats.RecordIntStat(4, int(UsedHealAmount));
                    }                    
                }
                else
                {
                    if(bMessageHealer)
                    {
                        InstigatorPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 8, PlayerReplicationInfo);
                    }
                }
            }
            if(bMessageHealer)
            {
                if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
                {
                    KFGameInfo(WorldInfo.Game).DialogManager.PlayHealingDialog(KFPawn(Healer.Pawn), self, float(Health + HealthToRegen) / float(HealthMax));
                }
            }
            I = 0;
            J0x875:

            if(I < DamageOverTimeArray.Length)
            {
                if(DamageOverTimeArray[I].DoT_Type == 1)
                {
                    DamageOverTimeArray[I].Duration *= 0.5;
                    DamageOverTimeArray[I].Damage *= 0.5;
                    goto J0x926;
                }
                ++ I;
                goto J0x875;
            }
            J0x926:

            if((Health - OldHealth) > 0)
            {
                WorldInfo.Game.ScoreHeal(Health - OldHealth, OldHealth, Healer, self, DamageType);
            }
            return true;
        }
    }
    if((Health - OldHealth) > 0)
    {
        WorldInfo.Game.ScoreHeal(Health - OldHealth, OldHealth, Healer, self, DamageType);
    }
    return bRepairedArmor;
}

function GiveHealthOverTime()
{
    local KFPlayerReplicationInfo KFPRI;

    if((HealthToRegen > 0) && Health < HealthMax)
    {
        ++ Health;
        -- HealthToRegen;
        WorldInfo.Game.ScoreHeal(1, Health - 1, Controller, self, none);
        KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
        if(KFPRI != none)
        {
            KFPRI.PlayerHealth = byte(Health);
            KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
        }        
    }
    else
    {
        HealthToRegen = 0;
        ClearTimer('GiveHealthOverTime');
    }
}

function AddArmor(int Amount)
{
    Armor = byte(Min(Armor + Amount, GetMaxArmor()));
}

function GiveMaxArmor()
{
    Armor = byte(GetMaxArmor());
}

function int GetMaxArmor()
{
    return MaxArmor;
}

function ShieldAbsorb(out int InDamage)
{
    local float AbsorbedPct;
    local int AbsorbedDmg;
    local KFPerk MyPerk;

    MyPerk = GetPerk();
    if((MyPerk != none) && MyPerk.HasHeavyArmor())
    {
        AbsorbedDmg = Min(InDamage, Armor);
        Armor -= byte(MyPerk.GetArmorDamageAmount(AbsorbedDmg));
        InDamage -= AbsorbedDmg;
        return;
    }
    if(Armor >= IntegrityLevel_High)
    {
        AbsorbedPct = ArmorAbsorbModifier_High;        
    }
    else
    {
        if(Armor >= IntegrityLevel_Medium)
        {
            AbsorbedPct = ArmorAbsorbModifier_Medium;            
        }
        else
        {
            AbsorbedPct = ArmorAbsorbModifier_Low;
        }
    }
    AbsorbedDmg = Min(Round(AbsorbedPct * float(InDamage)), Armor);
    Armor -= byte(AbsorbedDmg);
    InDamage -= AbsorbedDmg;
}

simulated function LeaveBloodPool()
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if(GoreManager != none)
    {
        GoreManager.LeaveABloodPoolDecal(self);
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation, optional bool bUseHitImpulse)
{
    local class<KFDamageType> dmgType;
    local name HitBoneName, RBBoneName;
    local int HitZoneIndex;

    bUseHitImpulse = true;
    dmgType = HitFxInfo.DamageType;
    if(WorldInfo.TimeSeconds > (PainSoundLastPlayedTime + PainSoundCoolDown))
    {
        if(PainSoundChanceOnHit >= (1 - FRand()))
        {
            SoundGroupArch.PlayPainSound(self);
            PainSoundLastPlayedTime = WorldInfo.TimeSeconds;
        }
    }
    super.PlayTakeHitEffects(HitDirection, HitLocation, bUseHitImpulse);
    if(dmgType != none)
    {
        if(bTearOff && !bPlayedDeath)
        {
            PlayDying(HitDamageType, TakeHitLocation);
        }
        if(bPlayedDeath)
        {
            HitZoneIndex = HitFxInfo.HitBoneIndex;
            if(HitZoneIndex != 255)
            {
                HitBoneName = HitZones[HitZoneIndex].BoneName;
            }
            if(HitBoneName != 'None')
            {
                RBBoneName = GetRBBoneFromBoneName(HitBoneName);
            }
            if(bUseHitImpulse)
            {
                ApplyRagdollImpulse(dmgType, HitLocation, HitDirection, RBBoneName, 1);
            }
        }
    }
}

simulated event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex)
{
    local int I;
    local KFGoreManager GoreManager;
    local RigidBodyContactInfo ContactInfo;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager != none) && (WorldInfo.TimeSeconds - LastGibCollisionTime) > GoreManager.GetTimeBetweenGibBloodSplats())
    {
        LastGibCollisionTime = WorldInfo.TimeSeconds;
        if(((OtherComponent != none) && OtherComponent.Owner != none) && !OtherComponent.Owner.IsA('KFPawn'))
        {
            SoundGroupArch.PlayRigidBodyCollisionSound(self, RigidCollisionData.ContactInfos[ContactIndex].ContactPosition);
            I = 0;
            J0x18C:

            if(I < RigidCollisionData.ContactInfos.Length)
            {
                ContactInfo = RigidCollisionData.ContactInfos[I];
                GoreManager.LeaveAPersistentBloodSplat(ContactInfo.ContactPosition, -ContactInfo.ContactNormal);
                ++ I;
                goto J0x18C;
            }
        }
    }
}

simulated function PlayDamageInstigatorHitEffects(KFPawn Victim)
{
    local float BloodParamIncrementValue;

    super.PlayDamageInstigatorHitEffects(Victim);
    if(WeaponAttachment != none)
    {
        if((WorldInfo.NetMode != NM_DedicatedServer) && VSizeSq(Victim.Location - Location) < BattleBloodRangeSq)
        {
            BloodParamIncrementValue = RandRange(0.01, 0.05);
            if(WorldInfo.TimeSeconds == Victim.TimeOfDeath)
            {
                BloodParamIncrementValue *= 2;
            }
            AddBattleBlood(BloodParamIncrementValue);
            WeaponAttachment.AddBattleBlood(BloodParamIncrementValue);
        }
    }
}

simulated function AddBattleBlood(float InBattleBloodIncrementvalue)
{
    local MaterialInstanceConstant MIC;

    BattleBloodParamValue = FMax(BattleBloodParamValue + InBattleBloodIncrementvalue, MinBattleBloodValue);
    foreach CharacterMICs(MIC,)
    {
        MIC.SetScalarParameterValue(BattleBloodParamName, BattleBloodParamValue);        
    }    
}

simulated function SetNightVisionLight(bool bEnabled);

simulated function TerminateEffectsOnDeath()
{
    super.TerminateEffectsOnDeath();
    if(FlashLight != none)
    {
        FlashLight.OwnerDied();
    }
}

function PlayPowerUp(class<KFPowerUp> PowerUpType)
{
    PowerUpFxInfo.PowerUpType = PowerUpType;
    ++ PowerUpFxInfo.Count;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        PlayPowerUpEffect(PowerUpFxInfo);
    }
}

simulated function PlayPowerUpEffect(KFPowerUpFxInfo PUpFxInfo)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Controller);
    if((KFPC != none) && PUpFxInfo.PowerUpType != none)
    {
        KFPC.PlayPowerUpEffect(PUpFxInfo.PowerUpType);
    }
    if(PUpFxInfo.PowerUpType != none)
    {
        PUpFxInfo.PowerUpType.static.PlayEffects(self);
    }
}

function StopPowerUp(class<KFPowerUp> PowerUpType)
{
    PowerUpFxStopInfo.PowerUpType = PowerUpType;
    ++ PowerUpFxStopInfo.Count;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        StopPowerUpEffect(PowerUpFxStopInfo);
    }
}

simulated function StopPowerUpEffect(KFPowerUpFxInfo PUpFxInfo)
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(Controller);
    if(KFPC != none)
    {
        KFPC.StopPowerUpEffect(PUpFxInfo.PowerUpType);
    }
    if(((PUpFxInfo.PowerUpType != none) && PUpFxInfo.PowerUpType == CurrentPowerUpEffect.PowerUpType) && CurrentPowerUpEffect.ParticleEffect != none)
    {
        CurrentPowerUpEffect.ParticleEffect.DeactivateSystem();
        CurrentPowerUpEffect.ParticleEffect = none;
    }
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    local class<KFDamageType> KFDT;

    super.PlayDying(DamageType, HitLoc);
    if(AAExplosionActor != none)
    {
        AAExplosionActor.Destroy();
    }
    if((Physics == 10) && !Mesh.HiddenGame)
    {
        KFDT = class<KFDamageType>(DamageType);
        SetTimer(BloodPoolDelay, false, 'LeaveBloodPool');
        PlayDeathMaterialEffects((((KFDT != none) && KFDT.default.DeathMaterialEffectParamName != 'None') ? KFDT.default.DeathMaterialEffectParamName : DefaultDeathMaterialEffectParamName), (((KFDT != none) && KFDT.default.DeathMaterialEffectDuration != 0) ? KFDT.default.DeathMaterialEffectDuration : DefaultDeathMaterialEffectDuration));
    }
    if(PlayerPartyInfo != none)
    {
        PlayerPartyInfo.Close(true);
        PlayerPartyInfo = none;
    }
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    ClearTimer('Timer_CheckSurrounded');
    if(super.Died(Killer, DamageType, HitLocation))
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPlayerDeathDialog(self);
        }
        return true;
    }
    return false;
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    local KFPerk MyKFPerk;
    local float TempDamage;
    local bool bHasSacrificeSkill;

    if(bLogTakeDamage)
    {
        LogInternal(((string(self) @ string(GetFuncName())) @ "Adjusted Damage BEFORE =") @ string(InDamage));
    }
    super.AdjustDamage(InDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
    if(KFGameReplicationInfo(KFGameInfo(WorldInfo.Game).GameReplicationInfo).bTraderIsOpen)
    {
        InDamage = 0;
        return;
    }
    MyKFPerk = GetPerk();
    if(MyKFPerk != none)
    {
        MyKFPerk.ModifyDamageTaken(InDamage, DamageType, InstigatedBy);
        bHasSacrificeSkill = MyKFPerk.ShouldSacrifice();
    }
    TempDamage = float(InDamage);
    if(((TempDamage > float(0)) && Class'KFPerk_Demolitionist'.static.IsDmgTypeExplosiveResistable(DamageType)) && HasExplosiveResistance())
    {
        Class'KFPerk_Demolitionist'.static.ModifyExplosiveDamage(TempDamage);
        TempDamage = ((TempDamage < 1) ? 1 : TempDamage);
    }
    TempDamage *= (GetHealingShieldModifier());
    InDamage = Round(TempDamage);
    if(((InDamage > 0) && Armor > 0) && DamageType.default.bArmorStops)
    {
        ShieldAbsorb(InDamage);
        if(InDamage <= 0)
        {
            AddHitFX(InDamage, InstigatedBy, GetHitZoneIndex(HitInfo.BoneName), HitLocation, Momentum, class<KFDamageType>(DamageType));
        }
    }
    if((bHasSacrificeSkill && Health >= 5) && (Health - InDamage) < 5)
    {
        Health = InDamage + 5;
        SacrificeExplode();
    }
    if(InstigatedBy != none)
    {
        AddTakenDamage(InstigatedBy, int(FMin(float(Health), float(InDamage))), DamageCauser, class<KFDamageType>(DamageType));
    }
    if(bLogTakeDamage)
    {
        LogInternal(((string(self) @ string(GetFuncName())) @ "Adjusted Damage AFTER =") @ string(InDamage));
    }
    if(((Controller != none) && Controller.bDemiGodMode) && InDamage >= Health)
    {
        if(Health == 1)
        {
            Health = int(float(HealthMax) * 0.25);
        }
        if(InDamage >= Health)
        {
            InDamage = Health - 1;
        }
    }
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int ActualDamageTaken, OldHealth, OldArmor;
    local KFGameReplicationInfo KFGRI;
    local KFPlayerReplicationInfo KFPRI;
    local KFAIController_ZedBoss InstigatedByBoss;

    OldHealth = Health;
    OldArmor = Armor;
    if(bLogTakeDamage)
    {
        LogInternal((((((string(GetFuncName()) @ "Damage BEFORE =") $ string(Damage)) $ " DamageType: ") $ string(DamageType)) $ " DamageCauser: ") $ string(DamageCauser));
    }
    super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    ActualDamageTaken = OldHealth - Health;
    if(bLogTakeDamage)
    {
        LogInternal((((((string(GetFuncName()) @ "Damage AFTER =") $ string(ActualDamageTaken)) $ " DamageType: ") $ string(DamageType)) $ " DamageCauser: ") $ string(DamageCauser));
    }
    KFGRI = KFGameReplicationInfo(KFGameInfo(WorldInfo.Game).GameReplicationInfo);
    if((((ActualDamageTaken > 0) || (OldArmor - Armor) > 0) && IsAliveAndWell()) && !KFGRI.bTraderIsOpen)
    {
        KFPlayerController(Controller).NotifyHitTaken();
    }
    if((ActualDamageTaken > 0) && IsAliveAndWell())
    {
        CheckAndEndActiveEMoteSpecialMove();
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPlayerDamageDialog(self, DamageType, ActualDamageTaken);
        }
        InstigatedByBoss = KFAIController_ZedBoss(InstigatedBy);
        if(InstigatedByBoss != none)
        {
            InstigatedByBoss.PlayDamagePlayerDialog(DamageType);
        }
        if((KFPlayerController(Controller) != none) && KFPlayerController(Controller).MatchStats != none)
        {
            KFPlayerController(Controller).MatchStats.RecordIntStat(3, ActualDamageTaken);
        }
    }
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.PlayerHealth = byte(Health);
        KFPRI.PlayerHealthPercent = FloatToByte(float(Health) / float(HealthMax));
    }
    ResetIdleStartTime();
}

simulated function PlayDeathMaterialEffects(name DamageMICParamName, float Duration)
{
    DeathMaterialEffectTimeRemaining = Duration;
    DeathMaterialEffectDuration = Duration;
    DeathMaterialEffectParamName = DamageMICParamName;
}

function UpdateDeathMaterialEffect(float DeltaTime)
{
    local float Intensity;
    local MaterialInstanceConstant MIC;

    if(DeathMaterialEffectTimeRemaining > 0)
    {
        if(DeathMaterialEffectTimeRemaining > DeltaTime)
        {
            DeathMaterialEffectTimeRemaining -= DeltaTime;
            Intensity = 1 - FClamp(DeathMaterialEffectTimeRemaining / DeathMaterialEffectDuration, 0, 1);            
        }
        else
        {
            DeathMaterialEffectTimeRemaining = 0;
            Intensity = 1;
        }
        foreach CharacterMICs(MIC,)
        {
            MIC.SetScalarParameterValue(DeathMaterialEffectParamName, Intensity);            
        }        
    }
}

function SacrificeExplode()
{
    local KFExplosionActorReplicated ExploActor;
    local GameExplosion ExplosionTemplate;
    local KFPerk_Demolitionist DemoPerk;

    if(Role < ROLE_Authority)
    {
        return;
    }
    DemoPerk = KFPerk_Demolitionist(GetPerk());
    ExploActor = Spawn(Class'KFExplosionActorReplicated', self,, Location,,, true);
    if(ExploActor != none)
    {
        ExploActor.InstigatorController = Controller;
        ExploActor.Instigator = self;
        ExplosionTemplate = Class'KFPerk_Demolitionist'.static.GetSacrificeExplosionTemplate();
        ExplosionTemplate.bIgnoreInstigator = true;
        ExploActor.Explode(ExplosionTemplate);
        if(DemoPerk != none)
        {
            DemoPerk.NotifyPerkSacrificeExploded();
        }
    }
}

function StartAirBorneAgentEvent()
{
    local KFGameExplosion AAExplosionTemplate;
    local class<KFExplosion_AirborneAgent> AAExplosionActorClass;

    if(AAExplosionActor != none)
    {
        AAExplosionActor.Destroy();
    }
    AAExplosionTemplate = Class'KFPerk_FieldMedic'.static.GetAAExplosionTemplate();
    AAExplosionTemplate.MyDamageType = Class'KFPerk_FieldMedic'.static.GetAADamageTypeClass();
    AAExplosionActorClass = Class'KFPerk_FieldMedic'.static.GetAAExplosionActorClass();
    AAExplosionActor = Spawn(AAExplosionActorClass, self,, Location);
    if(AAExplosionActor != none)
    {
        AAExplosionActor.Instigator = self;
        AAExplosionActor.InstigatorController = Controller;
        AAExplosionActor.MyPawn = self;
        AAExplosionActor.SetPhysics(0);
        AAExplosionActor.SetBase(self,, Mesh);
        AAExplosionActor.Explode(AAExplosionTemplate);
    }
}

simulated function UpdateHealingSpeedBoost()
{
    HealingSpeedBoost = byte(Min(HealingSpeedBoost + Class'KFPerk_FieldMedic'.static.GetHealingSpeedBoost(), Class'KFPerk_FieldMedic'.static.GetMaxHealingSpeedBoost()));
    SetTimer(Class'KFPerk_FieldMedic'.static.GetHealingSpeedBoostDuration(),, 'ResetHealingSpeedBoost');
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingSpeedBoostBuff(HealingSpeedBoost);
    }
}

simulated function ResetHealingSpeedBoost()
{
    HealingSpeedBoost = 0;
    if(IsTimerActive('ResetHealingSpeedBoost'))
    {
        ClearTimer('ResetHealingSpeedBoost');
    }
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingSpeedBoostBuff(HealingSpeedBoost);
    }
}

simulated function float GetHealingDamageBoostModifier()
{
    return 1 + (float(HealingDamageBoost) / float(100));
}

simulated function UpdateHealingDamageBoost()
{
    HealingDamageBoost = byte(Min(HealingDamageBoost + Class'KFPerk_FieldMedic'.static.GetHealingDamageBoost(), Class'KFPerk_FieldMedic'.static.GetMaxHealingDamageBoost()));
    SetTimer(Class'KFPerk_FieldMedic'.static.GetHealingDamageBoostDuration(),, 'ResetHealingDamageBoost');
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingDamageBoostBuff(HealingDamageBoost);
    }
}

simulated function ResetHealingDamageBoost()
{
    HealingDamageBoost = 0;
    if(IsTimerActive('ResetHealingDamageBoost'))
    {
        ClearTimer('ResetHealingDamageBoost');
    }
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingDamageBoostBuff(HealingDamageBoost);
    }
}

simulated function float GetHealingShieldModifier()
{
    return 1 - (float(HealingShield) / float(100));
}

simulated function UpdateHealingShield()
{
    HealingShield = byte(Min(HealingShield + Class'KFPerk_FieldMedic'.static.GetHealingShield(), Class'KFPerk_FieldMedic'.static.GetMaxHealingShield()));
    SetTimer(Class'KFPerk_FieldMedic'.static.GetHealingShieldDuration(),, 'ResetHealingShield');
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingShieldBoostBuff(HealingShield);
    }
}

simulated function ResetHealingShield()
{
    HealingShield = 0;
    if(IsTimerActive('ResetHealingShield'))
    {
        ClearTimer('ResetHealingShield');
    }
    if(WorldInfo.NetMode == NM_Standalone)
    {
        NotifyHealingShieldBoostBuff(HealingShield);
    }
}

protected function bool HasExplosiveResistance()
{
    local KFPawn_Human TestPawn;
    local KFPerk TestPawnPerk;

    foreach WorldInfo.AllPawns(Class'KFPawn_Human', TestPawn, Location, Class'KFPerk_Demolitionist'.static.GetExplosiveResistanceRadius())
    {
        TestPawnPerk = TestPawn.GetPerk();
        if((TestPawnPerk != none) && TestPawnPerk.IsSharedExplosiveResistaneActive())
        {            
            return true;
        }        
    }    
    return false;
}

function float GetPerkDoTScaler(optional Controller InstigatedBy, optional class<KFDamageType> KFDT)
{
    local KFPerk MyPerk;
    local float DoTScaler;

    DoTScaler = 1;
    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.ModifyBloatBileDoT(DoTScaler);
    }
    return DoTScaler;
}

function array<string> GetUpdatedSkillIndicators()
{
    return ActiveSkillIconPaths;
}

delegate OnFinishedDialog(const out DialogResponseInfo ResponseInfo);

function HandleDialogResponse()
{
    if(Role == ROLE_Authority)
    {
        if(__OnFinishedDialog__Delegate != none)
        {
            if((DlgRespInfo.RespondingToID < 0) || DlgRespInfo.RespondingToID == CurrDialogEventID)
            {
                OnFinishedDialog(DlgRespInfo);
            }
            __OnFinishedDialog__Delegate = None;
        }
    }
}

function SetDialogResponseDelegate(KFPawn Responder, delegate<OnFinishedDialog> ResponseDelegate, optional int ResponseID, optional int RespondingToID)
{
    ResponseID = -1;
    RespondingToID = -1;
    DlgRespInfo.Speaker = Responder;
    DlgRespInfo.RespondingToPawn = self;
    DlgRespInfo.EventID = ResponseID;
    DlgRespInfo.RespondingToID = RespondingToID;
    __OnFinishedDialog__Delegate = ResponseDelegate;
}

function UpdateDoshCaught(int Amount, PlayerReplicationInfo Tosser)
{
    if(((WorldInfo.TimeSeconds - LastDoshCaughtTime) < 0.75) && LastDoshCaughtGiver == Tosser)
    {
        DoshCaughtStreakAmt += Amount;        
    }
    else
    {
        DoshCaughtStreakAmt = Amount;
        LastDoshCaughtGiver = Tosser;
    }
    LastDoshCaughtTime = WorldInfo.TimeSeconds;
    SetTimer(0.75, false, 'CaughtDoshDialogTimer');
}

function CaughtDoshDialogTimer()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayDoshCaughtDialog(self);
    }
    ClearTimer('CaughtDoshDialogTimer');
}

function UpdateKillStreak()
{
    if(LastPainTime < LastZedKilledTime)
    {
        ++ ZedsKilledStreakAmt;        
    }
    else
    {
        ZedsKilledStreakAmt = 1;
    }
    LastZedKilledTime = WorldInfo.TimeSeconds;
}

function UpdateDamageTakenStreak(int Amount, float interval)
{
    if((WorldInfo.TimeSeconds - LastDamageTakenStreakStartTime) < interval)
    {
        DamageTakenStreakAmt += Amount;        
    }
    else
    {
        DamageTakenStreakAmt = Amount;
        LastDamageTakenStreakStartTime = WorldInfo.TimeSeconds;
    }
}

function UpdateContinuousDamage(KFPawn_Monster DamagedZed, float MaxHitInterval)
{
    if((DamagedZed.LastHitBy != Controller) || (WorldInfo.TimeSeconds - DamagedZed.LastPainTime) > MaxHitInterval)
    {
        InitialContinousDamageTime = WorldInfo.TimeSeconds;
    }
}

function ResetIdleStartTime()
{
    local PlayerController PC;
    local KFPawn_Human KFPH;
    local float DistanceToTeammateSq, MaxResetDistanceSq;

    IdleStartTime = WorldInfo.TimeSeconds;
    MaxResetDistanceSq = 3000 * float(3000);
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC == Controller)
        {
            continue;            
        }
        KFPH = KFPawn_Human(PC.Pawn);
        if((KFPH == none) || !KFPH.IsAliveAndWell())
        {
            continue;            
        }
        DistanceToTeammateSq = VSizeSq(KFPH.Location - Location);
        if(DistanceToTeammateSq <= MaxResetDistanceSq)
        {
            KFPH.IdleStartTime = WorldInfo.TimeSeconds;
        }        
    }    
}

function float TimeSpentIdling()
{
    return WorldInfo.TimeSeconds - IdleStartTime;
}

function PlayTraderDialog(AkEvent DialogEvent)
{
    if(bDisableTraderDialog)
    {
        return;
    }
    TraderDialogAkComponent.PlayEvent(DialogEvent);
}

function StopTraderDialog()
{
    if(TraderDialogAkComponent == none)
    {
        return;
    }
    TraderDialogAkComponent.StopEvents();
}

function SetSprinting(bool bNewSprintStatus)
{
    if(bIsSprinting || bNewSprintStatus)
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlaySprintPantingDialog(self, bNewSprintStatus);
        }
    }
    super.SetSprinting(bNewSprintStatus);
}

function bool DoJump(bool bUpdating)
{
    if(super.DoJump(bUpdating))
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayJumpDialog(self);
        }
        return true;
    }
    return false;
}

simulated event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local KFPerk MyPerk;

    if(((WorldInfo.TimeDilation < 1) && !IsZero(Velocity)) && Other.GetTeamNum() != GetTeamNum())
    {
        MyPerk = GetPerk();
        if(MyPerk != none)
        {
            MyPerk.OnBump(Other, self, Velocity, Rotation);
        }
    }
}

function Timer_CheckSurrounded()
{
    local KFGameInfo KFGI;

    if(((WorldInfo.Game.NumPlayers == 1) && GetHealthPercentage() < MinHealthPctToTriggerSurrounded) && IsSurrounded(true, MinEnemiesToTriggerSurrounded, 250))
    {
        KFGI = KFGameInfo(WorldInfo.Game);
        if((KFGI != none) && KFGI.GameConductor != none)
        {
            KFGI.GameConductor.NotifySoloPlayerSurrounded();
        }
    }
}

simulated function ToggleEquipment()
{
    if(IsLocallyControlled() && !bPlayedDeath)
    {
        SetFlashlight(!bFlashlightOn, true);
    }
}

simulated function SetFlashlight(bool bEnabled, optional bool bReplicate)
{
    bFlashlightOn = bEnabled;
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(!bPlayedDeath)
    {
        FlashLight.UpdateFlashlightFor(self);
    }
    if(bReplicate && Role == ROLE_AutonomousProxy)
    {
        ServerSetFlashlight(bFlashlightOn);
    }
}

private reliable server final function ServerSetFlashlight(bool bEnabled)
{
    bFlashlightOn = bEnabled;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetFlashlight(bEnabled, false);
    }
}

simulated function SetIronSights(bool bEnabled, optional bool bReplicate)
{
    bUsingIronSights = bEnabled;
    if(WeaponAttachment != none)
    {
        WeaponAttachment.SetWeaponUsingIronSights(bEnabled);
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(bReplicate && Role == ROLE_AutonomousProxy)
    {
        ServerSetIronSights(bUsingIronSights);
    }
}

private reliable server final function ServerSetIronSights(bool bEnabled)
{
    bUsingIronSights = bEnabled;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetIronSights(bEnabled, false);
    }
}

simulated function SetUsingAltFireMode(bool bEnabled, optional bool bReplicate)
{
    bUsingAltFireMode = bEnabled;
    if(WeaponAttachment != none)
    {
        WeaponAttachment.SetWeaponAltFireMode(bEnabled);
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(bReplicate && Role == ROLE_AutonomousProxy)
    {
        ServerSetUsingAltFireMode(bUsingAltFireMode);
    }
}

private reliable server final function ServerSetUsingAltFireMode(bool bEnabled)
{
    bUsingAltFireMode = bEnabled;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetUsingAltFireMode(bEnabled, false);
    }
}

simulated event NotifyOutOfBattery()
{
    local KFPlayerController KFPC;

    if(IsLocallyControlled())
    {
        KFPC = KFPlayerController(Controller);
        if(KFPC.bNightVisionActive)
        {
            KFPC.SetNightVision(false);
        }
        if(bFlashlightOn)
        {
            SetFlashlight(false, true);
        }
    }
}

simulated function SetFirstPersonVisibility(bool bWeaponVisible)
{
    super.SetFirstPersonVisibility(bWeaponVisible);
    if(FlashLight != none)
    {
        FlashLight.SetFirstPersonVisibility(bWeaponVisible);
    }
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    super.SetMeshLightingChannels(NewLightingChannels);
    if(FlashLight != none)
    {
        FlashLight.SetLightingChannels(NewLightingChannels);
    }
}

// Export UKFPawn_Human::execDrawDoors(FFrame&, void* const)
native simulated function DrawDoors(Canvas Canvas);

simulated function DrawHUD(HUD H)
{
    local Canvas Canvas;
    local KFPlayerController KFPC;

    super(Pawn).DrawHUD(H);
    KFPC = KFPlayerController(Controller);
    if(!H.bShowHUD)
    {
        return;
    }
    if((KFPC != none) && KFPC.IsBossCameraMode())
    {
        return;
    }
    Canvas = H.Canvas;
    if(Canvas != none)
    {
        DrawDoors(Canvas);
        Canvas.EnableStencilTest(true);
        DrawPerkHUD(Canvas);
        Canvas.EnableStencilTest(false);
    }
}

function DrawPerkHUD(Canvas C)
{
    local KFPerk Perk;

    Perk = GetPerk();
    if(Perk != none)
    {
        Perk.DrawSpecialPerkHUD(C);
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Canvas Canvas;

    super.DisplayDebug(HUD, out_YL, out_YPos);
    Canvas = HUD.Canvas;
    if(HUD.ShouldDisplayDebug('Movement'))
    {
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.DrawText("EncumbranceMod:" @ string(KFInventoryManager(InvManager).GetEncumbranceSpeedMod()));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("HealthSpeedMod:" @ string(1 - LowHealthSpeedPenalty), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
}

simulated function NotifyHealingSpeedBoostBuff(byte Speed)
{
    if(Role == ROLE_Authority)
    {
        HealingSpeedBoost = Speed;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        UpdateActiveSkillsPath(Class'KFPerk_FieldMedic'.default.PerkSkills[2].IconPath, float(Speed) > 0);
    }
}

simulated function NotifyHealingDamageBoostBuff(byte Damage)
{
    if(Role == ROLE_Authority)
    {
        HealingSpeedBoost = Damage;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        UpdateActiveSkillsPath(Class'KFPerk_FieldMedic'.default.PerkSkills[4].IconPath, float(Damage) > 0);
    }
}

simulated function NotifyHealingShieldBoostBuff(byte Shield)
{
    if(Role == ROLE_Authority)
    {
        HealingSpeedBoost = Shield;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        UpdateActiveSkillsPath(Class'KFPerk_FieldMedic'.default.PerkSkills[6].IconPath, float(Shield) > 0);
    }
}

function UpdateActiveSkillsPath(string IconPath, bool Active)
{
    local KFPlayerController KFPC;

    if(Active)
    {
        if(ActiveSkillIconPaths.Find(IconPath == -1)
        {
            ActiveSkillIconPaths.AddItem(IconPath;
        }        
    }
    else
    {
        ActiveSkillIconPaths.RemoveItem(IconPath;
    }
    KFPC = KFPlayerController(Controller);
    KFPC.myGfxHUD.PlayerStatusContainer.ShowActiveIndicators(ActiveSkillIconPaths);
}

event Landed(Vector HitNormal, Actor FloorActor)
{
    local KFPlayerController_WeeklySurvival KFPC;

    super.Landed(HitNormal, FloorActor);
    if(KFPawn_Monster(FloorActor) == none)
    {
        KFPC = KFPlayerController_WeeklySurvival(Controller);
        if(KFPC != none)
        {
            KFPC.ResetGoompaStreak();
        }
    }
}

reliable client simulated function ClientOverrideHumanDefaults()
{
    local KFPlayerController_WeeklySurvival KFPC_WS;
    local KFPlayerReplicationInfo KFPRI;
    local KFGameReplicationInfo KFGRI;
    local KFCharacterInfo_Human KFCIH;
    local int CowboyHatIndex;

    KFPC_WS = KFPlayerController_WeeklySurvival(Controller);
    if(KFPC_WS == none)
    {
        return;
    }
    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if((KFGRI != none) && KFGRI.CurrentWeeklyIndex == 12)
    {
        KFPRI = KFPlayerReplicationInfo(KFPC_WS.PlayerReplicationInfo);
        if(KFPRI != none)
        {
            KFCIH = KFPRI.CharacterArchetypes[KFPRI.RepCustomizationInfo.CharacterIndex];
            CowboyHatIndex = Class'KFGFxMenu_Gear'.static.FindCowboyHatAttachmentIndex(KFCIH);
            if(CowboyHatIndex >= 0)
            {
                KFCIH.DetachConflictingAttachments(CowboyHatIndex, self, KFPRI);
                KFPRI.SetWeeklyCharacterAttachment(CowboyHatIndex, 0);
            }
        }
    }
}

state Dying
{
    simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
    {
        local PlayerController PC;
        local Matrix HeadMatrix;
        local Vector HeadLoc;
        local Rotator HeadRot;

        PC = GetALocalPlayerController();
        if((PC.UsingFirstPersonCamera() && !PC.IsSpectating()) && PC.ViewTarget == self)
        {
            HeadMatrix = Mesh.GetBoneMatrix(Mesh.MatchRefBone('head'));
            HeadLoc = MatrixGetOrigin(HeadMatrix);
            HeadMatrix = Multiply_MatrixMatrix(MakeRotationMatrix(rot(0, -16383, 16383)), HeadMatrix);
            HeadRot = MatrixGetRotator(HeadMatrix);
            out_CamLoc = VInterpTo(out_CamLoc, HeadLoc, fDeltaTime, 10);
            out_CamRot = RInterpTo(out_CamRot, HeadRot, fDeltaTime, 10);
            return true;
        }
        return global.CalcCamera(fDeltaTime, out_CamLoc, out_CamRot, out_FOV);
    }
    stop;    
}

defaultproperties
{
    MaxArmor=100
    IntegrityLevel_High=75
    IntegrityLevel_Medium=50
    IntegrityLevel_Low=25
    MinEnemiesToTriggerSurrounded=2
    DeathFaceAnims(0)=Death_V1
    DeathFaceAnims(1)=Death_V2
    DeathFaceAnims(2)=Death_V3
    BloodPoolDelay=2
    PainSoundChanceOnHit=1
    PainSoundCoolDown=1
    PerkFXEmitterPoolClassPath="KFGame.KFPerkFXEmitterPool"
    DeathMaterialEffectDuration=0.1
    DeathMaterialEffectParamName=scalar_dead
    begin object name=FlashLight class=KFFlashlightAttachment
        LightTemplate=SpotLightComponent'Default__KFPawn_Human.FlashLight.FlashLightTemplate'
        LightConeMesh=StaticMesh'wep_flashlights_mesh.WEP_3P_Lightcone'
        begin object name=LightConeComp class=StaticMeshComponent
            ReplacementPrimitive=none
        object end
        // Reference: StaticMeshComponent'Default__KFPawn_Human.FlashLight.LightConeComp'
        LightConeMeshComp=LightConeComp
        AttachmentMesh=StaticMesh'wep_flashlights_mesh.PlayerLight_MESH'
    object end
    // Reference: KFFlashlightAttachment'Default__KFPawn_Human.FlashLight'
    FlashLightTemplate=FlashLight
    BatteryDrainRate=0.8
    BatteryRechargeRate=6
    BatteryCharge=100
    NVGBatteryDrainRate=0.8
    HealthRegenRate=0.1
    HealerRewardScaler=60
    ArmorAbsorbModifier_High=0.75
    ArmorAbsorbModifier_Medium=0.65
    ArmorAbsorbModifier_Low=0.55
    MinHealthPctToTriggerSurrounded=0.95
    begin object name=TraderDialogAkSoundComponent class=AkComponent
        BoneName=Root
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn_Human.TraderDialogAkSoundComponent'
    TraderDialogAkComponent=TraderDialogAkSoundComponent
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_Human.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bEnableAimOffset=true
    HitZones(0)=(ZoneName=head,BoneName=head,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(1)=(ZoneName=neck,BoneName=neck,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(2)=(ZoneName=chest,BoneName=Spine2,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(3)=(ZoneName=heart,BoneName=Spine2,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(4)=(ZoneName=lupperarm,BoneName=LeftArm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(5)=(ZoneName=lforearm,BoneName=LeftForearm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(6)=(ZoneName=lhand,BoneName=LeftForearm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(7)=(ZoneName=rupperarm,BoneName=RightArm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(8)=(ZoneName=rforearm,BoneName=RightForearm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(9)=(ZoneName=rhand,BoneName=RightForearm,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(10)=(ZoneName=stomach,BoneName=Spine1,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(11)=(ZoneName=abdomen,BoneName=hips,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(12)=(ZoneName=lthigh,BoneName=LeftUpLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(13)=(ZoneName=lcalf,BoneName=LeftLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(14)=(ZoneName=lfoot,BoneName=LeftLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(15)=(ZoneName=rthigh,BoneName=RightUpLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(16)=(ZoneName=rcalf,BoneName=RightLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    HitZones(17)=(ZoneName=rfoot,BoneName=RightLeg,GoreHealth=50,MaxGoreHealth=-1,DmgScale=1,Limb=EHitZoneBodyPart.BP_Torso,SkinID=0,bPlayedInjury=false)
    BattleBloodParamName=Scalar_Blood_Contrast
    MinBattleBloodValue=0.2
    BattleBloodRangeSq=40000
    AfflictionHandler=KFAfflictionManager'Default__KFPawn_Human.Afflictions'
    IncapSettings(0)=(Duration=5,Cooldown=5,ChildAfflictionCooldown=0,Vulnerability=none)
    IncapSettings(1)=(Duration=1,Cooldown=0,ChildAfflictionCooldown=0,Vulnerability=(50))
    TeammateCollisionRadiusPercent=0.5
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses(0)=none
        SpecialMoveClasses(1)=none
        SpecialMoveClasses(2)=none
        SpecialMoveClasses(3)=none
        SpecialMoveClasses(4)=none
        SpecialMoveClasses(5)=none
        SpecialMoveClasses(6)=none
        SpecialMoveClasses(7)=none
        SpecialMoveClasses(8)=none
        SpecialMoveClasses(9)=none
        SpecialMoveClasses(10)=none
        SpecialMoveClasses(11)=none
        SpecialMoveClasses(12)=none
        SpecialMoveClasses(13)=none
        SpecialMoveClasses(14)=none
        SpecialMoveClasses(15)=none
        SpecialMoveClasses(16)=none
        SpecialMoveClasses(17)=none
        SpecialMoveClasses(18)=none
        SpecialMoveClasses(19)=none
        SpecialMoveClasses(20)=none
        SpecialMoveClasses(21)=none
        SpecialMoveClasses(22)=none
        SpecialMoveClasses(23)=none
        SpecialMoveClasses(24)=none
        SpecialMoveClasses(25)=none
        SpecialMoveClasses(26)=none
        SpecialMoveClasses(27)=none
        SpecialMoveClasses(28)=none
        SpecialMoveClasses(29)=none
        SpecialMoveClasses(30)=none
        SpecialMoveClasses(31)=class'KFSM_GrappleVictim'
        SpecialMoveClasses(32)=class'KFSM_DisabledGrappleVictim'
        SpecialMoveClasses(33)=class'KFSM_HansGrappleVictim'
        SpecialMoveClasses(34)=none
        SpecialMoveClasses(35)=class'KFSM_Player_Emote'
        SpecialMoveClasses(36)=class'KFSM_EvilDAR_EMPGrapple'
        SpecialMoveClasses(37)=class'KFSM_BloatKingGorgeVictim'
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_Human.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_Human.WeaponAmbientEchoHandler'
    SecondaryWeaponAkComponent=AkComponent'Default__KFPawn_Human.SecondaryWeaponAkSoundComponent'
    FootstepAkComponent=AkComponent'Default__KFPawn_Human.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_Human.DialogAkSoundComponent'
    PowerUpAkComponent=AkComponent'Default__KFPawn_Human.PowerUpAkSoundComponent'
    bCanPickupInventory=true
    CrouchRadius=40
    GroundSpeed=383
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        bPerBoneMotionBlur=false
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_Human.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_Human.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        bPerBoneMotionBlur=false
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_Human.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_Human.DialogAkSoundComponent'
    Components(8)=AkComponent'Default__KFPawn_Human.PowerUpAkSoundComponent'
    Components(9)=AkComponent'Default__KFPawn_Human.SecondaryWeaponAkSoundComponent'
    begin object name=TraderDialogAkSoundComponent class=AkComponent
        BoneName=Root
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn_Human.TraderDialogAkSoundComponent'
    Components(10)=TraderDialogAkSoundComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}