/*******************************************************************************
 * KFPawn_Human generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_Human extends KFPawn
    native(Pawn)
    nativereplication
    config(Game)
    hidecategories(Navigation);

enum ECustomizationOption
{
    CO_Character,
    CO_Head,
    CO_Body,
    CO_Attachment,
    CO_MAX
};

struct native DialogResponseInfo
{
    var KFPawn Speaker;
    var KFPawn RespondingToPawn;
    var int EventID;
    var int RespondingToID;

    structdefaultproperties
    {
        Speaker=none
        RespondingToPawn=none
        EventID=0
        RespondingToID=0
    }
};

var float LowHealthSpeedPenalty;
var repnotify byte CurrentWeaponState;
var byte ActivePerkMessageIdx;
var byte HealthToRegen;
var byte MaxArmor;
var byte Armor;
var byte IntegrityLevel_High;
var byte IntegrityLevel_Medium;
var byte IntegrityLevel_Low;
var array<name> DeathFaceAnims;
var globalconfig float BloodPoolDelay;
var float PainSoundChanceOnHit;
var float PainSoundCoolDown;
var float PainSoundLastPlayedTime;
var repnotify bool bFlashlightOn;
var repnotify bool bHasSupportSafeguardBuff;
var repnotify bool bHasSupportBarrageBuff;
var repnotify bool bHasMedicVaccinationBuff;
var bool bMovesFastInZedTime;
var bool bBuffsUpdated;
var bool bObjectivePlayer;
var() float BatteryDrainRate;
var() float BatteryRechargeRate;
var float BatteryCharge;
var float NVGBatteryDrainRate;
/** @name Night Vision */
var() export editinline PointLightComponent NightVisionLightTemplate;
var export editinline transient PointLightComponent NightVisionLight;
var KFGFxMoviePlayer_PlayerInfo PlayerPartyInfo;
var float HealthRegenRate;
var float HealerRewardScaler;
var float ArmorAbsorbModifier_High;
var float ArmorAbsorbModifier_Medium;
var float ArmorAbsorbModifier_Low;
var array<string> ActiveSkillIconPaths;
var transient int DoshCaughtStreakAmt;
var transient float LastDoshCaughtTime;
var transient PlayerReplicationInfo LastDoshCaughtGiver;
var transient int ZedsKilledStreakAmt;
var transient float LastZedKilledTime;
var transient int DamageTakenStreakAmt;
var transient float LastDamageTakenStreakStartTime;
var transient float InitialContinousDamageTime;
var transient float IdleStartTime;
var transient int EnvironmentDialogEventID;
var transient float SprintTowardZedStartTime;
var transient float SprintStartTime;
var protected export editinline AkComponent TraderDialogAkComponent;
var DialogResponseInfo DlgRespInfo;
var delegate<OnFinishedDialog> __OnFinishedDialog__Delegate;

replication
{
     if(bNetDirty)
        Armor, MaxArmor, 
        bMovesFastInZedTime, bObjectivePlayer;

     if(bNetDirty && !bNetOwner || bDemoRecording)
        CurrentWeaponState, bFlashlightOn;

     if(bNetDirty && bNetOwner)
        bHasMedicVaccinationBuff, bHasSupportBarrageBuff, 
        bHasSupportSafeguardBuff;
}

simulated event Tick(float DeltaTime)
{
    local float NewSpeedPenalty;

    super.Tick(DeltaTime);
    if(Role == ROLE_Authority)
    {
        if(Health < HealthMax)
        {
            NewSpeedPenalty = Lerp(0.3, 0, FMin(float(Health) / float(100), 1));            
        }
        else
        {
            NewSpeedPenalty = 0;
        }
        if(NewSpeedPenalty != LowHealthSpeedPenalty)
        {
            LowHealthSpeedPenalty = NewSpeedPenalty;
            UpdateGroundSpeed();
        }
    }
}

simulated event PreBeginPlay()
{
    super.PreBeginPlay();
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super.PossessedBy(C, bVehicleTransition);
    bHasSupportSafeguardBuff = false;
    bHasSupportBarrageBuff = false;
    bHasMedicVaccinationBuff = false;
    ResetIdleStartTime();
}

simulated function NotifyTeamChanged()
{
    local KFPerk InstigatorPerk;

    if(PlayerReplicationInfo != none)
    {
        SetCharacterArch(GetCharacterInfo());
    }
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.NotifyPawnTeamChanged();
    }
}

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'CurrentWeaponState':
            WeaponStateChanged(CurrentWeaponState, true);
            break;
        case 'bFlashlightOn':
            SetFlashlight(bFlashlightOn, false);
            break;
        case 'bHasMedicVaccinationBuff':
            if(bHasMedicVaccinationBuff)
            {
                EnableMedicVaccinationBuff();                
            }
            else
            {
                DisableMedicVaccinationBuff();
            }
            break;
        case 'bHasSupportSafeguardBuff':
            SetSupportSafeguardBuff(bHasSupportSafeguardBuff);
            break;
        case 'bHasSupportBarrageBuff':
            SetSupportBarrageBuff(bHasSupportBarrageBuff);
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

simulated event Destroyed()
{
    if(PlayerPartyInfo != none)
    {
        PlayerPartyInfo.SetVisible(false);
        PlayerPartyInfo.Close();
    }
    super.Destroyed();
}

function AddDefaultInventory()
{
    local KFPerk MyPerk;

    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.AddDefaultInventory(self);
    }
    DefaultInventory.AddItem(class<Weapon>(DynamicLoadObject("KFGameContent.KFWeap_Pistol_9mm", Class'Class'));
    DefaultInventory.AddItem(class<Weapon>(DynamicLoadObject("KFGameContent.KFWeap_Healer_Syringe", Class'Class'));
    DefaultInventory.AddItem(class<Weapon>(DynamicLoadObject("KFGameContent.KFWeap_Welder", Class'Class'));
    DefaultInventory.AddItem(class<Inventory>(DynamicLoadObject("KFGameContent.KFInventory_Money", Class'Class'));
    super.AddDefaultInventory();
}

simulated function PlayWeaponSwitch(Weapon OldWeapon, Weapon NewWeapon)
{
    super.PlayWeaponSwitch(OldWeapon, NewWeapon);
    if(Role == ROLE_Authority)
    {
        UpdateGroundSpeed();
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlaySwitchToFavoriteWeaponDialog(self);
        }
    }
    if(bFlashlightOn)
    {
        SetFlashlight(false, false);
    }
}

function UpdateGroundSpeed()
{
    local KFInventoryManager InvM;
    local float WeightMod, HealthMod;

    if(Role < ROLE_Authority)
    {
        return;
    }
    InvM = KFInventoryManager(InvManager);
    WeightMod = ((InvM != none) ? InvM.GetEncumbranceSpeedMod() : 1);
    HealthMod = 1 - LowHealthSpeedPenalty;
    GroundSpeed = (default.GroundSpeed * WeightMod) * HealthMod;
    SprintSpeed = (default.SprintSpeed * WeightMod) * HealthMod;
    if((GetPerk()) != none)
    {
        GetPerk().ModifySpeed(GroundSpeed);
        GetPerk().ModifySpeed(SprintSpeed);
    }
}

simulated function WeaponStateChanged(byte NewState, optional bool bViaReplication)
{
    CurrentWeaponState = NewState;
    if((WorldInfo.TimeSeconds - CreationTime) < 1)
    {
        return;
    }
    if(IsDoingSpecialMove() && !SpecialMoves[SpecialMove].bAllowThirdPersonWeaponAnims)
    {
        return;
    }
    if(WeaponAttachment != none)
    {
        WeaponAttachment.UpdateThirdPersonWeaponAction(CurrentWeaponState, self);
    }
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    BodyStanceNodes[4] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_CH_Upper'));
    BodyStanceNodes[5] = AnimNodeSlot(SkelComp.FindAnimNode('Custom_CH_Lower'));
    RecoilNodes[0] = GameSkelCtrl_Recoil(SkelComp.FindSkelControl('SpineRecoil'));
}

simulated function StopAllAnimations()
{
    local name FacePose;

    FacePose = DeathFaceAnims[Rand(DeathFaceAnims.Length)];
    PlayBodyAnim(FacePose, 6,,,, true);
    super.StopAllAnimations();
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    local int DoshEarned;
    local float UsedHealAmount;
    local KFPlayerReplicationInfo InstigatorPRI;
    local KFPlayerController InstigatorPC, KFPC;
    local KFPerk InstigatorPerk;
    local class<KFDamageType> KFDT;
    local int I;
    local bool bRepairedArmor;

    bCanRepairArmor = true;
    bMessageHealer = true;
    InstigatorPC = KFPlayerController(Healer);
    InstigatorPerk = ((InstigatorPC != none) ? InstigatorPC.GetPerk() : none);
    if((InstigatorPerk != none) && bCanRepairArmor)
    {
        bRepairedArmor = InstigatorPerk.RepairArmor(self);
    }
    if(((Amount > 0) && IsAliveAndWell()) && Health < HealthMax)
    {
        KFDT = class<KFDamageType>(DamageType);
        if((KFDT != none) && KFDT.default.bNoPain)
        {
            PlayHeal(KFDT);            
        }
        else
        {
            WarnInternal("No hit effects et for damagetype:" @ string(DamageType));
        }
        if(Role == ROLE_Authority)
        {
            if((InstigatorPC == none) || InstigatorPC.PlayerReplicationInfo == none)
            {
                return false;
            }
            InstigatorPRI = KFPlayerReplicationInfo(InstigatorPC.PlayerReplicationInfo);
            UsedHealAmount = float(Amount);
            if(InstigatorPerk != none)
            {
                InstigatorPerk.ModifyHealAmount(UsedHealAmount);
            }
            if((float(Health + HealthToRegen) + UsedHealAmount) > float(HealthMax))
            {
                UsedHealAmount = float(HealthMax - (Health + HealthToRegen));
            }
            HealthToRegen += byte(UsedHealAmount);
            SetTimer(HealthRegenRate, true, 'GiveHealthOverTime');
            if((InstigatorPC.Pawn != none) && InstigatorPC.Pawn != self)
            {
                DoshEarned = int((UsedHealAmount / float(HealthMax)) * HealerRewardScaler);
                InstigatorPRI.AddDosh(Max(DoshEarned, 0), true);
                InstigatorPC.AddHealPoints(int(UsedHealAmount));
            }
            if(((WorldInfo.Game != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter != none) && KFGameInfo(WorldInfo.Game).GameplayEventsWriter.IsSessionInProgress())
            {
                KFGameInfo(WorldInfo.Game).GameplayEventsWriter.LogPlayerHealEvent(Amount, Healer, DamageType, self.Controller, DoshEarned);
            }
            if(Healer.bIsPlayer)
            {
                if(Healer != Controller)
                {
                    AddHealerToObjective(Healer);
                    InstigatorPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 3, PlayerReplicationInfo);
                    KFPC = KFPlayerController(Controller);
                    KFPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 2, Healer.PlayerReplicationInfo);
                    if((KFPC != none) && KFPC.MatchStats != none)
                    {
                        KFPC.MatchStats.RecordIntStat(5, int(UsedHealAmount));
                    }
                    if((InstigatorPC != none) && InstigatorPC.MatchStats != none)
                    {
                        InstigatorPC.MatchStats.RecordIntStat(4, int(UsedHealAmount));
                    }                    
                }
                else
                {
                    if(bMessageHealer)
                    {
                        InstigatorPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Game', 4, PlayerReplicationInfo);
                    }
                }
            }
            if(bMessageHealer)
            {
                if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
                {
                    KFGameInfo(WorldInfo.Game).DialogManager.PlayHealingDialog(KFPawn(Healer.Pawn), self, float(Health + HealthToRegen) / float(HealthMax));
                }
            }
            I = 0;
            J0x83C:

            if(I < DamageOverTimeArray.Length)
            {
                if(DamageOverTimeArray[I].DoT_Type == 1)
                {
                    DamageOverTimeArray[I].Duration *= 0.5;
                    DamageOverTimeArray[I].Damage *= 0.5;
                    goto J0x8ED;
                }
                ++ I;
                goto J0x83C;
            }
            J0x8ED:

            return true;
        }
    }
    return bRepairedArmor;
}

function GiveHealthOverTime()
{
    local KFPlayerReplicationInfo KFPRI;

    if((HealthToRegen > 0) && Health < HealthMax)
    {
        ++ Health;
        -- HealthToRegen;
        KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
        if(KFPRI != none)
        {
            KFPRI.PlayerHealth = byte(Health);
        }        
    }
    else
    {
        HealthToRegen = 0;
        ClearTimer('GiveHealthOverTime');
    }
}

function AddArmor(int Amount)
{
    Armor = byte(Min(Armor + Amount, GetMaxArmor()));
}

function GiveMaxArmor()
{
    Armor = byte(GetMaxArmor());
}

function int GetMaxArmor()
{
    return MaxArmor;
}

function ShieldAbsorb(out int InDamage)
{
    local float AbsorbedPct;
    local int AbsorbedDmg;

    if((Armor >= IntegrityLevel_High) || bHasSupportSafeguardBuff)
    {
        AbsorbedPct = ArmorAbsorbModifier_High;        
    }
    else
    {
        if(Armor >= IntegrityLevel_Medium)
        {
            AbsorbedPct = ArmorAbsorbModifier_Medium;            
        }
        else
        {
            AbsorbedPct = ArmorAbsorbModifier_Low;
        }
    }
    AbsorbedDmg = Min(Round(AbsorbedPct * float(InDamage)), Armor);
    Armor -= byte(AbsorbedDmg);
    InDamage -= AbsorbedDmg;
}

simulated function LeaveBloodPool()
{
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if(GoreManager != none)
    {
        GoreManager.LeaveABloodPoolDecal(self);
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation)
{
    local KFPlayerController KFPC;
    local class<KFDamageType> dmgType;

    dmgType = HitFxInfo.DamageType;
    if(IsLocallyControlled() && !Controller.bGodMode)
    {
        KFPC = KFPlayerController(Controller);
        if((KFPC != none) && dmgType != none)
        {
            KFPC.PlayScreenHitFX(dmgType, true);
            if(dmgType.default.RadialDamageImpulse > float(0))
            {
                KFPC.PlayEarRingEffect(ByteToFloat(HitFxRadialInfo.RadiusDamageScale));
            }
        }
        if(MyKFWeapon != none)
        {
            MyKFWeapon.PlayTakeHitEffects(HitFxInfo.HitLocation, HitFxInstigator);
        }
    }
    if(WorldInfo.TimeSeconds > (PainSoundLastPlayedTime + PainSoundCoolDown))
    {
        if(PainSoundChanceOnHit >= (1 - FRand()))
        {
            SoundGroupArch.PlayPainSound(self);
            PainSoundLastPlayedTime = WorldInfo.TimeSeconds;
        }
    }
    super.PlayTakeHitEffects(HitDirection, HitLocation);
}

simulated function PlayDamageInstigatorHitEffects(KFPawn Victim)
{
    local float BloodParamIncrementValue;

    super.PlayDamageInstigatorHitEffects(Victim);
    if(WeaponAttachment != none)
    {
        if((WorldInfo.NetMode != NM_DedicatedServer) && VSizeSq(Victim.Location - Location) < BattleBloodRangeSq)
        {
            BloodParamIncrementValue = RandRange(0.01, 0.05);
            if(WorldInfo.TimeSeconds == Victim.TimeOfDeath)
            {
                BloodParamIncrementValue *= 2;
            }
            AddBattleBlood(BloodParamIncrementValue);
            WeaponAttachment.AddBattleBlood(BloodParamIncrementValue);
        }
    }
}

simulated function AddBattleBlood(float InBattleBloodIncrementvalue)
{
    BattleBloodParamValue = FMax(BattleBloodParamValue + InBattleBloodIncrementvalue, MinBattleBloodValue);
    if((BodyMIC != none) && HeadMIC != none)
    {
        BodyMIC.SetScalarParameterValue(BattleBloodParamName, BattleBloodParamValue);
        HeadMIC.SetScalarParameterValue(BattleBloodParamName, BattleBloodParamValue);
    }
}

simulated function SetNightVisionLight(bool bEnabled);

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    local class<KFDamageType> KFDT;

    super.PlayDying(DamageType, HitLoc);
    if((Physics == 10) && !Mesh.HiddenGame)
    {
        KFDT = class<KFDamageType>(DamageType);
        SetTimer(BloodPoolDelay, false, 'LeaveBloodPool');
        PlayDamageMaterialEffects((((KFDT != none) && KFDT.default.DeathMaterialEffectParamName != 'None') ? KFDT.default.DeathMaterialEffectParamName : default.DeathMaterialEffectParamName), (((KFDT != none) && KFDT.default.DeathMaterialEffectDuration != 0) ? KFDT.default.DeathMaterialEffectDuration : default.DeathMaterialEffectDuration));
    }
    if(PlayerPartyInfo != none)
    {
        PlayerPartyInfo.Close(true);
        PlayerPartyInfo = none;
    }
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local int WaveNum;
    local KFPlayerController KFPC;

    if(super.Died(Killer, DamageType, HitLocation))
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPlayerDeathDialog(self);
        }
        WaveNum = KFGameReplicationInfo(WorldInfo.GRI).WaveNum;
        KFPC = KFPlayerController(Controller);
        if(KFPC != none)
        {
            if(KFPC.PWRI.DeathStreakEndWave != (WaveNum - 1))
            {
                KFPC.PWRI.DeathStreakStartWave = byte(WaveNum);
            }
            KFPC.PWRI.DeathStreakEndWave = byte(WaveNum);
            if(Killer.Pawn != none)
            {
                KFPC.PWRI.ClassKilledByLastWave = class<KFPawn_Monster>(Killer.Pawn.Class);
            }
            KFPC.ReceiveLocalizedMessage(Class'KFLocalMessage_Interaction', 0);
        }
        return true;
    }
    return false;
}

simulated function BroadcastDeathMessage(Controller Killer)
{
    if((Killer != none) && Killer.IsA('KFAIController'))
    {
        BroadcastLocalizedMessage(Class'KFLocalMessage_Game', 21, PlayerReplicationInfo, none, Killer.Class);        
    }
    else
    {
        BroadcastLocalizedMessage(Class'KFLocalMessage_Game', 22, PlayerReplicationInfo);
    }
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser)
{
    local KFPerk MyKFPerk, MyMedicPerk;
    local float TempDamage;
    local bool bHasSacrificeSkill;

    if(bLogTakeDamage)
    {
        LogInternal(((string(self) @ string(GetFuncName())) @ "Adjusted Damage BEFORE =") @ string(InDamage));
    }
    super.AdjustDamage(InDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
    MyKFPerk = GetPerk();
    if(MyKFPerk != none)
    {
        MyKFPerk.ModifyDamageTaken(InDamage, DamageType, InstigatedBy);
        MyMedicPerk = KFPerk_FieldMedic(MyKFPerk);
        bHasSacrificeSkill = MyKFPerk.ShouldSacrifice();
    }
    TempDamage = float(InDamage);
    if((TempDamage > float(0)) && bHasMedicVaccinationBuff)
    {
        if(MyMedicPerk != none)
        {
            Class'KFPerk_FieldMedic'.static.ModifyVaccinationDamage(TempDamage, DamageType, MyMedicPerk.GetLevel());            
        }
        else
        {
            Class'KFPerk_FieldMedic'.static.ModifyVaccinationDamage(TempDamage, DamageType);
        }
        TempDamage = ((TempDamage < 1) ? 1 : TempDamage);
    }
    if(((TempDamage > float(0)) && Class'KFPerk_Demolitionist'.static.IsDmgTypeExplosiveResistable(DamageType)) && HasExplosiveResistance())
    {
        Class'KFPerk_Demolitionist'.static.ModifyExplosiveDamage(TempDamage);
        TempDamage = ((TempDamage < 1) ? 1 : TempDamage);
    }
    InDamage = Round(TempDamage);
    if(((InDamage > 0) && Armor > 0) && DamageType.default.bArmorStops)
    {
        ShieldAbsorb(InDamage);
    }
    if((bHasSacrificeSkill && Health >= 5) && (Health - InDamage) < 5)
    {
        Health = InDamage + 5;
        SacrificeExplode();
    }
    if(bLogTakeDamage)
    {
        LogInternal(((string(self) @ string(GetFuncName())) @ "Adjusted Damage AFTER =") @ string(InDamage));
    }
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int ActualDamageTaken, OldHealth;
    local KFPlayerReplicationInfo KFPRI;
    local KFAIController_ZedBoss InstigatedByBoss;

    OldHealth = Health;
    if(bLogTakeDamage)
    {
        LogInternal((((((string(GetFuncName()) @ "Damage BEFORE =") $ string(Damage)) $ " DamageType: ") $ string(DamageType)) $ " DamageCauser: ") $ string(DamageCauser));
    }
    super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    ActualDamageTaken = OldHealth - Health;
    if(bLogTakeDamage)
    {
        LogInternal((((((string(GetFuncName()) @ "Damage AFTER =") $ string(ActualDamageTaken)) $ " DamageType: ") $ string(DamageType)) $ " DamageCauser: ") $ string(DamageCauser));
    }
    if((ActualDamageTaken > 0) && IsAliveAndWell())
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPlayerDamageDialog(self, DamageType, ActualDamageTaken);
        }
        InstigatedByBoss = KFAIController_ZedBoss(InstigatedBy);
        if(InstigatedByBoss != none)
        {
            InstigatedByBoss.PlayDamagePlayerDialog(DamageType);
        }
        if((KFPlayerController(Controller) != none) && KFPlayerController(Controller).MatchStats != none)
        {
            KFPlayerController(Controller).MatchStats.RecordIntStat(3, ActualDamageTaken);
        }
    }
    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI != none)
    {
        KFPRI.PlayerHealth = byte(Health);
    }
    ResetIdleStartTime();
}

function SacrificeExplode()
{
    local KFExplosionActorReplicated ExploActor;
    local GameExplosion ExplosionTemplate;
    local KFPerk_Demolitionist DemoPerk;

    if(Role < ROLE_Authority)
    {
        return;
    }
    DemoPerk = KFPerk_Demolitionist(GetPerk());
    ExploActor = Spawn(Class'KFExplosionActorReplicated', self,, Location,,, true);
    if(ExploActor != none)
    {
        ExploActor.InstigatorController = Controller;
        ExploActor.Instigator = self;
        ExplosionTemplate = Class'KFPerk_Demolitionist'.static.GetSacrificeExplosionTemplate();
        ExplosionTemplate.MyDamageType = Class'KFPerk_Demolitionist'.static.GetSacrificeDamageTypeClass();
        ExplosionTemplate.bIgnoreInstigator = true;
        ExploActor.Explode(ExplosionTemplate);
        if(DemoPerk != none)
        {
            DemoPerk.NotifyPerkSacrificeExploded();
        }
    }
}

protected function bool HasExplosiveResistance()
{
    local KFPawn_Human TestPawn;
    local KFPerk TestPawnPerk;

    foreach WorldInfo.AllPawns(Class'KFPawn_Human', TestPawn, Location, Class'KFPerk_Demolitionist'.static.GetExplosiveResistanceRadius())
    {
        TestPawnPerk = TestPawn.GetPerk();
        if((TestPawnPerk != none) && TestPawnPerk.IsSharedExplosiveResistaneActive())
        {            
            return true;
        }        
    }    
    return false;
}

function float GetPerkDoTScaler(optional Controller InstigatedBy, optional class<KFDamageType> KFDT)
{
    local KFPerk MyPerk;
    local float DoTScaler;

    DoTScaler = 1;
    MyPerk = GetPerk();
    if(MyPerk != none)
    {
        MyPerk.ModifyBloatBileDoT(DoTScaler);
    }
    return DoTScaler;
}

simulated function SetSupportBarrageBuff(bool bEnabled)
{
    if(Role == ROLE_Authority)
    {
        bHasSupportBarrageBuff = bEnabled;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        NotifyBuffUpdate(Class'KFPerk_Support'.default.PerkSkills[9].IconPath, bHasSupportBarrageBuff);
    }
}

simulated function SetSupportSafeguardBuff(bool bEnabled)
{
    if(Role == ROLE_Authority)
    {
        bHasSupportSafeguardBuff = bEnabled;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        NotifyBuffUpdate(Class'KFPerk_Support'.default.PerkSkills[8].IconPath, bHasSupportSafeguardBuff);
    }
}

simulated function EnableMedicVaccinationBuff()
{
    if(Role == ROLE_Authority)
    {
        bHasMedicVaccinationBuff = true;
        SetTimer(Class'KFPerk_FieldMedic'.static.GetVaccinationDuration(), false, 'DisableMedicVaccinationBuff');
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        NotifyBuffUpdate(Class'KFPerk_FieldMedic'.default.PerkSkills[6].IconPath, bHasMedicVaccinationBuff);
    }
}

simulated function DisableMedicVaccinationBuff()
{
    if(Role == ROLE_Authority)
    {
        bHasMedicVaccinationBuff = false;
        bForceNetUpdate = true;
    }
    if(IsLocallyControlled())
    {
        NotifyBuffUpdate(Class'KFPerk_FieldMedic'.default.PerkSkills[6].IconPath, bHasMedicVaccinationBuff);
    }
}

simulated function NotifyBuffUpdate(string BuffIconPath, bool bAddItem)
{
    local KFPlayerController KFPC;

    if(IsLocallyControlled())
    {
        if(bAddItem)
        {
            if(ActiveSkillIconPaths.Find(BuffIconPath == -1)
            {
                ActiveSkillIconPaths.AddItem(BuffIconPath;
            }            
        }
        else
        {
            ActiveSkillIconPaths.RemoveItem(BuffIconPath;
        }
        KFPC = KFPlayerController(Controller);
        KFPC.MyGFxHUD.PlayerStatusContainer.ShowActiveIndicators(ActiveSkillIconPaths);
    }
}

simulated function ClearBuffIcons()
{
    local KFPlayerController KFPC;

    if(IsLocallyControlled())
    {
        ActiveSkillIconPaths.Length = 0;
        KFPC = KFPlayerController(Controller);
        KFPC.MyGFxHUD.PlayerStatusContainer.ShowActiveIndicators(ActiveSkillIconPaths);
    }
}

function array<string> GetUpdatedSkillIndicators()
{
    bBuffsUpdated = false;
    return ActiveSkillIconPaths;
}

function AddHealerToObjective(Controller Healer)
{
    local KFGameReplicationInfo KFGRI;

    if(Healer.PlayerReplicationInfo != none)
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if((KFGRI != none) && KFGRI.CurrentObjective != none)
        {
            KFGRI.CurrentObjective.NewHealer(Healer.PlayerReplicationInfo);
        }
    }
}

simulated function UpdateCustomizationOption(KFPawn_Human.ECustomizationOption CustomizationOption, byte MeshIndex, byte SkinIndex, optional int AttachmentIndex)
{
    local string CharArchPath;
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    if(KFPRI == none)
    {
        return;
    }
    switch(CustomizationOption)
    {
        case 1:
            CharacterArch.SetHeadMeshAndSkin(MeshIndex, SkinIndex, self, KFPRI);
            break;
        case 2:
            CharacterArch.SetBodyMeshAndSkin(MeshIndex, SkinIndex, self, KFPRI);
            CharacterArch.SetArmsMeshAndSkin(MeshIndex, SkinIndex, self, KFPRI);
            break;
        case 3:
            if(MeshIndex == 255)
            {
                CharacterArch.ClearAllAttachments(self, KFPRI);                
            }
            else
            {
                CharacterArch.SetAttachmentMeshAndSkin(MeshIndex, SkinIndex, self, KFPRI);
            }
            break;
        default:
            break;
    }
    CharArchPath = PathName(KFPRI.CharacterArchetypes[KFPRI.RepCustomizationInfo.CharacterIndex]);
    KFPRI.SaveCharacterConfig(CharArchPath);
    if(Role < ROLE_Authority)
    {
        KFPRI.InitializeCharacter(KFPRI.StoredCharIndex);
    }
}

simulated function UpdateCustomizationChar(KFCharacterInfo_Human InCharArch)
{
    if(InCharArch != CharacterArch)
    {
        SetCharacterArch(InCharArch);        
    }
    else
    {
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            SetCharacterMeshFromArch();
        }
    }
}

simulated function SetCharacterMeshFromArch()
{
    local KFPlayerReplicationInfo KFPRI;

    KFPRI = KFPlayerReplicationInfo(PlayerReplicationInfo);
    CharacterArch.SetCharacterMeshFromArch(self, KFPRI);
}

delegate OnFinishedDialog(const out DialogResponseInfo ResponseInfo);

function HandleDialogResponse()
{
    if(Role == ROLE_Authority)
    {
        if(__OnFinishedDialog__Delegate != none)
        {
            if((DlgRespInfo.RespondingToID < 0) || DlgRespInfo.RespondingToID == CurrDialogEventID)
            {
                OnFinishedDialog(DlgRespInfo);
            }
            __OnFinishedDialog__Delegate = None;
        }
    }
}

function SetDialogResponseDelegate(KFPawn Responder, delegate<OnFinishedDialog> ResponseDelegate, optional int ResponseID, optional int RespondingToID)
{
    ResponseID = -1;
    RespondingToID = -1;
    DlgRespInfo.Speaker = Responder;
    DlgRespInfo.RespondingToPawn = self;
    DlgRespInfo.EventID = ResponseID;
    DlgRespInfo.RespondingToID = RespondingToID;
    __OnFinishedDialog__Delegate = ResponseDelegate;
}

function UpdateDoshCaught(int Amount, PlayerReplicationInfo Tosser)
{
    if(((WorldInfo.TimeSeconds - LastDoshCaughtTime) < 0.75) && LastDoshCaughtGiver == Tosser)
    {
        DoshCaughtStreakAmt += Amount;        
    }
    else
    {
        DoshCaughtStreakAmt = Amount;
        LastDoshCaughtGiver = Tosser;
    }
    LastDoshCaughtTime = WorldInfo.TimeSeconds;
    SetTimer(0.75, false, 'CaughtDoshDialogTimer');
}

function CaughtDoshDialogTimer()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayDoshCaughtDialog(self);
    }
    ClearTimer('CaughtDoshDialogTimer');
}

function UpdateKillStreak()
{
    if(LastPainTime < LastZedKilledTime)
    {
        ++ ZedsKilledStreakAmt;        
    }
    else
    {
        ZedsKilledStreakAmt = 1;
    }
    LastZedKilledTime = WorldInfo.TimeSeconds;
}

function UpdateDamageTakenStreak(int Amount, float interval)
{
    if((WorldInfo.TimeSeconds - LastDamageTakenStreakStartTime) < interval)
    {
        DamageTakenStreakAmt += Amount;        
    }
    else
    {
        DamageTakenStreakAmt = Amount;
        LastDamageTakenStreakStartTime = WorldInfo.TimeSeconds;
    }
}

function UpdateContinuousDamage(KFPawn_Monster DamagedZed, float MaxHitInterval)
{
    if((DamagedZed.LastHitBy != Controller) || (WorldInfo.TimeSeconds - DamagedZed.LastPainTime) > MaxHitInterval)
    {
        InitialContinousDamageTime = WorldInfo.TimeSeconds;
    }
}

function ResetIdleStartTime()
{
    local PlayerController PC;
    local KFPawn_Human KFPH;
    local float DistanceToTeammateSq, MaxResetDistanceSq;

    IdleStartTime = WorldInfo.TimeSeconds;
    MaxResetDistanceSq = 3000 * float(3000);
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC == Controller)
        {
            continue;            
        }
        KFPH = KFPawn_Human(PC.Pawn);
        if((KFPH == none) || !KFPH.IsAliveAndWell())
        {
            continue;            
        }
        DistanceToTeammateSq = VSizeSq(KFPH.Location - Location);
        if(DistanceToTeammateSq <= MaxResetDistanceSq)
        {
            KFPH.IdleStartTime = WorldInfo.TimeSeconds;
        }        
    }    
}

function float TimeSpentIdling()
{
    return WorldInfo.TimeSeconds - IdleStartTime;
}

function PlayTraderDialog(AkEvent DialogEvent)
{
    TraderDialogAkComponent.PlayEvent(DialogEvent);
}

function StopTraderDialog()
{
    if(TraderDialogAkComponent == none)
    {
        return;
    }
    TraderDialogAkComponent.StopEvents();
}

function SetSprinting(bool bNewSprintStatus)
{
    if(bIsSprinting || bNewSprintStatus)
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlaySprintPantingDialog(self, bNewSprintStatus);
        }
    }
    super.SetSprinting(bNewSprintStatus);
}

function bool DoJump(bool bUpdating)
{
    if(super.DoJump(bUpdating))
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayJumpDialog(self);
        }
        return true;
    }
    return false;
}

simulated function ToggleFlashlight()
{
    local bool bIsEnabled;

    if(IsLocallyControlled())
    {
        if((MyKFWeapon != none) && MyKFWeapon.bHasFlashlight)
        {
            bIsEnabled = (MyKFWeapon.FlashLight != none) && MyKFWeapon.FlashLight.bEnabled;
            SetFlashlight(!bIsEnabled, true);
        }
    }
}

simulated function SetFlashlight(bool bEnabled, optional bool bReplicate)
{
    bFlashlightOn = bEnabled;
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(IsLocallyControlled())
    {
        MyKFWeapon.FlashLight.SetEnabled(bEnabled);        
    }
    else
    {
        if(WeaponAttachment != none)
        {
            WeaponAttachment.SetThirdPersonFlashlight(bFlashlightOn);
        }
    }
    if(bReplicate && Role < ROLE_Authority)
    {
        ServerSetFlashlight(bFlashlightOn);
    }
}

private reliable server final function ServerSetFlashlight(bool bEnabled)
{
    bFlashlightOn = bEnabled;
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetFlashlight(bEnabled, false);
    }
}

simulated event NotifyOutOfBattery()
{
    local KFPlayerController KFPC;

    if(IsLocallyControlled())
    {
        KFPC = KFPlayerController(Controller);
        if(KFPC.bNightVisionActive)
        {
            KFPC.SetNightVision(false);
        }
        if(bFlashlightOn)
        {
            SetFlashlight(false, true);
        }
    }
}

// Export UKFPawn_Human::execDrawDoors(FFrame&, void* const)
native simulated function DrawDoors(Canvas Canvas);

simulated function DrawHUD(HUD H)
{
    local Canvas Canvas;
    local KFGameReplicationInfo KFGRI;

    super(Pawn).DrawHUD(H);
    if(!H.bShowHUD)
    {
        return;
    }
    Canvas = H.Canvas;
    if(Canvas != none)
    {
        DrawDoors(Canvas);
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if(KFGRI != none)
        {
            if((KFGRI.CurrentObjective != none) && IsAliveAndWell())
            {
                KFGRI.CurrentObjective.DrawObjectiveHUD(Canvas);
            }
        }
        Canvas.EnableStencilTest(true);
        DrawPerkHUD(Canvas);
        Canvas.EnableStencilTest(false);
    }
}

function DrawPerkHUD(Canvas C)
{
    local KFPerk Perk;

    Perk = GetPerk();
    if(Perk != none)
    {
        Perk.DrawSpecialPerkHUD(C);
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Canvas Canvas;

    super.DisplayDebug(HUD, out_YL, out_YPos);
    Canvas = HUD.Canvas;
    if(HUD.ShouldDisplayDebug('Movement'))
    {
        Canvas.SetDrawColor(0, 255, 255);
        Canvas.DrawText("EncumbranceMod:" @ string(KFInventoryManager(InvManager).GetEncumbranceSpeedMod()));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("HealthSpeedMod:" @ string(1 - LowHealthSpeedPenalty), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
}

state Dying
{
    simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
    {
        local PlayerController PC;
        local Matrix HeadMatrix;
        local Vector HeadLoc;
        local Rotator HeadRot;

        PC = GetALocalPlayerController();
        if((PC.UsingFirstPersonCamera() && !PC.IsSpectating()) && PC.ViewTarget == self)
        {
            HeadMatrix = Mesh.GetBoneMatrix(Mesh.MatchRefBone('head'));
            HeadLoc = MatrixGetOrigin(HeadMatrix);
            HeadMatrix = Multiply_MatrixMatrix(MakeRotationMatrix(rot(0, -16383, 16383)), HeadMatrix);
            HeadRot = MatrixGetRotator(HeadMatrix);
            out_CamLoc = VInterpTo(out_CamLoc, HeadLoc, fDeltaTime, 10);
            out_CamRot = RInterpTo(out_CamRot, HeadRot, fDeltaTime, 10);
            return true;
        }
        return global.CalcCamera(fDeltaTime, out_CamLoc, out_CamRot, out_FOV);
    }
    stop;    
}

defaultproperties
{
    MaxArmor=100
    IntegrityLevel_High=75
    IntegrityLevel_Medium=50
    IntegrityLevel_Low=25
    DeathFaceAnims(0)=Death_V1
    DeathFaceAnims(1)=Death_V2
    DeathFaceAnims(2)=Death_V3
    BloodPoolDelay=2
    PainSoundChanceOnHit=1
    PainSoundCoolDown=1
    BatteryDrainRate=2
    BatteryRechargeRate=4
    BatteryCharge=100
    NVGBatteryDrainRate=4
    HealthRegenRate=0.1
    HealerRewardScaler=60
    ArmorAbsorbModifier_High=0.75
    ArmorAbsorbModifier_Medium=0.65
    ArmorAbsorbModifier_Low=0.55
    begin object name=TraderDialogAkSoundComponent class=AkComponent
        BoneName=Root
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn_Human.TraderDialogAkSoundComponent'
    TraderDialogAkComponent=TraderDialogAkSoundComponent
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_Human.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bEnableAimOffset=true
    HitZones(0)=(ZoneName=head,BoneName=head,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(1)=(ZoneName=neck,BoneName=neck,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(2)=(ZoneName=chest,BoneName=Spine2,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(3)=(ZoneName=heart,BoneName=Spine2,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(4)=(ZoneName=lupperarm,BoneName=LeftArm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(5)=(ZoneName=lforearm,BoneName=LeftForearm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(6)=(ZoneName=lhand,BoneName=LeftForearm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(7)=(ZoneName=rupperarm,BoneName=RightArm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(8)=(ZoneName=rforearm,BoneName=RightForearm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(9)=(ZoneName=rhand,BoneName=RightForearm,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(10)=(ZoneName=stomach,BoneName=Spine1,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(11)=(ZoneName=abdomen,BoneName=Hips,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(12)=(ZoneName=lthigh,BoneName=LeftUpLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(13)=(ZoneName=lcalf,BoneName=LeftLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(14)=(ZoneName=lfoot,BoneName=LeftLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(15)=(ZoneName=rthigh,BoneName=RightUpLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(16)=(ZoneName=rcalf,BoneName=RightLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    HitZones(17)=(ZoneName=rfoot,BoneName=RightLeg,GoreHealth=50,DmgScale=1,Limb=EHitZoneBodyPart.BP_None,SkinID=0,bPlayedInjury=false)
    BattleBloodParamName=Scalar_Blood_Contrast
    MinBattleBloodValue=0.2
    BattleBloodRangeSq=40000
    DeathMaterialEffectParamName=scalar_dead
    DeathMaterialEffectDuration=0.1
    begin object name=Afflictions class=KFPawnAfflictions
        StackingAffl(0)=(Threshhold=1,Duration=5,Cooldown=5,DissipationRate=0.5)
        StackingAffl(1)=(Threshhold=0.2,Duration=1,Cooldown=0,DissipationRate=0.2)
        bNoBurnedMatBeforeDeath=true
    object end
    // Reference: KFPawnAfflictions'Default__KFPawn_Human.Afflictions'
    AfflictionHandler=Afflictions
    TeammateCollisionRadiusPercent=0.5
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    SpecialMoveHandler=KFSpecialMoveHandler'Default__KFPawn_Human.SpecialMoveHandler'
    AmbientAkComponent=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_Human.WeaponAmbientEchoHandler'
    FootstepAkComponent=AkComponent'Default__KFPawn_Human.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_Human.DialogAkSoundComponent'
    bCanPickupInventory=true
    CrouchRadius=40
    GroundSpeed=383
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        bPerBoneMotionBlur=false
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_Human.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_Human.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        bPerBoneMotionBlur=false
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_Human.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_Human.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_Human.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_Human.DialogAkSoundComponent'
    begin object name=TraderDialogAkSoundComponent class=AkComponent
        BoneName=Root
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFPawn_Human.TraderDialogAkSoundComponent'
    Components(8)=TraderDialogAkSoundComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=40
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_Human.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}