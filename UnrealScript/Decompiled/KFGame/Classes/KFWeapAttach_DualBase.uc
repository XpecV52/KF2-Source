/*******************************************************************************
 * KFWeapAttach_DualBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeapAttach_DualBase extends KFWeaponAttachment
    notplaceable
    hidecategories(Navigation,Object,Movement,Attachment,Collision,Physics,Advanced,Debug,Mobile);

const ShootLeftAnim = 'ADD_Shoot_LW';
const ShootRightAnim = 'ADD_Shoot_RW';
const CrouchShootLeftAnim = 'ADD_CH_Shoot_LW';
const CrouchShootRightAnim = 'ADD_CH_Shoot_RW';
const IronShootLeftAnim = 'ADD_Iron_Shoot_LW';
const IronShootRightAnim = 'ADD_Iron_Shoot_RW';
const WeaponFireAnim_R = 'Shoot_RW';
const WeaponFireAnim_L = 'Shoot_LW';
const WeaponAltFireAnim_R = 'Shoot_RW';
const WeaponAltFireAnim_L = 'Shoot_LW';
const LeftWeaponSocket = 'LW_Weapon';

/** Left hand skeletal mesh. If none is specified, the right hand skeletal mesh will be duplicated. */
var() const SkeletalMesh LeftHandSkelMesh;
/** Anim set to use for 3rd person weapon anims */
var() AnimSet LeftWeaponAnimSet;
var protected export editinline transient SkeletalMeshComponent LeftWeapMesh;
var protected transient KFMuzzleFlash LeftMuzzleFlash;
/** A reference to the left muzzle flash template (to specify left shell eject socket) */
var() protected const KFMuzzleFlash LeftMuzzleFlashTemplate;
var protected transient AnimNodeSequence LeftWeapAnimNode;
var transient bool bPlayFXOnSecondWeapon;
var transient float LastChooseWeaponTime;

event PreBeginPlay()
{
    if((LeftWeapMesh != none) && !bWeapMeshIsPawnMesh)
    {
        if(LeftWeaponAnimSet != none)
        {
            LeftWeapMesh.AnimSets[0] = LeftWeaponAnimSet;            
        }
        else
        {
            if(WeaponAnimSet != none)
            {
                LeftWeapMesh.AnimSets[0] = WeaponAnimSet;
            }
        }
        if(LeftHandSkelMesh != none)
        {
            LeftWeapMesh.SkeletalMesh = LeftHandSkelMesh;
        }
        LeftWeapAnimNode = AnimNodeSequence(LeftWeapMesh.Animations);
    }
    super.PreBeginPlay();
}

event ChangeVisibility(bool bIsVisible)
{
    super.ChangeVisibility(bIsVisible);
    if((LeftWeapMesh != none) && !bWeapMeshIsPawnMesh)
    {
        LeftWeapMesh.SetHidden(!bIsVisible);
    }
}

simulated function AttachTo(KFPawn P)
{
    super.AttachTo(P);
    if(bWeapMeshIsPawnMesh)
    {
        LeftWeapMesh = P.Mesh;        
    }
    else
    {
        if(LeftWeapMesh != none)
        {
            if(LeftHandSkelMesh == none)
            {
                LeftWeapMesh = new (self) Class'SkeletalMeshComponent' (WeapMesh);
            }
            LeftWeapMesh.SetShadowParent(P.Mesh);
            P.Mesh.AttachComponent(LeftWeapMesh, 'LW_Weapon');
        }
    }
    if((KFPawn_Human(P) != none) && KFPawn_Human(P).WeaponSkinItemId > 0)
    {
        SetWeaponSkin(KFPawn_Human(P).WeaponSkinItemId);
    }
}

simulated function DetachFrom(KFPawn P)
{
    super.DetachFrom(P);
    if(LeftMuzzleFlash != none)
    {
        LeftMuzzleFlash.DetachMuzzleFlash(LeftWeapMesh);
    }
    if(bWeapMeshIsPawnMesh)
    {
        LeftWeapMesh = none;        
    }
    else
    {
        if(LeftWeapMesh != none)
        {
            LeftWeapMesh.SetShadowParent(none);
            P.Mesh.DetachComponent(LeftWeapMesh);
        }
    }
}

simulated function AttachMuzzleFlash()
{
    super.AttachMuzzleFlash();
    if((WeapMesh != none) && LeftMuzzleFlash == none)
    {
        LeftMuzzleFlash = new (self) Class'KFMuzzleFlash' (LeftMuzzleFlashTemplate);
        LeftMuzzleFlash.AttachMuzzleFlash(LeftWeapMesh);
    }
}

function SetWeaponSkin(int ItemId)
{
    local array<MaterialInterface> SkinMICs;

    if((((WeapMesh != none) && LeftWeapMesh != none) && ItemId > 0) && WorldInfo.NetMode != NM_DedicatedServer)
    {
        SkinMICs = Class'KFWeaponSkinList'.static.GetWeaponSkin(ItemId, 1);
        if(SkinMICs.Length > 0)
        {
            WeapMesh.SetMaterial(0, SkinMICs[0]);
            LeftWeapMesh.SetMaterial(0, SkinMICs[0]);
        }
    }
}

function bool ChooseActiveWeapon(byte FlashCount)
{
    if(LastChooseWeaponTime == WorldInfo.TimeSeconds)
    {
        return bPlayFXOnSecondWeapon;
    }
    if(FlashCount > 0)
    {
        bPlayFXOnSecondWeapon = (FlashCount & 1) == 0;        
    }
    else
    {
        bPlayFXOnSecondWeapon = !bPlayFXOnSecondWeapon;
    }
    LastChooseWeaponTime = WorldInfo.TimeSeconds;
    return bPlayFXOnSecondWeapon;
}

simulated function bool ThirdPersonFireEffects(Vector HitLocation, KFPawn P, byte ThirdPersonAnimRateByte)
{
    ChooseActiveWeapon(P.FlashCount);
    return super.ThirdPersonFireEffects(HitLocation, P, ThirdPersonAnimRateByte);
}

simulated function PlayWeaponFireAnim()
{
    local float Duration;

    if((Instigator.FiringMode == 1) && 'Shoot' != 'None')
    {
        if(bPlayFXOnSecondWeapon)
        {
            Duration = LeftWeapMesh.GetAnimLength('Shoot_LW');
            LeftWeapMesh.PlayAnim('Shoot_LW', Duration / ThirdPersonAnimRate,, true);            
        }
        else
        {
            Duration = WeapMesh.GetAnimLength('Shoot_RW');
            WeapMesh.PlayAnim('Shoot_RW', Duration / ThirdPersonAnimRate,, true);
        }        
    }
    else
    {
        if('Shoot' != 'None')
        {
            if(bPlayFXOnSecondWeapon)
            {
                Duration = LeftWeapMesh.GetAnimLength('Shoot_LW');
                LeftWeapMesh.PlayAnim('Shoot_LW', Duration / ThirdPersonAnimRate,, true);                
            }
            else
            {
                Duration = WeapMesh.GetAnimLength('Shoot_RW');
                WeapMesh.PlayAnim('Shoot_RW', Duration / ThirdPersonAnimRate,, true);
            }
        }
    }
}

simulated function PlayPawnFireAnim(KFPawn P, KFPawn.EAnimSlotStance AnimType)
{
    if(P.bIsCrouched)
    {
        P.PlayBodyAnim(((bPlayFXOnSecondWeapon) ? 'ADD_CH_Shoot_LW' : 'ADD_CH_Shoot_RW'), 0, ThirdPersonAnimRate, ShootBlendInTime, ShootBlendOutTime);        
    }
    else
    {
        if(P.bIsWalking)
        {
            P.PlayBodyAnim(((bPlayFXOnSecondWeapon) ? 'ADD_Iron_Shoot_LW' : 'ADD_Iron_Shoot_RW'), 0, ThirdPersonAnimRate, ShootBlendInTime, ShootBlendOutTime);            
        }
        else
        {
            P.PlayBodyAnim(((bPlayFXOnSecondWeapon) ? 'ADD_Shoot_LW' : 'ADD_Shoot_RW'), 0, ThirdPersonAnimRate, ShootBlendInTime, ShootBlendOutTime);
        }
    }
}

simulated function CauseMuzzleFlash(byte FiringMode)
{
    if(bPlayFXOnSecondWeapon)
    {
        if((LeftMuzzleFlash == none) && MuzzleFlashTemplate != none)
        {
            AttachMuzzleFlash();
        }
        if(LeftMuzzleFlash != none)
        {
            LeftMuzzleFlash.CauseMuzzleFlash(FiringMode);
            if(LeftMuzzleFlash.bAutoActivateShellEject)
            {
                LeftMuzzleFlash.CauseShellEject();
            }
        }        
    }
    else
    {
        super.CauseMuzzleFlash(FiringMode);
    }
}

simulated function Vector GetMuzzleLocation(optional byte MuzzleID)
{
    local Vector SocketLocation;

    if((MuzzleID >= 1) || bPlayFXOnSecondWeapon)
    {
        if((LeftMuzzleFlash == none) && MuzzleFlashTemplate != none)
        {
            AttachMuzzleFlash();
        }
        if(LeftMuzzleFlash != none)
        {
            LeftWeapMesh.GetSocketWorldLocationAndRotation(LeftMuzzleFlash.GetSocketName(), SocketLocation);
            return SocketLocation;
        }
    }
    return super.GetMuzzleLocation(MuzzleID);
}

simulated function PlayWeaponMeshAnim(name AnimName, AnimNodeSlot SyncNode, bool bLoop)
{
    local float Duration;

    super.PlayWeaponMeshAnim(AnimName, SyncNode, bLoop);
    Duration = LeftWeapMesh.GetAnimLength(AnimName);
    LeftWeapMesh.PlayAnim(AnimName, Duration / ThirdPersonAnimRate, bLoop);
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels)
{
    super.SetMeshLightingChannels(NewLightingChannels);
    if(!bWeapMeshIsPawnMesh)
    {
        LeftWeapMesh.SetLightingChannels(NewLightingChannels);
    }
}

simulated function bool HasIndoorLighting()
{
    return super.HasIndoorLighting() && LeftWeapMesh.LightingChannels.Indoor;
}

simulated function bool HasOutdoorLighting()
{
    return super.HasOutdoorLighting() && LeftWeapMesh.LightingChannels.Outdoor;
}

defaultproperties
{
    begin object name=SkeletalMeshComponent1 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__KFWeaponAttachment.MeshSequenceA'
        bForceRefpose=1
        bUpdateSkelWhenNotRendered=false
        bIgnoreControllersWhenNotRendered=true
        bPerBoneMotionBlur=true
        bOverrideAttachmentOwnerVisibility=true
        ReplacementPrimitive=none
        MaxDrawDistance=4000
        CachedMaxDrawDistance=4000
        bOwnerNoSee=true
        LightingChannels=(bInitialized=true,Outdoor=true)
    object end
    // Reference: SkeletalMeshComponent'Default__KFWeapAttach_DualBase.SkeletalMeshComponent1'
    LeftWeapMesh=SkeletalMeshComponent1
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__KFWeapAttach_DualBase.SkeletalMeshComponent0.MeshSequenceA'
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFWeapAttach_DualBase.SkeletalMeshComponent0'
    WeapMesh=SkeletalMeshComponent0
}