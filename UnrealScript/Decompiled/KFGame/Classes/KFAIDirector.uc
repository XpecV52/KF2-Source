/*******************************************************************************
 * KFAIDirector generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIDirector extends Object within KFGameInfo
    native(AI)
    config(Game);

struct native ActiveAIInfo
{
    var Controller Member;

    structdefaultproperties
    {
        Member=none
    }
};

var array<KFAIController> AIList;
var config bool bAISprintToGrabVictim;
var config bool bShowAINames;
var config bool bDebugAllAI;
var bool bUseGrabAlerts;
var bool bForceFrustration;
var config bool bLoadDebugPackageResourcesAtStart;
var bool bShowVisualStuckZedDebugInfo;
var bool bShowMovePointsDebugInfo;
var bool bShowHighDetailCombatMovementDebugInfo;
var bool bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
var bool bShowLeapDownDebugArtifacts;
var bool bShowDoorNavigationDebugArtifacts;
var bool bShowDestructibleNavigationDebugArtifacts;
var float GrabAlertMaxZedDistance;
var Vector CurrentLocationSortingDoorsFor;
var private Font AiDebugScreenLargeFont;
var config string AiDebugScreenLargeFontName;
var private Texture2D DebugIsSprintingIcon;
var config string DebugIsSprintingIconName;
var private Texture2D DebugIsWalkingIcon;
var config string DebugIsWalkingIconName;
var array<ActiveAIInfo> ActiveZeds;
var delegate<ClosestDoorSort> __ClosestDoorSort__Delegate;

// Export UKFAIDirector::execRebuildAIList(FFrame&, void* const)
native function RebuildAIList();

// Export UKFAIDirector::execLoadAiDebugResources(FFrame&, void* const)
native function LoadAiDebugResources();

function Initialize()
{
    if(bLoadDebugPackageResourcesAtStart)
    {
        LoadAiDebugResources();
    }
    bShowVisualStuckZedDebugInfo = Class'KFAIController'.default.bConfigShowVisualStuckZedDebugInfo;
    bShowMovePointsDebugInfo = Class'KFAIController'.default.bConfigShowMovePointsDebugInfo;
    bShowHighDetailCombatMovementDebugInfo = Class'KFAIController'.default.bConfigShowHighDetailCombatMovementDebugInfo;
    bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState = Class'KFAIController'.default.bConfigShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState;
    bShowLeapDownDebugArtifacts = Class'KFAIController'.default.bConfigShowLeapDownDebugArtifacts;
    bShowDoorNavigationDebugArtifacts = Class'KFAIController'.default.bConfigShowDoorNavigationDebugArtifacts;
    bShowDestructibleNavigationDebugArtifacts = Class'KFAIController'.default.bConfigShowDestructibleNavigationDebugArtifacts;
}

function SetAIDebug(bool bOn)
{
    local int I;

    bDebugAllAI = bOn;
    I = 0;
    J0x20:

    if(I < AIList.Length)
    {
        if(AIList[I].bForceDebugCommand)
        {
            AIList[I].bForceDebugCommand = bOn;
        }
        AIList[I].Pawn.ZeroMovementVariables();
        AIList[I].AbortMovementCommands();
        AIList[I].AbortMovementPlugIns();
        if(!bOn && AIList[I].bHasDebugCommand)
        {
            AIList[I].AbortCommand(none, Class'AICommand_Debug');
            AIList[I].GotoState('Action_Idle', 'Begin');
        }
        if(bOn)
        {
            AIList[I].BeginDebugCommand();
        }
        ++ I;
        goto J0x20;
    }
}

final function Font GetAiDebugScreenLargeFont()
{
    if(AiDebugScreenLargeFont == none)
    {
        LoadAiDebugResources();
    }
    return AiDebugScreenLargeFont;
}

final function Texture2D GetDebugIsSprintingIcon()
{
    if(DebugIsSprintingIcon == none)
    {
        LoadAiDebugResources();
    }
    return DebugIsSprintingIcon;
}

final function Texture2D GetDebugIsWalkingIcon()
{
    if(DebugIsWalkingIcon == none)
    {
        LoadAiDebugResources();
    }
    return DebugIsWalkingIcon;
}

function NotifyNewPossess(KFAIController KFAIC)
{
    if(KFAIC != none)
    {
        KFAIC.AILog_Internal((string(GetFuncName()) $ " registering new Possession by ") $ string(KFAIC), 'AIDirector');
    }
    RegisterAIMember(KFAIC);
    KFAIC.bForceDebugCommand = bDebugAllAI;
}

final function RegisterAIMember(Controller NewMember)
{
    local int Idx;
    local KFAIController KFAIC;

    if(NewMember != none)
    {
        if(ActiveZeds.Find('Member', NewMember != -1)
        {            
        }
        else
        {
            UnRegisterAIMember(NewMember);
            Idx = ActiveZeds.Length;
            ActiveZeds.Length = Idx + 1;
            ActiveZeds[Idx].Member = NewMember;
            KFAIC = KFAIController(NewMember);
            if(KFAIC != none)
            {
                if(KFAIC != none)
                {
                    KFAIC.AILog_Internal(((string(GetFuncName()) $ " Adding ") $ string(KFAIC)) $ " to AIList", 'AIDirector');
                }
                AIList.AddItem(KFAIC;
            }
        }
    }
}

final function UnRegisterAIMember(Controller OldMember)
{
    local KFAIController KFAIC;
    local int Idx;

    if(OldMember != none)
    {
        Idx = ActiveZeds.Find('Member', OldMember;
        if(Idx >= 0)
        {
            KFAIC = KFAIController(OldMember);
            ActiveZeds.Remove(Idx, 1;
            if(KFAIC != none)
            {
                if(KFAIC != none)
                {
                    KFAIC.AILog_Internal(((string(GetFuncName()) $ " Removing ") $ string(KFAIC)) $ " from AIList", 'AIDirector');
                }
                AIList.RemoveItem(KFAIC;
            }
        }
    }
}

function Actor FindEnemyFor(KFAIController RequestingAI, optional bool bSkipCurrentEnemy)
{
    local Pawn P;
    local float DistToPlayer, DistToEnemy;

    bSkipCurrentEnemy = true;
    if(((RequestingAI.Pawn == none) || !RequestingAI.Pawn.IsAliveAndWell()) || RequestingAI.DoorEnemy != none)
    {
        return none;
    }
    if(RequestingAI.MyKFPawn.IsDoingSpecialMove(4))
    {
        return RequestingAI.Enemy;
    }
    if((RequestingAI.Enemy == none) || !RequestingAI.Enemy.IsAliveAndWell())
    {
        return RequestingAI.GetClosestEnemy();
    }
    P = Outer.WorldInfo.PawnList;
    J0x1A1:

    if(P != none)
    {
        if((!RequestingAI.Pawn.IsSameTeam(P) && P.IsAliveAndWell()) && P != RequestingAI.Enemy)
        {
            DistToPlayer = VSize(P.Location - RequestingAI.Pawn.Location);
            DistToEnemy = VSize(RequestingAI.Enemy.Location - RequestingAI.Pawn.Location);
            if(bSkipCurrentEnemy)
            {
                if(RequestingAI.ActorReachable(P))
                {
                    return P;
                }                
            }
            else
            {
                if((((DistToPlayer < DistToEnemy) && FRand() < 0.9) || ((KFPawn(P).IsDoingSpecialMove(28) && DistToPlayer < 1200) && RequestingAI.CanSee(P)) && FRand() < 0.85) || (float(RequestingAI.Pawn.Health) < (0.33 * float(RequestingAI.Pawn.default.Health))) && FRand() < 0.65)
                {
                    return P;
                }
            }
        }
        P = P.NextPawn;
        goto J0x1A1;
    }
    return none;
}

function NotifyPawnGrabbed(KFPawn Victim, KFPawn Attacker)
{
    local KFPawn KFP;

    if(Attacker.MyKFAIC != none)
    {
        Attacker.MyKFAIC.AILog_Internal((((string(GetFuncName()) $ " NotifyPawnGrabbed - victim, ") $ string(Victim)) $ " attacker ") $ string(Attacker), 'AIDirector');
    }
    foreach Outer.WorldInfo.AllPawns(Class'KFPawn', KFP)
    {
        if(((((((Attacker != none) && KFP == Attacker) || KFP.IsSameTeam(Victim)) || KFP.MyKFAIC == none) || !KFP.IsAliveAndWell()) || Victim == none) || !Victim.IsAliveAndWell())
        {
            continue;            
        }
        if(VSizeSq(KFP.Location - Victim.Location) < (GrabAlertMaxZedDistance * GrabAlertMaxZedDistance))
        {
            if((KFP.MyKFAIC.Enemy == none) || (KFP.MyKFAIC.Enemy != none) && KFP.MyKFAIC.Enemy != Victim)
            {
                if((KFP.MyKFAIC.Enemy == none) || FRand() < 0.85)
                {
                    KFP.MyKFAIC.SetEnemy(Victim);
                }
            }
        }
        if((bAISprintToGrabVictim && KFP.MyKFAIC.Enemy == Victim) && FRand() < 0.5)
        {
            KFP.SetSprinting(true);
        }        
    }    
}

function array<KFDoorActor> FindDoorsWithInRange(float RangeToBeLessThan, Vector Loc2TestFrom)
{
    local KFDoorActor curDoorActor;
    local KFGameReplicationInfo KFGRI;
    local array<KFDoorActor> doorsInRange;
    local int doorIndex;
    local Vector displacement2Door;
    local float distance2Door;

    KFGRI = KFGameReplicationInfo(Outer.WorldInfo.GRI);
    doorIndex = 0;
    J0x51:

    if(doorIndex < KFGRI.DoorList.Length)
    {
        curDoorActor = KFGRI.DoorList[doorIndex];
        displacement2Door = curDoorActor.Location - Loc2TestFrom;
        distance2Door = VSize(displacement2Door);
        if(distance2Door <= RangeToBeLessThan)
        {
            doorsInRange.AddItem(curDoorActor;
        }
        ++ doorIndex;
        goto J0x51;
    }
    return doorsInRange;
}

delegate int ClosestDoorSort(KFDoorActor A, KFDoorActor B)
{
    local float distSqToDoorA, distSqToDoorB;

    distSqToDoorA = VSizeSq(CurrentLocationSortingDoorsFor - A.Location);
    distSqToDoorB = VSizeSq(CurrentLocationSortingDoorsFor - B.Location);
    return ((distSqToDoorA > distSqToDoorB) ? -1 : 0);
}

function array<KFDoorActor> FindClosedDoorsWithInRange(float RangeToBeLessThan, Vector Loc2TestFrom)
{
    local KFDoorActor curDoorActor;
    local array<KFDoorActor> doorsInRange, closedDoorsInRange;
    local int doorIndex;

    doorsInRange = FindDoorsWithInRange(RangeToBeLessThan, Loc2TestFrom);
    doorIndex = 0;
    J0x31:

    if(doorIndex < doorsInRange.Length)
    {
        curDoorActor = doorsInRange[doorIndex];
        if(!curDoorActor.IsCompletelyOpen())
        {
            closedDoorsInRange.AddItem(curDoorActor;
        }
        ++ doorIndex;
        goto J0x31;
    }
    CurrentLocationSortingDoorsFor = Loc2TestFrom;
    closedDoorsInRange.Sort(ClosestDoorSort;
    return closedDoorsInRange;
}

defaultproperties
{
    GrabAlertMaxZedDistance=2700
    AiDebugScreenLargeFontName="AI_Debug_Helpers.Font_Large"
    DebugIsSprintingIconName="AI_Debug_Helpers.DebugIsSprintingIcon"
    DebugIsWalkingIconName="AI_Debug_Helpers.DebugIsWalkingIcon"
}