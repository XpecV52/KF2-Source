/*******************************************************************************
 * KFWeap_MeleeBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_MeleeBase extends KFWeapon
    abstract
    native
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const BLOCK_FIREMODE = 1;
const HEAVY_ATK_FIREMODE = 5;
const MeleeAttackAnim_F = 'Atk_F';
const MeleeAttackAnim_B = 'Atk_B';
const MeleeAttackAnim_L = 'Atk_L';
const MeleeAttackAnim_R = 'Atk_R';
const MeleeHeavyAttackAnim_F = 'Atk_H_F';
const MeleeHeavyAttackAnim_B = 'Atk_H_B';
const MeleeHeavyAttackAnim_L = 'Atk_H_L';
const MeleeHeavyAttackAnim_R = 'Atk_H_R';
const MeleeComboChainAnim_F = 'Combo_F';
const MeleeComboChainAnim_FL = 'Combo_FL';
const MeleeComboChainAnim_FR = 'Combo_FR';
const MeleeComboChainAnim_B = 'Combo_B';
const MeleeComboChainAnim_BL = 'Combo_BL';
const MeleeComboChainAnim_BR = 'Combo_BR';
const MeleeComboChainAnim_L = 'Combo_L';
const MeleeComboChainAnim_R = 'Combo_R';
const MeleeDrawStrikeAnim = 'Atk_Draw';
const MeleeBlockStartAnim = 'Brace_in';
const MeleeBlockLoopAnim = 'Brace_loop';
const MeleeBlockEndAnim = 'Brace_out';
const CleanBloodyAnim = 'Clean_Blood';
const CleanNonBloodyAnim = 'Clean_NoBlood';
const MeleeSustainedLoopAnim = 'Atk_F_Loop';
const MeleeSustainedStartAnim = 'Atk_F_In';
const MeleeSUstainedEndAnim = 'Atk_F_Out';

struct native BlockEffectInfo
{
    var class<DamageType> dmgType;
    var AkEvent BlockSound;
    var AkEvent ParrySound;
    var ParticleSystem BlockParticleSys;
    var ParticleSystem ParryParticleSys;

    structdefaultproperties
    {
        dmgType=none
        BlockSound=none
        ParrySound=none
        BlockParticleSys=none
        ParryParticleSys=none
    }
};

var bool bIsBloody;
var bool StartFireDisabled;
var bool bMoveAtWalkingSpeed;
var byte MaxChainAtkCount;
/** Hit reaction strength to bypass pawn's ParryStumbleResist */
var() byte ParryStrength;
/**  
 *Estimated attack rate for this weapon, taking chaining, etc. into account.
 *  Basically, just eyeball the animations and take an average.
 */
var() byte EstimatedFireRate;
var float MinMeleeSustainedTime;
/** Minimum amount of time to wait before dealing damage in the  MeleeSustained state */
var() float MeleeSustainedWarmupTime;
var private const float ReloadCancelTimeLimit;
var array<BlockEffectInfo> BlockTypes;
/** Damage while blocking will be mitigated by this percentage */
var() float BlockDamageMitigation;
/** Parry damage will be mitigated by this percentage */
var() float ParryDamageMitigationPercent;
/** Time between block hit reaction anims */
var() protected float BlockHitAnimCooldownTime;
var protected transient float LastBlockHitAnimTime;
var array<name> MeleeAttackSettleAnims;
var array<name> MeleeBlockHitAnims;
var ParticleSystem DistortTrailParticle;
var ParticleSystem WhiteTrailParticle;
var ParticleSystem BlueTrailParticle;
var ParticleSystem RedTrailParticle;
var AkBaseSoundObject BlockSound;
var AkBaseSoundObject ParrySound;
var ParticleSystem BlockParticleSystem;
var ParticleSystem ParryParticleSystem;
var name BlockEffectsSocketName;

simulated function bool ShouldOwnerWalk()
{
    return bMoveAtWalkingSpeed;
}

simulated function SetSlowMovement(bool bEnabled)
{
    if(Instigator.IsLocallyControlled())
    {
        bMoveAtWalkingSpeed = bEnabled;
        if(Role < ROLE_Authority)
        {
            ServerSetSlowMovement(bEnabled);
        }
    }
}

reliable server function ServerSetSlowMovement(bool bEnabled)
{
    bMoveAtWalkingSpeed = bEnabled;
}

simulated function StartFire(byte FireModeNum)
{
    if(StartFireDisabled)
    {
        return;
    }
    if(((CurrentFireMode == 0) || CurrentFireMode == 1) || CurrentFireMode == 3)
    {
        if(FireModeNum == 2)
        {
            if(IsTimerActive('Timer_FireCancel'))
            {
                return;                
            }
            else
            {
                SetTimer(ReloadCancelTimeLimit, false, 'Timer_FireCancel');
            }
        }
    }
    if((FireModeNum == 0) || FireModeNum == 5)
    {
        StartMeleeFire(FireModeNum, MeleeAttackHelper.ChooseAttackDir(), 0);
        return;
    }
    if((FireModeNum == 3) && WeaponFireTypes[FireModeNum] == 3)
    {
        StartMeleeFire(FireModeNum, MeleeAttackHelper.ChooseAttackDir(), 0);
        return;
    }
    super.StartFire(FireModeNum);
}

simulated function Timer_FireCancel();

simulated function StartMeleeFire(byte FireModeNum, KFPawn.EPawnOctant AttackDir, KFMeleeHelperWeapon.EMeleeAttackType AtkType)
{
    MeleeAttackHelper.InitAttackSequence(AttackDir, AtkType);
    if((Instigator == none) || !Instigator.bNoWeaponFiring)
    {
        if(Role < ROLE_Authority)
        {
            ServerStartMeleeFire(FireModeNum, AttackDir, AtkType);
        }
        BeginFire(FireModeNum);
    }
}

private reliable server final function ServerStartMeleeFire(byte FireModeNum, KFPawn.EPawnOctant AttackDir, KFMeleeHelperWeapon.EMeleeAttackType AtkType)
{
    MeleeAttackHelper.InitAttackSequence(AttackDir, AtkType);
    ServerStartFire(FireModeNum);
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    StartFire(1);
}

simulated function SetIronSights(bool bNewIronSights)
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    if(bNewIronSights)
    {
        StartFire(5);        
    }
    else
    {
        StopFire(5);
    }
}

simulated function SendToFiringState(byte FireModeNum)
{
    if((FireModeNum == 3) && WeaponFireTypes[FireModeNum] == 3)
    {
        super.SendToFiringState(0);
        ClearPendingFire(3);
    }
    super.SendToFiringState(FireModeNum);
}

event RecieveClientImpact(byte FiringMode, const out ImpactInfo Impact, optional out float PenetrationValue, optional int ImpactNum)
{
    MeleeAttackHelper.ProcessMeleeHit(FiringMode, Impact);
}

simulated function int GetMeleeDamage(byte FireModeNum, optional Vector RayDir)
{
    local int Damage;
    local KFPerk InstigatorPerk;

    Damage = GetModifiedDamage(FireModeNum, RayDir);
    if(!IsZero(RayDir))
    {
        Damage = Round(float(Damage) * FMin(VSize(RayDir), 1));
    }
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        if(IsHeavyAttack(FireModeNum))
        {
            InstigatorPerk.ModifyHardAttackDamage(Damage);            
        }
        else
        {
            if(IsLightAttack(FireModeNum))
            {
                InstigatorPerk.ModifyLightAttackDamage(Damage);
            }
        }
    }
    return Damage;
}

simulated function AddBlood(float MinAmount, float MaxAmount)
{
    super.AddBlood(MinAmount, MaxAmount);
    if(!bIsBloody)
    {
        bIsBloody = true;
        ServerSetBloody(true);
    }
}

private reliable server final function ServerSetBloody(bool bNewIsBloody)
{
    bIsBloody = bNewIsBloody;
}

simulated function ANIMNOTIFY_CleanBlood()
{
    local int I;

    bIsBloody = false;
    if((WorldInfo.NetMode != NM_DedicatedServer) && WeaponMICs.Length > 0)
    {
        BloodParamValue = 0;
        I = 0;
        J0x61:

        if(I < WeaponMICs.Length)
        {
            if(WeaponMICs[I] != none)
            {
                WeaponMICs[I].SetScalarParameterValue('Scalar_Blood_Contrast', BloodParamValue);
            }
            ++ I;
            goto J0x61;
        }
    }
}

simulated function PlayWeaponAnimation(name Sequence, float fDesiredDuration, optional bool bLoop, optional SkeletalMeshComponent SkelMesh)
{
    super.PlayWeaponAnimation(Sequence, fDesiredDuration, bLoop, SkelMesh);
    bFollowAnimSeqCamera = default.bFollowAnimSeqCamera;
}

simulated function PlayMeleeAnimation(name AnimName, out float out_Rate, float BlendTime)
{
    super.PlayMeleeAnimation(AnimName, out_Rate, BlendTime);
    bFollowAnimSeqCamera = true;
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayMeleeAttackDialog(KFPawn(Instigator), IsHeavyAttack(CurrentFireMode));
    }
}

simulated function UpkeepComplete();

simulated function bool CanReload(optional byte FireModeNum)
{
    if(FiringStatesArray[2] == 'WeaponUpkeep')
    {
        return true;
    }
    return super.CanReload(FireModeNum);
}

simulated function bool CanOverrideMagReload(byte FireModeNum)
{
    return super.CanOverrideMagReload(FireModeNum) || FireModeNum == 4;
}

simulated function bool IsLightAttack(byte FireMode);

simulated function PlayMeleeSettleAnim()
{
    local int AnimIdx;

    if(MeleeAttackSettleAnims.Length > 0)
    {
        AnimIdx = Rand(MeleeAttackSettleAnims.Length);
        PlayAnimation(MeleeAttackSettleAnims[AnimIdx], 0, false, 0.1);
    }
}

simulated function bool IsHeavyAttack(byte FireMode);

function SustainedMinFireTimer();

function SustainedWarmupEndTimer();

simulated function BlockLoopTimer();

simulated function ParryCheckTimer();

unreliable client simulated function ClientPlayBlockEffects(optional byte BlockTypeIndex)
{
    local AkBaseSoundObject Sound;
    local ParticleSystem PSTemplate;

    BlockTypeIndex = 255;
    GetBlockEffects(BlockTypeIndex, Sound, PSTemplate);
    PlayLocalBlockEffects(Sound, PSTemplate);
}

reliable client simulated function ClientPlayParryEffects(optional byte BlockTypeIndex)
{
    local AkBaseSoundObject Sound;
    local ParticleSystem PSTemplate;
    local KFPerk InstigatorPerk;

    BlockTypeIndex = 255;
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.SetSuccessfullParry();
    }
    GetParryEffects(BlockTypeIndex, Sound, PSTemplate);
    PlayLocalBlockEffects(Sound, PSTemplate);
}

simulated function NotifyAttackParried();

simulated function NotifyAttackBlocked();

simulated function float PlayBlockStart()
{
    local float AnimDuration;

    if(Instigator.IsLocallyControlled())
    {
        PlayAnimation('Brace_in');
    }
    AnimDuration = MySkelMesh.GetAnimLength('Brace_in');
    if(AnimDuration > 0)
    {
        SetTimer(AnimDuration, false, 'BlockLoopTimer');        
    }
    else
    {
        BlockLoopTimer();
    }
    return AnimDuration;
}

simulated function PlayLocalBlockEffects(AkBaseSoundObject Sound, ParticleSystem PSTemplate)
{
    local Vector Loc;
    local Rotator Rot;
    local editinline ParticleSystemComponent PSC;

    if(Sound != none)
    {
        PlaySoundBase(Sound, true);
    }
    if(PSTemplate != none)
    {
        if(MySkelMesh.GetSocketWorldLocationAndRotation(BlockEffectsSocketName, Loc, Rot))
        {
            PSC = WorldInfo.MyEmitterPool.SpawnEmitter(PSTemplate, Loc, Rot);
            PSC.SetDepthPriorityGroup(2);            
        }
        else
        {
            LogInternal((string(self) @ string(GetFuncName())) @ "missing BlockEffects Socket!");
        }
    }
}

function bool CanBlockDamageType(class<DamageType> DamageType, optional out byte out_Idx)
{
    local int Idx;

    Idx = 0;
    J0x0C:

    if(Idx < BlockTypes.Length)
    {
        if(ClassIsChildOf(DamageType, BlockTypes[Idx].dmgType))
        {
            out_Idx = byte(Idx);
            return true;
        }
        ++ Idx;
        goto J0x0C;
    }
    out_Idx = 255;
    return false;
}

simulated function GetBlockEffects(byte BlockIndex, out AkBaseSoundObject outSound, out ParticleSystem outParticleSys)
{
    outSound = BlockSound;
    outParticleSys = BlockParticleSystem;
    if(BlockIndex != 255)
    {
        if(BlockTypes[BlockIndex].BlockSound != none)
        {
            outSound = BlockTypes[BlockIndex].BlockSound;
        }
        if(BlockTypes[BlockIndex].BlockParticleSys != none)
        {
            outParticleSys = BlockTypes[BlockIndex].BlockParticleSys;
        }
    }
}

simulated function GetParryEffects(byte BlockIndex, out AkBaseSoundObject outSound, out ParticleSystem outParticleSys)
{
    outSound = ParrySound;
    outParticleSys = ParryParticleSystem;
    if(BlockIndex != 255)
    {
        if(BlockTypes[BlockIndex].ParrySound != none)
        {
            outSound = BlockTypes[BlockIndex].ParrySound;
        }
        if(BlockTypes[BlockIndex].ParryParticleSys != none)
        {
            outParticleSys = BlockTypes[BlockIndex].ParryParticleSys;
        }
    }
}

simulated function BlockCooldownTimer();

simulated function ANIMNOTIFY_DrawAtk();

simulated function AttemptDrawStrike();

static simulated event SetTraderWeaponStats(out array<STraderItemWeaponStats> WeaponStats)
{
    super.SetTraderWeaponStats(WeaponStats);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 4;
    WeaponStats[WeaponStats.Length - 1].StatValue = GetUpgradedBlockDamageMitigation(0);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 5;
    WeaponStats[WeaponStats.Length - 1].StatValue = GetUpgradedParryDamageMitigation(0);
}

static simulated function float CalculateTraderWeaponStatDamage()
{
    local float CalculatedDamage;
    local class<KFDamageType> DamageType;

    CalculatedDamage = default.InstantHitDamage[5];
    DamageType = class<KFDamageType>(default.InstantHitDamageTypes[5]);
    if((DamageType != none) && DamageType.default.DoT_Type != 0)
    {
        CalculatedDamage += ((DamageType.default.DoT_Duration / DamageType.default.DoT_Interval) * (CalculatedDamage * DamageType.default.DoT_DamageScale));
    }
    return CalculatedDamage;
}

static simulated function float CalculateTraderWeaponStatFireRate()
{
    return float(default.EstimatedFireRate);
}

static simulated event KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter()
{
    return 8;
}

static simulated function float GetUpgradedBlockDamageMitigation(int UpgradeIndex)
{
    return GetUpgradedStatValue(default.BlockDamageMitigation, 3, UpgradeIndex);
}

static simulated function float GetUpgradedParryDamageMitigation(int UpgradeIndex)
{
    return GetUpgradedStatValue(default.ParryDamageMitigationPercent, 4, UpgradeIndex);
}

simulated state WeaponUpkeep
{
    simulated function byte GetWeaponStateId()
    {
        return 25;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local name AnimName;
        local float Duration;

        AnimName = ((bIsBloody) ? 'Clean_Blood' : 'Clean_NoBlood');
        Duration = MySkelMesh.GetAnimInterruptTime(AnimName);
        if(Duration > 0)
        {
            if(Instigator.IsFirstPerson())
            {
                PlayAnimation(AnimName);
            }
            SetTimer(Duration, false, 'UpkeepComplete');            
        }
        else
        {
            WarnInternal("Duration is zero!!!" @ string(AnimName));
            SetTimer(0.001, false, 'UpkeepComplete');
        }
        NotifyBeginState();
    }

    simulated function BeginFire(byte FireModeNum)
    {
        global.BeginFire(FireModeNum);
        if(FireModeNum != 2)
        {
            if(PendingFire(FireModeNum) && HasAmmo(FireModeNum))
            {
                ClearPendingFire(2);
                GotoState('Active');
            }
        }
    }

    simulated event EndState(name NextStateName)
    {
        NotifyEndState();
    }

    simulated function UpkeepComplete()
    {
        GotoState('Active');
    }
    stop;    
}

simulated state MeleeChainAttacking extends MeleeAttackBasic
{
    simulated function BeginState(name PrevStateName)
    {
        super.BeginState(PrevStateName);
    }

    simulated function byte GetWeaponStateId()
    {
        switch(MeleeAttackHelper.CurrentAttackDir)
        {
            case 0:
                return 18;
            case 4:
                return 18;
            case 5:
                return 18;
            case 1:
                return 19;
            case 6:
                return 19;
            case 7:
                return 19;
            case 2:
                return 16;
            case 3:
                return 17;
            default:
                return 14;
                break;
        }
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        PlayMeleeSettleAnim();
        if(PendingFire(0) && PendingFire(5))
        {
            ClearPendingFire(0);
        }
    }

    simulated function bool ShouldContinueMelee(optional int ChainCount)
    {
        if(PendingFire(5))
        {
            return false;
        }
        if(!ShouldRefire())
        {
            return false;
        }
        if(!MeleeAttackHelper.bHasChainAttacks)
        {
            return false;
        }
        return (ChainCount + 1) < MaxChainAtkCount;
    }

    simulated function name GetMeleeAnimName(KFPawn.EPawnOctant AtkDir, KFMeleeHelperWeapon.EMeleeAttackType AtkType)
    {
        UpdateWeaponAttachmentAnimRate(GetThirdPersonAnimRate());
        KFPawn(Instigator).WeaponStateChanged(GetWeaponStateId());
        if(AtkType == 1)
        {
            switch(AtkDir)
            {
                case 0:
                    return 'Combo_F';
                case 4:
                    return 'Combo_FL';
                case 5:
                    return 'Combo_FR';
                case 1:
                    return ((FRand() < 0.5) ? 'Combo_BL' : 'Combo_BR');
                case 6:
                    return 'Combo_BL';
                case 7:
                    return 'Combo_BR';
                case 2:
                    return 'Combo_L';
                case 3:
                    return 'Combo_R';
                default:
                    break;
                }
        }
        else
        {
            switch(AtkDir)
            {
                case 0:
                    return 'Atk_F';
                case 4:
                    return 'Atk_F';
                case 5:
                    return 'Atk_F';
                case 1:
                    return 'Atk_B';
                case 6:
                    return 'Atk_B';
                case 7:
                    return 'Atk_B';
                case 2:
                    return 'Atk_L';
                case 3:
                    return 'Atk_R';
                default:
                    break;
            }
        }
    }

    simulated function bool IsLightAttack(byte FireMode)
    {
        return true;
    }

    simulated function float GetThirdPersonAnimRate()
    {
        local float ScaledRate;

        ScaledRate = EvalInterpCurveFloat(MeleeAttackHelper.FatigueCurve, float(MeleeAttackHelper.NumChainedAttacks));
        ModifyMeleeAttackSpeed(ScaledRate, CurrentFireMode);
        return 1 / ScaledRate;
    }
    stop;    
}

simulated state MeleeHeavyAttacking extends MeleeAttackBasic
{
    simulated function byte GetWeaponStateId()
    {
        switch(MeleeAttackHelper.CurrentAttackDir)
        {
            case 0:
                return 22;
            case 4:
                return 22;
            case 5:
                return 22;
            case 1:
                return 23;
            case 6:
                return 23;
            case 7:
                return 23;
            case 2:
                return 20;
            case 3:
                return 21;
            default:
                return 0;
                break;
        }
    }

    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(Instigator.IsLocallyControlled())
        {
            KFPlayerController(Instigator.Controller).PauseMoveInput(0.1);
        }
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        PlayMeleeSettleAnim();
    }

    simulated function name GetMeleeAnimName(KFPawn.EPawnOctant AtkDir, KFMeleeHelperWeapon.EMeleeAttackType AtkType)
    {
        if(AtkType == 2)
        {
            return 'Atk_Draw';
        }
        switch(AtkDir)
        {
            case 0:
                return 'Atk_H_F';
            case 4:
                return 'Atk_H_F';
            case 5:
                return 'Atk_H_F';
            case 1:
                return 'Atk_H_B';
            case 6:
                return 'Atk_H_B';
            case 7:
                return 'Atk_H_B';
            case 2:
                return 'Atk_H_L';
            case 3:
                return 'Atk_H_R';
            default:
                break;
        }
    }

    simulated function bool IsHeavyAttack(byte FireMode)
    {
        return true;
    }
    stop;    
}

simulated state MeleeSustained extends WeaponFiring
{
    ignores AllowSprinting, AllowIronSights;

    simulated function bool IsMeleeing()
    {
        return true;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;

        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        if(MeleeSustainedWarmupTime > 0)
        {
            SetTimer(MeleeSustainedWarmupTime, false, 'SustainedWarmupEndTimer');            
        }
        else
        {
            SustainedWarmupEndTimer();
        }
        StartLoopingFireEffects(CurrentFireMode, true);
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        NotifyEndState();
    }

    simulated function bool StillFiring(byte FireMode)
    {
        if((global.StillFiring(FireMode)) || IsTimerActive('SustainedMinFireTimer'))
        {
            return true;
        }
        return false;
    }

    simulated function SustainedWarmupEndTimer()
    {
        FireAmmunition();
        TimeWeaponFiring(CurrentFireMode);
        if(MinMeleeSustainedTime > 0)
        {
            SetTimer(MinMeleeSustainedTime, false, 'SustainedMinFireTimer');
        }
    }

    simulated function FireAmmunition()
    {
        HandleWeaponShotTaken(CurrentFireMode);
        MeleeAttackHelper.bHitEnemyThisAttack = false;
        MeleeAttackHelper.MeleeAttackImpact();
        ConsumeAmmo(CurrentFireMode);
    }

    simulated function name GetLoopingFireAnim(byte FireModeNum)
    {
        return 'Atk_F_Loop';
    }

    simulated function name GetLoopStartFireAnim(byte FireModeNum)
    {
        return 'Atk_F_In';
    }

    simulated function name GetLoopEndFireAnim(byte FireModeNum)
    {
        return 'Atk_F_Out';
    }

    simulated function byte GetWeaponStateId()
    {
        return 15;
    }
    stop;    
}

simulated state MeleeBlocking
{
    ignores ForceReload, ShouldAutoReload;

    simulated function byte GetWeaponStateId()
    {
        return 24;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local float ParryDuration;

        ParryDuration = PlayBlockStart();
        if(ParryDuration > 0)
        {
            SetTimer(ParryDuration, false, 'ParryCheckTimer');
        }
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        if(Instigator.IsLocallyControlled())
        {
            PlayAnimation('Brace_out');
        }
        NotifyEndState();
    }

    simulated function EndFire(byte FireModeNum)
    {
        global.EndFire(FireModeNum);
        if(!StillFiring(CurrentFireMode) && !IsTimerActive('ParryCheckTimer'))
        {
            GotoState('BlockingCooldown');
        }
    }

    simulated function ParryCheckTimer()
    {
        if(!StillFiring(CurrentFireMode))
        {
            GotoState('BlockingCooldown');
        }
    }

    function bool IsGrappleBlocked(Pawn InstigatedBy)
    {
        local float FacingDot;
        local Vector Dir2d;

        Dir2d = Normal2D(InstigatedBy.Location - Instigator.Location);
        FacingDot = vector(Instigator.Rotation) Dot Dir2d;
        if(FacingDot > 0.087)
        {
            if(IsTimerActive('ParryCheckTimer'))
            {
                KFPawn(InstigatedBy).NotifyAttackParried(Instigator, 255);
                ClientPlayParryEffects();
                NotifyAttackParried();                
            }
            else
            {
                ClientPlayBlockEffects();
                NotifyAttackBlocked();
            }
            return true;
        }
        return false;
    }

    function AdjustDamage(out int InDamage, class<DamageType> DamageType, Actor DamageCauser)
    {
        local float FacingDot;
        local Vector Dir2d;
        local KFPerk InstigatorPerk;
        local byte BlockTypeIndex;

        if(Instigator.IsSameTeam(DamageCauser.Instigator))
        {
            return;
        }
        Dir2d = Normal2D(DamageCauser.Location - Instigator.Location);
        FacingDot = vector(Instigator.Rotation) Dot Dir2d;
        if((FacingDot > 0.087) && CanBlockDamageType(DamageType, BlockTypeIndex))
        {
            InstigatorPerk = GetPerk();
            if(IsTimerActive('ParryCheckTimer'))
            {
                InDamage *= (GetUpgradedParryDamageMitigation(CurrentWeaponUpgradeIndex));
                if(KFPawn(DamageCauser) != none)
                {
                    KFPawn(DamageCauser).NotifyAttackParried(Instigator, ParryStrength);
                }
                ClientPlayParryEffects(BlockTypeIndex);
                NotifyAttackParried();
                if(InstigatorPerk != none)
                {
                    InstigatorPerk.SetSuccessfullParry();
                }                
            }
            else
            {
                InDamage *= (GetUpgradedBlockDamageMitigation(CurrentWeaponUpgradeIndex));
                ClientPlayBlockEffects(BlockTypeIndex);
                NotifyAttackBlocked();
                if(InstigatorPerk != none)
                {
                    InstigatorPerk.SetSuccessfullBlock();
                }
            }
        }
    }

    simulated function BlockLoopTimer()
    {
        if(Instigator.IsLocallyControlled())
        {
            PlayAnimation('Brace_loop',, true);
        }
    }

    unreliable client simulated function ClientPlayBlockEffects(optional byte BlockTypeIndex)
    {
        local int AnimIdx;
        local float Duration;
        local KFPerk InstigatorPerk;

        BlockTypeIndex = 255;
        global.ClientPlayBlockEffects(BlockTypeIndex);
        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            InstigatorPerk.SetSuccessfullBlock();
        }
        if(((MeleeBlockHitAnims.Length > 0) && (WorldInfo.TimeSeconds - LastBlockHitAnimTime) > BlockHitAnimCooldownTime) && !IsTimerActive('ParryCheckTimer'))
        {
            AnimIdx = Rand(MeleeBlockHitAnims.Length);
            Duration = MySkelMesh.GetAnimLength(MeleeBlockHitAnims[AnimIdx]);
            if(Duration > float(0))
            {
                LastBlockHitAnimTime = WorldInfo.TimeSeconds;
                PlayAnimation(MeleeBlockHitAnims[AnimIdx]);
                SetTimer(Duration, false, 'BlockLoopTimer');
            }
        }
    }
    stop;    
}

simulated state BlockingCooldown extends Active
{
    ignores AllowSprinting;

    simulated function BeginState(name PreviousStateName)
    {
        SetTimer(0.5, false, 'BlockCooldownTimer');
        super.BeginState(PreviousStateName);
    }

    simulated function bool HasAmmo(byte FireModeNum, optional int Amount)
    {
        if(FireModeNum == 1)
        {
            return false;
        }
        return global.HasAmmo(FireModeNum, Amount);
    }

    simulated function bool ShouldAutoReload(byte FireModeNum)
    {
        if(FireModeNum == 1)
        {
            return false;
        }
        return global.ShouldAutoReload(FireModeNum);
    }

    simulated function BlockCooldownTimer()
    {
        GotoState('Active');
    }
    stop;    
}

simulated state WeaponEquipping
{
    simulated function ANIMNOTIFY_DrawAtk()
    {
        SetTimer(0.001, false, 'AttemptDrawStrike');
    }

    simulated function AttemptDrawStrike()
    {
        if(PendingFire(0) || PendingFire(5))
        {
            MeleeAttackHelper.InitAttackSequence(3, 2);
            SendToFiringState(5);
        }
    }
    stop;    
}

defaultproperties
{
    MaxChainAtkCount=3
    ParryStrength=4
    EstimatedFireRate=100
    MinMeleeSustainedTime=0.5
    MeleeSustainedWarmupTime=0.25
    ReloadCancelTimeLimit=0.5
    BlockTypes(0)=(dmgType=Class'KFDT_Bludgeon',BlockSound=none,ParrySound=none,BlockParticleSys=none,ParryParticleSys=none)
    BlockTypes(1)=(dmgType=Class'KFDT_Slashing',BlockSound=none,ParrySound=none,BlockParticleSys=none,ParryParticleSys=none)
    BlockDamageMitigation=0.5
    ParryDamageMitigationPercent=0.2
    BlockHitAnimCooldownTime=0.5
    MeleeAttackSettleAnims(0)=Settle_V1
    MeleeBlockHitAnims(0)=Block_Hit_V1
    MeleeBlockHitAnims(1)=Block_Hit_V2
    MeleeBlockHitAnims(2)=Block_Hit_V3
    DistortTrailParticle=ParticleSystem'FX_Gameplay_EMIT_THREE.Trails.FX_Trail_Distort_R_01'
    WhiteTrailParticle=ParticleSystem'FX_Gameplay_EMIT_THREE.Trails.FX_Trail_White_R_01'
    BlueTrailParticle=ParticleSystem'FX_Gameplay_EMIT_THREE.Trails.FX_Trail_Blue_R_01'
    RedTrailParticle=ParticleSystem'FX_Gameplay_EMIT_THREE.Trails.FX_Trail_Red_R_01'
    BlockParticleSystem=ParticleSystem'FX_Impacts_EMIT.FX_Block_melee_01'
    ParryParticleSystem=ParticleSystem'FX_Impacts_EMIT.FX_Parry_melee_01'
    BlockEffectsSocketName=BlockEffect
    bTargetAdhesionEnabled=false
    FireModeIconPaths(0)=Texture2D'ui_firemodes_tex.UI_FireModeSelect_Melee'
    FireModeIconPaths(1)=none
    FireModeIconPaths(2)=none
    FireModeIconPaths(3)=none
    FireModeIconPaths(4)=none
    FireModeIconPaths(5)=Texture2D'ui_firemodes_tex.UI_FireModeSelect_Melee'
    InventoryGroup=EInventoryGroup.IG_Melee
    AmmoCost(0)=0
    AmmoCost(1)=0
    AmmoCost(2)=0
    AmmoCost(3)=0
    AmmoCost(4)=0
    AmmoCost(5)=0
    begin object name=MeleeHelper class=KFMeleeHelperWeapon
        bUseDirectionalMelee=true
        bHasChainAttacks=true
        MaxHitRange=150
    object end
    // Reference: KFMeleeHelperWeapon'Default__KFWeap_MeleeBase.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    UpgradeFireModes[1]=0
    UpgradeFireModes[5]=1
    UpgradeFireModes[6]=1
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitMomentum=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    bMeleeWeapon=true
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        MinTickTimeStep=0.025
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_MeleeBase.FirstPersonMesh'
    Mesh=FirstPersonMesh
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_MeleeBase.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_MeleeBase.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}