/*******************************************************************************
 * RCamDecalManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class RCamDecalManager extends DecalManager
    config(Game)
    hidecategories(Navigation);

var KFPlayerController KFPC;
var KFPlayerController PC;
var CamHUD overlay;
var KFHUDBase other_Hud;
var Vector tv;
var Rotator TR;
var bool bdotick;
var bool bserverdemo;
var LocalPlayer LP;
var PlayerController lpc;
var KFDemoRecSpectator drs;
var Rotator r1;
var Rotator r2;
var Rotator r3;
var Rotator r4;
var Rotator relrot;
var Vector relpos1;
var Vector relpos2;

function PostBeginPlay()
{
    super(Actor).PostBeginPlay();
}

event Tick(float DeltaTime)
{
    if(PC == none)
    {
        findOrCreatePlayerControllerAndDemorecSpectator();
        if(PC == none)
        {
            return;
        }
        if((((overlay == none) && (findCamHUD()) == none) && PC.Owner == none) && PC.WorldInfo.IsPlayingDemo())
        {
            if(PC.PlayerCamera != none)
            {
                PC.PlayerCamera.bLockedFOV = false;
            }
            overlay = new (PC) Class'CamHUD';
            PC.Interactions.Insert(0, 1;
            PC.Interactions[0] = overlay;
            overlay.PC = PC;
            overlay.drs = drs;
            overlay.bIsPaused = false;
            overlay.bDrawdemorec = false;
            overlay.bViewingdemorec = true;
            if(overlay.PauseCamMouseSensitivity == float(0))
            {
                overlay.PauseCamMouseSensitivity = 30;
            }
            if(overlay.speccamspeed == float(0))
            {
                if(!bserverdemo)
                {
                    overlay.speccamspeed = 7;                    
                }
                else
                {
                    overlay.speccamspeed = 3;
                }
            }
            overlay.bTargetnone = false;
            overlay.dista = 0;
            overlay.TimeCount = 0;
            overlay.followdist = 60;
            overlay.myPawnVelocity = vect(5, 5, 5);
            overlay.bserverdemo = bserverdemo;
            foreach AllActors(Class'KFHUDBase', other_Hud)
            {
                overlay.H = other_Hud;
                break;                
            }            
        }        
    }
    else
    {
        if((overlay != none) && overlay.bact)
        {
            if(overlay != none)
            {
                if(overlay.bw)
                {
                    if(overlay.bFollowTarget && overlay.bfollowtarget_lock_rotation)
                    {
                        if(overlay.specfollowdistance >= float(30))
                        {
                            overlay.specfollowdistance -= (overlay.speccamspeed / float(2));
                        }                        
                    }
                    else
                    {
                        tv = drs.Location;
                        TR = drs.Rotation;
                        tv = tv + (vector(TR) * overlay.speccamspeed);
                        drs.SetLocation(tv);
                    }
                }
                if(overlay.bs)
                {
                    if(overlay.bFollowTarget && overlay.bfollowtarget_lock_rotation)
                    {
                        overlay.specfollowdistance += (overlay.speccamspeed / float(2));                        
                    }
                    else
                    {
                        tv = drs.Location;
                        TR = drs.Rotation;
                        tv = tv - (vector(TR) * overlay.speccamspeed);
                        drs.SetLocation(tv);
                    }
                }
                if(overlay.ba)
                {
                    tv = drs.Location;
                    TR = drs.Rotation;
                    TR.Yaw = TR.Yaw + 16384;
                    TR.Pitch = 0;
                    tv = tv - (vector(TR) * overlay.speccamspeed);
                    drs.SetLocation(tv);
                }
                if(overlay.bd)
                {
                    tv = drs.Location;
                    TR = drs.Rotation;
                    TR.Yaw = TR.Yaw + 16384;
                    TR.Pitch = 0;
                    tv = tv + (vector(TR) * overlay.speccamspeed);
                    drs.SetLocation(tv);
                }
                if(overlay.bdown)
                {
                    tv = drs.Location;
                    TR = drs.Rotation;
                    TR.Yaw = TR.Yaw - 16384;
                    TR.Pitch = 0;
                    tv.Z = tv.Z - overlay.speccamspeed;
                    drs.SetLocation(tv);
                }
                if(overlay.bUp)
                {
                    tv = drs.Location;
                    TR = drs.Rotation;
                    TR.Yaw = TR.Yaw - 16384;
                    TR.Pitch = 0;
                    tv.Z = tv.Z + overlay.speccamspeed;
                    drs.SetLocation(tv);
                }
            }
            if(!overlay.bViewingdemorec && PC.ViewTarget != drs.ViewTarget)
            {
                PC.SetViewTarget(drs.ViewTarget);
            }
            if(!overlay.bTargetnone)
            {
                if((overlay.Target != none) && overlay.CC != none)
                {
                    overlay.CC.thisTarget = overlay.Target;
                }
                if(overlay.Target == none)
                {
                    overlay.bTargetnone = true;
                }
            }
            if(!overlay.bTargetnone && overlay.bFollowTarget)
            {
                if(overlay.waspressed)
                {
                    relpos2 = overlay.Target.Location;
                    relrot = overlay.Target.Rotation;
                    overlay.waspressed = false;                    
                }
                else
                {
                    if(overlay.followtarget_mode == "loc")
                    {
                        relpos1 = relpos2 - overlay.Target.Location;
                        drs.SetLocation(drs.Location - relpos1);
                        relpos2 = overlay.Target.Location;                        
                    }
                    else
                    {
                        if(overlay.followtarget_mode == "center_target")
                        {
                            drs.SetLocation(overlay.Target.Location - (vector(drs.Rotation) * overlay.specfollowdistance));
                            drs.SetRotation(rotator(overlay.Target.Location - drs.Location));                            
                        }
                        else
                        {
                            drs.SetLocation(overlay.Target.Location - (vector((rotator(relpos2 - drs.Location) + overlay.Target.Rotation) - relrot) * VSize(relpos2 - drs.Location)));
                            drs.SetRotation((drs.Rotation + overlay.Target.Rotation) - relrot);
                            relpos2 = overlay.Target.Location;
                            relrot = overlay.Target.Rotation;
                        }
                    }
                }
            }
            if(overlay.bdumpframes)
            {
                if(overlay.dumpframes_fps <= 0)
                {
                    overlay.dumpframes_fps = 30;
                }
                PC.WorldInfo.DemoPlayTimeDilation = 30 / float(overlay.dumpframes_fps);                
                PC.ConsoleCommand("shot");
            }
            if(overlay.CC != none)
            {
                if((((PC != none) && overlay.bViewingcam) && (PC.ViewTarget == overlay.CC) || PC.ViewTarget == overlay.CC.viewer01) && PC.GetFOVAngle() != overlay.CC.FOV)
                {
                    PC.SetFOV(overlay.CC.FOV);
                }
                if((PC.ViewTarget == overlay.CC.viewer01) && overlay.bserverdemo)
                {
                    PC.SetRotation(drs.ViewTarget.Rotation);
                }
                if(overlay.CC.ssw)
                {
                    PC.SetRotation(drs.ViewTarget.Rotation);
                }
            }
            if((!overlay.bserverdemo && overlay.bViewingcam) && !overlay.bViewingdemorec)
            {
                r1 = PC.Rotation;
                r2 = drs.ViewTarget.Rotation;
                if((r1 != r4) && PC.Pawn != none)
                {
                    PC.Pawn.FaceRotation(r1, DeltaTime);
                }
                if(r2 != r1)
                {
                    PC.SetRotation(r2);
                }
                r4 = PC.Rotation;
                PC.SetRotation(r2);
            }
        }
    }
}

function findOrCreatePlayerControllerAndDemorecSpectator()
{
    foreach AllActors(Class'KFPlayerController', KFPC)
    {
        if(KFPC.Pawn != none)
        {
            drs = KFPC.Spawn(Class'KFDemoRecSpectator');            
        }
        else
        {
            drs = KFDemoRecSpectator(KFPC);
            if(drs != none)
            {
                bserverdemo = true;                
            }
            else
            {
                drs = KFPC.Spawn(Class'KFDemoRecSpectator');
            }
        }
        PC = KFPC;
        break;        
    }    
}

function CamHUD findCamHUD()
{
    local Interaction inter;
    local int I;

    if(PC != none)
    {
        I = 0;
        J0x1A:

        if(I < PC.Interactions.Length)
        {
            inter = PC.Interactions[I];
            if(inter.IsA('CamHUD'))
            {
                return CamHUD(inter);
            }
            ++ I;
            goto J0x1A;
        }
    }
    return none;
}

defaultproperties
{
    begin object name=BaseDecal class=DecalComponent
        ReplacementPrimitive=none
    object end
    // Reference: DecalComponent'Default__RCamDecalManager.BaseDecal'
    DecalTemplate=BaseDecal
    bHidden=true
    bAlwaysTick=true
}