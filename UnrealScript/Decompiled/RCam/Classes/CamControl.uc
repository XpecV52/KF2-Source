/*******************************************************************************
 * CamControl generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CamControl extends Actor
    notplaceable
    hidecategories(Navigation);

struct TMultiArray
{
    var int Y[121];

    structdefaultproperties
    {
        Y[0]=0
        Y[1]=0
        Y[2]=0
        Y[3]=0
        Y[4]=0
        Y[5]=0
        Y[6]=0
        Y[7]=0
        Y[8]=0
        Y[9]=0
        Y[10]=0
        Y[11]=0
        Y[12]=0
        Y[13]=0
        Y[14]=0
        Y[15]=0
        Y[16]=0
        Y[17]=0
        Y[18]=0
        Y[19]=0
        Y[20]=0
        Y[21]=0
        Y[22]=0
        Y[23]=0
        Y[24]=0
        Y[25]=0
        Y[26]=0
        Y[27]=0
        Y[28]=0
        Y[29]=0
        Y[30]=0
        Y[31]=0
        Y[32]=0
        Y[33]=0
        Y[34]=0
        Y[35]=0
        Y[36]=0
        Y[37]=0
        Y[38]=0
        Y[39]=0
        Y[40]=0
        Y[41]=0
        Y[42]=0
        Y[43]=0
        Y[44]=0
        Y[45]=0
        Y[46]=0
        Y[47]=0
        Y[48]=0
        Y[49]=0
        Y[50]=0
        Y[51]=0
        Y[52]=0
        Y[53]=0
        Y[54]=0
        Y[55]=0
        Y[56]=0
        Y[57]=0
        Y[58]=0
        Y[59]=0
        Y[60]=0
        Y[61]=0
        Y[62]=0
        Y[63]=0
        Y[64]=0
        Y[65]=0
        Y[66]=0
        Y[67]=0
        Y[68]=0
        Y[69]=0
        Y[70]=0
        Y[71]=0
        Y[72]=0
        Y[73]=0
        Y[74]=0
        Y[75]=0
        Y[76]=0
        Y[77]=0
        Y[78]=0
        Y[79]=0
        Y[80]=0
        Y[81]=0
        Y[82]=0
        Y[83]=0
        Y[84]=0
        Y[85]=0
        Y[86]=0
        Y[87]=0
        Y[88]=0
        Y[89]=0
        Y[90]=0
        Y[91]=0
        Y[92]=0
        Y[93]=0
        Y[94]=0
        Y[95]=0
        Y[96]=0
        Y[97]=0
        Y[98]=0
        Y[99]=0
        Y[100]=0
        Y[101]=0
        Y[102]=0
        Y[103]=0
        Y[104]=0
        Y[105]=0
        Y[106]=0
        Y[107]=0
        Y[108]=0
        Y[109]=0
        Y[110]=0
        Y[111]=0
        Y[112]=0
        Y[113]=0
        Y[114]=0
        Y[115]=0
        Y[116]=0
        Y[117]=0
        Y[118]=0
        Y[119]=0
        Y[120]=0
    }
};

var TMultiArray M[121];
var bool bxedited;
var bool conf;
var bool do_not_update_Spline;
var bool startCam;
var bool bbadaccel;
var bool bisdrawing;
var bool bpcam;
var bool bredox;
var bool bSpline_update_required;
var bool btimedpath;
var bool C4D_Export_Target;
var bool C4D_Export;
var bool combineLoc;
var bool dif_tpstart_add;
var bool dif_tpstart_subtract;
var bool draw_Spline;
var bool drawSplineWasFalse;
var bool enable2;
var bool fovplus;
var bool fovminus;
var bool I_want_to_insert_a_Flag;
var bool is_spawning;
var bool justSpawn;
var bool remove_the_specified_Flag;
var bool rollplus;
var bool rollminus;
var bool ssw;
var bool Start;
var float basic_speed2;
var float Flag_Fovs[121];
var float Flag_Times[121];
var float kabstand;
var float mabstand;
var float X[121];
var int drawdetail;
var int Z;
var Rotator Rotation_At_Flags[121];
var Vector Flag_Locations[121];
var float Accel;
var float carry;
var float Counter;
var float CurFrame;
var float d1;
var float derivates[121];
var float dif_tpstart_temp;
var float dif_tpstart;
var float Dist;
var float Flag_Dist[121];
var float FOV;
var float path_length;
var float start_CurTime;
var float StartTimedPath_Later_seconds;
var float T;
var float T0;
var float v0;
var float TempDist;
var float testdist;
var float tfov;
var float x_speed;
var int drawcount;
var int flag_zaehler;
var int insert_after_Flag;
var int J;
var int N;
var int remove_Flag;
var int testzaehler;
var int Viewing;
var Rotator rotat;
var Rotator rotat2;
var Rotator TargetRotation;
var Rotator TR;
var Vector TargetLocation;
var Vector trc4dexport;
var Vector V;
var Vector v2;
var Vector v2old;
var Vector v3;
var Actor thisTarget;
var KFDemoRecSpectator Demo3;
var Knoten OtherKnot;
var RotKnoten Other2Rot;
var Viewer viewer01;
var float a_a[121];
var float a_b[121];
var float a_c[121];
var float a_d[121];
var float b_a[121];
var float b_b[121];
var float b_c[121];
var float b_d[121];
var float c_a[121];
var float c_b[121];
var float c_c[121];
var float c_d[121];
var float yaw_a[121];
var float yaw_b[121];
var float yaw_c[121];
var float yaw_d[121];
var float pitch_a[121];
var float pitch_b[121];
var float pitch_c[121];
var float pitch_d[121];
var float roll_a[121];
var float roll_b[121];
var float roll_c[121];
var float roll_d[121];
var float fov_a[121];
var float fov_b[121];
var float fov_c[121];
var float fov_d[121];

function PostBeginPlay()
{
    local int I;
    local Knoten Other;
    local KFDemoRecSpectator Other2;

    foreach DynamicActors(Class'KFDemoRecSpectator', Other2)
    {
        Demo3 = Other2;
        break;        
    }    
    foreach DynamicActors(Class'Knoten', Other)
    {
        conf = false;
        break;        
    }    
    if(!conf)
    {
        if(basic_speed2 == float(0))
        {
            basic_speed2 = 4;
        }
        Z = 0;
        Viewing = 0;
        drawdetail = 50;
        foreach DynamicActors(Class'Knoten', Other)
        {
            SetLocation(Other.Location);
            break;            
        }                
    }
    else
    {
        is_spawning = true;
        if(basic_speed2 == float(0))
        {
            basic_speed2 = 4;
        }
        I = 0;
        J0x125:

        if(I < Z)
        {
            Spawn(Class'Knoten',,, Flag_Locations[I]);
            ++ I;
            goto J0x125;
        }
        I = 0;
        foreach DynamicActors(Class'Knoten', Other)
        {
            Other.SetRotation(Rotation_At_Flags[I]);
            Other.FOV = Flag_Fovs[I];
            Other.Time = Flag_Times[I];
            ++ I;            
        }        
        updateSplinef(true);
        SetLocation(Flag_Locations[0]);
    }
    if(viewer01 == none)
    {
        viewer01 = Spawn(Class'Viewer');
    }
    draw_Spline = true;
    drawSplineWasFalse = false;
    I_want_to_insert_a_Flag = false;
    conf = false;
    Counter = 0;
    T = 0;
    x_speed = 10;
    C4D_Export = false;
    is_spawning = false;
    enable2 = false;
    Demo3.RotationRate.Pitch = 65536;
    self.Tag = Demo3.Tag;
    FOV = 100;
    Accel = 0;
    if(thisTarget == none)
    {
        thisTarget = Spawn(Class'scl');
    }
    SetTimer(0.005, true);
}

function get_x(int I, out float FL)
{
    FL = X[I];
}

function set__x(float FL, int I)
{
    X[I] = FL;
}

function get_Flag_Locations(int I, out Vector FL)
{
    FL = Flag_Locations[I];
}

function set_Flag_Locations(Vector FL, int I)
{
    Flag_Locations[I] = FL;
    update_flags();
}

function get_Flag_Rotations(int I, out Rotator FR)
{
    FR = Rotation_At_Flags[I];
}

function set_Flag_Rotations(Rotator FR, int I)
{
    local Knoten Other, knoten2;
    local int jj;

    Rotation_At_Flags[I] = FR;
    jj = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        if((I == 0) && jj == 1)
        {
            knoten2 = Other;
            break;
        }
        if(jj == (I - 1))
        {
            knoten2 = Other;
            break;
        }
        ++ jj;        
    }    
    if(knoten2 != none)
    {
        Rotation_At_Flags[I].Yaw = FR.Yaw;
        Rotation_At_Flags[I].Pitch = FR.Pitch;
        if(Abs(float(Rotation_At_Flags[I].Yaw - knoten2.Rotation.Yaw)) > float(32768))
        {
            J0x1B2:

            if(Abs(float(Rotation_At_Flags[I].Yaw - knoten2.Rotation.Yaw)) > float(32768))
            {
                if(Rotation_At_Flags[I].Yaw > knoten2.Rotation.Yaw)
                {
                    Rotation_At_Flags[I].Yaw = Rotation_At_Flags[I].Yaw - 65536;                    
                }
                else
                {
                    Rotation_At_Flags[I].Yaw = Rotation_At_Flags[I].Yaw + 65536;
                }
                goto J0x1B2;
            }            
        }
        else
        {
            Rotation_At_Flags[I].Yaw = FR.Yaw;
        }
        if(Abs(float(Rotation_At_Flags[I].Pitch - knoten2.Rotation.Pitch)) > float(32768))
        {
            J0x3D4:

            if(Abs(float(Rotation_At_Flags[I].Pitch - knoten2.Rotation.Pitch)) > float(32768))
            {
                if(Rotation_At_Flags[I].Pitch > knoten2.Rotation.Pitch)
                {
                    Rotation_At_Flags[I].Pitch = Rotation_At_Flags[I].Pitch - 65536;                    
                }
                else
                {
                    Rotation_At_Flags[I].Pitch = Rotation_At_Flags[I].Pitch + 65536;
                }
                goto J0x3D4;
            }            
        }
        else
        {
            Rotation_At_Flags[I].Pitch = FR.Pitch;
        }
    }
    update_flags();
}

function set_Flag_Fovs(float tf, int I)
{
    Flag_Fovs[I] = tf;
    update_flags();
}

function get_Flag_Fovs(int I, out float tf)
{
    tf = Flag_Fovs[I];
}

function set_Flag_Times(float tf, int I)
{
    Flag_Times[I] = tf;
    update_flags();
}

function get_Flag_Times(int I, out float tf)
{
    tf = Flag_Times[I];
}

function update_flags()
{
    local int z2, z3;
    local Knoten Other, other10;
    local bool negdisp;
    local float disp;
    local Vector tv;

    z2 = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        if(Other.FOV != Flag_Fovs[z2])
        {
            Other.FOV = Flag_Fovs[z2];
            if((Viewing == z2) && Demo3.ViewTarget == viewer01)
            {
                FOV = Flag_Fovs[z2];
            }
        }
        if(Other.Time != Flag_Times[z2])
        {
            Other.Time = Flag_Times[z2];
        }
        if(Other.Location != Flag_Locations[z2])
        {
            if(!combineLoc)
            {
                Other.SetLocation(Flag_Locations[z2]);
                if(Viewing == z2)
                {
                    viewer01.SetLocation(Flag_Locations[z2]);
                }                
            }
            else
            {
                tv = vect(0, 0, 0);
                if(Other.Location.X != Flag_Locations[z2].X)
                {
                    negdisp = Other.Location.X < Flag_Locations[z2].X;
                    disp = Abs(Other.Location.X - Flag_Locations[z2].X);
                }
                if(Other.Location.Y != Flag_Locations[z2].Y)
                {
                    negdisp = Other.Location.Y < Flag_Locations[z2].Y;
                    disp = Abs(Other.Location.Y - Flag_Locations[z2].Y);
                }
                if(Other.Location.Z != Flag_Locations[z2].Z)
                {
                    negdisp = Other.Location.Z < Flag_Locations[z2].Z;
                    disp = Abs(Other.Location.Z - Flag_Locations[z2].Z);
                }
                z3 = 0;
                foreach DynamicActors(Class'Knoten', other10)
                {
                    if(other10 != Other)
                    {
                        tv = other10.Location;
                        if(Other.Location.X != Flag_Locations[z2].X)
                        {
                            if(negdisp)
                            {
                                tv.X = other10.Location.X + disp;                                
                            }
                            else
                            {
                                tv.X = other10.Location.X - disp;
                            }
                        }
                        if(Other.Location.Y != Flag_Locations[z2].Y)
                        {
                            if(negdisp)
                            {
                                tv.Y = other10.Location.Y + disp;                                
                            }
                            else
                            {
                                tv.Y = other10.Location.Y - disp;
                            }
                        }
                        if(Other.Location.Z != Flag_Locations[z2].Z)
                        {
                            if(negdisp)
                            {
                                tv.Z = other10.Location.Z + disp;                                
                            }
                            else
                            {
                                tv.Z = other10.Location.Z - disp;
                            }
                        }
                        Flag_Locations[z3] = tv;
                        other10.SetLocation(tv);
                        if(Viewing == z3)
                        {
                            viewer01.SetLocation(Flag_Locations[z3]);
                        }
                    }
                    ++ z3;                    
                }                
                Other.SetLocation(Flag_Locations[z2]);
                if(Viewing == z2)
                {
                    viewer01.SetLocation(Flag_Locations[z2]);
                }
            }
            break;
        }
        if(Other.Rotation != Rotation_At_Flags[z2])
        {
            Other.SetRotation(Rotation_At_Flags[z2]);
            if(Viewing == z2)
            {
                viewer01.SetRotation(Rotation_At_Flags[z2]);
            }
            break;
        }
        ++ z2;        
    }    
}

function timesangleichen()
{
    local float dif;
    local int I;
    local Knoten Other;

    dif = (WorldInfo.TimeSeconds - Flag_Times[0]) + dif_tpstart;
    I = 0;
    J0x4B:

    if(I < Z)
    {
        Flag_Times[I] = Flag_Times[I] + dif;
        ++ I;
        goto J0x4B;
    }
    I = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        Other.Time = Other.Time + dif;        
    }    
}

function updateViewer(bool dec)
{
    if(Demo3.ViewTarget != viewer01)
    {
        Demo3.SetViewTarget(viewer01);
        viewer01.changeView(Viewing, Z - 1, false, false);        
    }
    else
    {
        viewer01.changeView(Viewing, Z - 1, !dec, dec);
    }
}

function removeFlag()
{
    local Knoten Other;
    local int I;

    I = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        if(I == remove_Flag)
        {
            Other.Destroy();
        }
        ++ I;        
    }    
    I = remove_Flag;
    J0x73:

    if(I < Z)
    {
        Flag_Locations[I] = Flag_Locations[I + 1];
        Rotation_At_Flags[I] = Rotation_At_Flags[I + 1];
        ++ I;
        goto J0x73;
    }
    Z = Z - 1;
    updateSplinef(true);
}

function FlagEinfuegen()
{
    local Knoten Other;
    local Vector v10;
    local int I;

    I_want_to_insert_a_Flag = false;
    I = 0;
    SetTimer(0, false);
    foreach DynamicActors(Class'Knoten', Other)
    {
        if(I == Z)
        {
            v10 = Other.Location;
        }
        ++ I;        
    }    
    I = Z - 1;
    J0x9D:

    if(I > insert_after_Flag)
    {
        Flag_Locations[I + 1] = Flag_Locations[I];
        Rotation_At_Flags[I + 1] = Rotation_At_Flags[I];
        -- I;
        goto J0x9D;
    }
    Flag_Locations[insert_after_Flag + 1] = v10;
    foreach DynamicActors(Class'Knoten', Other)
    {
        Other.Destroy();        
    }    
    Z = Z + 1;
    justSpawn = true;
    I = 0;
    J0x196:

    if(I < Z)
    {
        Spawn(Class'Knoten',,, Flag_Locations[I]);
        ++ I;
        goto J0x196;
    }
    justSpawn = false;
    I = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        Other.SetRotation(Rotation_At_Flags[I]);
        ++ I;        
    }    
    updateSplinef(true);
    I_want_to_insert_a_Flag = true;
}

function updateSplinef(bool draw, optional bool force_update_Spline)
{
    local Knoten Other;
    local RotKnoten Other2;

    Z = 0;
    foreach DynamicActors(Class'Knoten', Other)
    {
        Flag_Locations[Z] = Other.Location;
        Rotation_At_Flags[Z] = Other.Rotation;
        Flag_Fovs[Z] = Other.FOV;
        Flag_Times[Z] = Other.Time;
        ++ Z;        
    }    
    if((!do_not_update_Spline || force_update_Spline) || bxedited)
    {
        SetTimer(0.004, false);
        foreach DynamicActors(Class'RotKnoten', Other2)
        {
            Other2.Destroy();            
        }        
        set_x();
        KubSplineKoeffNat();
        if(draw)
        {
            DrawPath();
            drawcount = 0;            
        }
        else
        {
            drawcount = 2;
        }
        Dist = 0;
        Flag_Dist[0] = 0;
        bSpline_update_required = false;
        SetTimer(0.004, false);        
    }
    else
    {
        bSpline_update_required = true;
    }
}

function calculate_path_length()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < Z)
    {
        path_length = Flag_Dist[I];
        ++ I;
        goto J0x0B;
    }
}

event Tick(float DeltaTime)
{
    if(ssw == true)
    {
        if(!Start)
        {
            Start = true;
        }
        if(btimedpath && WorldInfo.TimeSeconds > Flag_Times[Z - 1])
        {
            ssw = false;
        }
        if(T >= X[Z - 1])
        {
            ssw = false;
        }
        if((T < X[Z - 1]) && Start)
        {
            if(btimedpath)
            {
                spline_pchip_val(Z, Flag_Times, X, derivates, 1, WorldInfo.TimeSeconds, T);
            }
            J = 0;
            J0x150:

            if(J < (N - 1))
            {
                if(T >= X[J])
                {
                    if(T < X[J + 1])
                    {
                        KubSplineWertX(T, J);
                        KubSplineWertY(T, J);
                        KubSplineWertZ(T, J);
                        v3 = v2 - V;
                        Norm(d1, v3);
                        TempDist = 0;
                        if(carry != float(0))
                        {
                            TempDist = TempDist + carry;
                        }
                        if((btimedpath && T >= X[flag_zaehler]) && flag_zaehler < Z)
                        {
                            ++ flag_zaehler;                            
                        }
                        else
                        {
                            J0x2D2:

                            if(((!btimedpath && !bpcam) && TempDist < basic_speed2) && T < X[J + 1])
                            {
                                KubSplineWertX(T, J);
                                KubSplineWertY(T, J);
                                KubSplineWertZ(T, J);
                                v3 = v2 - V;
                                Norm(d1, v3);
                                T = T + 0.0005;
                                Dist = Dist + d1;
                                TempDist = TempDist + d1;
                                V = v2;
                                if((T >= X[flag_zaehler]) && flag_zaehler < Z)
                                {
                                    ++ flag_zaehler;
                                }
                                goto J0x2D2;
                            }
                        }
                        if(btimedpath || (TempDist >= basic_speed2) && T < X[J + 1])
                        {
                            V = v2;
                            SetLocation(V);
                            FOV = tfov;
                            KubSplineWertYaw(T, J);
                            KubSplineWertPitch(T, J);
                            KubSplineWertRoll(T, J);
                            KubSplineWertFov(T, J);
                            carry = 0;
                            if(!enable2)
                            {
                                SetRotation(rotat);
                            }                            
                        }
                        else
                        {
                            carry = TempDist;
                        }
                    }
                }
                if(J == (N - 2))
                {
                    if(T == X[J + 1])
                    {
                        KubSplineWertX(T, J);
                        KubSplineWertY(T, J);
                        KubSplineWertZ(T, J);
                        KubSplineWertYaw(T, J);
                        KubSplineWertPitch(T, J);
                        KubSplineWertRoll(T, J);
                        KubSplineWertFov(T, J);
                        v3 = v2 - V;
                        Norm(d1, v3);
                        Dist = Dist + d1;
                        T = T + 0.0005;
                        V = v2;
                        SetLocation(V);
                        FOV = tfov;
                        if(!enable2)
                        {
                            SetRotation(rotat);
                        }
                    }
                }
                ++ J;
                goto J0x150;
            }
        }
    }
    if(dif_tpstart_add)
    {
        dif_tpstart_temp += 5E-05;
        dif_tpstart = ((Flag_Times[0] - WorldInfo.TimeSeconds) + StartTimedPath_Later_seconds) - dif_tpstart_temp;
        timesangleichen();
        inittimespline();
    }
    if(dif_tpstart_subtract)
    {
        dif_tpstart_temp += 5E-05;
        dif_tpstart = ((Flag_Times[0] - WorldInfo.TimeSeconds) + StartTimedPath_Later_seconds) + dif_tpstart_temp;
        timesangleichen();
        inittimespline();
    }
    if(fovplus)
    {
        if(Flag_Fovs[Viewing] < float(150))
        {
            Flag_Fovs[Viewing] += 0.2;
            update_flags();            
        }
        else
        {
            fovplus = false;
            updateSplinef(true);
        }
    }
    if(fovminus)
    {
        if(Flag_Fovs[Viewing] > float(2))
        {
            Flag_Fovs[Viewing] -= 0.2;
            update_flags();            
        }
        else
        {
            fovminus = false;
            updateSplinef(true);
        }
    }
    if(rollplus)
    {
        Rotation_At_Flags[Viewing].Roll -= 70;
        update_flags();
    }
    if(rollminus)
    {
        Rotation_At_Flags[Viewing].Roll += 70;
        update_flags();
    }
    if(enable2)
    {
        TR = rotator(thisTarget.Location - Location);
        TR.Roll = rotat.Roll;
        SetRotation(TR);
    }
}

function Timer()
{
    if(Demo3.ViewTarget != none)
    {
        TargetLocation = Demo3.ViewTarget.Location;
        TargetRotation = Demo3.ViewTarget.Rotation;
    }
    if(remove_the_specified_Flag == true)
    {
        SetTimer(0.004, false);
        removeFlag();
        remove_the_specified_Flag = false;
    }
    if((draw_Spline == false) && !drawSplineWasFalse)
    {
        foreach DynamicActors(Class'Knoten', OtherKnot)
        {
            OtherKnot.SetHidden(true);            
        }        
        foreach DynamicActors(Class'RotKnoten', Other2Rot)
        {
            Other2Rot.SetHidden(true);            
        }        
        drawSplineWasFalse = true;
        drawcount = 1;
    }
    if((drawSplineWasFalse == true) && draw_Spline == true)
    {
        foreach DynamicActors(Class'Knoten', OtherKnot)
        {
            OtherKnot.SetHidden(false);            
        }        
        foreach DynamicActors(Class'RotKnoten', Other2Rot)
        {
            Other2Rot.SetHidden(false);            
        }        
        drawSplineWasFalse = false;
        drawcount = 0;
    }
    if(startCam == true)
    {
        ssw = true;
        startCam = false;
        v2 = vect(0, 0, 0);
        V = Flag_Locations[0];
        rotat = Rotation_At_Flags[0];
        T = 0;
        SetLocation(V);
        SetRotation(rotat);
        flag_zaehler = 1;
        Dist = 0;
        Counter = 2;
        SetTimer(0.004, true);
    }
    N = Z;
    if((T >= X[Z - 1]) && !enable2)
    {
        SetTimer(0.05, true);
    }
}

function Norm(out float F2, Vector vv3)
{
    F2 = Sqrt(((vv3.X * vv3.X) + (vv3.Y * vv3.Y)) + (vv3.Z * vv3.Z));
}

function KubSplineWertX(float tt, int jj)
{
    v2.X = ((a_a[jj] + (a_b[jj] * (tt - X[jj]))) + ((a_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((a_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj]));
}

function KubSplineWertY(float tt, int jj)
{
    v2.Y = ((b_a[jj] + (b_b[jj] * (tt - X[jj]))) + ((b_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((b_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj]));
}

function KubSplineWertZ(float tt, int jj)
{
    v2.Z = ((c_a[jj] + (c_b[jj] * (tt - X[jj]))) + ((c_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((c_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj]));
}

function KubSplineWertYaw(float tt, int jj)
{
    rotat.Yaw = int(((yaw_a[jj] + (yaw_b[jj] * (tt - X[jj]))) + ((yaw_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((yaw_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj])));
}

function KubSplineWertPitch(float tt, int jj)
{
    rotat.Pitch = int(((pitch_a[jj] + (pitch_b[jj] * (tt - X[jj]))) + ((pitch_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((pitch_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj])));
}

function KubSplineWertRoll(float tt, int jj)
{
    rotat.Roll = int(((roll_a[jj] + (roll_b[jj] * (tt - X[jj]))) + ((roll_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((roll_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj])));
}

function KubSplineWertFov(float tt, int jj)
{
    tfov = ((fov_a[jj] + (fov_b[jj] * (tt - X[jj]))) + ((fov_c[jj] * (tt - X[jj])) * (tt - X[jj]))) + (((fov_d[jj] * (tt - X[jj])) * (tt - X[jj])) * (tt - X[jj]));
}

function equalArray(float A1[121], out float b1[121])
{
    local int I;

    I = 0;
    J0x0B:

    if(I < 121)
    {
        b1[I] = A1[I];
        ++ I;
        goto J0x0B;
    }
}

function Cholesky(float K[121], out float erg[121])
{
    local int nn, I;
    local float D[121], G, z1, E;

    nn = Z - 3;
    I = 0;
    J0x22:

    if(I <= nn)
    {
        D[I] = 0;
        G[I] = 0;
        E[I] = 0;
        z1[I] = 0;
        erg[I] = 0;
        ++ I;
        goto J0x22;
    }
    D[0] = float(M[0].Y[0]);
    I = 1;
    J0xFD:

    if(I <= N)
    {
        G[I - 1] = float(M[I].Y[I - 1]) / D[I - 1];
        D[I] = float(M[I].Y[I]) - (G[I - 1] * float(M[I].Y[I - 1]));
        ++ I;
        goto J0xFD;
    }
    D[nn] = float(M[nn].Y[nn]) - (float(M[nn].Y[nn - 1]) * G[nn - 1]);
    z1[0] = K[0];
    I = 1;
    J0x2D2:

    if(I <= nn)
    {
        z1[I] = K[I] - (G[I - 1] * z1[I - 1]);
        ++ I;
        goto J0x2D2;
    }
    I = 0;
    J0x359:

    if(I <= nn)
    {
        E[I] = z1[I] / D[I];
        ++ I;
        goto J0x359;
    }
    erg[nn] = E[nn];
    I = nn - 1;
    J0x3F7:

    if(I >= 0)
    {
        erg[I] = E[I] - (G[I] * erg[I + 1]);
        -- I;
        goto J0x3F7;
    }
}

function KubSplineKoeffNat()
{
    local int nn;
    local float K[121], Y, H1, ska, skb, skc,
	    skd;

    local int I, H, O, jj;

    nn = Z - 1;
    I = 0;
    J0x21:

    if(I < 121)
    {
        jj = 0;
        J0x3C:

        if(jj < 121)
        {
            M[I].Y[jj] = 0;
            ++ jj;
            goto J0x3C;
        }
        ++ I;
        goto J0x21;
    }
    I = 0;
    J0xA5:

    if(I <= nn)
    {
        ska[I] = 0;
        skb[I] = 0;
        skc[I] = 0;
        skd[I] = 0;
        ++ I;
        goto J0xA5;
    }
    H = 7;
    O = 0;
    O = 0;
    J0x150:

    if(O < H)
    {
        if(O == 0)
        {
            I = 0;
            J0x181:

            if(I < 121)
            {
                Y[I] = Flag_Locations[I].X;
                ++ I;
                goto J0x181;
            }
        }
        if(O == 1)
        {
            I = 0;
            J0x1F3:

            if(I < 121)
            {
                Y[I] = Flag_Locations[I].Y;
                ++ I;
                goto J0x1F3;
            }
        }
        if(O == 2)
        {
            I = 0;
            J0x266:

            if(I < 121)
            {
                Y[I] = Flag_Locations[I].Z;
                ++ I;
                goto J0x266;
            }
        }
        if(O == 3)
        {
            I = 0;
            J0x2D9:

            if(I < 121)
            {
                Y[I] = float(Rotation_At_Flags[I].Yaw);
                ++ I;
                goto J0x2D9;
            }
        }
        if(O == 4)
        {
            I = 0;
            J0x34E:

            if(I < 121)
            {
                Y[I] = float(Rotation_At_Flags[I].Pitch);
                ++ I;
                goto J0x34E;
            }
        }
        if(O == 5)
        {
            I = 0;
            J0x3C3:

            if(I < 121)
            {
                Y[I] = float(Rotation_At_Flags[I].Roll);
                ++ I;
                goto J0x3C3;
            }
        }
        if(O == 6)
        {
            I = 0;
            J0x438:

            if(I < 121)
            {
                Y[I] = Flag_Fovs[I];
                ++ I;
                goto J0x438;
            }
        }
        skc[0] = 0;
        skc[nn] = 0;
        skb[0] = 0;
        skb[nn] = 0;
        jj = 1;
        J0x4DC:

        if(jj <= (nn - 1))
        {
            skb[jj] = 3 * (((Y[jj + 1] - Y[jj]) / (X[jj + 1] - X[jj])) - ((Y[jj] - Y[jj - 1]) / (X[jj] - X[jj - 1])));
            ++ jj;
            goto J0x4DC;
        }
        M[0].Y[0] = int(float(2) * (X[2] - X[0]));
        M[0].Y[1] = int(X[2] - X[1]);
        I = 0;
        J0x65A:

        if(I <= (nn - 4))
        {
            M[I + 1].Y[I] = int(float(1) * (X[I + 2] - X[I + 1]));
            M[I + 1].Y[I + 1] = int(float(2) * (X[I + 3] - X[I + 1]));
            M[I + 1].Y[I + 2] = int(float(1) * (X[I + 3] - X[I + 2]));
            ++ I;
            goto J0x65A;
        }
        M[nn - 2].Y[nn - 3] = int(float(1) * (X[nn - 1] - X[nn - 2]));
        M[nn - 2].Y[nn - 2] = int(float(2) * (X[nn] - X[nn - 2]));
        I = 1;
        J0x8B1:

        if(I <= (nn - 1))
        {
            K[I - 1] = skb[I];
            ++ I;
            goto J0x8B1;
        }
        Cholesky(K, H1);
        I = 1;
        J0x92A:

        if(I <= (nn - 1))
        {
            skc[I] = H1[I - 1];
            ++ I;
            goto J0x92A;
        }
        I = 0;
        J0x987:

        if(I <= (nn - 1))
        {
            skd[I] = (skc[I + 1] - skc[I]) / (float(3) * (X[I + 1] - X[I]));
            skb[I] = ((Y[I + 1] - Y[I]) / (X[I + 1] - X[I])) - (((X[I + 1] - X[I]) * (skc[I + 1] + (float(2) * skc[I]))) / float(3));
            ++ I;
            goto J0x987;
        }
        equalArray(Y, ska);
        I = 0;
        J0xB1A:

        if(I < nn)
        {
            K[I] = 0;
            ++ I;
            goto J0xB1A;
        }
        if(O == 0)
        {
            equalArray(ska, a_a);
            equalArray(skb, a_b);
            equalArray(skc, a_c);
            equalArray(skd, a_d);
        }
        if(O == 1)
        {
            equalArray(ska, b_a);
            equalArray(skb, b_b);
            equalArray(skc, b_c);
            equalArray(skd, b_d);
        }
        if(O == 2)
        {
            equalArray(ska, c_a);
            equalArray(skb, c_b);
            equalArray(skc, c_c);
            equalArray(skd, c_d);
        }
        if(O == 3)
        {
            equalArray(ska, yaw_a);
            equalArray(skb, yaw_b);
            equalArray(skc, yaw_c);
            equalArray(skd, yaw_d);
        }
        if(O == 4)
        {
            equalArray(ska, pitch_a);
            equalArray(skb, pitch_b);
            equalArray(skc, pitch_c);
            equalArray(skd, pitch_d);
        }
        if(O == 5)
        {
            equalArray(ska, roll_a);
            equalArray(skb, roll_b);
            equalArray(skc, roll_c);
            equalArray(skd, roll_d);
        }
        if(O == 6)
        {
            equalArray(ska, fov_a);
            equalArray(skb, fov_b);
            equalArray(skc, fov_c);
            equalArray(skd, fov_d);
        }
        ++ O;
        goto J0x150;
    }
}

function edit_x(int I, bool bminus)
{
    local RotKnoten Other2;
    local int jj;
    local float tempdiff;

    bxedited = true;
    if(I == 0)
    {
        return;
    }
    tempdiff = (X[I] - X[I - 1]) / float(7);
    if(bminus)
    {
        if((X[I] - tempdiff) > X[I - 1])
        {
            jj = I;
            J0xB1:

            if(jj < Z)
            {
                X[jj] = X[jj] - tempdiff;
                ++ jj;
                goto J0xB1;
            }
        }        
    }
    else
    {
        jj = I;
        J0x11E:

        if(jj < Z)
        {
            X[jj] = X[jj] + tempdiff;
            ++ jj;
            goto J0x11E;
        }
    }
    KubSplineKoeffNat();
    foreach DynamicActors(Class'RotKnoten', Other2)
    {
        Other2.Destroy();        
    }    
    DrawPath();
    drawcount = 0;
}

function set_x()
{
    local int I;
    local float t2;

    X[0] = 0;
    if(!bxedited)
    {
        kabstand = VSize(Flag_Locations[1] - Flag_Locations[0]);
        mabstand = kabstand;
        I = 1;
        J0x62:

        if(I < Z)
        {
            t2 = VSize(Flag_Locations[I] - Flag_Locations[I - 1]);
            if(t2 < kabstand)
            {
                kabstand = t2;                
            }
            else
            {
                if(t2 > mabstand)
                {
                    mabstand = t2;
                }
            }
            ++ I;
            goto J0x62;
        }
        I = 1;
        J0x120:

        if(I < Z)
        {
            X[I] = X[I - 1] + (float(2) * (VSize(Flag_Locations[I] - Flag_Locations[I - 1]) / kabstand));
            ++ I;
            goto J0x120;
        }        
    }
    else
    {
        X[Z - 1] = X[Z - 2] + (float(2) * (VSize(Flag_Locations[Z - 1] - Flag_Locations[Z - 2]) / kabstand));
    }
}

function DrawPath()
{
    local int nn, jj;
    local float dd1, tempdist1;
    local Vector vv3;

    Flag_Dist[0] = 0;
    T = 0;
    V = vect(0, 0, 0);
    v2 = vect(0, 0, 0);
    V = Flag_Locations[0];
    nn = Z;
    T = 0;
    Dist = 0;
    J0x94:

    if(T < X[Z - 1])
    {
        bisdrawing = true;
        jj = 0;
        J0xCF:

        if(jj < (nn - 1))
        {
            if(T >= X[jj])
            {
                if(T < X[jj + 1])
                {
                    KubSplineWertX(T, jj);
                    KubSplineWertY(T, jj);
                    KubSplineWertZ(T, jj);
                    vv3 = v2 - V;
                    Norm(dd1, vv3);
                    tempdist1 = 0;
                    if(carry != float(0))
                    {
                        tempdist1 = carry;
                    }
                    J0x1EF:

                    if((tempdist1 < float(drawdetail)) && T < X[jj + 1])
                    {
                        KubSplineWertX(T, jj);
                        KubSplineWertY(T, jj);
                        KubSplineWertZ(T, jj);
                        vv3 = v2 - V;
                        Norm(dd1, vv3);
                        T = T + 0.005;
                        tempdist1 = tempdist1 + dd1;
                        Dist = Dist + dd1;
                        V = v2;
                        Flag_Dist[J + 1] = Dist;
                        goto J0x1EF;
                    }
                    if((tempdist1 >= float(drawdetail)) && T < X[jj + 1])
                    {
                        V = v2;
                        Spawn(Class'RotKnoten',,, V);
                        Flag_Dist[J + 1] = Dist;
                        carry = 0;                        
                    }
                    else
                    {
                        carry = tempdist1;
                    }
                }
            }
            if(jj == (nn - 2))
            {
                if(T == X[jj + 1])
                {
                    KubSplineWertX(T, jj);
                    KubSplineWertY(T, jj);
                    KubSplineWertZ(T, jj);
                    vv3 = v2 - V;
                    Norm(dd1, vv3);
                    Dist = Dist + dd1;
                    Flag_Dist[jj + 1] = Dist;
                    T = T + 0.005;
                    V = v2;
                    Spawn(Class'RotKnoten',,, V);
                }
            }
            ++ jj;
            goto J0xCF;
        }
        goto J0x94;
    }
    if(bisdrawing)
    {
        bisdrawing = false;
    }
}

function chfev(float X1, float X2, float F1, float F2, float dd1, float d2, int ne, float xe, out float fe, int Next[2])
{
    local float H, xmi, XMA, Delta, del1, del2,
	    c2, C3, lx;

    H = X2 - X1;
    Next[0] = 0;
    Next[1] = 0;
    if(H < 0)
    {
        xmi = H;        
    }
    else
    {
        xmi = 0;
    }
    if(H > 0)
    {
        XMA = H;        
    }
    else
    {
        XMA = 0;
    }
    Delta = (F2 - F1) / H;
    del1 = (dd1 - Delta) / H;
    del2 = (d2 - Delta) / H;
    c2 = -(del1 + del1) + del2;
    C3 = (del1 + del2) / H;
    lx = xe - X1;
    fe = F1 + (lx * (dd1 + (lx * (c2 + (lx * C3)))));
    if(lx < xmi)
    {
        Next[0] = Next[0] + 1;
    }
    if(XMA < lx)
    {
        Next[1] = Next[1] + 1;
    }
}

function pchst(float arg1, float arg2, out float Value)
{
    if(arg1 == 0)
    {
        Value = 0;        
    }
    else
    {
        if(arg1 < 0)
        {
            if(arg2 < 0)
            {
                Value = 1;                
            }
            else
            {
                if(arg2 == 0)
                {
                    Value = 0;                    
                }
                else
                {
                    if(0 < arg2)
                    {
                        Value = -1;
                    }
                }
            }            
        }
        else
        {
            if(0 < arg1)
            {
                if(arg2 < 0)
                {
                    Value = -1;                    
                }
                else
                {
                    if(arg2 == 0)
                    {
                        Value = 0;                        
                    }
                    else
                    {
                        if(0 < arg2)
                        {
                            Value = 1;
                        }
                    }
                }
            }
        }
    }
}

function spline_pchip_set(int nn, float xx[121], float F[121], out float D[121])
{
    local int nless1, I;
    local float H1, H2, hsum, hsumt3, dmax, dmin,
	    drat1, drat2, w1, w2, del1,
	    del2, Value1, Value2, Temp;

    nless1 = nn - 1;
    H1 = xx[1] - xx[0];
    del1 = (F[1] - F[0]) / H1;
    if(nn == 2)
    {
        D[0] = del1;
        D[nn - 1] = del1;
        return;
    }
    H2 = xx[2] - xx[1];
    del2 = (F[2] - F[1]) / H2;
    hsum = H1 + H2;
    w1 = (H1 + hsum) / hsum;
    w2 = -H1 / hsum;
    D[0] = (w1 * del1) + (w2 * del2);
    pchst(D[0], del1, Value1);
    pchst(del1, del2, Value2);
    if(Value1 <= 0)
    {
        D[0] = 0;        
    }
    else
    {
        if(Value2 < 0)
        {
            dmax = 3 * del1;
            if(Abs(dmax) < Abs(D[0]))
            {
                D[0] = dmax;
            }
        }
    }
    I = 2;
    J0x278:

    if(I <= nless1)
    {
        if(2 < I)
        {
            H1 = H2;
            H2 = xx[I] - xx[I - 1];
            hsum = H1 + H2;
            del1 = del2;
            del2 = (F[I] - F[I - 1]) / H2;
        }
        D[I - 1] = 0;
        pchst(del1, del2, Temp);
        if(Temp < 0)
        {            
        }
        else
        {
            if(Temp == 0)
            {
                if(del2 != float(0))
                {
                }
            }
        }
        if(Temp > 0)
        {
            hsumt3 = 3 * hsum;
            w1 = (hsum + H1) / hsumt3;
            w2 = (hsum + H2) / hsumt3;
            dmax = FMax(Abs(del1), Abs(del2));
            dmin = FMin(Abs(del1), Abs(del2));
            drat1 = del1 / dmax;
            drat2 = del2 / dmax;
            D[I - 1] = dmin / ((w1 * drat1) + (w2 * drat2));
        }
        ++ I;
        goto J0x278;
    }
    w1 = -H2 / hsum;
    w2 = (H2 + hsum) / hsum;
    D[nn - 1] = (w1 * del1) + (w2 * del2);
    pchst(D[nn - 1], del2, Value1);
    pchst(del1, del2, Value2);
    if(Value1 <= 0)
    {
        D[nn - 1] = 0;        
    }
    else
    {
        if(Value2 < 0)
        {
            dmax = 3 * del2;
            if(Abs(dmax) < Abs(D[nn - 1]))
            {
                D[nn - 1] = dmax;
            }
        }
    }
}

function spline_pchip_val(int nn, float xx[121], float F[121], float D[121], int ne, float xe, out float fe)
{
    local int j_first, j_save, ir, jj, I, j_new,
	    Next;

    local float nj;

    j_first = 1;
    ir = 2;
    Next[0] = 0;
    Next[1] = 0;
    J0x31:

    if(true)
    {
        if(ne < j_first)
        {
            goto J0x320;
        }
        j_save = ne + 1;
        jj = j_first;
        J0x78:

        if(jj <= ne)
        {
            if(xx[ir - 1] <= xe)
            {
                j_save = jj;
                if(ir == nn)
                {
                    j_save = ne + 1;
                }
                goto J0x104;
            }
            ++ jj;
            goto J0x78;
        }
        J0x104:

        jj = j_save;
        nj = float(jj - j_first);
        if(nj != float(0))
        {
            chfev(xx[ir - 2], X[ir - 1], F[ir - 2], F[ir - 1], D[ir - 2], D[ir - 1], int(nj), xe, fe, Next);
            if(Next[0] != 0)
            {
                if(ir > 2)
                {
                    j_new = -1;
                    if(xe < xx[ir - 2])
                    {
                        j_new = 1;
                        goto J0x320;
                    }
                    jj = j_new;
                    I = 1;
                    J0x280:

                    if(I <= (ir - 1))
                    {
                        if(xe < xx[I - 1])
                        {
                            goto J0x2CF;
                        }
                        ++ I;
                        goto J0x280;
                    }
                    J0x2CF:

                    ir = 1;
                }
            }
            j_first = jj;
        }
        ir = ir + 1;
        if(nn < ir)
        {
            goto J0x320;
        }
        goto J0x31;
    }
    J0x320:

}

function inittimespline()
{
    spline_pchip_set(Z, Flag_Times, X, derivates);
}

defaultproperties
{
    bSpline_update_required=true
    bHidden=true
    bAlwaysTick=true
}