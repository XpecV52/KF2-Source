/*******************************************************************************
 * GFxMoviePlayer generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GFxMoviePlayer extends Object
    native
    config(UI);

enum GFxTimingMode
{
    TM_Game,
    TM_Real,
    TM_MAX
};

enum GFxRenderTextureMode
{
    RTM_Opaque,
    RTM_Alpha,
    RTM_AlphaComposite,
    RTM_MAX
};

enum ASType
{
    AS_Undefined,
    AS_Null,
    AS_Number,
    AS_Int,
    AS_String,
    AS_Boolean,
    AS_MAX
};

enum GFxScaleMode
{
    SM_NoScale,
    SM_ShowAll,
    SM_ExactFit,
    SM_NoBorder,
    SM_MAX
};

enum GFxAlign
{
    Align_Center,
    Align_TopCenter,
    Align_BottomCenter,
    Align_CenterLeft,
    Align_CenterRight,
    Align_TopLeft,
    Align_TopRight,
    Align_BottomLeft,
    Align_BottomRight,
    Align_MAX
};

struct native ExternalTexture
{
    /**  
     *Stores a mapping between a movie's image resource ("Linkage" identifier on an image resource in the movie) and an Unreal texture resource.  This allows
     *  runtime remapping of the images used by the movie.  Any texture with a linkage identifier can be replaced at runtime using SetExternalTexture()
     */
    var() string Resource;
    /**  
     *Stores a mapping between a movie's image resource ("Linkage" identifier on an image resource in the movie) and an Unreal texture resource.  This allows
     *  runtime remapping of the images used by the movie.  Any texture with a linkage identifier can be replaced at runtime using SetExternalTexture()
     */
    var() Texture Texture;

    structdefaultproperties
    {
        Resource=""
        Texture=none
    }
};

struct native SoundThemeBinding
{
    /** Name of the sound theme, specified by the artist in the movie */
    var() name ThemeName;
    /** Corresponding sound theme to handle sound events for this ThemeName. Setting this directly will create a hardlink. You may optionally just set ThemeClassName. */
    var() UISoundTheme Theme;
    /** String name of ThemeClass to avoid hard linking UISoundTheme resources to GFxMoviePlayer default properties. You may set this instead of setting Theme directly. */
    var() string ThemeClassName;

    structdefaultproperties
    {
        ThemeName=None
        Theme=none
        ThemeClassName=""
    }
};

struct native GFxWidgetBinding
{
    /**  
     *Widget class binding:  To associate a CLIK widget instance in a movie with a particular UnrealScript subclass of GFxObject, add the widget's Flash name here, and specify the class.
     *  This will cause the GFxObject parameter of WidgetInitialized() to be created as the appropriate subclass.
     */
    var() name WidgetName;
    /**  
     *Widget class binding:  To associate a CLIK widget instance in a movie with a particular UnrealScript subclass of GFxObject, add the widget's Flash name here, and specify the class.
     *  This will cause the GFxObject parameter of WidgetInitialized() to be created as the appropriate subclass.
     */
    var() class<GFxObject> WidgetClass;

    structdefaultproperties
    {
        WidgetName=None
        WidgetClass=none
    }
};

struct native ASValue
{
    /** Generic struct used for passing generic data to and from ActionScript.  Should be used as little as possible because of overhead, except in cases where it is unavoidable */
    var() GFxMoviePlayer.ASType Type;
    /** Generic struct used for passing generic data to and from ActionScript.  Should be used as little as possible because of overhead, except in cases where it is unavoidable */
    var() bool B;
    /** Generic struct used for passing generic data to and from ActionScript.  Should be used as little as possible because of overhead, except in cases where it is unavoidable */
    var() float N;
    /** Generic struct used for passing generic data to and from ActionScript.  Should be used as little as possible because of overhead, except in cases where it is unavoidable */
    var() int I;
    /** Generic struct used for passing generic data to and from ActionScript.  Should be used as little as possible because of overhead, except in cases where it is unavoidable */
    var() init string S;

    structdefaultproperties
    {
        Type=ASType.AS_Undefined
        B=false
        N=0
        I=0
        S=""
    }
};

var native const transient Pointer pMovie;
var native const transient Pointer pCaptureKeys;
var native const transient Pointer pFocusIgnoreKeys;
var private native const transient map<0, 0> ASUClasses;
var private native const transient map<0, 0> ASUObjects;
var private const transient int NextASUObject;
var SwfMovie MovieInfo;
var const bool bMovieIsOpen;
var bool bDisplayWithHudOff;
var bool bEnableGammaCorrection;
var const transient bool bWidgetsInitializedThisFrame;
var bool bLogUnhandedWidgetInitializations;
var bool bAllowInput;
var bool bAllowFocus;
var bool bAutoPlay;
var bool bPauseGameWhileActive;
var bool bDisableWorldRendering;
var bool bCaptureWorldRendering;
var bool bCloseOnLevelChange;
var bool bOnlyOwnerFocusable;
var bool bForceFullViewport;
var bool bDiscardNonOwnerInput;
var bool bCaptureInput;
var bool bCaptureMouseInput;
var bool bIgnoreMouseInput;
var transient bool bIsSplitscreenLayoutModified;
var bool bShowHardwareMouseCursor;
var bool bBlurLesserMovies;
var bool bHideLesserMovies;
var bool bIsPriorityBlurred;
var bool bIsPriorityHidden;
var bool bIgnoreVisibilityEffect;
var bool bIgnoreBlurEffect;
/** Texture that the movie should be rendered to.  If NULL, the movie will be rendered to the frame buffer. */
var() TextureRenderTarget2D RenderTexture;
var transient int LocalPlayerOwnerIndex;
var Object ExternalInterface;
var array<name> CaptureKeys;
var array<name> FocusIgnoreKeys;
var array<ExternalTexture> ExternalTextures;
/** Stores an array of bindings between sound theme names and actual UISoundThemes */
var() array<SoundThemeBinding> SoundThemes;
var private GFxMoviePlayer.GFxTimingMode TimingMode;
var GFxMoviePlayer.GFxRenderTextureMode RenderTextureMode;
var private byte Priority;
var array<GFxWidgetBinding> WidgetBindings;
var native const map<0, 0> WidgetPathBindings;
var transient GFxObject SplitscreenLayoutObject;
var config int SplitscreenLayoutYAdjust;
var delegate<OnPostAdvance> __OnPostAdvance__Delegate;

// Export UGFxMoviePlayer::execStart(FFrame&, void* const)
native event bool Start(optional bool StartPaused)
{
    StartPaused = false;            
}

// Export UGFxMoviePlayer::execAdvance(FFrame&, void* const)
native final function Advance(float Time);

// Export UGFxMoviePlayer::execPostAdvance(FFrame&, void* const)
native function PostAdvance(float DeltaTime);

delegate OnPostAdvance(float DeltaTime);

// Export UGFxMoviePlayer::execRefreshViewportFlags(FFrame&, void* const)
native function RefreshViewportFlags();

// Export UGFxMoviePlayer::execSetPause(FFrame&, void* const)
native function SetPause(optional bool bPausePlayback)
{
    bPausePlayback = true;            
}

// Export UGFxMoviePlayer::execClose(FFrame&, void* const)
native final function Close(optional bool Unload)
{
    Unload = true;            
}

event OnClose();

event OnCleanup();

final event ConditionalClearPause()
{
    local LocalPlayer LP;

    if(bPauseGameWhileActive)
    {
        LP = GetLP();
        if((LP != none) && LP.Actor != none)
        {
            LP.Actor.SetPause(false);
        }
    }
}

function SetMovieInfo(SwfMovie Data)
{
    MovieInfo = Data;
}

// Export UGFxMoviePlayer::execSetTimingMode(FFrame&, void* const)
native function SetTimingMode(GFxMoviePlayer.GFxTimingMode Mode);

function SetExternalInterface(Object H)
{
    ExternalInterface = H;
}

// Export UGFxMoviePlayer::execSetExternalTexture(FFrame&, void* const)
native function bool SetExternalTexture(string Resource, Texture Texture);

// Export UGFxMoviePlayer::execSetPriority(FFrame&, void* const)
native function SetPriority(byte NewPriority);

// Export UGFxMoviePlayer::execGetGameViewportClient(FFrame&, void* const)
native final function GameViewportClient GetGameViewportClient();

// Export UGFxMoviePlayer::execIsViewportInFocus(FFrame&, void* const)
native final function bool IsViewportInFocus();

// Export UGFxMoviePlayer::execSetViewport(FFrame&, void* const)
native final function SetViewport(int X, int Y, int Width, int Height);

// Export UGFxMoviePlayer::execSetViewScaleMode(FFrame&, void* const)
native final function SetViewScaleMode(GFxMoviePlayer.GFxScaleMode SM);

// Export UGFxMoviePlayer::execSetAlignment(FFrame&, void* const)
native final function SetAlignment(GFxMoviePlayer.GFxAlign A);

// Export UGFxMoviePlayer::execGetVisibleFrameRect(FFrame&, void* const)
native final function GetVisibleFrameRect(out float x0, out float y0, out float X1, out float Y1);

// Export UGFxMoviePlayer::execSetView3D(FFrame&, void* const)
native final function SetView3D(const out Matrix matView);

// Export UGFxMoviePlayer::execSetPerspective3D(FFrame&, void* const)
native final function SetPerspective3D(const out Matrix matPersp);

// Export UGFxMoviePlayer::execSetMovieCanReceiveFocus(FFrame&, void* const)
native final function SetMovieCanReceiveFocus(bool bCanReceiveFocus);

// Export UGFxMoviePlayer::execSetMovieCanReceiveInput(FFrame&, void* const)
native final function SetMovieCanReceiveInput(bool bCanReceiveInput);

// Export UGFxMoviePlayer::execAddCaptureKey(FFrame&, void* const)
native final function AddCaptureKey(name Key);

// Export UGFxMoviePlayer::execClearCaptureKeys(FFrame&, void* const)
native final function ClearCaptureKeys();

// Export UGFxMoviePlayer::execAddFocusIgnoreKey(FFrame&, void* const)
native final function AddFocusIgnoreKey(name Key);

// Export UGFxMoviePlayer::execClearFocusIgnoreKeys(FFrame&, void* const)
native final function ClearFocusIgnoreKeys();

// Export UGFxMoviePlayer::execFlushPlayerInput(FFrame&, void* const)
native final function FlushPlayerInput(bool capturekeysonly);

event bool FilterButtonInput(int ControllerId, name ButtonName, Core.Object.EInputEvent InputEvent);

// Export UGFxMoviePlayer::execGetAVMVersion(FFrame&, void* const)
native function int GetAVMVersion();

// Export UGFxMoviePlayer::execGetVariable(FFrame&, void* const)
native function ASValue GetVariable(string Path);

// Export UGFxMoviePlayer::execGetVariableBool(FFrame&, void* const)
native function bool GetVariableBool(string Path);

// Export UGFxMoviePlayer::execGetVariableNumber(FFrame&, void* const)
native function float GetVariableNumber(string Path);

// Export UGFxMoviePlayer::execGetVariableInt(FFrame&, void* const)
native function int GetVariableInt(string Path);

// Export UGFxMoviePlayer::execGetVariableString(FFrame&, void* const)
native function string GetVariableString(string Path);

// Export UGFxMoviePlayer::execGetVariableObject(FFrame&, void* const)
native function GFxObject GetVariableObject(string Path, optional class<GFxObject> Type);

// Export UGFxMoviePlayer::execSetVariable(FFrame&, void* const)
native function SetVariable(string Path, ASValue Arg);

// Export UGFxMoviePlayer::execSetVariableBool(FFrame&, void* const)
native function SetVariableBool(string Path, bool B);

// Export UGFxMoviePlayer::execSetVariableNumber(FFrame&, void* const)
native function SetVariableNumber(string Path, float F);

// Export UGFxMoviePlayer::execSetVariableInt(FFrame&, void* const)
native function SetVariableInt(string Path, int I);

// Export UGFxMoviePlayer::execSetVariableString(FFrame&, void* const)
native function SetVariableString(string Path, string S);

// Export UGFxMoviePlayer::execSetVariableObject(FFrame&, void* const)
native function SetVariableObject(string Path, GFxObject Object);

// Export UGFxMoviePlayer::execGetVariableArray(FFrame&, void* const)
native function bool GetVariableArray(string Path, int Index, out array<ASValue> Arg);

// Export UGFxMoviePlayer::execGetVariableIntArray(FFrame&, void* const)
native function bool GetVariableIntArray(string Path, int Index, out array<int> Arg);

// Export UGFxMoviePlayer::execGetVariableFloatArray(FFrame&, void* const)
native function bool GetVariableFloatArray(string Path, int Index, out array<float> Arg);

// Export UGFxMoviePlayer::execGetVariableStringArray(FFrame&, void* const)
native function bool GetVariableStringArray(string Path, int Index, out array<string> Arg);

// Export UGFxMoviePlayer::execSetVariableArray(FFrame&, void* const)
native function bool SetVariableArray(string Path, int Index, array<ASValue> Arg);

// Export UGFxMoviePlayer::execSetVariableIntArray(FFrame&, void* const)
native function bool SetVariableIntArray(string Path, int Index, array<int> Arg);

// Export UGFxMoviePlayer::execSetVariableFloatArray(FFrame&, void* const)
native function bool SetVariableFloatArray(string Path, int Index, array<float> Arg);

// Export UGFxMoviePlayer::execSetVariableStringArray(FFrame&, void* const)
native function bool SetVariableStringArray(string Path, int Index, array<string> Arg);

// Export UGFxMoviePlayer::execCreateObject(FFrame&, void* const)
native function GFxObject CreateObject(string ASClass, optional class<GFxObject> Type, optional array<ASValue> args);

// Export UGFxMoviePlayer::execCreateArray(FFrame&, void* const)
native function GFxObject CreateArray();

// Export UGFxMoviePlayer::execActionScriptSetFunction(FFrame&, void* const)
protected native final function ActionScriptSetFunction(GFxObject Object, string Member);

// Export UGFxMoviePlayer::execInvoke(FFrame&, void* const)
native function ASValue Invoke(string method, array<ASValue> args);

// Export UGFxMoviePlayer::execActionScriptVoid(FFrame&, void* const)
protected native final function ActionScriptVoid(string Path);

// Export UGFxMoviePlayer::execActionScriptInt(FFrame&, void* const)
protected native final function int ActionScriptInt(string Path);

// Export UGFxMoviePlayer::execActionScriptFloat(FFrame&, void* const)
protected native final function float ActionScriptFloat(string Path);

// Export UGFxMoviePlayer::execActionScriptString(FFrame&, void* const)
protected native final function string ActionScriptString(string Path);

// Export UGFxMoviePlayer::execActionScriptObject(FFrame&, void* const)
protected native final function GFxObject ActionScriptObject(string Path);

// Export UGFxMoviePlayer::execActionScriptConstructor(FFrame&, void* const)
protected native final function GFxObject ActionScriptConstructor(string ClassName);

event bool WidgetInitialized(name WidgetName, name WidgetPath, GFxObject Widget);

event bool WidgetUnloaded(name WidgetName, name WidgetPath, GFxObject Widget);

event PostWidgetInit();

// Export UGFxMoviePlayer::execSetWidgetPathBinding(FFrame&, void* const)
native final function SetWidgetPathBinding(GFxObject WidgetToBind, name Path);

function Init(optional LocalPlayer LocPlay)
{
    LocalPlayerOwnerIndex = Class'Engine'.static.GetEngine().GamePlayers.Find(LocPlay;
    if(LocalPlayerOwnerIndex == -1)
    {
        LocalPlayerOwnerIndex = 0;
    }
    if(MovieInfo != none)
    {
        if(bAutoPlay)
        {
            Start();
            Advance(0);
        }
    }
}

event LocalPlayer GetLP()
{
    local Engine Eng;

    Eng = Class'Engine'.static.GetEngine();
    if(LocalPlayerOwnerIndex < 0)
    {
        LocalPlayerOwnerIndex = 0;        
    }
    else
    {
        if(LocalPlayerOwnerIndex >= Eng.GamePlayers.Length)
        {
            return none;
        }
    }
    return Eng.GamePlayers[LocalPlayerOwnerIndex];
}

event PlayerController GetPC()
{
    local LocalPlayer LocalPlayerOwner;

    LocalPlayerOwner = GetLP();
    if(LocalPlayerOwner == none)
    {
        return none;
    }
    return LocalPlayerOwner.Actor;
}

function ConsoleCommand(string Command)
{
    local PlayerController PC;

    PC = GetPC();
    if(PC != none)
    {        
        PC.ConsoleCommand(Command);
    }
}

event OnFocusGained(int LocalPlayerIndex);

event OnFocusLost(int LocalPlayerIndex);

function PlaySoundFromTheme(name EventName, optional name SoundThemeName)
{
    local int ThemeIndex;
    local UISoundTheme Theme;

    SoundThemeName = 'Default';
    LogInternal((("gfcProcessSound Callback - Sound Theme: " $ string(SoundThemeName)) $ " SoundEvent: ") $ string(EventName), 'DevGFxUI');
    ThemeIndex = SoundThemes.Find('ThemeName', SoundThemeName;
    if(ThemeIndex != -1)
    {
        Theme = SoundThemes[ThemeIndex].Theme;
        if(Theme != none)
        {
            Theme.ProcessSoundEvent(EventName, GetPC());            
        }
        else
        {
            LogInternal("Invalid theme binding for theme " $ string(SoundThemeName), 'GearsUI');
        }        
    }
    else
    {
        LogInternal("Unable to find sound theme for movie " $ string(SoundThemeName), 'GearsUI');
    }
}

event ApplyPriorityEffect(bool bRequestedBlurState, bool bRequestedHiddenState)
{
    if((bRequestedHiddenState != bIsPriorityHidden) && !bRequestedHiddenState || !bIgnoreVisibilityEffect)
    {
        ApplyPriorityVisibilityEffect(!bRequestedHiddenState);
        bIsPriorityHidden = bRequestedHiddenState;
    }
    if((bRequestedBlurState != bIsPriorityBlurred) && !bRequestedBlurState || !bIgnoreBlurEffect)
    {
        ApplyPriorityBlurEffect(!bRequestedBlurState);
        bIsPriorityBlurred = bRequestedBlurState;
    }
}

function ApplyPriorityBlurEffect(bool bRemoveEffect);

function ApplyPriorityVisibilityEffect(bool bRemoveEffect);

// Export UGFxMoviePlayer::execUpdateSplitscreenLayout(FFrame&, void* const)
native function UpdateSplitscreenLayout();

defaultproperties
{
    bDisplayWithHudOff=true
    bAllowInput=true
    bAllowFocus=true
    bCloseOnLevelChange=true
    Priority=1
    SplitscreenLayoutYAdjust=-27
}