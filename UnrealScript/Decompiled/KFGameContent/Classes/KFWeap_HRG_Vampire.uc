/*******************************************************************************
 * KFWeap_HRG_Vampire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_HRG_Vampire extends KFWeap_FlameBase
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const SecondaryFireAnim = 'Alt_Fire';
const SecondaryFireIronAnim = 'Alt_Fire_Iron';
const SecondaryFireAnimEmpty = 'Alt_Fire_Empty';
const SecondaryFireIronAnimEmpty = 'Alt_Fire_Iron_Empty';

var float MaxChargeAmmo;
var float ChargeSpeed;
var float MinDamageWhileChargingThreshold;
var float ValueIncreaseTime;
var float DmgIncreasePerCharge;
var float AOEIncreasePerCharge;
var float IncapIncreasePerCharge;
var transient float ChargeTime;
var transient float CurrentCharge;
var transient float CurrentChargeOrigin;
var transient float CurrentChargeDesired;
var transient float CurrentChargeAmmo;
var transient float CurrentChargeAccumulatedTime;
var transient float CurrentChargeForBloodBallProjectile;
var ParticleSystem ChargingEffect;
var ParticleSystem ChargedEffect;
var ParticleSystem BloodStolenEffect;
var const ParticleSystem MuzzleFlashEffectL3;
var export editinline transient ParticleSystemComponent FullyChargedPSC;
var export editinline transient ParticleSystemComponent ChargingPSC;
var KFEmit_DirectionalPath BloodStolenParticles[15];
var int NumBloodStolenParticlesForPool;
var float SpeedBloodParticlesDefault;
var float SpawnRateBloodParticlesDefault;
var float HalfAngleSpawnConeDefault;
var float CurveTurnRateUntilDestinationMidPointDefault;
var float CurveTurnRateUntilDestinationFinalDefault;
var float LimitDistanceMidPointDefault;
var float LimitDistanceFinalPointDefault;
var transient float BloodStolenControlTime;
var transient bool bHasCharged;
var bool bIsSprayDisabled;
var bool bHasToLaunchEmptyAnim;
var bool bBlocked;
var transient bool bFirstBloodParticleCreated;
var transient bool bIsAlreadyInitializedFX;
var transient bool bIsFullCharged;
var transient bool bIsChargingSoundStarted;
var repnotify bool bClientDisableSprayVisualAndMesh;
var const WeaponFireSndInfo FullyChargedSound;
var const WeaponFireSndInfo ChargingSound;
var const WeaponFireSndInfo ChargedSound;
var const WeaponFireSndInfo BloodSuctionStartSound;
var const WeaponFireSndInfo BloodSuctionEndSound;
var const WeaponFireSndInfo BloodSuctionLoopNoAmmoAndBloodBallChargedSound;
var float SelfDamageReductionValue;
var float FullChargedTimerInterval;
var float ChargePercentage;
var float DamageByChargePercentage;
var float MinScale;
var float MaxScale;
var int MaxDamageByCharge;
var int MinDamageByCharge;
var SkelControlSingleBone Control;
/** Shoot animation to play when shooting secondary fire */
var(Animations) const editconst name FireHeavyAnim;
/** Shoot animation to play when shooting secondary fire last shot */
var(Animations) const editconst name FireLastHeavyAnim;
/** Shoot animation to play when shooting secondary fire last shot when aiming */
var(Animations) const editconst name FireLastHeavySightedAnim;
/** Alt-fire explosion template */
var() GameExplosion ExplosionTemplate;
var float ReplenishingAmmoOnSuctioningTime;
var float ReplenishingAmmoOnSuctioningInterval;
var int ReplenishingAmmoOnSuctioningCount;
var class<KFProjectile> BloodBallProjClass;
var float SpeedBloodParticles;
var float SpawnRateBloodParticles;
var float HalfAngleSpawnCone;
var float CurveTurnRateUntilDestinationMidPoint;
var float CurveTurnRateUntilDestinationFinal;
var float LimitDistanceMidPoint;
var float LimitDistanceFinalPoint;
var float RateUpdateDestinationBloodParticles;
var transient float UpdateDestinationBloodParticlesTime;
var int InitialAmmoSecondaryCount;
var float AmmoCostScaleDefaultFiremode;
var float AmmoCostAccumulated;
var transient float DelayUntilStartCharging;
var float ScaleDelayUntilStartCharging;
var transient float CurrentStartChargingTime;
var class<KFProj_BloodSplash> BloodSplashClass;
var transient float TimesConsumeAmmoCalled;
var KFPawn_Monster oZedPreviouslyBeingSprayed;
var repnotify KFPawn_Monster oZedCurrentlyBeingSprayed;
var repnotify float ClientChargePercentage;
var repnotify float ClientCurrentChargeDesired;

replication
{
     if(bNetDirty)
        ChargeTime, ClientCurrentChargeDesired, 
        oZedCurrentlyBeingSprayed;

     if(bNetDirty && !bNetOwner)
        ClientChargePercentage, bClientDisableSprayVisualAndMesh;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'ClientChargePercentage')
    {
        NotifyChargePercentage(ClientChargePercentage);
    }
    if(VarName == 'oZedCurrentlyBeingSprayed')
    {
        NotifyZedCurrentlyBeingSprayed(oZedCurrentlyBeingSprayed);
    }
    if((VarName == 'bClientDisableSprayVisualAndMesh') && bClientDisableSprayVisualAndMesh)
    {
        NotifyDisableSprayVisualAndMesh();
    }
    if(VarName == 'ClientCurrentChargeDesired')
    {
        CurrentChargeDesired = ClientCurrentChargeDesired;
    }
    super(KFWeapon).ReplicatedEvent(VarName);
}

simulated function PostBeginPlay()
{
    local KFPawn_Human KFPH;
    local int Index;

    super(Actor).PostBeginPlay();
    AmmoCostAccumulated = 0;
    KFPH = KFPawn_Human(Instigator);
    bIsAlreadyInitializedFX = false;
    if((WorldInfo.NetMode == NM_DedicatedServer) || (KFPH != none) && !KFPH.IsFirstPerson())
    {
        return;
    }
    UpdateDestinationBloodParticlesTime = RateUpdateDestinationBloodParticles;
    bFirstBloodParticleCreated = false;
    CurrentStartChargingTime = DelayUntilStartCharging * ScaleDelayUntilStartCharging;
    Index = NumBloodStolenParticlesForPool - 1;
    J0xF6:

    if(Index >= 0)
    {
        BloodStolenParticles[Index] = Spawn(Class'KFEmit_DirectionalPath');
        BloodStolenParticles[Index].SetTemplate(BloodStolenEffect, true);
        BloodStolenParticles[Index].DeactivateEmitter();
        -- Index;
        goto J0xF6;
    }
}

simulated event Tick(float DeltaTime)
{
    return;
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    local bool bPlayFireLast;

    bPlayFireLast = ShouldPlayFireLast(FireModeNum);
    if(FireModeNum == 6)
    {
        return FireLoopEndAnim;
    }
    if(bUsingSights)
    {
        if(bPlayFireLast)
        {
            if(FireModeNum == 1)
            {
                return FireLastHeavySightedAnim;                
            }
            else
            {
                return FireLastSightedAnim;
            }            
        }
        else
        {
            return FireSightedAnims[FireModeNum];
        }        
    }
    else
    {
        if(bPlayFireLast)
        {
            if(FireModeNum == 1)
            {
                return FireLastHeavyAnim;                
            }
            else
            {
                return FireLastAnim;
            }            
        }
        else
        {
            if(FireModeNum == 1)
            {
                return FireHeavyAnim;                
            }
            else
            {
                return FireAnim;
            }
        }
    }
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    StartFire(1);
}

simulated function bool ShouldAutoReload(byte FireModeNum)
{
    local bool bRequestReload;

    bRequestReload = super(KFWeapon).ShouldAutoReload(FireModeNum);
    if((FireModeNum == 1) && AmmoCount[0] > 0)
    {
        bPendingAutoSwitchOnDryFire = false;
        return false;
    }
    return bRequestReload;
}

static simulated event KFGame.KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter()
{
    return 5;
}

protected simulated function TurnOnPilot()
{
    super.TurnOnPilot();
    if(((FlamePool[0] != none) && KFSprayActor_HRG_Vampire(FlamePool[0]) != none) && KFSprayActor_HRG_Vampire(FlamePool[0]).OwnerWeapon == none)
    {
        KFSprayActor_HRG_Vampire(FlamePool[0]).OwnerWeapon = self;
    }
    if(((FlamePool[1] != none) && KFSprayActor_HRG_Vampire(FlamePool[1]) != none) && KFSprayActor_HRG_Vampire(FlamePool[1]).OwnerWeapon == none)
    {
        KFSprayActor_HRG_Vampire(FlamePool[1]).OwnerWeapon = self;
    }
}

simulated function float FlameHeatCalc()
{
    LastBarrelHeat = 1;
    return 1;
}

simulated function SetCurrentSprayedZed(KFPawn_Monster _Monster)
{
    if(((Role != ROLE_Authority) && WorldInfo.NetMode != NM_ListenServer) && WorldInfo.NetMode != NM_Standalone)
    {
        return;
    }
    oZedPreviouslyBeingSprayed = oZedCurrentlyBeingSprayed;
    oZedCurrentlyBeingSprayed = _Monster;
    bNetDirty = true;
    AmmoCostScaleDefaultFiremode = 1;
    if((oZedCurrentlyBeingSprayed == none) || !oZedCurrentlyBeingSprayed.IsAliveAndWell())
    {
        AmmoCostScaleDefaultFiremode = default.AmmoCostScaleDefaultFiremode;
    }
}

function DropFrom(Vector StartLocation, Vector StartVelocity)
{
    super(KFWeapon).DropFrom(StartLocation, StartVelocity);
    self.SetTickIsDisabled(true);
}

function SetOriginalValuesFromPickup(KFWeapon PickedUpWeapon)
{
    super(KFWeapon).SetOriginalValuesFromPickup(PickedUpWeapon);
    self.SetTickIsDisabled(false);
}

simulated function NotifyChargePercentage(float ChargePercentageNotified)
{
    local KFPawn KFPawn;
    local KFWeapAttach_HRG_Vampire KFWeapAttach;

    KFPawn = KFPawn(Instigator);
    KFWeapAttach = KFWeapAttach_HRG_Vampire(KFPawn.WeaponAttachment);
    if(KFWeapAttach != none)
    {
        KFWeapAttach.SetChargePercentage(ChargePercentageNotified);
    }
}

simulated function NotifyZedCurrentlyBeingSprayed(KFPawn_Monster Monster)
{
    local KFPawn KFPawn;
    local KFWeapAttach_HRG_Vampire KFWeapAttach;

    KFPawn = KFPawn(Instigator);
    KFWeapAttach = KFWeapAttach_HRG_Vampire(KFPawn.WeaponAttachment);
    if(KFWeapAttach != none)
    {
        KFWeapAttach.SetZedCurrentlyBeingSprayed(Monster);
    }
}

simulated function NotifyDisableSprayVisualAndMesh()
{
    local KFPawn KFPawn;
    local KFWeapAttach_HRG_Vampire KFWeapAttach;

    KFPawn = KFPawn(Instigator);
    KFWeapAttach = KFWeapAttach_HRG_Vampire(KFPawn.WeaponAttachment);
    if(KFWeapAttach != none)
    {
        KFWeapAttach.DisableSprayVisualAndMesh();
    }
}

simulated function CreateBloodParticle(KFPawn_Monster Monster)
{
    local KFEmit_DirectionalPath Emitter;
    local Vector DestinationLocation, MonsterLocation, BloodParticlesMidPointSocketLocation;
    local Rotator DestinationRotation, BloodParticlesMidPointSocketRotation;
    local Vector BloodSplashVelocity;
    local int Index;

    if(!IsInState('FiringSuctioning'))
    {
        return;
    }
    Emitter = none;
    Index = NumBloodStolenParticlesForPool - 1;
    J0x35:

    if(Index >= 0)
    {
        if(BloodStolenParticles[Index].IsEnabled == false)
        {
            Emitter = BloodStolenParticles[Index];
            goto J0xA1;
        }
        -- Index;
        goto J0x35;
    }
    J0xA1:

    if(Emitter == none)
    {
        return;
    }
    if(MySkelMesh != none)
    {
        GetFlameSocketLocAndRot(DestinationLocation, DestinationRotation);
        MySkelMesh.GetSocketWorldLocationAndRotation('BloodParticlesMidPoint', BloodParticlesMidPointSocketLocation, BloodParticlesMidPointSocketRotation);
    }
    MonsterLocation = ActiveFlameSpray.GetLastContactPositionMeshHit();
    if(IsZero(MonsterLocation))
    {
        Monster.Mesh.GetBoneLocation('Spine1');
    }
    if(MonsterLocation == vect(0, 0, 0))
    {
        MonsterLocation = Monster.Location + vect(0, 0, 20);
    }
    if(FRand() > 0.4)
    {
        BloodSplashVelocity = BloodParticlesMidPointSocketLocation - MonsterLocation;
        BloodSplashVelocity = VRandCone(vect(0, 0, -1), 3.141593 / float(5)) * float(100);
        SpawnBloodSplash(BloodSplashClass, MonsterLocation, BloodSplashVelocity);
    }
    Emitter.ParticleSpeed = SpeedBloodParticles;
    Emitter.SetLocation(MonsterLocation);
    Emitter.SetDestination(DestinationLocation, BloodParticlesMidPointSocketLocation, LimitDistanceFinalPoint, LimitDistanceMidPoint, CurveTurnRateUntilDestinationFinal, CurveTurnRateUntilDestinationMidPoint, HalfAngleSpawnCone);
    Emitter.ActivateEmitter();
}

simulated function SpawnBloodSplash(class<KFProj_BloodSplash> SpawnClass, Vector SpawnLoc, Vector SpawnVel)
{
    local TraceHitInfo HitInfo;
    local Vector HitLocation, HitRotation;
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager == none) || oZedCurrentlyBeingSprayed == none)
    {
        return;
    }
    Trace(HitLocation, HitRotation, SpawnLoc + (SpawnVel * 32), SpawnLoc, false,, HitInfo, 1);
    if(IsZero(HitLocation))
    {
        HitLocation = Location;
    }
    if(IsZero(HitRotation))
    {
        HitRotation = vect(0, 0, 1);
    }
    GoreManager.LeaveABloodSplatterDecal(oZedCurrentlyBeingSprayed, HitLocation, HitRotation);
    if(oZedCurrentlyBeingSprayed != none)
    {
        GoreManager.CausePersistentBlood(oZedCurrentlyBeingSprayed, Class'KFDamageType', HitLocation, vect(0, 0, -1), 0, false, false);
    }
}

simulated function RemoveAllBloodParticles()
{
    local int Index;
    local KFEmit_DirectionalPath EmitterToRemove;

    Index = NumBloodStolenParticlesForPool - 1;
    J0x16:

    if(Index >= 0)
    {
        EmitterToRemove = BloodStolenParticles[Index];
        EmitterToRemove.DeactivateEmitter();
        -- Index;
        goto J0x16;
    }
}

simulated function OnStartFire()
{
    local KFPawn PawnInst;

    PawnInst = KFPawn(Instigator);
    if(PawnInst != none)
    {
        PawnInst.OnStartFire();
    }
}

simulated function InitBloodBallFX()
{
    if(FullyChargedPSC == none)
    {
        FullyChargedPSC = new (self) Class'ParticleSystemComponent';
        if(MySkelMesh != none)
        {
            MySkelMesh.AttachComponentToSocket(FullyChargedPSC, 'MuzzleFlash');            
        }
        else
        {
            AttachComponent(FullyChargedPSC);
        }
        FullyChargedPSC.SetTemplate(ChargedEffect);
    }
    FullyChargedPSC.SetActive(false);
    if(ChargingPSC == none)
    {
        ChargingPSC = new (self) Class'ParticleSystemComponent';
        if(MySkelMesh != none)
        {
            MySkelMesh.AttachComponentToSocket(ChargingPSC, 'MuzzleFlash');            
        }
        else
        {
            AttachComponent(ChargingPSC);
        }
        ChargingPSC.SetTemplate(ChargingEffect);
    }
    ChargingPSC.SetActive(false);
}

simulated function Timer_StopFireEffects()
{
    if(WorldInfo.NetMode == NM_Client)
    {
        Instigator.WeaponStoppedFiring(self, false);
    }
    ClearFlashCount();
    ClearFlashLocation();
}

simulated function name GetLoopEndFireAnim(byte FireModeNum)
{
    if(FireModeNum == 0)
    {
        return 'None';
    }
    return super(KFWeapon).GetLoopEndFireAnim(FireModeNum);
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProj_BloodBall_HRG_Vampire BloodBall;
    local KFProjectile Projectile;

    Projectile = super(KFWeapon).SpawnProjectile(KFProjClass, RealStartLoc, AimDir);
    BloodBall = KFProj_BloodBall_HRG_Vampire(Projectile);
    if(BloodBall != none)
    {
        BloodBall.SetInheritedScale(CurrentChargeForBloodBallProjectile, DamageByChargePercentage);
        return BloodBall;
    }
    return Projectile;
}

simulated function DisableRecoil()
{
    maxRecoilPitch = 0;
    minRecoilPitch = 0;
    maxRecoilYaw = 0;
    minRecoilYaw = 0;
}

simulated function RestoreRecoil()
{
    maxRecoilPitch = default.maxRecoilPitch;
    minRecoilPitch = default.minRecoilPitch;
    maxRecoilYaw = default.maxRecoilYaw;
    minRecoilYaw = default.minRecoilYaw;
}

function InitializeAmmo()
{
    super(KFWeapon).InitializeAmmo();
    AmmoCount[1] = InitialAmmoSecondaryCount;
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    local byte AmmoType;
    local KFPerk InstigatorPerk;

    if(FireModeNum == 0)
    {
        AmmoType = byte(GetAmmoType(FireModeNum));
        InstigatorPerk = GetPerk();
        if((InstigatorPerk != none) && InstigatorPerk.GetIsUberAmmoActive(self))
        {
            return;
        }
        TimesConsumeAmmoCalled += float(AmmoCost[FireModeNum]);
        if((Role == ROLE_Authority) || bAllowClientAmmoTracking)
        {
            if((MagazineCapacity[AmmoType] > 0) && AmmoCount[AmmoType] > 0)
            {
                AmmoCostAccumulated += (float(AmmoCost[FireModeNum]) * AmmoCostScaleDefaultFiremode);
                CurrentChargeDesired = FMin(1, (float(AmmoConsumed) + AmmoCostAccumulated) / MaxChargeAmmo);
                if(CurrentChargeDesired > float(0))
                {
                    bHasCharged = true;
                }
                if(WorldInfo.NetMode == NM_DedicatedServer)
                {
                    ClientCurrentChargeDesired = CurrentChargeDesired;
                }
                if(AmmoCostAccumulated >= float(AmmoCost[FireModeNum]))
                {
                    AmmoCostAccumulated = 0;
                    AmmoConsumed += AmmoCost[CurrentFireMode];
                    CurrentChargeDesired = FMin(1, float(AmmoConsumed) / MaxChargeAmmo);
                    if(WorldInfo.NetMode == NM_DedicatedServer)
                    {
                        ClientCurrentChargeDesired = CurrentChargeDesired;
                    }
                    AmmoCount[AmmoType] = Max(AmmoCount[AmmoType] - AmmoCost[FireModeNum], 0);
                }
            }
        }
        return;        
    }
    else
    {
        super(KFWeapon).ConsumeAmmo(FireModeNum);
    }
}

simulated function Timer_CreateBloodParticle()
{
    if((oZedCurrentlyBeingSprayed != none) && oZedCurrentlyBeingSprayed.IsAliveAndWell())
    {
        CreateBloodParticle(oZedCurrentlyBeingSprayed);
    }
}

simulated function PerformReload(optional byte FireModeNum)
{
    super(KFWeapon).PerformReload(FireModeNum);
    if(((Role != ROLE_Authority) && WorldInfo.NetMode != NM_ListenServer) && WorldInfo.NetMode != NM_Standalone)
    {
        SetTimer(0.09, true, 'Timer_CheckPendingFire');
        SetTimer(0.5, false, 'Timer_EndCheckPendingFire');
    }
}

simulated function Timer_CheckPendingFire()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < GetPendingFireLength())
    {
        if(PendingFire(I))
        {
            BeginFire(byte(I));
            ClearTimer('Timer_CheckPendingFire');
            goto J0x73;
        }
        ++ I;
        goto J0x0B;
    }
    J0x73:

}

simulated function Timer_EndCheckPendingFire()
{
    ClearTimer('Timer_CheckPendingFire');
}

simulated state FiringSuctioning extends SprayingFire
{
    simulated event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        NotifyBeginState();
        if(KFPawn(Owner).IsLocallyControlled())
        {
            PlaySoundBase(BloodSuctionStartSound.FirstPersonCue);            
        }
        else
        {
            PlaySoundBase(BloodSuctionStartSound.DefaultCue);
        }
        CurrentCharge = 0;
        bHasCharged = false;
        global.OnStartFire();
        bIsSprayDisabled = false;
        AmmoCostScaleDefaultFiremode = default.AmmoCostScaleDefaultFiremode;
        CurrentCharge = 0;
        CurrentChargeOrigin = 0;
        CurrentChargeDesired = 0;
        CurrentChargeForBloodBallProjectile = 0;
        if(WorldInfo.NetMode == NM_DedicatedServer)
        {
            ClientCurrentChargeDesired = 0;
        }
        TimesConsumeAmmoCalled = 0;
        bIsChargingSoundStarted = false;
    }

    simulated function EndState(name NextStateName)
    {
        local KFPawn_Human KFPH;

        super.EndState(NextStateName);
        NotifyEndState();
        ClearZedTimeResist();
        ClearPendingFire(CurrentFireMode);
        ClearTimer('RefireCheckTimer');
        KFPawn(Instigator).bHasStartedFire = false;
        KFPawn(Instigator).bNetDirty = true;
        if((oZedCurrentlyBeingSprayed == none) || !oZedCurrentlyBeingSprayed.IsAliveAndWell())
        {
            if(KFPawn(Owner).IsLocallyControlled())
            {
                PlaySoundBase(BloodSuctionEndSound.FirstPersonCue);                
            }
            else
            {
                PlaySoundBase(BloodSuctionEndSound.DefaultCue);
            }
        }
        KFPawn(Instigator).SetWeaponAmbientSound(none);
        KFPawn(Instigator).SetSecondaryWeaponAmbientSound(none);
        KFPH = KFPawn_Human(Instigator);
        if(!WorldInfo.NetMode == NM_DedicatedServer || !(KFPH != none) && !KFPH.IsFirstPerson())
        {
            RemoveAllBloodParticles();
            CurrentChargeAccumulatedTime = 0;
            if(ChargingPSC != none)
            {
                ChargingPSC.SetActive(false);
            }
            if(FullyChargedPSC != none)
            {
                FullyChargedPSC.SetActive(false);
            }
        }
        CurrentChargeForBloodBallProjectile = CurrentChargeDesired;
        CurrentCharge = 0;
        CurrentChargeOrigin = 0;
        CurrentChargeDesired = 0;
    }

    simulated function bool ShouldRefire()
    {
        if(!HasAmmo(CurrentFireMode))
        {
            return StillFiring(CurrentFireMode);
        }
        return (StillFiring(CurrentFireMode)) || TimesConsumeAmmoCalled < float(MinAmmoConsumed);
    }

    simulated function ConsumeAmmo(byte FireMode)
    {
        global.ConsumeAmmo(FireMode);
    }

    simulated event Tick(float DeltaTime)
    {
        local int Index;
        local Vector MuzzleFlashSocketLocation, BloodParticlesMidPointSocketLocation;
        local Rotator DestinationRotation, BloodParticlesMidPointSocketRotation;
        local KFEmit_DirectionalPath EmitterToRemove;
        local Vector VectorParameterParticle, BloodSplashVelocity;
        local KFPawn_Human KFPH;
        local Vector ChargePercentageVector;
        local float InstantHitDamageValue;

        super(WeaponFiring).Tick(DeltaTime);
        if(!HasAmmo(CurrentFireMode) && !bIsSprayDisabled)
        {
            if(CurrentChargeDesired <= float(0))
            {
                GotoState('Active');                
            }
            else
            {
                TurnOffFireSpray();
                KFPawn(Instigator).SetWeaponAmbientSound(BloodSuctionLoopNoAmmoAndBloodBallChargedSound.DefaultCue, BloodSuctionLoopNoAmmoAndBloodBallChargedSound.FirstPersonCue);
                KFPawn(Instigator).SetSecondaryWeaponAmbientSound(none, none);
                oZedCurrentlyBeingSprayed = none;
                DisableRecoil();
                bIsSprayDisabled = true;
                bClientDisableSprayVisualAndMesh = true;
            }
        }
        if(oZedCurrentlyBeingSprayed == none)
        {
            bIsChargingSoundStarted = false;
            KFPawn(Instigator).SetSecondaryWeaponAmbientSound(none, none);
        }
        if((oZedCurrentlyBeingSprayed != none) && oZedCurrentlyBeingSprayed.IsAliveAndWell())
        {
            ReplenishingAmmoOnSuctioningTime -= DeltaTime;
            if(ReplenishingAmmoOnSuctioningTime <= float(0))
            {
                AmmoCount[1] = Min(MagazineCapacity[1], AmmoCount[1] + ReplenishingAmmoOnSuctioningCount);
                ReplenishingAmmoOnSuctioningTime += ReplenishingAmmoOnSuctioningInterval;
            }
            if(CurrentChargeDesired > float(0))
            {
                DamageByChargePercentage = FMin((CurrentChargeDesired - MinDamageWhileChargingThreshold) / (float(1) - MinDamageWhileChargingThreshold), 1);
                InstantHitDamageValue = FMax(float(MinDamageByCharge), Lerp(float(MinDamageByCharge), float(MaxDamageByCharge), DamageByChargePercentage));
                InstantHitDamage[6] = InstantHitDamageValue;
                InstantHitDamageTypes[6] = Class'KFDT_Ballistic_HRG_Vampire_BloodBallImpact';
                if(CurrentChargeDesired >= 1)
                {
                    InstantHitDamageTypes[6] = Class'KFDT_Ballistic_HRG_Vampire_BloodBallHeavyImpact';
                }
                KFPawn(Instigator).SetWeaponComponentRTPCValue("Weapon_Charge", CurrentChargeDesired);
                Instigator.SetRTPCValue('Weapon_Charge', CurrentChargeDesired);
                if(WorldInfo.NetMode == NM_DedicatedServer)
                {
                    ClientChargePercentage = CurrentChargeDesired;
                }
                if(!bIsChargingSoundStarted)
                {
                    KFPawn(Instigator).SetSecondaryWeaponAmbientSound(ChargingSound.DefaultCue, ChargingSound.FirstPersonCue);
                }
                bIsChargingSoundStarted = true;
            }
        }
        KFPH = KFPawn_Human(Instigator);
        if((WorldInfo.NetMode == NM_DedicatedServer) || (KFPH != none) && !KFPH.IsFirstPerson())
        {
            return;
        }
        UpdateDestinationBloodParticlesTime -= DeltaTime;
        if(UpdateDestinationBloodParticlesTime <= float(0))
        {
            UpdateDestinationBloodParticlesTime = RateUpdateDestinationBloodParticles;
            GetFlameSocketLocAndRot(MuzzleFlashSocketLocation, DestinationRotation);
            if(MySkelMesh != none)
            {
                MySkelMesh.GetSocketWorldLocationAndRotation('BloodParticlesMidPoint', BloodParticlesMidPointSocketLocation, BloodParticlesMidPointSocketRotation);
            }
            Index = NumBloodStolenParticlesForPool - 1;
            J0x52E:

            if(Index >= 0)
            {
                if(!BloodStolenParticles[Index].IsEnabled || BloodStolenParticles[Index] == none)
                {                    
                }
                else
                {
                    if(BloodStolenParticles[Index].bReachDestinationFinal)
                    {
                        EmitterToRemove = BloodStolenParticles[Index];
                        EmitterToRemove.DeactivateEmitter();                        
                    }
                    else
                    {
                        if(BloodStolenParticles[Index].ParticleSystemComponent != none)
                        {
                            VectorParameterParticle.X = WorldInfo.TimeDilation;
                            VectorParameterParticle.Y = WorldInfo.TimeDilation;
                            VectorParameterParticle.Z = WorldInfo.TimeDilation;
                            BloodStolenParticles[Index].ParticleSystemComponent.SetVectorParameter(name("ZedtimeScale"), VectorParameterParticle);
                        }
                        BloodStolenParticles[Index].UpdateDestination(MuzzleFlashSocketLocation, BloodParticlesMidPointSocketLocation);
                        if(FRand() > 0.8)
                        {
                            BloodSplashVelocity.X = 0;
                            BloodSplashVelocity.Y = RandRange(-100, 100);
                            BloodSplashVelocity.Z = -200;
                            SpawnBloodSplash(BloodSplashClass, BloodStolenParticles[Index].Location, BloodSplashVelocity);
                        }
                    }
                }
                -- Index;
                goto J0x52E;
            }
        }
        Index = NumBloodStolenParticlesForPool - 1;
        J0x84E:

        if(Index >= 0)
        {
            if(BloodStolenParticles[Index].IsEnabled == true)
            {
                bFirstBloodParticleCreated = true;
            }
            -- Index;
            goto J0x84E;
        }
        CurrentStartChargingTime = FMax(0, CurrentStartChargingTime - DeltaTime);
        if((CurrentChargeDesired > float(0)) && CurrentStartChargingTime <= float(0))
        {
            CurrentChargeAccumulatedTime = FMin(CurrentChargeAccumulatedTime + (DeltaTime * ChargeSpeed), CurrentChargeDesired);
            CurrentCharge = CurrentChargeAccumulatedTime;
        }
        if(CurrentCharge > float(0))
        {
            if(ChargingPSC != none)
            {
                ChargingPSC.SetActive(true, true);
                ChargePercentageVector.X = CurrentCharge;
                ChargePercentageVector.Y = CurrentCharge;
                ChargePercentageVector.Z = CurrentCharge;
                ChargingPSC.SetVectorParameter(name("BlobCharge"), ChargePercentageVector);
            }
            if((FullyChargedPSC != none) && CurrentCharge >= 1)
            {
                if(!bIsFullCharged)
                {
                    if(KFPawn(Owner).IsLocallyControlled())
                    {
                        PlaySoundBase(ChargedSound.FirstPersonCue);                        
                    }
                    else
                    {
                        PlaySoundBase(ChargedSound.DefaultCue);
                    }
                }
                bIsFullCharged = true;
                FullyChargedPSC.SetActive(true, true);
            }
        }
    }

    simulated function HandleFinishedFiring()
    {
        if(bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
        SetTimer(0.1, false, 'Timer_StopFireEffects');
        NotifyWeaponFinishedFiring(CurrentFireMode);
        super(Weapon).HandleFinishedFiring();
    }

    simulated function PutDownWeapon()
    {
        if(bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
        SetTimer(0.1, false, 'Timer_StopFireEffects');
        NotifyWeaponFinishedFiring(CurrentFireMode);
        super(Weapon).PutDownWeapon();
    }
    stop;    
}

simulated state Active
{
    simulated event BeginState(name PreviousStateName)
    {
        local KFPawn KFPawn;
        local KFWeapAttach_HRG_Vampire KFWeapAttach;

        if(((PreviousStateName == 'FiringSuctioning') && Role == ROLE_Authority) && bHasCharged)
        {
            StartFire(6);
        }
        super.BeginState(PreviousStateName);
        RestoreRecoil();
        bClientDisableSprayVisualAndMesh = false;
        bHasCharged = false;
        bIsFullCharged = false;
        if((WorldInfo.NetMode == NM_DedicatedServer) || bIsAlreadyInitializedFX)
        {
            return;
        }
        KFPawn = KFPawn(Instigator);
        KFWeapAttach = KFWeapAttach_HRG_Vampire(KFPawn.WeaponAttachment);
        if(KFWeapAttach != none)
        {
            SpeedBloodParticles = KFWeapAttach.SpeedBloodParticles;
            SpawnRateBloodParticles = KFWeapAttach.SpawnRateBloodParticles;
            HalfAngleSpawnCone = KFWeapAttach.HalfAngleSpawnCone;
            CurveTurnRateUntilDestinationMidPoint = KFWeapAttach.CurveTurnRateUntilDestinationMidPoint;
            CurveTurnRateUntilDestinationFinal = KFWeapAttach.CurveTurnRateUntilDestinationFinal;
            LimitDistanceMidPoint = KFWeapAttach.LimitDistanceMidPoint;
            LimitDistanceFinalPoint = KFWeapAttach.LimitDistanceFinalPoint;
        }
        if(SpeedBloodParticles <= float(0))
        {
            SpeedBloodParticles = SpeedBloodParticlesDefault;
        }
        if(SpawnRateBloodParticles <= float(0))
        {
            SpawnRateBloodParticles = SpawnRateBloodParticlesDefault;
        }
        if(HalfAngleSpawnCone <= float(0))
        {
            HalfAngleSpawnCone = HalfAngleSpawnConeDefault;
        }
        if(CurveTurnRateUntilDestinationMidPoint <= float(0))
        {
            CurveTurnRateUntilDestinationMidPoint = CurveTurnRateUntilDestinationMidPointDefault;
        }
        if(CurveTurnRateUntilDestinationFinal <= float(0))
        {
            CurveTurnRateUntilDestinationFinal = CurveTurnRateUntilDestinationFinalDefault;
        }
        if(LimitDistanceMidPoint <= float(0))
        {
            LimitDistanceMidPoint = LimitDistanceMidPointDefault;
        }
        if(LimitDistanceFinalPoint <= float(0))
        {
            LimitDistanceFinalPoint = LimitDistanceFinalPointDefault;
        }
        if((KFPawn != none) && !KFPawn.IsFirstPerson())
        {
            return;
        }
        InitBloodBallFX();
        SetTimer(SpawnRateBloodParticles, true, 'Timer_CreateBloodParticle');
        bIsAlreadyInitializedFX = true;
    }
    stop;    
}

defaultproperties
{
    MaxChargeAmmo=10
    ChargeSpeed=1
    MinDamageWhileChargingThreshold=0.12
    ValueIncreaseTime=0.2
    ChargingEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_BlobCharge_01'
    ChargedEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_FullCharge'
    BloodStolenEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_BloodStolen'
    NumBloodStolenParticlesForPool=15
    SpeedBloodParticlesDefault=750
    SpawnRateBloodParticlesDefault=0.1
    HalfAngleSpawnConeDefault=45
    CurveTurnRateUntilDestinationMidPointDefault=0.6
    CurveTurnRateUntilDestinationFinalDefault=4
    LimitDistanceMidPointDefault=16
    LimitDistanceFinalPointDefault=12
    ChargingSound=(DefaultCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Loop_3P',FirstPersonCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Loop_1P')
    ChargedSound=(DefaultCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Charged_3P',FirstPersonCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Charged_1P')
    BloodSuctionStartSound=(DefaultCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_3P_Start',FirstPersonCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_1P_Start')
    BloodSuctionEndSound=(DefaultCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_3P_End',FirstPersonCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_1P_End')
    BloodSuctionLoopNoAmmoAndBloodBallChargedSound=(DefaultCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Charged_Loop_3P',FirstPersonCue=AkEvent'WW_WEP_HRG_Vampire.Play_WEP_HRG_Vampire_SuckBlood_Charged_Loop_1P')
    SelfDamageReductionValue=0.1
    FullChargedTimerInterval=2
    MinScale=0.5
    MaxScale=4.5
    MaxDamageByCharge=150
    MinDamageByCharge=15
    FireHeavyAnim=Shoot_Heavy
    FireLastHeavyAnim=Shoot_Heavy_Last
    FireLastHeavySightedAnim=Shoot_Heavy_Iron_Last
    ReplenishingAmmoOnSuctioningInterval=0.04
    ReplenishingAmmoOnSuctioningCount=1
    BloodBallProjClass=Class'KFProj_BloodBall_HRG_Vampire'
    RateUpdateDestinationBloodParticles=0.2
    ScaleDelayUntilStartCharging=0.2
    BloodSplashClass=Class'KFProj_BloodSplash'
    bWarnAIWhenFiring=true
    FlameSprayArchetype=KFSprayActor_HRG_Vampire'WEP_HRG_Vampire_Arch.WEP_HRG_Vampire_Spray'
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_HRG_Vampire.PilotLight0'
    PSC_PilotLight=PilotLight0
    begin object name=FlameEndSpray0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_HRG_Vampire.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    MinAmmoConsumed=4
    PackageKey="HRG_Vampire"
    FirstPersonMeshName="WEP_1P_HRG_Vampire_MESH.Wep_1stP_HRG_Vampire_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="WEP_3P_HRG_Vampire_MESH.Wep_3rdP_HRG_Vampire_Pickup"
    AttachmentArchetypeName="WEP_HRG_Vampire_ARCH.WEP_HRG_Vampire_3P"
    MuzzleFlashTemplateName="WEP_HRG_Vampire_ARCH.Wep_HRG_Vampire_MuzzleFlash"
    bHasIronSights=true
    bCanRefillSecondaryAmmo=false
    bCanBeReloaded=true
    bReloadFromMagazine=true
    bAllowClientAmmoTracking=false
    bHasFireLastAnims=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=8
    PenetrationPower=/* Array type was not detected. */
    MeshFOV=80
    MeshIronSightFOV=65
    PlayerIronSightFOV=50
    DOF_FG_FocalRadius=150
    DOF_FG_MaxNearBlurSize=1
    MaxAIWarningDistSQ=2250000
    GroupPriority=100
    WeaponSelectTexture=Texture2D'WEP_UI_HRG_Vampire_TEX.UI_WeaponSelect_HRG_Vampire'
    SecondaryAmmoTexture=Texture2D'ui_firemodes_tex.UI_FireModeSelect_Vampire'
    MagazineCapacity[0]=40
    MagazineCapacity[1]=100
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCapacity=240
    InitialSpareMags=1
    bLoopingFireAnim=/* Array type was not detected. */
    bLoopingFireSnd=/* Array type was not detected. */
    FireSightedAnims=/* Array type was not detected. */
    FireLoopEndLastAnim=ShootLoop_End
    FireLoopEndLastSightedAnim=ShootLoop_Iron_End
    BonesToLockOnEmpty=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=20,Y=12,Z=-1)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_HRG_Vampire.MeleeHelper'
    maxRecoilPitch=115
    minRecoilPitch=75
    maxRecoilYaw=75
    minRecoilYaw=-75
    RecoilRate=0.085
    RecoilViewRotationScale=0.25
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65034
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=75
    RecoilISMinYawLimit=65460
    RecoilISMaxPitchLimit=375
    RecoilISMinPitchLimit=65460
    HippedRecoilModifier=1.5
    IronSightMeshFOVCompensationScale=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitMomentum=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=4.5,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_HRG_Vampire.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="HRG Vampire"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Vampire.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Vampire.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
    bOnlyRelevantToOwner=false
    bAlwaysRelevant=true
}