/*******************************************************************************
 * KFProj_Grenade_GravityImploderAlt generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProj_Grenade_GravityImploderAlt extends KFProj_BallisticExplosive
    hidecategories(Navigation);

/** Factor added to the rolling speed of the ball when bouncing */
var(Projectile) float RollingFactor;
var transient bool bIsRolling;
var bool bHasAlreadyBounced;
var bool bVortexReduceImpulseOnDist;
var protected transient bool bFirstAbsorption;
var transient float CurrentRoll;
var Object Collider;
var float PreparationTime;
var float VortexDuration;
var float VortexTime;
var float VortexRadius;
var float VortexAbsorptionStrength;
var float VortexElevationStrength;
var protected transient Vector VortexLocation;
var protected Vector VortexNormal;
var protected KFImpactEffectInfo VortexImpactEffects;

simulated function PostBeginPlay()
{
    super(KFProjectile).PostBeginPlay();
    GotoState('PreparingState');
}

simulated function Timer_Ready()
{
    GotoState('WaitingToImplode');
}

simulated function Detonation_Ready()
{
    GotoState('DetonatingState');
}

simulated function Detonate()
{
    local Vector ExplosionNormal, vExplosionOffset;

    if(!bHasExploded && !bHasDisintegrated)
    {
        ExplosionNormal = vect(0, 0, 1) >> Rotation;
        vExplosionOffset.X = 0;
        vExplosionOffset.Y = 0;
        vExplosionOffset.Z = 10;
        SetLocation(VortexLocation + vExplosionOffset);
        CallExplode(VortexLocation, ExplosionNormal);        
    }
    else
    {
        bIsTimedExplosive = false;
        bNetDirty = true;
    }
}

simulated function SetIsDud(bool bWantsClientSideDudHit, Vector HitNormal);

protected simulated function StopSimulating()
{
    Velocity = vect(0, 0, 0);
    Acceleration = vect(0, 0, 0);
    RotationRate = rot(0, 0, 0);
    SetCollision(false, false);
    StopFlightEffects();
    bRotationFollowsVelocity = false;
}

simulated function ProcessRebound(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    local Vector VNorm;
    local Rotator NewRotation;
    local Vector Offset;
    local bool bWantsClientSideDudHit;
    local TraceHitInfo HitInfo;
    local float TraveledDistance;

    bIsRolling = true;
    if((Instigator != none) && Instigator.Role < ROLE_Authority)
    {
        bWantsClientSideDudHit = true;
    }
    TraveledDistance = (WorldInfo.TimeSeconds - CreationTime) * Speed;
    TraveledDistance *= TraveledDistance;
    if(bDud || ((TraveledDistance < ArmDistSquared) || bIsTimedExplosive) || (OriginalLocation == vect(0, 0, 0)) && ArmDistSquared > float(0))
    {
        VNorm = (Velocity Dot HitNormal) * HitNormal;
        Velocity = (-VNorm * WallHitDampenFactor) + ((Velocity - VNorm) * WallHitDampenFactorParallel);
        Speed = VSize(Velocity);
        if(!bDud || bWantsClientSideDudHit && !bClientDudHit)
        {
            SetIsDud(bWantsClientSideDudHit, HitNormal);
        }
        if(((WorldInfo.NetMode != NM_DedicatedServer) && Pawn(Wall) == none) && bHasAlreadyBounced == false)
        {
            bHasAlreadyBounced = true;
            KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(Location, Instigator, HitNormal, GrenadeBounceEffectInfo, true);
        }
        if(Speed < MinSpeedBeforeStop)
        {
            ImpactedActor = Wall;
            SetPhysics(0);
            if(ProjEffects != none)
            {
                ProjEffects.SetTranslation(LandedTranslationOffset);
            }
            RotationRate.Yaw = 0;
            RotationRate.Pitch = 0;
            RotationRate.Roll = 0;
            NewRotation = Rotation;
            NewRotation.Pitch = 0;
            if(ResetRotationOnStop)
            {
                SetRotation(NewRotation);
            }
            Offset.Z = LandedTranslationOffset.X;
            SetLocation(Location + Offset);
        }
        if(((!Wall.bStatic && Wall.bCanBeDamaged) && (DamageRadius == float(0)) || bDamageDestructiblesOnTouch) && !CheckRepeatingTouch(Wall))
        {
            HitInfo.HitComponent = WallComp;
            HitInfo.Item = -1;
            Wall.TakeDamage(int(Damage), InstigatorController, Location, MomentumTransfer * Normal(Velocity), MyDamageType, HitInfo, self);
        }
    }
}

simulated state PreparingState
{
    simulated function BeginState(name PrevStateName)
    {
        super(Object).BeginState(PrevStateName);
        SetTimer(PreparationTime, false, 'Timer_Ready');
    }

    simulated event Tick(float DeltaTime)
    {
        local Vector RollDelta;
        local Rotator NewRotation;

        if(((bIsRolling && WorldInfo.NetMode != NM_DedicatedServer) && Physics != 0) && (Velocity.X != float(0)) || Velocity.Y != float(0))
        {
            CurrentRoll -= (((Abs(Velocity.X) + Abs(Velocity.Y)) * DeltaTime) * RollingFactor);
            RollDelta = (vect(1, 0, 0) * Velocity.X) + (vect(0, 1, 0) * Velocity.Y);
            NewRotation = rotator(RollDelta);
            NewRotation.Pitch += int(CurrentRoll);
            SetRotation(NewRotation);
        }
        super(Actor).Tick(DeltaTime);
    }

    simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
    {
        VortexNormal = HitNormal;
        ProcessRebound(HitNormal, Wall, WallComp);
        if(!bDud && !bIsTimedExplosive)
        {
            super(KFProj_BallisticExplosive).HitWall(HitNormal, Wall, WallComp);
        }
    }

    simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
    {
        local bool bWantsClientSideDudHit;
        local float TraveledDistance;
        local Vector VNorm;

        if(Other.IsA('KFTrigger_SirenProjectileShield'))
        {
            return;
        }
        if(!bCollideWithTeammates && Pawn(Other) != none)
        {
            if(Other.GetTeamNum() == GetTeamNum())
            {
                return;
            }
        }
        if((Instigator != none) && Instigator.Role < ROLE_Authority)
        {
            bWantsClientSideDudHit = true;
        }
        TraveledDistance = (WorldInfo.TimeSeconds - CreationTime) * Speed;
        TraveledDistance *= TraveledDistance;
        if((!bDud || bWantsClientSideDudHit && !bClientDudHit) && ((TraveledDistance < ArmDistSquared) || bIsTimedExplosive) || (OriginalLocation == vect(0, 0, 0)) && ArmDistSquared > float(0))
        {
            if(((LastTouched.Actor == Other) && TouchTimeThreshhold > float(0)) && (WorldInfo.TimeSeconds - LastTouched.Time) <= TouchTimeThreshhold)
            {
                return;
            }
            SetIsDud(bWantsClientSideDudHit, HitNormal);
            if((((Other != Instigator) && !Other.bStatic) && Other.GetTeamNum() != GetTeamNum()) && !CheckRepeatingTouch(Other))
            {
                ProcessBulletTouch(Other, HitLocation, HitNormal);
            }
            VNorm = (Velocity Dot HitNormal) * HitNormal;
            Velocity = (-VNorm * DampenFactor) + ((Velocity - VNorm) * DampenFactorParallel);
            Speed = VSize(Velocity);            
        }
        else
        {
            if(!bDud && !bIsTimedExplosive)
            {
                if((Other != Instigator) && !Other.bStatic)
                {
                    if(!CheckRepeatingTouch(Other) && Other.GetTeamNum() != GetTeamNum())
                    {
                        ProcessBulletTouch(Other, HitLocation, HitNormal);
                    }
                }
                if((WorldInfo.NetMode == NM_Standalone) || ((WorldInfo.NetMode == NM_ListenServer) && Instigator != none) && Instigator.IsLocallyControlled())
                {
                    super(KFProj_BallisticExplosive).ProcessTouch(Other, HitLocation, HitNormal);
                    return;
                }
                if(((Owner != none) && KFWeapon(Owner) != none) && Instigator != none)
                {
                    if((Instigator.Role < ROLE_Authority) && Instigator.IsLocallyControlled())
                    {
                        KFWeapon(Owner).HandleClientProjectileExplosion(HitLocation, self);
                        super(KFProj_BallisticExplosive).ProcessTouch(Other, HitLocation, HitNormal);
                        return;
                    }
                }
            }
        }
    }
    stop;    
}

simulated state WaitingToImplode
{
    simulated function BeginState(name PrevStateName)
    {
        super(Object).BeginState(PrevStateName);
    }

    simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
    {
        if((HitNormal Dot vect(0, 0, 1)) > 0.5)
        {
            GotoState('ImplodingState');
            return;
        }
        ProcessRebound(HitNormal, Wall, WallComp);
        if(!bDud && !bIsTimedExplosive)
        {
            super(KFProj_BallisticExplosive).HitWall(HitNormal, Wall, WallComp);
        }
    }

    simulated function Tick(float Delta)
    {
        if(VSize(Velocity) < 0.05)
        {
            GotoState('ImplodingState');
            return;
        }
        super(Actor).Tick(Delta);
    }

    simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
    {
        super(KFProj_BallisticExplosive).ProcessTouch(Other, HitLocation, HitNormal);
    }
    stop;    
}

simulated state ImplodingState
{
    simulated function BeginState(name PrevStateName)
    {
        super(Object).BeginState(PrevStateName);
        StopSimulating();
        AdjustVortexForPerk();
        if(WorldInfo.NetMode != NM_Client)
        {
            Velocity = vect(0, 0, 0);
            Acceleration = vect(0, 0, 0);
            RotationRate = rot(0, 0, 0);
            GravityScale = 0;
            bFirstAbsorption = true;
            VortexTime = 0;
            SetTimer(VortexDuration, false, 'Detonation_Ready');
        }
        VortexLocation = Location + (vect(0, 0, 1) * float(125));
        StartVortexVFX();
    }

    simulated function StartVortexVFX()
    {
        if(VortexImpactEffects != none)
        {
            if(VortexImpactEffects.DefaultImpactEffect.ParticleTemplate != none)
            {
                WorldInfo.MyEmitterPool.SpawnEmitter(VortexImpactEffects.DefaultImpactEffect.ParticleTemplate, VortexLocation, rotator(VortexNormal));
            }
            if(VortexImpactEffects.DefaultImpactEffect.Sound != none)
            {
                PlaySoundBase(VortexImpactEffects.DefaultImpactEffect.Sound, true,,, VortexLocation);
            }
        }
    }

    simulated function EndState(name NextStateName)
    {
        super(Object).EndState(NextStateName);
    }

    simulated event Tick(float DeltaTime)
    {
        super(Actor).Tick(DeltaTime);
        SetLocation(VortexLocation);
        if(WorldInfo.NetMode < NM_Client)
        {
            VortexTime += DeltaTime;
            AbsorbEnemies();
            bFirstAbsorption = false;
        }
    }

    function AdjustVortexForPerk()
    {
        local KFPlayerController KFPC;
        local KFPerk Perk;

        KFPC = KFPlayerController(InstigatorController);
        if(KFPC != none)
        {
            Perk = KFPC.GetPerk();
            if(Perk != none)
            {
                VortexRadius = default.VortexRadius * Perk.GetAoERadiusModifier();
            }
        }
    }

    simulated function AbsorbEnemies()
    {
        local Actor Victim;
        local TraceHitInfo HitInfo;
        local KFPawn KFP;
        local KFPawn_Monster KFPM;
        local float ColRadius, ColHeight, Dist;
        local Vector Dir, Momentum;
        local float MomentumModifier;

        foreach CollidingActors(Class'Actor', Victim, VortexRadius, VortexLocation, true,, HitInfo)
        {
            KFP = KFPawn(Victim);
            KFPM = KFPawn_Monster(Victim);
            if(((((((Victim != self) && !Victim.bWorldGeometry || Victim.bCanBeDamaged) && NavigationPoint(Victim) == none) && Victim != Instigator) && KFP != none) && KFPawn_Human(Victim) == none) && (KFPM == none) || VortexTime < (VortexDuration * KFPM.GetVortexAttractionModifier()))
            {
                KFP.GetBoundingCylinder(ColRadius, ColHeight);
                if(bFirstAbsorption)
                {
                    Dir = vect(0, 0, 1);
                    Momentum = Dir * VortexElevationStrength;                    
                }
                else
                {
                    Dir = Normal(VortexLocation - KFP.Location);
                    Dist = FMax(VSize(Dir) - ColRadius, 0);
                    MomentumModifier = ((bVortexReduceImpulseOnDist) ? 1 - (Dist / VortexRadius) : 1);
                    Momentum = ((Dir * VortexAbsorptionStrength) * MomentumModifier) + ((vect(0, 0, 1) * (Dist / VortexRadius)) * VortexAbsorptionStrength);
                }
                if(KFPM != none)
                {
                    Momentum *= KFPM.GetVortexAttractionModifier();
                }
                KFP.AddVelocity(Momentum, KFP.Location - ((0.5 * (ColHeight + ColRadius)) * Dir), Class'KFDT_Explosive_GravityImploder');
            }            
        }        
    }
    stop;    
}

simulated state DetonatingState
{
    simulated function BeginState(name PrevStateName)
    {
        super(Object).BeginState(PrevStateName);
        Detonate();
    }
    stop;    
}

defaultproperties
{
    RollingFactor=1100
    bFirstAbsorption=true
    PreparationTime=0.8
    VortexDuration=0.5
    VortexRadius=500
    VortexAbsorptionStrength=120
    VortexElevationStrength=700
    VortexImpactEffects=KFImpactEffectInfo'WEP_Gravity_Imploder_ARCH.Blue_Attract'
    bIsTimedExplosive=true
    ResetRotationOnStop=false
    GrenadeBounceEffectInfo=KFImpactEffectInfo'FX_Impacts_ARCH.DefaultGrenadeImpacts'
    DampenFactor=0.1
    DampenFactorParallel=0
    WallHitDampenFactor=0.4
    WallHitDampenFactorParallel=0.4
    MinSpeedBeforeStop=5
    bWarnAIWhenFired=true
    TouchTimeThreshhold=60
    TerminalVelocity=3200
    begin object name=ExploTemplate0 class=KFGameExplosion
        ExplosionEffects=KFImpactEffectInfo'WEP_Gravity_Imploder_ARCH.Blue_Explosion'
        Damage=1
        DamageRadius=450
        DamageFalloffExponent=0
        MyDamageType=Class'KFDT_Explosive_GravityImploderWave'
        KnockDownStrength=150
        MomentumTransferScale=10000
        ExplosionSound=AkEvent'WW_WEP_Gravity_Imploder.Play_WEP_Gravity_Imploder_Grenade_Blue_Explosion'
        ExploLight=PointLightComponent'Default__KFProj_Grenade_GravityImploderAlt.ExplosionPointLight'
        ExploLightFadeOutTime=0.2
        CamShake=KFCameraShake'FX_CameraShake_Arch.Misc_Explosions.Light_Explosion_Rumble'
        CamShakeInnerRadius=200
        CamShakeFalloff=1.5
    object end
    // Reference: KFGameExplosion'Default__KFProj_Grenade_GravityImploderAlt.ExploTemplate0'
    ExplosionTemplate=ExploTemplate0
    ProjDisintegrateTemplate=ParticleSystem'ZED_Siren_EMIT.FX_Siren_grenade_disable_01'
    AltExploEffects=KFImpactEffectInfo'WEP_Gravity_Imploder_ARCH.Blue_Explosion_Concussive_Force'
    ProjFlightTemplate=ParticleSystem'WEP_Gravity_Imploder_EMIT.FX_Blue_Projectile'
    ProjFlightTemplateZedTime=ParticleSystem'WEP_Gravity_Imploder_EMIT.FX_Blue_Projectile_ZEDTIME'
    AmbientComponent=AkComponent'Default__KFProj_Grenade_GravityImploderAlt.AmbientAkSoundComponent'
    Speed=3200
    MaxSpeed=3200
    MomentumTransfer=100000
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_Grenade_GravityImploderAlt.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_Grenade_GravityImploderAlt.CollisionCylinder'
    Components(0)=CollisionCylinder
    Components(1)=AkComponent'Default__KFProj_Grenade_GravityImploderAlt.AmbientAkSoundComponent'
    Physics=EPhysics.PHYS_Falling
    bUpdateSimulatedPosition=true
    LifeSpan=0
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFProj_Grenade_GravityImploderAlt.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}