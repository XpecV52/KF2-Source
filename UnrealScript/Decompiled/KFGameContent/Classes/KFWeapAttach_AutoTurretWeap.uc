/*******************************************************************************
 * KFWeapAttach_AutoTurretWeap generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeapAttach_AutoTurretWeap extends KFWeaponAttachment
    hidecategories(Navigation,Object,Movement,Attachment,Collision,Physics,Advanced,Debug,Mobile);

const DeployAnimName = 'Drone_Deploy';
const DroneFireAnim = 'Drone_Shoot';
const DroneEmptyStartAnim = 'Drone_Start_Empty';
const DroneEmptyAnim = 'Drone_Empty';
const DroneIdleAnim = 'Drone_Idle';
const DroneClosedAnim = 'Drone_IdleClose';
const LaserSightSocketName = 'LaserSightSocket';
const LaserColorParamName = '0blue_1red';

var transient MaterialInstanceConstant LaserDotMIC;
var transient MaterialInstanceConstant LaserBeamMIC;

simulated function float PlayDeployAnim()
{
    local float Duration;

    Duration = WeapMesh.GetAnimLength('Drone_Deploy');
    WeapMesh.PlayAnim('Drone_Deploy', Duration / ThirdPersonAnimRate, false, true);
    return Duration;
}

simulated function PlayEmptyState()
{
    local float Duration;

    ClearTimer('PlayIdleAnim');
    Duration = WeapMesh.GetAnimLength('Drone_Start_Empty');
    WeapMesh.PlayAnim('Drone_Start_Empty', Duration / ThirdPersonAnimRate, true, false);
    SetTimer(Duration, false, 'PlayEmptyAnim');
}

simulated function PlayEmptyAnim()
{
    local float Duration;

    Duration = WeapMesh.GetAnimLength('Drone_Empty');
    WeapMesh.PlayAnim('Drone_Empty', Duration / ThirdPersonAnimRate, true, false);
    if(LaserSight != none)
    {
        LaserSight.ChangeVisibility(false);
    }
}

simulated function PlayIdleAnim()
{
    local float Duration;

    Duration = WeapMesh.GetAnimLength('Drone_Idle');
    WeapMesh.PlayAnim('Drone_Idle', Duration / ThirdPersonAnimRate, true, false);
}

simulated function PlayCloseAnim()
{
    local float Duration;

    Duration = WeapMesh.GetAnimLength('Drone_IdleClose');
    WeapMesh.PlayAnim('Drone_IdleClose', Duration / ThirdPersonAnimRate, true, false);
}

simulated function bool ThirdPersonFireEffects(Vector HitLocation, KFPawn P, byte ThirdPersonAnimRateByte)
{
    SpawnTracer(GetMuzzleLocation(), HitLocation);
    if(!ActorIsRelevant(self, false, MaxFireEffectDistance))
    {
        return false;
    }
    DecodeThirdPersonAnimRate(ThirdPersonAnimRateByte);
    if(!bWeapMeshIsPawnMesh)
    {
        PlayWeaponFireAnim();
    }
    CauseMuzzleFlash(0);
    return true;
}

simulated function bool ActorIsRelevant(Actor EffectInstigator, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance)
{
    local PlayerController P;
    local float DistSq;
    local Vector CameraLoc;
    local Rotator CameraRot;

    VisibleCullDistance = 5000;
    HiddenCullDistance = 350;
    if(EffectInstigator == none)
    {
        return false;
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return bForceDedicated;
    }
    if((bForceDedicated && WorldInfo.NetMode == NM_ListenServer) && WorldInfo.Game.NumPlayers > 1)
    {
        return true;
    }
    DistSq = 1E+10;
    foreach LocalPlayerControllers(Class'PlayerController', P)
    {
        if(P.GetViewTarget() == self)
        {            
            return true;
        }
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        DistSq = FMin(DistSq, VSizeSq(Location - CameraLoc) * Square(P.LODDistanceFactor));        
    }    
    if(DistSq > (VisibleCullDistance * VisibleCullDistance))
    {
        return false;        
    }
    else
    {
        if(DistSq < (HiddenCullDistance * HiddenCullDistance))
        {
            return true;
        }
    }
    return true;
}

simulated function PlayWeaponFireAnim()
{
    local float Duration;
    local bool bAnimPlayed;

    Duration = WeapMesh.GetAnimLength('Drone_Shoot');
    bAnimPlayed = WeapMesh.PlayAnim('Drone_Shoot', Duration / ThirdPersonAnimRate, false, false);
    if(bAnimPlayed)
    {
        ClearTimer('PlayIdleAnim');
        SetTimer(Duration, false, 'PlayIdleAnim');
    }
}

simulated function AttachLaserSight()
{
    if(((WeapMesh != none) && LaserSight == none) && LaserSightArchetype != none)
    {
        LaserSight = new (self) Class'KFLaserSightAttachment' (LaserSightArchetype);
        LaserSight.AttachLaserSight(WeapMesh, false, 'LaserSightSocket');
    }
}

simulated function UpdateLaserColor(bool bInCombat)
{
    if(LaserSight != none)
    {
        if(LaserDotMIC == none)
        {
            LaserDotMIC = LaserSight.LaserDotMeshComp.CreateAndSetMaterialInstanceConstant(0);
        }
        if(LaserBeamMIC == none)
        {
            LaserBeamMIC = LaserSight.LaserBeamMeshComp.CreateAndSetMaterialInstanceConstant(0);
        }
    }
    if(LaserDotMIC != none)
    {
        LaserDotMIC.SetScalarParameterValue('0blue_1red', float(((bInCombat) ? 1 : 0)));
    }
    if(LaserBeamMIC != none)
    {
        LaserBeamMIC.SetScalarParameterValue('0blue_1red', float(((bInCombat) ? 1 : 0)));
    }
}

simulated event SetWeaponSkin(int ItemId, optional bool bFinishedLoading)
{
    local array<MaterialInterface> SkinMICs;

    bFinishedLoading = false;
    if(((ItemId > 0) && WorldInfo.NetMode != NM_DedicatedServer) && !bWaitingForWeaponSkinLoad)
    {
        if(!bFinishedLoading && StartLoadWeaponSkin(ItemId))
        {
            return;
        }
        SkinMICs = Class'KFWeaponSkinList'.static.GetWeaponSkin(ItemId, 1);
        if(SkinMICs.Length > 0)
        {
            WeapMesh.SetMaterial(0, SkinMICs[0]);
        }
    }
}

defaultproperties
{
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__KFWeapAttach_AutoTurretWeap.SkeletalMeshComponent0.MeshSequenceA'
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFWeapAttach_AutoTurretWeap.SkeletalMeshComponent0'
    WeapMesh=SkeletalMeshComponent0
    bHasLaserSight=true
}