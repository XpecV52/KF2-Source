/*******************************************************************************
 * KFSM_Matriarch_PlasmaCannon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_Matriarch_PlasmaCannon extends KFSM_PlaySingleAnim;

var float MaxVictimDistance;
var name ShootingSocketName;
var Vector BeamSize;
var float DamageTickRate;
var float DamagePerTick;
var class<DamageType> CannonDamageType;
var ParticleSystem BeamPSCTemplate;
var export editinline ParticleSystemComponent BeamPSC;
var const ParticleSystem BeamHitPSCTemplate;
var export editinline ParticleSystemComponent BeamHitPSC;
var ParticleSystem MuzzleFlashPSCTemplate;
var export editinline ParticleSystemComponent MuzzleFlashPSC;
var float SinceLastDamage;
var AkEvent BeamStartSFX;
var AkEvent BeamEndSFX;
var AkEvent BeamHitSFX;
var AkEvent BeamHitStopSFX;
var name WindUpAnimName;
var name WindDownAnimName;
var bool bTickDamage;
var bool bLogTargeting;
var KFPawn_ZedMatriarch MyMatPawn;
var float VisibilityCheckTime;
var float VisibilityCheckTimer;
var float AngleCheckDot;

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    super.SpecialMoveStarted(bForced, PrevMove);
    PlayWindUpAnimation();
    MyMatPawn = KFPawn_ZedMatriarch(KFPOwner);
    MyMatPawn.PlayPlasmaCannonDialog();
}

function SpecialMoveFlagsUpdated()
{
    switch(KFPOwner.SpecialMoveFlags)
    {
        case 1:
            PlayFireAnim();
            break;
        case 2:
            PlayWindDownAnim();
            break;
        default:
            break;
    }
}

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    switch(DeferredSeqName)
    {
        case WindUpAnimName:
            if(KFPOwner.Role == ROLE_Authority)
            {
                if(PrefireBeamCheck())
                {
                    KFPOwner.DoSpecialMove(23, true,, 1);                    
                }
                else
                {
                    KFPOwner.DoSpecialMove(23, true,, 2);
                }
            }
            break;
        case AnimName:
            PlayWindDownAnim();
            break;
        case WindDownAnimName:
            KFPOwner.EndSpecialMove();
            break;
        default:
            break;
    }
}

function bool PrefireBeamCheck()
{
    local Actor HitActor;
    local Vector SocketLocation, HitLocation, HitNormal, ToEnemy, TraceEnd, GunTargetBoneLocation;

    local Rotator SocketRotation;

    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, SocketLocation, SocketRotation);
    GunTargetBoneLocation = KFPOwner.Controller.Enemy.Mesh.GetBoneLocation(MyMatPawn.GunTargetBoneName);
    ToEnemy = Normal(GunTargetBoneLocation - SocketLocation);
    TraceEnd = SocketLocation + (ToEnemy * MaxVictimDistance);
    HitActor = PawnOwner.Trace(HitLocation, HitNormal, TraceEnd, SocketLocation, true);
    return KFPawn(HitActor) != none;
}

function PlayAnimation();

function PlayWindUpAnimation()
{
    PlaySpecialMoveAnim(WindUpAnimName, 0, BlendInTime, BlendOutTime, 1);
    KFPOwner.ZeroMovementVariables();
}

function PlayFireAnim()
{
    MyMatPawn.SetGunTracking(true);
    PlaySpecialMoveAnim(AnimName, 0, 0.1, 0.2);
    ActivateFX();
    KFPOwner.ZeroMovementVariables();
    KFPOwner.SetWeaponAmbientSound(BeamStartSFX);
    bTickDamage = true;
    if(KFPOwner.Role == ROLE_Authority)
    {
        VisibilityCheckTimer = VisibilityCheckTime;
    }
    PawnOwner.RotationRate = CustomRotationRate;
}

function PlayWindDownAnim()
{
    MyMatPawn.SetGunTracking(false);
    PlaySpecialMoveAnim(WindDownAnimName, 0, BlendInTime, BlendOutTime, 1);
    KFPOwner.ZeroMovementVariables();
    bTickDamage = false;
    DeactivateFX();
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    super.SpecialMoveEnded(PrevMove, NextMove);
    KFPOwner.RotationRate = KFPOwner.default.RotationRate;
    bTickDamage = false;
    DeactivateFX();
}

function ActivateFX()
{
    local ParticleSysParam SourceParam;

    if(KFPOwner.WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(BeamPSCTemplate != none)
        {
            BeamPSC = PawnOwner.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BeamPSCTemplate, PawnOwner.Mesh, 'LeftHand');
            if(BeamPSC != none)
            {
                SourceParam.Name = 'SourceActor';
                SourceParam.ParamType = 6;
                SourceParam.Actor = PawnOwner;
                BeamPSC.InstanceParameters.AddItem(SourceParam;
            }
        }
        if(MuzzleFlashPSCTemplate != none)
        {
            MuzzleFlashPSC = PawnOwner.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(MuzzleFlashPSCTemplate, PawnOwner.Mesh, 'LeftHand');
            if(MuzzleFlashPSC != none)
            {
                SourceParam.Name = 'SourceActor';
                SourceParam.ParamType = 6;
                SourceParam.Actor = PawnOwner;
                MuzzleFlashPSC.InstanceParameters.AddItem(SourceParam;
            }
        }
    }
}

function DeactivateFX()
{
    if(BeamPSC != none)
    {
        BeamPSC.DeactivateSystem();
        BeamPSC = none;
        KFPOwner.SetWeaponAmbientSound(BeamEndSFX);
    }
    if(BeamHitPSC != none)
    {
        BeamHitPSC.DeactivateSystem();
        BeamHitPSC = none;
        MyMatPawn.BeamHitAC.PlayEvent(BeamHitStopSFX);
    }
    if(MuzzleFlashPSC != none)
    {
        MuzzleFlashPSC.DeactivateSystem();
        MuzzleFlashPSC = none;
    }
    if(MyMatPawn.BeamHitAC != none)
    {
        MyMatPawn.BeamHitAC.StopEvents();
    }
}

function Actor GetBeamTarget(out Vector HitLocation)
{
    local Actor HitActor;
    local Vector SocketLocation, HitNormal, TraceEnd;
    local Rotator SocketRotation;

    if((PawnOwner.Role < ROLE_Authority) && MyMatPawn.BeamTarget != none)
    {
        HitLocation = MyMatPawn.BeamTarget.Mesh.GetBoneLocation(MyMatPawn.GunTargetBoneName);
        return MyMatPawn.BeamTarget;
    }
    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, SocketLocation, SocketRotation);
    TraceEnd = SocketLocation + (vector(SocketRotation) * MaxVictimDistance);
    foreach PawnOwner.TraceActors(Class'Actor', HitActor, HitLocation, HitNormal, TraceEnd, SocketLocation, BeamSize)
    {
        if(IsValidBeamTarget(HitActor))
        {
            break;
            continue;
        }
        HitActor = none;        
    }    
    return HitActor;
}

function bool IsValidBeamTarget(Actor HitActor)
{
    return (((Pawn(HitActor) != none) || (StaticMeshActor(HitActor) != none) && !StaticMeshActor(HitActor).bResetCapable) || SkeletalMeshActor(HitActor) != none) || StaticMeshCollectionActor(HitActor) != none;
}

function Tick(float DeltaTime)
{
    local Actor HitActor;
    local Vector SocketLocation, HitLocation;
    local Rotator SocketRotation;

    super(KFSpecialMove).Tick(DeltaTime);
    if(bTickDamage)
    {
        HitActor = GetBeamTarget(HitLocation);
        if(PawnOwner.Role == ROLE_Authority)
        {
            SinceLastDamage += DeltaTime;
            J0x7A:

            if(SinceLastDamage > DamageTickRate)
            {
                if(HitActor != none)
                {
                    HitActor.TakeDamage(int(DamagePerTick), PawnOwner.Controller, HitActor.Location, vect(0, 0, 0), CannonDamageType);
                    if((KFPawn(HitActor) != none) && !KFPawn(HitActor).IsAliveAndWell())
                    {
                        HitActor = none;
                    }
                }
                MyMatPawn.BeamTarget = Pawn(HitActor);
                SinceLastDamage -= DamageTickRate;
                goto J0x7A;
            }
            if(bLogTargeting)
            {
                LogInternal((((("(PLASMA BEAM TARGETING) " $ string(self)) $ "::Tick - HitActor: ") $ string(HitActor)) $ "; VisibilityCheckTimer: ") $ string(VisibilityCheckTimer));
            }
            if(CanHitEnemy())
            {
                VisibilityCheckTimer = VisibilityCheckTime;                
            }
            else
            {
                VisibilityCheckTimer -= DeltaTime;
                if(VisibilityCheckTimer <= float(0))
                {
                    FindNewEnemy();
                    VisibilityCheckTimer = VisibilityCheckTime;
                }
            }
        }
        if(PawnOwner.WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(HitActor != none)
            {
                if(BeamPSC != none)
                {
                    BeamPSC.SetBeamTargetPoint(0, HitLocation, 0);
                }
                if(BeamHitPSC == none)
                {
                    BeamHitPSC = KFPOwner.WorldInfo.MyEmitterPool.SpawnEmitter(BeamHitPSCTemplate, HitLocation);
                    MyMatPawn.BeamHitAC.PlayEvent(BeamHitSFX);
                }
                if(BeamHitPSC != none)
                {
                    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, SocketLocation, SocketRotation);
                    BeamHitPSC.SetAbsolute(true, true, false);
                    BeamHitPSC.SetTranslation(HitLocation);
                    BeamHitPSC.SetRotation(SocketRotation);
                }                
            }
            else
            {
                if((BeamHitPSC != none) && BeamHitPSC.bIsActive)
                {
                    BeamHitPSC.DeactivateSystem();
                    BeamHitPSC = none;
                    MyMatPawn.BeamHitAC.PlayEvent(BeamHitStopSFX);
                }
            }
        }
    }
}

function bool CanHitEnemy()
{
    local Actor HitActor;
    local Vector SocketLocation, HitLocation, HitNormal, ToEnemy, TraceEnd, GunTargetBoneLocation;

    local Rotator SocketRotation;

    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, SocketLocation, SocketRotation);
    GunTargetBoneLocation = KFPOwner.Controller.Enemy.Mesh.GetBoneLocation(MyMatPawn.GunTargetBoneName);
    ToEnemy = Normal(GunTargetBoneLocation - SocketLocation);
    TraceEnd = SocketLocation + (ToEnemy * MaxVictimDistance);
    HitActor = PawnOwner.Trace(HitLocation, HitNormal, TraceEnd, SocketLocation, true);
    return HitActor == KFPOwner.Controller.Enemy;
}

function FindNewEnemy()
{
    local KFPawn_Human KFPH, BestTarget;
    local Vector StartTrace, EndTrace, ToTarget;
    local Rotator SocketRotation;
    local float TargetDot, BestDot, MaxVictimDistanceSq;
    local Vector HitLocation, HitNormal;
    local Actor HitActor;

    KFPOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, StartTrace, SocketRotation);
    MaxVictimDistanceSq = MaxVictimDistance * MaxVictimDistance;
    foreach KFPOwner.WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
    {
        if(bLogTargeting)
        {
            LogInternal((("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - Potential target: ") $ string(KFPH));
        }
        ToTarget = KFPH.Location - StartTrace;
        if(VSizeSq(ToTarget) > MaxVictimDistanceSq)
        {
            if(bLogTargeting)
            {
                LogInternal(("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - too far");
            }
            continue;            
        }
        ToTarget = Normal(ToTarget);
        TargetDot = ToTarget Dot vector(SocketRotation);
        if((TargetDot < AngleCheckDot) || TargetDot < BestDot)
        {
            if(bLogTargeting)
            {
                LogInternal(("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - bad angle");
            }
            continue;            
        }
        EndTrace = StartTrace + (ToTarget * MaxVictimDistance);
        HitActor = KFPOwner.Trace(HitLocation, HitNormal, EndTrace, StartTrace, true,,, 1);
        if(bLogTargeting)
        {
            LogInternal((("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - HitActor: ") $ string(HitActor));
        }
        if(HitActor != KFPH)
        {
            if(bLogTargeting)
            {
                LogInternal(("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - obstructed");
            }
            continue;            
        }
        if(bLogTargeting)
        {
            LogInternal(("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - okay!");
        }
        BestTarget = KFPH;
        BestDot = TargetDot;        
    }    
    if(bLogTargeting)
    {
        LogInternal((("(PLASMA BEAM TARGETING) " $ string(self)) $ "::FindNewEnemy - BestTarget: ") $ string(BestTarget));
    }
    if(BestTarget != none)
    {
        if(BestTarget != KFPOwner.Controller.Enemy)
        {
            KFAIController(KFPOwner.Controller).ChangeEnemy(BestTarget, false);
        }        
    }
    else
    {
        KFPOwner.DoSpecialMove(23, true,, 2);
    }
}

defaultproperties
{
    MaxVictimDistance=2500
    ShootingSocketName=Hand_FX_End_L
    BeamSize=(X=15,Y=15,Z=15)
    DamageTickRate=0.1
    DamagePerTick=7
    CannonDamageType=Class'KFDT_EMP_MatriarchPlasmaCannon'
    BeamPSCTemplate=ParticleSystem'ZED_Matriarch_EMIT.FX_Plasma_Cannon_Beam_01'
    BeamHitPSCTemplate=ParticleSystem'ZED_Matriarch_EMIT.FX_Plasma_Cannon_Impact_01'
    MuzzleFlashPSCTemplate=ParticleSystem'ZED_Matriarch_EMIT.FX_Plasma_Cannon_Muzzleflash_01'
    BeamStartSFX=AkEvent'WW_ZED_Matriarch.Play_Matriarch_Plasma_Cannon_Loop_01'
    BeamEndSFX=AkEvent'WW_ZED_Matriarch.Play_Matriarch_Plasma_Cannon_End_01'
    BeamHitSFX=AkEvent'WW_ZED_Matriarch.Play_Matriarch_SFX_Attack_PulseCannon_Beam_Hit_LP'
    BeamHitStopSFX=AkEvent'WW_ZED_Matriarch.Stop_Matriarch_SFX_Attack_PulseCannon_Beam_Hit_LP'
    WindUpAnimName=Plasma_Cannon_TO_Load
    WindDownAnimName=Plasma_Cannon_TO_Idle
    VisibilityCheckTime=0.8
    AngleCheckDot=0.5
    AnimName=Plasma_Cannon_Idle
    AnimStance=EAnimSlotStance.EAS_UpperBody
    bDisableMovement=true
    bDisableSteering=false
    bDisableTurnInPlace=true
    bShouldDeferToPostTick=true
    CustomRotationRate=(Pitch=50000,Yaw=4500,Roll=50000)
    Handle=KFSM_Matriarch_PlasmaCannon
}