/*******************************************************************************
 * KFExplosion_MineReconstructor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFExplosion_MineReconstructor extends KFExplosionActorLingering
    config(Weapon)
    hidecategories(Navigation);

var() class<KFDamageType> HealingDamageType;
var() float HealingAmount;
var AkEvent SmokeLoopStartEvent;
var AkEvent SmokeLoopStopEvent;
var KFPerk CachedInstigatorPerk;
var float fChargePercentage;
var float fMinAmmoutHealing;
var float fMaxAmmoutHealing;
var float fAltMinAmmoutHealing;
var float fAltMaxAmmoutHealing;
var bool bHealsInstigator;
var bool bHealsDifferentAmmoutToInstigator;
var bool bAllowFractureDamage;

simulated function SpawnExplosionParticleSystem(ParticleSystem Template)
{
    local editinline ParticleSystemComponent PSC;
    local Vector vec;

    if(!ExplosionTemplate.bAllowPerMaterialFX && Template == none)
    {
        Template = KFGameExplosion(ExplosionTemplate).ExplosionEffects.DefaultImpactEffect.ParticleTemplate;
    }
    PSC = WorldInfo.MyEmitterPool.SpawnEmitter(Template, Location, rotator(ExplosionTemplate.HitNormal), none);
    vec.X = fChargePercentage;
    vec.Y = fChargePercentage;
    vec.Z = fChargePercentage;
    PSC.SetVectorParameter(name("BlobCharge"), vec);
    PSC.SetFloatParameter(name("MineFxControlParam"), fChargePercentage);
}

simulated function Explode(GameExplosion NewExplosionTemplate, optional Vector Direction)
{
    local KFPawn KFP;

    super.Explode(NewExplosionTemplate, Direction);
    if(Instigator != none)
    {
        KFP = KFPawn(Instigator);
        if(KFP != none)
        {
            CachedInstigatorPerk = KFP.GetPerk();
        }
    }
    if(Role == ROLE_Authority)
    {
        SetTimer(interval, false, 'DelayedExplosionDamage', self);
    }
}

protected simulated function AffectsPawn(Pawn Victim, float DamageScale)
{
    local KFPawn_Human HumanVictim;
    local KFPawn_Monster MonsterVictim;
    local KFProj_MedicGrenade OwnerProjectile;
    local bool bCanRepairArmor;
    local Box BBox;
    local Vector BBoxCenter;
    local Actor HitActor;
    local bool bDamageBlocked;

    if((Victim != none) && Victim.IsAliveAndWell())
    {
        MonsterVictim = KFPawn_Monster(Victim);
        if(MonsterVictim != none)
        {
            if((bWasFadedOut || bDeleteMe) || bPendingDelete)
            {
                return;
            }
            Victim.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            HitActor = TraceExplosive(BBoxCenter, Location + vect(0, 0, 20));
            bDamageBlocked = (HitActor != none) && HitActor != Victim;
            if(bDamageBlocked && HitActor.IsA('KFDoorActor'))
            {
                bDamageBlocked = false;
            }
            if(!bDamageBlocked)
            {
                Victim.TakeRadiusDamage(InstigatorController, ExplosionTemplate.Damage * DamageScale, ExplosionTemplate.DamageRadius, ExplosionTemplate.MyDamageType, ExplosionTemplate.MomentumTransferScale, Location, bDoFullDamage, ((Owner != none) ? Owner : self), ExplosionTemplate.DamageFalloffExponent);
            }            
        }
        else
        {
            Victim.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            HitActor = TraceExplosive(BBoxCenter, Location + vect(0, 0, 20));
            bDamageBlocked = (HitActor != none) && HitActor != Victim;
            if(bDamageBlocked && HitActor.IsA('KFDoorActor'))
            {
                bDamageBlocked = false;
            }
            if(!bDamageBlocked)
            {
                if(!bHealsInstigator && Victim == Instigator)
                {
                    return;
                }
                HumanVictim = KFPawn_Human(Victim);
                if((HumanVictim != none) && HumanVictim.GetExposureTo(Location) > float(0))
                {
                    OwnerProjectile = KFProj_MedicGrenade(Owner);
                    if(OwnerProjectile != none)
                    {
                        bCanRepairArmor = OwnerProjectile.HealedPawns.Find(HumanVictim == -1;
                    }
                    if((bHealsDifferentAmmoutToInstigator && bHealsInstigator) && Victim == Instigator)
                    {
                        HumanVictim.HealDamage(int(Lerp(fAltMinAmmoutHealing, fAltMaxAmmoutHealing, fChargePercentage)), InstigatorController, HealingDamageType, bCanRepairArmor);                        
                    }
                    else
                    {
                        HumanVictim.HealDamage(int(Lerp(fMinAmmoutHealing, fMaxAmmoutHealing, fChargePercentage)), InstigatorController, HealingDamageType, bCanRepairArmor);
                    }
                    if(bCanRepairArmor)
                    {
                        OwnerProjectile.HealedPawns.AddItem(HumanVictim;
                    }
                }
            }
        }
    }
}

protected simulated function bool DoExplosionDamage(bool bCauseDamage, bool bCauseEffects)
{
    if((bWasFadedOut || bDeleteMe) || bPendingDelete)
    {
        return false;
    }
    if(bOnlyDamagePawns && bAllowFractureDamage)
    {
        ExplodeFractures();
    }
    if(bOnlyDamagePawns)
    {
        return ExplodePawns();
    }
    return super(KFExplosionActor).DoExplosionDamage(bCauseDamage, bCauseEffects);
}

protected simulated function ExplodeFractures()
{
    local Actor Victim;
    local bool bCauseFractureEffects;
    local float CheckRadius, VictimDist;
    local Box BBox;
    local FracturedStaticMeshActor FracActor;
    local byte WantPhysChunksAndParticles;
    local TraceHitInfo HitInfo;

    if((bWasFadedOut || bDeleteMe) || bPendingDelete)
    {
        return;
    }
    bCauseFractureEffects = (WorldInfo.NetMode != NM_DedicatedServer) && ExplosionTemplate.bCausesFracture;
    if(!bCauseFractureEffects)
    {
        return;
    }
    CheckRadius = GetEffectCheckRadius(true, bCauseFractureEffects, WorldInfo.NetMode != NM_Client);
    if(CheckRadius > 0)
    {
        foreach CollidingActors(Class'Actor', Victim, CheckRadius, Location, ExplosionTemplate.bUseOverlapCheck,, HitInfo)
        {
            if(((((((Victim != self) && !Victim.bWorldGeometry || Victim.bCanBeDamaged) && NavigationPoint(Victim) == none) && Victim != ExplosionTemplate.ActorToIgnoreForDamage) && !ExplosionTemplate.bIgnoreInstigator || Victim != Instigator) && !ClassIsChildOf(Victim.Class, ExplosionTemplate.ActorClassToIgnoreForDamage)) && !IsBehindExplosion(Victim))
            {
                if(GamePawn(Victim) != none)
                {                    
                    return;
                }
                Victim.GetComponentsBoundingBox(BBox);
                VictimDist = ((ExplosionTemplate.bUseOverlapCheck) ? BoxDistanceToPoint(Location, BBox) : VSize(Location - Victim.Location));
                FracActor = FracturedStaticMeshActor(Victim);
                if(((((FracActor != none) && VictimDist < ExplosionTemplate.FractureMeshRadius) && FracActor.Physics == 0) && FracActor.IsFracturedByDamageType(ExplosionTemplate.MyDamageType)) && FracActor.FractureEffectIsRelevant(false, Instigator, WantPhysChunksAndParticles))
                {
                    FracActor.NotifyHitByExplosion(InstigatorController, ExplosionTemplate.Damage, ExplosionTemplate.MyDamageType);
                    FracActor.BreakOffPartsInRadius(Location, ExplosionTemplate.FractureMeshRadius, ExplosionTemplate.FracturePartVel, ((WantPhysChunksAndParticles == 1) ? true : false));
                }
            }            
        }        
    }
}

defaultproperties
{
    HealingDamageType=Class'KFGame.KFDT_Healing'
    fMinAmmoutHealing=4
    fMaxAmmoutHealing=40
    fAltMinAmmoutHealing=1
    fAltMaxAmmoutHealing=5
    bAllowFractureDamage=true
    interval=0
    maxTime=0
    bSkipLineCheckForPawns=true
    FadeOutTime=0
    bExplodeMoreThanOnce=false
}