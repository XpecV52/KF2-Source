/*******************************************************************************
 * KFSM_DAR_EMPAttack generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_DAR_EMPAttack extends KFSM_RangedAttack;

struct EMPBlastHitInfo
{
    var Actor HitActor;
    var Vector HitLocation;
    var TraceHitInfo HitInfo;

    structdefaultproperties
    {
        HitActor=none
        HitLocation=(X=0,Y=0,Z=0)
        HitInfo=(Material=none,PhysMaterial=none,Item=0,LevelIndex=0,BoneName=None,HitComponent=none)
    }
};

var const ParticleSystem EMPPSCTemplate;
var export editinline ParticleSystemComponent EMPPSC;
var const ParticleSystem EMPHitPSCTemplate;
var export editinline ParticleSystemComponent EMPHitPSC;
var AkEvent EMPStartSFX;
var AkEvent EMPEndSFX;
var AkEvent EMPHitSFX;
var AkEvent EMPHitStopSFX;
var CameraShake EMPHitShake;
var const name EMPSocketName;
var const class<KFDamageType> EMPDamageType;
var const float MaxEMPLength;
var const Vector EMPExtent;
var int EMPDamage;
var array<EMPBlastHitInfo> Victims;
var float ApplyDamageDelay;
var const bool bDrawDebugEMP;
var float GrappleTime;

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    super(KFSM_PlaySingleAnim).SpecialMoveStarted(bForced, PrevMove);
    KFPOwner.UpdateGameplayMICParams();
    KFPOwner.SetWeaponAmbientSound(EMPStartSFX);
    Victims.Length = 0;
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    super.SpecialMoveEnded(PrevMove, NextMove);
    DisableEMP();
    if((KFPOwner != none) && KFPOwner.IsAliveAndWell())
    {
        KFPOwner.UpdateGameplayMICParams();
    }
    KFPOwner.FlushPersistentDebugLines();
}

function ToggleEMP(bool bEnabled)
{
    local ParticleSysParam SourceParam;

    if(bEnabled)
    {
        if(EMPPSCTemplate != none)
        {
            EMPPSC = KFPOwner.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(EMPPSCTemplate, KFPOwner.Mesh, EMPSocketName, true);
            if(EMPPSC != none)
            {
                SourceParam.Name = 'SourceActor';
                SourceParam.ParamType = 6;
                SourceParam.Actor = KFPOwner;
                EMPPSC.InstanceParameters.AddItem(SourceParam;
                SetEMPEndPoint();
            }
        }        
    }
    else
    {
        DisableEMP();
        KFPOwner.SetWeaponAmbientSound(EMPEndSFX);
    }
}

function DisableEMP()
{
    ReleaseVictims();
    DeactivatePSC();
    DeactivateHitPSC();
}

function bool IsValidTarget(Actor HitActor)
{
    return (((Pawn(HitActor) != none) || (StaticMeshActor(HitActor) != none) && !StaticMeshActor(HitActor).bResetCapable) || SkeletalMeshActor(HitActor) != none) && WithinRange(HitActor);
}

function bool WithinRange(Actor HitActor)
{
    return VSizeSq(HitActor.Location - KFPOwner.Location) <= Square(MaxEMPLength);
}

function SetEMPEndPoint()
{
    local Vector SocketLocation, EMPEnd;
    local bool bHitTarget;
    local EMPBlastHitInfo BlastHitInfo;
    local Rotator SocketRot;
    local array<EMPBlastHitInfo> HitList;
    local Vector HitLoc, HitNrm;
    local Actor HitActor;

    KFPOwner.Mesh.GetSocketWorldLocationAndRotation(EMPSocketName, SocketLocation, SocketRot);
    bHitTarget = false;
    EMPEnd = SocketLocation + (vector(SocketRot) * MaxEMPLength);
    if(KFPOwner.InteractionPawn != none)
    {
        if(IsValidTarget(KFPOwner.InteractionPawn))
        {
            BlastHitInfo.HitActor = KFPOwner.InteractionPawn;
            BlastHitInfo.HitLocation = KFPOwner.InteractionPawn.Location;
            HitList.AddItem(BlastHitInfo;
        }        
    }
    else
    {
        GetEnemyByTrace(HitList, SocketLocation, EMPEnd);
    }
    foreach HitList(BlastHitInfo,)
    {
        if(IsValidTarget(BlastHitInfo.HitActor))
        {
            HitActor = KFPOwner.Trace(HitLoc, HitNrm, BlastHitInfo.HitLocation, SocketLocation);
            if(HitActor != BlastHitInfo.HitActor)
            {
                BlastHitInfo.HitLocation = HitLoc;                
            }
            else
            {
                bHitTarget = true;
                Victims.AddItem(BlastHitInfo;
            }
        }
        if(HitList.Length == 1)
        {
            EMPEnd = BlastHitInfo.HitLocation - vect(0, 0, 64);
        }        
    }    
    if(Victims.Length > 0)
    {
        if(ApplyDamageDelay > float(0))
        {
            KFPOwner.SetTimer(ApplyDamageDelay, false, 'ApplyDamage', self);            
        }
        else
        {
            ApplyDamage();
        }
    }
    EMPPSC.SetBeamTargetPoint(0, EMPEnd, 0);
    if(bHitTarget)
    {
        if((EMPHitPSC == none) && EMPHitPSCTemplate != none)
        {
            EMPHitPSC = KFPOwner.WorldInfo.MyEmitterPool.SpawnEmitter(EMPHitPSCTemplate, EMPEnd);
        }
        if(EMPHitPSC != none)
        {
            EMPHitPSC.SetAbsolute(true, true, false);
            EMPHitPSC.SetTranslation(EMPEnd);
            EMPHitPSC.SetRotation(rotator(EMPEnd - SocketLocation));
        }        
    }
    else
    {
        DeactivateHitPSC();
    }
    if(bDrawDebugEMP)
    {
        KFPOwner.FlushPersistentDebugLines();
        KFPOwner.DrawDebugLine(SocketLocation, EMPEnd, 100, 128, 255, true);
    }
}

function GetEnemyByTrace(out array<EMPBlastHitInfo> out_EMPBlastHitInfo, Vector StartLocation, Vector EndLocation)
{
    local Vector HitLocation, HitNormal;
    local Actor HitActor;
    local TraceHitInfo HitInfo;
    local EMPBlastHitInfo BlastHitInfo;

    out_EMPBlastHitInfo.Length = 0;
    HitActor = KFPOwner.Trace(HitLocation, HitNormal, EndLocation, StartLocation,, EMPExtent, HitInfo, KFPOwner.1);
    if(HitActor != none)
    {
        if(IsValidTarget(HitActor))
        {
            BlastHitInfo.HitActor = HitActor;
            BlastHitInfo.HitLocation = HitLocation;
            BlastHitInfo.HitInfo = HitInfo;
            out_EMPBlastHitInfo.AddItem(BlastHitInfo;
        }
    }
}

function ApplyDamage()
{
    local EMPBlastHitInfo BlastHitInfo;

    foreach Victims(BlastHitInfo,)
    {
        if(BlastHitInfo.HitActor != none)
        {
            BlastHitInfo.HitActor.TakeDamage(EMPDamage, KFPOwner.Controller, BlastHitInfo.HitLocation, vector(KFPOwner.Rotation), EMPDamageType, BlastHitInfo.HitInfo, KFPOwner);
            if(KFPawn(BlastHitInfo.HitActor) != none)
            {
                KFPawn(BlastHitInfo.HitActor).DoSpecialMove(36, true, PawnOwner);
            }
        }        
    }    
    if(Victims.Length > 0)
    {
        KFPOwner.SetTimer(GrappleTime, false, 'ReleaseVictims', self);
    }
}

function ReleaseVictims()
{
    local EMPBlastHitInfo BlastHitInfo;

    foreach Victims(BlastHitInfo,)
    {
        if((BlastHitInfo.HitActor != none) && KFPawn(BlastHitInfo.HitActor) != none)
        {
            KFPawn(BlastHitInfo.HitActor).EndSpecialMove(36);
        }        
    }    
    Victims.Length = 0;
}

function bool DeactivatePSC()
{
    if((EMPPSC != none) && EMPPSC.bIsActive)
    {
        EMPPSC.DeactivateSystem();
        EMPPSC = none;
        return true;
    }
    return false;
}

function bool DeactivateHitPSC()
{
    if((EMPHitPSC != none) && EMPHitPSC.bIsActive)
    {
        EMPHitPSC.DeactivateSystem();
        EMPHitPSC = none;
        return true;
    }
    return false;
}

defaultproperties
{
    EMPPSCTemplate=ParticleSystem'ZED_EvilDAR_EMIT.FX_EvilDar_Empblast_Beam'
    EMPHitPSCTemplate=ParticleSystem'ZED_EvilDAR_EMIT.FX_EvilDar_Empblast_Impact'
    EMPStartSFX=AkEvent'WW_ZED_Evil_DAR.Play_ZED_EvilDAR_SFX_EMP_LP'
    EMPEndSFX=AkEvent'WW_ZED_Evil_DAR.Stop_ZED_EvilDAR_SFX_EMP_LP'
    EMPSocketName=EMP_Blast
    EMPDamageType=Class'KFGame.KFDT_EMP'
    MaxEMPLength=2500
    EMPExtent=(X=15,Y=15,Z=15)
    EMPDamage=10
    GrappleTime=2.5
    AnimNames=/* Array type was not detected. */
    FireOffsets=/* Array type was not detected. */
    bUseCustomRotationRate=true
    bDisableTurnInPlace=true
    CustomRotationRate=(Pitch=50000,Yaw=25000,Roll=50000)
    Handle=KFSM_DAR_EMPAttack
}