/*******************************************************************************
 * KFExplosion_HRG_Vampire_BloodBall generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFExplosion_HRG_Vampire_BloodBall extends KFExplosionActorLingering
    config(Weapon)
    hidecategories(Navigation);

var() class<KFDamageType> HealingDamageType;
var() float HealingAmount;
var AkEvent SmokeLoopStartEvent;
var AkEvent SmokeLoopStopEvent;
var KFPerk CachedInstigatorPerk;
var float ChargePercentage;
var float DamageByChargePercentage;
var float fMinAmmoutHealing;
var float fMaxAmmoutHealing;
var float fAltMinAmmoutHealing;
var float fAltMaxAmmoutHealing;
var bool bHealsInstigator;
var bool bHealsDifferentAmmoutToInstigator;
var float ImpactDecalSizeMax;
var float ImpactDecalSizeMin;

simulated function SpawnExplosionParticleSystem(ParticleSystem Template)
{
    local editinline ParticleSystemComponent PSC;
    local Vector vec;

    if(!ExplosionTemplate.bAllowPerMaterialFX && Template == none)
    {
        Template = KFGameExplosion(ExplosionTemplate).ExplosionEffects.DefaultImpactEffect.ParticleTemplate;
    }
    PSC = WorldInfo.MyEmitterPool.SpawnEmitter(Template, Location, rotator(ExplosionTemplate.HitNormal), none);
    vec.X = ChargePercentage;
    vec.Y = ChargePercentage;
    vec.Z = ChargePercentage;
    PSC.SetVectorParameter(name("BlobCharge"), vec);
    PSC.SetFloatParameter(name("MineFxControlParam"), ChargePercentage);
}

simulated function Explode(GameExplosion NewExplosionTemplate, optional Vector Direction)
{
    local KFPawn KFP;

    super.Explode(NewExplosionTemplate, Direction);
    if(Instigator != none)
    {
        KFP = KFPawn(Instigator);
        if(KFP != none)
        {
            CachedInstigatorPerk = KFP.GetPerk();
        }
    }
    if(Role == ROLE_Authority)
    {
        SetTimer(interval, false, 'DelayedExplosionDamage', self);
    }
}

protected simulated function AffectsPawn(Pawn Victim, float DamageScale)
{
    local KFPawn_Human HumanVictim;
    local KFPawn_Monster MonsterVictim;
    local KFProj_MedicGrenade OwnerProjectile;
    local bool bCanRepairArmor;
    local Box BBox;
    local Vector BBoxCenter;
    local Actor HitActor;
    local bool bDamageBlocked;
    local float AmountToHeal;

    if((Victim != none) && Victim.IsAliveAndWell())
    {
        MonsterVictim = KFPawn_Monster(Victim);
        if(MonsterVictim != none)
        {
            if((bWasFadedOut || bDeleteMe) || bPendingDelete)
            {
                return;
            }
            Victim.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            HitActor = TraceExplosive(BBoxCenter, Location + vect(0, 0, 20));
            bDamageBlocked = (HitActor != none) && HitActor != Victim;
            if(bDamageBlocked && HitActor.IsA('KFDoorActor'))
            {
                bDamageBlocked = false;
            }
            if(!bDamageBlocked)
            {
                Victim.TakeRadiusDamage(InstigatorController, ExplosionTemplate.Damage * DamageScale, ExplosionTemplate.DamageRadius, ExplosionTemplate.MyDamageType, ExplosionTemplate.MomentumTransferScale, Location, bDoFullDamage, ((Owner != none) ? Owner : self), ExplosionTemplate.DamageFalloffExponent);
            }            
        }
        else
        {
            Victim.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            HitActor = TraceExplosive(BBoxCenter, Location + vect(0, 0, 20));
            bDamageBlocked = (HitActor != none) && HitActor != Victim;
            if(bDamageBlocked && HitActor.IsA('KFDoorActor'))
            {
                bDamageBlocked = false;
            }
            if(!bDamageBlocked)
            {
                if(!bHealsInstigator && Victim == Instigator)
                {
                    return;
                }
                HumanVictim = KFPawn_Human(Victim);
                if((HumanVictim != none) && HumanVictim.GetExposureTo(Location) > float(0))
                {
                    OwnerProjectile = KFProj_MedicGrenade(Owner);
                    if(OwnerProjectile != none)
                    {
                        bCanRepairArmor = OwnerProjectile.HealedPawns.Find(HumanVictim == -1;
                    }
                    if((bHealsDifferentAmmoutToInstigator && bHealsInstigator) && Victim == Instigator)
                    {
                        AmountToHeal = FMax(fAltMinAmmoutHealing, Lerp(fAltMinAmmoutHealing, fAltMaxAmmoutHealing, DamageByChargePercentage));
                        HumanVictim.HealDamage(int(AmountToHeal), InstigatorController, HealingDamageType, bCanRepairArmor);                        
                    }
                    else
                    {
                        AmountToHeal = FMax(fMinAmmoutHealing, Lerp(fMinAmmoutHealing, fMaxAmmoutHealing, DamageByChargePercentage));
                        HumanVictim.HealDamage(int(AmountToHeal), InstigatorController, HealingDamageType, bCanRepairArmor);
                    }
                    if(bCanRepairArmor)
                    {
                        OwnerProjectile.HealedPawns.AddItem(HumanVictim;
                    }
                }
            }
        }
    }
}

protected simulated function UpdateExplosionTemplateWithPerMaterialFX(PhysicalMaterial PhysMaterial)
{
    super(KFExplosionActor).UpdateExplosionTemplateWithPerMaterialFX(PhysMaterial);
    if(PhysMaterial == none)
    {
        MyImpactEffect = KFGameExplosion(ExplosionTemplate).ExplosionEffects.DefaultImpactEffect;        
    }
    else
    {
        if(WorldInfo.MyImpactEffectManager != none)
        {
            KFImpactEffectManager(WorldInfo.MyImpactEffectManager).GetImpactEffect(PhysMaterial, MyImpactEffect, KFGameExplosion(ExplosionTemplate).ExplosionEffects);
        }
    }
    if(MyImpactEffect.ParticleTemplate != none)
    {
        ExplosionTemplate.ExplosionSound = MyImpactEffect.Sound;
    }
}

simulated function SpawnExplosionDecal()
{
    local MaterialInterface MI;
    local MaterialInstanceTimeVarying MITV_Decal;
    local int DecalMaterialsLength;
    local float DecalSize, DecalThickness;
    local KFGameExplosion KFExplosionTemplate;

    if(WorldInfo.bDropDetail)
    {
        return;
    }
    if(!ExplosionTemplate.bAllowPerMaterialFX)
    {
        KFExplosionTemplate = KFGameExplosion(ExplosionTemplate);
        if((KFExplosionTemplate == none) || KFExplosionTemplate.ExplosionEffects == none)
        {
            return;
        }
        MyImpactEffect = KFExplosionTemplate.ExplosionEffects.DefaultImpactEffect;
    }
    DecalMaterialsLength = MyImpactEffect.DecalMaterials.Length;
    if(DecalMaterialsLength > 0)
    {
        MI = MyImpactEffect.DecalMaterials[Rand(DecalMaterialsLength)];
        if(MI != none)
        {
            DecalSize = Lerp(ImpactDecalSizeMin, ImpactDecalSizeMax, ChargePercentage);
            DecalThickness = DecalSize * 2;
            if(MaterialInstanceTimeVarying(MI) != none)
            {
                MITV_Decal = new (self) Class'MaterialInstanceTimeVarying';
                MITV_Decal.SetParent(MI);
                WorldInfo.ExplosionDecalManager.SpawnDecal(MITV_Decal, ExplosionTemplate.HitLocation, rotator(-ExplosionTemplate.HitNormal), DecalSize, DecalSize, DecalThickness, false, ((MyImpactEffect.bNoDecalRotation) ? 0 : FRand() * 360));
                MITV_Decal.SetScalarStartTime(MyImpactEffect.DecalDissolveParamName, MyImpactEffect.DecalDuration);                
            }
            else
            {
                WorldInfo.ExplosionDecalManager.SpawnDecal(MI, ExplosionTemplate.HitLocation, rotator(-ExplosionTemplate.HitNormal), DecalSize, DecalSize, DecalThickness, true, ((MyImpactEffect.bNoDecalRotation) ? 0 : FRand() * 360),,,,,,, MyImpactEffect.DecalDuration);
            }
        }
    }
}

defaultproperties
{
    HealingDamageType=Class'KFGame.KFDT_Healing'
    fMinAmmoutHealing=12
    fMaxAmmoutHealing=60
    fAltMinAmmoutHealing=1
    fAltMaxAmmoutHealing=5
    ImpactDecalSizeMax=425
    ImpactDecalSizeMin=178
    interval=0
    maxTime=0
    bSkipLineCheckForPawns=true
    FadeOutTime=0
    bExplodeMoreThanOnce=false
}