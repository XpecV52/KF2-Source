/*******************************************************************************
 * KFAIController_ZedBloatKing generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController_ZedBloatKing extends KFAIController_ZedBloat
    config(AI)
    hidecategories(Navigation);

var KFPawn_ZedBloatKing BloatPawn;
var float LostSightSprintDelay;
/** How often to spawn a new pack of minions. This is done continuously throughout the fight. */
var() const float MinionSpawnTimer[4];
var Vector2D NumMinionsToSpawn[4];
var KFAIWaveInfo ContinuousSpawnWaveInfos[4];
var float ArmorEnrageTimer;
var float NextSpecialMoveCheck;
var float NextGorgeAttackCheck;
var float NextHumanGorgeAttackCheck;
var float LastRetargetTime;
var Vector2D RetargetWaitTimeRange;
var transient float ActualRetargetWaitTime;

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    super(KFAIController_Monster).Possess(inPawn, bVehicleTransition);
    BloatPawn = KFPawn_ZedBloatKing(inPawn);
    NextSpecialMoveCheck = 0.5;
    NextGorgeAttackCheck = Class'KFSM_BloatKing_Gorge'.default.GorgeAttackCheckDelay;
    SetTimer(2, true, 'StartMinionWaves');
    LastRetargetTime = WorldInfo.TimeSeconds;
    ActualRetargetWaitTime = RandRange(RetargetWaitTimeRange.X, RetargetWaitTimeRange.Y);
}

simulated function Tick(float DeltaTime)
{
    super(KFAIController).Tick(DeltaTime);
    EvaluateSpecialMoves(DeltaTime);
}

function EvaluateSpecialMoves(float DeltaTime)
{
    if((CommandList != none) && CommandList.Class == Class'AICommand_BossTheatrics')
    {
        return;
    }
    NextSpecialMoveCheck -= DeltaTime;
    NextGorgeAttackCheck -= DeltaTime;
    NextHumanGorgeAttackCheck -= DeltaTime;
    if((NextSpecialMoveCheck > 0) || BloatPawn.IsDoingSpecialMove())
    {
        return;
    }
    if(NextGorgeAttackCheck < float(0))
    {
        if(CanDoGorgeAttack())
        {
            TriggerGorge();
            return;            
        }
        else
        {
            NextGorgeAttackCheck = Class'KFSM_BloatKing_Gorge'.default.GorgeAttackCheckDelay;
        }
    }
    NextSpecialMoveCheck = 0.5;
}

function TriggerGorge(optional bool bForced)
{
    bForced = false;
    Class'AICommand_BloatKing_Gorge'.static.StartGorge(self);
    if(!bForced)
    {
        NextHumanGorgeAttackCheck = Class'KFSM_BloatKing_Gorge'.static.GetGorgeCooldown(MyKFPawn, int(WorldInfo.Game.GameDifficulty));
    }
}

function bool CanDoGorgeAttack()
{
    local KFPawn KFP;
    local Vector ViewDirection, ToTarget;
    local float DotAngle, ToTargetRange;

    ViewDirection = vector(MyKFPawn.Rotation);
    foreach BloatPawn.GorgeTrigger.TouchingActors(Class'KFPawn', KFP)
    {
        if(!KFP.IsAliveAndWell() || !Class'KFSM_BloatKing_Gorge'.static.IsValidPullClass(KFP))
        {
            continue;            
        }
        if(NextHumanGorgeAttackCheck > float(0))
        {
            if(KFP.IsHumanControlled())
            {
                continue;                
            }
        }
        ToTarget = KFP.Location - MyKFPawn.Location;
        ToTargetRange = VSizeSq(ToTarget);
        if(KFP.IsHumanControlled() && ToTargetRange > Class'KFSM_BloatKing_Gorge'.default.GorgeHumanAttackRangeSq)
        {
            continue;                        
        }
        else
        {
            if(ToTargetRange > Class'KFSM_BloatKing_Gorge'.default.GorgeAttackRangeSq)
            {
                continue;                
            }
        }
        DotAngle = ViewDirection Dot Normal(ToTarget);
        if((DotAngle > Class'KFSM_BloatKing_Gorge'.default.GorgeMinAttackAngle) && MyKFPawn.FastTrace(KFP.Location, MyKFPawn.Location))
        {            
            return true;
        }        
    }    
    return false;
}

event SeePlayer(Pawn Seen)
{
    super(KFAIController).SeePlayer(Seen);
    EvaluateSprinting();
    if((((((Seen == none) || !Seen.IsAliveAndWell()) || Pawn.IsSameTeam(Seen)) || Pawn == none) || !Pawn.IsAliveAndWell()) || !Seen.CanAITargetThisPawn(self))
    {
        return;
    }
    LastEnemySightedTime = WorldInfo.TimeSeconds;
}

function NotifySpecialMoveEnded(KFSpecialMove SM)
{
    super(KFAIController).NotifySpecialMoveEnded(SM);
    EvaluateSprinting();
    if((SM.Handle == 'KFSM_MeleeAttack') && (WorldInfo.TimeSeconds - LastRetargetTime) > ActualRetargetWaitTime)
    {
        CheckForEnemiesInFOV(3000, -1, 1, true);
    }
}

event ChangeEnemy(Pawn NewEnemy, optional bool bCanTaunt)
{
    local Pawn OldEnemy;

    bCanTaunt = true;
    OldEnemy = Enemy;
    super(KFAIController).ChangeEnemy(NewEnemy, bCanTaunt);
    if(OldEnemy != Enemy)
    {
        LastRetargetTime = WorldInfo.TimeSeconds;
        ActualRetargetWaitTime = RandRange(RetargetWaitTimeRange.X, RetargetWaitTimeRange.Y);
    }
}

function EvaluateSprinting()
{
    if(((MyKFPawn != none) && MyKFPawn.IsAliveAndWell()) && Enemy != none)
    {
        if(ShouldSprint())
        {
            MyKFPawn.SetSprinting(true);            
        }
        else
        {
            MyKFPawn.SetSprinting(false);
        }
    }
}

function bool ShouldSprint()
{
    local float DistToEnemy, CurrentSprintDistance;

    if(MyKFPawn.IsDoingSpecialMove(17))
    {
        return false;        
    }
    else
    {
        if(MyKFPawn.IsEnraged())
        {
            return true;            
        }
        else
        {
            if((LastEnemySightedTime == float(0)) || (WorldInfo.TimeSeconds - LastEnemySightedTime) > LostSightSprintDelay)
            {
                return true;                
            }
            else
            {
                DistToEnemy = VSizeSq(Enemy.Location - Pawn.Location);
                CurrentSprintDistance = Lerp(SprintWithinEnemyRange.X, SprintWithinEnemyRange.Y, MyKFPawn.GetHealthPercentage());
                if(DistToEnemy < (CurrentSprintDistance * CurrentSprintDistance))
                {
                    return true;                    
                }
                else
                {
                    return false;
                }
            }
        }
    }
    return false;
}

function StartMinionWaves()
{
    local KFGameInfo KFGI;
    local float TimerIdx;

    if((CommandList != none) && CommandList.Class == Class'AICommand_BossTheatrics')
    {
        LogInternal("*** Still not done with theatrics");
        return;
    }
    ClearTimer('StartMinionWaves');
    KFGI = KFGameInfo(WorldInfo.Game);
    TimerIdx = float(Clamp(int(KFGI.GameDifficulty), 0, 3));
    SetTimer(MinionSpawnTimer[int(TimerIdx)], true, 'SpawnMinions');
}

function SpawnMinions()
{
    local KFAIWaveInfo SpawnInfo;
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    SpawnInfo = GetWaveInfo(int(KFGI.GameDifficulty));
    KFGI.SpawnManager.SummonBossMinions(SpawnInfo.Squads, GetNumMinionsToSpawn(), false);
    SetTimer(2, true, 'PauseBossWave');
}

function PauseBossWave()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI.SpawnManager.GetNumAINeeded() <= 0)
    {
        ClearTimer('PauseBossWave');
        KFGI.SpawnManager.StopSummoningBossMinions();
    }
}

function KFAIWaveInfo GetWaveInfo(int GameDifficulty)
{
    return ContinuousSpawnWaveInfos[Clamp(GameDifficulty, 0, 3)];
}

function byte GetNumMinionsToSpawn()
{
    local KFGameInfo KFGI;

    KFGI = KFGameInfo(WorldInfo.Game);
    if(KFGI != none)
    {
        return byte(Lerp(NumMinionsToSpawn[int(KFGI.GameDifficulty)].X, NumMinionsToSpawn[int(KFGI.GameDifficulty)].Y, float(KFGameInfo(WorldInfo.Game).GetLivingPlayerCount()) / float(WorldInfo.Game.MaxPlayers)));
    }
    return byte(Lerp(NumMinionsToSpawn[0].X, NumMinionsToSpawn[0].Y, FMax(float(WorldInfo.Game.NumPlayers), 1) / float(WorldInfo.Game.MaxPlayers)));
}

function SetEnrageTimer()
{
    SetTimer(ArmorEnrageTimer, false, 'EndArmorEnrage');
}

function StartArmorEnrage()
{
    MyKFPawn.SetEnraged(true);
}

function EndArmorEnrage()
{
    MyKFPawn.SetEnraged(false);
}

function EnterZedVictoryState()
{
    MyKFGameInfo.SpawnManager.StopSummoningBossMinions();
    BloatPawn.ClearFartTimer();
    super(KFAIController).EnterZedVictoryState();
}

state ZedVictory
{
    ignores NotifyTakeHit, NotifyKilled, NotifySpecialMoveEnded, NotifyFleeFinished, SeePlayer, CheckForEnemiesInFOV, 
	    EvaluateSprinting, ChangeEnemy, SetEnemy, FindNewEnemy;
Begin:

    Sleep(0.1);
    Class'AICommand_BossTheatrics'.static.DoTheatrics(self, 1, -1);
    stop;                    
}

defaultproperties
{
    LostSightSprintDelay=5
    MinionSpawnTimer[0]=70
    MinionSpawnTimer[1]=65
    MinionSpawnTimer[2]=65
    MinionSpawnTimer[3]=60
    NumMinionsToSpawn[0]=(X=5,Y=30)
    NumMinionsToSpawn[1]=(X=6,Y=66)
    NumMinionsToSpawn[2]=(X=6,Y=36)
    NumMinionsToSpawn[3]=(X=8,Y=48)
    ContinuousSpawnWaveInfos[0]=KFAIWaveInfo'GP_Spawning_ARCH.Special.Boss.BloatKing_Normal_WaveInfo'
    ContinuousSpawnWaveInfos[1]=KFAIWaveInfo'GP_Spawning_ARCH.Special.Boss.BloatKing_Normal_WaveInfo'
    ContinuousSpawnWaveInfos[2]=KFAIWaveInfo'GP_Spawning_ARCH.Special.Boss.BloatKing_Normal_WaveInfo'
    ContinuousSpawnWaveInfos[3]=KFAIWaveInfo'GP_Spawning_ARCH.Special.Boss.BloatKing_Normal_WaveInfo'
    ArmorEnrageTimer=9
    RetargetWaitTimeRange=(X=4.4,Y=5)
    SprintWithinEnemyRange=(X=2500,Y=500)
    AggroEnemySwitchWaitTime=7
}