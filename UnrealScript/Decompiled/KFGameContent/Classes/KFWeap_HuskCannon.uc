/*******************************************************************************
 * KFWeap_HuskCannon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_HuskCannon extends KFWeapon
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

var float MaxChargeTime;
var float ValueIncreaseTime;
var float DmgIncreasePerCharge;
var float AOEIncreasePerCharge;
var float IncapIncreasePerCharge;
var int AmmoIncreasePerCharge;
var transient float ChargeTime;
var transient float ConsumeAmmoTime;
var transient float MaxChargeLevel;
var ParticleSystem ChargingEffect;
var ParticleSystem ChargedEffect;
var const ParticleSystem MuzzleFlashEffectL1;
var const ParticleSystem MuzzleFlashEffectL2;
var const ParticleSystem MuzzleFlashEffectL3;
var export editinline transient ParticleSystemComponent ChargingPSC;
var transient bool bIsFullyCharged;
var const WeaponFireSndInfo FullyChargedSound;
var float SelfDamageReductionValue;
var float FullChargedTimerInterval;

static simulated event KFGame.KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter()
{
    return 4;
}

static simulated function float CalculateTraderWeaponStatDamage()
{
    local float CalculatedDamage;
    local class<KFDamageType> DamageType;
    local GameExplosion ExplosionInstance;

    ExplosionInstance = class<KFProjectile>(default.WeaponProjectiles[0]).default.ExplosionTemplate;
    CalculatedDamage = default.InstantHitDamage[0] + ExplosionInstance.Damage;
    DamageType = class<KFDamageType>(ExplosionInstance.MyDamageType);
    if((DamageType != none) && DamageType.default.DoT_Type != 0)
    {
        CalculatedDamage += ((DamageType.default.DoT_Duration / DamageType.default.DoT_Interval) * (CalculatedDamage * DamageType.default.DoT_DamageScale));
    }
    return CalculatedDamage;
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    local KFPerk InstigatorPerk;

    InstigatorPerk = GetPerk();
    if((InstigatorPerk != none) && InstigatorPerk.GetIsUberAmmoActive(self))
    {
        return;
    }
    if((Role == ROLE_Authority) || bAllowClientAmmoTracking)
    {
        super.ConsumeAmmo(FireModeNum);
    }
}

simulated function StartFire(byte FireModeNum)
{
    if(IsTimerActive('RefireCheckTimer'))
    {
        return;
    }
    super.StartFire(FireModeNum);
}

simulated function OnStartFire()
{
    local KFPawn PawnInst;

    PawnInst = KFPawn(Instigator);
    if(PawnInst != none)
    {
        PawnInst.OnStartFire();
    }
}

simulated function FireAmmunition()
{
    HandleWeaponShotTaken(CurrentFireMode);
    switch(WeaponFireTypes[CurrentFireMode])
    {
        case 0:
            if((self.WorldInfo.TimeDilation < 1) && WeaponProjectiles[CurrentFireMode] != none)
            {
                ProjectileFire();                
            }
            else
            {
                InstantFireClient();
            }
            break;
        case 1:
            ProjectileFire();
            break;
        case 2:
            CustomFire();
            break;
        default:
            break;
    }
    if((GetChargeLevel()) < 1)
    {
        ConsumeAmmo(CurrentFireMode);
    }
    NotifyWeaponFired(CurrentFireMode);
    PlayFireEffects(CurrentFireMode, vect(0, 0, 0));
}

simulated function Timer_StopFireEffects()
{
    if(WorldInfo.NetMode == NM_Client)
    {
        Instigator.WeaponStoppedFiring(self, false);
    }
    ClearFlashCount();
    ClearFlashLocation();
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProj_HuskCannon_Fireball HuskBall;
    local int Charges;

    HuskBall = KFProj_HuskCannon_Fireball(super.SpawnProjectile(KFProjClass, RealStartLoc, AimDir));
    if(HuskBall != none)
    {
        Charges = GetChargeLevel();
        HuskBall.DamageScale = 1 + (DmgIncreasePerCharge * float(Charges));
        HuskBall.AOEScale = 1 + (AOEIncreasePerCharge * float(Charges));
        HuskBall.IncapScale = 1 + (IncapIncreasePerCharge * float(Charges));
        return HuskBall;
    }
    return none;
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if(MuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(MuzzleFlash != none)
    {
        switch(GetChargeFXLevel())
        {
            case 1:
                MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL1;
                MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL1);
                break;
            case 2:
                MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL2;
                MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL2);
                break;
            case 3:
                MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL3;
                MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL3);
                break;
            default:
                break;
        }
    }
    else
    {
        super.CauseMuzzleFlash(FireModeNum);
    }
}

simulated function int GetChargeLevel()
{
    return Min(int(ChargeTime / ValueIncreaseTime), int(MaxChargeLevel));
}

simulated function int GetChargeFXLevel()
{
    local int ChargeLevel;

    ChargeLevel = GetChargeLevel();
    if(ChargeLevel < 1)
    {
        return 1;        
    }
    else
    {
        if(float(ChargeLevel) < MaxChargeLevel)
        {
            return 2;            
        }
        else
        {
            return 3;
        }
    }
}

function AdjustDamage(out int InDamage, class<DamageType> DamageType, Actor DamageCauser)
{
    super.AdjustDamage(InDamage, DamageType, DamageCauser);
    if(((Instigator != none) && DamageCauser != none) && DamageCauser.Instigator == Instigator)
    {
        InDamage *= SelfDamageReductionValue;
    }
}

simulated function int GetModifiedDamage(byte FireModeNum, optional Vector RayDir)
{
    local int ModifiedDamage;

    ModifiedDamage = super.GetModifiedDamage(FireModeNum, RayDir);
    if(FireModeNum == 0)
    {
        ModifiedDamage = int(float(ModifiedDamage) * (1 + (DmgIncreasePerCharge * float(GetChargeLevel()))));
    }
    return ModifiedDamage;
}

simulated state HuskCannonCharge extends WeaponFiring
{
    ignores FireAmmunition;

    simulated event BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        ChargeTime = 0;
        ConsumeAmmoTime = 0;
        MaxChargeLevel = float(int(MaxChargeTime / ValueIncreaseTime));
        if(ChargingPSC == none)
        {
            ChargingPSC = new (self) Class'ParticleSystemComponent';
            if(MySkelMesh != none)
            {
                MySkelMesh.AttachComponentToSocket(ChargingPSC, 'MuzzleFlash');                
            }
            else
            {
                AttachComponent(ChargingPSC);
            }            
        }
        else
        {
            ChargingPSC.ActivateSystem();
        }
        bIsFullyCharged = false;
        global.OnStartFire();
        if(ChargingPSC != none)
        {
            ChargingPSC.SetTemplate(ChargingEffect);
        }
    }

    simulated function bool ShouldRefire()
    {
        return StillFiring(CurrentFireMode);
    }

    simulated event Tick(float DeltaTime)
    {
        local float ChargeRTPC;

        global.Tick(DeltaTime);
        if(PendingFire(CurrentFireMode))
        {
            ConsumeAmmoTime += DeltaTime;
        }
        if(bIsFullyCharged)
        {
            if(ConsumeAmmoTime >= FullChargedTimerInterval)
            {
                ConsumeAmmoTime -= FullChargedTimerInterval;
            }
            return;
        }
        if(PendingFire(CurrentFireMode))
        {
            ChargeTime += DeltaTime;
        }
        ChargeRTPC = FMin(ChargeTime / MaxChargeTime, 1);
        KFPawn(Instigator).SetWeaponComponentRTPCValue("Weapon_Charge", ChargeRTPC);
        Instigator.SetRTPCValue('Weapon_Charge', ChargeRTPC);
        if(ConsumeAmmoTime >= ValueIncreaseTime)
        {
            ConsumeAmmo(0);
            ConsumeAmmoTime -= ValueIncreaseTime;
        }
        if((ChargeTime >= MaxChargeTime) || !HasAmmo(0))
        {
            bIsFullyCharged = true;
            ChargingPSC.SetTemplate(ChargedEffect);
            KFPawn(Instigator).SetWeaponAmbientSound(FullyChargedSound.DefaultCue, FullyChargedSound.FirstPersonCue);
        }
    }

    simulated event EndState(name NextStateName)
    {
        ClearZedTimeResist();
        ClearPendingFire(CurrentFireMode);
        ClearTimer('RefireCheckTimer');
        KFPawn(Instigator).bHasStartedFire = false;
        KFPawn(Instigator).bNetDirty = true;
        if(ChargingPSC != none)
        {
            ChargingPSC.DeactivateSystem();
        }
        KFPawn(Instigator).SetWeaponAmbientSound(none);
    }

    simulated function HandleFinishedFiring()
    {
        global.FireAmmunition();
        if(bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
        if(MuzzleFlash != none)
        {
            SetTimer(MuzzleFlash.MuzzleFlash.Duration, false, 'Timer_StopFireEffects');            
        }
        else
        {
            SetTimer(0.3, false, 'Timer_StopFireEffects');
        }
        NotifyWeaponFinishedFiring(CurrentFireMode);
        super(Weapon).HandleFinishedFiring();
    }
    stop;    
}

defaultproperties
{
    MaxChargeTime=1
    ValueIncreaseTime=0.2
    DmgIncreasePerCharge=0.8
    AOEIncreasePerCharge=0.6
    IncapIncreasePerCharge=0.22
    AmmoIncreasePerCharge=1
    ChargingEffect=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_Charging_01'
    ChargedEffect=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_Charged_01'
    MuzzleFlashEffectL1=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_MuzzleFlash_L1_1P'
    MuzzleFlashEffectL2=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_MuzzleFlash_L2_1P'
    MuzzleFlashEffectL3=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_MuzzleFlash_L3_1P'
    FullyChargedSound=(DefaultCue=AkEvent'WW_WEP_Husk_Cannon.Play_WEP_Husk_Cannon_Charged_3P',FirstPersonCue=AkEvent'WW_WEP_Husk_Cannon.Play_WEP_Husk_Cannon_Charged')
    SelfDamageReductionValue=0.1
    FullChargedTimerInterval=2
    PackageKey="HuskCannon"
    FirstPersonMeshName="WEP_1P_HuskCannon_MESH.Wep_1stP_HuskCannon_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="wep_3p_huskcannon_mesh.Wep_3rdP_HuskCannon_Pickup"
    AttachmentArchetypeName="WEP_HuskCannon_ARCH.Wep_HuskCannon_3P"
    MuzzleFlashTemplateName="WEP_HuskCannon_ARCH.Wep_HuskCannon_MuzzleFlash"
    bHasIronSights=true
    bCanBeReloaded=true
    bReloadFromMagazine=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=8
    MeshFOV=80
    MeshIronSightFOV=65
    PlayerIronSightFOV=50
    DOF_FG_FocalRadius=150
    DOF_FG_MaxNearBlurSize=1
    GroupPriority=75
    WeaponSelectTexture=Texture2D'WEP_UI_HuskCannon_TEX.UI_WeaponSelect_HuskCannon'
    MagazineCapacity=30
    SpareAmmoCapacity=150
    InitialSpareMags=1
    AmmoPickupScale=0.75
    WeaponFireWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Weak_Recoil'
    bLoopingFireAnim=/* Array type was not detected. */
    bLoopingFireSnd=/* Array type was not detected. */
    FireSightedAnims=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponFireLoopEndSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=20,Y=12,Z=-1)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_HuskCannon.MeleeHelper'
    maxRecoilPitch=150
    minRecoilPitch=115
    maxRecoilYaw=115
    minRecoilYaw=-115
    RecoilRate=0.085
    RecoilViewRotationScale=0.25
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=75
    RecoilISMinYawLimit=65460
    RecoilISMaxPitchLimit=375
    RecoilISMinPitchLimit=65460
    HippedRecoilModifier=1.5
    IronSightMeshFOVCompensationScale=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=4.5,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_HuskCannon.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="Husk Cannon"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HuskCannon.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HuskCannon.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}