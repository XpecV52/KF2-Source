/*******************************************************************************
 * KFSM_Matriarch_TeslaBlast generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_Matriarch_TeslaBlast extends KFSM_PlaySingleAnim;

var name WindUpAnimName;
var name WindDownAnimName;
var float MaxVictimDistance;
var name ShootingSocketName;
var KFPawn_ZedMatriarch MyMatPawn;

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    super.SpecialMoveStarted(bForced, PrevMove);
    PlayWindUpAnimation();
    MyMatPawn = KFPawn_ZedMatriarch(KFPOwner);
    MyMatPawn.SetGunTracking(true);
    MyMatPawn.PlayTeslaBlastDialog();
}

function SpecialMoveFlagsUpdated()
{
    switch(KFPOwner.SpecialMoveFlags)
    {
        case 1:
            PlayFireAnim();
            break;
        case 2:
            KFPOwner.EndSpecialMove();
            break;
        default:
            break;
    }
}

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    switch(DeferredSeqName)
    {
        case WindUpAnimName:
            if(KFPOwner.Role == ROLE_Authority)
            {
                if(PrefireBeamCheck())
                {
                    KFPOwner.DoSpecialMove(22, true,, 1);                    
                }
                else
                {
                    KFPOwner.DoSpecialMove(22, true,, 2);
                }
            }
            break;
        case AnimName:
            KFPOwner.EndSpecialMove();
            break;
        default:
            break;
    }
}

function bool PrefireBeamCheck()
{
    local Actor HitActor;
    local Vector SocketLocation, HitLocation, HitNormal, ToEnemy, TraceEnd, GunTargetBoneLocation;

    local Rotator SocketRotation;

    PawnOwner.Mesh.GetSocketWorldLocationAndRotation(ShootingSocketName, SocketLocation, SocketRotation);
    GunTargetBoneLocation = KFPOwner.Controller.Enemy.Mesh.GetBoneLocation(MyMatPawn.GunTargetBoneName);
    ToEnemy = Normal(GunTargetBoneLocation - SocketLocation);
    TraceEnd = SocketLocation + (ToEnemy * MaxVictimDistance);
    HitActor = PawnOwner.Trace(HitLocation, HitNormal, TraceEnd, SocketLocation, true);
    return KFPawn(HitActor) != none;
}

function PlayAnimation();

function PlayWindUpAnimation()
{
    KFPOwner.ZeroMovementVariables();
    PlaySpecialMoveAnim(WindUpAnimName, 0, BlendInTime, BlendOutTime, 1);
}

function PlayFireAnim()
{
    PlaySpecialMoveAnim(AnimName, 0, 0.1, 0.2);
    KFPOwner.ZeroMovementVariables();
    if((KFPOwner.Role == ROLE_Authority) || KFPOwner.IsLocallyControlled())
    {
        KFPOwner.Weapon.StartFire(0);
    }
}

function PlayWindDownAnim()
{
    if((KFPOwner.Weapon != none) && !KFPOwner.Weapon.IsInState('Active'))
    {
        KFPOwner.StopFiring();
        KFPOwner.Weapon.GotoState('Active');
    }
    KFPOwner.ZeroMovementVariables();
    PlaySpecialMoveAnim(WindDownAnimName, 0, BlendInTime, BlendOutTime, 1);
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    super.SpecialMoveEnded(PrevMove, NextMove);
    MyMatPawn.SetGunTracking(false);
}

defaultproperties
{
    WindUpAnimName=Tesla_Blast_TO_Load
    WindDownAnimName=Tesla_Blast_TO_Idle
    MaxVictimDistance=2500
    ShootingSocketName=Hand_FX_End_L
    AnimName=Tesla_Blast_Shoot
    bDisableMovement=true
    bDisableSteering=false
    bAllowFireAnims=true
    bShouldDeferToPostTick=true
    Handle=KFSM_Matriarch_TeslaBlast
}