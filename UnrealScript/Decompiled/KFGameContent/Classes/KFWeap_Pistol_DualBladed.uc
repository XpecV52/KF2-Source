/*******************************************************************************
 * KFWeap_Pistol_DualBladed generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_Pistol_DualBladed extends KFWeap_DualBase
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const BLOCK_FIREMODE = 1;
const MeleeBlockStartAnim = 'Brace_in';
const MeleeBlockLoopAnim = 'Brace_loop';
const MeleeBlockEndAnim = 'Brace_out';

struct native BlockEffectInfo
{
    var class<DamageType> dmgType;
    var AkEvent BlockSound;
    var AkEvent ParrySound;
    var ParticleSystem BlockParticleSys;
    var ParticleSystem ParryParticleSys;

    structdefaultproperties
    {
        dmgType=none
        BlockSound=none
        ParrySound=none
        BlockParticleSys=none
        ParryParticleSys=none
    }
};

var array<BlockEffectInfo> BlockTypes;
/** Damage while blocking will be mitigated by this percentage */
var() float BlockDamageMitigation;
/** Parry damage will be mitigated by this percentage */
var() float ParryDamageMitigationPercent;
/** Hit reaction strength to bypass pawn's ParryStumbleResist */
var() byte ParryStrength;
var bool bMoveAtWalkingSpeed;
/** Time between block hit reaction anims */
var() protected float BlockHitAnimCooldownTime;
var protected transient float LastBlockHitAnimTime;
var array<name> MeleeBlockHitAnims;
var AkBaseSoundObject BlockSound;
var AkBaseSoundObject ParrySound;
var ParticleSystem BlockParticleSystem;
var ParticleSystem ParryParticleSystem;
var name BlockEffectsSocketName;
var array<name> BonesToLockOnEmpty_Override;

simulated function NotifyAttackParried();

simulated function NotifyAttackBlocked();

simulated function BlockLoopTimer();

simulated function ParryCheckTimer();

unreliable client simulated function ClientPlayBlockEffects(optional byte BlockTypeIndex)
{
    local AkBaseSoundObject Sound;
    local ParticleSystem PSTemplate;

    BlockTypeIndex = 255;
    GetBlockEffects(BlockTypeIndex, Sound, PSTemplate);
    PlayLocalBlockEffects(Sound, PSTemplate);
}

reliable client simulated function ClientPlayParryEffects(optional byte BlockTypeIndex)
{
    local AkBaseSoundObject Sound;
    local ParticleSystem PSTemplate;
    local KFPerk InstigatorPerk;

    BlockTypeIndex = 255;
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.SetSuccessfullParry();
    }
    GetParryEffects(BlockTypeIndex, Sound, PSTemplate);
    PlayLocalBlockEffects(Sound, PSTemplate);
}

simulated function float PlayBlockStart()
{
    local float AnimDuration;

    if(Instigator.IsLocallyControlled())
    {
        PlayAnimation('Brace_in');
    }
    AnimDuration = MySkelMesh.GetAnimLength('Brace_in');
    if(AnimDuration > 0)
    {
        SetTimer(AnimDuration, false, 'BlockLoopTimer');        
    }
    else
    {
        BlockLoopTimer();
    }
    return AnimDuration;
}

simulated function PlayLocalBlockEffects(AkBaseSoundObject Sound, ParticleSystem PSTemplate)
{
    local Vector Loc;
    local Rotator Rot;
    local editinline ParticleSystemComponent PSC;

    if(Sound != none)
    {
        PlaySoundBase(Sound, true);
    }
    if(PSTemplate != none)
    {
        if(MySkelMesh.GetSocketWorldLocationAndRotation(BlockEffectsSocketName, Loc, Rot))
        {
            PSC = WorldInfo.MyEmitterPool.SpawnEmitter(PSTemplate, Loc, Rot);
            PSC.SetDepthPriorityGroup(2);            
        }
        else
        {
            LogInternal((string(self) @ string(GetFuncName())) @ "missing BlockEffects Socket!");
        }
    }
}

function bool CanBlockDamageType(class<DamageType> DamageType, optional out byte out_Idx)
{
    local int Idx;

    Idx = 0;
    J0x0C:

    if(Idx < BlockTypes.Length)
    {
        if(ClassIsChildOf(DamageType, BlockTypes[Idx].dmgType))
        {
            out_Idx = byte(Idx);
            return true;
        }
        ++ Idx;
        goto J0x0C;
    }
    out_Idx = 255;
    return false;
}

simulated function GetBlockEffects(byte BlockIndex, out AkBaseSoundObject outSound, out ParticleSystem outParticleSys)
{
    outSound = BlockSound;
    outParticleSys = BlockParticleSystem;
    if(BlockIndex != 255)
    {
        if(BlockTypes[BlockIndex].BlockSound != none)
        {
            outSound = BlockTypes[BlockIndex].BlockSound;
        }
        if(BlockTypes[BlockIndex].BlockParticleSys != none)
        {
            outParticleSys = BlockTypes[BlockIndex].BlockParticleSys;
        }
    }
}

simulated function GetParryEffects(byte BlockIndex, out AkBaseSoundObject outSound, out ParticleSystem outParticleSys)
{
    outSound = ParrySound;
    outParticleSys = ParryParticleSystem;
    if(BlockIndex != 255)
    {
        if(BlockTypes[BlockIndex].ParrySound != none)
        {
            outSound = BlockTypes[BlockIndex].ParrySound;
        }
        if(BlockTypes[BlockIndex].ParryParticleSys != none)
        {
            outParticleSys = BlockTypes[BlockIndex].ParryParticleSys;
        }
    }
}

simulated function BlockCooldownTimer();

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    if(bUsingSights)
    {
        SetIronSights(false);
    }
    StartFire(1);
}

simulated function bool CanOverrideMagReload(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        return true;
    }
    return super(KFWeapon).CanOverrideMagReload(FireModeNum);
}

static simulated function float GetUpgradedBlockDamageMitigation(int UpgradeIndex)
{
    return GetUpgradedStatValue(default.BlockDamageMitigation, 3, UpgradeIndex);
}

static simulated function float GetUpgradedParryDamageMitigation(int UpgradeIndex)
{
    return GetUpgradedStatValue(default.ParryDamageMitigationPercent, 4, UpgradeIndex);
}

simulated function int GetModifiedDamage(byte FireModeNum, optional Vector RayDir)
{
    if(FireModeNum == 3)
    {
        return int(GetUpgradedStatValue(InstantHitDamage[FireModeNum], 7, CurrentWeaponUpgradeIndex));
    }
    return super(KFWeapon).GetModifiedDamage(FireModeNum, RayDir);
}

simulated function UpdateOutOfAmmoEffects(float BlendTime)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(EmptyMagBlendNode != none)
    {
        if(bAllowClientAmmoTracking && AmmoCount[0] <= 1)
        {
            EmptyMagBlendNode.SetBlendTarget(1, 0);
            if(AmmoCount[0] == 0)
            {
                EmptyMagBlendNode = AnimNodeBlendPerBone(SkeletalMeshComponent(Mesh).FindAnimNode('EmptyMagBlend'));
                BuildEmptyMagNodeWeightList(EmptyMagBlendNode, BonesToLockOnEmpty_Override);
                EmptyMagBlendNode.SetBlendTarget(1, 0);
                LogInternal("blending left");
                EmptyMagBlendNode_L.SetBlendTarget(1, 0);
            }
        }
    }
}

simulated function ANIMNOTIFY_UnLockBolt()
{
    super.ANIMNOTIFY_UnLockBolt();
    EmptyMagBlendNode_L.SetBlendTarget(0, 0);
    EmptyMagBlendNode = AnimNodeBlendPerBone(SkeletalMeshComponent(Mesh).FindAnimNode('EmptyMagBlend'));
    BuildEmptyMagNodeWeightList(EmptyMagBlendNode, BonesToLockOnEmpty);
}

simulated state MeleeBlocking
{
    ignores ForceReload, ShouldAutoReload;

    simulated function bool AllowIronSights()
    {
        return false;
    }

    simulated function byte GetWeaponStateId()
    {
        return 26;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local float ParryDuration;

        ParryDuration = PlayBlockStart();
        if(ParryDuration > 0)
        {
            SetTimer(ParryDuration, false, 'ParryCheckTimer');
        }
        NotifyBeginState();
    }

    simulated function EndState(name NextStateName)
    {
        if(Instigator.IsLocallyControlled())
        {
            PlayAnimation('Brace_out');
        }
        NotifyEndState();
    }

    simulated function EndFire(byte FireModeNum)
    {
        global.EndFire(FireModeNum);
        if(!StillFiring(CurrentFireMode) && !IsTimerActive('ParryCheckTimer'))
        {
            GotoState('BlockingCooldown');
        }
    }

    simulated function ParryCheckTimer()
    {
        if(!StillFiring(CurrentFireMode))
        {
            GotoState('BlockingCooldown');
        }
    }

    function bool IsGrappleBlocked(Pawn InstigatedBy)
    {
        local float FacingDot;
        local Vector Dir2d;

        Dir2d = Normal2D(InstigatedBy.Location - Instigator.Location);
        FacingDot = vector(Instigator.Rotation) Dot Dir2d;
        if(FacingDot > 0.087)
        {
            if(IsTimerActive('ParryCheckTimer'))
            {
                KFPawn(InstigatedBy).NotifyAttackParried(Instigator, 255);
                ClientPlayParryEffects();
                NotifyAttackParried();                
            }
            else
            {
                ClientPlayBlockEffects();
                NotifyAttackBlocked();
            }
            return true;
        }
        return false;
    }

    function AdjustDamage(out int InDamage, class<DamageType> DamageType, Actor DamageCauser)
    {
        local float FacingDot;
        local Vector Dir2d;
        local KFPerk InstigatorPerk;
        local byte BlockTypeIndex;

        if(Instigator.IsSameTeam(DamageCauser.Instigator))
        {
            return;
        }
        Dir2d = Normal2D(DamageCauser.Location - Instigator.Location);
        FacingDot = vector(Instigator.Rotation) Dot Dir2d;
        if((FacingDot > 0.087) && CanBlockDamageType(DamageType, BlockTypeIndex))
        {
            InstigatorPerk = GetPerk();
            if(IsTimerActive('ParryCheckTimer'))
            {
                InDamage *= (GetUpgradedParryDamageMitigation(CurrentWeaponUpgradeIndex));
                if(KFPawn(DamageCauser) != none)
                {
                    KFPawn(DamageCauser).NotifyAttackParried(Instigator, ParryStrength);
                }
                ClientPlayParryEffects(BlockTypeIndex);
                NotifyAttackParried();
                if(InstigatorPerk != none)
                {
                    InstigatorPerk.SetSuccessfullParry();
                }                
            }
            else
            {
                InDamage *= (GetUpgradedBlockDamageMitigation(CurrentWeaponUpgradeIndex));
                ClientPlayBlockEffects(BlockTypeIndex);
                NotifyAttackBlocked();
                if(InstigatorPerk != none)
                {
                    InstigatorPerk.SetSuccessfullBlock();
                }
            }
        }
    }

    simulated function BlockLoopTimer()
    {
        if(Instigator.IsLocallyControlled())
        {
            PlayAnimation('Brace_loop',, true);
        }
    }

    unreliable client simulated function ClientPlayBlockEffects(optional byte BlockTypeIndex)
    {
        local int AnimIdx;
        local float Duration;
        local KFPerk InstigatorPerk;

        BlockTypeIndex = 255;
        global.ClientPlayBlockEffects(BlockTypeIndex);
        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            InstigatorPerk.SetSuccessfullBlock();
        }
        if(((MeleeBlockHitAnims.Length > 0) && (WorldInfo.TimeSeconds - LastBlockHitAnimTime) > BlockHitAnimCooldownTime) && !IsTimerActive('ParryCheckTimer'))
        {
            AnimIdx = Rand(MeleeBlockHitAnims.Length);
            Duration = MySkelMesh.GetAnimLength(MeleeBlockHitAnims[AnimIdx]);
            if(Duration > float(0))
            {
                LastBlockHitAnimTime = WorldInfo.TimeSeconds;
                PlayAnimation(MeleeBlockHitAnims[AnimIdx]);
                SetTimer(Duration, false, 'BlockLoopTimer');
            }
        }
    }
    stop;    
}

simulated state BlockingCooldown extends Active
{
    ignores AllowSprinting;

    simulated function BeginState(name PreviousStateName)
    {
        SetTimer(0.5, false, 'BlockCooldownTimer');
        super.BeginState(PreviousStateName);
    }

    simulated function bool HasAmmo(byte FireModeNum, optional int Amount)
    {
        if(FireModeNum == 1)
        {
            return false;
        }
        return global.HasAmmo(FireModeNum, Amount);
    }

    simulated function bool ShouldAutoReload(byte FireModeNum)
    {
        if(FireModeNum == 1)
        {
            return false;
        }
        return global.ShouldAutoReload(FireModeNum);
    }

    simulated function BlockCooldownTimer()
    {
        GotoState('Active');
    }
    stop;    
}

defaultproperties
{
    BlockTypes(0)=(dmgType=Class'KFGame.KFDT_Bludgeon',BlockSound=none,ParrySound=none,BlockParticleSys=none,ParryParticleSys=none)
    BlockTypes(1)=(dmgType=Class'KFGame.KFDT_Slashing',BlockSound=none,ParrySound=none,BlockParticleSys=none,ParryParticleSys=none)
    BlockDamageMitigation=0.6
    ParryDamageMitigationPercent=0.5
    ParryStrength=4
    BlockHitAnimCooldownTime=0.5
    MeleeBlockHitAnims(0)=Block_Hit_V1
    MeleeBlockHitAnims(1)=Block_Hit_V2
    MeleeBlockHitAnims(2)=Block_Hit_V3
    BlockSound=AkEvent'WW_WEP_Bullet_Impacts.Play_Block_MEL_Crovel'
    ParrySound=AkEvent'WW_WEP_Bullet_Impacts.Play_Parry_Metal'
    BlockParticleSystem=ParticleSystem'FX_Impacts_EMIT.FX_Block_melee_01'
    ParryParticleSystem=ParticleSystem'FX_Impacts_EMIT.FX_Parry_melee_01'
    BlockEffectsSocketName=BlockEffect
    BonesToLockOnEmpty_Override(0)=RW_FrontPivot
    BonesToLockOnEmpty_Override(1)=LW_FrontPivot
    LeftFireOffset=(X=30,Y=-7,Z=-5)
    SingleClass=Class'KFWeap_Pistol_Bladed'
    BonesToLockOnEmpty_L=/* Array type was not detected. */
    PackageKey="Dual_BladedPistol"
    FirstPersonMeshName="WEP_1P_Dual_BladedPistol_MESH.WEP_1stP_DualBladedPistol_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="WEP_3P_Dual_BladedPistol_MESH.Wep_Dual_BladedPistol_Pickup"
    AttachmentArchetypeName="WEP_Dual_BladedPistol_ARCH.Wep_Dual_BladedPistol_3P"
    MuzzleFlashTemplateName="WEP_Dual_BladedPistol_ARCH.Wep_Dual_BladedPistol_MuzzleFlash"
    bHasIronSights=true
    bCanBeReloaded=true
    bReloadFromMagazine=true
    bHasFireLastAnims=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=6
    PenetrationPower=/* Array type was not detected. */
    MeshFOV=96
    MeshIronSightFOV=77
    PlayerIronSightFOV=77
    IronSightPosition=(X=-3,Y=0,Z=0)
    QuickWeaponDownRotation=(Pitch=-8192,Yaw=0,Roll=0)
    DOF_FG_FocalRadius=40
    DOF_FG_MaxNearBlurSize=3.5
    GroupPriority=45
    WeaponSelectTexture=Texture2D'WEP_UI_Dual_BladedPistol_TEX.UI_WeaponSelect_Dual_BladedPistol'
    MagazineCapacity=12
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCapacity=72
    InitialSpareMags=1
    AmmoPickupScale=0.5
    BonesToLockOnEmpty=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=-15,Y=0,Z=0)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_Pistol_DualBladed.MeleeHelper'
    maxRecoilPitch=330
    minRecoilPitch=300
    maxRecoilYaw=120
    minRecoilYaw=-120
    RecoilRate=0.07
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=50
    RecoilISMinYawLimit=65485
    RecoilISMaxPitchLimit=250
    RecoilISMinPitchLimit=65485
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    UpgradeFireModes[1]=0
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=7,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_Pistol_DualBladed.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="Dual Piranha Pistols"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_Pistol_DualBladed.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_Pistol_DualBladed.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}