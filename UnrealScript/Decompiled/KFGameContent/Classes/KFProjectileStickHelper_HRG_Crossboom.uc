/*******************************************************************************
 * KFProjectileStickHelper_HRG_Crossboom generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProjectileStickHelper_HRG_Crossboom extends KFProjectileStickHelper within KFProjectile;

var() float MinDistanceFromPlayer;
var() float DampingFactor;
var() bool bAltFire;

simulated function TryStick(Vector HitNormal, optional Vector HitLocation, optional Actor HitActor)
{
    local TraceHitInfo HitInfo;

    if(((Outer.Instigator == none) || !Outer.Instigator.IsLocallyControlled()) || (Outer.Physics == 0) && Outer.StuckToActor != none)
    {
        return;
    }
    if((HitActor != none) && (HitActor == Outer.StuckToActor) || HitActor == PinPawn)
    {
        return;
    }
    GetImpactInfo(Outer.Velocity, HitLocation, HitNormal, HitInfo);
    if((HitInfo.HitComponent != none) && GetImpactResult(HitActor, HitInfo.HitComponent))
    {
        Stick(HitActor, HitLocation, HitNormal, HitInfo);
        if(Outer.WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(bAltFire)
            {
                KFImpactEffectManager(Outer.WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, Outer.Instigator,, KFProj_Bolt_HRG_CrossboomAlt(Outer).ImpactEffects);                
            }
            else
            {
                KFImpactEffectManager(Outer.WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, Outer.Instigator,, KFProj_Bolt_HRG_Crossboom(Outer).ImpactEffects);
            }
        }
    }
}

simulated function Stick(Actor HitActor, Vector HitLocation, Vector HitNormal, const out TraceHitInfo HitInfo)
{
    local int BoneIdx;
    local KFPawn_Monster HitMonster;
    local array<ImpactInfo> HitZoneImpactList;
    local Vector StartTrace, EndTrace, Direction, ClosestBoneLocation;
    local name BoneName;

    BoneName = HitInfo.BoneName;
    HitMonster = KFPawn_Monster(HitActor);
    if(HitMonster != none)
    {
        StartTrace = HitLocation;
        Direction = Normal(Outer.Velocity);
        EndTrace = StartTrace + (Direction * (HitMonster.CylinderComponent.CollisionRadius * 6));
        Outer.TraceProjHitZones(HitMonster, EndTrace, StartTrace, HitZoneImpactList);
        if(BoneName == 'None')
        {
            ClosestBoneLocation = HitMonster.Mesh.GetClosestCollidingBoneLocation(HitLocation, true, false);
            BoneName = HitMonster.Mesh.FindClosestBone(ClosestBoneLocation, ClosestBoneLocation);
        }
        if(KFWeapon(Outer.Owner) != none)
        {
            HitZoneImpactList[0].RayDir = Normal(EndTrace - StartTrace);
            KFWeapon(Outer.Owner).HandleProjectileImpact(Outer.WeaponFireMode, HitZoneImpactList[0], Outer.PenetrationPower);
        }        
    }
    else
    {
        if(HitActor.bCanBeDamaged)
        {
            if(Outer.Role != ROLE_Authority)
            {
                if(KFProj_Bolt_HRG_Crossboom(Outer) != none)
                {
                    KFProj_Bolt_HRG_Crossboom(Outer).OnCollectibleHit(HitActor);                    
                }
                else
                {
                    if(KFProj_Bolt_HRG_CrossboomAlt(Outer) != none)
                    {
                        KFProj_Bolt_HRG_CrossboomAlt(Outer).OnCollectibleHit(HitActor);
                    }
                }                
            }
            else
            {
                HitActor.TakeDamage(int(Outer.Damage), Outer.InstigatorController, Outer.Location, Outer.MomentumTransfer * Normal(Outer.Velocity), Outer.MyDamageType, HitInfo, Outer.Owner);
            }
        }
    }
    if(!IsZero(HitLocation))
    {
        Outer.SetLocation(HitLocation);
    }
    Outer.SetStickOrientation(HitNormal);
    BoneIdx = -1;
    if(BoneName != 'None')
    {
        BoneIdx = GetBoneIndexFromActor(HitActor, BoneName);
    }
    StickToActor(HitActor, HitInfo.HitComponent, BoneIdx, true);
    if(Outer.Role < ROLE_Authority)
    {
        Outer.ServerStick(HitActor, BoneIdx, Outer.StuckToLocation, Outer.StuckToRotation);
    }
    if((Outer.WorldInfo.NetMode != NM_DedicatedServer) && StickAkEvent != none)
    {
        Outer.PlaySoundBase(StickAkEvent);
    }
}

simulated function StickToActor(Actor StickTo, PrimitiveComponent HitComp, int BoneIdx, optional bool bCalculateRelativeLocRot)
{
    local editinline SkeletalMeshComponent SkelMeshComp;
    local name BoneName;
    local Vector RelStuckToLocation;
    local Rotator RelStuckToRotation;
    local KFPawn StickToPawn;

    StickToPawn = KFPawn(StickTo);
    if(Outer.bCanPin && (StickToPawn == none) || StickToPawn.bCanBePinned)
    {
        if(Outer.Role == ROLE_Authority)
        {
            if((StickToPawn != none) && !StickToPawn.IsAliveAndWell())
            {
                if(PinPawn == none)
                {
                    Pin(StickTo, BoneIdx);
                }
                return;
            }
        }
        if((Outer.WorldInfo.NetMode != NM_DedicatedServer) && PinPawn != none)
        {
            if(StickToPawn == none)
            {
                PinPawn.Mesh.SetRBPosition(Outer.Location, PinBoneName);
                PinConstraint = Outer.Spawn(Class'RB_ConstraintActorSpawnable',,, Outer.Location);
                PinConstraint.InitConstraint(PinPawn, none, PinBoneName, 'None');
            }
            PinPawn = none;
        }
    }
    Outer.SetPhysics(0);
    Outer.PrevStuckToActor = Outer.StuckToActor;
    Outer.StuckToActor = StickTo;
    Outer.StuckToBoneIdx = BoneIdx;
    if(BoneIdx != -1)
    {
        SkelMeshComp = SkeletalMeshComponent(HitComp);
        BoneName = SkelMeshComp.GetBoneName(BoneIdx);
        if(bCalculateRelativeLocRot)
        {
            Outer.StuckToLocation = Outer.Location;
            Outer.StuckToRotation = Outer.Rotation;
        }
        SkelMeshComp.TransformToBoneSpace(BoneName, Outer.StuckToLocation, Outer.StuckToRotation, RelStuckToLocation, RelStuckToRotation);
        Outer.SetBase(StickTo,, SkelMeshComp, BoneName);
        Outer.SetRelativeLocation(RelStuckToLocation);
        Outer.SetRelativeRotation(RelStuckToRotation);        
    }
    else
    {
        if(bCalculateRelativeLocRot)
        {
            Outer.StuckToLocation = Outer.Location;
            Outer.StuckToRotation = Outer.Rotation;            
        }
        else
        {
            Outer.SetLocation(Outer.StuckToLocation);
            Outer.SetRotation(Outer.StuckToRotation);
        }
        Outer.SetBase(StickTo);
    }
    if(bAltFire)
    {
        KFProj_Bolt_HRG_CrossboomAlt(Outer).NotifyStick();        
    }
    else
    {
        KFProj_Bolt_HRG_Crossboom(Outer).NotifyStick();
    }
}

simulated function UnStick()
{
    Outer.PrevStuckToActor = Outer.StuckToActor;
    Outer.StuckToActor = none;
    Outer.StuckToBoneIdx = -1;
    Outer.StuckToLocation = vect(0, 0, 0);
    Outer.StuckToRotation = rot(0, 0, 0);
    if(!Outer.PrevStuckToActor.bTearOff)
    {
        Outer.SetBase(none);
        Outer.SetPhysics(Outer.default.Physics);
    }
}

simulated function bool GetImpactResult(Actor HitActor, PrimitiveComponent HitComp)
{
    local editinline StaticMeshComponent StaticMeshComp;

    StaticMeshComp = StaticMeshComponent(HitComp);
    if(StaticMeshComp != none)
    {
        return true;
    }
    if(super.GetImpactResult(HitActor, HitComp))
    {
        return true;
    }
    return (InterpActor(HitActor) != none) && InterpActor(HitActor).bDestroyProjectilesOnEncroach;
}

defaultproperties
{
    MinDistanceFromPlayer=1500
    DampingFactor=0.02
}