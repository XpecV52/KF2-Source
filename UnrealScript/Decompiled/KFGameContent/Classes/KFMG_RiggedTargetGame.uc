/*******************************************************************************
 * KFMG_RiggedTargetGame generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFMG_RiggedTargetGame extends KFMG_TargetGame
    placeable
    hidecategories(Navigation);

enum eAnimationState
{
    EAS_Closed,
    EAS_Open,
    EAS_Active,
    EAS_Idle,
    EAS_Close,
    EAS_MAX
};

/** Archetype of target actor that will be spawned per-bone */
var() Actor TargetArchetype;
/** SKL actor used to drive animation of the minigame */
var() repnotify KFMGA_TargetGame MinigameRig;
var int TargetsRemaining;
var repnotify int AnimationIndex;
var repnotify int RigIndex;
var bool bLocalStarted;
var repnotify int EndGameState;
/** Time to take to blend to new animations (if using an AnimTree) */
var() array<float> BlendToTimes;

replication
{
     if(bNetDirty)
        AnimationIndex, EndGameState, 
        RigIndex;

     if(bNetInitial)
        MinigameRig;
}

simulated event ReplicatedEvent(name VarName)
{
    super(Actor).ReplicatedEvent(VarName);
    if(VarName == 'EndGameState')
    {
        if(EndGameState >= 0)
        {
            FinalizeGame();
        }        
    }
    else
    {
        if(VarName == 'AnimationIndex')
        {
            if((!bLocalStarted && AnimationIndex >= 0) && RigIndex >= 0)
            {
                StartupGame();
            }            
        }
        else
        {
            if(VarName == 'RigIndex')
            {
                if((!bLocalStarted && AnimationIndex >= 0) && RigIndex >= 0)
                {
                    StartupGame();
                }                
            }
            else
            {
                if(VarName == 'MinigameRig')
                {
                    MinigameRig.ParentGame = self;
                }
            }
        }
    }
}

event PostBeginPlay()
{
    local name BoneName;
    local Actor NewTarget;
    local KFMGA_Target RiggedTarget;

    super(Actor).PostBeginPlay();
    MinigameRig.ParentGame = self;
    if((MinigameRig != none) && TargetArchetype != none)
    {
        foreach MinigameRig.TargetBones(BoneName,)
        {
            NewTarget = Spawn(TargetArchetype.Class, self,,,, TargetArchetype);
            if(NewTarget != none)
            {
                MinigameTargets.AddItem(NewTarget;
                NewTarget.SetBase(MinigameRig,, MinigameRig.SkeletalMeshComponent, BoneName);
                RiggedTarget = KFMGA_Target(NewTarget);
                if(RiggedTarget != none)
                {
                    RiggedTarget.SetInactive();
                    RiggedTarget.SpawnerOwner = self;
                    RiggedTarget.SpawnerOwnerIndex = MinigameTargets.Length - 1;
                }
            }            
        }        
    }
}

simulated function Reset()
{
    local int I;

    super(Actor).Reset();
    SwitchAnim(0);
    if(!MinigameRig.SkeletalMeshComponent.Animations.IsA('AnimTree'))
    {
        MinigameRig.SkeletalMeshComponent.StopAnim();
    }
    MinigameRig.SetTickIsDisabled(true);
    bLocalStarted = false;
    I = 0;
    J0xD0:

    if(I < MinigameTargets.Length)
    {
        MinigameTargets[I].Reset();
        ++ I;
        goto J0xD0;
    }
}

function Activated(KFTrigger_MinigameButton ActivationSource)
{
    if((((RigIndex >= 0) && MinigameRig != none) && (MinigameRig.MinigameAnimData.Length > 0) || MinigameRig.SkeletalMeshComponent.AnimTreeTemplate != none) && MinigameTargets.Length == MinigameRig.TargetBones.Length)
    {
        super.Activated(ActivationSource);
        TargetsRemaining = MinigameTargets.Length;
        AnimationIndex = ((MinigameRig.MinigameAnimData[RigIndex].MinigameAnimations.Length > 0) ? Rand(MinigameRig.MinigameAnimData[RigIndex].MinigameAnimations.Length) : -1);
        StartupGame();
        EndGameState = -1;
    }
}

simulated function SwitchAnim(KFMG_RiggedTargetGame.eAnimationState SelectedState)
{
    local name AnimName;
    local bool bLoop;
    local AnimNodeBlendList BlendList;

    if(MinigameRig.SkeletalMeshComponent.Animations.IsA('AnimTree'))
    {
        BlendList = AnimNodeBlendList(MinigameRig.SkeletalMeshComponent.FindAnimNode('StateBlend'));
        if(BlendList != none)
        {
            BlendList.SetActiveChild(SelectedState, BlendToTimes[SelectedState]);
        }        
    }
    else
    {
        bLoop = false;
        switch(SelectedState)
        {
            case 0:
                AnimName = MinigameRig.IdleClosedAnim;
                bLoop = true;
                break;
            case 1:
                AnimName = MinigameRig.GameStartAnim;
                break;
            case 2:
                AnimName = MinigameRig.MinigameAnimData[RigIndex].MinigameAnimations[AnimationIndex];
                bLoop = true;
                break;
            case 3:
                AnimName = MinigameRig.IdleOpenAnim;
                break;
            case 4:
                AnimName = MinigameRig.GameEndAnim;
                break;
            default:
                break;
        }
        if(AnimName != 'None')
        {
            MinigameRig.SkeletalMeshComponent.PlayAnim(AnimName,, bLoop);
        }
    }
}

simulated function StartupGame()
{
    local float StartupTime;

    MinigameRig.SetTickIsDisabled(false);
    StartupTime = MinigameRig.SkeletalMeshComponent.GetAnimLength(MinigameRig.GameStartAnim);
    if((MinigameRig.SkeletalMeshComponent.AnimTreeTemplate != none) && !MinigameRig.SkeletalMeshComponent.Animations.IsA('AnimTree'))
    {
        MinigameRig.SkeletalMeshComponent.SetAnimTreeTemplate(MinigameRig.SkeletalMeshComponent.AnimTreeTemplate);
    }
    if(StartupTime > float(0))
    {
        SetTimer(StartupTime, false, 'DelayedStart');
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            SwitchAnim(NM_DedicatedServer);
        }        
    }
    else
    {
        DelayedStart();
    }
    EndGameState = -1;
    bLocalStarted = true;
}

simulated function DelayedStart()
{
    local int I;

    SwitchAnim(2);
    I = 0;
    J0x17:

    if(I < MinigameTargets.Length)
    {
        MinigameTargets[I].SetBase(MinigameRig,, MinigameRig.SkeletalMeshComponent, MinigameRig.TargetBones[I]);
        MinigameTargets[I].Reset();
        if(KFMGA_Target(MinigameTargets[I]) != none)
        {
            KFMGA_Target(MinigameTargets[I]).AttachBoneName = MinigameRig.TargetBones[I];
            KFMGA_Target(MinigameTargets[I]).SetActive();
        }
        ++ I;
        goto J0x17;
    }
}

function TargetHit(Actor Target, Controller HitInstigator)
{
    if(bGameRunning && MinigameTargets.Find(Target != -1)
    {
        -- TargetsRemaining;
        if((HitInstigator != none) && KillerControllers.Find(HitInstigator == -1)
        {
            KillerControllers.AddItem(HitInstigator;
        }
        if(TargetsRemaining <= 0)
        {
            MinigameComplete(true);
        }
    }
}

simulated function UpdateBase(KFMGA_Target Target)
{
    Target.SetBase(MinigameRig,, MinigameRig.SkeletalMeshComponent, MinigameRig.TargetBones[Target.SpawnerOwnerIndex]);
}

simulated event bool CanPlayAkEvent(Actor InOwner, name BoneName)
{
    local KFMGA_Target Target;
    local int I;

    I = 0;
    J0x0B:

    if(I < MinigameTargets.Length)
    {
        Target = KFMGA_Target(MinigameTargets[I]);
        if((Target != none) && Target.AttachBoneName == BoneName)
        {
            return Target.IsAlive();
        }
        ++ I;
        goto J0x0B;
    }
    return false;
}

function MinigameComplete(bool bVictory)
{
    EndGameState = ((bVictory) ? 0 : 1);
    super.MinigameComplete(bVictory);
}

simulated function FinalizeGame()
{
    local Actor Target;

    super.FinalizeGame();
    AnimationIndex = -1;
    foreach MinigameTargets(Target,)
    {
        if(KFMGA_Target(Target) != none)
        {
            KFMGA_Target(Target).SetInactive();
        }        
    }    
    HandleDelayedShutdown();
}

simulated function HandleDelayedShutdown()
{
    local float DelayTime;

    switch(EndGameState)
    {
        case 0:
            DelayTime = MinigameRig.PostVictoryIdleTime;
            break;
        case 1:
            DelayTime = MinigameRig.PostDefeatIdleTime;
            break;
        default:
            break;
    }
    if(DelayTime > float(0))
    {
        SetTimer(DelayTime, false, 'Finalize');
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            SwitchAnim(NM_Client);
        }        
    }
    else
    {
        Finalize();
    }
}

simulated function Finalize()
{
    local int I;
    local float ResetTime;

    I = 0;
    J0x0B:

    if(I < MinigameTargets.Length)
    {
        if(KFMGA_Target(MinigameTargets[I]) != none)
        {
            KFMGA_Target(MinigameTargets[I]).Finalize();
        }
        ++ I;
        goto J0x0B;
    }
    ResetTime = MinigameRig.SkeletalMeshComponent.GetAnimLength(MinigameRig.GameEndAnim);
    if(ResetTime > 0)
    {
        SetTimer(ResetTime, false, 'Reset');        
    }
    else
    {
        Reset();
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SwitchAnim(NM_MAX);
    }
}

defaultproperties
{
    AnimationIndex=-1
    BlendToTimes(0)=0
    BlendToTimes(1)=0
    BlendToTimes(2)=0
    BlendToTimes(3)=0.5
    BlendToTimes(4)=0
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFMG_RiggedTargetGame.Sprite'
    Components(0)=Sprite
}