/*******************************************************************************
 * KFGameInfo_Endless generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGameInfo_Endless extends KFGameInfo_Survival
    config(Game)
    hidecategories(Navigation,Movement,Collision);

var bool bIsInHoePlus;
var bool bUseSpecialWave;
var KFGameDifficulty_Endless EndlessDifficulty;
var() float BaseGameDifficulty;
var int CurrentFrameBooms;
var array<KFGame.KFAISpawnManager.EAIType> SpecialWaveTypes;
var KFGame.KFAISpawnManager.EAIType SpecialWaveType;
var const int SpecialWaveStart;
var const int OutbreakWaveStart;

event InitGame(string Options, out string ErrorMessage)
{
    super(KFGameInfo).InitGame(Options, ErrorMessage);
    GameLength = 2;
    BaseGameDifficulty = GameDifficulty;
    ResetDifficulty();
}

event PostBeginPlay()
{
    super.PostBeginPlay();
    OutbreakEvent.CacheGRI();
    OutbreakEvent.CacheWorldInfo();
}

function InitGRIVariables()
{
    super(KFGameInfo).InitGRIVariables();
    KFGameReplicationInfo_Endless(MyKFGRI).BaseGameDifficulty = byte(BaseGameDifficulty);
}

function InitSpawnManager()
{
    SpawnManager = new (self) SpawnManagerClasses[0];
    SpawnManager.Initialize();
    WaveMax = 255;
    MyKFGRI.WaveMax = WaveMax;
}

function ResetDifficulty()
{
    if(EndlessDifficulty == none)
    {
        EndlessDifficulty = KFGameDifficulty_Endless(DifficultyInfo);
    }
    if(EndlessDifficulty != none)
    {
        EndlessDifficulty.SetDifficultyScaling(BaseGameDifficulty);
        EndlessDifficulty.SetDifficultySettings(0);
    }
}

static function bool GetShouldShowLength()
{
    return false;
}

function WaveStarted()
{
    super.WaveStarted();
    if((bForceOutbreakWave && !bUseSpecialWave) || bForceOutbreakWave && KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode == -1)
    {
        TrySetNextWaveSpecial();
    }
    if(KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode != -1)
    {
        LogInternal("Starting Outbreak" @ string(KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode));
        StartOutbreakRound(KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode);        
    }
    else
    {
        if(bUseSpecialWave)
        {
            LogInternal("Starting special wave" @ string(SpecialWaveType));
        }
    }
    SetTimer(1, false, 'WaveStarted', KFGameReplicationInfo_Endless(GameReplicationInfo));
}

function byte GetWaveStartMessage()
{
    local int tempInt;

    if(MyKFGRI.IsSpecialWave(tempInt))
    {
        return 18;        
    }
    else
    {
        if(MyKFGRI.IsWeeklyWave(tempInt))
        {
            return 17;
        }
    }
    return super.GetWaveStartMessage();
}

function bool TrySetNextWaveSpecial()
{
    local float OutbreakPct, SpecialWavePct;
    local int OutbreakEventIdx;

    if(MyKFGRI.IsBossWave() || MyKFGRI.IsBossWaveNext())
    {
        return false;
    }
    OutbreakPct = EndlessDifficulty.GetOutbreakPctChance();
    SpecialWavePct = EndlessDifficulty.GetSpeicalWavePctChance();
    if(bForceOutbreakWave || ((WaveNum >= OutbreakWaveStart) && OutbreakPct > 0) && FRand() < OutbreakPct)
    {
        if(DebugForcedOutbreakIdx == -1)
        {
            OutbreakEventIdx = Rand(OutbreakEvent.SetEvents.Length);            
        }
        else
        {
            LogInternal("Forcing Outbreak" @ string(DebugForcedOutbreakIdx));
            OutbreakEventIdx = DebugForcedOutbreakIdx;
        }
        KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode = OutbreakEventIdx;
        bForceOutbreakWave = false;
        DebugForcedOutbreakIdx = -1;
        return true;        
    }
    else
    {
        if(bForceSpecialWave || ((WaveNum >= SpecialWaveStart) && SpecialWavePct > 0) && FRand() < SpecialWavePct)
        {
            bUseSpecialWave = true;
            if(DebugForceSpecialWaveZedType == -1)
            {
                SpecialWaveType = EndlessDifficulty.GetSpecialWaveType();                
            }
            else
            {
                LogInternal("Forcing Special Wave Type" @ string(byte(DebugForceSpecialWaveZedType)));
                SpecialWaveType = byte(DebugForceSpecialWaveZedType);
            }
            KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentSpecialMode = SpecialWaveType;
            bForceSpecialWave = false;
            DebugForceSpecialWaveZedType = -1;
            return true;
        }
    }
    bForceOutbreakWave = false;
    bForceSpecialWave = false;
    DebugForcedOutbreakIdx = -1;
    DebugForceSpecialWaveZedType = -1;
    return false;
}

function WaveEnded(KFGameInfo_Survival.EWaveEndCondition WinCondition)
{
    local KFPlayerController KFPC;

    WaveMax = byte(WaveNum + 2);
    MyKFGRI.WaveMax = WaveMax;
    if(KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode != -1)
    {
        EndOutbreakRound();
    }
    bUseSpecialWave = false;
    KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode = -1;
    KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentSpecialMode = -1;
    HellOnEarthPlusRoundIncrement();
    if(WinCondition == 0)
    {
        foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
        {
            if(KFPC != none)
            {
                KFPC.OnEndlessWaveComplete(WaveNum);
            }            
        }        
    }
    super.WaveEnded(WinCondition);
    TrySetNextWaveSpecial();
}

function HellOnEarthPlusRoundIncrement()
{
    if(bIsInHoePlus)
    {
        EndlessDifficulty.IncreaseZedUpgradePct();
        EndlessDifficulty.IncreaseZedFullUpgradePct();
    }
}

function BossDied(Controller Killer, optional bool bCheckWaveEnded)
{
    local KFPawn_Monster AIP;
    local KFPlayerController KFPC;

    bCheckWaveEnded = true;
    KFPC = KFPlayerController(Killer);
    if((KFPC != none) && KFPC.MatchStats != none)
    {
        KFPC.MatchStats.bKilledBoss = true;
    }
    foreach WorldInfo.AllPawns(Class'KFPawn_Monster', AIP)
    {
        if(AIP.Health > 0)
        {
            AIP.Died(none, none, AIP.Location);
        }        
    }    
    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPC != none)
        {
            KFPC.ClientOnBossDied();
        }        
    }    
    if(KFAISpawnManager_Endless(SpawnManager) != none)
    {
        KFAISpawnManager_Endless(SpawnManager).OnBossDied();
    }
    IncrementDifficulty();
    SetBossIndex();
    if(bCheckWaveEnded)
    {
        CheckWaveEnd(true);
    }
}

function SetBossIndex()
{
    local int OldBossIndex;
    local SpawnReplacement Replacement;
    local int ReplaceIdx;
    local bool bShouldCacheBoss;

    OldBossIndex = BossIndex;
    BossIndex = Rand(default.AIBossClassList.Length);
    bShouldCacheBoss = OldBossIndex != BossIndex;
    if(OutbreakEvent.ActiveEvent.BossSpawnReplacementList.Length > 0)
    {
        foreach OutbreakEvent.ActiveEvent.BossSpawnReplacementList(Replacement,)
        {
            if(Replacement.SpawnEntry == BossIndex)
            {
                ReplaceIdx = AIBossClassList.Find(Replacement.NewClass;
                if(ReplaceIdx != -1)
                {
                    bShouldCacheBoss = true;
                    BossIndex = ReplaceIdx;
                    goto J0x152;
                }
            }            
        }
        J0x152:
        
    }
    if(bShouldCacheBoss)
    {
        MyKFGRI.CacheSelectedBoss(BossIndex);
    }
}

function IncrementDifficulty()
{
    if(bIsInHoePlus)
    {
        EndlessDifficulty.IncrementHoePlus();
        LogInternal("Incrementing Hell on Earth Plus.");        
    }
    else
    {
        if(EndlessDifficulty.ShouldStartHoePlus())
        {
            StartHoePlus();
            LogInternal("Starting Hell on Earth Plus.");            
        }
        else
        {
            GameDifficulty = float(Clamp(int(GameDifficulty + float(1)), MinGameDifficulty, MaxGameDifficulty));
            MyKFGRI.GameDifficulty = byte(GameDifficulty);
            LogInternal("Increasing Difficulty to" @ string(GameDifficulty));
        }
        EndlessDifficulty.IncrementDifficulty();
    }
    if(KFAISpawnManager_Endless(SpawnManager) != none)
    {
        KFAISpawnManager_Endless(SpawnManager).OnDifficultyUpdated();
    }
    TimeBetweenWaves = int(GetTraderTime());
    UpdateGameSettings();
}

function class<KFPawn_Monster> GetAISpawnType(KFGame.KFAISpawnManager.EAIType AIType)
{
    local KFGame.KFAISpawnManager.EAIType OldAIType;
    local string OldAITypeStr, NewAITypeStr;
    local class<KFPawn_Monster> OverrideType;

    if(bUseSpecialWave)
    {
        return super(KFGameInfo).GetAISpawnType(SpecialWaveType);
    }
    if(ShouldFullyUpgradeAIType())
    {
        OldAIType = AIType;
        AIType = GetFullyUpgradedAIType(AIType);
        OldAITypeStr = SpawnManager.ZedTypeToString(OldAIType);
        NewAITypeStr = SpawnManager.ZedTypeToString(AIType);
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal((("Upgrade" @ OldAITypeStr) @ "to") @ NewAITypeStr);
        }        
    }
    else
    {
        if(ShouldUpgradeAIType())
        {
            OldAIType = AIType;
            AIType = GetUpgradedAIType(AIType);
            OldAITypeStr = SpawnManager.ZedTypeToString(OldAIType);
            NewAITypeStr = SpawnManager.ZedTypeToString(AIType);
            if(SpawnManager.bLogAISpawning)
            {
                LogInternal((("Upgrade" @ OldAITypeStr) @ "to") @ NewAITypeStr);
            }
        }
    }
    if((KFGameReplicationInfo_Endless(GameReplicationInfo).CurrentWeeklyMode != -1) && !MyKFGRI.IsBossWave() || OutbreakEvent.ActiveEvent.bAllowSpawnReplacementDuringBossWave)
    {
        OverrideType = OutbreakEvent.GetAISpawnOverrirde(AIType);
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal("KFGameInfo_Endless.GetAISpawnType - Force AI Type during Outbreak Event:" @ string(OverrideType));
        }
        return OverrideType;
    }
    return super(KFGameInfo).GetAISpawnType(AIType);
}

function bool ShouldUpgradeAIType()
{
    local float DieRoll;
    local bool bShouldUpgrade;
    local float UpgradeChance;

    bShouldUpgrade = false;
    if(bIsInHoePlus)
    {
        DieRoll = FRand();
        UpgradeChance = EndlessDifficulty.GetZedUpgradePctChance();
        bShouldUpgrade = DieRoll < UpgradeChance;
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal("Should Upgrade AI Type:" @ string(bShouldUpgrade));
        }
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal((((("bIsInHoePlus:" @ string(bIsInHoePlus)) @ "Upgrade Chance:") @ string(DieRoll)) @ "Zed Upgrade Chance:") @ string(UpgradeChance));
        }
    }
    return bShouldUpgrade;
}

function bool ShouldFullyUpgradeAIType()
{
    local float DieRoll;
    local bool bShouldUpgrade;
    local float UpgradeChance;

    if(bIsInHoePlus)
    {
        DieRoll = FRand();
        UpgradeChance = EndlessDifficulty.GetZedFullUpgradePctChance();
        bShouldUpgrade = bIsInHoePlus && DieRoll < UpgradeChance;
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal("Should Full Upgrade AI Type:" @ string(bShouldUpgrade));
        }
        if(SpawnManager.bLogAISpawning)
        {
            LogInternal((((("bIsInHoePlus:" @ string(bIsInHoePlus)) @ "Upgrade Chance:") @ string(DieRoll)) @ "Zed Upgrade Chance:") @ string(UpgradeChance));
        }
    }
    return bShouldUpgrade;
}

function KFGame.KFAISpawnManager.EAIType GetUpgradedAIType(KFGame.KFAISpawnManager.EAIType AIType)
{
    switch(AIType)
    {
        case 0:
            return 2;
        case 1:
            return 5;
        case 2:
            return 4;
        case 3:
            return 1;
        case 4:
            return 9;
        case 5:
            return 10;
        case 9:
            return 8;
        case 10:
            return 11;
        case 11:
            return 6;
        case 8:
            return 7;
        case 6:
        case 7:
        default:
            return AIType;
            break;
    }
}

function KFGame.KFAISpawnManager.EAIType GetFullyUpgradedAIType(KFGame.KFAISpawnManager.EAIType AIType)
{
    switch(AIType)
    {
        case 1:
        case 3:
        case 5:
        case 10:
        case 11:
        case 6:
            return 6;
        case 0:
        case 2:
        case 4:
        case 9:
        case 8:
        case 7:
            return 7;
        default:
            return AIType;
            break;
    }
}

function StartHoePlus()
{
    bIsInHoePlus = true;
    EndlessDifficulty.SetZedUpgradeToBase();
    EndlessDifficulty.SetZedFullUpgradeToBase();
}

function SetMonsterDefaults(KFPawn_Monster P)
{
    super(KFGameInfo).SetMonsterDefaults(P);
    OutbreakEvent.AdjustMonsterDefaults(P);
}

function float GetGameInfoSpawnRateMod()
{
    return 1 / OutbreakEvent.ActiveEvent.SpawnRateMultiplier;
}

function RestartPlayer(Controller NewPlayer)
{
    local KFPawn_Human KFPH;

    super.RestartPlayer(NewPlayer);
    KFPH = KFPawn_Human(NewPlayer.Pawn);
    OutbreakEvent.AdjustRestartedPlayer(KFPH);
}

function ReduceDamage(out int Damage, Pawn injured, Controller InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType, Actor DamageCauser, TraceHitInfo HitInfo)
{
    local StatAdjustments ToAdjust;
    local array<StatAdjustments> ZedsToAdjust;
    local KFPawn InstigatorPawn;

    super.ReduceDamage(Damage, injured, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser, HitInfo);
    if(InstigatedBy != none)
    {
        InstigatorPawn = KFPawn(InstigatedBy.Pawn);
    }
    ZedsToAdjust = EndlessDifficulty.GetZedsToAdjust();
    foreach ZedsToAdjust(ToAdjust,)
    {
        if(ClassIsChildOf(injured.Class, ToAdjust.ClassToAdjust))
        {
            Damage *= ToAdjust.DamageTakenScale;
        }
        if((InstigatorPawn != none) && ClassIsChildOf(InstigatorPawn.Class, ToAdjust.ClassToAdjust))
        {
            Damage *= ToAdjust.DamageDealtScale;
        }        
    }    
    OutbreakEvent.ReduceDamage(Damage, injured, InstigatedBy, DamageType, HitInfo);
}

function StartOutbreakRound(int OutbreakIdx)
{
    OutbreakEvent.SetActiveEvent(OutbreakIdx);
    OutbreakEvent.UpdateGRI();
    OutbreakEvent.SetWorldInfoOverrides();
    if((OutbreakEvent.ActiveEvent.GlobalDamageTickRate > 0) && OutbreakEvent.ActiveEvent.GlobalDamageTickAmount > 0)
    {
        SetTimer(OutbreakEvent.ActiveEvent.GlobalDamageTickRate, true, 'ApplyGlobalDamage', OutbreakEvent);
    }
}

function EndOutbreakRound()
{
    local KFPawn KFP;

    OutbreakEvent.ClearActiveEvent();
    foreach WorldInfo.AllPawns(Class'KFPawn', KFP)
    {
        KFP.IntendedBodyScale = 1;        
    }    
    if(IsTimerActive('ApplyGlobalDamage', OutbreakEvent))
    {
        ClearTimer('ApplyGlobalDamage', OutbreakEvent);
    }
}

function Tick(float DeltaTime)
{
    CurrentFrameBooms = 0;
    super(KFGameInfo).Tick(DeltaTime);
}

function ModifyGroundSpeed(KFPawn PlayerPawn, out float GroundSpeed)
{
    super(KFGameInfo).ModifyGroundSpeed(PlayerPawn, GroundSpeed);
    OutbreakEvent.ModifyGroundSpeed(PlayerPawn, GroundSpeed);
}

function float GetTotalWaveCountScale()
{
    if(WaveNum == (WaveMax - 1))
    {
        return 1;
    }
    if(OutbreakEvent.ActiveEvent.WaveAICountScale.Length > 0)
    {
        return (((GetLivingPlayerCount()) > OutbreakEvent.ActiveEvent.WaveAICountScale.Length) ? OutbreakEvent.ActiveEvent.WaveAICountScale[OutbreakEvent.ActiveEvent.WaveAICountScale.Length - 1] : OutbreakEvent.ActiveEvent.WaveAICountScale[(GetLivingPlayerCount()) - 1]);
    }
    return 1;
}

function ScoreDamage(int DamageAmount, int HealthBeforeDamage, Controller InstigatedBy, Pawn DamagedPawn, class<DamageType> DamageType)
{
    super(KFGameInfo).ScoreDamage(DamageAmount, HealthBeforeDamage, InstigatedBy, DamagedPawn, DamageType);
    OutbreakEvent.AdjustScoreDamage(InstigatedBy, DamagedPawn, DamageType);
}

function ScoreHeal(int HealAmount, int HealthBeforeHeal, Controller InstigatedBy, Pawn HealedPawn, class<DamageType> DamageType)
{
    super(GameInfo).ScoreHeal(HealAmount, HealthBeforeHeal, InstigatedBy, HealedPawn, DamageType);
    if(OutbreakEvent.ActiveEvent.bScaleOnHealth)
    {
        OutbreakEvent.AdjustPawnScale(HealedPawn);
    }
}

function PassiveHeal(int HealAmount, int HealthBeforeHeal, Controller InstigatedBy, Pawn HealedPawn)
{
    super(KFGameInfo).PassiveHeal(HealAmount, HealthBeforeHeal, InstigatedBy, HealedPawn);
    if(OutbreakEvent.ActiveEvent.bScaleOnHealth)
    {
        OutbreakEvent.AdjustPawnScale(HealedPawn);
    }
}

function ScoreKill(Controller Killer, Controller Other)
{
    super(KFGameInfo).ScoreKill(Killer, Other);
    if(((Role == ROLE_Authority) && Other != none) && Other.Pawn != none)
    {
        OutbreakEvent.OnScoreKill(Other.Pawn);
    }
}

function NotifyRally(KFPawn RalliedPawn)
{
    super(KFGameInfo).NotifyRally(RalliedPawn);
    if(OutbreakEvent.ActiveEvent.bUseBeefcakeRules)
    {
        OutbreakEvent.AdjustForBeefcakeRules(RalliedPawn, 1);
    }
}

function NotifyIgnoredScream(KFPawn ScreamPawn)
{
    super(KFGameInfo).NotifyIgnoredScream(ScreamPawn);
    if(OutbreakEvent.ActiveEvent.bUseBeefcakeRules)
    {
        OutbreakEvent.AdjustForBeefcakeRules(ScreamPawn, 2);
    }
}

function DoDeathExplosion(Pawn DeadPawn, KFGameExplosion ExplosionTemplate, class<KFPawn> ExplosionIgnoreClass)
{
    local KFExplosionActorReplicated ExploActor;

    if(CurrentFrameBooms < OutbreakEvent.ActiveEvent.MaxBoomsPerFrame)
    {
        ExploActor = Spawn(Class'KFExplosionActorReplicated', DeadPawn,, DeadPawn.Location);
        if(ExploActor != none)
        {
            ExploActor.InstigatorController = DeadPawn.Controller;
            ExploActor.Instigator = DeadPawn;
            ExploActor.Attachee = DeadPawn;
            ExplosionTemplate.ActorClassToIgnoreForDamage = ExplosionIgnoreClass;
            ExploActor.Explode(ExplosionTemplate, vect(0, 0, 1));
            ++ CurrentFrameBooms;
        }
    }
}

function bool ShouldOverrideDoshOnKill(class<KFPawn_Monster> KilledPawn, out float DoshGiven)
{
    local StatAdjustments ToAdjust;
    local array<StatAdjustments> ZedsToAdjust;

    ZedsToAdjust = EndlessDifficulty.GetZedsToAdjust();
    foreach ZedsToAdjust(ToAdjust,)
    {
        if((ToAdjust.ClassToAdjust == KilledPawn) && ToAdjust.DoshGiven != -1)
        {
            DoshGiven = float(ToAdjust.DoshGiven);            
            return true;
        }        
    }    
    return false;
}

exec function SetWave(byte NewWaveNum)
{
    local int CurrRound;

    if(!AllowWaveCheats())
    {
        return;
    }
    GotoState('DebugSuspendWave');
    WaveNum = NewWaveNum - 1;
    MyKFGRI.WaveNum = byte(WaveNum);
    SpawnManager.GetWaveSettings(SpawnManager.WaveSettings);
    ResetDifficulty();
    CurrRound = 0;
    J0xB6:

    if(CurrRound < (WaveNum - 1))
    {
        if((CurrRound > 0) && (CurrRound % 5) == 0)
        {
            IncrementDifficulty();
        }
        HellOnEarthPlusRoundIncrement();
        ++ CurrRound;
        goto J0xB6;
    }
    ResetAllPickups();
    GotoState('PlayingWave');
}

function int CalculateMinimumRespawnDosh(float UsedMaxRespawnDosh)
{
    return Round(UsedMaxRespawnDosh * float(Min(1, int(float(WaveNum) / 10))));
}

defaultproperties
{
    SpecialWaveTypes(0)=102
    SpecialWaveTypes(1)=1
    SpecialWaveTypes(2)=0
    SpecialWaveTypes(3)=0
    SpecialWaveTypes(4)=0
    SpecialWaveTypes(5)=0
    SpecialWaveTypes(6)=0
    SpecialWaveTypes(7)=0
    SpecialWaveTypes(8)=109
    SpecialWaveTypes(9)=1
    SpecialWaveTypes(10)=0
    SpecialWaveStart=6
    OutbreakWaveStart=6
    bSplitBossDoshReward=false
    bGoToBossCameraOnDeath=false
    bIsEndlessGame=true
    DifficultyInfoClass=Class'KFGameDifficulty_Endless'
    DifficultyInfoConsoleClass=Class'KFGameDifficulty_Endless_Console'
    SpawnManagerClasses=/* Array type was not detected. */
    TraderVoiceGroupClass=Class'KFTraderVoiceGroup_Patriarch'
    OutbreakEventClass=Class'KFOutbreakEvent_Endless'
    GameName="Endless"
    GameReplicationInfoClass=Class'KFGameReplicationInfo_Endless'
}