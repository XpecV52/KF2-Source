/*******************************************************************************
 * KFAIController_ZedDAR generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController_ZedDAR extends KFAIController_Ranged
    abstract
    config(AI)
    hidecategories(Navigation);

var float MinRangeAttackDist;
var float MaxRangeAttackDist;
var float LastRangeAttackTime;
var float TimeBetweenRangeAttacks;
var float BaseTimeBetweenRangeAttacks;
var float TimeBetweenRangeAttackVariance;
var float CheckSpecialMoveTime;
var float LastCheckSpecialMoveTime;
var name FiringSocketName;
var protected float RangeAttackIntervalNormal;
var protected float RangeAttackIntervalHard;
var protected float RangeAttackIntervalSuicidal;
var protected float RangeAttackIntervalHellOnEarth;
var float HeadLossAttackTimeDebuff;
var float HeadLossAccuracyDebuffPct;
var float AimError;
var bool bAllowedToSprint;
var bool bCanEvade;
var int ArmorLossStumblePower;

event PostBeginPlay()
{
    super(KFAIController).PostBeginPlay();
    BaseTimeBetweenRangeAttacks = GetAttackIntervalByDifficulty();
    TimeBetweenRangeAttacks = BaseTimeBetweenRangeAttacks;
    if(TimeBetweenRangeAttackVariance > float(0))
    {
        TimeBetweenRangeAttacks += RandRange(-TimeBetweenRangeAttackVariance, TimeBetweenRangeAttackVariance);
    }
}

function float GetAttackIntervalByDifficulty()
{
    if(Skill == Class'KFGameDifficultyInfo'.static.GetDifficultyValue(0))
    {
        return RangeAttackIntervalNormal;        
    }
    else
    {
        if(Skill <= Class'KFGameDifficultyInfo'.static.GetDifficultyValue(1))
        {
            return RangeAttackIntervalHard;            
        }
        else
        {
            if(Skill <= Class'KFGameDifficultyInfo'.static.GetDifficultyValue(2))
            {
                return RangeAttackIntervalSuicidal;                
            }
            else
            {
                if(Skill <= Class'KFGameDifficultyInfo'.static.GetDifficultyValue(3))
                {
                    return RangeAttackIntervalHellOnEarth;
                }
            }
        }
    }
    return RangeAttackIntervalNormal;
}

function bool CanDoRangedAttack(float DistanceToTargetSqr)
{
    if(!CheckOverallCooldownTimer())
    {
        return false;
    }
    return ((((LastRangeAttackTime == float(0)) || (WorldInfo.TimeSeconds - LastRangeAttackTime) > TimeBetweenRangeAttacks) && DistanceToTargetSqr >= Square(MinRangeAttackDist)) && DistanceToTargetSqr <= Square(MaxRangeAttackDist)) && MyKFPawn.CanDoSpecialMove(22);
}

simulated function Tick(float DeltaTime)
{
    local float DistToTargetSqr;

    super(KFAIController).Tick(DeltaTime);
    if(((Role == ROLE_Authority) && Enemy != none) && MyKFPawn != none)
    {
        if(((WorldInfo.TimeSeconds - LastCheckSpecialMoveTime) >= CheckSpecialMoveTime) && !MyKFPawn.IsDoingSpecialMove())
        {
            if((GetActiveCommand() != none) && !GetActiveCommand().IsA('AICommand_SpecialMove'))
            {
                if(WorldInfo.FastTrace(Enemy.Location, Pawn.Location,, true))
                {
                    DistToTargetSqr = VSizeSq(Enemy.Location - Pawn.Location);
                    if(CanDoRangedAttack(DistToTargetSqr))
                    {
                        if((KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).GameConductor != none)
                        {
                            KFGameInfo(WorldInfo.Game).GameConductor.UpdateOverallAttackCoolDowns(self);
                        }
                        StartRangedAttack();
                        if(TimeBetweenRangeAttackVariance > float(0))
                        {
                            TimeBetweenRangeAttacks = BaseTimeBetweenRangeAttacks + RandRange(-TimeBetweenRangeAttackVariance, TimeBetweenRangeAttackVariance);
                        }
                    }
                }
            }
            LastCheckSpecialMoveTime = WorldInfo.TimeSeconds;
        }
        if(MyKFPawn.IsDoingSpecialMove(22))
        {
            Focus = none;
            SetFocalPoint(Enemy.Location);            
        }
        else
        {
            if(Focus == none)
            {
                Focus = Enemy;
            }
        }
    }
}

event bool SetEnemy(Pawn NewEnemy)
{
    if((MyKFPawn == none) || MyKFPawn.IsDoingSpecialMove(22))
    {
        if(MyKFPawn.NeedToTurn(NewEnemy.Location))
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                AILog_Internal(((((string(GetFuncName()) $ "() rejecting ") $ string(NewEnemy)) $ " because current enemy (") $ string(Enemy)) $ ") we would need to turn to see it", 'SetEnemy');
            }
            return false;
        }
    }
    return super(KFAIController).SetEnemy(NewEnemy);
}

function StartRangedAttack();

function FireRangedAttack(class<KFProjectile> RangedProjectileClass, Vector ProjectileOffset)
{
    local Vector SocketLocation, DirToEnemy, HitLocation, HitNormal;
    local KFProjectile SpawnedProjectile;
    local Actor HitActor;
    local Vector AimLocation, AimDispalcement, displacementToHitLoc;
    local float distanceToHitLoc;

    if(MyKFPawn == none)
    {
        return;
    }
    if(bDebugAimError)
    {
        DebugAimError(FiringSocketName);
        return;
    }
    SocketLocation = (GetStartFireLocation()) + (ProjectileOffset >> Pawn.GetViewRotation());
    if(((float(MyKFPawn.Health) > 0) && Role == ROLE_Authority) && MyKFPawn.IsDoingSpecialMove(22))
    {
        AimLocation = Enemy.Location;
        HitActor = WorldInfo.Trace(HitLocation, HitNormal, AimLocation, SocketLocation, true);
        if(HitActor == Enemy)
        {
            if(!bCanLeadTarget)
            {
                DirToEnemy = Normal(AimLocation - SocketLocation);
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && self != none)
                {
                    self.AILog_Internal((((string(GetFuncName()) @ "Leading - HitActor: ") @ string(HitActor)) @ " Is My Enemy: ") @ string(Enemy), 'FireBall');
                }                
            }
            else
            {
                DirToEnemy = Normal((CalcAimLocToHit(AimLocation, SocketLocation, RangedProjectileClass.default.Speed, RangedProjectileClass.default.Speed, Enemy.Velocity)) - SocketLocation);
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && self != none)
                {
                    self.AILog_Internal((((string(GetFuncName()) @ "Not Leading - HitActor: ") @ string(HitActor)) @ " Is My Enemy: ") @ string(Enemy), 'FireBall');
                }
            }            
        }
        else
        {
            AimLocation = AICommand_RangedAttack(GetActiveCommand()).LastKnownEnemyLocation;
            HitActor = Trace(HitLocation, HitNormal, AimLocation, SocketLocation, true);
            displacementToHitLoc = HitLocation - SocketLocation;
            distanceToHitLoc = VSize(displacementToHitLoc);
            if(distanceToHitLoc < MinRangeAttackDist)
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && self != none)
                {
                    self.AILog_Internal(((((((string(GetFuncName()) @ "- HitActor: ") @ string(HitActor)) @ " Is NOT My Enemy: ") @ string(Enemy)) @ " and distanceToHitLoc: ") @ string(distanceToHitLoc)) @ " is too close so not firing!!!", 'FireBall');
                }
                MyKFPawn.SpecialMoves[22].AbortedByAICommand();
                LastRangeAttackTime = WorldInfo.TimeSeconds;
                return;                
            }
            else
            {
                DirToEnemy = Normal(AimLocation - SocketLocation);
                if(!Class'Engine'.static.GetEngine().bDisableAILogging && self != none)
                {
                    self.AILog_Internal(((string(GetFuncName()) @ "- Fire at enemy last known position : ") @ string(Enemy)) @ string(AimLocation), 'FireBall');
                }
            }
        }
        AimDispalcement = VRand();
        DirToEnemy += (AimDispalcement * AimError);
        SpawnedProjectile = Spawn(RangedProjectileClass, MyKFPawn,, SocketLocation, rotator(DirToEnemy));
        SpawnedProjectile.Instigator = MyKFPawn;
        SpawnedProjectile.InstigatorController = self;
        SpawnedProjectile.Init(DirToEnemy);
        LastRangeAttackTime = WorldInfo.TimeSeconds;
    }
}

function Vector GetStartFireLocation()
{
    return MyKFPawn.GetPawnViewLocation();
}

function bool ShouldSprint()
{
    return bAllowedToSprint && super(KFAIController).ShouldSprint();
}

function bool CanEvade(optional bool bOverrideSpecialMove)
{
    return bCanEvade && super(KFAIController).CanEvade(bOverrideSpecialMove);
}

function OnArmorLoss(name ArmorName)
{
    MyKFPawn.AfflictionHandler.AccrueAffliction(4, float(ArmorLossStumblePower));
    if(ArmorName == 'head')
    {
        BaseTimeBetweenRangeAttacks += HeadLossAttackTimeDebuff;
        AimError *= (1 + HeadLossAccuracyDebuffPct);        
    }
    else
    {
        if(ArmorName == 'Front')
        {
            bCanSprint = false;
            bAllowedToSprint = false;
            bCanEvade = false;
            MyKFPawn.bIsSprinting = false;
        }
    }
}

defaultproperties
{
    MinRangeAttackDist=300
    MaxRangeAttackDist=4000
    TimeBetweenRangeAttackVariance=1
    CheckSpecialMoveTime=0.25
    RangeAttackIntervalNormal=7
    RangeAttackIntervalHard=6
    RangeAttackIntervalSuicidal=5
    RangeAttackIntervalHellOnEarth=4
    HeadLossAttackTimeDebuff=2
    HeadLossAccuracyDebuffPct=2
    AimError=0.03
    bAllowedToSprint=true
    bCanEvade=true
    ArmorLossStumblePower=100
    bCanTeleportCloser=false
    bUseDesiredRotationForMelee=false
    SprintWithinEnemyRange=(X=500,Y=5000)
    EvadeGrenadeChance=0.9
    BaseShapeOfProjectileForCalc=(X=10,Y=10,Z=10)
    DangerEvadeSettings=/* Array type was not detected. */
}