/*******************************************************************************
 * KFWeap_Mine_Reconstructor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_Mine_Reconstructor extends KFWeapon
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const SecondaryFireAnim = 'Alt_Fire';
const SecondaryFireIronAnim = 'Alt_Fire_Iron';
const SecondaryFireAnimEmpty = 'Alt_Fire_Empty';
const SecondaryFireIronAnimEmpty = 'Alt_Fire_Iron_Empty';

var float MaxChargeTime;
var float ValueIncreaseTime;
var float DmgIncreasePerCharge;
var float AOEIncreasePerCharge;
var float IncapIncreasePerCharge;
var int AmmoIncreasePerCharge;
var transient float ChargeTime;
var transient float ConsumeAmmoTime;
var transient float MaxChargeLevel;
var ParticleSystem ChargingEffect;
var ParticleSystem ChargedEffect;
var const ParticleSystem MuzzleFlashEffectL3;
var export editinline transient ParticleSystemComponent FullyChargedPSC;
var export editinline transient ParticleSystemComponent ChargingPSC;
var transient bool bIsFullyCharged;
var bool bHasToLaunchEmptyAnim;
var bool bBlocked;
var const WeaponFireSndInfo FullyChargedSound;
var float SelfDamageReductionValue;
var float FullChargedTimerInterval;
var float FXScalingFactorByCharge;
var float ChargePercentage;
var float MinScale;
var float MaxScale;
var int MaxDamageByCharge;
var int MinDamageByCharge;
var private array<KFProj_Mine_Reconstructor> PoolOfMines;
var SkelControlSingleBone Control;
var protected const byte MAX_ACTIVE_MINE_RECONSTRUCTOR_MINES;

replication
{
     if((Role == ROLE_Authority) && bNetDirty)
        ChargeTime;
}

function AddProjectileToPool(KFProj_Mine_Reconstructor Proj)
{
    AddProjectileToPool_Internal(PoolOfMines, Proj, MAX_ACTIVE_MINE_RECONSTRUCTOR_MINES);
}

function RemoveProjectileFromPool(KFProj_Mine_Reconstructor Proj)
{
    RemoveProjectileFromPool_Internal(PoolOfMines, Proj);
}

private final function AddProjectileToPool_Internal(out array<KFProj_Mine_Reconstructor> PoolProjectiles, KFProj_Mine_Reconstructor Proj, byte MaxActiveProjectiles)
{
    if(PoolProjectiles.Length == MaxActiveProjectiles)
    {
        if(PoolProjectiles[0] != none)
        {
            PoolProjectiles[0].Detonate();
        }
        PoolProjectiles.Remove(0, 1;
    }
    PoolProjectiles.AddItem(Proj;
}

private final function RemoveProjectileFromPool_Internal(out array<KFProj_Mine_Reconstructor> PoolProjectiles, KFProj_Mine_Reconstructor Proj)
{
    PoolProjectiles.RemoveItem(Proj;
}

function SetOriginalValuesFromPickup(KFWeapon PickedUpWeapon)
{
    local int I, NumDeployedCharges;

    super.SetOriginalValuesFromPickup(PickedUpWeapon);
    PoolOfMines = KFWeap_Mine_Reconstructor(PickedUpWeapon).PoolOfMines;
    NumDeployedCharges = PoolOfMines.Length;
    bForceNetUpdate = true;
    I = 0;
    J0x6F:

    if(I < NumDeployedCharges)
    {
        PoolOfMines[I].Instigator = Instigator;
        PoolOfMines[I].SetOwner(self);
        if(Instigator.Controller != none)
        {
            PoolOfMines[I].InstigatorController = Instigator.Controller;
        }
        ++ I;
        goto J0x6F;
    }
}

simulated function CustomFire()
{
    local int I, NumDeployedCharges;

    super(Weapon).CustomFire();
    NumDeployedCharges = PoolOfMines.Length;
    bForceNetUpdate = true;
    if(CurrentFireMode != 1)
    {
        super(Weapon).CustomFire();
        return;
    }
    if(Instigator.Role < ROLE_Authority)
    {
        return;
    }
    if(NumDeployedCharges <= 0)
    {
        bHasToLaunchEmptyAnim = true;
        return;
    }
    I = 0;
    J0x9A:

    if(I < NumDeployedCharges)
    {
        if(PoolOfMines[I] == none)
        {            
        }
        else
        {
            PoolOfMines[I].Instigator = Instigator;
            PoolOfMines[I].SetOwner(self);
            if(Instigator.Controller != none)
            {
                PoolOfMines[I].ManuallyDetonate();
            }
        }
        ++ I;
        goto J0x9A;
    }
    PoolOfMines.Remove(0, PoolOfMines.Length;
    bHasToLaunchEmptyAnim = false;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    local Vector vec;
    local float fPercentage;

    super.PostInitAnimTree(SkelComp);
    Control = SkelControlSingleBone(SkelComp.FindSkelControl('AmmoControl'));
    if(Control != none)
    {
        Control.SetSkelControlActive(true);
    }
    fPercentage = FMin(float(AmmoCount[0]) / float(MagazineCapacity[0]), 1);
    vec.X = Control.BoneTranslation.X;
    vec.Y = Control.BoneTranslation.Y;
    vec.Z = Lerp(-8, 0, fPercentage);
    Control.BoneTranslation = vec;
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    local Vector vec;
    local float fPercentage;

    if(Role == ROLE_Authority)
    {
        fPercentage = FMin(float(AmmoCount[0]) / float(MagazineCapacity[0]), 1);
        super.ConsumeAmmo(FireModeNum);
        if(Control != none)
        {
            vec.X = Control.BoneTranslation.X;
            vec.Y = Control.BoneTranslation.Y;
            vec.Z = Lerp(-8, 0, fPercentage);
            Control.BoneTranslation = vec;
        }
        ClientUpdateVisualAmmo(fPercentage);
    }
}

reliable client simulated function ClientUpdateVisualAmmo(float BoneControlTranslation)
{
    local Vector vec;

    if((Role < ROLE_Authority) && Control != none)
    {
        vec.X = Control.BoneTranslation.X;
        vec.Y = Control.BoneTranslation.Y;
        vec.Z = Lerp(-8, 0, BoneControlTranslation);
        Control.BoneTranslation = vec;
    }
}

simulated function BeginFire(byte FireModeNum)
{
    super.BeginFire(FireModeNum);
}

simulated function StartFire(byte FireModeNum)
{
    if(IsTimerActive('RefireCheckTimer') || bBlocked)
    {
        return;
    }
    if(((Role != ROLE_Authority) && FireModeNum == 0) && HasAmmo(0))
    {
        bBlocked = true;
        if(IsTimerActive('UnlockClientFire'))
        {
            ClearTimer('UnlockClientFire');
        }
    }
    super.StartFire(FireModeNum);
    if(PendingFire(2) && Role != ROLE_Authority)
    {
        bBlocked = false;
    }
}

simulated function RefireCheckTimer()
{
    super(Weapon).RefireCheckTimer();
    if(bBlocked && Role != ROLE_Authority)
    {
        SetTimer(0.25, false, 'UnlockClientFire');
    }
}

reliable client simulated function UnlockClientFire()
{
    bBlocked = false;
}

simulated function EndFire(byte FireModeNum)
{
    super(Weapon).EndFire(FireModeNum);
}

simulated function OnStartFire()
{
    local KFPawn PawnInst;

    PawnInst = KFPawn(Instigator);
    if(PawnInst != none)
    {
        PawnInst.OnStartFire();
    }
}

simulated function FireAmmunition()
{
    HandleWeaponShotTaken(CurrentFireMode);
    switch(WeaponFireTypes[CurrentFireMode])
    {
        case 0:
            if((self.WorldInfo.TimeDilation < 1) && WeaponProjectiles[CurrentFireMode] != none)
            {
                ProjectileFire();                
            }
            else
            {
                InstantFireClient();
            }
            break;
        case 1:
            ProjectileFire();
            break;
        case 2:
            CustomFire();
            break;
        default:
            break;
    }
    if((GetChargeLevel()) < 1)
    {
        ConsumeAmmo(CurrentFireMode);
    }
    NotifyWeaponFired(CurrentFireMode);
}

simulated function ANIMNOTIFY_FILLMAG()
{
    local Vector vec;

    vec.X = Control.BoneTranslation.X;
    vec.Y = Control.BoneTranslation.Y;
    vec.Z = 0;
    Control.BoneTranslation = vec;
}

simulated function Timer_StopFireEffects()
{
    if(WorldInfo.NetMode == NM_Client)
    {
        Instigator.WeaponStoppedFiring(self, false);
        if(FullyChargedPSC != none)
        {
            FullyChargedPSC.DeactivateSystem();
        }
    }
    ClearFlashCount();
    ClearFlashLocation();
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProj_Mine_Reconstructor Mine;

    Mine = KFProj_Mine_Reconstructor(super.SpawnProjectile(KFProjClass, RealStartLoc, AimDir));
    if(Mine != none)
    {
        AddProjectileToPool(Mine);
        ChargePercentage = FMax(0.1, ChargePercentage);
        FXScalingFactorByCharge = FMax(0.1, FXScalingFactorByCharge);
        Mine.SetInheritedScale(FXScalingFactorByCharge, ChargePercentage);
        return Mine;
    }
    return none;
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if(MuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(MuzzleFlash != none)
    {
    }
    super.CauseMuzzleFlash(FireModeNum);
}

simulated function int GetChargeLevel()
{
    return Min(int(ChargeTime / ValueIncreaseTime), int(MaxChargeLevel));
}

static simulated event KFGame.KFGFxObject_TraderItems.EFilterTypeUI GetTraderFilter()
{
    return 4;
}

static simulated function float CalculateTraderWeaponStatDamage()
{
    local float CalculatedDamage;
    local class<KFDamageType> DamageType;
    local GameExplosion ExplosionInstance;

    ExplosionInstance = class<KFProjectile>(default.WeaponProjectiles[0]).default.ExplosionTemplate;
    CalculatedDamage = default.InstantHitDamage[0] + ExplosionInstance.Damage;
    DamageType = class<KFDamageType>(ExplosionInstance.MyDamageType);
    if((DamageType != none) && DamageType.default.DoT_Type != 0)
    {
        CalculatedDamage += ((DamageType.default.DoT_Duration / DamageType.default.DoT_Interval) * (CalculatedDamage * DamageType.default.DoT_DamageScale));
    }
    return CalculatedDamage;
}

simulated function int GetModifiedDamage(byte FireModeNum, optional Vector RayDir)
{
    local int ModifiedDamage;

    ModifiedDamage = super.GetModifiedDamage(FireModeNum, RayDir);
    return ModifiedDamage;
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    StartFire(1);
}

simulated state MineReconstructorCharge extends WeaponFiring
{
    simulated function FireAmmunition()
    {
        return;
    }

    simulated event BeginState(name PreviousStateName)
    {
        local KFPerk InstigatorPerk;

        super.BeginState(PreviousStateName);
        InstigatorPerk = GetPerk();
        if(InstigatorPerk != none)
        {
            SetZedTimeResist(InstigatorPerk.GetZedTimeModifier(self));
        }
        ChargeTime = 0;
        ConsumeAmmoTime = 0;
        MaxChargeLevel = float(int(MaxChargeTime / ValueIncreaseTime));
        if(ChargingPSC == none)
        {
            ChargingPSC = new (self) Class'ParticleSystemComponent';
            if(MySkelMesh != none)
            {
                MySkelMesh.AttachComponentToSocket(ChargingPSC, 'MuzzleFlash');                
            }
            else
            {
                AttachComponent(ChargingPSC);
            }            
        }
        else
        {
            ChargingPSC.ActivateSystem();
        }
        bIsFullyCharged = false;
        global.OnStartFire();
        if(ChargingPSC != none)
        {
            ChargingPSC.SetTemplate(ChargingEffect);
        }
        ChargeTime = 0;
        FXScalingFactorByCharge = 0;
    }

    simulated function bool ShouldRefire()
    {
        return StillFiring(CurrentFireMode);
    }

    simulated event Tick(float DeltaTime)
    {
        local float ChargeRTPC, InstantHitDamageValue;

        global.Tick(DeltaTime);
        if(bIsFullyCharged)
        {
            return;
        }
        if(PendingFire(CurrentFireMode))
        {
            ConsumeAmmoTime += DeltaTime;
        }
        if(bIsFullyCharged)
        {
            if(ConsumeAmmoTime >= FullChargedTimerInterval)
            {
                ConsumeAmmo(0);
                ConsumeAmmoTime -= FullChargedTimerInterval;
            }
            return;
        }
        if(PendingFire(CurrentFireMode))
        {
            if((Role == ROLE_Authority) && !bIsFullyCharged)
            {
                ChargeTime += DeltaTime;
                bNetDirty = true;
            }
            if((ChargingPSC != none) && !bIsFullyCharged)
            {
                FXScalingFactorByCharge = FMin(Lerp(MinScale, MaxScale, ChargeTime / MaxChargeTime), MaxScale);
                ChargePercentage = FMin(ChargeTime / MaxChargeTime, 1);
                if(ChargePercentage < 0.1)
                {
                    InstantHitDamageValue = Lerp(float(MinDamageByCharge), float(MaxDamageByCharge), 0.1);                    
                }
                else
                {
                    InstantHitDamageValue = Lerp(float(MinDamageByCharge), float(MaxDamageByCharge), ChargePercentage);
                }
                InstantHitDamage[0] = InstantHitDamageValue;
                ChargingPSC.SetFloatParameter(name("InflateBlob"), ChargePercentage);
                if(ChargePercentage > 0.51)
                {
                    InstantHitDamageTypes[0] = Class'KFDT_Toxic_MineReconstructorImpactHeavy';                    
                }
                else
                {
                    InstantHitDamageTypes[0] = Class'KFDT_Toxic_MineReconstructorImpact';
                }
            }
        }
        ChargeRTPC = FMin(ChargeTime / MaxChargeTime, 1);
        KFPawn(Instigator).SetWeaponComponentRTPCValue("Weapon_Charge", ChargeRTPC);
        Instigator.SetRTPCValue('Weapon_Charge', ChargeRTPC);
        if((ConsumeAmmoTime >= ValueIncreaseTime) && !bIsFullyCharged)
        {
            ConsumeAmmo(0);
            ConsumeAmmoTime -= ValueIncreaseTime;
        }
        if((ChargeTime >= MaxChargeTime) || !HasAmmo(0))
        {
            bIsFullyCharged = true;
            if((Instigator.Role != ROLE_Authority) || WorldInfo.NetMode == NM_Standalone)
            {
                if(FullyChargedPSC == none)
                {
                    FullyChargedPSC = new (self) Class'ParticleSystemComponent';
                    if(MySkelMesh != none)
                    {
                        MySkelMesh.AttachComponentToSocket(FullyChargedPSC, 'MuzzleFlash');                        
                    }
                    else
                    {
                        AttachComponent(FullyChargedPSC);
                    }                    
                }
                else
                {
                    FullyChargedPSC.ActivateSystem();
                }
                FullyChargedPSC.SetTemplate(ChargedEffect);
                KFPawn(Instigator).SetWeaponAmbientSound(FullyChargedSound.DefaultCue, FullyChargedSound.FirstPersonCue);
            }
        }
    }

    simulated event EndState(name NextStateName)
    {
        if(Role == ROLE_Authority)
        {
            UnlockClientFire();
        }
        ClearZedTimeResist();
        ClearPendingFire(CurrentFireMode);
        ClearTimer('RefireCheckTimer');
        KFPawn(Instigator).bHasStartedFire = false;
        KFPawn(Instigator).bNetDirty = true;
        if(ChargingPSC != none)
        {
            ChargingPSC.DeactivateSystem();
        }
        if(FullyChargedPSC != none)
        {
            FullyChargedPSC.DeactivateSystem();
        }
        KFPawn(Instigator).SetWeaponAmbientSound(none);
    }

    simulated function HandleFinishedFiring()
    {
        global.FireAmmunition();
        if(bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
        SetTimer(0.1, false, 'Timer_StopFireEffects');
        NotifyWeaponFinishedFiring(CurrentFireMode);
        super(Weapon).HandleFinishedFiring();
    }

    simulated function PutDownWeapon()
    {
        global.FireAmmunition();
        if(bPlayingLoopingFireAnim)
        {
            StopLoopingFireEffects(CurrentFireMode);
        }
        SetTimer(0.1, false, 'Timer_StopFireEffects');
        NotifyWeaponFinishedFiring(CurrentFireMode);
        if(Role == ROLE_Authority)
        {
            UnlockClientFire();
        }
        super(Weapon).PutDownWeapon();
    }
    stop;    
}

simulated state Active
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(Role == ROLE_Authority)
        {
            UnlockClientFire();
        }
    }
    stop;    
}

state WeaponSingleFiring
{
    local name Returned;

    simulated function name GetWeaponFireAnim(byte FireModeNum)
    {
        if(bUsingSights)
        {
            Returned = ((bHasToLaunchEmptyAnim == false) ? 'Alt_Fire_Iron' : 'Alt_Fire_Iron_Empty');
            return Returned;            
        }
        else
        {
            Returned = ((bHasToLaunchEmptyAnim == false) ? 'Alt_Fire' : 'Alt_Fire_Empty');
            return Returned;
        }
    }
    stop;    
}

defaultproperties
{
    MaxChargeTime=1.2
    ValueIncreaseTime=0.2
    AmmoIncreasePerCharge=1
    ChargingEffect=ParticleSystem'WEP_Mine_Reconstructor_EMIT.FX_Bile_BlobCharge_01'
    ChargedEffect=ParticleSystem'WEP_Mine_Reconstructor_EMIT.FX_Mine_Reconstructor_FullCharge'
    MuzzleFlashEffectL3=ParticleSystem'WEP_HuskCannon_EMIT.FX_Huskcannon_MuzzleFlash_L3_1P'
    FullyChargedSound=(DefaultCue=AkEvent'WW_WEP_MineReconstructor.Play_WEP_Mine_Reconstructor_Charged_3P',FirstPersonCue=AkEvent'WW_WEP_MineReconstructor.Play_WEP_Mine_Reconstructor_Charged')
    SelfDamageReductionValue=0.1
    FullChargedTimerInterval=2
    MinScale=0.5
    MaxScale=1.5
    MaxDamageByCharge=250
    MinDamageByCharge=25
    MAX_ACTIVE_MINE_RECONSTRUCTOR_MINES=12
    PackageKey="Mine_Reconstructor"
    FirstPersonMeshName="WEP_1P_Mine_Reconstructor_MESH.Wep_1stP_HMTech_Mine_Reconstructor_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="WEP_3P_Mine_Reconstructor_MESH.Wep_3rdP_Mine_Reconstructor_Lowpoly_Pickup"
    AttachmentArchetypeName="WEP_Mine_Reconstructor_Arch.Wep_Mine_Reconstructor_3P"
    MuzzleFlashTemplateName="WEP_Mine_Reconstructor_Arch.Wep_Mine_Reconstructor_MuzzleFlash"
    bHasIronSights=true
    bCanBeReloaded=true
    bReloadFromMagazine=true
    bAllowClientAmmoTracking=false
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=8
    MeshFOV=80
    MeshIronSightFOV=65
    PlayerIronSightFOV=50
    QuickWeaponDownRotation=(Pitch=-19192,Yaw=-11500,Roll=16384)
    DOF_FG_FocalRadius=150
    DOF_FG_MaxNearBlurSize=1
    GroupPriority=80
    WeaponSelectTexture=Texture2D'WEP_UI_Mine_Reconstructor_TEX.UI_WeaponSelect_HMTechMineReconstructor'
    MagazineCapacity=12
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCapacity=108
    InitialSpareMags=2
    AmmoPickupScale=1.5
    WeaponFireWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Weak_Recoil'
    bLoopingFireAnim=/* Array type was not detected. */
    bLoopingFireSnd=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponFireLoopEndSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=0,Y=12,Z=-1)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_Mine_Reconstructor.MeleeHelper'
    maxRecoilPitch=150
    minRecoilPitch=115
    maxRecoilYaw=115
    minRecoilYaw=-115
    RecoilRate=0.085
    RecoilViewRotationScale=0.25
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=75
    RecoilISMinYawLimit=65460
    RecoilISMaxPitchLimit=375
    RecoilISMinPitchLimit=65460
    HippedRecoilModifier=1.5
    IronSightMeshFOVCompensationScale=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=4.5,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        AnimTreeTemplate=AnimTree'WEP_Mine_Reconstructor_Arch.WEP_1stP_Animtree_MineReconstructor'
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_Mine_Reconstructor.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="Mine Reconstructor"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_Mine_Reconstructor.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_Mine_Reconstructor.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}