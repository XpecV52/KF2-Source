/*******************************************************************************
 * KFPawn_ZedHans generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_ZedHans extends KFPawn_ZedHansBase
    config(Game)
    hidecategories(Navigation);

struct ProjectileTossInfo
{
    var Vector TossVelocity;
    var Vector TossFromLocation;
    var Vector TossTargetLocation;
    var float TossSpeed;
    var float TossZPct;
    var float TossTime;

    structdefaultproperties
    {
        TossVelocity=(X=0,Y=0,Z=0)
        TossFromLocation=(X=0,Y=0,Z=0)
        TossTargetLocation=(X=0,Y=0,Z=0)
        TossSpeed=0
        TossZPct=0
        TossTime=0
    }
};

var() AnimSet MeleeAnimSet;
var() AnimSet GunsAnimSet;
var SkelControlSingleBone RightHolsterSkelCtrl;
var SkelControlSingleBone LeftHolsterSkelCtrl;
var class<KFDamageType> HeavyBumpDamageType;
var ProjectileTossInfo CachedGoodGrenadeToss;
var AkEvent AmbientBreathingEvent;
var AkEvent LowHealthAmbientBreathingEvent;
var float LastTickDialogTime;
var float TickDialogInterval;
var ParticleSystem BackPackSmokeEffectTemplate;
var export editinline ParticleSystemComponent BackPackSmokePSC;
var name BattlePhaseLightFrontSocketName;
var name BattlePhaseLightBackSocketName;
var export editinline transient PointLightComponent BattlePhaseLightTemplateGreen;
var export editinline transient PointLightComponent BattlePhaseLightTemplateYellow;
var export editinline transient PointLightComponent BattlePhaseLightTemplateRed;
var export editinline transient PointLightComponent BattlePhaseLightTemplateBlinking;
var export editinline transient PointLightComponent BattlePhaseLightFront;
var export editinline transient PointLightComponent BattlePhaseLightBack;
var LinearColor BattlePhaseGlowColorParamGreen;
var LinearColor BattlePhaseGlowColorParamYellow;
var LinearColor BattlePhaseGlowColorParamRed;
var LinearColor BattlePhaseGlowColorParamBlinking;
var name BattleDamageFXSocketName_LegR;
var name BattleDamageFXSocketName_LegL;
var name BattleDamageFXSocketName_ArmR;
var name BattleDamageFXSocketName_ArmL;
var name BattleDamageFXSocketName_Chest;
var name BattleDamageFXSocketName_TorsoR;
var name BattleDamageFXSocketName_TorsoL;
var name BattleDamageFXSocketName_Back;
var export editinline ParticleSystemComponent BattleDamagePSC_LegR;
var export editinline ParticleSystemComponent BattleDamagePSC_LegL;
var export editinline ParticleSystemComponent BattleDamagePSC_ArmR;
var export editinline ParticleSystemComponent BattleDamagePSC_ArmL;
var export editinline ParticleSystemComponent BattleDamagePSC_Chest;
var export editinline ParticleSystemComponent BattleDamagePSC_TorsoR;
var export editinline ParticleSystemComponent BattleDamagePSC_TorsoL;
var export editinline ParticleSystemComponent BattleDamagePSC_Back;
var ParticleSystem BattleDamageFX_Sparks_Low;
var ParticleSystem BattleDamageFX_Sparks_Mid;
var ParticleSystem BattleDamageFX_Sparks_High;
var ParticleSystem BattleDamageFX_Sparks_Chest_Mid;
var ParticleSystem BattleDamageFX_Sparks_Chest_High;
var ParticleSystem BattleDamageFX_Sparks_Back_Mid;
var ParticleSystem BattleDamageFX_Sparks_Back_High;
var ParticleSystem BattleDamageFX_Blood_Mid;
var ParticleSystem BattleDamageFX_Blood_High;
var ParticleSystem InvulnerableShieldFX;
var export editinline ParticleSystemComponent InvulnerableShieldPSC;
var name ShieldSocketName;
var KFSkinTypeEffects ShieldImpactEffects;

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'bGunsEquipped':
            if(SpecialMove != 22)
            {
                SetWeaponStance(bGunsEquipped);
            }
            break;
        case 'CurrentBattlePhase':
            OnBattlePhaseChanged();
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

simulated event PostBeginPlay()
{
    super(KFPawn).PostBeginPlay();
    AddDefaultInventory();
    AmbientAkComponent.CachedObjectPosition = Location;
    SetPawnAmbientSound(AmbientBreathingEvent);
    LastTickDialogTime = WorldInfo.TimeSeconds;
    OnBattlePhaseChanged();
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        Mesh.bPauseAnims = false;
    }
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super(KFPawn_Monster).PostInitAnimTree(SkelComp);
    RightHolsterSkelCtrl = SkelControlSingleBone(SkelComp.FindSkelControl('RightWeapon_Hip'));
    LeftHolsterSkelCtrl = SkelControlSingleBone(SkelComp.FindSkelControl('LeftWeapon_Hip'));
}

simulated function SetCharacterAnimationInfo()
{
    super(KFPawn).SetCharacterAnimationInfo();
    SetWeaponStance(bGunsEquipped, true);
}

simulated function SetWeaponStance(bool bInEquipWeapons, optional bool bForce)
{
    local byte WeapAnimSetIdx;
    local bool bUsingGunAnimSet;

    WeapAnimSetIdx = byte(CharacterArch.AnimSets.Length);
    if((Mesh.AnimSets.Length > WeapAnimSetIdx) && Mesh.AnimSets[WeapAnimSetIdx] == GunsAnimSet)
    {
        bUsingGunAnimSet = true;
    }
    if((bUsingGunAnimSet != bInEquipWeapons) || bForce)
    {
        bGunsEquipped = bInEquipWeapons;
        if(bGunsEquipped)
        {
            Mesh.AnimSets[WeapAnimSetIdx] = GunsAnimSet;
            RightHolsterSkelCtrl.SetSkelControlStrength(0, 0);
            LeftHolsterSkelCtrl.SetSkelControlStrength(0, 0);            
        }
        else
        {
            Mesh.AnimSets[WeapAnimSetIdx] = MeleeAnimSet;
            RightHolsterSkelCtrl.SetSkelControlActive(true);
            LeftHolsterSkelCtrl.SetSkelControlActive(true);
        }
        Mesh.UpdateAnimations();
    }
}

function SetSprinting(bool bNewSprintStatus)
{
    local bool bWasSprinting;
    local KFAIController_Hans KFAIHans;

    bWasSprinting = bIsSprinting;
    super(KFPawn_Monster).SetSprinting(bNewSprintStatus);
    if((!bIsSprinting && !bNewSprintStatus) && bWasSprinting != bIsSprinting)
    {
        KFAIHans = KFAIController_Hans(MyKFAIC);
        if(KFAIHans != none)
        {
            KFAIHans.LastAttackMoveFinishTime = WorldInfo.TimeSeconds;
        }
    }
}

simulated function bool ShouldPlaySpecialMeleeAnims()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanFrenzy;
}

simulated function ANIMNOTIFY_TossGrenade_RightHand()
{
    StartThrowingGrenade(false);
}

simulated function ANIMNOTIFY_TossGrenade_LeftHand()
{
    StartThrowingGrenade(true);
}

simulated function ANIMNOTIFY_AoENerveGas()
{
    local KFExplosionActor ExplosionActor;

    if(NerveGasGrenadeClass != none)
    {
        ExplosionActor = KFExplosionActor(Spawn(NerveGasGrenadeClass.default.ExplosionActorClass, self,, Mesh.GetBoneLocation('Root'), rotator(vect(0, 0, 1))));
        if(ExplosionActor != none)
        {
            ExplosionActor.Explode(NerveGasGrenadeClass.default.ExplosionTemplate);
        }
    }
}

function bool CacheGrenadeThrowLocation(optional bool bLeftHand)
{
    local Vector StartThrowLocation;
    local name HandSocketName;
    local Vector TossVelocity, Extent, Offset;
    local bool bFoundVel;
    local float XYExtent, ZExtent, TossZPct;
    local bool bUsingCachedValues;
    local Vector TargetLocation;
    local class<KFProj_Grenade> UsedGrenadeClass;
    local Vector UsedEnemyLocation;
    local KFAIController_Hans KFAIHans;
    local int RandIdx, I;
    local array<TrackedEnemyInfo> TargetCandidates;

    if(!bLeftHand)
    {
        HandSocketName = RightHandSocketName;        
    }
    else
    {
        HandSocketName = LeftHandSocketName;
    }
    Mesh.GetSocketWorldLocationAndRotation(HandSocketName, StartThrowLocation);
    if(ActiveGrenadeClass == none)
    {
        UsedGrenadeClass = ExplosiveGrenadeClass;        
    }
    else
    {
        UsedGrenadeClass = ExplosiveGrenadeClass;
    }
    KFAIHans = KFAIController_Hans(MyKFAIC);
    if((KFAIHans != none) && KFAIHans.RecentlySeenEnemyList.Length > 0)
    {
        I = KFAIHans.RecentlySeenEnemyList.Length - 1;
        J0x122:

        if(I >= 0)
        {
            if(((KFAIHans.RecentlySeenEnemyList[I].TrackedEnemy == none) || !KFAIHans.RecentlySeenEnemyList[I].TrackedEnemy.IsAliveAndWell()) || !KFAIHans.RecentlySeenEnemyList[I].TrackedEnemy.CanAITargetThisPawn(KFAIHans))
            {
                KFAIHans.RecentlySeenEnemyList.Remove(I, 1;
                goto J0x2E7;                
            }
            else
            {
                if(!NeedToTurnEx(KFAIHans.RecentlySeenEnemyList[I].LastVisibleLocation, 0))
                {
                    TargetCandidates[TargetCandidates.Length] = KFAIHans.RecentlySeenEnemyList[I];
                }
            }
            J0x2E7:

            -- I;
            goto J0x122;
        }
        I = TargetCandidates.Length - 1;
        J0x30C:

        if(I >= 0)
        {
            if(((TargetCandidates.Length > 1) && TargetCandidates[I].TrackedEnemy == KFAIHans.LastRecentlySeenEnemyGrenaded) && (WorldInfo.TimeSeconds - TargetCandidates[I].LastTimeGrenadeAttacked) < 5)
            {
                TargetCandidates.Remove(I, 1;
            }
            -- I;
            goto J0x30C;
        }
        if(TargetCandidates.Length > 0)
        {
            RandIdx = Rand(TargetCandidates.Length);
            UsedEnemyLocation = TargetCandidates[RandIdx].LastVisibleLocation;
            KFAIHans.LastRecentlySeenEnemyGrenaded = TargetCandidates[RandIdx].TrackedEnemy;
            KFAIHans.RecentlySeenEnemyList[RandIdx].LastTimeGrenadeAttacked = WorldInfo.TimeSeconds;            
        }
        else
        {
            UsedEnemyLocation = MyKFAIC.Enemy.Location;
        }        
    }
    else
    {
        UsedEnemyLocation = MyKFAIC.Enemy.Location;
    }
    Offset = UsedGrenadeClass.static.StaticGetTimeToLocation(UsedEnemyLocation, StartThrowLocation, MyKFAIC) * MyKFAIC.Enemy.Velocity;
    TargetLocation = UsedEnemyLocation + Offset;
    XYExtent = UsedGrenadeClass.default.CylinderComponent.CollisionRadius;
    ZExtent = UsedGrenadeClass.default.CylinderComponent.CollisionHeight;
    Extent.X = XYExtent;
    Extent.Y = XYExtent;
    Extent.Z = ZExtent;
    TossZPct = 0.45;
    bFoundVel = SuggestTossVelocity(TossVelocity, TargetLocation, StartThrowLocation, UsedGrenadeClass.default.Speed * 1.2,, TossZPct, Extent);
    if(!bFoundVel)
    {
        TossZPct = 0.75;
        bFoundVel = SuggestTossVelocity(TossVelocity, TargetLocation, StartThrowLocation, UsedGrenadeClass.default.Speed * 1.2,, TossZPct, Extent);
    }
    if(!bFoundVel && (WorldInfo.TimeSeconds - CachedGoodGrenadeToss.TossTime) < 5)
    {
        TossVelocity = CachedGoodGrenadeToss.TossVelocity;
        TargetLocation = CachedGoodGrenadeToss.TossTargetLocation;
        bUsingCachedValues = true;
    }
    if(bFoundVel || bUsingCachedValues)
    {
        if(!bUsingCachedValues)
        {
            CachedGoodGrenadeToss.TossVelocity = TossVelocity;
            CachedGoodGrenadeToss.TossFromLocation = StartThrowLocation;
            CachedGoodGrenadeToss.TossTargetLocation = TargetLocation;
            CachedGoodGrenadeToss.TossSpeed = UsedGrenadeClass.default.Speed * 1.2;
            CachedGoodGrenadeToss.TossZPct = TossZPct;
            CachedGoodGrenadeToss.TossTime = WorldInfo.TimeSeconds;
        }
        return true;
    }
    return false;
}

function StartThrowingGrenade(optional bool bLeftHand)
{
    if((Health > 0) && IsThrowingGrenade())
    {
        if(CacheGrenadeThrowLocation(bLeftHand))
        {
            ThrowGrenade();
        }
    }
}

simulated function bool ThrowGrenade()
{
    local Rotator DirToEnemy;
    local KFProj_Grenade MyGrenade;
    local float TossSpeed;

    MyGrenade = Spawn(ActiveGrenadeClass, self,, CachedGoodGrenadeToss.TossFromLocation);
    if(MyGrenade == none)
    {
        return false;
    }
    MyGrenade.Instigator = self;
    MyGrenade.InstigatorController = Controller;
    TossSpeed = VSize(CachedGoodGrenadeToss.TossVelocity);
    DirToEnemy = rotator(Normal(CachedGoodGrenadeToss.TossVelocity));
    DirToEnemy = AddGrenadeSpread(DirToEnemy);
    MyGrenade.Init(vector(DirToEnemy));
    if((bDoingBarrage && BarrageTossCount == 0) && ActiveGrenadeClass == SmokeGrenadeClass)
    {
        MyGrenade.Velocity = vect(0, 0, -1) * TossSpeed;        
    }
    else
    {
        MyGrenade.Velocity = vector(DirToEnemy) * TossSpeed;
    }
    if(bDoingBarrage)
    {
        if(ActiveGrenadeClass == ExplosiveGrenadeClass)
        {
            LastHENadeBarrageTime = WorldInfo.TimeSeconds;
            LastOffensiveNadeTime = WorldInfo.TimeSeconds;            
        }
        else
        {
            if(ActiveGrenadeClass == NerveGasGrenadeClass)
            {
                LastNerveGasBarrageTime = WorldInfo.TimeSeconds;
                LastOffensiveNadeTime = WorldInfo.TimeSeconds;                
            }
            else
            {
                if(ActiveGrenadeClass == SmokeGrenadeClass)
                {
                    LastSmokeTossTime = WorldInfo.TimeSeconds;
                }
            }
        }        
    }
    else
    {
        if(ActiveGrenadeClass == ExplosiveGrenadeClass)
        {
            LastHENadeTossTime = WorldInfo.TimeSeconds;
            LastOffensiveNadeTime = WorldInfo.TimeSeconds;            
        }
        else
        {
            if(ActiveGrenadeClass == NerveGasGrenadeClass)
            {
                LastNerveGasTossTime = WorldInfo.TimeSeconds;
                LastOffensiveNadeTime = WorldInfo.TimeSeconds;                
            }
            else
            {
                if(ActiveGrenadeClass == SmokeGrenadeClass)
                {
                    LastSmokeTossTime = WorldInfo.TimeSeconds;
                }
            }
        }
    }
    ++ BarrageTossCount;
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlaySpotGrenadeDialog(self);
    }
    return true;
}

simulated function Rotator AddGrenadeSpread(Rotator BaseAim)
{
    local Vector X, Y, Z;
    local float RandY, RandZ;

    if(GrenadeTossSpread == float(0))
    {
        return BaseAim;        
    }
    else
    {
        GetAxes(BaseAim, X, Y, Z);
        RandY = FRand() - 0.5;
        RandZ = Sqrt(0.5 - Square(RandY)) * (FRand() - 0.5);
        return rotator((X + ((RandY * GrenadeTossSpread) * Y)) + ((RandZ * GrenadeTossSpread) * Z));
    }
}

function bool IsThrowingGrenade()
{
    if((Health <= 0) || MyKFAIC == none)
    {
        return false;
    }
    return (IsDoingSpecialMove(23) || IsDoingSpecialMove(25)) || AICommand_ThrowGrenade(MyKFAIC.GetActiveCommand()) != none;
}

function DrawDebugOverheadText(KFHUDBase HUD, out Vector2D ScreenPos)
{
    local Canvas Canvas;
    local Vector ScreenLoc;
    local bool bShowAllCategories;
    local KFAIController_Hans KFAIHans;

    super(KFPawn_Monster).DrawDebugOverheadText(HUD, ScreenPos);
    if(!IsAliveAndWell())
    {
        return;
    }
    Canvas = HUD.Canvas;
    ScreenLoc = Canvas.Project(Location + ((vect(0, 0, 1) * (GetCollisionHeight())) * 1.5));
    if(((ScreenLoc.X < float(0)) || ScreenLoc.X >= HUD.Canvas.ClipX) || (ScreenLoc.Y < float(0)) && ScreenLoc.Y >= HUD.Canvas.ClipY)
    {
        return;
    }
    if(HUD.ShouldDisplayDebug('All'))
    {
        bShowAllCategories = true;
    }
    KFAIHans = KFAIController_Hans(MyKFAIC);
    if((KFAIHans != none) && bShowAllCategories || HUD.ShouldDisplayDebug('RangedCombat'))
    {
        KFAIHans.DrawRangedAttackInfo(HUD);
    }
}

function int GetKillerDialogID()
{
    return 67;
}

function int GetSpotterDialogID()
{
    return 127;
}

static function int GetTraderAdviceID()
{
    return 47;
}

simulated function Tick(float DeltaTime)
{
    super(KFPawn).Tick(DeltaTime);
    if((WorldInfo.TimeSeconds - LastTickDialogTime) > TickDialogInterval)
    {
        LastTickDialogTime = WorldInfo.TimeSeconds;
        if((((WorldInfo.TimeSeconds - SpawnTime) > 2) && IsAliveAndWell()) && !IsDoingSpecialMove())
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayHansTickDialog(self);
            }
        }
    }
}

function PlayBossMusic()
{
    if(KFGameInfo(WorldInfo.Game) != none)
    {
        KFGameInfo(WorldInfo.Game).ForceHansMusicTrack();
    }
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local float OldHealthPct;

    OldHealthPct = GetHealthPercentage();
    super(KFPawn_Monster).TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if((OldHealthPct > 0.25) && GetHealthPercentage() <= 0.25)
    {
        SetPawnAmbientSound(LowHealthAmbientBreathingEvent);
    }
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    local bool Retval;
    local float OldHealthPct;

    bCanRepairArmor = true;
    bMessageHealer = true;
    OldHealthPct = GetHealthPercentage();
    Retval = super(KFPawn_Monster).HealDamage(Amount, Healer, DamageType);
    if((OldHealthPct <= 0.25) && GetHealthPercentage() > 0.25)
    {
        SetPawnAmbientSound(AmbientBreathingEvent);
    }
    return Retval;
}

function TakeHitZoneDamage(float Damage, class<DamageType> DamageType, int HitZoneIdx, Vector InstigatorLocation)
{
    if((HitZoneIdx != 0) || Health <= 0)
    {
        super(KFPawn_Monster).TakeHitZoneDamage(Damage, DamageType, HitZoneIdx, InstigatorLocation);
    }
}

function bool CanInjureHitZone(class<DamageType> DamageType, int HitZoneIdx)
{
    local class<KFDamageType> KFDmgType;
    local name HitZoneName;

    if(bPlayedDeath)
    {
        KFDmgType = class<KFDamageType>(DamageType);
        HitZoneName = HitZones[HitZoneIdx].ZoneName;
        if((KFDmgType != none) && KFDmgType.static.CanDismemberHitZone(HitZoneName))
        {
            return true;
        }
    }
    return false;
}

function class<KFDamageType> GetBumpAttackDamageType()
{
    return HeavyBumpDamageType;
}

simulated function SetHuntAndHealMode(bool bOn)
{
    super.SetHuntAndHealMode(bOn);
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(bOn)
    {
        PlayHuntAndHealModeFX();        
    }
    else
    {
        StopHuntAndHealModeFX();
    }
}

simulated function PlayHuntAndHealModeFX()
{
    BackPackSmokePSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BackPackSmokeEffectTemplate, Mesh, BattleDamageFXSocketName_Back, true);
    InvulnerableShieldPSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(InvulnerableShieldFX, Mesh, ShieldSocketName, true);
    InvulnerableShieldPSC.SetAbsolute(false, true, true);
    BodyMIC.SetScalarParameterValue('Scalar_DamageResist', 1);
}

simulated function StopHuntAndHealModeFX()
{
    DetachEmitter(BackPackSmokePSC);
    DetachShieldFX();
    BodyMIC.SetScalarParameterValue('Scalar_DamageResist', 0);
}

simulated function DetachShieldFX()
{
    DetachEmitter(InvulnerableShieldPSC);
}

simulated function TerminateEffectsOnDeath()
{
    SetHuntAndHealMode(false);
    OnBattlePhaseChanged();
    super(KFPawn).TerminateEffectsOnDeath();
}

function IncrementBattlePhase(KFAIController_Hans HansAI)
{
    super.IncrementBattlePhase(HansAI);
    OnBattlePhaseChanged();
}

simulated function OnBattlePhaseChanged()
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    UpdateBattlePhaseLights();
    UpdateBattlePhaseMaterials();
    UpdateBattlePhaseParticles();
}

simulated function UpdateBattlePhaseLights()
{
    local editinline PointLightComponent LightTemplate;

    if(BattlePhaseLightFront != none)
    {
        BattlePhaseLightFront.DetachFromAny();
        BattlePhaseLightFront = none;
    }
    if(BattlePhaseLightBack != none)
    {
        BattlePhaseLightBack.DetachFromAny();
        BattlePhaseLightBack = none;
    }
    switch(CurrentBattlePhase)
    {
        case 1:
            LightTemplate = BattlePhaseLightTemplateGreen;
            break;
        case 2:
            LightTemplate = BattlePhaseLightTemplateYellow;
            break;
        case 3:
            LightTemplate = BattlePhaseLightTemplateRed;
            break;
        case 4:
            if(IsAliveAndWell())
            {
                LightTemplate = BattlePhaseLightTemplateBlinking;
            }
            break;
        default:
            break;
    }
    if(LightTemplate != none)
    {
        BattlePhaseLightFront = new (self) Class'PointLightComponent' (LightTemplate);
        BattlePhaseLightBack = new (self) Class'PointLightComponent' (LightTemplate);
    }
    if(BattlePhaseLightFront != none)
    {
        Mesh.AttachComponentToSocket(BattlePhaseLightFront, BattlePhaseLightFrontSocketName);
        BattlePhaseLightFront.SetEnabled(true);
    }
    if(BattlePhaseLightBack != none)
    {
        Mesh.AttachComponentToSocket(BattlePhaseLightBack, BattlePhaseLightBackSocketName);
        BattlePhaseLightBack.SetEnabled(true);
    }
}

simulated function UpdateBattlePhaseMaterials()
{
    local MaterialInstanceConstant MIC;

    MIC = ((bIsGoreMesh) ? GoreMIC : BodyMIC);
    switch(CurrentBattlePhase)
    {
        case 1:
            MIC.SetScalarParameterValue('Scalar_BattleGrime', 0);
            MIC.SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1);
            MIC.SetScalarParameterValue('Scalar_GlowFlashing', 0);
            MIC.SetVectorParameterValue('Vector_GlowColor', BattlePhaseGlowColorParamGreen);
            break;
        case 2:
            MIC.SetScalarParameterValue('Scalar_BattleGrime', 0.25);
            MIC.SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1.48);
            MIC.SetScalarParameterValue('Scalar_GlowFlashing', 0);
            MIC.SetVectorParameterValue('Vector_GlowColor', BattlePhaseGlowColorParamYellow);
            break;
        case 3:
            MIC.SetScalarParameterValue('Scalar_BattleGrime', 0.25);
            MIC.SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1.49);
            MIC.SetScalarParameterValue('Scalar_GlowFlashing', 0);
            MIC.SetVectorParameterValue('Vector_GlowColor', BattlePhaseGlowColorParamRed);
            break;
        case 4:
            MIC.SetScalarParameterValue('Scalar_BattleGrime', 0.5);
            MIC.SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1.6);
            MIC.SetScalarParameterValue('Scalar_GlowFlashing', ((IsAliveAndWell()) ? 1 : 0));
            MIC.SetVectorParameterValue('Vector_GlowColor', BattlePhaseGlowColorParamBlinking);
            break;
        default:
            break;
    }
}

simulated function UpdateBattlePhaseParticles()
{
    switch(CurrentBattlePhase)
    {
        case 1:
            break;
        case 2:
            DetachEmitter(BattleDamagePSC_LegR);
            DetachEmitter(BattleDamagePSC_ArmL);
            DetachEmitter(BattleDamagePSC_Chest);
            BattleDamagePSC_LegR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Low, Mesh, BattleDamageFXSocketName_LegR, true);
            BattleDamagePSC_ArmL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Low, Mesh, BattleDamageFXSocketName_ArmL, true);
            BattleDamagePSC_Chest = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Low, Mesh, BattleDamageFXSocketName_Chest, true);
            break;
        case 3:
            DetachEmitter(BattleDamagePSC_LegR);
            DetachEmitter(BattleDamagePSC_LegL);
            DetachEmitter(BattleDamagePSC_ArmR);
            DetachEmitter(BattleDamagePSC_ArmL);
            DetachEmitter(BattleDamagePSC_Chest);
            DetachEmitter(BattleDamagePSC_TorsoR);
            DetachEmitter(BattleDamagePSC_TorsoL);
            DetachEmitter(BattleDamagePSC_Back);
            BattleDamagePSC_LegR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Mid, Mesh, BattleDamageFXSocketName_LegR, true);
            BattleDamagePSC_LegL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Low, Mesh, BattleDamageFXSocketName_LegL, true);
            BattleDamagePSC_ArmR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Low, Mesh, BattleDamageFXSocketName_ArmR, true);
            BattleDamagePSC_ArmL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Mid, Mesh, BattleDamageFXSocketName_ArmL, true);
            BattleDamagePSC_Chest = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Chest_Mid, Mesh, BattleDamageFXSocketName_Chest, true);
            BattleDamagePSC_TorsoR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Blood_Mid, Mesh, BattleDamageFXSocketName_TorsoR, true);
            BattleDamagePSC_TorsoL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Blood_Mid, Mesh, BattleDamageFXSocketName_TorsoL, true);
            BattleDamagePSC_Back = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Back_Mid, Mesh, BattleDamageFXSocketName_Back, true);
            break;
        case 4:
            DetachEmitter(BattleDamagePSC_LegR);
            DetachEmitter(BattleDamagePSC_LegL);
            DetachEmitter(BattleDamagePSC_ArmR);
            DetachEmitter(BattleDamagePSC_ArmL);
            DetachEmitter(BattleDamagePSC_Chest);
            DetachEmitter(BattleDamagePSC_TorsoR);
            DetachEmitter(BattleDamagePSC_TorsoL);
            DetachEmitter(BattleDamagePSC_Back);
            if(IsAliveAndWell())
            {
                BattleDamagePSC_LegR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_High, Mesh, BattleDamageFXSocketName_LegR, true);
                BattleDamagePSC_LegL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_High, Mesh, BattleDamageFXSocketName_LegL, true);
                BattleDamagePSC_ArmR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_High, Mesh, BattleDamageFXSocketName_ArmR, true);
                BattleDamagePSC_ArmL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_High, Mesh, BattleDamageFXSocketName_ArmL, true);
                BattleDamagePSC_Chest = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Chest_High, Mesh, BattleDamageFXSocketName_Chest, true);
                BattleDamagePSC_TorsoR = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Blood_High, Mesh, BattleDamageFXSocketName_TorsoR, true);
                BattleDamagePSC_TorsoL = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Blood_High, Mesh, BattleDamageFXSocketName_TorsoL, true);
                BattleDamagePSC_Back = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_Back_High, Mesh, BattleDamageFXSocketName_Back, true);
            }
            break;
        default:
            break;
    }
}

simulated function SetGameplayMICParams()
{
    super(KFPawn_Monster).SetGameplayMICParams();
    OnBattlePhaseChanged();
}

simulated function KFSkinTypeEffects GetHitZoneSkinTypeEffects(int HitZoneIdx)
{
    if(bInHuntAndHealMode)
    {
        return ShieldImpactEffects;        
    }
    else
    {
        return super(KFPawn).GetHitZoneSkinTypeEffects(HitZoneIdx);
    }
}

defaultproperties
{
    MeleeAnimSet=AnimSet'ZED_Hans_ANIM.Hans_Melee_Master'
    GunsAnimSet=AnimSet'ZED_Hans_ANIM.Hans_Gun_Master'
    HeavyBumpDamageType=Class'KFDT_HeavyZedBump'
    AmbientBreathingEvent=AkEvent'WW_VOX_NPC_HansVolter.Play_HANS_Breathing_Base'
    LowHealthAmbientBreathingEvent=AkEvent'WW_VOX_NPC_HansVolter.Play_HANS_BreathHurt_Base'
    TickDialogInterval=0.5
    BackPackSmokeEffectTemplate=ParticleSystem'ZED_Hans_EMIT.FX_Life_Drain_Smoke_01'
    BattlePhaseLightFrontSocketName=Light_Front
    BattlePhaseLightBackSocketName=Light_Back
    begin object name=PointLightComponent0 class=PointLightComponent
        Radius=128
        LightColor=(B=173,G=222,R=168,A=255)
        CastShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPawn_ZedHans.PointLightComponent0'
    BattlePhaseLightTemplateGreen=PointLightComponent0
    begin object name=PointLightComponent1 class=PointLightComponent
        Radius=128
        LightColor=(B=161,G=215,R=231,A=255)
        CastShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPawn_ZedHans.PointLightComponent1'
    BattlePhaseLightTemplateYellow=PointLightComponent1
    begin object name=PointLightComponent2 class=PointLightComponent
        Radius=128
        LightColor=(B=0,G=144,R=231,A=255)
        CastShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPawn_ZedHans.PointLightComponent2'
    BattlePhaseLightTemplateRed=PointLightComponent2
    begin object name=PointLightComponent3 class=PointLightComponent
        Radius=128
        Brightness=2
        LightColor=(B=64,G=64,R=255,A=255)
        CastShadows=false
        LightingChannels=(Outdoor=true)
        MaxBrightness=2
        MinBrightness=1
        AnimationType=1
        AnimationFrequency=5
    object end
    // Reference: PointLightComponent'Default__KFPawn_ZedHans.PointLightComponent3'
    BattlePhaseLightTemplateBlinking=PointLightComponent3
    BattlePhaseGlowColorParamGreen=(R=0.1,G=1,B=0,A=1)
    BattlePhaseGlowColorParamYellow=(R=1,G=0.5,B=0,A=1)
    BattlePhaseGlowColorParamRed=(R=1,G=0.1,B=0,A=1)
    BattlePhaseGlowColorParamBlinking=(R=2,G=0,B=0,A=1)
    BattleDamageFXSocketName_LegR=LegVent_R
    BattleDamageFXSocketName_LegL=LegVent_L
    BattleDamageFXSocketName_ArmR=ArmVent_R
    BattleDamageFXSocketName_ArmL=ArmVent_L
    BattleDamageFXSocketName_Chest=Chest_FX
    BattleDamageFXSocketName_TorsoR=Implant_FX_R
    BattleDamageFXSocketName_TorsoL=Implant_FX_L
    BattleDamageFXSocketName_Back=BackPackVent
    BattleDamageFX_Sparks_Low=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Sparks_LowD_01'
    BattleDamageFX_Sparks_Mid=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Sparks_MidD_01'
    BattleDamageFX_Sparks_High=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Sparks_HighD_01'
    BattleDamageFX_Sparks_Chest_Mid=ParticleSystem'ZED_Hans_EMIT.FX_Chest_electricity_HighD_01'
    BattleDamageFX_Sparks_Chest_High=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Paralyze_01'
    BattleDamageFX_Sparks_Back_Mid=ParticleSystem'ZED_Hans_EMIT.FX_Back_sparks_MidD_01'
    BattleDamageFX_Sparks_Back_High=ParticleSystem'ZED_Hans_EMIT.FX_Back_sparks_HighD_01'
    BattleDamageFX_Blood_Mid=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Blood_Spray_02'
    BattleDamageFX_Blood_High=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Blood_Spray_01'
    InvulnerableShieldFX=ParticleSystem'ZED_Hans_EMIT.FX_Hans_Hunt_Shield'
    ShieldSocketName=Hips
    ShieldImpactEffects=KFSkinTypeEffects_HansShield'Default__KFPawn_ZedHans.ShieldEffects'
    BattlePhases=/* Array type was not detected. */
    CurrentBattlePhase=1
    HuntAndHealModeDamageReduction=0.15
    ExplosiveGrenadeClass=Class'KFProj_HansHEGrenade'
    NerveGasGrenadeClass=Class'KFProj_HansNerveGasGrenade'
    SmokeGrenadeClass=Class'KFProj_HansSmokeGrenade'
    RightHandSocketName=RightHandSocket
    LeftHandSocketName=LeftHandSocket
    GrenadeTossSpread=0.07
    SmokeTossCooldown=5
    SummonWaves[0]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Normal_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Normal_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Normal_Three')
    SummonWaves[1]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Hard_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Hard_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Hard_Three')
    SummonWaves[2]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Suicidal_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Suicidal_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_Suicidal_Three')
    SummonWaves[3]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_HOE_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_HOE_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Hans_Minions_HOE_Three')
    NumMinionsToSpawn=8
    bLargeZed=true
    bCanGrabAttack=true
    CharacterMonsterArch=KFCharacterInfo_Monster'ZED_Hans_ARCH.ZED_Hans_Archetype'
    HeadlessBleedOutTime=6
    ParryResistance=4
    begin object name=MeleeHelper class=KFMeleeHelperAI
        BaseDamage=75
        MyDamageType=Class'KFDT_Slashing_Hans'
        MomentumTransfer=40000
        MaxHitRange=275
    object end
    // Reference: KFMeleeHelperAI'Default__KFPawn_ZedHans.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    DoshValue=500
    XPValues[0]=423
    XPValues[1]=564
    XPValues[2]=762
    XPValues[3]=874
    VulnerableDamageTypes=/* Array type was not detected. */
    ResistantDamageTypes=/* Array type was not detected. */
    BumpDamageType=Class'KFGame.KFDT_NPCBump_Large'
    PawnAnimInfo=KFPawnAnimInfo'ZED_Hans_ANIM.Hans_AnimGroup'
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_ZedHans.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bEnableAimOffset=true
    HitZones=/* Array type was not detected. */
    PenetrationResistance=4
    begin object name=Afflictions class=KFPawnAfflictions
        InstantAffl=/* Array type was not detected. */
        StackingAffl=/* Array type was not detected. */
    object end
    // Reference: KFPawnAfflictions'Default__KFPawn_ZedHans.Afflictions'
    AfflictionHandler=Afflictions
    KnockdownImpulseScale=1
    SprintSpeed=650
    DefaultInventory=/* Array type was not detected. */
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedHans.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses=/* Array type was not detected. */
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_ZedHans.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_ZedHans.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_ZedHans.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_ZedHans.WeaponAmbientEchoHandler'
    FootstepAkComponent=AkComponent'Default__KFPawn_ZedHans.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_ZedHans.DialogAkSoundComponent'
    DamageRecoveryTimeHeavy=0.1
    DamageRecoveryTimeMedium=0.09
    Mass=175
    GroundSpeed=210
    Health=3500
    ControllerClass=Class'KFGame.KFAIController_Hans'
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedHans.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedHans.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_ZedHans.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedHans.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_ZedHans.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedHans.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_ZedHans.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_ZedHans.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_ZedHans.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_ZedHans.DialogAkSoundComponent'
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedHans.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    RotationRate=(Pitch=50000,Yaw=50000,Roll=50000)
}