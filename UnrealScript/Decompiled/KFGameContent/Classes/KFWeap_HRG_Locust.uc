/*******************************************************************************
 * KFWeap_HRG_Locust generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_HRG_Locust extends KFWeap_GrenadeLauncher_Base
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const MAX_LOCKED_TARGETS = 6;

var protected array<Pawn> LockedTargets;
var float BurstFireRecoilModifier;
var protected float LastTargetLockTime;
var protected float LastTargetValidationCheckTime;
var const float TimeBetweenLockOns;
var const float TargetValidationCheckInterval;
var const float MinTargetDistFromCrosshairSQ;
var const float MaxLockMaintainFOVDotThreshold;
var AkBaseSoundObject LockAcquiredSoundFirstPerson;
var AkBaseSoundObject LockLostSoundFirstPerson;
var const Texture2D LockedOnIcon;
var LinearColor LockedIconColor;
var export editinline AkComponent IronsightsComponent;
var AkEvent IronsightsZoomInSound;
var AkEvent IronsightsZoomOutSound;
/** Reduction for the amount of damage dealt to the weapon owner (including damage by the explosion) */
var() float SelfDamageReductionValue;

simulated function AltFireMode()
{
    super(KFWeapon).AltFireMode();
    LockedTargets.Length = 0;
}

simulated event Tick(float DeltaTime)
{
    local Pawn RecentlyLocked, StaticLockedTargets;
    local bool bUpdateServerTargets;
    local int I;

    super(KFWeapon).Tick(DeltaTime);
    if(((bUsingSights && bUseAltFireMode) && Instigator != none) && Instigator.IsLocallyControlled())
    {
        if((((WorldInfo.TimeSeconds - LastTargetLockTime) > TimeBetweenLockOns) && LockedTargets.Length < AmmoCount[GetAmmoType(0)]) && LockedTargets.Length < 6)
        {
            bUpdateServerTargets = FindTargets(RecentlyLocked);
        }
        if(LockedTargets.Length > 0)
        {
            bUpdateServerTargets = bUpdateServerTargets || ValidateTargets(RecentlyLocked);
        }
        if(bUpdateServerTargets && Role < ROLE_Authority)
        {
            I = 0;
            J0x15E:

            if(I < 6)
            {
                if(I < LockedTargets.Length)
                {
                    StaticLockedTargets[I] = LockedTargets[I];                    
                }
                else
                {
                    StaticLockedTargets[I] = none;
                }
                ++ I;
                goto J0x15E;
            }
            ServerSyncLockedTargets(StaticLockedTargets);
        }
    }
}

simulated function bool CanLockOnTo(Actor TA)
{
    local KFPawn PawnTarget;

    PawnTarget = KFPawn(TA);
    if(((((((TA == none) || !TA.bProjTarget) || TA.bDeleteMe) || PawnTarget == none) || TA == Instigator) || PawnTarget.Health <= 0) || !HasAmmo(0))
    {
        return false;
    }
    return !WorldInfo.GRI.OnSameTeam(Instigator, TA);
}

simulated function bool FindTargets(out Pawn RecentlyLocked)
{
    local Pawn P, BestTargetLock;
    local byte TeamNum;
    local Vector AimStart, AimDir, TargetLoc, Projection, DirToPawn, LinePoint;

    local Actor HitActor;
    local float PointDistSQ, Score, BestScore, TargetSizeSQ;

    TeamNum = Instigator.GetTeamNum();
    AimStart = GetSafeStartTraceLocation();
    AimDir = vector(GetAdjustedAim(AimStart));
    BestScore = 0;
    if(IsInState('WeaponBurstFiring'))
    {
        return false;
    }
    foreach WorldInfo.AllPawns(Class'Pawn', P)
    {
        if(!CanLockOnTo(P))
        {
            continue;            
        }
        if((((P != none) && P.IsAliveAndWell()) && P.GetTeamNum() != TeamNum) && LockedTargets.Find(P == -1)
        {
            TargetLoc = GetLockedTargetLoc(P);
            Projection = TargetLoc - AimStart;
            DirToPawn = Normal(Projection);
            if((AimDir Dot DirToPawn) < 0.5)
            {
                continue;                
            }
            PointDistToLine(TargetLoc, AimDir, AimStart, LinePoint);
            PointDistSQ = VSizeSq(LinePoint - P.Location);
            TargetSizeSQ = P.GetCollisionRadius() * 2;
            TargetSizeSQ *= TargetSizeSQ;
            if(PointDistSQ > (TargetSizeSQ + MinTargetDistFromCrosshairSQ))
            {
                continue;                
            }
            HitActor = Class'KFAIController'.static.ActorBlockTest(self, TargetLoc, AimStart,, true, true);
            if((HitActor != none) && HitActor != P)
            {
                continue;                
            }
            Score = VSizeSq(Projection) + PointDistSQ;
            if((BestScore == 0) || Score < BestScore)
            {
                BestTargetLock = P;
                BestScore = Score;
            }
        }        
    }    
    if(BestTargetLock != none)
    {
        LastTargetLockTime = WorldInfo.TimeSeconds;
        LockedTargets.AddItem(BestTargetLock;
        RecentlyLocked = BestTargetLock;
        PlayTargetLockOnEffects();
        return true;
    }
    RecentlyLocked = none;
    return false;
}

simulated function bool ValidateTargets(optional Pawn RecentlyLocked)
{
    local int I;
    local bool bShouldRemoveTarget, bAlteredTargets;
    local Vector AimStart, AimDir, TargetLoc;
    local Actor HitActor;

    if((WorldInfo.TimeSeconds - LastTargetValidationCheckTime) < TargetValidationCheckInterval)
    {
        return false;
    }
    LastTargetValidationCheckTime = WorldInfo.TimeSeconds;
    AimStart = GetSafeStartTraceLocation();
    AimDir = vector(GetAdjustedAim(AimStart));
    bAlteredTargets = false;
    I = 0;
    J0xAC:

    if(I < LockedTargets.Length)
    {
        if((RecentlyLocked != none) && RecentlyLocked == LockedTargets[I])
        {            
        }
        else
        {
            bShouldRemoveTarget = false;
            if((LockedTargets[I] == none) || !LockedTargets[I].IsAliveAndWell())
            {
                bShouldRemoveTarget = true;                
            }
            else
            {
                TargetLoc = GetLockedTargetLoc(LockedTargets[I]);
                if((AimDir Dot Normal(LockedTargets[I].Location - AimStart)) >= MaxLockMaintainFOVDotThreshold)
                {
                    HitActor = Class'KFAIController'.static.ActorBlockTest(self, TargetLoc, AimStart,, true, true);
                    if((HitActor != none) && HitActor != LockedTargets[I])
                    {
                        bShouldRemoveTarget = true;
                    }                    
                }
                else
                {
                    bShouldRemoveTarget = true;
                }
            }
            if(bShouldRemoveTarget)
            {
                LockedTargets.Remove(I, 1;
                -- I;
                bAlteredTargets = true;                
            }
        }
        ++ I;
        goto J0xAC;
    }
    if(bAlteredTargets && RecentlyLocked == none)
    {
        PlayTargetLostEffects();
    }
    return bAlteredTargets;
}

reliable server function ServerSyncLockedTargets(Pawn TargetPawns[6])
{
    local int I;

    LockedTargets.Length = 0;
    I = 0;
    J0x17:

    if(I < 6)
    {
        if(TargetPawns[I] != none)
        {
            LockedTargets.AddItem(TargetPawns[I];
        }
        ++ I;
        goto J0x17;
    }
}

static simulated function Vector GetLockedTargetLoc(Pawn P)
{
    if((P.Mesh.SkeletalMesh != none) && P.Mesh.bAnimTreeInitialised)
    {
        if(P.Mesh.MatchRefBone('Spine2') != -1)
        {
            return P.Mesh.GetBoneLocation('Spine2');            
        }
        else
        {
            if(P.Mesh.MatchRefBone('Spine1') != -1)
            {
                return P.Mesh.GetBoneLocation('Spine1');
            }
        }
        return P.Mesh.GetPosition() + ((P.CylinderComponent.CollisionHeight + (P.BaseEyeHeight * 0.5)) * vect(0, 0, 1));
    }
    return P.Location + ((vect(0, 0, 1) * P.BaseEyeHeight) * 0.75);
}

simulated function ZoomIn(bool bAnimateTransition, float ZoomTimeToGo)
{
    super(KFWeapon).ZoomIn(bAnimateTransition, ZoomTimeToGo);
    if(((IronsightsZoomInSound != none) && Instigator != none) && Instigator.IsLocallyControlled())
    {
        IronsightsComponent.PlayEvent(IronsightsZoomInSound, false);
    }
}

simulated function ZoomOut(bool bAnimateTransition, float ZoomTimeToGo)
{
    super(KFWeapon).ZoomOut(bAnimateTransition, ZoomTimeToGo);
    if(((IronsightsZoomOutSound != none) && Instigator != none) && Instigator.IsLocallyControlled())
    {
        IronsightsComponent.PlayEvent(IronsightsZoomOutSound, false);
    }
    if(Instigator.IsLocallyControlled() && LockedTargets.Length > 0)
    {
        PlayTargetLostEffects();
    }
    LockedTargets.Length = 0;
}

simulated function PlayTargetLockOnEffects()
{
    if((Instigator != none) && Instigator.IsHumanControlled())
    {
        PlaySoundBase(LockAcquiredSoundFirstPerson, true);
    }
}

simulated function PlayTargetLostEffects()
{
    if((Instigator != none) && Instigator.IsHumanControlled())
    {
        PlaySoundBase(LockLostSoundFirstPerson, true);
    }
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProj_HRG_Locust LocustProj;

    if(CurrentFireMode == 4)
    {
        return super(KFWeapon).SpawnProjectile(KFProjClass, RealStartLoc, AimDir);
    }
    if((bUsingSights && CurrentFireMode == 1) && LockedTargets.Length > 0)
    {
        if(LockedTargets.Length > 0)
        {
            LocustProj = KFProj_HRG_Locust(super(KFWeapon).SpawnProjectile(KFProjClass, RealStartLoc, AimDir));
            if(LocustProj != none)
            {
                LocustProj.SetLockedTarget(KFPawn(LockedTargets[0]));
                LockedTargets.Remove(0, 1;
                return LocustProj;
            }
        }
        return none;
    }
    return super(KFWeapon).SpawnProjectile(KFProjClass, RealStartLoc, AimDir);
}

simulated function DrawHUD(HUD H, Canvas C)
{
    local int I;

    if(!bUsingSights || LockedTargets.Length == 0)
    {
        return;
    }
    C.EnableStencilTest(true);
    I = 0;
    J0x4E:

    if(I < LockedTargets.Length)
    {
        if(LockedTargets[I] != none)
        {
            DrawTargetingIcon(C, I);
        }
        ++ I;
        goto J0x4E;
    }
    C.EnableStencilTest(false);
}

simulated function DrawTargetingIcon(Canvas Canvas, int Index)
{
    local Vector WorldPos, ScreenPos;
    local float IconSize, IconScale;

    WorldPos = GetLockedTargetLoc(LockedTargets[Index]);
    ScreenPos = Canvas.Project(WorldPos);
    IconScale = FMin(float(Canvas.SizeX) / 1024, 1);
    IconScale *= FClamp(1 - (VSize(WorldPos - Instigator.Location) / 4000), 0.2, 1);
    IconSize = 200 * IconScale;
    ScreenPos.X -= (IconSize / 2);
    ScreenPos.Y -= (IconSize / 2);
    if((((ScreenPos.X < float(0)) || ScreenPos.X > float(Canvas.SizeX)) || ScreenPos.Y < float(0)) || ScreenPos.Y > float(Canvas.SizeY))
    {
        return;
    }
    Canvas.SetPos(ScreenPos.X, ScreenPos.Y);
    Canvas.DrawTile(LockedOnIcon, IconSize, IconSize, 0, 0, float(LockedOnIcon.SizeX), float(LockedOnIcon.SizeY), LockedIconColor);
}

function AdjustDamage(out int InDamage, class<DamageType> DamageType, Actor DamageCauser)
{
    super(KFWeapon).AdjustDamage(InDamage, DamageType, DamageCauser);
    if((Instigator != none) && DamageCauser.Instigator == Instigator)
    {
        InDamage *= SelfDamageReductionValue;
    }
}

simulated state WeaponSingleFiring
{
    simulated function BeginState(name PrevStateName)
    {
        LockedTargets.Length = 0;
        super(WeaponFiring).BeginState(PrevStateName);
    }
    stop;    
}

simulated state WeaponBurstFiring
{
    simulated function int GetBurstAmount()
    {
        return Clamp(LockedTargets.Length, 1, AmmoCount[GetAmmoType(CurrentFireMode)]);
    }

    simulated function ModifyRecoil(out float CurrentRecoilModifier)
    {
        super(KFWeapon).ModifyRecoil(CurrentRecoilModifier);
        CurrentRecoilModifier *= BurstFireRecoilModifier;
    }

    simulated function bool ShouldRefire()
    {
        return LockedTargets.Length > 0;
    }

    simulated function FireAmmunition()
    {
        super.FireAmmunition();
        if(Role < ROLE_Authority)
        {
            LockedTargets.Remove(0, 1;
        }
    }

    simulated event EndState(name NextStateName)
    {
        LockedTargets.Length = 0;
        super.EndState(NextStateName);
    }
    stop;    
}

defaultproperties
{
    BurstFireRecoilModifier=0.15
    TimeBetweenLockOns=0.06
    TargetValidationCheckInterval=0.1
    MinTargetDistFromCrosshairSQ=2500
    MaxLockMaintainFOVDotThreshold=0.36
    LockAcquiredSoundFirstPerson=AkEvent'WW_WEP_SA_Railgun.Play_Railgun_Scope_Locked'
    LockLostSoundFirstPerson=AkEvent'WW_WEP_SA_Railgun.Play_Railgun_Scope_Lost'
    LockedOnIcon=Texture2D'Wep_Scope_TEX.Wep_1stP_Yellow_Red_Target'
    LockedIconColor=(R=1,G=0,B=0,A=0.5)
    begin object name=IronsightsComponent0 class=AkComponent
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFWeap_HRG_Locust.IronsightsComponent0'
    IronsightsComponent=IronsightsComponent0
    IronsightsZoomInSound=AkEvent'WW_WEP_Seeker_6.Play_Seeker_6_Iron_In'
    IronsightsZoomOutSound=AkEvent'WW_WEP_Seeker_6.Play_Seeker_6_Iron_In_Out'
    ForceReloadTime=0.4
    PackageKey="HRG_Locust"
    FirstPersonMeshName="wep_1p_hrg_locust_mesh.Wep_1stP_HRG_Locust_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="wep_3p_hrg_locust_mesh.Wep_3rdP_HRG_Locust_Pickup"
    AttachmentArchetypeName="wep_hrg_locust_arch.Wep_HRG_Locust_3P"
    MuzzleFlashTemplateName="wep_hrg_locust_arch.Wep_HRG_Locust_MuzzleFlash"
    bHasIronSights=true
    bCanBeReloaded=true
    bReloadFromMagazine=true
    bHasFireLastAnims=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=6
    MeshIronSightFOV=65
    PlayerIronSightFOV=70
    IronSightPosition=(X=0,Y=-0.065,Z=-0.31)
    FastZoomOutTime=0.2
    DOF_FG_MaxNearBlurSize=2.5
    GroupPriority=100
    WeaponSelectTexture=Texture2D'wep_ui_hrg_locust_tex.UI_WeaponSelect_HRG_Locust'
    MagazineCapacity=6
    SpareAmmoCapacity=84
    InitialSpareMags=3
    AmmoPickupScale=2
    WeaponFireWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Heavy_Recoil_SingleShot'
    IdleFidgetAnims=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=20,Y=5,Z=-5)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_HRG_Locust.MeleeHelper'
    maxRecoilPitch=400
    minRecoilPitch=275
    maxRecoilYaw=200
    minRecoilYaw=-200
    RecoilRate=0.085
    RecoilBlendOutRatio=0.35
    RecoilViewRotationScale=0.8
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMinPitchLimit=64785
    RecoilISMaxYawLimit=50
    RecoilISMinYawLimit=65485
    RecoilISMaxPitchLimit=500
    RecoilISMinPitchLimit=65485
    HippedRecoilModifier=1.25
    FallingRecoilModifier=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=20,Y=4,Z=-3)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_HRG_Locust.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="HRG Locust"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Locust.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Locust.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
    begin object name=IronsightsComponent0 class=AkComponent
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
    object end
    // Reference: AkComponent'Default__KFWeap_HRG_Locust.IronsightsComponent0'
    Components(0)=IronsightsComponent0
}