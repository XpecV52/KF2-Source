/*******************************************************************************
 * KFObj_Wave generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFObj_Wave extends KFObjective
    config(Game)
    hidecategories(Navigation,Movement,Collision);

var bool bInfiniteSpawningEnabled;
var const localized string ObjectiveAvailableString;
var int CurAlertAlpha;
var int AlertAlphaDelta;

simulated event ReplicatedEvent(name VarName)
{
    if(bLogObjective)
    {
        LogInternal((("[OBJECTIVE]" @ string(GetFuncName())) @ "Replicated variable:") @ string(VarName));
    }
    if(VarName == 'ObjectiveState')
    {
        switch(ObjectiveState)
        {
            case 0:
                HideObj();
                EndObjective();
                break;
            case 1:
                DoObjAlertNotify();
                break;
            case 2:
                PreStartObjective();
                break;
            case 3:
                StartObjective();
                break;
            case 4:
                HideObj();
                break;
            case 5:
                HideObj();
                break;
            default:
                break;
        }        
    }
    else
    {
        super.ReplicatedEvent(VarName);
    }
}

simulated event Initialize()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    super.Initialize();
    NotifyGRI();
    StartVolume.InitVolume(self);
    StartVolume.Unhide();
    ObjectiveState = 1;
    if(WorldInfo.Role == ROLE_Authority)
    {
        SetTimer(ObjectiveAlertDelay, false, 'PreStartObjective');
    }
    bNetDirty = true;
}

simulated function PreStartObjective()
{
    super.PreStartObjective();
    if(WorldInfo.Role == ROLE_Authority)
    {
        ObjectiveState = 2;
    }
    ObjectiveStartTime = WorldInfo.TimeSeconds + ObjectiveStartDelay;
}

simulated function StartObjective()
{
    if(bLogObjective)
    {
        LogInternal("[OBJECTIVE]" @ string(GetFuncName()));
    }
    super.StartObjective();
    EnableInifiteSpawning();
}

function WinObjective()
{
    DisableInifiteSpawning();
    super.WinObjective();
}

simulated function FailObjective(KFGame.KFObjective.EObjFailIndex FailReason)
{
    DisableInifiteSpawning();
    super.FailObjective(FailReason);
}

simulated function EndObjective()
{
    StartVolume = none;
    super.EndObjective();
}

simulated function ShowObjStartMessage()
{
    local KFGameInfo KFGI;

    super.ShowObjStartMessage();
    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && WorldInfo.Role == ROLE_Authority)
    {
        BroadcastLocalizedMessage(Class'KFLocalMessage_Priority', 4);
    }
}

simulated function ShowObjWinMessage()
{
    local KFGameInfo KFGI;

    super.ShowObjWinMessage();
    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && WorldInfo.Role == ROLE_Authority)
    {
        BroadcastLocalizedMessage(Class'KFLocalMessage_Priority', 5);
    }
}

simulated function ShowObjFailMessage()
{
    local KFGameInfo KFGI;
    local byte FailMessage;

    super.ShowObjFailMessage();
    KFGI = KFGameInfo(WorldInfo.Game);
    if((KFGI != none) && WorldInfo.Role == ROLE_Authority)
    {
        switch(ObjectiveFailReason)
        {
            case 6:
                FailMessage = 7;
                break;
            case 0:
                FailMessage = 8;
                break;
            default:
                FailMessage = 6;
                break;
        }
        BroadcastLocalizedMessage(Class'KFLocalMessage_Priority', FailMessage);
    }
}

protected function EnableInifiteSpawning()
{
    NotifySpawnManager(true);
    bInfiniteSpawningEnabled = true;
}

protected function DisableInifiteSpawning()
{
    NotifySpawnManager(false);
    bInfiniteSpawningEnabled = false;
}

function bool InfiniteZedsEnabled()
{
    return bInfiniteSpawningEnabled;
}

simulated function DrawObjAlertHUD(Canvas C)
{
    local float XPos, YPos, CurScale;

    CurAlertAlpha += AlertAlphaDelta;
    if((CurAlertAlpha >= 255) || CurAlertAlpha <= 0)
    {
        CurAlertAlpha = ((CurAlertAlpha >= 255) ? 255 : 0);
        AlertAlphaDelta = -AlertAlphaDelta;
    }
    C.SetDrawColor(255, 255, 255, byte(CurAlertAlpha));
    CurScale = 1;
    C.bCenter = true;
    XPos = (float(C.SizeX) - (float(256) * CurScale)) - float(10);
    YPos = 10;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjAlertTex, 96 * CurScale, 96 * CurScale, 0, 0, 256, 256);
}

simulated function DrawObjPrestartHUD(Canvas C)
{
    local float XPos, YPos, CurScale, textscale, HeaderHeight, BodyHeight,
	    OrigX, OrigY, Padding, Width, HeaderTextPadding,
	    IconSize, IconSizeSmall, TextScaleSmall;

    local string TempString;
    local int TimeSeconds, TimeMinutes, CurrentTime;
    local Color HeaderColor, BodyColor;

    CurScale = 1;
    textscale = 0.36;
    TextScaleSmall = 0.3;
    HeaderHeight = 28;
    HeaderTextPadding = 6;
    BodyHeight = 140;
    Width = 272;
    Padding = 10;
    OrigX = (float(C.SizeX) - (Width * CurScale)) - Padding;
    OrigY = Padding;
    HeaderColor = MakeColor(137, 58, 43, 192);
    BodyColor = MakeColor(0, 0, 0, 128);
    C.Font = ObjectiveFont;
    IconSize = 22;
    IconSizeSmall = 16;
    C.bNoSmooth = false;
    C.DrawColor = HeaderColor;
    XPos = OrigX;
    YPos = OrigY;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, Width * CurScale, HeaderHeight * CurScale, 0, 0, 32, 32);
    C.DrawColor = BodyColor;
    YPos += HeaderHeight;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, Width * CurScale, BodyHeight * CurScale, 0, 0, 32, 32);
    XPos = OrigX + HeaderTextPadding;
    YPos = OrigY + (HeaderTextPadding / float(2));
    C.SetPos(XPos, YPos);
    C.SetDrawColor(255, 255, 255, 255);
    C.DrawTile(ObjAlertAlphaTex, IconSize * CurScale, IconSize * CurScale, 0, 0, 256, 256);
    XPos += (IconSize + HeaderTextPadding);
    C.SetPos(XPos, YPos);
    C.DrawText(ObjectiveAvailableString, false, textscale, textscale);
    XPos = OrigX + HeaderTextPadding;
    YPos = (OrigY + HeaderHeight) + (float(2) * HeaderTextPadding);
    C.SetPos(XPos, YPos);
    TempString = (ObjectiveTypeString @ "-") @ ObjectiveDifficulties[ObjectiveDifficulty];
    C.DrawText(TempString, false, textscale, textscale);
    YPos += (HeaderTextPadding + IconSize);
    C.SetPos(XPos, YPos);
    C.DrawTile(DoshTex, IconSize * CurScale, IconSize * CurScale, 0, 0, 256, 256);
    XPos += ((1.5 * HeaderTextPadding) + IconSize);
    C.SetPos(XPos, YPos);
    C.DrawText(string(DoshReward), false, textscale, textscale);
    XPos += (HeaderHeight * float(2));
    C.SetPos(XPos, YPos);
    TempString = ObjectiveXPString @ string(PerkReward);
    C.DrawText(TempString, false, textscale, textscale);
    XPos = OrigX + HeaderTextPadding;
    YPos += (HeaderHeight * 1.6);
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, IconSizeSmall * CurScale, IconSizeSmall * CurScale, 0, 0, 32, 32);
    C.SetDrawColor(0, 0, 0, 255);
    XPos += 1;
    YPos += 1;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, (IconSizeSmall - float(2)) * CurScale, (IconSizeSmall - float(2)) * CurScale, 0, 0, 32, 32);
    C.SetDrawColor(255, 255, 255, 255);
    XPos -= 1;
    YPos -= 1;
    XPos += (IconSizeSmall + HeaderTextPadding);
    C.SetPos(XPos, YPos);
    C.DrawText(ObjectiveStartTitle, false, TextScaleSmall, TextScaleSmall);
    XPos = OrigX + HeaderTextPadding;
    YPos += (float(4) * HeaderTextPadding);
    C.SetPos(XPos, YPos);
    CurrentTime = Max(0, int(ObjectiveStartTime - WorldInfo.TimeSeconds));
    TimeMinutes = CurrentTime / 60;
    TimeSeconds = CurrentTime % 60;
    if(TimeSeconds > 9)
    {
        TempString = (((ObjectiveTimeLimitString @ string(TimeMinutes)) $ ":") $ string(TimeSeconds)) $ ObjectiveTimeUnit;        
    }
    else
    {
        TempString = (((ObjectiveTimeLimitString @ string(TimeMinutes)) $ ":0") $ string(TimeSeconds)) $ ObjectiveTimeUnit;
    }
    C.DrawText(TempString, false, textscale, textscale);
    C.Reset();
}

simulated function DrawTrackerHUD(Canvas C)
{
    local float XPos, YPos, CurScale, textscale, HeaderHeight, BodyHeight,
	    OrigX, OrigY, Padding, Width, HeaderTextPadding,
	    IconSizeSmall, TextScaleSmall;

    local string TempString;
    local int TimeSeconds, TimeMinutes, CurrentTime;
    local Color HeaderColor, BodyColor;

    CurScale = 1;
    textscale = 0.36;
    TextScaleSmall = 0.3;
    HeaderHeight = 28;
    HeaderTextPadding = 6;
    BodyHeight = 140;
    Width = 272;
    Padding = 10;
    OrigX = (float(C.SizeX) - (Width * CurScale)) - Padding;
    OrigY = Padding;
    HeaderColor = MakeColor(137, 58, 43, 192);
    BodyColor = MakeColor(0, 0, 0, 128);
    C.Font = ObjectiveFont;
    IconSizeSmall = 16;
    C.bNoSmooth = false;
    C.DrawColor = HeaderColor;
    XPos = OrigX;
    YPos = OrigY;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, Width * CurScale, HeaderHeight * CurScale, 0, 0, 32, 32);
    C.DrawColor = BodyColor;
    YPos += HeaderHeight;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, Width * CurScale, BodyHeight * CurScale, 0, 0, 32, 32);
    XPos = OrigX + HeaderTextPadding;
    YPos = OrigY + (HeaderTextPadding / float(2));
    C.SetDrawColor(255, 255, 255, 255);
    C.SetPos(XPos, YPos);
    C.DrawText(ObjectiveStatusString, false, textscale, textscale);
    YPos += ((OrigY + HeaderHeight) + (float(2) * HeaderTextPadding));
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, IconSizeSmall * CurScale, IconSizeSmall * CurScale, 0, 0, 32, 32);
    C.SetDrawColor(0, 0, 0, 255);
    XPos += 1;
    YPos += 1;
    C.SetPos(XPos, YPos);
    C.DrawTile(ObjWhiteTex, (IconSizeSmall - float(2)) * CurScale, (IconSizeSmall - float(2)) * CurScale, 0, 0, 32, 32);
    C.SetDrawColor(255, 255, 255, 255);
    XPos -= 1;
    YPos -= 1;
    XPos += (IconSizeSmall + HeaderTextPadding);
    C.SetPos(XPos, YPos);
    C.DrawText(ObjectiveTargetTitle, false, TextScaleSmall, TextScaleSmall);
    YPos += (IconSizeSmall + (float(4) * HeaderTextPadding));
    XPos = OrigX + HeaderTextPadding;
    C.SetPos(XPos, YPos);
    C.SetDrawColor(255, 255, 255, 255);
    C.DrawRect(102, 16);
    YPos += float(1);
    C.SetPos(XPos + float(1), YPos);
    C.SetDrawColor(137, 58, 43, 255);
    C.DrawRect(float(ObjectiveProgress), 14);
    C.SetDrawColor(255, 255, 255, 255);
    XPos = OrigX + HeaderTextPadding;
    YPos += (IconSizeSmall + (float(4) * HeaderTextPadding));
    C.SetPos(XPos, YPos);
    CurrentTime = Max(0, int(ObjectiveEndTime - WorldInfo.TimeSeconds));
    TimeMinutes = CurrentTime / 60;
    TimeSeconds = CurrentTime % 60;
    if(TimeSeconds > 9)
    {
        TempString = (((ObjectiveTimeLimitString @ string(TimeMinutes)) $ ":") $ string(TimeSeconds)) $ ObjectiveTimeUnit;        
    }
    else
    {
        TempString = (((ObjectiveTimeLimitString @ string(TimeMinutes)) $ ":0") $ string(TimeSeconds)) $ ObjectiveTimeUnit;
    }
    C.DrawText(TempString, false, textscale, textscale);
    C.Reset();
}

defaultproperties
{
    AlertAlphaDelta=14
}