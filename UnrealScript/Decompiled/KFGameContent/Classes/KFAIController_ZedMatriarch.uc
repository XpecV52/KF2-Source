/*******************************************************************************
 * KFAIController_ZedMatriarch generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController_ZedMatriarch extends KFAIController_ZedBoss
    config(AI)
    hidecategories(Navigation);

enum EMatriarchAttacksByRange
{
    EMatriarchAttacksByRange_SweepingClaw,
    EMatriarchAttacksByRange_LightningStorm,
    EMatriarchAttacksByRange_WarningSiren,
    EMatriarchAttacksByRange_TeslaBlast,
    EMatriarchAttacksByRange_PlasmaCannon,
    EMatriarchAttacksByRange_ScorpionWhip,
    EMatriarchAttacksByRange_MAX
};

var KFPawn_ZedMatriarch MyMatPawn;
var bool bCanEvaluateAttacks;
var bool bLogTargeting;
var config bool bRandomMoves;
var float GlobalCooldownTimer;
var Vector2D GlobalCooldownTimeRange_Melee;
var Vector2D GlobalCooldownTimeRange_LightningStorm;
var Vector2D GlobalCooldownTimeRange_WarningSiren;
var Vector2D GlobalCooldownTimeRange_TeslaBlast;
var Vector2D GlobalCooldownTimeRange_PlasmaCannon;
var Vector2D GlobalCooldownTimeRange_ScorpionWhip;
var Vector2D ReevaluateEnemiesTimeRange;
var transient float ReevaluateEnemiesTimer;
var array<int> PlayerDamages;
var Pawn CurrentTargetPawn;
var float SweepingClawCooldown;
var float LastSweepingClawTime;
var float TeslaBlastCooldown;
var float LastTeslaBlastTime;
var float PlasmaCannonCooldown;
var float LastPlasmaCannonTime;
var float LightningStormCooldown;
var float LastLightningStormTime;
var float WarningSirenCooldown;
var float LastWarningSirenTime;
var float ScorpionWhipCooldown;
var float LastScorpionWhipTime;

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    super.Possess(inPawn, bVehicleTransition);
    if(KFPawn_ZedMatriarch(inPawn) != none)
    {
        MyMatPawn = KFPawn_ZedMatriarch(inPawn);        
    }
    else
    {
        WarnInternal(((string(GetFuncName()) $ "() attempting to possess ") $ string(inPawn)) $ ", but it's not a KFPawn_ZedMatriarch class! MyMatPawn variable will not be valid.");
    }
    GlobalCooldownTimer = 2.5 + FRand();
    bCanEvaluateAttacks = true;
    if((CommandList == none) || CommandList.Class != Class'AICommand_BossTheatrics')
    {
        MyMatPawn.ActivateShield();
    }
    SetReevaluateEnemiesTimer();
}

simulated function SetReevaluateEnemiesTimer()
{
    ReevaluateEnemiesTimer = RandRange(ReevaluateEnemiesTimeRange.X, ReevaluateEnemiesTimeRange.Y);
    if(bLogTargeting)
    {
        LogInternal((string(self) $ "::SetReevaluateEnemiesTimer - ReevaluateEnemiesTimer: ") $ string(ReevaluateEnemiesTimer));
    }
}

simulated function ReevaluateEnemies()
{
    local int MaxPlayerDamage, I;
    local KFPlayerController KFPC, MaxKFPC;

    if(bLogTargeting)
    {
        I = 0;
        J0x18:

        if(I < PlayerDamages.Length)
        {
            LogInternal((((string(self) $ "::ReevaluateEnemies - PlayerDamages ") $ string(I)) $ ": ") $ string(PlayerDamages[I]));
            ++ I;
            goto J0x18;
        }
    }
    MaxPlayerDamage = 0;
    foreach WorldInfo.AllControllers(Class'KFPlayerController', KFPC)
    {
        if(KFPawn(KFPC.Pawn).IsAliveAndWell())
        {
            if((PlayerDamages.Length > KFPC.PlayerNum) && PlayerDamages[KFPC.PlayerNum] > MaxPlayerDamage)
            {
                MaxPlayerDamage = PlayerDamages[KFPC.PlayerNum];
                MaxKFPC = KFPC;
            }
            continue;
        }
        PlayerDamages[MaxKFPC.PlayerNum] = 0;        
    }    
    if(bLogTargeting)
    {
        LogInternal((string(self) $ "::ReevaluateEnemies - Max damage player: ") $ string(MaxKFPC));
    }
    if(MaxKFPC != none)
    {
        CurrentTargetPawn = MaxKFPC.Pawn;
        ChangeEnemy(MaxKFPC.Pawn, false);
        PlayerDamages[MaxKFPC.PlayerNum] = 0;
    }
    SetReevaluateEnemiesTimer();
}

simulated function Tick(float DeltaTime)
{
    super(KFAIController).Tick(DeltaTime);
    EvaluateAttacks(DeltaTime);
}

event SeePlayer(Pawn Seen);

event bool FindNewEnemy()
{
    local bool Result;

    Result = super(KFAIController).FindNewEnemy();
    CurrentTargetPawn = Enemy;
    return Result;
}

function EvaluateAttacks(float DeltaTime)
{
    local float DistToTargetSq;
    local array<KFAIController_ZedMatriarch.EMatriarchAttacksByRange> PossibleMoves;
    local KFAIController_ZedMatriarch.EMatriarchAttacksByRange ChosenMove;

    if(!bCanEvaluateAttacks)
    {
        return;
    }
    ReevaluateEnemiesTimer -= DeltaTime;
    if(MyMatPawn.IsDoingSpecialMove() || (CommandList != none) && GetActiveCommand().IsA('AICommand_SpecialMove'))
    {
        return;
    }
    if(MyMatPawn.bShouldTaunt)
    {
        MyMatPawn.bShouldTaunt = false;
        MyMatPawn.DoSpecialMove(13, true,, Class'KFSM_Matriarch_Taunt'.static.PackSMFlags(MyMatPawn, 0));
        return;
    }
    if(ReevaluateEnemiesTimer <= 0)
    {
        ReevaluateEnemies();
    }
    GlobalCooldownTimer -= DeltaTime;
    if(GlobalCooldownTimer > 0)
    {
        return;
    }
    if((Enemy != none) && WorldInfo.FastTrace(Enemy.Location, Pawn.Location,, true))
    {
        DistToTargetSq = VSizeSq(Enemy.Location - Pawn.Location);
        PossibleMoves = GetPossibleMovesByRange(DistToTargetSq);
        if(PossibleMoves.Length > 0)
        {
            if(!bRandomMoves)
            {
                ChosenMove = PossibleMoves[0];                
            }
            else
            {
                ChosenMove = PossibleMoves[Rand(PossibleMoves.Length)];
            }
            switch(ChosenMove)
            {
                case 1:
                    Class'AICommand_Matriarch_LightningStorm'.static.LightningStorm(self);
                    break;
                case 2:
                    Class'AICommand_Matriarch_WarningSiren'.static.WarningSiren(self);
                    break;
                case 3:
                    Class'AICommand_Matriarch_TeslaBlast'.static.TeslaBlast(self);
                    break;
                case 4:
                    Class'AICommand_MatriarchPlasmaCannon'.static.PlasmaCannonAttack(self);
                    break;
                case 5:
                    Class'AICommand_Matriarch_ScorpionWhip'.static.ScorpionWhip(self);
                    break;
                default:
                    break;
            }
            GlobalCooldownTimer = 1000000;            
        }
        else
        {
            GlobalCooldownTimer = 0.5;
        }        
    }
    else
    {
        GlobalCooldownTimer = 0.5;
    }
}

function array<KFAIController_ZedMatriarch.EMatriarchAttacksByRange> GetPossibleMovesByRange(float DistToTargetSq)
{
    local array<KFAIController_ZedMatriarch.EMatriarchAttacksByRange> PossibleMoves;

    if(CanUseLightningStorm(DistToTargetSq))
    {
        PossibleMoves.AddItem(1;
    }
    if(CanUseWarningSiren(DistToTargetSq))
    {
        PossibleMoves.AddItem(2;
    }
    if(CanUseTeslaBlast(DistToTargetSq))
    {
        PossibleMoves.AddItem(3;
    }
    if(CanUsePlasmaCannon(DistToTargetSq))
    {
        PossibleMoves.AddItem(4;
    }
    if(CanUseScorpionWhip(DistToTargetSq))
    {
        PossibleMoves.AddItem(5;
    }
    return PossibleMoves;
}

function bool CanUseTeslaBlast(float DistToTargetSq)
{
    if(!MyMatPawn.CanUseTeslaBlast())
    {
        return false;
    }
    if(DistToTargetSq > Square(Class'KFSM_Matriarch_TeslaBlast'.default.MaxVictimDistance))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastTeslaBlastTime) < TeslaBlastCooldown)
    {
        return false;
    }
    return true;
}

function bool CanUsePlasmaCannon(float DistToTargetSq)
{
    if(!MyMatPawn.CanUsePlasmaCannon())
    {
        return false;
    }
    if(DistToTargetSq > Square(Class'KFSM_Matriarch_PlasmaCannon'.default.MaxVictimDistance))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastPlasmaCannonTime) < PlasmaCannonCooldown)
    {
        return false;
    }
    return true;
}

function bool CanUseLightningStorm(float DistToTargetSq)
{
    if(!MyMatPawn.CanUseLightningStorm())
    {
        return false;
    }
    if(DistToTargetSq > Square(Class'KFSM_Matriarch_LightningStorm'.default.MaxVictimDistance))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastLightningStormTime) < LightningStormCooldown)
    {
        return false;
    }
    return true;
}

function bool CanUseWarningSiren(float DistToTargetSq)
{
    if(!MyMatPawn.CanUseWarningSiren())
    {
        return false;
    }
    if(DistToTargetSq > Square(Class'KFSM_Matriarch_WarningSiren'.default.MaxVictimDistance))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastWarningSirenTime) < WarningSirenCooldown)
    {
        return false;
    }
    return true;
}

function bool CanUseScorpionWhip(float DistToTargetSq)
{
    if(!MyMatPawn.CanUseScorpionWhip())
    {
        return false;
    }
    if(DistToTargetSq > Square(Class'KFSM_Matriarch_ScorpionWhip'.default.MaxRange))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastScorpionWhipTime) < ScorpionWhipCooldown)
    {
        return false;
    }
    return true;
}

function NotifySpecialMoveStarted(KFSpecialMove SM)
{
    super(KFAIController).NotifySpecialMoveStarted(SM);
    if(MyMatPawn.Role == ROLE_Authority)
    {
        MyMatPawn.SetShieldUp(false);
        MyMatPawn.SetCloaked(false);
    }
}

function NotifySpecialMoveEnded(KFSpecialMove SM)
{
    super(KFAIController).NotifySpecialMoveEnded(SM);
    switch(SM.Handle)
    {
        case 'KFSM_MeleeAttack':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_Melee.X, GlobalCooldownTimeRange_Melee.Y);
            break;
        case 'KFSM_Matriarch_TeslaBlast':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_TeslaBlast.X, GlobalCooldownTimeRange_TeslaBlast.Y);
            break;
        case 'KFSM_Matriarch_PlasmaCannon':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_PlasmaCannon.X, GlobalCooldownTimeRange_PlasmaCannon.Y);
            break;
        case 'KFSM_Matriarch_LightningStorm':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_LightningStorm.X, GlobalCooldownTimeRange_LightningStorm.Y);
            break;
        case 'KFSM_Matriarch_WarningSiren':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_WarningSiren.X, GlobalCooldownTimeRange_WarningSiren.Y);
            break;
        case 'KFSM_Matriarch_ScorpionWhip':
            GlobalCooldownTimer = RandRange(GlobalCooldownTimeRange_ScorpionWhip.X, GlobalCooldownTimeRange_ScorpionWhip.Y);
            break;
        default:
            GlobalCooldownTimer = 0.5;
            break;
            break;
    }
    EvaluateSprinting();
    if(SM.Handle == 'KFSM_Zed_Boss_Theatrics')
    {
        MyMatPawn.ActivateShield();        
    }
    else
    {
        MyMatPawn.SetShieldUp(true);
        MyMatPawn.SetCloaked(true);
    }
    if((CurrentTargetPawn != none) && Enemy != CurrentTargetPawn)
    {
        ChangeEnemy(CurrentTargetPawn, false);
    }
}

function EvaluateSprinting()
{
    if(ShouldSprint())
    {
        MyKFPawn.SetSprinting(true);        
    }
    else
    {
        MyKFPawn.SetSprinting(false);
    }
}

function bool ShouldSprint()
{
    local float DistToEnemy;

    if((((MyKFPawn != none) && MyKFPawn.IsAliveAndWell()) && Enemy != none) && Enemy.IsAliveAndWell())
    {
        DistToEnemy = VSize(Enemy.Location - Pawn.Location);
        if((DistToEnemy > SprintWithinEnemyRange.X) && DistToEnemy < SprintWithinEnemyRange.Y)
        {
            return true;            
        }
        else
        {
            if(!FastTrace(Enemy.Location, Pawn.Location,, true))
            {
                return true;
            }
        }
    }
    return false;
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum)
{
    super(KFAIController).NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
    if(Damage > 0)
    {
        if(PlayerDamages.Length <= InstigatedBy.PlayerNum)
        {
            PlayerDamages[InstigatedBy.PlayerNum] = Damage;            
        }
        else
        {
            PlayerDamages[InstigatedBy.PlayerNum] += Damage;
        }
        if(bLogTargeting)
        {
            LogInternal(((((((string(self) $ "::NotifyTakeHit - player ") $ string(InstigatedBy.PlayerNum)) $ " add ") $ string(Damage)) $ " damage (") $ string(PlayerDamages[InstigatedBy.PlayerNum])) $ ")");
        }
    }
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    if(GetIsInZedVictoryState())
    {
        return;
    }
    if((self == Killer) && Killed.GetTeamNum() != GetTeamNum())
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayMattyKilledDialog(MyKFPawn);
        }        
    }
    else
    {
        if(Killed.GetTeamNum() == GetTeamNum())
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayMattyMinionKilledDialog(MyKFPawn);
            }
        }
    }
    super(KFAIController).NotifyKilled(Killer, Killed, KilledPawn, DamageType);
}

function EnterZedVictoryState()
{
    super.EnterZedVictoryState();
    bCanEvaluateAttacks = false;
    KFWeapon(MyMatPawn.Weapon).GotoState('Inactive');
}

function bool AmIAllowedToSuicideWhenStuck()
{
    return false;
}

function bool DoHeavyZedBump(Actor Other, Vector HitNormal)
{
    local int BumpEffectDamage;
    local KFPawn_Monster BumpedMonster;

    if(Other.bCanBeDamaged && KFFracturedMeshGlass(Other) != none)
    {
        KFFracturedMeshGlass(Other).BreakOffAllFragments();
        return true;
    }
    BumpedMonster = KFPawn_Monster(Other);
    if(((BumpedMonster == none) || !BumpedMonster.IsAliveAndWell()) || BumpedMonster.ZedBumpDamageScale <= float(0))
    {
        return false;
    }
    if((MyKFPawn == none) || !MyKFPawn.IsAliveAndWell())
    {
        return false;
    }
    BumpEffectDamage = int((float(ZedBumpEffectThreshold) * BumpedMonster.ZedBumpDamageScale) * float(((MyKFPawn.bIsSprinting) ? 2 : 1)));
    if((BumpedMonster.Health - BumpEffectDamage) <= 0)
    {
        BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());
        BumpedMonster.Knockdown(,, vect(1, 1, 1), Pawn.Location, 1000, 100);
        return true;        
    }
    else
    {
        BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());
        BumpedMonster.DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(BumpedMonster, HitNormal));
        return true;
    }
    return false;
}

event bool NotifyBump(Actor Other, Vector HitNormal)
{
    local KFPawn_Human BumpedHuman;

    BumpedHuman = KFPawn_Human(Other);
    if(((((BumpedHuman != none) && BumpedHuman != CurrentTargetPawn) && !MyMatPawn.IsDoingSpecialMove()) && !IsZero(MyMatPawn.Velocity)) && (HitNormal Dot vector(Rotation)) < -0.7)
    {
        AbortCommand(CommandList);
        ChangeEnemy(BumpedHuman, false);
        EnableMeleeRangeEventProbing();
        BeginCombatCommand(GetDefaultCommand(), "Restarting default command");
        return true;
    }
    return super(KFAIController).NotifyBump(Other, HitNormal);
}

defaultproperties
{
    GlobalCooldownTimeRange_LightningStorm=(X=2.5,Y=2.5)
    GlobalCooldownTimeRange_WarningSiren=(X=2.5,Y=2.5)
    GlobalCooldownTimeRange_TeslaBlast=(X=2.5,Y=2.5)
    GlobalCooldownTimeRange_PlasmaCannon=(X=2.5,Y=2.5)
    ReevaluateEnemiesTimeRange=(X=8,Y=10)
    TeslaBlastCooldown=5
    PlasmaCannonCooldown=7
    LightningStormCooldown=8
    WarningSirenCooldown=10
    ScorpionWhipCooldown=12
    bCanDoHeavyBump=true
    DefaultCommandClass=Class'AICommand_Base_Matriarch'
    MeleeCommandClass=Class'AICommand_Base_Matriarch'
    SprintWithinEnemyRange=(X=1500,Y=1E+09)
}