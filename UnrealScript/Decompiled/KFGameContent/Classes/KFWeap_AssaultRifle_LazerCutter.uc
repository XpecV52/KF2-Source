/*******************************************************************************
 * KFWeap_AssaultRifle_LazerCutter generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_AssaultRifle_LazerCutter extends KFWeap_FlameBase
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

var float ChargeTimePerLevel;
var float OverchargeConsumeTime;
var float ChargeConsumeTime;
var float TotalChargeTime;
var float CurrentChargeTime;
var float FlashInterval;
var float DamageTime;
var float FiringTime;
var float FlashTime;
var float ChargingRotationSpeedLimit;
var float ChargingMovementSpeedModifier;
var array<float> FiringRotationSpeedLimit;
var float FiringMovementSpeedModifier;
var float BaseScale;
var float ScalePerChargeLevel;
var float DamagePerChargeLevel;
var float BaseDuration;
var float DurationPerChargeLevel;
var int MaxChargeLevel;
/** Charge in animation */
var(Animations) const editconst name AltFireLoopStartAnim;
/** Charge animations per level */
var(Animations) const editconst name AltFireBeamInAnimL1;
var(Animations) const editconst name AltFireBeamInAnimL2;
var(Animations) const editconst name AltFireBeamInAnimL3;
/** Animations to loop if stuck at a charge level */
var(Animations) const editconst name AltFireLoopAnimL1;
var(Animations) const editconst name AltFireLoopAnimL2;
var(Animations) const editconst name AltFireLoopAnimL3;
/** Firing animations per level */
var(Animations) const editconst name CustomFireLoopAnimL1;
var(Animations) const editconst name CustomFireLoopAnimL2;
var(Animations) const editconst name CustomFireLoopAnimL3;
/** Firing end animations */
var(Animations) const editconst name CustomFireLoopEndLastAnim;
var(Animations) const editconst name CustomFireLoopEndAnim;
var const ParticleSystem MuzzleFlashEffectL1;
var const ParticleSystem MuzzleFlashEffectL2;
var const ParticleSystem MuzzleFlashEffectL3;
var array<AkEvent> FireLoopSounds;
var AkEvent FireLoopStop;
var array<AkEvent> ChargeSounds;
var AkEvent InterruptSoundEvent;
var WeaponFireSndInfo SingleShotFireSnd;
var LinearColor DefaultFireModeColor;
var LinearColor EnergyColorL0;
var LinearColor EnergyColorL1;
var LinearColor EnergyColorL2;
var LinearColor EnergyColorL3;
var export editinline transient ParticleSystemComponent ChargingPSC;
var const ParticleSystem ChargingEffect;
var float MaxRotationAdjustmentTime;
var InterpCurveFloat RotationAdjustmentCurve;
var bool bPlayMuzzleFlash;

simulated function SetWeapon()
{
    super(KFWeapon).SetWeapon();
    SetBeamColor(0);
}

simulated function StartFire(byte FireModeNum)
{
    if(IsTimerActive('RefireCheckTimer'))
    {
        return;
    }
    super(KFWeapon).StartFire(FireModeNum);
}

simulated function OnStartFire()
{
    local KFPawn PawnInst;

    PawnInst = KFPawn(Instigator);
    if(PawnInst != none)
    {
        PawnInst.OnStartFire();
    }
}

simulated function CustomFire()
{
    if(CurrentFireMode == 6)
    {
        IncrementFlashCount();
    }
    super.CustomFire();
}

simulated function AltFireMode()
{
    super(KFWeapon).AltFireMode();
    SetBeamColor(GetChargeLevel());
}

simulated function int GetChargeLevel()
{
    return Min(int(TotalChargeTime / ChargeTimePerLevel), MaxChargeLevel);
}

simulated function FireAmmunition()
{
    if(CurrentFireMode == 1)
    {
        SendToFiringState(6);
        return;
    }
    HandleWeaponShotTaken(CurrentFireMode);
    switch(WeaponFireTypes[CurrentFireMode])
    {
        case 0:
            if((self.WorldInfo.TimeDilation < 1) && WeaponProjectiles[CurrentFireMode] != none)
            {
                ProjectileFire();                
            }
            else
            {
                InstantFireClient();
            }
            break;
        case 1:
            ProjectileFire();
            break;
        case 2:
            CustomFire();
            break;
        default:
            break;
    }
    if((CurrentFireMode == 0) || (GetChargeLevel()) < 1)
    {
        ConsumeAmmo(CurrentFireMode);
    }
    NotifyWeaponFired(CurrentFireMode);
    PlayFireEffects(CurrentFireMode, vect(0, 0, 0));
}

simulated function name GetLoopStartFireAnim(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        return AltFireLoopStartAnim;        
    }
    else
    {
        if(FireModeNum == 6)
        {
            return 'None';
        }
    }
    return super(KFWeapon).GetLoopStartFireAnim(FireModeNum);
}

simulated function name GetLoopEndFireAnim(byte FireModeNum)
{
    local bool bPlayFireLast;

    if(FireModeNum == 1)
    {
        return 'None';        
    }
    else
    {
        if(FireModeNum == 6)
        {
            bPlayFireLast = ShouldPlayFireLast(FireModeNum);
            if(bPlayFireLast && CustomFireLoopEndLastAnim != 'None')
            {
                return CustomFireLoopEndLastAnim;                
            }
            else
            {
                return CustomFireLoopEndAnim;
            }
        }
    }
    return super(KFWeapon).GetLoopEndFireAnim(FireModeNum);
}

simulated function name GetLoopingFireAnim(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        return AltFireLoopStartAnim;        
    }
    else
    {
        if(FireModeNum == 6)
        {
            switch(GetChargeLevel())
            {
                case 3:
                    return CustomFireLoopAnimL3;
                case 2:
                    return CustomFireLoopAnimL2;
                case 1:
                case 0:
                    return CustomFireLoopAnimL1;
                default:
                    break;
                }
        }
        else
        {
        }
        return super(KFWeapon).GetLoopingFireAnim(FireModeNum);
    }
}

simulated function CauseMuzzleFlash(byte FireModeNum)
{
    if(MuzzleFlash == none)
    {
        AttachMuzzleFlash();
    }
    if(MuzzleFlash != none)
    {
        if(FireModeNum == 6)
        {
            if(bPlayMuzzleFlash)
            {
                switch(GetChargeLevel())
                {
                    case 0:
                    case 1:
                        MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL1;
                        MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL1);
                        break;
                    case 2:
                        MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL2;
                        MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL2);
                        break;
                    case 3:
                        MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashEffectL3;
                        MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashEffectL3);
                        break;
                    default:
                        break;
                }
                bPlayMuzzleFlash = false;
                MuzzleFlash.MuzzleFlash.Duration = 0;
                super(KFWeapon).CauseMuzzleFlash(FireModeNum);
            }            
        }
        else
        {
            MuzzleFlash.MuzzleFlash.ParticleSystemTemplate = MuzzleFlashTemplate.MuzzleFlash.ParticleSystemTemplate;
            MuzzleFlash.MuzzleFlash.PSC.SetTemplate(MuzzleFlashTemplate.MuzzleFlash.ParticleSystemTemplate);
            MuzzleFlash.MuzzleFlash.Duration = MuzzleFlashTemplate.MuzzleFlash.Duration;
            super(KFWeapon).CauseMuzzleFlash(FireModeNum);
        }
    }
}

simulated function SetBeamColor(int ChargeLevel)
{
    local LinearColor BeamColor;
    local int I;

    if(bUseAltFireMode)
    {
        switch(ChargeLevel)
        {
            case 3:
                BeamColor = EnergyColorL3;
                break;
            case 2:
                BeamColor = EnergyColorL2;
                break;
            case 1:
                BeamColor = EnergyColorL1;
                break;
            default:
                BeamColor = EnergyColorL0;
                break;
                break;
        }        
    }
    else
    {
        BeamColor = DefaultFireModeColor;
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        I = 0;
        J0xD3:

        if(I < WeaponMICs.Length)
        {
            if(WeaponMICs[I] != none)
            {
                WeaponMICs[I].SetVectorParameterValue('Energy_Color', BeamColor);
            }
            ++ I;
            goto J0xD3;
        }
    }
}

simulated function bool ShouldForceSingleFireSound()
{
    return self.WorldInfo.TimeDilation < 1;
}

simulated function PlayFiringSound(byte FireModeNum)
{
    local bool bUseSingleFireSound;

    MakeNoise(1, 'PlayerFiring');
    if(!bPlayingLoopingFireSnd)
    {
        if(((FireModeNum < bLoopingFireSnd.Length) && bLoopingFireSnd[FireModeNum]) && ShouldForceSingleFireSound())
        {
            bUseSingleFireSound = true;
        }
        if(bUseSingleFireSound)
        {
            WeaponPlayFireSound(SingleShotFireSnd.DefaultCue, SingleShotFireSnd.FirstPersonCue);            
        }
        else
        {
            if(FireModeNum < WeaponFireSnd.Length)
            {
                WeaponPlayFireSound(WeaponFireSnd[FireModeNum].DefaultCue, WeaponFireSnd[FireModeNum].FirstPersonCue);
            }
        }
    }
}

simulated state LazerCharge extends WeaponFiring
{
    ignores FireAmmunition, AltFireMode, AltFireModeRelease;

    simulated function bool AllowIronSights()
    {
        return false;
    }

    simulated event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
    {
        local name WeaponFireAnimName;

        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(AmmoCount[0] == 0)
            {
                switch(GetChargeLevel())
                {
                    case 3:
                    case 2:
                        WeaponFireAnimName = AltFireLoopAnimL3;
                        break;
                    case 1:
                        WeaponFireAnimName = AltFireLoopAnimL2;
                        break;
                    case 0:
                        WeaponFireAnimName = AltFireLoopAnimL1;
                        break;
                    default:
                        break;
                }                
            }
            else
            {
                switch(GetChargeLevel())
                {
                    case 3:
                        WeaponFireAnimName = AltFireLoopAnimL3;
                        break;
                    case 2:
                        WeaponFireAnimName = AltFireBeamInAnimL2;
                        break;
                    case 1:
                        WeaponFireAnimName = AltFireBeamInAnimL1;
                        break;
                    default:
                        break;
                }
            }
            if((WeaponFireAnimName != 'None') && WeaponAnimSeqNode.AnimSeq.SequenceName != WeaponFireAnimName)
            {
                PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName), AmmoCount[0] == 0, FireTweenTime);
            }
        }
    }

    simulated event BeginState(name PreviousStateName)
    {
        local int ChargeLevel;
        local KFPawn_Human OwnerHuman;
        local KFPlayerController OwnerController;

        OwnerHuman = KFPawn_Human(Instigator);
        super.BeginState(PreviousStateName);
        TotalChargeTime = 0;
        CurrentChargeTime = 0;
        DamageTime = 0;
        FiringTime = 0;
        FlashTime = 0;
        MovementSpeedMod = ChargingMovementSpeedModifier;
        if(OwnerHuman != none)
        {
            OwnerController = KFPlayerController(OwnerHuman.Controller);
            if(OwnerController != none)
            {
                OwnerController.RotationSpeedLimit = ChargingRotationSpeedLimit;
            }
            OwnerHuman.UpdateGroundSpeed();
        }
        if(bUsingSights)
        {
            SetIronSights(false);
        }
        ChargeLevel = GetChargeLevel();
        if((ChargeLevel >= 0) && ChargeLevel < ChargeSounds.Length)
        {
            KFPawn(Instigator).PlayWeaponSoundEvent(ChargeSounds[ChargeLevel]);
        }
        if(ChargingPSC == none)
        {
            ChargingPSC = new (self) Class'ParticleSystemComponent';
            if(MySkelMesh != none)
            {
                MySkelMesh.AttachComponentToSocket(ChargingPSC, 'MuzzleFlash');                
            }
            else
            {
                AttachComponent(ChargingPSC);
            }            
        }
        else
        {
            ChargingPSC.ActivateSystem();
        }
        if(ChargingPSC != none)
        {
            ChargingPSC.SetTemplate(ChargingEffect);
        }
        global.OnStartFire();
    }

    simulated function bool ShouldRefire()
    {
        return StillFiring(CurrentFireMode);
    }

    simulated event Tick(float DeltaTime)
    {
        local float ConsumeTime, ChargeRTPC;
        local name WeaponFireAnimName;
        local int StartChargeLevel, EndChargeLevel;

        global.Tick(DeltaTime);
        StartChargeLevel = GetChargeLevel();
        FlashTime += DeltaTime;
        ConsumeTime = (((GetChargeLevel()) >= MaxChargeLevel) ? OverchargeConsumeTime : ChargeConsumeTime);
        if(PendingFire(CurrentFireMode) && AmmoCount[0] > 0)
        {
            TotalChargeTime += DeltaTime;
            CurrentChargeTime += DeltaTime;
        }
        if(ConsumeTime > float(0))
        {
            J0xDA:

            if(CurrentChargeTime >= ConsumeTime)
            {
                CurrentChargeTime -= ConsumeTime;
                ConsumeAmmo(1);
                goto J0xDA;
            }
        }
        J0x114:

        if(FlashTime >= FlashInterval)
        {
            FlashTime -= FlashInterval;
            IncrementFlashCount();
            goto J0x114;
        }
        EndChargeLevel = GetChargeLevel();
        if(EndChargeLevel != StartChargeLevel)
        {
            if((EndChargeLevel >= 0) && EndChargeLevel < ChargeSounds.Length)
            {
                KFPawn(Instigator).PlayWeaponSoundEvent(ChargeSounds[EndChargeLevel]);
            }
            if(bPlayingLoopingFireAnim)
            {
                switch(GetChargeLevel())
                {
                    case 3:
                        WeaponFireAnimName = AltFireLoopAnimL3;
                        break;
                    case 2:
                        WeaponFireAnimName = AltFireBeamInAnimL2;
                        break;
                    case 1:
                        WeaponFireAnimName = AltFireBeamInAnimL1;
                        break;
                    default:
                        break;
                }
                if((WeaponFireAnimName != 'None') && WeaponAnimSeqNode.AnimSeq.SequenceName != WeaponFireAnimName)
                {
                    PlayAnimation(WeaponFireAnimName, MySkelMesh.GetAnimLength(WeaponFireAnimName), (GetChargeLevel()) == 3, FireTweenTime);
                }
            }
        }
        SetBeamColor(GetChargeLevel());
        ChargeRTPC = FMin(TotalChargeTime / (float(MaxChargeLevel) * ChargeTimePerLevel), 1);
        KFPawn(Instigator).SetWeaponComponentRTPCValue("Weapon_Charge", ChargeRTPC);
        Instigator.SetRTPCValue('Weapon_Charge', ChargeRTPC);
    }

    simulated event EndState(name NextStateName)
    {
        local KFPawn_Human OwnerHuman;
        local KFPlayerController OwnerController;

        OwnerHuman = KFPawn_Human(Instigator);
        MovementSpeedMod = 1;
        if(OwnerHuman != none)
        {
            OwnerController = KFPlayerController(OwnerHuman.Controller);
            if(OwnerController != none)
            {
                OwnerController.RotationSpeedLimit = -1;
            }
            OwnerHuman.UpdateGroundSpeed();
        }
        ClearZedTimeResist();
        ClearPendingFire(CurrentFireMode);
        ClearTimer('RefireCheckTimer');
        NotifyWeaponFinishedFiring(CurrentFireMode);
        KFPawn(Instigator).bHasStartedFire = false;
        KFPawn(Instigator).bNetDirty = true;
        if(NextStateName == 'Inactive')
        {
            KFPawn(Instigator).PlayWeaponSoundEvent(InterruptSoundEvent);
            WeaponAnimSeqNode.StopAnim();            
        }
        else
        {
            global.FireAmmunition();
        }
    }
    stop;    
}

simulated state SprayingFireLazer extends SprayingFire
{
    ignores AltFireMode, AltFireModeRelease;

    simulated function bool AllowIronSights()
    {
        return false;
    }

    simulated function BeginState(name PreviousStateName)
    {
        local KFPawn_Human OwnerHuman;
        local KFPlayerController OwnerController;
        local float ChargeLevel;

        OwnerHuman = KFPawn_Human(Instigator);
        ChargeLevel = float(GetChargeLevel());
        bPlayMuzzleFlash = true;
        FlashTime = 0;
        if((ChargeLevel >= float(0)) && ChargeLevel < float(FireLoopSounds.Length))
        {
            KFPawn(Instigator).PlayWeaponSoundEvent(FireLoopSounds[int(ChargeLevel)]);
        }
        MovementSpeedMod = FiringMovementSpeedModifier;
        if(OwnerHuman != none)
        {
            OwnerController = KFPlayerController(OwnerHuman.Controller);
            if(OwnerController != none)
            {
                if((ChargeLevel >= float(0)) && ChargeLevel < float(FiringRotationSpeedLimit.Length))
                {
                    OwnerController.RotationSpeedLimit = FiringRotationSpeedLimit[int(ChargeLevel)];
                }
            }
            OwnerHuman.UpdateGroundSpeed();
        }
        FiringTime = BaseDuration + (ChargeLevel * DurationPerChargeLevel);
        if(bUsingSights)
        {
            SetIronSights(false);
        }
        if(ChargingPSC != none)
        {
            ChargingPSC.DeactivateSystem();
        }
        super.BeginState(PreviousStateName);
    }

    simulated function DebugRenderBones()
    {
        local Vector BoneLoc;
        local string BoneString;
        local int X, Y;
        local Vector BoxExtent;

        X = 0;
        J0x0B:

        if(X < 2)
        {
            Y = 1;
            J0x26:

            if(Y <= 15)
            {
                BoxExtent.X = BaseScale + (ScalePerChargeLevel * float((GetChargeLevel()) - 1));
                BoxExtent.Y = BaseScale + (ScalePerChargeLevel * float((GetChargeLevel()) - 1));
                BoxExtent.Z = 1;
                BoneString = "Bone";
                if(Y < 10)
                {                    
                    BoneString $= "0";
                }                
                BoneString $= string(Y);
                BoneLoc = FlamePool[X].SkeletalSprayMesh.GetBoneLocation(name(BoneString));
                DrawDebugBox(BoneLoc, BoxExtent, 255, 255, 0, true);
                ++ Y;
                goto J0x26;
            }
            ++ X;
            goto J0x0B;
        }
    }

    simulated function DamageActorsCheck()
    {
        local KFPawn HitPawn;
        local Vector BeamExtent, SmallBeamExtent;
        local int FlamePoolCounter, BoneCounter;
        local string BoneString;
        local Vector BoneLoc, PrevBoneLoc;
        local KFPawn OwnerPawn;
        local int CurrentCollisions;
        local array<KFPawn> AlreadyHitActors;
        local array<Actor> HitDamageActors, HitBeamActors;
        local array<Vector> DamageHitLocations, BeamHitLocations;
        local Vector HitLocation;
        local int I;

        BeamExtent.X = BaseScale + (ScalePerChargeLevel * float((GetChargeLevel()) - 1));
        BeamExtent.Y = BaseScale + (ScalePerChargeLevel * float((GetChargeLevel()) - 1));
        BeamExtent.Z = 1;
        SmallBeamExtent.X = 8;
        SmallBeamExtent.Y = 8;
        SmallBeamExtent.Z = 8;
        CurrentCollisions = 0;
        OwnerPawn = KFPawn(Owner);
        FlamePoolCounter = 0;
        J0x13E:

        if(FlamePoolCounter < 2)
        {
            BoneCounter = 1;
            J0x159:

            if(BoneCounter < 15)
            {
                BoneString = "Bone";
                if(BoneCounter < 10)
                {                    
                    BoneString $= "0";
                }                
                BoneString $= string(BoneCounter);
                BoneLoc = FlamePool[FlamePoolCounter].SkeletalSprayMesh.GetBoneLocation(name(BoneString));
                if(BoneCounter != 1)
                {
                    if(CurrentCollisions < FlamePool[FlamePoolCounter].MaxSprayMeshesCollided)
                    {
                        HitDamageActors = BeamLineCheck(PrevBoneLoc, BoneLoc, BeamExtent, DamageHitLocations);
                        HitBeamActors = BeamLineCheck(PrevBoneLoc, BoneLoc, SmallBeamExtent, BeamHitLocations);
                        I = 0;
                        J0x2D5:

                        if(I < HitDamageActors.Length)
                        {
                            if(CurrentCollisions < FlamePool[FlamePoolCounter].MaxSprayMeshesCollided)
                            {
                                HitPawn = KFPawn(HitDamageActors[I]);
                                if(((((HitPawn != none) && HitPawn.Base != Owner) && HitPawn != Owner) && HitPawn.bBlockActors) && AlreadyHitActors.Find(HitPawn == -1)
                                {
                                    ++ CurrentCollisions;
                                    AlreadyHitActors.AddItem(HitPawn;
                                    HitLocation = vect(0, 0, 0);
                                    if(DamageHitLocations.Length > I)
                                    {
                                        HitLocation = DamageHitLocations[I];
                                    }
                                    HitPawn.TakeDamage(int(InstantHitDamage[1] + (float(GetChargeLevel()) * DamagePerChargeLevel)), OwnerPawn.Controller, HitLocation, vect(0, 0, 0), InstantHitDamageTypes[1]);                                    
                                }
                                else
                                {
                                    if((((((HitDamageActors[I] != none) && HitDamageActors[I].Base != Owner) && HitDamageActors[I] != Owner) && HitDamageActors[I].bBlockActors) && HitDamageActors[I].bWorldGeometry) && HitBeamActors.Find(HitDamageActors[I] != -1)
                                    {
                                        CurrentCollisions = FlamePool[FlamePoolCounter].MaxSprayMeshesCollided;
                                    }
                                }
                            }
                            ++ I;
                            goto J0x2D5;
                        }
                    }
                }
                PrevBoneLoc = BoneLoc;
                ++ BoneCounter;
                goto J0x159;
            }
            ++ FlamePoolCounter;
            goto J0x13E;
        }
    }

    simulated event Tick(float DeltaTime)
    {
        global.Tick(DeltaTime);
        if(FiringTime > 0)
        {
            FiringTime -= DeltaTime;
            DamageTime += DeltaTime;
            FlashTime += DeltaTime;
            J0x62:

            if(DamageTime >= FireInterval[1])
            {
                DamageTime -= FireInterval[1];
                DamageActorsCheck();
                goto J0x62;
            }
            J0x9E:

            if(FlashTime >= FlashInterval)
            {
                FlashTime -= FlashInterval;
                IncrementFlashCount();
                goto J0x9E;
            }            
        }
        else
        {
            GotoState('Active');
        }
    }

    simulated function EndState(name NextStateName)
    {
        local int FlamePoolCounter;
        local KFPawn_Human OwnerHuman;
        local KFPlayerController OwnerController;

        OwnerHuman = KFPawn_Human(Instigator);
        MovementSpeedMod = 1;
        if(OwnerHuman != none)
        {
            OwnerController = KFPlayerController(OwnerHuman.Controller);
            if(OwnerController != none)
            {
                if(RotationAdjustmentCurve.Points.Length > 0)
                {
                    RotationAdjustmentCurve.Points[0].OutVal = OwnerController.RotationSpeedLimit;
                }
                OwnerController.StartRotationAdjustment(RotationAdjustmentCurve, MaxRotationAdjustmentTime);
            }
            OwnerHuman.UpdateGroundSpeed();
        }
        FlamePoolCounter = 0;
        J0x148:

        if(FlamePoolCounter < 2)
        {
            FlamePool[FlamePoolCounter].SkeletalSprayMesh.SetScale(1);
            ++ FlamePoolCounter;
            goto J0x148;
        }
        if(MuzzleFlash.MuzzleFlash.PSC != none)
        {
            MuzzleFlash.MuzzleFlash.PSC.DeactivateSystem();
        }
        SetBeamColor(0);
        TotalChargeTime = 0;
        CurrentChargeTime = 0;
        DamageTime = 0;
        FiringTime = 0;
        FlashTime = 0;
        ClearFlashLocation();
        ClearTimer('RefireCheckTimer');
        ClearPendingFire(0);
        super.EndState(NextStateName);
        KFPawn(Instigator).PlayWeaponSoundEvent(FireLoopStop);
    }

    simulated function bool ShouldRefire()
    {
        return FiringTime > 0;
    }

    simulated function bool IsFiring()
    {
        return FiringTime > 0;
    }

    simulated function bool TryPutDown()
    {
        return false;
    }
    stop;    
}

defaultproperties
{
    ChargeTimePerLevel=1
    ChargeConsumeTime=0.12
    FlashInterval=0.15
    ChargingMovementSpeedModifier=1
    FiringRotationSpeedLimit(0)=420
    FiringRotationSpeedLimit(1)=240
    FiringRotationSpeedLimit(2)=180
    FiringRotationSpeedLimit(3)=120
    FiringMovementSpeedModifier=0.5
    BaseScale=40
    ScalePerChargeLevel=10
    DamagePerChargeLevel=5
    BaseDuration=0.25
    DurationPerChargeLevel=0.75
    MaxChargeLevel=3
    AltFireLoopStartAnim=Beam_Charge_In_lvl1
    AltFireBeamInAnimL1=Beam_Charge_In_lvl2
    AltFireBeamInAnimL2=Beam_Charge_In_lvl3
    AltFireLoopAnimL1=Beam_Charge_Loop_lvl1
    AltFireLoopAnimL2=Beam_Charge_Loop_lvl2
    AltFireLoopAnimL3=Beam_Charge_Loop_lvl3
    CustomFireLoopAnimL1=Beam_Shoot_Loop_lvl1
    CustomFireLoopAnimL2=Beam_Shoot_Loop_lvl2
    CustomFireLoopAnimL3=Beam_Shoot_Loop_lvl3
    CustomFireLoopEndLastAnim=Beam_Shoot_End_Last
    CustomFireLoopEndAnim=Beam_Shoot_End
    MuzzleFlashEffectL1=ParticleSystem'WEP_Laser_Cutter_EMIT.FX_Laser_Cutter_Beam_Muzzleflash_01'
    MuzzleFlashEffectL2=ParticleSystem'WEP_Laser_Cutter_EMIT.FX_Laser_Cutter_Beam_Muzzleflash_02'
    MuzzleFlashEffectL3=ParticleSystem'WEP_Laser_Cutter_EMIT.FX_Laser_Cutter_Beam_Muzzleflash_03'
    FireLoopSounds(0)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Beam_Shoot_LP_Level_0_1P'
    FireLoopSounds(1)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Beam_Shoot_LP_Level_1_1P'
    FireLoopSounds(2)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Beam_Shoot_LP_Level_2_1P'
    FireLoopSounds(3)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Beam_Shoot_LP_Level_3_1P'
    FireLoopStop=AkEvent'WW_WEP_Lazer_Cutter.Stop_WEP_LazerCutter_Beam_Shoot_LP_1P'
    ChargeSounds(0)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LaserCutter_Beam_Charged_LP_Level_0_1P'
    ChargeSounds(1)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LaserCutter_Beam_Charged_LP_Level_1_1P'
    ChargeSounds(2)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LaserCutter_Beam_Charged_LP_Level_2_1P'
    ChargeSounds(3)=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LaserCutter_Beam_Charged_LP_Level_3_1P'
    InterruptSoundEvent=AkEvent'WW_WEP_Lazer_Cutter.Stop_WEP_LazerCutter_Interrupt_1P'
    SingleShotFireSnd=(DefaultCue=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Single_3P',FirstPersonCue=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Single_1P')
    DefaultFireModeColor=(R=5,G=1,B=20,A=1)
    EnergyColorL0=(R=5,G=1,B=20,A=1)
    EnergyColorL1=(R=20,G=5,B=200,A=1)
    EnergyColorL2=(R=5,G=25,B=200,A=1)
    EnergyColorL3=(R=20,G=50,B=200,A=1)
    ChargingEffect=ParticleSystem'WEP_Laser_Cutter_EMIT.FX_Laser_Cutter_Beam_Charge_00'
    MaxRotationAdjustmentTime=0.25
    RotationAdjustmentCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=120,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Linear)
    FlameSprayArchetype=SprayActor_Flame'WEP_Laser_Cutter_ARCH.WEP_Laser_Cutter_Flame'
    PilotLightPlayEvent=AkEvent'WW_WEP_Lazer_Cutter.Play_WEP_LazerCutter_Idle_LP'
    PilotLightStopEvent=AkEvent'WW_WEP_Lazer_Cutter.Stop_WEP_LazerCutter_Idle_LP'
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_AssaultRifle_LazerCutter.PilotLight0'
    PSC_PilotLight=PilotLight0
    begin object name=FlameEndSpray0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_AssaultRifle_LazerCutter.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    PackageKey="Laser_Cutter"
    FirstPersonMeshName="wep_1p_laser_cutter_mesh.Wep_1stP_Laser_Cutter_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="WEP_3P_Laser_Cutter_Mesh.Wep_3rdP_Laser_Cutter_Pickup"
    AttachmentArchetypeName="WEP_Laser_Cutter_ARCH.Wep_Laser_Cutter_3P"
    MuzzleFlashTemplateName="WEP_Laser_Cutter_ARCH.Wep_Laser_Cutter_MuzzleFlash_1P"
    bHasIronSights=true
    bCanBeReloaded=true
    bReloadFromMagazine=true
    bHasFireLastAnims=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=8
    MagazineCapacity=50
    MeshIronSightFOV=52
    PlayerIronSightFOV=70
    DOF_FG_FocalRadius=85
    DOF_FG_MaxNearBlurSize=2.5
    GroupPriority=50
    WeaponSelectTexture=Texture2D'WEP_UI_Laser_Cutter_TEX.UI_WeaponSelect_Laser_Cutter'
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCapacity=250
    InitialSpareMags=1
    bLoopingFireAnim=/* Array type was not detected. */
    bLoopingFireSnd=/* Array type was not detected. */
    FireSightedAnims=/* Array type was not detected. */
    BonesToLockOnEmpty=/* Array type was not detected. */
    WeaponFireSnd=/* Array type was not detected. */
    WeaponFireLoopEndSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=3,Y=10,Z=-1)
    NumBloodMapMaterials=5
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_AssaultRifle_LazerCutter.MeleeHelper'
    maxRecoilPitch=100
    minRecoilPitch=70
    maxRecoilYaw=100
    minRecoilYaw=-100
    RecoilRate=0.063
    RecoilViewRotationScale=0.25
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=75
    RecoilISMinYawLimit=65460
    RecoilISMaxPitchLimit=375
    RecoilISMinPitchLimit=65460
    HippedRecoilModifier=1.5
    IronSightMeshFOVCompensationScale=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=4.5,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_AssaultRifle_LazerCutter.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="Killerwatt"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_AssaultRifle_LazerCutter.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_AssaultRifle_LazerCutter.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}