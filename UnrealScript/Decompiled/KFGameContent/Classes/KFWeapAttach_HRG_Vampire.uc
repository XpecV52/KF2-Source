/*******************************************************************************
 * KFWeapAttach_HRG_Vampire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeapAttach_HRG_Vampire extends KFWeapAttach_SprayBase
    hidecategories(Navigation,Object,Movement,Attachment,Collision,Physics,Advanced,Debug,Mobile);

var export editinline transient ParticleSystemComponent ChargingPSC;
var export editinline transient ParticleSystemComponent ChargedPSC;
var ParticleSystem ChargingEffect;
var ParticleSystem ChargedEffect;
var ParticleSystem BloodStolenEffect;
var bool bIsCharging;
var bool bIsFullyCharged;
var bool bIsChargeEffectsActive;
var bool bIsBloodParticlesEffectActive;
var bool bIsDisabledSprayVisualAndMesh;
var bool bHasToStopDoingFireAnim;
var bool bHasToStopDoingFireAnimB;
var repnotify float StartFireTime;
var int ChargeLevel;
var float FXScalingFactorByCharge;
var float ChargeRTPC;
var KFPawn_Monster oZedCurrentlyBeingSprayed;
var KFPawn_Monster oZedPreviouslyBeingSprayed;
var KFWeap_HRG_Vampire Weapon;
var KFEmit_DirectionalPath BloodStolenParticles[15];
var int NumBloodStolenParticlesForPool;
var transient float BloodStolenControlTime;
var float RateUpdateDestinationBloodParticles;
var transient float UpdateDestinationBloodParticlesTime;
var class<KFProj_BloodSplash> BloodSplashClass;
/** Blood Particles */
var(BloodParticles) float SpeedBloodParticles;
var(BloodParticles) float SpawnRateBloodParticles;
var(BloodParticles) float SpeedBloodParticles_3P;
var(BloodParticles) float SpawnRateBloodParticles_3P;
var(BloodParticles) float HalfAngleSpawnCone;
var(BloodParticles) float CurveTurnRateUntilDestinationFinal;
var(BloodParticles) float CurveTurnRateUntilDestinationMidPoint;
var(BloodParticles) float LimitDistanceFinalPoint;
var(BloodParticles) float LimitDistanceMidPoint;

simulated function PostBeginPlay()
{
    local int Index;

    super(Actor).PostBeginPlay();
    UpdateDestinationBloodParticlesTime = RateUpdateDestinationBloodParticles;
    Index = NumBloodStolenParticlesForPool - 1;
    J0x33:

    if(Index >= 0)
    {
        BloodStolenParticles[Index] = Spawn(Class'KFEmit_DirectionalPath');
        BloodStolenParticles[Index].DeactivateEmitter();
        BloodStolenParticles[Index].SetTemplate(BloodStolenEffect, true);
        -- Index;
        goto J0x33;
    }
}

simulated function StartFire()
{
    StartFireTime = WorldInfo.TimeSeconds;
    bIsCharging = false;
    bIsFullyCharged = false;
    bIsDisabledSprayVisualAndMesh = false;
    if(ChargingPSC == none)
    {
        ChargingPSC = new (self) Class'ParticleSystemComponent';
        if(WeapMesh != none)
        {
            WeapMesh.AttachComponentToSocket(ChargingPSC, 'MuzzleFlash');            
        }
        else
        {
            AttachComponent(ChargingPSC);
        }
        ChargingPSC.SetTemplate(ChargingEffect);
    }
    if(ChargedPSC == none)
    {
        ChargedPSC = new (self) Class'ParticleSystemComponent';
        if(WeapMesh != none)
        {
            WeapMesh.AttachComponentToSocket(ChargedPSC, 'MuzzleFlash');            
        }
        else
        {
            AttachComponent(ChargedPSC);
        }
        ChargedPSC.SetTemplate(ChargedEffect);
    }
    ChargingPSC.SetActive(false);
    ChargedPSC.SetActive(false);
}

simulated event Tick(float DeltaTime)
{
    local int Index;
    local Vector MuzzleFlashSocketLocation, BloodParticlesMidPointSocketLocation;
    local KFEmit_DirectionalPath EmitterToRemove;
    local Vector VectorParameterParticle, ChargePercentageVector;
    local Rotator DestinationRotation, BloodParticlesMidPointSocketRotation;
    local Vector BloodSplashVelocity;

    if(bIsChargeEffectsActive)
    {
        if(bIsCharging)
        {
            ChargingPSC.SetActive(true, true);
            ChargePercentageVector.X = ChargeRTPC;
            ChargePercentageVector.Y = ChargeRTPC;
            ChargePercentageVector.Z = ChargeRTPC;
            ChargingPSC.SetVectorParameter(name("BlobCharge"), ChargePercentageVector);
        }
        if(bIsFullyCharged)
        {
            ChargedPSC.SetActive(true, true);
            ChargingPSC.SetFloatParameter(name("InflateBlob"), ChargeRTPC);
        }
    }
    if(bIsDisabledSprayVisualAndMesh)
    {
        TurnOffFireSpray();
        ActiveFlameSpray.CleanupEndFire();
    }
    if(bIsBloodParticlesEffectActive)
    {
        if((oZedCurrentlyBeingSprayed != none) && oZedCurrentlyBeingSprayed.IsAliveAndWell())
        {
            CreateBloodParticle(DeltaTime, oZedCurrentlyBeingSprayed);
        }
    }
    UpdateDestinationBloodParticlesTime -= DeltaTime;
    if(UpdateDestinationBloodParticlesTime <= float(0))
    {
        UpdateDestinationBloodParticlesTime = RateUpdateDestinationBloodParticles;
        if(WeapMesh != none)
        {
            GetFlameSocketLocAndRot(MuzzleFlashSocketLocation, DestinationRotation);
            WeapMesh.GetSocketWorldLocationAndRotation('BloodParticlesMidPoint', BloodParticlesMidPointSocketLocation, BloodParticlesMidPointSocketRotation);
        }
        Index = NumBloodStolenParticlesForPool - 1;
        J0x28E:

        if(Index >= 0)
        {
            if(!BloodStolenParticles[Index].IsEnabled || BloodStolenParticles[Index] == none)
            {                
            }
            else
            {
                if(BloodStolenParticles[Index].bReachDestinationFinal)
                {
                    EmitterToRemove = BloodStolenParticles[Index];
                    EmitterToRemove.DeactivateEmitter();                    
                }
                else
                {
                    if(BloodStolenParticles[Index].ParticleSystemComponent != none)
                    {
                        VectorParameterParticle.X = WorldInfo.TimeDilation;
                        VectorParameterParticle.Y = WorldInfo.TimeDilation;
                        VectorParameterParticle.Z = WorldInfo.TimeDilation;
                        BloodStolenParticles[Index].ParticleSystemComponent.SetVectorParameter(name("ZedtimeScale"), VectorParameterParticle);
                    }
                    BloodStolenParticles[Index].UpdateDestination(MuzzleFlashSocketLocation, BloodParticlesMidPointSocketLocation);
                    if(FRand() > 0.47)
                    {
                        BloodSplashVelocity.X = 0;
                        BloodSplashVelocity.Y = RandRange(-100, 100);
                        BloodSplashVelocity.Z = -200;
                        SpawnBloodSplash(BloodSplashClass, BloodStolenParticles[Index].Location, BloodSplashVelocity);
                    }
                }
            }
            -- Index;
            goto J0x28E;
        }
    }
    super.Tick(DeltaTime);
}

simulated function FirstPersonFireEffects(Weapon W, Vector HitLocation)
{
    super(KFWeaponAttachment).FirstPersonFireEffects(W, HitLocation);
}

simulated function bool ThirdPersonFireEffects(Vector HitLocation, KFPawn P, byte ThirdPersonAnimRateByte)
{
    local KFGame.KFPawn.EAnimSlotStance AnimType;
    local bool bResult;

    bIsChargeEffectsActive = true;
    bIsBloodParticlesEffectActive = true;
    SpawnTracer(GetMuzzleLocation(), HitLocation);
    if(!ActorEffectIsRelevant(P, false, MaxFireEffectDistance))
    {
        return false;
    }
    DecodeThirdPersonAnimRate(ThirdPersonAnimRateByte);
    if(!bWeapMeshIsPawnMesh && bHasToStopDoingFireAnim == false)
    {
        PlayWeaponFireAnim();
        bHasToStopDoingFireAnim = true;
    }
    if(P.IsDoingSpecialMove() && P.SpecialMoves[P.SpecialMove].bAllowFireAnims)
    {
        AnimType = 3;        
    }
    else
    {
        AnimType = 0;
    }
    if(!P.IsDoingSpecialMove() || AnimType == 3)
    {
        if(!bHasToStopDoingFireAnimB)
        {
            bHasToStopDoingFireAnimB = true;
            PlayPawnFireAnim(P, AnimType);
        }
        if(!P.IsDoingSpecialMove())
        {
            P.StopBodyAnim(((P.bIsCrouched) ? 4 : 1), 0.1);
        }
        if(__OnWeaponStateChanged__Delegate != none)
        {
            OnWeaponStateChanged(true);
        }
    }
    CauseMuzzleFlash(P.FiringMode);
    if(((P.FiringMode != 1) && P.ActorEffectIsRelevant(P, false, 15000, 2000)) && !bIsDisabledSprayVisualAndMesh)
    {
        TurnOnFireSpray();
        bResult = true;
    }
    return bResult;
}

simulated function StopThirdPersonFireEffects(optional bool bForce)
{
    super.StopThirdPersonFireEffects(bForce);
    bIsChargeEffectsActive = false;
    bIsBloodParticlesEffectActive = false;
    RemoveAllBloodParticles();
    bIsDisabledSprayVisualAndMesh = false;
    if(ChargingPSC != none)
    {
        ChargingPSC.SetActive(false);
    }
    if(ChargedPSC != none)
    {
        ChargedPSC.SetActive(false);
    }
    bHasToStopDoingFireAnim = false;
    bHasToStopDoingFireAnimB = false;
}

simulated function CauseMuzzleFlash(byte FiringMode)
{
    if((MuzzleFlash == none) && MuzzleFlashTemplate != none)
    {
        AttachMuzzleFlash();
    }
    super(KFWeaponAttachment).CauseMuzzleFlash(FiringMode);
}

protected simulated function TurnOnPilot()
{
    super.TurnOnPilot();
    if(((FlamePool[0] != none) && KFSprayActor_HRG_Vampire(FlamePool[0]) != none) && KFSprayActor_HRG_Vampire(FlamePool[0]).OwnerWeapon == none)
    {
        KFSprayActor_HRG_Vampire(FlamePool[0]).OwnerWeapon = KFWeap_HRG_Vampire(KFPawn_Human(Instigator).MyKFWeapon);
    }
    if(((FlamePool[1] != none) && KFSprayActor_HRG_Vampire(FlamePool[1]) != none) && KFSprayActor_HRG_Vampire(FlamePool[1]).OwnerWeapon == none)
    {
        KFSprayActor_HRG_Vampire(FlamePool[1]).OwnerWeapon = KFWeap_HRG_Vampire(KFPawn_Human(Instigator).MyKFWeapon);
    }
}

simulated function CreateBloodParticle(float DeltaTime, KFPawn_Monster Monster)
{
    local KFEmit_DirectionalPath Emitter;
    local Vector DestinationLocation, MonsterLocation, BloodParticlesMidPointSocketLocation;
    local Rotator DestinationRotation, BloodParticlesMidPointSocketRotation;
    local Vector BloodSplashVelocity;
    local int Index;

    if(BloodStolenControlTime > float(0))
    {
        BloodStolenControlTime -= DeltaTime;
        return;
    }
    Emitter = none;
    Index = NumBloodStolenParticlesForPool - 1;
    J0x48:

    if(Index >= 0)
    {
        if(BloodStolenParticles[Index].IsEnabled == false)
        {
            Emitter = BloodStolenParticles[Index];
            goto J0xB4;
        }
        -- Index;
        goto J0x48;
    }
    J0xB4:

    if(Emitter == none)
    {
        return;
    }
    if((WeapMesh != none) && WeapMesh.SkeletalMesh != none)
    {
        GetFlameSocketLocAndRot(DestinationLocation, DestinationRotation);
        WeapMesh.GetSocketWorldLocationAndRotation('BloodParticlesMidPoint', BloodParticlesMidPointSocketLocation, BloodParticlesMidPointSocketRotation);
    }
    BloodStolenControlTime += SpawnRateBloodParticles_3P;
    MonsterLocation = ActiveFlameSpray.GetLastContactPositionMeshHit();
    if(IsZero(MonsterLocation))
    {
        Monster.Mesh.GetBoneLocation('Spine1');
    }
    if(MonsterLocation == vect(0, 0, 0))
    {
        MonsterLocation = Monster.Location + vect(0, 0, 20);
    }
    if(FRand() > 0.4)
    {
        BloodSplashVelocity = BloodParticlesMidPointSocketLocation - MonsterLocation;
        BloodSplashVelocity = VRandCone(vect(0, 0, -1), 3.141593 / float(5)) * float(100);
        SpawnBloodSplash(BloodSplashClass, MonsterLocation, BloodSplashVelocity);
    }
    Emitter.ParticleSpeed = SpeedBloodParticles_3P;
    Emitter.RateTickCheckHasReached = 0.2;
    Emitter.SetLocation(MonsterLocation);
    Emitter.SetDestination(DestinationLocation, BloodParticlesMidPointSocketLocation, 20, 20, 50, 50, 0);
    Emitter.ActivateEmitter();
}

simulated function SetChargePercentage(float ChargePercentage)
{
    ChargeRTPC = ChargePercentage;
    bIsCharging = false;
    bIsFullyCharged = false;
    if(ChargeRTPC >= 0)
    {
        bIsCharging = true;
    }
    if(ChargeRTPC >= 1)
    {
        bIsFullyCharged = true;
    }
}

simulated function SetZedCurrentlyBeingSprayed(KFPawn_Monster ZedCurrentlyBeingSprayed)
{
    oZedPreviouslyBeingSprayed = oZedCurrentlyBeingSprayed;
    oZedCurrentlyBeingSprayed = ZedCurrentlyBeingSprayed;
}

simulated function DisableSprayVisualAndMesh()
{
    bIsDisabledSprayVisualAndMesh = true;
}

function SpawnBloodSplash(class<KFProj_BloodSplash> SpawnClass, Vector SpawnLoc, Vector SpawnVel)
{
    local TraceHitInfo HitInfo;
    local Vector HitLocation, HitRotation;
    local KFGoreManager GoreManager;

    GoreManager = KFGoreManager(WorldInfo.MyGoreEffectManager);
    if((GoreManager == none) || oZedCurrentlyBeingSprayed == none)
    {
        return;
    }
    Trace(HitLocation, HitRotation, SpawnLoc + (SpawnVel * 32), SpawnLoc, false,, HitInfo, 1);
    if(IsZero(HitLocation))
    {
        HitLocation = Location;
    }
    if(IsZero(HitRotation))
    {
        HitRotation = vect(0, 0, 1);
    }
    GoreManager.LeaveABloodSplatterDecal(oZedCurrentlyBeingSprayed, HitLocation, HitRotation);
    if(oZedCurrentlyBeingSprayed != none)
    {
        GoreManager.CausePersistentBlood(oZedCurrentlyBeingSprayed, Class'KFDamageType', HitLocation, vect(0, 0, -1), 0, false, false);
    }
}

simulated function RemoveAllBloodParticles()
{
    local int Index;
    local KFEmit_DirectionalPath EmitterToRemove;

    Index = NumBloodStolenParticlesForPool - 1;
    J0x16:

    if(Index >= 0)
    {
        EmitterToRemove = BloodStolenParticles[Index];
        EmitterToRemove.DeactivateEmitter();
        -- Index;
        goto J0x16;
    }
}

defaultproperties
{
    ChargingEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_BlobCharge_3P_01'
    ChargedEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_FullCharge'
    BloodStolenEffect=ParticleSystem'WEP_HRG_Vampire_EMIT.FX_HRG_Vampire_BloodStolen_3P'
    NumBloodStolenParticlesForPool=15
    RateUpdateDestinationBloodParticles=0.7
    BloodSplashClass=Class'KFProj_BloodSplash'
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeapAttach_HRG_Vampire.PilotLight0'
    PSC_PilotLight=PilotLight0
    begin object name=FlameEndSpray0 class=ParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: ParticleSystemComponent'Default__KFWeapAttach_HRG_Vampire.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__KFWeapAttach_HRG_Vampire.SkeletalMeshComponent0.MeshSequenceA'
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFWeapAttach_HRG_Vampire.SkeletalMeshComponent0'
    WeapMesh=SkeletalMeshComponent0
    MuzzleFlashTemplate=KFMuzzleFlash'WEP_HRG_Vampire_Arch.Wep_HRG_Vampire_MuzzleFlash_3P'
}