/*******************************************************************************
 * KFProj_ArcGeneratorSphereBlast generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProj_ArcGeneratorSphereBlast extends KFProjectile
    hidecategories(Navigation);

const ALTFIRE_FIREMODE = 1;

struct BeamZapInfo
{
    var export editinline ParticleSystemComponent oBeam;
    var KFPawn_Monster oAttachedZed;
    var Actor oSourceActor;
    var float oControlTime;

    structdefaultproperties
    {
        oBeam=none
        oAttachedZed=none
        oSourceActor=none
        oControlTime=0
    }
};

var int MaxNumberOfZedsZapped;
var int MaxDistanceToBeZapped;
var float ZapInterval;
var int ZapDamage;
var float TimeToZap;
var KFPawn_Monster oZedCurrentlyBeingSprayed;
var ParticleSystem BeamPSCTemplate;
var ParticleSystem oPawnPSCEffect;
var string EmitterPoolClassPath;
var EmitterPool vBeamEffects;
var array<BeamZapInfo> CurrentZapBeams;
var bool ImpactEffectTriggered;
var export editinline AkComponent ZapSFXComponent;
var() AkEvent ZapSFX;
var Controller oOriginalOwnerController;
var Pawn oOriginalInstigator;
var KFWeapon oOriginalOwnerWeapon;

simulated event PreBeginPlay()
{
    local class<EmitterPool> PoolClass;

    super.PreBeginPlay();
    bIsAIProjectile = (InstigatorController == none) || !InstigatorController.bIsPlayer;
    oOriginalOwnerController = InstigatorController;
    oOriginalInstigator = Instigator;
    oOriginalOwnerWeapon = KFWeapon(Weapon(Owner));
    PoolClass = class<EmitterPool>(DynamicLoadObject(EmitterPoolClassPath, Class'Class'));
    if(PoolClass != none)
    {
        vBeamEffects = Spawn(PoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
    }
    if(oOriginalOwnerWeapon != none)
    {
        PenetrationPower = oOriginalOwnerWeapon.GetInitialPenetrationPower(1);
    }
}

function Init(Vector Direction)
{
    if((LifeSpan == default.LifeSpan) && WorldInfo.TimeDilation < 1)
    {
        LifeSpan /= WorldInfo.TimeDilation;
    }
    super.Init(Direction);
}

simulated function bool ZapFunction(Actor _TouchActor)
{
    local Vector BeamEndPoint;
    local KFPawn_Monster oMonsterPawn;
    local int iZapped;
    local editinline ParticleSystemComponent BeamPSC;

    foreach WorldInfo.AllPawns(Class'KFPawn_Monster', oMonsterPawn)
    {
        if(oMonsterPawn.IsAliveAndWell() && oMonsterPawn != _TouchActor)
        {
            if(VSizeSq(oMonsterPawn.Location - _TouchActor.Location) < Square(float(MaxDistanceToBeZapped)))
            {
                if(FastTrace(_TouchActor.Location, oMonsterPawn.Location, vect(0, 0, 0)) == false)
                {
                    continue;                    
                }
                if(WorldInfo.NetMode != NM_DedicatedServer)
                {
                    BeamPSC = vBeamEffects.SpawnEmitter(BeamPSCTemplate, _TouchActor.Location, _TouchActor.Rotation);
                    BeamEndPoint = oMonsterPawn.Mesh.GetBoneLocation('Spine1');
                    if(BeamEndPoint == vect(0, 0, 0))
                    {
                        BeamEndPoint = oMonsterPawn.Location;
                    }
                    BeamPSC.SetBeamSourcePoint(0, _TouchActor.Location, 0);
                    BeamPSC.SetBeamTargetPoint(0, BeamEndPoint, 0);
                    BeamPSC.SetAbsolute(false, false, false);
                    BeamPSC.bUpdateComponentInTick = true;
                    BeamPSC.SetActive(true);
                    StoreBeam(BeamPSC, oMonsterPawn);
                    ZapSFXComponent.PlayEvent(ZapSFX, true);
                }
                if(((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.NetMode == NM_Standalone) || WorldInfo.NetMode == NM_ListenServer)
                {
                    ChainedZapDamageFunction(oMonsterPawn, _TouchActor);
                }
                ++ iZapped;
            }
        }
        if(iZapped >= MaxNumberOfZedsZapped)
        {
            break;
        }        
    }    
    if(iZapped > 0)
    {
        return true;        
    }
    else
    {
        return false;
    }
}

simulated function StoreBeam(ParticleSystemComponent Beam, KFPawn_Monster Monster)
{
    local BeamZapInfo BeamInfo;

    BeamInfo.oBeam = Beam;
    BeamInfo.oAttachedZed = Monster;
    BeamInfo.oSourceActor = self;
    BeamInfo.oControlTime = ZapInterval;
    CurrentZapBeams.AddItem(BeamInfo;
}

function ChainedZapDamageFunction(Actor _TouchActor, Actor _OriginActor)
{
    local Vector Momentum;
    local TraceHitInfo HitInfo;
    local Pawn TouchPawn;
    local int TotalDamage;

    if(_OriginActor != none)
    {
        Momentum = _TouchActor.Location - _OriginActor.Location;
    }
    if(ZapDamage > 0)
    {
        TouchPawn = Pawn(_TouchActor);
        if(TouchPawn != none)
        {
            ProcessDirectImpact();
        }
        TotalDamage = int(float(ZapDamage) * UpgradeDamageMod);
        _TouchActor.TakeDamage(TotalDamage, oOriginalOwnerController, _TouchActor.Location, Momentum, Class'KFDT_EMP_ArcGenerator_AltFiremodeZapDamage', HitInfo, self);
    }
}

event ProcessDirectImpact()
{
    local KFPlayerController KFPC;

    KFPC = KFPlayerController(oOriginalOwnerController);
    if(KFPC != none)
    {
        KFPC.AddShotsHit(1);
    }
}

simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    if(!bHasExploded)
    {
        Explode(Location - (HitNormal * CylinderComponent.CollisionRadius), HitNormal);
    }
}

simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
{
    local KFPawn_Monster Monster;
    local KFPawn KFP;
    local bool bPassThrough, bNoPenetrationDmgReduction;
    local KFPerk CurrentPerk;
    local InterpCurveFloat PenetrationCurve;
    local KFWeapon KFW;

    ProcessEffect(HitLocation, HitNormal, Other);
    if(Role != ROLE_Authority)
    {
        return;
    }
    if(Other != oOriginalOwnerWeapon)
    {
        if(IgnoreTouchActor == Other)
        {
            return;
        }
        if(!Other.bStatic && DamageRadius == 0)
        {
            if(CheckRepeatingTouch(Other))
            {
                return;
            }
            KFW = oOriginalOwnerWeapon;
            if((KFW == none) || KFW.GetInitialPenetrationPower(1) > 0)
            {
                if((PenetrationPower > float(0)) || PassThroughDamage(Other))
                {
                    if(KFW != none)
                    {
                        CurrentPerk = KFW.GetPerk();
                        if(CurrentPerk != none)
                        {
                            bNoPenetrationDmgReduction = CurrentPerk.IgnoresPenetrationDmgReduction();
                        }
                        PenetrationCurve = KFW.PenetrationDamageReductionCurve[1];
                        if(!bNoPenetrationDmgReduction)
                        {
                            Damage *= EvalInterpCurveFloat(PenetrationCurve, PenetrationPower / KFW.GetInitialPenetrationPower(1));
                        }
                    }
                    ProcessBulletTouch(Other, HitLocation, HitNormal);
                    KFP = KFPawn(Other);
                    if(KFP != none)
                    {
                        PenetrationPower -= KFP.PenetrationResistance;
                        bPassThrough = true;
                    }
                }                
            }
            else
            {
                ProcessBulletTouch(Other, HitLocation, HitNormal);
            }            
        }
        else
        {
            if(((DamageRadius == 0) && !Other.bBlockActors) && Other.IsA('KFWaterMeshActor'))
            {
                if(WorldInfo.NetMode != NM_DedicatedServer)
                {
                    KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, oOriginalInstigator,, ImpactEffects);
                }
                bPassThrough = true;
            }
        }
        if(!bPassThrough)
        {
            super.ProcessTouch(Other, HitLocation, HitNormal);
        }
    }
    Monster = KFPawn_Monster(Other);
    if(((Monster != none) && Monster.IsAliveAndWell()) && ImpactEffects != none)
    {
        WorldInfo.MyEmitterPool.SpawnEmitter(oPawnPSCEffect, HitLocation, rotator(HitNormal), Other);
    }
}

simulated function ProcessBulletTouch(Actor Other, Vector HitLocation, Vector HitNormal)
{
    local Pawn Victim, CurrentInstigator;
    local array<ImpactInfo> HitZoneImpactList;
    local Vector StartTrace, EndTrace, Direction;
    local TraceHitInfo HitInfo;
    local KFWeapon KFW;

    ProcessEffect(HitLocation, HitNormal, Other);
    Victim = Pawn(Other);
    if(Victim == none)
    {
        if(bDamageDestructiblesOnTouch && Other.bCanBeDamaged)
        {
            HitInfo.HitComponent = LastTouchComponent;
            HitInfo.Item = -1;
            Other.TakeDamage(int(Damage), oOriginalOwnerController, Location, MomentumTransfer * Normal(Velocity), MyDamageType, HitInfo, self);
        }
        if(InteractiveFoliageActor(Other) == none)
        {
            PenetrationPower = 0;
            return;
        }        
    }
    else
    {
        if(bSpawnShrapnel)
        {
            SpawnShrapnel(Other, HitLocation, HitNormal, rotator(Velocity), ShrapnelSpreadWidthZed, ShrapnelSpreadHeightZed);
        }
        StartTrace = HitLocation;
        Direction = Normal(Velocity);
        EndTrace = StartTrace + (Direction * (Victim.CylinderComponent.CollisionRadius * 6));
        TraceProjHitZones(Victim, EndTrace, StartTrace, HitZoneImpactList);
        if(HitZoneImpactList.Length > 0)
        {
            HitZoneImpactList[0].RayDir = Direction;
            if(bReplicateClientHitsAsFragments)
            {
                if(oOriginalInstigator != none)
                {
                    KFW = oOriginalOwnerWeapon;
                    if(KFW != none)
                    {
                        KFW.HandleGrenadeProjectileImpact(HitZoneImpactList[0], Class);
                    }
                }                
            }
            else
            {
                if(oOriginalOwnerWeapon != none)
                {
                    KFW = oOriginalOwnerWeapon;
                    if(KFW != none)
                    {
                        CurrentInstigator = KFW.Instigator;
                        KFW.Instigator = oOriginalInstigator;
                        KFW.HandleProjectileImpactSpecial(1, HitZoneImpactList[0], oOriginalInstigator, PenetrationPower);
                        KFW.Instigator = CurrentInstigator;
                    }
                }
            }
        }
    }
}

simulated event Tick(float DeltaTime)
{
    local int I;
    local Vector BeamEndPoint;

    if(CurrentZapBeams.Length > 0)
    {
        I = 0;
        J0x1B:

        if(I < CurrentZapBeams.Length)
        {
            CurrentZapBeams[I].oControlTime -= DeltaTime;
            if((CurrentZapBeams[I].oControlTime > float(0)) && CurrentZapBeams[I].oAttachedZed.IsAliveAndWell())
            {
                BeamEndPoint = CurrentZapBeams[I].oAttachedZed.Mesh.GetBoneLocation('Spine1');
                if(BeamEndPoint == vect(0, 0, 0))
                {
                    BeamEndPoint = CurrentZapBeams[I].oAttachedZed.Location;
                }
                CurrentZapBeams[I].oBeam.SetBeamSourcePoint(0, CurrentZapBeams[I].oSourceActor.Location, 0);
                CurrentZapBeams[I].oBeam.SetBeamTargetPoint(0, BeamEndPoint, 0);                
            }
            else
            {
                CurrentZapBeams[I].oBeam.DeactivateSystem();
                CurrentZapBeams.RemoveItem(CurrentZapBeams[I];
                -- I;
            }
            ++ I;
            goto J0x1B;
        }
    }
    TimeToZap += DeltaTime;
    if(TimeToZap > ZapInterval)
    {
        if(ZapFunction(self))
        {
            TimeToZap = 0;
        }
    }
}

protected simulated function DeferredDestroy(float DelaySec)
{
    super.DeferredDestroy(DelaySec);
    FinalEffectHandling();
}

simulated function Destroyed()
{
    FinalEffectHandling();
    super.Destroyed();
}

simulated function FinalEffectHandling()
{
    local int I;

    if(ImpactEffects != none)
    {
        ImpactEffectTriggered = true;
        WorldInfo.MyEmitterPool.SpawnEmitter(ImpactEffects.DefaultImpactEffect.ParticleTemplate, Location, Rotation);
    }
    if(CurrentZapBeams.Length > 0)
    {
        I = 0;
        J0xB1:

        if(I < CurrentZapBeams.Length)
        {
            CurrentZapBeams[I].oBeam.DeactivateSystem();
            ++ I;
            goto J0xB1;
        }
    }
}

simulated function TriggerExplosion(Vector HitLocation, Vector HitNormal, Actor HitActor)
{
    if(ExplosionTemplate != none)
    {
        super.TriggerExplosion(HitLocation, HitNormal, HitActor);
        return;
    }
    ProcessEffect(HitLocation, HitNormal, HitActor);
}

simulated function ProcessEffect(Vector HitLocation, Vector HitNormal, Actor HitActor)
{
    local KFPawn OtherPawn;

    if(ImpactEffectTriggered || WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(Instigator != none)
    {
        KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, Instigator,, ImpactEffects);        
    }
    else
    {
        if(oOriginalInstigator != none)
        {
            KFImpactEffectManager(WorldInfo.MyImpactEffectManager).PlayImpactEffects(HitLocation, oOriginalInstigator,, ImpactEffects);            
        }
        else
        {
            WorldInfo.MyEmitterPool.SpawnEmitter(ImpactEffects.DefaultImpactEffect.ParticleTemplate, Location, Rotation);
        }
    }
    if(HitActor != none)
    {
        OtherPawn = KFPawn(HitActor);
        ImpactEffectTriggered = ((OtherPawn != none) ? false : true);
    }
}

simulated function bool PassThroughDamage(Actor HitActor)
{
    if(!HitActor.bBlockActors && HitActor.IsA('InteractiveFoliageActor'))
    {
        return true;
    }
    return false;
}

defaultproperties
{
    MaxNumberOfZedsZapped=3
    MaxDistanceToBeZapped=250
    ZapInterval=0.4
    ZapDamage=25
    TimeToZap=100
    BeamPSCTemplate=ParticleSystem'WEP_HRG_ArcGenerator_EMIT.FX_Beam_Test_2'
    oPawnPSCEffect=ParticleSystem'WEP_HRG_ArcGenerator_EMIT.FX_HRG_ArcGenerator_ALT_Impact_Player_01'
    EmitterPoolClassPath="Engine.EmitterPool"
    begin object name=ZapOneShotSFX class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFProj_ArcGeneratorSphereBlast.ZapOneShotSFX'
    ZapSFXComponent=ZapOneShotSFX
    ZapSFX=AkEvent'WW_WEP_Bleeder.Play_WEP_Bleeder_Tube_Blood'
    bSyncToOriginalLocation=true
    bSyncToThirdPersonMuzzleLocation=true
    bUseClientSideHitDetection=true
    bAlwaysReplicateExplosion=true
    bAutoStartAmbientSound=true
    bStopAmbientSoundOnExplode=true
    bImportantAmbientSound=true
    bWarnAIWhenFired=true
    GravityScale=0
    ExtraLineCollisionOffsets=/* Array type was not detected. */
    ProjDisintegrateTemplate=ParticleSystem'ZED_Siren_EMIT.FX_Siren_grenade_disable_01'
    ProjFlightTemplate=ParticleSystem'WEP_HRG_ArcGenerator_EMIT.FX_HRG_ArcGenerator_Projectile_ALT'
    AmbientSoundPlayEvent=AkEvent'WW_WEP_HRG_ArcGenerator.Play_HRG_ArcGenerator_AltFire_Loop'
    ImpactEffects=KFImpactEffectInfo'WEP_HRG_ArcGenerator_ARCH.Wep_HRG_ArcGenerator_Alt_Impact'
    Speed=600
    MaxSpeed=1000
    bBlockedByInstigator=false
    bIgnoreFoliageTouch=true
    DamageRadius=0
    MomentumTransfer=0
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=40
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__KFProj_ArcGeneratorSphereBlast.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=40
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__KFProj_ArcGeneratorSphereBlast.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=ZapOneShotSFX class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
    object end
    // Reference: AkComponent'Default__KFProj_ArcGeneratorSphereBlast.ZapOneShotSFX'
    Components(1)=ZapOneShotSFX
    bNetTemporary=false
    bUpdateSimulatedPosition=true
    bCanBeDamaged=false
    bCollideComplex=true
    NetUpdateFrequency=200
    NetPriority=5
    LifeSpan=10
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=40
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__KFProj_ArcGeneratorSphereBlast.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}