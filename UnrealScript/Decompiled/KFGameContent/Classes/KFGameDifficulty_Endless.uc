/*******************************************************************************
 * KFGameDifficulty_Endless generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFGameDifficulty_Endless extends KFGameDifficultyInfo
    hidecategories(Object);

struct ZedAdjustments
{
    /** How each Zed type will be adjusted. */
    var() array<StatAdjustments> ZedsToAdjust;

    structdefaultproperties
    {
        ZedsToAdjust=none
    }
};

struct SpecialWaveInfo
{
    var() KFGame.KFAISpawnManager.EAIType ZedType;
    var() float PctChance;
    var() float WaveScale;
    var() float SpawnRateMultiplier;
    var() bool bSpawnEnraged;
    var() float NextSpawnTimeModMin;

    structdefaultproperties
    {
        ZedType=EAIType.AT_Clot
        PctChance=0
        WaveScale=1
        SpawnRateMultiplier=1
        bSpawnEnraged=false
        NextSpawnTimeModMin=0
    }
};

struct SpecialWaveDifficultyInfo
{
    var() array<SpecialWaveInfo> SpecialWaveInfos;

    structdefaultproperties
    {
        SpecialWaveInfos(0)=(ZedType=EAIType.AT_Clot,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(1)=(ZedType=EAIType.AT_SlasherClot,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(2)=(ZedType=EAIType.AT_Crawler,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(3)=(ZedType=EAIType.AT_Stalker,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(4)=(ZedType=EAIType.AT_Siren,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(5)=(ZedType=EAIType.AT_Husk,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(6)=(ZedType=EAIType.AT_Scrake,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(7)=(ZedType=EAIType.AT_AlphaClot,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(8)=(ZedType=EAIType.AT_GoreFast,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(9)=(ZedType=EAIType.AT_Bloat,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0)
        SpecialWaveInfos(10)=(ZedType=EAIType.AT_FleshPound,PctChance=0,WaveScale=1,SpawnRateMultiplier=1,bSpawnEnraged=false,NextSpawnTimeModMin=0.25)
    }
};

struct ZedDifficultyOverride
{
    var() class<KFPawn_Monster> ClassToAdjust;
    /** The individual health modifier for this zed type */
    var() float HealthMod;
    /** A per zed damage mod configurable by difficulty */
    var() float DamageMod;
    /** A per zed damage mod configurable by difficulty when playing solo/offline */
    var() float SoloDamageMod;

    structdefaultproperties
    {
        ClassToAdjust=none
        HealthMod=1
        DamageMod=1
        SoloDamageMod=1
    }
};

struct DifficultyOverride
{
    var() array<ZedDifficultyOverride> ZedsOverride;

    structdefaultproperties
    {
        ZedsOverride=none
    }
};

struct DifficultyScaling
{
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty. */
    var() array<DifficultySettings> Difficulties;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
 */
    var() DifficultySettings DifficultyIncrement;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
 */
    var() int CurrentDifficultyIndex;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
 */
    var() const float BaseUpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
 */
    var() const float IncreaseUpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
 */
    var() float UpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
 */
    var() const float BaseFullUpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
 */
    var() const float IncreaseFullUpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
 */
    var() float FullUpgradeZedPctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
 */
    var() array<ZedAdjustments> ZedAdjustmentsByDifficulty;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
// How the Hell on Earth Stat Adjustment will adjust past each boss fight.
 */
    var() StatAdjustments ZedAdjustmentIncrement;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
// How the Hell on Earth Stat Adjustment will adjust past each boss fight.
// The probability that the wave will be an outbreak
 */
    var() array<float> OutbreakPctChances;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
// How the Hell on Earth Stat Adjustment will adjust past each boss fight.
// The probability that the wave will be an outbreak
// The probability that the wave will be a special wave.
 */
    var() array<float> SpecialWavePctChance;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
// How the Hell on Earth Stat Adjustment will adjust past each boss fight.
// The probability that the wave will be an outbreak
// The probability that the wave will be a special wave.
// If we're in a special wave, then what is the probability of a certain zed type being chosen
 */
    var() array<SpecialWaveDifficultyInfo> DifficultySpecialWaveTypes;
    /** How the difficulty will scale each difficulty increase based on the starting difficulty. // The difficulty settings for each difficulty.// When we get into Hell on Earth plus rounds, how will difficulty settings adjust
// Which difficulty we're currently on
// The starting probability that a zed will upgrade to the next class
// Amount that the zed upgrade percent chance will increase each round.
// The probability that a zed will upgrade to the next class.
// Starting probability that a zed will fully upgrade to the final class
// Amount that the zed full upgrade will increase each round
// The probability that a zed will fully upgrade to the final class.
// How each Stat Adjustment will vary by current difficulty.
// How the Hell on Earth Stat Adjustment will adjust past each boss fight.
// The probability that the wave will be an outbreak
// The probability that the wave will be a special wave.
// If we're in a special wave, then what is the probability of a certain zed type being chosen
// If a Zed Difficulty Setting needs to be overriden.
 */
    var() array<DifficultyOverride> ZedDiffOverride;

    structdefaultproperties
    {
        Difficulties=none
        DifficultyIncrement=(TraderTime=60,GlobalHealthMod=1,MovementSpeedMod=1,WaveCountMod=1,DoshKillMod=1,StartingDosh=250,RespawnDosh=250,AmmoPickupsMod=0.5,ItemPickupsMod=0.3,WeakAttackChance=1,MediumAttackChance=0,HardAttackChance=0,SelfInflictedDamageMod=1,SpawnRateModifier=1,TraderTimerMapOverride=none)
        CurrentDifficultyIndex=0
        BaseUpgradeZedPctChance=0.01
        IncreaseUpgradeZedPctChance=0.01
        UpgradeZedPctChance=0
        BaseFullUpgradeZedPctChance=0.001
        IncreaseFullUpgradeZedPctChance=0.001
        FullUpgradeZedPctChance=0
        ZedAdjustmentsByDifficulty=none
        ZedAdjustmentIncrement=(ClassToAdjust=none,HealthScale=1,HeadHealthScale=1,ShieldScale=1,bStartEnraged=false,bExplosiveDeath=false,ExplosionTemplate=none,ExplosionIgnoreClass=none,BeefcakeScaleIncreases=none,BeefcakeHealthIncreases=none,MaxBeefcake=1.5,MaxBeefcakeHealth=1.5,DamageDealtScale=1,DamageTakenScale=1,OverrideDeflationRate=(X=0,Y=0),AdditionalSubSpawns=none,AdditionalSubSpawnCount=(X=1,Y=1),HealByKill=0,HealByAssistance=0,DoshGiven=-1,InitialGroundSpeedModifierScale=1,HitZonesOverride=none,WeakPoints=none,GunGameKilledScore=0,GunGameAssistanceScore=0)
        OutbreakPctChances=none
        SpecialWavePctChance=none
        DifficultySpecialWaveTypes=none
        ZedDiffOverride=none
    }
};

var DifficultyScaling CurrentDifficultyScaling;
var() array<DifficultyScaling> DifficultyScalings;

function IncrementHoePlus()
{
    local int DifficultyIndex;

    DifficultyIndex = CurrentDifficultyScaling.CurrentDifficultyIndex;
    if((DifficultyIndex < 0) || DifficultyIndex >= CurrentDifficultyScaling.Difficulties.Length)
    {
        return;
    }
    AdjustDifficulties(DifficultyIndex);
    AdjustZedStats(DifficultyIndex);
    SetDifficultySettings(float(CurrentDifficultyScaling.CurrentDifficultyIndex));
}

function AdjustDifficulties(int DifficultyIndex)
{
    if((DifficultyIndex < 0) || DifficultyIndex >= CurrentDifficultyScaling.Difficulties.Length)
    {
        return;
    }
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].TraderTime += CurrentDifficultyScaling.DifficultyIncrement.TraderTime;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].GlobalHealthMod += CurrentDifficultyScaling.DifficultyIncrement.GlobalHealthMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].MovementSpeedMod += CurrentDifficultyScaling.DifficultyIncrement.MovementSpeedMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].WaveCountMod += CurrentDifficultyScaling.DifficultyIncrement.WaveCountMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].DoshKillMod += CurrentDifficultyScaling.DifficultyIncrement.DoshKillMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].StartingDosh += CurrentDifficultyScaling.DifficultyIncrement.StartingDosh;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].RespawnDosh += CurrentDifficultyScaling.DifficultyIncrement.RespawnDosh;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].AmmoPickupsMod += CurrentDifficultyScaling.DifficultyIncrement.AmmoPickupsMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].ItemPickupsMod += CurrentDifficultyScaling.DifficultyIncrement.ItemPickupsMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].WeakAttackChance += CurrentDifficultyScaling.DifficultyIncrement.WeakAttackChance;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].MediumAttackChance += CurrentDifficultyScaling.DifficultyIncrement.MediumAttackChance;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].HardAttackChance += CurrentDifficultyScaling.DifficultyIncrement.HardAttackChance;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].SelfInflictedDamageMod += CurrentDifficultyScaling.DifficultyIncrement.SelfInflictedDamageMod;
    CurrentDifficultyScaling.Difficulties[DifficultyIndex].SpawnRateModifier += CurrentDifficultyScaling.DifficultyIncrement.SpawnRateModifier;
}

function AdjustZedStats(int DifficultyIndex)
{
    local int I;

    if((DifficultyIndex < 0) || DifficultyIndex >= CurrentDifficultyScaling.ZedAdjustmentsByDifficulty.Length)
    {
        return;
    }
    I = 0;
    J0x49:

    if(I < CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust.Length)
    {
        CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust[I].HealthScale += CurrentDifficultyScaling.ZedAdjustmentIncrement.HealthScale;
        CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust[I].HeadHealthScale += CurrentDifficultyScaling.ZedAdjustmentIncrement.HeadHealthScale;
        CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust[I].ShieldScale += CurrentDifficultyScaling.ZedAdjustmentIncrement.ShieldScale;
        CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust[I].DamageDealtScale += CurrentDifficultyScaling.ZedAdjustmentIncrement.DamageDealtScale;
        CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[DifficultyIndex].ZedsToAdjust[I].DamageTakenScale += CurrentDifficultyScaling.ZedAdjustmentIncrement.DamageTakenScale;
        ++ I;
        goto J0x49;
    }
}

function IncrementDifficulty()
{
    CurrentDifficultyScaling.CurrentDifficultyIndex = Clamp(CurrentDifficultyScaling.CurrentDifficultyIndex + 1, 0, CurrentDifficultyScaling.Difficulties.Length - 1);
    LogInternal("Incrementing Difficulty Index to" @ string(CurrentDifficultyScaling.CurrentDifficultyIndex));
    SetDifficultySettings(float(CurrentDifficultyScaling.CurrentDifficultyIndex));
}

function SetDifficultySettings(float GameDifficulty)
{
    local int DiffSettingIndex;

    if(CurrentDifficultyScaling.Difficulties.Length > 0)
    {
        DiffSettingIndex = Clamp(int(GameDifficulty), 0, CurrentDifficultyScaling.Difficulties.Length - 1);
        LogInternal("Setting Difficulty Settings to" @ string(DiffSettingIndex));
        CurrentSettings = CurrentDifficultyScaling.Difficulties[DiffSettingIndex];
    }
}

function SetDifficultyScaling(float StartingGameDifficulty)
{
    local int DiffScalingIndex;

    if(DifficultyScalings.Length > 0)
    {
        DiffScalingIndex = Min(int(StartingGameDifficulty), DifficultyScalings.Length - 1);
        LogInternal("Setting Difficulty Scalings to" @ string(DiffScalingIndex));
        CurrentDifficultyScaling = DifficultyScalings[DiffScalingIndex];
    }
}

function float GetZedUpgradePctChance()
{
    return CurrentDifficultyScaling.UpgradeZedPctChance;
}

function float GetZedFullUpgradePctChance()
{
    return CurrentDifficultyScaling.FullUpgradeZedPctChance;
}

function IncreaseZedUpgradePct()
{
    CurrentDifficultyScaling.UpgradeZedPctChance = FClamp(CurrentDifficultyScaling.UpgradeZedPctChance + CurrentDifficultyScaling.IncreaseUpgradeZedPctChance, 0, 1);
}

function IncreaseZedFullUpgradePct()
{
    CurrentDifficultyScaling.FullUpgradeZedPctChance = FClamp(CurrentDifficultyScaling.FullUpgradeZedPctChance + CurrentDifficultyScaling.IncreaseFullUpgradeZedPctChance, 0, 1);
}

function SetZedUpgradeToBase()
{
    CurrentDifficultyScaling.UpgradeZedPctChance = CurrentDifficultyScaling.BaseUpgradeZedPctChance;
}

function SetZedFullUpgradeToBase()
{
    CurrentDifficultyScaling.FullUpgradeZedPctChance = CurrentDifficultyScaling.BaseFullUpgradeZedPctChance;
}

function bool ShouldStartHoePlus()
{
    return (CurrentDifficultyScaling.CurrentDifficultyIndex + 1) >= (CurrentDifficultyScaling.Difficulties.Length - 1);
}

function array<StatAdjustments> GetZedsToAdjust()
{
    return CurrentDifficultyScaling.ZedAdjustmentsByDifficulty[CurrentDifficultyScaling.CurrentDifficultyIndex].ZedsToAdjust;
}

function array<ZedDifficultyOverride> GetZedsOverride()
{
    return CurrentDifficultyScaling.ZedDiffOverride[CurrentDifficultyScaling.CurrentDifficultyIndex].ZedsOverride;
}

function float GetOutbreakPctChance()
{
    if(CurrentDifficultyScaling.OutbreakPctChances.Length > 0)
    {
        return CurrentDifficultyScaling.OutbreakPctChances[Min(CurrentDifficultyScaling.CurrentDifficultyIndex, CurrentDifficultyScaling.OutbreakPctChances.Length - 1)];
    }
    return 0;
}

function float GetSpeicalWavePctChance()
{
    if(CurrentDifficultyScaling.SpecialWavePctChance.Length > 0)
    {
        return CurrentDifficultyScaling.SpecialWavePctChance[Min(CurrentDifficultyScaling.CurrentDifficultyIndex, CurrentDifficultyScaling.SpecialWavePctChance.Length - 1)];
    }
    return 0;
}

function KFGame.KFAISpawnManager.EAIType GetSpecialWaveType()
{
    local array<SpecialWaveInfo> SpecialWaves;
    local float RandF, TotalProb;
    local SpecialWaveInfo It;

    SpecialWaves = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    RandF = FRand();
    if(SpecialWaves.Length == 0)
    {
        return 0;
    }
    foreach SpecialWaves(It,)
    {
        TotalProb += It.PctChance;
        if((It.PctChance > float(0)) && RandF < TotalProb)
        {            
            return It.ZedType;
        }        
    }    
    return SpecialWaves[int(RandRange(0, float(SpecialWaves.Length - 1)))].ZedType;
}

function bool GetSpecialWaveModifiers(KFGame.KFAISpawnManager.EAIType AIType, out float WaveCountMod, out float SpawnRateMod)
{
    local array<SpecialWaveInfo> SpecialWaves;
    local SpecialWaveInfo It;

    SpecialWaves = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    WaveCountMod = 1;
    SpawnRateMod = 1;
    foreach SpecialWaves(It,)
    {
        if(It.ZedType == AIType)
        {
            WaveCountMod = It.WaveScale;
            SpawnRateMod = 1 / It.SpawnRateMultiplier;            
            return true;
        }        
    }    
    return false;
}

function float GetSpecialWaveScale(KFGame.KFAISpawnManager.EAIType AIType)
{
    local array<SpecialWaveInfo> SpecialWaves;
    local SpecialWaveInfo It;

    SpecialWaves = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    LogInternal((((string(self) @ "-") @ string(GetFuncName())) @ "- AIType:") @ string(AIType));
    foreach SpecialWaves(It,)
    {
        LogInternal((((string(self) @ "-") @ string(GetFuncName())) @ "- It.ZedType:") @ string(It.ZedType));
        if(It.ZedType == AIType)
        {
            LogInternal((((string(self) @ "-") @ string(GetFuncName())) @ "- Wave Scale:") @ string(It.WaveScale));            
            return It.WaveScale;
        }        
    }    
    return 1;
}

function float GetSpecialWaveSpawnRateMod(KFGame.KFAISpawnManager.EAIType AIType)
{
    local array<SpecialWaveInfo> SpecialWaves;
    local SpecialWaveInfo It;

    SpecialWaves = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    foreach SpecialWaves(It,)
    {
        if(It.ZedType == AIType)
        {            
            return 1 / It.SpawnRateMultiplier;
        }        
    }    
    return 1;
}

function float GetSpecialWaveSpawnTimeModMin(KFGame.KFAISpawnManager.EAIType AIType)
{
    local array<SpecialWaveInfo> SpecialWaves;
    local SpecialWaveInfo It;

    SpecialWaves = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    foreach SpecialWaves(It,)
    {
        if(It.ZedType == AIType)
        {            
            return It.NextSpawnTimeModMin;
        }        
    }    
    return 0;
}

function float GetAIDamageModifier(KFPawn_Monster P, float GameDifficulty, bool bSoloPlay)
{
    local float PerZedDamageMod, SoloPlayDamageMod;
    local array<ZedDifficultyOverride> ZedsToAdjust;
    local ZedDifficultyOverride ZedDifficulty;
    local bool bFoundOverride;

    PerZedDamageMod = 1;
    SoloPlayDamageMod = 1;
    bFoundOverride = false;
    ZedsToAdjust = GetZedsOverride();
    foreach ZedsToAdjust(ZedDifficulty,)
    {
        if(ZedDifficulty.ClassToAdjust != P.Class)
        {
            continue;            
        }
        else
        {
            PerZedDamageMod = ZedDifficulty.DamageMod;
            if(bSoloPlay)
            {
                SoloPlayDamageMod = ZedDifficulty.SoloDamageMod;
            }
            bFoundOverride = true;
            goto J0x101;            
        }
    }
    J0x101:
    
    if(bFoundOverride)
    {
        return PerZedDamageMod * SoloPlayDamageMod;        
    }
    else
    {
        return super.GetAIDamageModifier(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)), bSoloPlay);
    }
}

function GetAIHealthModifier(KFPawn_Monster P, float GameDifficulty, byte NumLivingPlayers, out float HealthMod, out float HeadHealthMod, optional bool bApplyDifficultyScaling)
{
    local array<StatAdjustments> ZedsToAdjust;
    local StatAdjustments ZedAdjustment;

    bApplyDifficultyScaling = true;
    super.GetAIHealthModifier(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)), NumLivingPlayers, HealthMod, HeadHealthMod, bApplyDifficultyScaling);
    ZedsToAdjust = GetZedsToAdjust();
    foreach ZedsToAdjust(ZedAdjustment,)
    {
        if(ZedAdjustment.ClassToAdjust == P.Class)
        {
            HealthMod *= ZedAdjustment.HealthScale;
            HeadHealthMod *= ZedAdjustment.HeadHealthScale;
        }        
    }    
}

function float GetCharHealthModDifficulty(KFPawn_Monster P, float GameDifficulty)
{
    local array<ZedDifficultyOverride> ZedsToAdjust;
    local ZedDifficultyOverride ZedDifficulty;

    ZedsToAdjust = GetZedsOverride();
    foreach ZedsToAdjust(ZedDifficulty,)
    {
        if(ZedDifficulty.ClassToAdjust == P.Class)
        {            
            return ZedDifficulty.HealthMod;
        }        
    }    
    return super.GetCharHealthModDifficulty(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)));
}

function float GetCharHeadHealthModDifficulty(KFPawn_Monster P, float GameDifficulty)
{
    return super.GetCharHeadHealthModDifficulty(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)));
}

function float GetCharSprintChanceByDifficulty(KFPawn_Monster P, float GameDifficulty)
{
    local KFGameInfo_Endless KFGI;

    KFGI = KFGameInfo_Endless(P.WorldInfo.Game);
    if(((KFGI != none) && KFGI.bUseSpecialWave) && ShouldSpawnEnraged(KFGI.SpecialWaveType))
    {
        return 1;
    }
    return super.GetCharSprintChanceByDifficulty(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)));
}

function float GetCharSprintWhenDamagedChanceByDifficulty(KFPawn_Monster P, float GameDifficulty)
{
    local KFGameInfo_Endless KFGI;

    KFGI = KFGameInfo_Endless(P.WorldInfo.Game);
    if(((KFGI != none) && KFGI.bUseSpecialWave) && ShouldSpawnEnraged(KFGI.SpecialWaveType))
    {
        return 1;
    }
    return super.GetCharSprintWhenDamagedChanceByDifficulty(P, float(Clamp(GetCurrentDifficultyIndex(), 0, 3)));
}

function int GetCurrentDifficultyIndex()
{
    return CurrentDifficultyScaling.CurrentDifficultyIndex;
}

function bool ShouldSpawnEnraged(KFGame.KFAISpawnManager.EAIType AIType)
{
    local array<SpecialWaveInfo> CurrentSpecialWave;
    local SpecialWaveInfo CurrentWaveInfo;

    CurrentSpecialWave = CurrentDifficultyScaling.DifficultySpecialWaveTypes[CurrentDifficultyScaling.CurrentDifficultyIndex].SpecialWaveInfos;
    foreach CurrentSpecialWave(CurrentWaveInfo,)
    {
        if(CurrentWaveInfo.ZedType == AIType)
        {            
            return CurrentWaveInfo.bSpawnEnraged;
        }        
    }    
    return false;
}

defaultproperties
{
    CurrentDifficultyScaling=(Difficulties=none,DifficultyIncrement=(TraderTime=60,GlobalHealthMod=1,MovementSpeedMod=1,WaveCountMod=1,DoshKillMod=1,StartingDosh=250,RespawnDosh=250,AmmoPickupsMod=0.5,ItemPickupsMod=0.3,WeakAttackChance=1,MediumAttackChance=0,HardAttackChance=0,SelfInflictedDamageMod=1,SpawnRateModifier=1,TraderTimerMapOverride=none),CurrentDifficultyIndex=0,BaseUpgradeZedPctChance=0.01,IncreaseUpgradeZedPctChance=0.01,UpgradeZedPctChance=0,BaseFullUpgradeZedPctChance=0.001,IncreaseFullUpgradeZedPctChance=0.001,FullUpgradeZedPctChance=0,ZedAdjustmentsByDifficulty=none,ZedAdjustmentIncrement=(ClassToAdjust=none,HealthScale=1,HeadHealthScale=1,ShieldScale=1,bStartEnraged=false,bExplosiveDeath=false,ExplosionTemplate=none,ExplosionIgnoreClass=none,BeefcakeScaleIncreases=none,BeefcakeHealthIncreases=none,MaxBeefcake=1.5,MaxBeefcakeHealth=1.5,DamageDealtScale=1,DamageTakenScale=1,OverrideDeflationRate=(X=0,Y=0),AdditionalSubSpawns=none,AdditionalSubSpawnCount=(X=1,Y=1),HealByKill=0,HealByAssistance=0,DoshGiven=-1,InitialGroundSpeedModifierScale=1,HitZonesOverride=none,WeakPoints=none,GunGameKilledScore=0,GunGameAssistanceScore=0),OutbreakPctChances=none,SpecialWavePctChance=none,DifficultySpecialWaveTypes=none,ZedDiffOverride=none)
    DifficultyScalings(0)=(Difficulties=((TraderTime=75,GlobalHealthMod=1,MovementSpeedMod=0.9,WaveCountMod=0.75,DoshKillMod=1.1,StartingDosh=300,RespawnDosh=250,AmmoPickupsMod=0.4,ItemPickupsMod=0.45,WeakAttackChance=1,MediumAttackChance=0,HardAttackChance=0,SelfInflictedDamageMod=0.1,SpawnRateModifier=0.8,TraderTimerMapOverride=/* Array type was not detected. */,MapName="KF-DieSector",TraderTime=45),none,(TraderTime=75,GlobalHealthMod=1,MovementSpeedMod=0.95,WaveCountMod=0.8,DoshKillMod=1,StartingDosh=250,RespawnDosh=300,AmmoPickupsMod=0.3,ItemPickupsMod=0.35,WeakAttackChance=1,MediumAttackChance=0,HardAttackChance=0,SelfInflictedDamageMod=0.1,SpawnRateModifier=0.8,TraderTimerMapOverride=/* Array type was not detected. */,MapName="KF-DieSector",TraderTime=45),none,(TraderTime=75,GlobalHealthMod=1,MovementSpeedMod=0.95,WaveCountMod=0.9,DoshKillMod=1,StartingDosh=250,RespawnDosh=250,AmmoPickupsMod=0.4,ItemPickupsMod=0.25,WeakAttackChance=1,MediumAttackChance=1,HardAttackChance=0.5,SelfInflictedDamageMod=0.1,SpawnRateModifier=0.7,TraderTimerMapOverride=/* Array type was not detected. */,MapName="KF-DieSector",TraderTime=45)))
    DifficultyScalings(1)=(TraderTime=75,GlobalHealthMod=1,MovementSpeedMod=0.95,WaveCountMod=0.95,DoshKillMod=1,StartingDosh=250,RespawnDosh=250,AmmoPickupsMod=0.25,ItemPickupsMod=0.1,WeakAttackChance=1,MediumAttackChance=1,HardAttackChance=1,SelfInflictedDamageMod=0.1,SpawnRateModifier=0.68,TraderTimerMapOverride=/* Array type was not detected. */,MapName="KF-DieSector",TraderTime=45)
    DifficultyScalings(2)=none
    DifficultyScalings(3)=(TraderTime=75,GlobalHealthMod=1,MovementSpeedMod=0.95,WaveCountMod=1,DoshKillMod=1,StartingDosh=250,RespawnDosh=250,AmmoPickupsMod=0.25,ItemPickupsMod=0.1,WeakAttackChance=1,MediumAttackChance=1,HardAttackChance=1,SelfInflictedDamageMod=0.1,SpawnRateModifier=0.68,TraderTimerMapOverride=/* Array type was not detected. */,MapName="KF-DieSector",TraderTime=45)
}