/*******************************************************************************
 * KFMapObjective_RepairActors generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFMapObjective_RepairActors extends KFMapObjective_ActorBase
    hidecategories(Navigation);

/** How many actors needs to be repaired for the objective to be completed, per number of players */
var() const int ActivationsRequiredForPlayerCount[6];
/** A delay from the the start of an objective, so the player can't automatically repair the first actor */
var() float ActivationDelay;
/** A sound to play when each repair actor is activated */
var() array<AkEvent> ActorActivationSoundEvents;
/** A sound to play when each repair actor is repaired */
var() array<AkEvent> ActorRepairedSoundEvents;
var int ActivationsRequired;
var repnotify int ActorsRepaired;
/** List of all the actors that must be repaired by the user. */
var() array<KFRepairableActor> RepairableActors;
var array<KFRepairableActor> UnusedRepairableActors;
var KFRepairableActor LastRepairedActor;
var repnotify KFRepairableActor CurrentActorToRepair;
/** How long until the next repairable actor can be activated. */
var() float TimeUntilNextActivation;
/** A sound to play when the objective is fully complete */
var() AkEvent SuccessSoundEvent100pct;
/** A sound to play when the objective is mostly complete */
var() AkEvent SuccessSoundEvent85pct;
/** A sound to play when the objective is adequately complete */
var() AkEvent SuccessSoundEvent50pct;
/** A sound to play when the objective is barely complete */
var() AkEvent SuccessSoundEvent25pct;
var float JustWinThreshold;
var float StandardWinThreshold;
var float GoodWinThreshold;
/** Whether the sequence of repairables should be randomized */
var() bool bRandomSequence;

replication
{
     if(bNetDirty)
        ActivationsRequired, ActorsRepaired, 
        CurrentActorToRepair;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'CurrentActorToRepair')
    {
        UpdateTrailActor();        
    }
    else
    {
        if(VarName == 'ActorsRepaired')
        {
            if(ActorsRepaired != 0)
            {
                TriggerObjectiveProgressEvent(,, float(ActorsRepaired) / float(ActivationsRequired));
            }            
        }
        else
        {
            super(Actor).ReplicatedEvent(VarName);
        }
    }
}

simulated function ActivateObjective()
{
    local int PlayerCount;
    local KFRepairableActor CurrActor;

    super.ActivateObjective();
    foreach RepairableActors(CurrActor,)
    {
        CurrActor.__OnRepairCompelete__Delegate = OnActorRepaired;        
    }    
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(bUseTrailToObjective)
        {
            TrailActor = Class'WorldInfo'.static.GetWorldInfo().Spawn(Class'KFReplicatedShowPathActor', none);
            TrailActor.SetEmitterTemplate(ParticleSystem'FX_Objective_White_Trail');
        }
    }
    if(Role == ROLE_Authority)
    {
        PlayerCount = Clamp(KFGameInfo(WorldInfo.Game).GetLivingPlayerCount(), 1, 6) - 1;
        ActivationsRequired = ActivationsRequiredForPlayerCount[PlayerCount];
        ActorsRepaired = 0;
        bIsActive = true;
        if(ActivationDelay > 0)
        {
            SetTimer(ActivationDelay, false, 'ActivateNextRepairableActor');            
        }
        else
        {
            ActivateNextRepairableActor();
        }
    }
}

simulated function DeactivateObjective()
{
    local KFPlayerController KFPC;
    local KFPawn_Human KFPH;
    local KFRepairableActor CurrActor;

    super.DeactivateObjective();
    if(Role == ROLE_Authority)
    {
        bIsActive = false;
        if(!HasFailedObjective())
        {
            foreach WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
            {
                GrantReward(KFPlayerReplicationInfo(KFPH.PlayerReplicationInfo), KFPlayerController(KFPH.Controller));
                if(KFPlayerController(KFPH.Controller) != none)
                {
                    if((GetTotalProgress()) >= 1)
                    {
                    }
                }                
            }                        
        }
        else
        {
            LogInternal("objective failed");
        }
        PlayDeactivationDialog();
        ClearTimer('ActivateNextRepairableActor');
    }
    foreach RepairableActors(CurrActor,)
    {
        CurrActor.Reset();        
    }    
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(TrailActor != none)
        {
            TrailActor.Destroy();
            TrailActor = none;
        }
    }
    KFPC = KFPlayerController(GetALocalPlayerController());
    if((KFPC != none) && KFPC.myGfxHUD != none)
    {
        KFPC.myGfxHUD.WaveInfoWidget.ObjectiveContainer.SetFailState(HasFailedObjective());
    }
}

function PlayDeactivationDialog()
{
    if((GetTotalProgress()) <= 0)
    {
        PlaySoundBase(FailureSoundEvent, false, WorldInfo.NetMode == NM_DedicatedServer);
        BroadcastLocalizedMessage(Class'KFLocalMessage_Priority', 6);        
    }
    else
    {
        if((GetTotalProgress()) <= JustWinThreshold)
        {
            PlaySoundBase(SuccessSoundEvent25pct, false, WorldInfo.NetMode == NM_DedicatedServer);            
        }
        else
        {
            if((GetTotalProgress()) <= StandardWinThreshold)
            {
                PlaySoundBase(SuccessSoundEvent50pct, false, WorldInfo.NetMode == NM_DedicatedServer);                
            }
            else
            {
                if((GetTotalProgress()) <= GoodWinThreshold)
                {
                    PlaySoundBase(SuccessSoundEvent85pct, false, WorldInfo.NetMode == NM_DedicatedServer);                    
                }
                else
                {
                    PlaySoundBase(SuccessSoundEvent100pct, false, WorldInfo.NetMode == NM_DedicatedServer);
                }
            }
        }
    }
}

function ActivateNextRepairableActor()
{
    if(Role == ROLE_Authority)
    {
        LastRepairedActor = CurrentActorToRepair;
        CurrentActorToRepair = ChooseNextActorToRepair();
        if(CurrentActorToRepair != none)
        {
            CurrentActorToRepair.PlayDestroyed();
        }
        if(ActorsRepaired < ActorActivationSoundEvents.Length)
        {
            PlaySoundBase(ActorActivationSoundEvents[ActorsRepaired], false, WorldInfo.NetMode == NM_DedicatedServer);
        }
    }
    UpdateTrailActor();
}

simulated function UpdateTrailActor()
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(TrailActor != none)
        {
            TrailActor.SetPathTarget(CurrentActorToRepair.RepairTrigger);
        }
    }
}

function KFRepairableActor ChooseNextActorToRepair()
{
    local int ChosenActorIndex;
    local KFRepairableActor ChosenActor;
    local array<KFRepairableActor> ValidActors;

    if(RepairableActors.Length == 0)
    {
        return none;
    }
    if(UnusedRepairableActors.Length == 0)
    {
        UnusedRepairableActors = RepairableActors;
    }
    ValidActors = UnusedRepairableActors;
    if(ValidActors.Length > 1)
    {
        ValidActors.RemoveItem(LastRepairedActor;
    }
    if(bRandomSequence)
    {
        ChosenActorIndex = int(RandRange(0, float(ValidActors.Length - 1)));        
    }
    else
    {
        ChosenActorIndex = 0;
    }
    ChosenActor = ValidActors[ChosenActorIndex];
    UnusedRepairableActors.Remove(ChosenActorIndex, 1;
    return ChosenActor;
}

function OnActorRepaired(KFRepairableActor RepairedActor)
{
    local KFGameReplicationInfo KFGRI;

    if(!bIsActive)
    {
        return;
    }
    if(Role == ROLE_Authority)
    {
        if(ActorsRepaired < ActorRepairedSoundEvents.Length)
        {
            PlaySoundBase(ActorRepairedSoundEvents[ActorsRepaired], false, WorldInfo.NetMode == NM_DedicatedServer);
        }
    }
    ++ ActorsRepaired;
    TriggerObjectiveProgressEvent(,, float(ActorsRepaired) / float(ActivationsRequired));
    if((GetTotalProgress()) >= 1)
    {
        KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
        if(KFGRI != none)
        {
            KFGRI.DeactivateObjective();
        }        
    }
    else
    {
        if(TimeUntilNextActivation > 0)
        {
            SetTimer(TimeUntilNextActivation, false, 'ActivateNextRepairableActor');
            CurrentActorToRepair = none;
            UpdateTrailActor();            
        }
        else
        {
            ActivateNextRepairableActor();
        }
    }
}

simulated function bool IsActive()
{
    return bIsActive;
}

simulated function bool IsBonus()
{
    return true;
}

function bool CanActivateObjective()
{
    return !IsCurrentGameModeBlacklisted();
}

function bool IsCurrentGameModeBlacklisted()
{
    local class<KFGameInfo> CurrGameClass;

    foreach GameModeBlacklist(CurrGameClass,)
    {
        if(CurrGameClass == WorldInfo.GRI.GameClass)
        {            
            return true;
        }        
    }    
    return false;
}

simulated function bool UsesProgress()
{
    return false;
}

simulated function bool ShouldShowObjectiveHUD()
{
    return false;
}

simulated function float GetProgress()
{
    if(!HasFailedObjective())
    {
        return float(ActorsRepaired) / float(ActivationsRequired);
    }
    return 0;
}

simulated function bool IsComplete()
{
    return (GetProgress()) >= 1;
}

simulated function float GetTotalProgress()
{
    if(ActivationsRequired == 0)
    {
        return 0;
    }
    return float(ActorsRepaired) / float(ActivationsRequired);
}

simulated function float GetActivationPctChance()
{
    return 1;
}

simulated function string GetLocalizedRequirements()
{
    return (Localize("Objectives", default.RequirementsLocKey, "KFGame")) @ string(ActivationsRequired);
}

simulated function bool ShouldDrawIcon()
{
    return CurrentActorToRepair != none;
}

simulated function Vector GetIconLocation()
{
    if(CurrentActorToRepair != none)
    {
        return CurrentActorToRepair.Location + CurrentActorToRepair.IconLocationOffset;
    }
    return Location;
}

simulated function int GetVoshReward()
{
    local int MaxDosh;

    MaxDosh = GetMaxVoshReward();
    if(MaxDosh == 0)
    {
        return MaxDosh;
    }
    return int(float(MaxDosh) * (GetTotalProgress()));
}

simulated function int GetXPReward()
{
    local int MaxXP;

    MaxXP = GetMaxXPReward();
    if(MaxXP == 0)
    {
        return MaxXP;
    }
    return int(float(MaxXP) * (GetTotalProgress()));
}

simulated function string GetProgressText()
{
    if(!bIsActive)
    {
        return "";
    }
    return (string(ActorsRepaired) $ "/") $ string(ActivationsRequired);
}

simulated function bool GetIsMissionCritical()
{
    return bIsMissionCriticalObjective;
}

simulated function DrawHUD(KFHUDBase HUD, Canvas DrawCanvas)
{
    local float Percentage, BarHeight, BarLength;
    local Vector ScreenPos, TargetLocation;
    local float ResModifier, ThisDot;
    local KFGameReplicationInfo KFGRI;
    local Vector ViewLocation, ViewVector;
    local Rotator ViewRotation;
    local KFPlayerController KFPC;

    ResModifier = WorldInfo.GetResolutionBasedHUDScale() * HUD.FriendlyHudScale;
    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    KFPC = KFPlayerController(GetALocalPlayerController());
    if(!ShouldDrawIcon() || KFGRI.bHidePawnIcons)
    {
        return;
    }
    if(KFPC != none)
    {
        KFPC.GetPlayerViewPoint(ViewLocation, ViewRotation);
    }
    ViewVector = vector(ViewRotation);
    ThisDot = Normal((GetIconLocation()) - ViewLocation) Dot ViewVector;
    if(ThisDot <= float(0))
    {
        return;
    }
    BarLength = FMin(HUD.PlayerStatusBarLengthMax * (DrawCanvas.ClipX / 1024), HUD.PlayerStatusBarLengthMax) * ResModifier;
    BarHeight = FMin(8 * (DrawCanvas.ClipX / 1024), 8) * ResModifier;
    TargetLocation = GetIconLocation();
    ScreenPos = DrawCanvas.Project(TargetLocation);
    ScreenPos.X = FClamp(ScreenPos.X, (BarLength * 0.5) + HUD.PlayerStatusIconSize, DrawCanvas.ClipX - (BarLength * 0.5));
    ScreenPos.Y = FClamp(ScreenPos.Y, HUD.PlayerStatusIconSize * 0.5, DrawCanvas.ClipY - (HUD.PlayerStatusIconSize * 0.5));
    Percentage = FMin(FClamp(float(CurrentActorToRepair.WeldIntegrity) / float(CurrentActorToRepair.MaxWeldIntegrity), 0, 1), 1);
    HUD.DrawKFBar(Percentage, BarLength, BarHeight, ScreenPos.X - (BarLength * 0.5), ScreenPos.Y, HUD.NonPlayerHealth);
    if((GetIcon()) != none)
    {
        DrawCanvas.SetDrawColorStruct(HUD.PlayerBarShadowColor);
        DrawCanvas.SetPos((ScreenPos.X - (BarLength * 0.75)) + float(1), (ScreenPos.Y - (BarHeight * 2)) + float(1));
        DrawCanvas.DrawTile(GetIcon(), HUD.PlayerStatusIconSize * ResModifier, HUD.PlayerStatusIconSize * ResModifier, 0, 0, 256, 256);
        DrawCanvas.SetDrawColorStruct(GetIconColor());
        DrawCanvas.SetPos(ScreenPos.X - (BarLength * 0.75), ScreenPos.Y - (BarHeight * 2));
        DrawCanvas.DrawTile(GetIcon(), HUD.PlayerStatusIconSize * ResModifier, HUD.PlayerStatusIconSize * ResModifier, 0, 0, 256, 256);
    }
}

defaultproperties
{
    ActivationsRequired=6
    TimeUntilNextActivation=5
    JustWinThreshold=0.25
    StandardWinThreshold=0.5
    GoodWinThreshold=0.85
    bRandomSequence=true
    LocalizationKey="RepairObjective"
    NameShortLocKey="RepairObjective"
    DescriptionLocKey="UseWelderToRepair"
    DescriptionShortLocKey="UseWelderToRepairShort"
    LocalizationPackageName="KFGame"
    RequirementsLocKey="RepairObjectiveRequired"
    bUseTrailToObjective=true
    GameModeBlacklist=/* Array type was not detected. */
    PerPlayerSpawnRateMod=/* Array type was not detected. */
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__KFMapObjective_RepairActors.Sprite'
    Components(0)=Sprite
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bAlwaysRelevant=true
    SupportedEvents=/* Array type was not detected. */
}