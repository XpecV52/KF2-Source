/*******************************************************************************
 * KFWeap_HRG_Healthrower generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_HRG_Healthrower extends KFWeap_FlameBase
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const ShootDartAnim = 'Shoot_Dart';
const ShootDartIronAnim = 'Shoot_Iron_Dart';

var class<DamageType> HealingDartDamageType;
/** How much to heal for when using this weapon */
var(Healing) int HealAmount;
/** How many points of heal ammo to recharge per second */
var(Healing) float HealFullRechargeSeconds;
var float HealingIncrement;
var float HealRechargePerSecond;
var AkEvent HealImpactSoundPlayEvent;
var AkEvent HurtImpactSoundPlayEvent;
/** Sound to play when the weapon is fired */
var(Sounds) WeaponFireSndInfo DartFireSnd;
/**  
 *How long after we shoot a healing dart before a zed can grab us.
 *  Prevents us from missing healing shots from being grabbed
 */
var(Weapon) float HealDartShotWeakZedGrabCooldown;
/** Recoil override for healing dart alt-fire */
var(Recoil) int DartMaxRecoilPitch;
var(Recoil) int DartMinRecoilPitch;
var(Recoil) int DartMaxRecoilYaw;
var(Recoil) int DartMinRecoilYaw;
var ForceFeedbackWaveform HealingDartWaveForm;
var repnotify byte HealingDartAmmo;
var byte StoredPrimaryAmmo;
var byte StoredSecondaryAmmo;
/** The frequency with which we will check for a lock */
var(Locking) float LockCheckTime;
/** How far out should we be considering actors for a lock */
var(Locking) float LockRange;
/** How long does the player need to target an actor to lock on to it */
var(Locking) float LockAcquireTime;
/** Once locked, how long can the player go without painting the object before they lose the lock */
var(Locking) float LockTolerance;
var bool bLockedOnTarget;
var bool bTargetLockingActive;
var bool bRechargeHealAmmo;
var repnotify Actor LockedTarget;
var repnotify Actor PendingLockedTarget;
/** angle for locking for lock targets */
var(Locking) float LockAim;
var AkBaseSoundObject LockAcquiredSoundFirstPerson;
var AkBaseSoundObject LockTargetingStopEvent;
var AkBaseSoundObject LockTargetingStopEventFirstPerson;
var AkBaseSoundObject LockLostSoundFirstPerson;
var AkBaseSoundObject LockTargetingSoundFirstPerson;
var float PendingLockAcquireTimeLeft;
var float PendingLockTimeout;
var float LockedOnTimeout;
var class<KFGFxWorld_MedicOptics> OpticsUIClass;
var KFGFxWorld_MedicOptics OpticsUI;

replication
{
     if(bNetDirty && Role == ROLE_Authority)
        LockedTarget, PendingLockedTarget, 
        bLockedOnTarget;

     if(((bNetDirty && Role == ROLE_Authority) && bAllowClientAmmoTracking) && bRechargeHealAmmo)
        HealingDartAmmo;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'LockedTarget')
    {
        if(OpticsUI != none)
        {
            if((LockedTarget == none) && PendingLockedTarget == none)
            {
                OpticsUI.ClearLockOn();                
            }
            else
            {
                if(LockedTarget != none)
                {
                    OpticsUI.LockedOn();
                }
            }
        }        
    }
    else
    {
        if(VarName == 'PendingLockedTarget')
        {
            if(OpticsUI != none)
            {
                if((PendingLockedTarget == none) && LockedTarget == none)
                {
                    OpticsUI.ClearLockOn();                    
                }
                else
                {
                    if(PendingLockedTarget != none)
                    {
                        OpticsUI.StartLockOn();
                    }
                }
            }            
        }
        else
        {
            if(VarName == 'HealingDartAmmo')
            {
                AmmoCount[1] = HealingDartAmmo;                
            }
            else
            {
                super(KFWeapon).ReplicatedEvent(VarName);
            }
        }
    }
}

simulated event Tick(float DeltaTime)
{
    if(AmmoCount[1] < MagazineCapacity[1])
    {
        HealAmmoRegeneration(DeltaTime);
    }
    if((Instigator != none) && Instigator.Weapon == self)
    {
        UpdateOpticsUI();
    }
    super.Tick(DeltaTime);
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    StartFire(1);
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    if(FireModeNum != 1)
    {
        super(KFWeapon).ConsumeAmmo(FireModeNum);
        return;
    }
    if((Role == ROLE_Authority) || bAllowClientAmmoTracking)
    {
        if((MagazineCapacity[1] > 0) && AmmoCount[1] > 0)
        {
            AmmoCount[1] = byte(Max(AmmoCount[1] - AmmoCost[1], 0));
        }
    }
}

simulated function ProcessInstantHitEx(byte FiringMode, ImpactInfo Impact, optional int NumHits, optional out float out_PenetrationVal, optional int ImpactNum)
{
    local KFPawn HealTarget;
    local KFPlayerController Healer;
    local KFPerk InstigatorPerk;
    local float AdjustedHealAmount;

    HealTarget = KFPawn(Impact.HitActor);
    Healer = KFPlayerController(Instigator.Controller);
    InstigatorPerk = GetPerk();
    if(InstigatorPerk != none)
    {
        InstigatorPerk.UpdatePerkHeadShots(Impact, InstantHitDamageTypes[FiringMode], ImpactNum);
    }
    if(((FiringMode == 1) && HealTarget != none) && WorldInfo.GRI.OnSameTeam(Instigator, HealTarget))
    {
        if(Healer != none)
        {
            Healer.AddShotsHit(1);
        }
        AdjustedHealAmount = float(HealAmount) * (GetUpgradeHealMod(CurrentWeaponUpgradeIndex));
        HealTarget.HealDamage(int(AdjustedHealAmount), Instigator.Controller, HealingDartDamageType);
        if(((HealImpactSoundPlayEvent != none) && HealTarget != none) && !bSuppressSounds)
        {
            HealTarget.PlaySoundBase(HealImpactSoundPlayEvent, false, false,, Impact.HitLocation);
        }        
    }
    else
    {
        if(((HurtImpactSoundPlayEvent != none) && HealTarget != none) && !bSuppressSounds)
        {
            HealTarget.PlaySoundBase(HurtImpactSoundPlayEvent, false, false,, Impact.HitLocation);
        }
        super(KFWeapon).ProcessInstantHitEx(FiringMode, Impact, NumHits, out_PenetrationVal);
    }
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProjectile SpawnedProjectile;

    SpawnedProjectile = super(KFWeapon).SpawnProjectile(KFProjClass, RealStartLoc, AimDir);
    if(bLockedOnTarget && KFProj_HealingDart(SpawnedProjectile) != none)
    {
        KFProj_HealingDart(SpawnedProjectile).SeekTarget = LockedTarget;
    }
    return SpawnedProjectile;
}

simulated event HandleRecoil()
{
    if(CurrentFireMode == 1)
    {
        minRecoilPitch = DartMinRecoilPitch;
        maxRecoilPitch = DartMaxRecoilPitch;
        minRecoilYaw = DartMinRecoilYaw;
        maxRecoilYaw = DartMaxRecoilYaw;        
    }
    else
    {
        minRecoilPitch = default.minRecoilPitch;
        maxRecoilPitch = default.maxRecoilPitch;
        minRecoilYaw = default.minRecoilYaw;
        maxRecoilYaw = default.maxRecoilYaw;
    }
    super(KFWeapon).HandleRecoil();
}

simulated function ShakeView()
{
    if(CurrentFireMode == 1)
    {
        WeaponFireWaveForm = HealingDartWaveForm;        
    }
    else
    {
        WeaponFireWaveForm = default.WeaponFireWaveForm;
    }
    super(KFWeapon).ShakeView();
}

simulated function StartFire(byte FireModeNum)
{
    if((FireModeNum == 1) && !HasAmmo(FireModeNum, AmmoCost[FireModeNum]))
    {
        return;
    }
    super(KFWeapon).StartFire(FireModeNum);
}

function GivenTo(Pawn thisPawn, optional bool bDoNotActivate)
{
    super(KFWeapon).GivenTo(thisPawn, bDoNotActivate);
    if((Role == ROLE_Authority) && !thisPawn.IsLocallyControlled())
    {
        StartHealRecharge();
    }
}

function StartHealRecharge()
{
    local KFPerk InstigatorPerk;
    local float UsedHealRechargeTime;

    if(!bRechargeHealAmmo)
    {
        return;
    }
    if(Role == ROLE_Authority)
    {
        InstigatorPerk = GetPerk();
        UsedHealRechargeTime = HealFullRechargeSeconds * (GetUpgradeHealRechargeMod(CurrentWeaponUpgradeIndex));
        InstigatorPerk.ModifyHealerRechargeTime(UsedHealRechargeTime);
        HealRechargePerSecond = float(MagazineCapacity[1]) / UsedHealRechargeTime;
        HealingIncrement = 0;
    }
}

function HealAmmoRegeneration(float DeltaTime)
{
    if(!bRechargeHealAmmo)
    {
        return;
    }
    if(Role == ROLE_Authority)
    {
        HealingIncrement += (HealRechargePerSecond * DeltaTime);
        if((HealingIncrement >= 1) && AmmoCount[1] < MagazineCapacity[1])
        {
            ++ AmmoCount[1];
            HealingIncrement -= 1;
            if(bAllowClientAmmoTracking)
            {
                HealingDartAmmo = AmmoCount[1];
            }
        }
    }
}

simulated function bool HasAnyAmmo()
{
    if((HasSpareAmmo()) || HasAmmo(0))
    {
        return true;
    }
    return false;
}

function AdjustLockTarget(Actor NewLockTarget)
{
    if(LockedTarget == NewLockTarget)
    {
        return;
    }
    if(NewLockTarget == none)
    {
        if(bLockedOnTarget)
        {
            bLockedOnTarget = false;
            LockedTarget = none;
            if((OpticsUI != none) && PendingLockedTarget == none)
            {
                OpticsUI.ClearLockOn();
            }
            if(bUsingSights)
            {
                ClientPlayTargetingSound(LockLostSoundFirstPerson);
            }
        }        
    }
    else
    {
        bLockedOnTarget = true;
        LockedTarget = NewLockTarget;
        if(OpticsUI != none)
        {
            OpticsUI.LockedOn();
        }
        ClientPlayTargetingSound(LockAcquiredSoundFirstPerson);
    }
}

simulated function bool CanLockOnTo(Actor TA)
{
    local Pawn PawnTarget;
    local KFPawn KFPawnTarget;

    PawnTarget = Pawn(TA);
    if(((((((TA == none) || !TA.bProjTarget) || TA.bDeleteMe) || PawnTarget == none) || TA == Instigator) || PawnTarget.Health <= 0) || PawnTarget.Health >= PawnTarget.HealthMax)
    {
        return false;
    }
    KFPawnTarget = KFPawn(PawnTarget);
    if((KFPawnTarget != none) && !KFPawnTarget.CanBeHealed())
    {
        return false;
    }
    return WorldInfo.GRI.OnSameTeam(Instigator, TA);
}

function bool AllowTargetLockOn()
{
    return !Instigator.bNoWeaponFiring;
}

function CheckTargetLock()
{
    local Actor BestTarget, HitActor, TA;
    local Vector StartTrace, EndTrace, Aim, HitLocation, HitNormal;

    local Rotator AimRot;
    local float bestAim, bestDist;

    if(((Instigator == none) || Instigator.Controller == none) || self != Instigator.Weapon)
    {
        return;
    }
    if(!AllowTargetLockOn())
    {
        AdjustLockTarget(none);
        PendingLockedTarget = none;
        return;
    }
    if(LockedTarget != none)
    {
        if(LockedTarget.bDeleteMe)
        {
            AdjustLockTarget(none);
        }
    }
    BestTarget = none;
    Instigator.Controller.GetPlayerViewPoint(StartTrace, AimRot);
    Aim = vector(AimRot);
    EndTrace = StartTrace + (Aim * LockRange);
    HitActor = Trace(HitLocation, HitNormal, EndTrace, StartTrace, true,,, 1);
    if((HitActor == none) || !CanLockOnTo(HitActor))
    {
        bestAim = LockAim;
        bestDist = 0;
        TA = Instigator.Controller.PickTarget(Class'Pawn', bestAim, bestDist, Aim, StartTrace, LockRange, true);
        if((TA != none) && CanLockOnTo(TA))
        {
            HitActor = Trace(HitLocation, HitNormal, TA.Location, StartTrace, true,,, 1);
            if((KFFracturedMeshActor(HitActor) != none) || KFDestructibleActor(HitActor) != none)
            {
                BestTarget = none;                
            }
            else
            {
                BestTarget = TA;
            }
        }        
    }
    else
    {
        BestTarget = HitActor;
    }
    if(BestTarget != none)
    {
        if(BestTarget == LockedTarget)
        {
            LockedOnTimeout = LockTolerance;            
        }
        else
        {
            if(PendingLockedTarget != BestTarget)
            {
                PendingLockedTarget = BestTarget;
                PendingLockTimeout = LockTolerance;
                PendingLockAcquireTimeLeft = LockAcquireTime;
                if(OpticsUI != none)
                {
                    OpticsUI.StartLockOn();
                }
                if(bUsingSights)
                {
                    ClientPlayTargetingSound(LockTargetingSoundFirstPerson);
                }
            }
        }
        if(PendingLockedTarget != none)
        {
            PendingLockAcquireTimeLeft -= LockCheckTime;
            if((PendingLockedTarget == BestTarget) && PendingLockAcquireTimeLeft <= float(0))
            {
                AdjustLockTarget(PendingLockedTarget);
                PendingLockedTarget = none;
            }
        }        
    }
    else
    {
        if(PendingLockedTarget != none)
        {
            PendingLockTimeout -= LockCheckTime;
            if((PendingLockTimeout <= float(0)) || !CanLockOnTo(PendingLockedTarget))
            {
                PendingLockedTarget = none;
                if(OpticsUI != none)
                {
                    OpticsUI.ClearLockOn();
                }
            }
        }
    }
    if((LockedTarget != none) && BestTarget != LockedTarget)
    {
        LockedOnTimeout -= LockCheckTime;
        if((LockedOnTimeout <= 0) || !CanLockOnTo(LockedTarget))
        {
            AdjustLockTarget(none);
        }
    }
}

unreliable client simulated function ClientPlayTargetingSound(AkBaseSoundObject Sound)
{
    if((Sound != none) && !bSuppressSounds)
    {
        if((Instigator != none) && Instigator.IsHumanControlled())
        {
            PlaySoundBase(Sound, true);
        }
    }
}

simulated function PlayFiringSound(byte FireModeNum)
{
    if(!bPlayingLoopingFireSnd)
    {
        if((FireModeNum == 1) && bRechargeHealAmmo)
        {
            WeaponPlayFireSound(DartFireSnd.DefaultCue, DartFireSnd.FirstPersonCue);            
        }
        else
        {
            super(KFWeapon).PlayFiringSound(FireModeNum);
            return;
        }
    }
    MakeNoise(1, 'PlayerFiring');
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        return ((bUsingSights) ? 'Shoot_Iron_Dart' : 'Shoot_Dart');
    }
    return super(KFWeapon).GetWeaponFireAnim(FireModeNum);
}

reliable client simulated function ClientWeaponSet(bool bOptionalSet, optional bool bDoNotActivate)
{
    local KFInventoryManager KFIM;

    super(KFWeapon).ClientWeaponSet(bOptionalSet, bDoNotActivate);
    if(OpticsUI == none)
    {
        KFIM = KFInventoryManager(InvManager);
        if(KFIM != none)
        {
            OpticsUI = KFGFxWorld_MedicOptics(KFIM.GetOpticsUIMovie(OpticsUIClass));
        }
    }
    StartHealRecharge();
}

function ItemRemovedFromInvManager()
{
    local KFInventoryManager KFIM;

    super(KFWeapon).ItemRemovedFromInvManager();
    if(OpticsUI != none)
    {
        KFIM = KFInventoryManager(InvManager);
        if(KFIM != none)
        {
            KFIM.RemoveOpticsUIMovie(OpticsUI.Class);
            OpticsUI.Close();
            OpticsUI = none;
        }
    }
}

simulated function AttachWeaponTo(SkeletalMeshComponent MeshCpnt, optional name SocketName)
{
    super(KFWeapon).AttachWeaponTo(MeshCpnt, SocketName);
    if(OpticsUI != none)
    {
        OpticsUI.SetPause(false);
        OpticsUI.ClearLockOn();
        UpdateOpticsUI(true);
        OpticsUI.SetShotPercentCost(float(AmmoCost[1]));
    }
}

simulated function DetachWeapon()
{
    local Pawn OwnerPawn;

    super.DetachWeapon();
    OwnerPawn = Pawn(Owner);
    if((OwnerPawn != none) && OwnerPawn.Weapon == self)
    {
        if(OpticsUI != none)
        {
            OpticsUI.SetPause();
        }
    }
}

simulated function UpdateOpticsUI(optional bool bForceUpdate)
{
    if((OpticsUI != none) && OpticsUI.OpticsContainer != none)
    {
        if((AmmoCount[0] != StoredPrimaryAmmo) || bForceUpdate)
        {
            StoredPrimaryAmmo = AmmoCount[0];
            OpticsUI.SetPrimaryAmmo(StoredPrimaryAmmo);
        }
        if((AmmoCount[1] != StoredSecondaryAmmo) || bForceUpdate)
        {
            StoredSecondaryAmmo = AmmoCount[1];
            OpticsUI.SetHealerCharge(StoredSecondaryAmmo);
        }
        if(OpticsUI.MinPercentPerShot != float(AmmoCost[1]))
        {
            OpticsUI.SetShotPercentCost(float(AmmoCost[1]));
        }
    }
}

static simulated event SetTraderWeaponStats(out array<STraderItemWeaponStats> WeaponStats)
{
    super(KFWeapon).SetTraderWeaponStats(WeaponStats);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 8;
    WeaponStats[WeaponStats.Length - 1].StatValue = float(default.HealAmount);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 9;
    WeaponStats[WeaponStats.Length - 1].StatValue = default.HealFullRechargeSeconds;
}

simulated function int GetSecondaryAmmoForHUD()
{
    return AmmoCount[1];
}

simulated state WeaponSingleFiring
{
    simulated function FireAmmunition()
    {
        if(CurrentFireMode == 1)
        {
            SetWeakZedGrabCooldownOnPawn(HealDartShotWeakZedGrabCooldown);
            StartHealRecharge();
        }
        super.FireAmmunition();
    }
    stop;    
}

auto simulated state Inactive
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(Role == ROLE_Authority)
        {
            bTargetLockingActive = false;
            AdjustLockTarget(none);
            ClearTimer('CheckTargetLock');
        }
        PendingLockedTarget = none;
    }

    simulated function EndState(name NextStateName)
    {
        super(Object).EndState(NextStateName);
        if(Role == ROLE_Authority)
        {
            bTargetLockingActive = true;
            SetTimer(LockCheckTime, true, 'CheckTargetLock');
        }
    }
    stop;    
}

simulated state WeaponSprinting
{
    ignores AllowTargetLockOn;
    stop;    
}

defaultproperties
{
    HealingDartDamageType=Class'KFDT_Dart_Healing'
    HealAmount=20
    HealFullRechargeSeconds=12
    HealImpactSoundPlayEvent=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Heal'
    HurtImpactSoundPlayEvent=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Hurt'
    DartFireSnd=(DefaultCue=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Shoot_3P',FirstPersonCue=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Shoot_1P')
    HealDartShotWeakZedGrabCooldown=0.5
    DartMaxRecoilPitch=250
    DartMinRecoilPitch=200
    DartMaxRecoilYaw=100
    DartMinRecoilYaw=-100
    HealingDartWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Default_Recoil'
    HealingDartAmmo=100
    LockCheckTime=0.1
    LockRange=50000
    LockAcquireTime=0.2
    LockTolerance=0.2
    bRechargeHealAmmo=true
    LockAim=0.98
    LockAcquiredSoundFirstPerson=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Alert_Locked_1P'
    LockLostSoundFirstPerson=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Alert_Lost_1P'
    LockTargetingSoundFirstPerson=AkEvent'WW_WEP_Cryo_Gun.Play_WEP_HRG_Healthrower_MedicDart_Alert_Locking_1P'
    OpticsUIClass=Class'KFGame.KFGFxWorld_MedicOptics'
    bWarnAIWhenFiring=true
    FlameSprayArchetype=SprayActor_Heal'WEP_Healthrower_ARCH.WEP_Healthrower_Spray'
    begin object name=PilotLight0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_HRG_Healthrower.PilotLight0'
    PSC_PilotLight=PilotLight0
    PilotLightSocketName=FXPilot1
    begin object name=FlameEndSpray0 class=KFParticleSystemComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFParticleSystemComponent'Default__KFWeap_HRG_Healthrower.FlameEndSpray0'
    PSC_EndSpray=FlameEndSpray0
    MinAmmoConsumed=4
    PackageKey="Healthrower"
    FirstPersonMeshName="WEP_1P_HRG_Healthrower_MESH.Wep_1stP_HRG_Healthrower_Rig"
    FirstPersonAnimSetNames=/* Array type was not detected. */
    PickupMeshName="WEP_3P_HRG_Healthrower_MESH.Wep_HRG_Healthrower_Pickup"
    AttachmentArchetypeName="WEP_Healthrower_ARCH.Wep_HEALTHROWER_3P"
    MuzzleFlashTemplateName="WEP_Healthrower_ARCH.Wep_Healthrower_MuzzleFlash"
    bHasIronSights=true
    bCanRefillSecondaryAmmo=false
    bCanBeReloaded=true
    bReloadFromMagazine=true
    FireModeIconPaths=/* Array type was not detected. */
    InventorySize=7
    MagazineCapacity[0]=100
    MagazineCapacity[1]=100
    AimCorrectionSize=40
    MeshIronSightFOV=52
    PlayerIronSightFOV=80
    IronSightPosition=(X=20,Y=8,Z=-3)
    QuickWeaponDownRotation=(Pitch=-8192,Yaw=0,Roll=0)
    DOF_FG_FocalRadius=150
    DOF_FG_MaxNearBlurSize=1
    GroupPriority=75
    WeaponSelectTexture=Texture2D'Wep_UI_HRG_Healthrower_TEX.UI_WeaponSelect_HRG_Healthrower'
    SecondaryAmmoTexture=Texture2D'UI_SecondaryAmmo_TEX.MedicDarts'
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCapacity=500
    InitialSpareMags=1
    AmmoPickupScale=0.4
    WeaponFireWaveForm=ForceFeedbackWaveform'FX_ForceFeedback_ARCH.Gunfire.Weak_Recoil'
    bLoopingFireAnim=/* Array type was not detected. */
    bLoopingFireSnd=/* Array type was not detected. */
    FireSightedAnims=/* Array type was not detected. */
    FireLoopSightedAnim=ShootLoop
    FireLoopStartSightedAnim=ShootLoop_Start
    FireLoopEndSightedAnim=ShootLoop_End
    WeaponFireSnd=/* Array type was not detected. */
    WeaponFireLoopEndSnd=/* Array type was not detected. */
    WeaponDryFireSnd=/* Array type was not detected. */
    PlayerViewOffset=(X=6,Y=15,Z=-5)
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_HRG_Healthrower.MeleeHelper'
    maxRecoilPitch=150
    minRecoilPitch=115
    maxRecoilYaw=115
    minRecoilYaw=-115
    RecoilRate=0.085
    RecoilViewRotationScale=0.25
    RecoilMaxYawLimit=500
    RecoilMinYawLimit=65035
    RecoilMaxPitchLimit=900
    RecoilMinPitchLimit=65035
    RecoilISMaxYawLimit=75
    RecoilISMinYawLimit=65460
    RecoilISMaxPitchLimit=375
    RecoilISMinPitchLimit=65460
    HippedRecoilModifier=1.5
    IronSightMeshFOVCompensationScale=1.5
    AssociatedPerkClasses=/* Array type was not detected. */
    WeaponUpgrades=/* Array type was not detected. */
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamage=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    FireOffset=(X=30,Y=4.5,Z=-5)
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_HRG_Healthrower.FirstPersonMesh'
    Mesh=FirstPersonMesh
    ItemName="HRG Healthrower"
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Healthrower.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_HRG_Healthrower.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}