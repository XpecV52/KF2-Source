/*******************************************************************************
 * KFExplosion_MedicGrenade generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFExplosion_MedicGrenade extends KFExplosionActorLingering
    config(Weapon)
    hidecategories(Navigation);

var() class<KFDamageType> HealingDamageType;
var() float HealingAmount;
var AkEvent SmokeLoopStartEvent;
var AkEvent SmokeLoopStopEvent;
var KFPerk CachedInstigatorPerk;

simulated function Explode(GameExplosion NewExplosionTemplate, optional Vector Direction)
{
    local KFPawn KFP;

    super.Explode(NewExplosionTemplate, Direction);
    if(Instigator != none)
    {
        KFP = KFPawn(Instigator);
        if(KFP != none)
        {
            CachedInstigatorPerk = KFP.GetPerk();
        }
    }
    if(Role == ROLE_Authority)
    {
        SetTimer(interval, true, 'DelayedExplosionDamage', self);
    }
}

protected simulated function AffectsPawn(Pawn Victim, float DamageScale)
{
    local KFPawn_Human HumanVictim;
    local KFPawn_Monster MonsterVictim;
    local KFProj_MedicGrenade OwnerProjectile;
    local bool bCanRepairArmor;
    local Box BBox;
    local Vector BBoxCenter;
    local Actor HitActor;
    local bool bDamageBlocked;

    if((Victim != none) && Victim.IsAliveAndWell())
    {
        MonsterVictim = KFPawn_Monster(Victim);
        if(MonsterVictim != none)
        {
            if((bWasFadedOut || bDeleteMe) || bPendingDelete)
            {
                return;
            }
            Victim.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            HitActor = TraceExplosive(BBoxCenter, Location + vect(0, 0, 20));
            bDamageBlocked = (HitActor != none) && HitActor != Victim;
            if(bDamageBlocked && HitActor.IsA('KFDoorActor'))
            {
                bDamageBlocked = false;
            }
            if(!bDamageBlocked)
            {
                Victim.TakeRadiusDamage(InstigatorController, ExplosionTemplate.Damage * DamageScale, ExplosionTemplate.DamageRadius, ExplosionTemplate.MyDamageType, ExplosionTemplate.MomentumTransferScale, Location, bDoFullDamage, ((Owner != none) ? Owner : self), ExplosionTemplate.DamageFalloffExponent);
            }            
        }
        else
        {
            HumanVictim = KFPawn_Human(Victim);
            if((HumanVictim != none) && HumanVictim.GetExposureTo(Location) > float(0))
            {
                OwnerProjectile = KFProj_MedicGrenade(Owner);
                if(OwnerProjectile != none)
                {
                    bCanRepairArmor = OwnerProjectile.HealedPawns.Find(HumanVictim == -1;
                }
                HumanVictim.HealDamage(int(HealingAmount), InstigatorController, HealingDamageType, bCanRepairArmor);
                if(bCanRepairArmor)
                {
                    OwnerProjectile.HealedPawns.AddItem(HumanVictim;
                }
            }
        }
    }
}

simulated function SpawnExplosionParticleSystem(ParticleSystem Template)
{
    if(!ExplosionTemplate.bAllowPerMaterialFX && Template == none)
    {
        Template = KFGameExplosion(ExplosionTemplate).ExplosionEffects.DefaultImpactEffect.ParticleTemplate;
    }
    WorldInfo.MyEmitterPool.SpawnEmitter(Template, Location, rotator(ExplosionTemplate.HitNormal));
}

defaultproperties
{
    HealingDamageType=Class'KFDT_Healing_MedicGrenade'
    HealingAmount=5
    interval=1
    maxTime=8
    bSkipLineCheckForPawns=true
    bDoFullDamage=true
    LoopStartEvent=AkEvent'WW_WEP_EXP_Grenade_Medic.Play_WEP_EXP_Grenade_Medic_Smoke_Loop'
    LoopStopEvent=AkEvent'WW_WEP_EXP_Grenade_Medic.Stop_WEP_EXP_Grenade_Medic_Smoke_Loop'
}