/*******************************************************************************
 * KFMG_BloatDunk generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFMG_BloatDunk extends KFMG_TargetGame
    placeable
    hidecategories(Navigation);

enum eBloatGameState
{
    BGS_Off,
    BGS_On,
    BGS_Victory,
    BGS_Defeat,
    BGS_MAX
};

/** Archetype of target actor that will be spawned per-bone */
var() Actor TargetArchetype;
/** Two rigs used for alternately rotating wheels */
var() KFMGA_TargetGame OuterWheel;
var() KFMGA_TargetGame InnerWheel;
/** Dunk tank rig for handling curtain/dunk board */
var() SkeletalMeshActor DunkTankRig;
/** Bloat being dunked */
var() SkeletalMeshActor BloatRig;
/** How often to activate a new set of targets */
var() float TargetActivationDelay;
/** How fast to begin rotation */
var() float StartingRotationRate;
/** How much to increase rotation per-target hit */
var() float PerHitRotationIncrease;
/** How many targets to activate per attempt */
var() int NumActiveTargets;
var float CurrentRotationRate;
var int TargetsRemaining;
var repnotify KFMG_BloatDunk.eBloatGameState BloatGameState;
/** Standard idle while game is off */
var() name IdleClosedAnim;
/** Standard idle while game is being played */
var() name IdleOpenAnim;
/** Animation played on game start */
var() name OpenAnim;
/** Played on victory to dunk the bloat */
var() name DunkVictoryAnim;
/** Victory close animation */
var() name VictoryCloseAnim;
/** Defeat close animation */
var() name DefeatCloseAnim;

replication
{
     if(bNetInitial)
        BloatRig, DunkTankRig, 
        InnerWheel, OuterWheel;

     if(bNetDirty)
        BloatGameState, CurrentRotationRate;
}

simulated event ReplicatedEvent(name VarName)
{
    super(Actor).ReplicatedEvent(VarName);
    if(VarName == 'bGameRunning')
    {
        if(bGameRunning)
        {
            HandleDelayedStartup();
        }
    }
    if((VarName == 'bGameRunning') || VarName == 'BloatGameState')
    {
        if(!bGameRunning && BloatGameState > 1)
        {
            FinalizeGame();
        }
    }
}

simulated event Tick(float DeltaTime)
{
    local Rotator NewRotation;

    super(Actor).Tick(DeltaTime);
    if(bGameRunning)
    {
        NewRotation = OuterWheel.Rotation;
        NewRotation.Pitch = int((float(NewRotation.Pitch) + (CurrentRotationRate * DeltaTime)) % float(65536));
        OuterWheel.SetRotation(NewRotation);
        NewRotation = InnerWheel.Rotation;
        NewRotation.Pitch = int((float(NewRotation.Pitch) - (CurrentRotationRate * DeltaTime)) % float(65536));
        InnerWheel.SetRotation(NewRotation);
    }
}

event PostBeginPlay()
{
    local name BoneName;

    super(Actor).PostBeginPlay();
    if(((InnerWheel != none) && OuterWheel != none) && TargetArchetype != none)
    {
        foreach InnerWheel.TargetBones(BoneName,)
        {
            SpawnTarget(InnerWheel, BoneName);            
        }        
        foreach OuterWheel.TargetBones(BoneName,)
        {
            SpawnTarget(OuterWheel, BoneName);            
        }        
    }
    Reset();
}

function SpawnTarget(KFMGA_TargetGame Wheel, name BoneName)
{
    local Actor NewTarget;
    local KFMGA_Target RiggedTarget;

    NewTarget = Spawn(TargetArchetype.Class, self,,,, TargetArchetype);
    if(NewTarget != none)
    {
        MinigameTargets.AddItem(NewTarget;
        NewTarget.SetBase(Wheel,, Wheel.SkeletalMeshComponent, BoneName);
        RiggedTarget = KFMGA_Target(NewTarget);
        if(RiggedTarget != none)
        {
            RiggedTarget.SetInactive();
            RiggedTarget.SpawnerOwner = self;
            RiggedTarget.SpawnerOwnerIndex = MinigameTargets.Length - 1;
            UpdateBase(RiggedTarget);
        }
    }
}

function Activated(KFTrigger_MinigameButton ActivationSource)
{
    if(MinigameTargets.Length == (OuterWheel.TargetBones.Length + InnerWheel.TargetBones.Length))
    {
        super.Activated(ActivationSource);
        BloatGameState = 1;
        TargetsRemaining = MinigameTargets.Length;
        HandleDelayedStartup();
    }
}

simulated function Reset()
{
    super(Actor).Reset();
    CurrentRotationRate = 0;
    BloatRig.SkeletalMeshComponent.StopAnim();
}

simulated function HandleDelayedStartup()
{
    local float AnimLength;
    local int I;
    local Vector NewLocation;
    local Rotator NewRotation;

    InnerWheel.SetTickIsDisabled(false);
    I = 0;
    J0x2B:

    if(I < InnerWheel.TargetBones.Length)
    {
        MinigameTargets[I].Reset();
        MinigameTargets[I].SetBase(InnerWheel,, InnerWheel.SkeletalMeshComponent, InnerWheel.TargetBones[I]);
        ++ I;
        goto J0x2B;
    }
    OuterWheel.SetTickIsDisabled(false);
    I = 0;
    J0x12C:

    if(I < OuterWheel.TargetBones.Length)
    {
        MinigameTargets[InnerWheel.TargetBones.Length + I].Reset();
        MinigameTargets[InnerWheel.TargetBones.Length + I].SetBase(OuterWheel,, OuterWheel.SkeletalMeshComponent, OuterWheel.TargetBones[I]);
        ++ I;
        goto J0x12C;
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && BloatRig != none)
    {
        if(DunkTankRig.SkeletalMeshComponent.GetSocketWorldLocationAndRotation('BloatAttach', NewLocation, NewRotation))
        {
            BloatRig.SetLocation(NewLocation);
            BloatRig.SetRotation(NewRotation);
        }
        BloatRig.SetPhysics(0);
        BloatRig.SetBase(DunkTankRig,, DunkTankRig.SkeletalMeshComponent, 'Root');
        BloatRig.SkeletalMeshComponent.PlayAnim('BloatDunk_Idle',, true);
    }
    if(DunkTankRig != none)
    {
        AnimLength = DunkTankRig.SkeletalMeshComponent.GetAnimLength(OpenAnim);
        if(AnimLength > 0)
        {
            SetTimer(AnimLength, false, 'StartupGame');
            if(WorldInfo.NetMode != NM_DedicatedServer)
            {
                DunkTankRig.SkeletalMeshComponent.PlayAnim(OpenAnim);
            }            
        }
        else
        {
            StartupGame();
        }        
    }
    else
    {
        StartupGame();
    }
}

simulated function StartupGame()
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        DunkTankRig.SkeletalMeshComponent.PlayAnim(IdleOpenAnim,, true);
    }
    if(Role == ROLE_Authority)
    {
        CurrentRotationRate = StartingRotationRate;
        ActivateTargets();
        SetTimer(TargetActivationDelay, true, 'ActivateTargets');
    }
}

function ActivateTargets()
{
    local int I, Activated;
    local array<Actor> RandLookupList;

    I = 0;
    J0x0B:

    if(I < MinigameTargets.Length)
    {
        if(KFMGA_Target(MinigameTargets[I]) != none)
        {
            KFMGA_Target(MinigameTargets[I]).SetInactive();
        }
        ++ I;
        goto J0x0B;
    }
    RandLookupList = MinigameTargets;
    J0x98:

    if((RandLookupList.Length > 0) && Activated < NumActiveTargets)
    {
        I = Rand(RandLookupList.Length);
        if(KFMGA_Target(RandLookupList[I]).IsAlive())
        {
            ++ Activated;
            KFMGA_Target(RandLookupList[I]).SetActive();
        }
        RandLookupList.Remove(I, 1;
        goto J0x98;
    }
}

function TargetHit(Actor Target, Controller HitInstigator)
{
    if(bGameRunning && MinigameTargets.Find(Target != -1)
    {
        -- TargetsRemaining;
        CurrentRotationRate += PerHitRotationIncrease;
        if((HitInstigator != none) && KillerControllers.Find(HitInstigator == -1)
        {
            KillerControllers.AddItem(HitInstigator;
        }
        if(TargetsRemaining <= 0)
        {
            MinigameComplete(true);
        }
    }
}

simulated function UpdateBase(KFMGA_Target Target)
{
    if(Target.SpawnerOwnerIndex < InnerWheel.TargetBones.Length)
    {
        Target.SetBase(InnerWheel,, InnerWheel.SkeletalMeshComponent, InnerWheel.TargetBones[Target.SpawnerOwnerIndex]);        
    }
    else
    {
        Target.SetBase(OuterWheel,, OuterWheel.SkeletalMeshComponent, OuterWheel.TargetBones[Target.SpawnerOwnerIndex - InnerWheel.TargetBones.Length]);
    }
}

function MinigameComplete(bool bVictory)
{
    BloatGameState = ((bVictory) ? 2 : 3);
    super.MinigameComplete(bVictory);
}

simulated function FinalizeGame()
{
    local Actor Target;

    super.FinalizeGame();
    ClearTimer('ActivateTargets');
    foreach MinigameTargets(Target,)
    {
        if(KFMGA_Target(Target) != none)
        {
            KFMGA_Target(Target).SetInactive();
        }        
    }    
    InnerWheel.SetTickIsDisabled(false);
    OuterWheel.SetTickIsDisabled(false);
    HandleDelayedShutdown();
}

simulated function HandleDelayedShutdown()
{
    local float DelayTime;
    local name DelayedShutdownAnim;

    switch(BloatGameState)
    {
        case 2:
            DelayTime = DunkTankRig.SkeletalMeshComponent.GetAnimLength(DunkVictoryAnim);
            DelayedShutdownAnim = DunkVictoryAnim;
            SetTimer(DelayTime * 2, false, 'FinalizeVictory');
            break;
        case 3:
            DelayTime = DunkTankRig.SkeletalMeshComponent.GetAnimLength(DefeatCloseAnim);
            DelayedShutdownAnim = DefeatCloseAnim;
            SetTimer(DelayTime, false, 'Reset');
            break;
        default:
            break;
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        DunkTankRig.SkeletalMeshComponent.PlayAnim(DelayedShutdownAnim);
        if(BloatGameState == 2)
        {
            SetBloatRagdoll();
        }
    }
}

simulated function SetBloatRagdoll()
{
    if(BloatRig == none)
    {
        return;
    }
    BloatRig.SkeletalMeshComponent.StopAnim();
    BloatRig.SkeletalMeshComponent.bUpdateSkelWhenNotRendered = true;
    if(BloatRig.SkeletalMeshComponent.bNotUpdatingKinematicDueToDistance)
    {
        BloatRig.SkeletalMeshComponent.ForceSkelUpdate();
        BloatRig.SkeletalMeshComponent.UpdateRBBonesFromSpaceBases(true, true);
        BloatRig.SkeletalMeshComponent.SetBlockRigidBody(true);
    }
    BloatRig.SkeletalMeshComponent.PhysicsWeight = 1;
    BloatRig.SkeletalMeshComponent.SetHasPhysicsAssetInstance(true);
    BloatRig.SetPhysics(10);
    BloatRig.SkeletalMeshComponent.PhysicsAssetInstance.SetAllBodiesFixed(false);
    BloatRig.SkeletalMeshComponent.WakeRigidBody();
    BloatRig.SkeletalMeshComponent.SetActorCollision(true, false);
    BloatRig.SkeletalMeshComponent.bUpdateJointsFromAnimation = false;
    BloatRig.SkeletalMeshComponent.SetRBChannel(22);
    BloatRig.SkeletalMeshComponent.SetRBCollidesWithChannel(22, true);
    BloatRig.SkeletalMeshComponent.SetRBCollidesWithChannel(2, false);
    BloatRig.SkeletalMeshComponent.SetRBCollidesWithChannel(16, false);
}

simulated function FinalizeVictory()
{
    local float ResetTime;

    ResetTime = DunkTankRig.SkeletalMeshComponent.GetAnimLength(VictoryCloseAnim);
    if(ResetTime > 0)
    {
        SetTimer(ResetTime, false, 'Reset');        
    }
    else
    {
        Reset();
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        DunkTankRig.SkeletalMeshComponent.PlayAnim(VictoryCloseAnim);
    }
}

defaultproperties
{
    TargetActivationDelay=2
    StartingRotationRate=500
    PerHitRotationIncrease=100
    NumActiveTargets=2
    IdleClosedAnim=Idle_Close
    IdleOpenAnim=Idle_Open
    OpenAnim=Open
    DunkVictoryAnim=Dunk
    VictoryCloseAnim=Close_Win
    DefeatCloseAnim=Close_lost
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFMG_BloatDunk.Sprite'
    Components(0)=Sprite
}