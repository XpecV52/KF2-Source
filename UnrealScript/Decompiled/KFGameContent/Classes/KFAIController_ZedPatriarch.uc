/*******************************************************************************
 * KFAIController_ZedPatriarch generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFAIController_ZedPatriarch extends KFAIController_ZedBoss
    config(AI)
    hidecategories(Navigation);

struct Patriarch_TrackedEnemyInfo
{
    var KFPawn TrackedEnemy;
    var float LastTimeVisible;
    var Vector LastVisibleLocation;
    var float LastTakeDamageTime;
    var int AggroDamage;

    structdefaultproperties
    {
        TrackedEnemy=none
        LastTimeVisible=0
        LastVisibleLocation=(X=0,Y=0,Z=0)
        LastTakeDamageTime=0
        AggroDamage=0
    }
};

var KFPawn_ZedPatriarch MyPatPawn;
var bool bCanEvaluateAttacks;
var bool bDoingChargeAttack;
var bool bWantsToCharge;
var bool bHadMinigunAttack;
var bool bSprintUntilAttack;
var bool bRaging;
var bool bRagedThisPhase;
var bool bWantsToFlee;
var bool bFleeing;
var bool bFleeInterrupted;
var float LostSightSprintDelay;
var float AggroFalloffWaitTime;
var float AggroFalloffPerSecond;
var float VisibleAggroDmgThreshold;
var float HiddenAggroDmgThreshold;
var array<Patriarch_TrackedEnemyInfo> RecentlySeenEnemyList;
var array<Patriarch_TrackedEnemyInfo> HiddenEnemies;
var array<KFPawn> LastMinigunEnemies;
var float MinMinigunRangeSQ;
var float MaxMinigunRangeSQ;
var float MaxFanFireRangeSQ;
var array<KFPawn> LastChargedPlayers;
var float MinChargeRangeSQ;
var float LastChargeAttackTime;
var Pawn CachedChargeTarget;
var array<KFPawn> LastGrabbedPlayers;
var float LastGrabAttackTime;
var float MinTentacleRangeSQ;
var array<KFPawn> LastMissileEnemies;
var float LastMissileAttackTime;
var float MinMissileRangeSQ;
var float MaxMissileRangeSQ;
var float LastMortarAttackTime;
var float LastSuccessfulAttackTime;
/** How often to update RecentlySeenEnemyList */
var() float RecentSeenEnemyListUpdateInterval;
var float LastRecentSeenEnemyListUpdateTime;
var float LastAttackMoveFinishTime;
var float NextAttackCheckTime;
var float LastSprintTime;
var float LastRetargetTime;
var float RetargetWaitTime;
var int MaxRageAttacks;
var int RageAttackCount;
var float MaxRageRangeSQ;
var float RageTimeOut;
var array<KFPawn> RageAttackedTargets;
var int HumanBumpDamage;
var int HumanBumpMomentum;
var float FleeHealthThreshold;
var float MaxFleeDuration;
var float MaxFleeDistance;
var float FleeStartTime;
var float TotalFleeTime;

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    if(KFPawn_ZedPatriarch(inPawn) != none)
    {
        MyPatPawn = KFPawn_ZedPatriarch(inPawn);        
    }
    else
    {
        WarnInternal(((string(GetFuncName()) $ "() attempting to possess ") $ string(inPawn)) $ ", but it's not a KFPawn_ZedPatriarchBase class! MyPatPawn variable will not be valid.");
    }
    LastRetargetTime = WorldInfo.TimeSeconds;
    LastSprintTime = WorldInfo.TimeSeconds;
    LastSuccessfulAttackTime = WorldInfo.TimeSeconds;
    LastGrabAttackTime = WorldInfo.TimeSeconds;
    LastMissileAttackTime = WorldInfo.TimeSeconds;
    LastMortarAttackTime = WorldInfo.TimeSeconds;
    NextAttackCheckTime = 2.5 + FRand();
    bCanEvaluateAttacks = true;
    super.Possess(inPawn, bVehicleTransition);
}

function PawnDied(Pawn inPawn)
{
    if(MyPatPawn != none)
    {
        MyPatPawn = none;
    }
    super(KFAIController).PawnDied(inPawn);
}

simulated event Destroyed()
{
    if(MyPatPawn != none)
    {
        MyPatPawn.ClearMortarTargets();
    }
    MyPatPawn = none;
    MyKFGameInfo.SpawnManager.StopSummoningBossMinions();
    super(KFAIController).Destroyed();
}

function bool IsAggroEnemySwitchAllowed()
{
    return ((super(KFAIController).IsAggroEnemySwitchAllowed() && !MyPatPawn.IsDoingSpecialMove(20)) && !MyPatPawn.IsDoingSpecialMove(21)) && !MyPatPawn.IsDoingSpecialMove(3);
}

function bool CanSwitchEnemies()
{
    return ((((((!bWantsToFlee && !bFleeing) && MyPatPawn != none) && !MyPatPawn.bIsCloaking) && !MyPatPawn.IsDoingSpecialMove(17)) && !MyPatPawn.IsDoingSpecialMove(20)) && !MyPatPawn.IsDoingSpecialMove(19)) && !MyPatPawn.IsDoingSpecialMove(3);
}

function float GetAggroRating(KFPawn KFP)
{
    local int EnemyIndex;
    local float AggroDmg;

    EnemyIndex = RecentlySeenEnemyList.Find('TrackedEnemy', KFP;
    if(EnemyIndex != -1)
    {
        AggroDmg = float(RecentlySeenEnemyList[EnemyIndex].AggroDamage);
        if(AggroDmg > 0)
        {
            return FMin(AggroDmg / VisibleAggroDmgThreshold, 1);            
        }
        else
        {
            return 0;
        }        
    }
    else
    {
        EnemyIndex = HiddenEnemies.Find('TrackedEnemy', KFP;
        if(EnemyIndex != -1)
        {
            AggroDmg = float(HiddenEnemies[EnemyIndex].AggroDamage);
            if(AggroDmg > 0)
            {
                return FMin(AggroDmg / HiddenAggroDmgThreshold, 1);                
            }
            else
            {
                return 0;
            }            
        }
        else
        {
            return 0.5;
        }
    }
    return 1;
}

event bool FindNewEnemy()
{
    if(!CanSwitchEnemies())
    {
        return false;
    }
    return super(KFAIController).FindNewEnemy();
}

event bool SetEnemy(Pawn NewEnemy)
{
    if(!CanSwitchEnemies())
    {
        return false;
    }
    return super.SetEnemy(NewEnemy);
}

function ForceSetEnemy(Pawn NewEnemy)
{
    SetEnemy(NewEnemy);
}

event ChangeEnemy(Pawn NewEnemy, optional bool bCanTaunt)
{
    local Pawn OldEnemy;

    bCanTaunt = true;
    if(!CanSwitchEnemies())
    {
        return;
    }
    OldEnemy = Enemy;
    super(KFAIController).ChangeEnemy(NewEnemy, !MyPatPawn.bIsCloaking && bCanTaunt);
    if(OldEnemy != Enemy)
    {
        LastRetargetTime = WorldInfo.TimeSeconds;
    }
}

function bool SetBestTarget(out array<KFPawn> RecentTargets, optional float MinDistSQ, optional float MaxDistSQ, optional float ClampFOV, optional bool bPreferFurtherTargets, optional bool bIsWeaponAttack)
{
    local KFPawn_Human KFPH;
    local KFPawn KFP, BestTarget;
    local int I, FoundIndex, BestIndex;
    local float TempRating, BestRating;
    local Vector TempDist;

    MinDistSQ = -1;
    MaxDistSQ = -1;
    ClampFOV = -1;        
    I = 0;
    J0x28:

    if(I < RecentTargets.Length)
    {
        if((RecentTargets[I] == none) || !RecentTargets[I].IsAliveAndWell())
        {
            RecentTargets.Remove(I, 1;
            -- I;
        }
        ++ I;
        goto J0x28;
    }
    if((RecentTargets.Length == 0) || WorldInfo.NetMode == NM_Standalone)
    {
        if(Enemy == none)
        {
            ChangeEnemy(GetClosestEnemy(), false);
        }
        if(Enemy == none)
        {
            return false;
        }
        TempRating = VSizeSq(MyPatPawn.Location - Enemy.Location);
        if(((MinDistSQ >= 0) && TempRating < MinDistSQ) || (MaxDistSQ > 0) && TempRating > MaxDistSQ)
        {
            return false;
        }
        if(bIsWeaponAttack && !IsWeaponArmClear(Enemy.Location))
        {
            return false;
        }
        KFP = KFPawn(Enemy);
        FoundIndex = RecentTargets.Find(KFP;
        if(FoundIndex == -1)
        {
            RecentTargets[RecentTargets.Length] = KFP;
        }
        return true;
    }
    foreach WorldInfo.AllPawns(Class'KFPawn_Human', KFPH)
    {
        if((KFPH != none) && KFPH.IsAliveAndWell())
        {
            TempDist = KFPH.Location - MyPatPawn.Location;
            TempRating = VSizeSq(TempDist);
            if(((MinDistSQ >= 0) && TempRating < MinDistSQ) || (MaxDistSQ > 0) && TempRating > MaxDistSQ)
            {
                continue;                
            }
            if((vector(Pawn.Rotation) Dot Normal(TempDist)) < ClampFOV)
            {
                continue;                
            }
            if(bIsWeaponAttack && !IsWeaponArmClear(KFPH.Location))
            {                
                return false;
            }
            FoundIndex = RecentTargets.Find(KFPH;
            if(FoundIndex != -1)
            {
                TempRating *= ((bPreferFurtherTargets) ? 2.5 + (2.5 * (FMax(float(FoundIndex), 1) / float(RecentTargets.Length))) : 1 - (0.5 * (FMax(float(FoundIndex), 1) / float(RecentTargets.Length))));
            }
            if(RecentlySeenEnemyList.Find('TrackedEnemy', KFPH == -1)
            {
                TempRating *= ((bPreferFurtherTargets) ? 0.5 : 2);
            }
            TempRating *= ((bPreferFurtherTargets) ? 0.5 + (0.5 * (GetAggroRating(KFPH))) : 1 - (0.5 * (GetAggroRating(KFPH))));
            if((BestRating == 0) || (bPreferFurtherTargets && TempRating > BestRating) || !bPreferFurtherTargets && TempRating < BestRating)
            {
                BestTarget = KFPH;
                BestRating = TempRating;
                BestIndex = FoundIndex;
            }
        }        
    }    
    if(BestTarget != none)
    {
        ChangeEnemy(BestTarget, false);
        if(BestIndex != -1)
        {
            RecentTargets.Remove(BestIndex, 1;
        }
        RecentTargets[RecentTargets.Length] = BestTarget;
        return true;
    }
    return false;
}

simulated function Tick(float DeltaTime)
{
    super(KFAIController).Tick(DeltaTime);
    UpdateRecentlySeenEnemyList();
    EvaluateAttacks(DeltaTime);
}

event SeePlayer(Pawn Seen)
{
    local int EnemyListIndex, HiddenEnemyIndex;
    local Patriarch_TrackedEnemyInfo NewTrackedEnemy;
    local KFPawn KFP;

    super(KFAIController).SeePlayer(Seen);
    EvaluateSprinting();
    if((((((Seen == none) || !Seen.IsAliveAndWell()) || Pawn.IsSameTeam(Seen)) || Pawn == none) || !Pawn.IsAliveAndWell()) || !Seen.CanAITargetThisPawn(self))
    {
        return;
    }
    KFP = KFPawn(Seen);
    if(KFP != none)
    {
        EnemyListIndex = RecentlySeenEnemyList.Find('TrackedEnemy', KFP;
        if(EnemyListIndex == -1)
        {
            HiddenEnemyIndex = HiddenEnemies.Find('TrackedEnemy', KFP;
            if(HiddenEnemyIndex != -1)
            {
                HiddenEnemies.Remove(HiddenEnemyIndex, 1;
            }
            NewTrackedEnemy.TrackedEnemy = KFP;
            NewTrackedEnemy.LastTimeVisible = WorldInfo.TimeSeconds;
            NewTrackedEnemy.LastVisibleLocation = Seen.Location;
            if(RecentlySeenEnemyList.Length == 0)
            {
                NextAttackCheckTime = 1.5 + FRand();
            }
            RecentlySeenEnemyList[RecentlySeenEnemyList.Length] = NewTrackedEnemy;            
        }
        else
        {
            RecentlySeenEnemyList[EnemyListIndex].LastTimeVisible = WorldInfo.TimeSeconds;
            RecentlySeenEnemyList[EnemyListIndex].LastVisibleLocation = Seen.Location;
        }
        LastEnemySightedTime = WorldInfo.TimeSeconds;
    }
}

function UpdateRecentlySeenEnemyList()
{
    local int I;
    local bool bWantsNewEnemy;

    if((LastRecentSeenEnemyListUpdateTime == float(0)) || (WorldInfo.TimeSeconds - LastRecentSeenEnemyListUpdateTime) > RecentSeenEnemyListUpdateInterval)
    {
        LastRecentSeenEnemyListUpdateTime = WorldInfo.TimeSeconds;
        I = RecentlySeenEnemyList.Length - 1;
        J0x89:

        if(I >= 0)
        {
            bWantsNewEnemy = false;
            if((((RecentlySeenEnemyList[I].TrackedEnemy == none) || !RecentlySeenEnemyList[I].TrackedEnemy.IsAliveAndWell()) || !RecentlySeenEnemyList[I].TrackedEnemy.CanAITargetThisPawn(self)) || (WorldInfo.TimeSeconds - RecentlySeenEnemyList[I].LastTimeVisible) > 0.5)
            {
                if((RecentlySeenEnemyList[I].TrackedEnemy != none) && RecentlySeenEnemyList[I].TrackedEnemy.IsAliveAndWell())
                {
                    HiddenEnemies[HiddenEnemies.Length] = RecentlySeenEnemyList[I];
                }
                if(Enemy == RecentlySeenEnemyList[I].TrackedEnemy)
                {
                    if(RecentlySeenEnemyList.Length > 1)
                    {
                        bWantsNewEnemy = true;                        
                    }
                    else
                    {
                        FindNewEnemy();
                    }
                }
                RecentlySeenEnemyList.Remove(I, 1;
                if(bWantsNewEnemy)
                {
                    ChangeEnemy(RecentlySeenEnemyList[Rand(RecentlySeenEnemyList.Length)].TrackedEnemy);
                }                
            }
            else
            {
                if(CanSee(RecentlySeenEnemyList[I].TrackedEnemy))
                {
                    if((WorldInfo.TimeSeconds - RecentlySeenEnemyList[I].LastTakeDamageTime) > AggroFalloffWaitTime)
                    {
                        RecentlySeenEnemyList[I].AggroDamage -= int(FMax(AggroFalloffPerSecond * (RecentSeenEnemyListUpdateInterval / 1), 0));
                    }
                    RecentlySeenEnemyList[I].LastVisibleLocation = RecentlySeenEnemyList[I].TrackedEnemy.Location;
                    RecentlySeenEnemyList[I].LastTimeVisible = WorldInfo.TimeSeconds;
                }
            }
            -- I;
            goto J0x89;
        }
        I = HiddenEnemies.Length - 1;
        J0x48C:

        if(I >= 0)
        {
            if((WorldInfo.TimeSeconds - HiddenEnemies[I].LastTakeDamageTime) > AggroFalloffWaitTime)
            {
                HiddenEnemies[I].AggroDamage -= int(FMax(AggroFalloffPerSecond * (RecentSeenEnemyListUpdateInterval / 1), 0));
            }
            if(((HiddenEnemies[I].TrackedEnemy == none) || !HiddenEnemies[I].TrackedEnemy.IsAliveAndWell()) || !HiddenEnemies[I].TrackedEnemy.CanAITargetThisPawn(self))
            {
                HiddenEnemies.Remove(I, 1;
            }
            -- I;
            goto J0x48C;
        }
    }
}

function EvaluateAttacks(float DeltaTime)
{
    local bool bCanFireMinigun, bCanFireMissile, bCanFireMortar, bShouldFireMortar, bShouldFireMissile, bMortarBarrage;

    if(!bCanEvaluateAttacks)
    {
        return;
    }
    NextAttackCheckTime -= DeltaTime;
    if(((((bWantsToCharge || bWantsToFlee) || bFleeing) || MyPatPawn == none) || MyPatPawn.IsDoingSpecialMove()) || NextAttackCheckTime > 0)
    {
        return;
    }
    if(((MyPatPawn.CanTentacleGrab() && RecentlySeenEnemyList.Length > 0) && (WorldInfo.TimeSeconds - LastGrabAttackTime) > MyPatPawn.TentacleGrabCooldownTime) && !MyPatPawn.bIsCloaking || FRand() < 0.25)
    {
        if(SetBestTarget(LastGrabbedPlayers, MinTentacleRangeSQ, Square((Class'KFSM_Patriarch_Grapple'.default.MaxRange * 0.8) * MyPatPawn.GetAttackRangeScale()), 0.4, true, true))
        {
            MyPatPawn.SetCloaked(false);
            Class'AICommand_Patriarch_Grab'.static.TentacleGrab(self);
            return;
        }
    }
    if(((!MyPatPawn.bIsCloaking && MyPatPawn.CanChargeAttack()) && bHadMinigunAttack || FRand() < 0.75) && (WorldInfo.TimeSeconds - LastChargeAttackTime) > MyPatPawn.ChargeAttackCooldownTime)
    {
        if(SetBestTarget(LastChargedPlayers, MinChargeRangeSQ))
        {
            CachedChargeTarget = Enemy;
            bDoingChargeAttack = true;
            bSprintUntilAttack = true;
            MyPatPawn.SetSprinting(true);
            MyPatPawn.SetCloaked(true);
            NextAttackCheckTime = 2.5 + FRand();
            SetTimer(2, false, 'Timer_SearchForChargeObstructions');
            return;
        }
    }
    bCanFireMinigun = (((!MyPatPawn.CanChargeAttack() || FRand() < 0.5) && !MyPatPawn.bIsCloaking || FRand() < 0.75) && RecentlySeenEnemyList.Length > 0) && (WorldInfo.TimeSeconds - LastSuccessfulAttackTime) > MyPatPawn.MinigunAttackCooldownTime;
    bCanFireMissile = ((((!MyPatPawn.CanChargeAttack() || FRand() < 0.5) && !MyPatPawn.bIsCloaking || FRand() < 0.75) && MyPatPawn.CanMissileAttack()) && RecentlySeenEnemyList.Length > 0) && (WorldInfo.TimeSeconds - LastMissileAttackTime) > MyPatPawn.MissileAttackCooldownTime;
    bCanFireMortar = (!MyPatPawn.bIsCloaking && MyPatPawn.CanMortarAttack()) && (WorldInfo.TimeSeconds - LastMortarAttackTime) > MyPatPawn.MortarAttackCooldownTime;
    if((bCanFireMissile || bCanFireMinigun) || bCanFireMortar)
    {
        bShouldFireMortar = ((bCanFireMortar && !bCanFireMissile || FRand() < 0.5) && !bCanFireMinigun || FRand() < 0.75) && IsCeilingClear();
        if(bShouldFireMortar)
        {
            if(MyPatPawn.CanDoMortarBarrage() && FRand() < 0.2)
            {
                bMortarBarrage = true;
                bShouldFireMortar = MyPatPawn.CollectMortarTargets(true, true);                
            }
            else
            {
                if(HiddenEnemies.Length > 0)
                {
                    bMortarBarrage = false;
                    bShouldFireMortar = (SomeEnemiesAreHidden()) && MyPatPawn.CollectMortarTargets(true);                    
                }
                else
                {
                    bShouldFireMortar = false;
                }
            }
        }
        bShouldFireMissile = ((!bShouldFireMortar && bCanFireMissile) && ((bCanFireMinigun || !bHadMinigunAttack) && FRand() < 0.2) || FRand() < 0.6) && SetBestTarget(LastMissileEnemies, MinMissileRangeSQ, MaxMissileRangeSQ * MyPatPawn.GetAttackRangeScale(), 0.5, true, true);
        if((bCanFireMinigun && !bShouldFireMissile) && !bShouldFireMortar)
        {
            bCanFireMinigun = SetBestTarget(LastMinigunEnemies, MinMinigunRangeSQ, MaxMinigunRangeSQ * MyPatPawn.GetAttackRangeScale(), 0.25, false, true);
        }
        if(bShouldFireMortar)
        {
            Class'AICommand_Patriarch_MortarAttack'.static.FireMortar(self, bMortarBarrage);
            return;            
        }
        else
        {
            if(bShouldFireMissile)
            {
                bHadMinigunAttack = false;
                MyPatPawn.SetCloaked(false);
                Class'AICommand_Patriarch_MissileAttack'.static.FireMissiles(self);
                return;                
            }
            else
            {
                if(bCanFireMinigun)
                {
                    bHadMinigunAttack = true;
                    MyPatPawn.SetCloaked(false);
                    Class'AICommand_Patriarch_MinigunBarrage'.static.MinigunBarrage(self);
                    return;
                }
            }
        }
    }
    NextAttackCheckTime = 0.5;
}

function bool IsWeaponArmClear(Vector EndTrace)
{
    local Vector StartTrace;

    MyPatPawn.Mesh.GetSocketWorldLocationAndRotation('MissileCenter', StartTrace);
    return MyPatPawn.FastTrace(EndTrace, StartTrace,, true);
}

function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    if(Enemy != none)
    {
        return rotator(Enemy.Location - StartFireLoc);
    }
    return super(Controller).GetAdjustedAimFor(W, StartFireLoc);
}

function DoStrike()
{
    local name AttackName;

    if((MyPatPawn != none) && MyPatPawn.PawnAnimInfo != none)
    {
        AttackName = MyPatPawn.PawnAnimInfo.Attacks[PendingAnimStrikeIndex].Tag;
        if(AttackName == 'Radial')
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyWhirlwindDialog(MyPatPawn);
            }
        }
    }
    super(KFAIController_Monster).DoStrike();
}

function EvaluateSprinting()
{
    if(((MyKFPawn != none) && MyKFPawn.IsAliveAndWell()) && Enemy != none)
    {
        if(ShouldSprint())
        {
            MyKFPawn.SetSprinting(true);            
        }
        else
        {
            MyKFPawn.SetSprinting(false);
        }
    }
}

function bool ShouldSprint()
{
    if(((Enemy != none) && MyPatPawn != none) && !MyPatPawn.bIsHeadless)
    {
        if(MyPatPawn.IsDoingSpecialMove(21))
        {
            return false;
        }
        if(bFleeing)
        {
            return true;
        }
        if(MyPatPawn.bIsCloaking)
        {
            return true;
        }
        if(bRaging)
        {
            return true;
        }
        if(MyPatPawn.bEmpPanicked)
        {
            return false;
        }
        if(bSprintUntilAttack)
        {
            return true;
        }
        if((LastEnemySightedTime == float(0)) || (WorldInfo.TimeSeconds - LastEnemySightedTime) > LostSightSprintDelay)
        {
            return true;
        }
        if(MyPatPawn.DesireSprintingInThisPhase() && (WorldInfo.TimeSeconds - LastSprintTime) > MyPatPawn.SprintCooldownTime)
        {
            bSprintUntilAttack = true;
            return true;
        }
    }
    return false;
}

function bool CanSetSprinting(bool bNewSprintStatus)
{
    return super(KFAIController).CanSetSprinting(bNewSprintStatus) && !bNewSprintStatus || !MyPatPawn.IsDoingSpecialMove(21);
}

function bool IsCeilingClear()
{
    local Vector TraceStart, TraceEnd, Extent;

    TraceStart = MyPatPawn.Location + (vect(0, 0, 1) * MyPatPawn.GetCollisionHeight());
    TraceEnd = TraceStart + (vect(0, 0, 1) * 500);
    Extent.X = MyPatPawn.GetCollisionRadius() * 2;
    Extent.Y = Extent.X;
    Extent.Z = 1;
    return MyPatPawn.FastTrace(TraceEnd, TraceStart, Extent, true);
}

function bool SomeEnemiesAreHidden()
{
    local KFPawn KFP;
    local float TargetDist;
    local int I, NumValidHiddenEnemies;

    I = 0;
    J0x0B:

    if(I < HiddenEnemies.Length)
    {
        KFP = HiddenEnemies[I].TrackedEnemy;
        if(!KFP.IsAliveAndWell() || MyPatPawn.IsSameTeam(KFP))
        {            
        }
        else
        {
            TargetDist = VSizeSq(KFP.Location - MyPatPawn.Location);
            if((TargetDist < MyPatPawn.MinMortarRangeSQ) || TargetDist > MyPatPawn.MaxMortarRangeSQ)
            {                
            }
            else
            {
                ++ NumValidHiddenEnemies;
                if((NumValidHiddenEnemies >= 2) || NumValidHiddenEnemies >= (Max(HiddenEnemies.Length + RecentlySeenEnemyList.Length, 1) / 2))
                {
                    return true;
                }
            }
        }
        ++ I;
        goto J0x0B;
    }
    return false;
}

function NotifyAttackDoor(KFDoorActor door)
{
    if(bFleeing || bWantsToFlee)
    {
        if(bFleeing)
        {
            bFleeInterrupted = true;
            bFleeing = false;
            TotalFleeTime = TotalFleeTime + (WorldInfo.TimeSeconds - FleeStartTime);
            bWantsToFlee = true;
        }
        AbortCommand(CommandList);
        EnableMeleeRangeEventProbing();
        BeginCombatCommand(GetDefaultCommand(), "Restarting default command");        
    }
    else
    {
        if(MyPatPawn.bIsCloaking)
        {
            MyPatPawn.SetCloaked(false);
            bWantsToCharge = true;
        }
    }
    super(KFAIController).NotifyAttackDoor(door);
}

function bool DoorFinished()
{
    local bool bSuperFinished;

    bSuperFinished = super(KFAIController).DoorFinished();
    if(bWantsToFlee && !bFleeing)
    {
        if(MyPatPawn.IsDoingSpecialMove())
        {
            MyPatPawn.EndSpecialMove();
        }
        Flee();        
    }
    else
    {
        if(bWantsToCharge)
        {
            ChangeEnemy(CachedChargeTarget, false);
            bDoingChargeAttack = true;
            bSprintUntilAttack = true;
            bWantsToCharge = false;
            MyPatPawn.SetSprinting(true);
            MyPatPawn.SetCloaked(true);
            SetTimer(2, false, 'Timer_SearchForChargeObstructions');
            NextAttackCheckTime = 2.5 + FRand();
        }
    }
    return bSuperFinished;
}

function NotifyAttackActor(Actor A);

function NotifyCommandFinished(AICommand FinishedCommand)
{
    if((((!bWantsToFlee && bFleeing) && PendingDoor == none) && (ActorEnemy == none) || ActorEnemy.bPendingDelete) && AICommand_Flee(FinishedCommand) != none)
    {
        TotalFleeTime = TotalFleeTime + (WorldInfo.TimeSeconds - FleeStartTime);
        AbortCommand(FinishedCommand);
        if(MyPatPawn.IsDoingSpecialMove())
        {
            MyPatPawn.EndSpecialMove();
        }
        SetTimer(0.06, false, 'Flee');
    }
}

function NotifySpecialMoveEnded(KFSpecialMove SM)
{
    super(KFAIController).NotifySpecialMoveEnded(SM);
    bFleeInterrupted = false;
    if(!bWantsToFlee)
    {
        if((((SM.Handle == 'KFSM_DoorMeleeAttack') || SM.Handle == 'KFSM_MeleeAttack') || SM.Handle == 'KFSM_Patriarch_Grapple') || SM.Handle == 'KFSM_Patriarch_MinigunBarrage')
        {
            if((((PendingDoor == none) && bWantsToCharge) && CachedChargeTarget != none) && CachedChargeTarget.IsAliveAndWell())
            {
                ChangeEnemy(CachedChargeTarget, false);
                bDoingChargeAttack = true;
                bSprintUntilAttack = true;
                bWantsToCharge = false;
                MyPatPawn.SetSprinting(true);
                MyPatPawn.SetCloaked(true);
                SetTimer(2, false, 'Timer_SearchForChargeObstructions');
                NextAttackCheckTime = 2.5 + FRand();                
            }
            else
            {
                if(bRaging)
                {
                    ++ RageAttackCount;
                    UpdateRageState();                    
                }
                else
                {
                    if(bSprintUntilAttack)
                    {
                        if(bDoingChargeAttack)
                        {
                            LastChargeAttackTime = WorldInfo.TimeSeconds;
                        }
                        LastSprintTime = WorldInfo.TimeSeconds;
                        bSprintUntilAttack = false;
                        bWantsToCharge = false;
                        CachedChargeTarget = none;
                        ClearTimer('Timer_SearchForChargeObstructions');
                    }
                }
            }
            if((SM.Handle == 'KFSM_MeleeAttack') && (WorldInfo.TimeSeconds - LastRetargetTime) > RetargetWaitTime)
            {
                CheckForEnemiesInFOV(3000, -1, 1, true);
            }            
        }
        else
        {
            if(SM.Handle == 'KFSM_Patriarch_Heal')
            {
                ChangeEnemy(GetClosestEnemy(), true);
                SetEnemyMoveGoal(self, true);
                NextAttackCheckTime = FRand();
            }
        }
        if(SM.Handle == 'KFSM_Patriarch_MinigunBarrage')
        {
            NextAttackCheckTime = 2.25 + FRand();
            CheckForEnemiesInFOV(2000, -1, 1);            
        }
        else
        {
            if(SM.Handle == 'KFSM_Patriarch_MissileAttack')
            {
                LastMissileAttackTime = WorldInfo.TimeSeconds;
                NextAttackCheckTime = 2.25 + FRand();
                CheckForEnemiesInFOV(2000, -1, 1);                
            }
            else
            {
                if(SM.Handle == 'KFSM_Patriarch_MortarAttack')
                {
                    LastMortarAttackTime = WorldInfo.TimeSeconds;
                    NextAttackCheckTime = 2.25 + FRand();
                    CheckForEnemiesInFOV(2000, -1, 1);                    
                }
                else
                {
                    if(SM.Handle == 'KFSM_Patriarch_Grapple')
                    {
                        LastSuccessfulAttackTime = WorldInfo.TimeSeconds;
                        LastGrabAttackTime = WorldInfo.TimeSeconds;
                        NextAttackCheckTime = 2.25 + FRand();
                    }
                }
            }
        }
        bCanEvaluateAttacks = true;
        EnableMeleeRangeEventProbing();        
    }
    else
    {
        if((PendingDoor == none) && !bFleeing)
        {
            bSprintUntilAttack = false;
            Flee();
        }
    }
    EvaluateSprinting();
    bDoingChargeAttack = false;
}

function NotifyMeleeDamageDealt()
{
    super(KFAIController).NotifyMeleeDamageDealt();
    LastSuccessfulAttackTime = WorldInfo.TimeSeconds;
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    if(GetIsInZedVictoryState())
    {
        return;
    }
    if((self == Killer) && Killed.GetTeamNum() != GetTeamNum())
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyKilledDialog(MyPatPawn, DamageType);
        }        
    }
    else
    {
        if((((((!bWantsToFlee && !bFleeing) && !bRagedThisPhase) && MyPatPawn.MaxRageAttacks > 0) && !MyPatPawn.IsDoingSpecialMove(17)) && Killed != self) && Killed.GetTeamNum() == GetTeamNum())
        {
            if(CanSee(KilledPawn))
            {
                if(Killer.Pawn != none)
                {
                    ChangeEnemy(Killer.Pawn, false);
                }
                StartPaternalInstinct();
            }            
        }
        else
        {
            if((Killed.Pawn == Enemy) && MyPatPawn.IsDoingSpecialMove(21))
            {
                KFSM_Patriarch_MinigunBarrage(MyPatPawn.SpecialMoves[21]).Timer_SearchForMinigunTargets();
            }
        }
    }
    super(KFAIController).NotifyKilled(Killer, Killed, KilledPawn, DamageType);
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum)
{
    local KFPawn EnemyPawn;
    local int EnemyIndex, pawnDmg;
    local Vector pawnRotToVec;

    if(InstigatedBy.Pawn != none)
    {
        EnemyPawn = KFPawn(InstigatedBy.Pawn);
        if(EnemyPawn != none)
        {
            EnemyIndex = RecentlySeenEnemyList.Find('TrackedEnemy', EnemyPawn;
            if(EnemyIndex != -1)
            {
                pawnDmg = Damage;
                pawnRotToVec = vector(MyPatPawn.Rotation);
                pawnRotToVec.Z = 0;
                if((pawnRotToVec Dot Normal2D(EnemyPawn.Location - MyPatPawn.Location)) < -0.25)
                {
                    pawnDmg *= float(2);
                }
                RecentlySeenEnemyList[EnemyIndex].AggroDamage += pawnDmg;
                RecentlySeenEnemyList[EnemyIndex].LastTakeDamageTime = WorldInfo.TimeSeconds;                
            }
            else
            {
                EnemyIndex = HiddenEnemies.Find('TrackedEnemy', EnemyPawn;
                if(EnemyIndex != -1)
                {
                    pawnDmg = Damage;
                    pawnRotToVec = vector(MyPatPawn.Rotation);
                    pawnRotToVec.Z = 0;
                    if((pawnRotToVec Dot Normal2D(EnemyPawn.Location - MyPatPawn.Location)) < -0.25)
                    {
                        pawnDmg *= float(2);
                    }
                    HiddenEnemies[EnemyIndex].AggroDamage += pawnDmg;
                    HiddenEnemies[EnemyIndex].LastTakeDamageTime = WorldInfo.TimeSeconds;
                }
            }
        }
    }
    if(((((!bWantsToFlee && !bFleeing) && MyPatPawn != none) && !MyPatPawn.bHealedThisPhase) && MyPatPawn.CanSummonChildren()) && !MyPatPawn.IsDoingSpecialMove(17))
    {
        if(!bSummonedThisPhase && GetHealthPercentage() < (FleeHealthThreshold + 0.075))
        {
            bSummonedThisPhase = true;
            MyAIDirector.bForceFrustration = true;
            MyPatPawn.SummonChildren();
            SetTimer(30, false, 'Timer_StopSummoningZeds');
        }
        if(!MyPatPawn.IsDoingSpecialMove(12) && GetHealthPercentage() < FleeHealthThreshold)
        {
            if(MyPatPawn.IsDoingSpecialMove())
            {
                MyPatPawn.EndSpecialMove();
            }
            if(GetActiveCommand().IsA('AICommand_SpecialMove'))
            {
                AICommand_SpecialMove(GetActiveCommand()).ClearTimeout();
            }
            TotalFleeTime = 0;
            bCanEvaluateAttacks = false;
            bWantsToFlee = true;
            EndPanicWander();
            NextBattlePhase();
            Class'AICommand_TauntEnemy'.static.Taunt(self, Enemy, 2, Class'KFSM_Patriarch_Taunt');
            MyPatPawn.SetFleeAndHealMode(true);
        }
    }
    super(KFAIController).NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
}

function StartPaternalInstinct()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyChildKilledDialog(MyPatPawn);
    }
    bRaging = true;
    bRagedThisPhase = true;
    RageAttackCount = 0;
    MaxRageAttacks = MyPatPawn.MaxRageAttacks + Max(0, int(MyKFGameInfo.GameDifficulty - float(1)));
    MyPatPawn.SetSprinting(true);
    SetTimer(RageTimeOut, false, 'Timer_RageTimeOut');
}

function UpdateRageState()
{
    local float DistSq, BestDistSq;
    local KFPawn KFP, BestTarget;
    local int I;

    if(RageAttackCount >= MaxRageAttacks)
    {
        bRaging = false;
        bCanEvaluateAttacks = true;
        RageAttackCount = 0;
        RageAttackedTargets.Length = 0;
        ClearTimer('Timer_RageTimeOut');
        EvaluateSprinting();        
    }
    else
    {
        foreach WorldInfo.AllPawns(Class'KFPawn', KFP)
        {
            if(!KFP.IsAliveAndWell() || MyPatPawn.IsSameTeam(KFP))
            {
                continue;                
            }
            if(RageAttackedTargets.Find(KFP != -1)
            {
                continue;                
            }
            DistSq = VSizeSq(KFP.Location - MyPatPawn.Location);
            if(DistSq > MaxRageRangeSQ)
            {
                continue;                
            }
            if((BestDistSq == 0) || DistSq < BestDistSq)
            {
                BestDistSq = DistSq;
                BestTarget = KFP;
            }            
        }        
        if(BestTarget == none)
        {
            I = 0;
            J0x1E9:

            if(I < RageAttackedTargets.Length)
            {
                KFP = RageAttackedTargets[I];
                if((KFP == none) || !KFP.IsAliveAndWell())
                {
                    RageAttackedTargets.Remove(I, 1;
                    -- I;                    
                }
                else
                {
                    DistSq = VSizeSq(KFP.Location - MyPatPawn.Location);
                    if(DistSq > MaxRageRangeSQ)
                    {                        
                    }
                    else
                    {
                        BestTarget = KFP;
                        RageAttackedTargets.Remove(I, 1;
                        goto J0x313;
                    }
                }
                ++ I;
                goto J0x1E9;
            }
        }
        J0x313:

        if(BestTarget != none)
        {
            RageAttackedTargets[RageAttackedTargets.Length] = BestTarget;
            ChangeEnemy(BestTarget);            
        }
        else
        {
            RageAttackCount = MaxRageAttacks;
            UpdateRageState();
        }
    }
}

function Timer_RageTimeOut()
{
    RageAttackCount = MaxRageAttacks;
    UpdateRageState();
}

function bool AmIAllowedToSuicideWhenStuck()
{
    return false;
}

function Timer_StopSummoningZeds()
{
    bSummonedThisPhase = false;
    super.Timer_StopSummoningZeds();
}

function NextBattlePhase()
{
    bRagedThisPhase = false;
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyBattlePhaseDialog(MyPatPawn, MyPatPawn.CurrentBattlePhase);
    }
    if(MyPatPawn != none)
    {
        MyPatPawn.IncrementBattlePhase();
    }
}

function Timer_SearchForFleeObstructions()
{
    local KFPawn ObstructingEnemy;

    if((!bFleeing || bWantsToFlee) || MyPatPawn.IsDoingSpecialMove())
    {
        SetTimer(0.25, false, 'Timer_SearchForFleeObstructions');
        return;
    }
    ObstructingEnemy = CheckForEnemiesInFOV(AttackRange * 1.1, 0.4, 1, false, false);
    if(ObstructingEnemy != none)
    {
        TotalFleeTime = TotalFleeTime + (WorldInfo.TimeSeconds - FleeStartTime);
        bFleeInterrupted = true;
        bFleeing = false;
        MyPatPawn.SetCloaked(false);
        AbortCommand(CommandList);
        ChangeEnemy(ObstructingEnemy, false);
        bWantsToFlee = true;
        bSprintUntilAttack = true;
        SetEnemyMoveGoal(self, true);
        EnableMeleeRangeEventProbing();
        BeginCombatCommand(GetDefaultCommand(), "Restarting default command");
        SetTimer(3, false, 'Timer_SearchForFleeObstructions');        
    }
    else
    {
        SetTimer(0.25, false, 'Timer_SearchForFleeObstructions');
    }
}

function Timer_SearchForChargeObstructions()
{
    local KFPawn ObstructingEnemy;

    if(bWantsToCharge || MyPatPawn.IsDoingSpecialMove())
    {
        SetTimer(0.25, false, 'Timer_SearchForChargeObstructions');
        return;
    }
    ObstructingEnemy = CheckForEnemiesInFOV(AttackRange * 1.1, 0.4, 1, false, false);
    if(ObstructingEnemy != none)
    {
        MyPatPawn.SetCloaked(false);
        ChangeEnemy(ObstructingEnemy, false);
        bWantsToCharge = true;        
    }
    else
    {
        SetTimer(0.25, false, 'Timer_SearchForChargeObstructions');
    }
}

function DoHeavyBump(Actor Other, Vector HitNormal)
{
    local KFPawn_Human KFPH;

    if(IsTimerActive('Timer_SearchForFleeObstructions'))
    {
        KFPH = KFPawn_Human(Other);
        if(KFPH != none)
        {
            KFPH.TakeDamage(HumanBumpDamage, self, KFPH.Location, HitNormal * float(HumanBumpMomentum), MyPatPawn.GetBumpAttackDamageType());
            return;
        }
    }
    DoHeavyZedBump(Other, HitNormal);
}

function bool DoHeavyZedBump(Actor Other, Vector HitNormal)
{
    local int BumpEffectDamage;
    local KFPawn_Monster BumpedMonster;

    if(Other.bCanBeDamaged && KFFracturedMeshGlass(Other) != none)
    {
        KFFracturedMeshGlass(Other).BreakOffAllFragments();
        return true;
    }
    BumpedMonster = KFPawn_Monster(Other);
    if(((BumpedMonster == none) || !BumpedMonster.IsAliveAndWell()) || BumpedMonster.ZedBumpDamageScale <= float(0))
    {
        return false;
    }
    if((MyPatPawn == none) || !MyPatPawn.IsAliveAndWell())
    {
        return false;
    }
    if(MyPatPawn.bIsSprinting && !MyKFPawn.IsDoingSpecialMove())
    {
        BumpEffectDamage = int(float(ZedBumpEffectThreshold) * BumpedMonster.ZedBumpDamageScale);
        if((BumpedMonster.Health - BumpEffectDamage) <= 0)
        {
            if(FRand() < ZedBumpObliterationEffectChance)
            {
                BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());                
            }
            else
            {
                BumpedMonster.Knockdown(,, vect(1, 1, 1), Pawn.Location, 1000, 100);
            }
            return true;            
        }
        else
        {
            BumpedMonster.TakeDamage(BumpEffectDamage, self, BumpedMonster.Location, vect(0, 0, 0), MyKFPawn.GetBumpAttackDamageType());
            BumpedMonster.DoSpecialMove(4,,, Class'KFSM_Stumble'.static.PackBodyHitSMFlags(BumpedMonster, HitNormal));
            return true;
        }
    }
    return false;
}

function DoFleeFrom(Actor FleeFrom, optional float FleeDuration, optional float FleeDistance, optional bool bShouldStopAtGoal, optional bool bFromFear)
{
    bShouldStopAtGoal = false;
    bFromFear = false;
    if(!bFromFear || !MyPatPawn.bInFleeAndHealMode)
    {
        super(KFAIController).DoFleeFrom(FleeFrom, FleeDuration, FleeDistance, bShouldStopAtGoal, bFromFear);
    }
}

function Flee()
{
    local Actor FleeFromTarget;
    local float FleeDuration;
    local AICommand_SpecialMove AICSM;

    bFleeing = false;
    bWantsToFlee = false;
    bFleeInterrupted = false;
    if(Enemy == none)
    {
        SetEnemy(GetClosestEnemy());
    }
    if(Enemy != none)
    {
        FleeFromTarget = Enemy;        
    }
    else
    {
        FleeFromTarget = Class'NavigationPoint'.static.GetNearestNavToActor(MyPatPawn);
    }
    if(bRaging)
    {
        RageAttackCount = MaxRageAttacks;
        UpdateRageState();
    }
    AICSM = FindCommandOfClass(Class'AICommand_SpecialMove');
    if(AICSM != none)
    {
        AICSM.ClearTimeout();
    }
    EndPanicWander();
    AbortCommand(CommandList);
    bFleeing = true;
    bCanEvaluateAttacks = false;
    MyPatPawn.SetCloaked(true);
    SetSprintingDisabled(false);
    MyPatPawn.SetSprinting(true);
    DisableMeleeRangeEventProbing();
    FleeDuration = FMax(MaxFleeDuration - TotalFleeTime, 6);
    FleeStartTime = WorldInfo.TimeSeconds;
    DoFleeFrom(FleeFromTarget, FleeDuration, MaxFleeDistance + float(Rand(int(MaxFleeDistance * 0.25))), true);
    EvaluateSprinting();
    if(!IsTimerActive('Timer_SearchForFleeObstructions'))
    {
        SetTimer(2, false, 'Timer_SearchForFleeObstructions');
    }
}

function NotifyFleeFinished(optional bool bAcquireNewEnemy)
{
    bAcquireNewEnemy = true;
    if(!MyPatPawn.bInFleeAndHealMode)
    {
        return;
    }
    if(MyPatPawn != none)
    {
        MyPatPawn.SetCloaked(false);
        if(IsTimerActive('Timer_StopSummoningZeds'))
        {
            SetTimer(4, false, 'Timer_StopSummoningZeds');
        }
        ClearTimer('Timer_SearchForFleeObstructions');
        bWantsToFlee = false;
        bFleeing = false;
        MyPatPawn.DoSpecialMove(17,,, Class'KFSM_Patriarch_Heal'.static.PackSMFlags(MyPatPawn.CurrentBattlePhase - 1));
    }
    EnableMeleeRangeEventProbing();
    BeginCombatCommand(GetDefaultCommand(), "Restarting default command");
}

function ForceHeal()
{
    if(bFleeing)
    {
        bFleeing = false;
        bWantsToFlee = false;
        AbortCommand(FindCommandOfClass(Class'AICommand_Flee'));        
    }
    else
    {
        bWantsToFlee = false;
    }
    NotifyFleeFinished(false);
}

function EnterZedVictoryState()
{
    bCanEvaluateAttacks = false;
    bRaging = false;
    MyPatPawn.SetCloaked(false);
    bWantsToFlee = false;
    bFleeing = false;
    bFleeInterrupted = false;
    if(IsTimerActive('Timer_SearchForFleeObstructions'))
    {
        ClearTimer('Timer_SearchForFleeObstructions');
    }
    if(IsTimerActive('Timer_SearchForChargeObstructions'))
    {
        ClearTimer('Timer_SearchForChargeObstructions');
    }
    if(IsTimerActive('Timer_RageTimeOut'))
    {
        ClearTimer('Timer_RageTimeOut');
    }
    MyKFGameInfo.SpawnManager.StopSummoningBossMinions();
    super.EnterZedVictoryState();
    KFWeapon(MyPatPawn.Weapon).GotoState('Inactive');
}

function PlayDamagePlayerDialog(class<DamageType> dmgType);

simulated function DrawDebug(KFHUDBase HUD, name Category)
{
    local Canvas C;

    super(KFAIController).DrawDebug(HUD, Category);
    if((MyPatPawn == none) || Category != 'All')
    {
        return;
    }
    C = HUD.Canvas;
    C.SetDrawColor(255, 255, 255, 255);
    DrawDebugText(HUD, "************************************************************");
    C.SetDrawColor(0, 0, 255, 255);
    DrawDebugText(HUD, "PATRIARCH STATUS");
    C.SetDrawColor(0, 255, 0, 255);
    DrawDebugText(HUD, "BattlePhase:" @ string(MyPatPawn.CurrentBattlePhase));
}

state ZedVictory
{
    ignores NotifyTakeHit, NotifyKilled, NotifySpecialMoveEnded, NotifyFleeFinished, SeePlayer, UpdateRageState, 
	    CheckForEnemiesInFOV, EvaluateSprinting, ChangeEnemy, SetEnemy, FindNewEnemy, 
	    EvaluateAttacks, UpdateRecentlySeenEnemyList, Timer_SearchForFleeObstructions, Timer_SearchForChargeObstructions;
Begin:

    Sleep(0.1);
    Class'AICommand_BossTheatrics'.static.DoTheatrics(self, 1, -1);
    stop;                    
}

defaultproperties
{
    bSprintUntilAttack=true
    LostSightSprintDelay=5
    AggroFalloffWaitTime=1
    AggroFalloffPerSecond=25
    VisibleAggroDmgThreshold=260
    HiddenAggroDmgThreshold=200
    MinMinigunRangeSQ=160000
    MaxMinigunRangeSQ=1.6E+07
    MaxFanFireRangeSQ=490000
    MinChargeRangeSQ=810000
    MinTentacleRangeSQ=90000
    MinMissileRangeSQ=360000
    MaxMissileRangeSQ=1.6E+07
    LastRecentSeenEnemyListUpdateTime=0.1
    RetargetWaitTime=5
    MaxRageRangeSQ=1440000
    RageTimeOut=16
    HumanBumpDamage=10
    HumanBumpMomentum=8000
    FleeHealthThreshold=0.35
    MaxFleeDuration=25
    MaxFleeDistance=20000
    bRepathOnInvalidStrike=true
    bUseRunOverWarning=true
    MinRunOverSpeed=360
    MinRunOverWarningAim=0.85
    bCanDoHeavyBump=true
    DefaultCommandClass=Class'AICommand_Base_Patriarch'
    MeleeCommandClass=Class'AICommand_Base_Patriarch'
    DangerEvadeSettings=/* Array type was not detected. */
}