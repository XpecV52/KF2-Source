/*******************************************************************************
 * KFPawn_ZedPatriarch generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFPawn_ZedPatriarch extends KFPawn_MonsterBoss
    config(Game)
    hidecategories(Navigation);

struct Patriarch_MortarTarget
{
    var KFPawn TargetPawn;
    var Vector TargetVelocity;

    structdefaultproperties
    {
        TargetPawn=none
        TargetVelocity=(X=0,Y=0,Z=0)
    }
};

struct PatriarchBattlePhaseInfo
{
    var bool bAllowedToSprint;
    var float SprintCooldownTime;
    var bool bCanTentacleGrab;
    var float TentacleGrabCooldownTime;
    var bool bCanUseMissiles;
    var float MissileAttackCooldownTime;
    var bool bCanUseMortar;
    var float MortarAttackCooldownTime;
    var bool bCanDoMortarBarrage;
    var bool bCanChargeAttack;
    var float ChargeAttackCooldownTime;
    var int MaxRageAttacks;
    var int TentacleDamage;
    var float MinigunAttackCooldownTime;
    var bool bCanSummonMinions;
    var array<bool> bCanMoveWhenMinigunning;
    var array<float> HealAmounts;

    structdefaultproperties
    {
        bAllowedToSprint=false
        SprintCooldownTime=0
        bCanTentacleGrab=false
        TentacleGrabCooldownTime=0
        bCanUseMissiles=false
        MissileAttackCooldownTime=0
        bCanUseMortar=false
        MortarAttackCooldownTime=0
        bCanDoMortarBarrage=false
        bCanChargeAttack=false
        ChargeAttackCooldownTime=0
        MaxRageAttacks=0
        TentacleDamage=0
        MinigunAttackCooldownTime=0
        bCanSummonMinions=false
        bCanMoveWhenMinigunning=none
        HealAmounts=none
    }
};

var AkEvent AmbientBreathingEvent;
var AkEvent LowHealthAmbientBreathingEvent;
var export editinline AkComponent CloakedAkComponent;
var AkEvent CloakedLoop;
var AkEvent CloakedLoopEnd;
var MaterialInstanceConstant BodyMaterial;
var MaterialInstanceConstant BodyAltMaterial;
var MaterialInstanceConstant SpottedMaterial;
var MaterialInstanceConstant CloakedBodyMaterial;
var MaterialInstanceConstant CloakedBodyAltMaterial;
var KFSkelControl_SpinBone BarrelSpinSkelCtrl;
var SkelControlLookAt GunTrackingSkelCtrl;
var export editinline array<export editinline StaticMeshComponent> HealingSyringeMeshes;
var array<MaterialInstanceConstant> HealingSyringeMICs;
var int CurrentSyringeMeshNum;
var int ActiveSyringe;
var float SyringeInjectTimeDuration;
var float SyringeInjectTimeRemaining;
var LinearColor MechColors[4];
var LinearColor DeadMechColor;
var LinearColor BoilColors[4];
var LinearColor DeadBoilColor;
var bool bPulseBoils;
var bool bSprayingFire;
var bool bSpinBarrels;
var protected const bool bUseServerSideGunTracking;
var bool bGunTracking;
var repnotify bool bInFleeAndHealMode;
var bool bHealedThisPhase;
var float BoilPulseRate;
var float BoilPulseAccum;
var float BoilLightBrightness[4];
var name BoilLightSocketName;
var export editinline transient PointLightComponent BoilLightComponent;
var ParticleSystem CloakFX;
var name CloakFXSocketName;
var float CloakShimmerAmount;
var float LastCloakShimmerTime;
var name BattleDamageFXSocketName_LeftHip;
var name BattleDamageFXSocketName_LeftKnee;
var name BattleDamageFXSocketName_LeftFoot;
var name BattleDamageFXSocketName_LeftArm;
var name BattleDamageFXSocketName_Weapon;
var name BattleDamageFXSocketName_LowerSpike;
var name BattleDamageFXSocketName_UpperSpike;
var name BattleDamageFXSocketName_BackSpike;
var export editinline ParticleSystemComponent BattleDamagePSC_LeftHip;
var export editinline ParticleSystemComponent BattleDamagePSC_LeftKnee;
var export editinline ParticleSystemComponent BattleDamagePSC_LeftFoot;
var export editinline ParticleSystemComponent BattleDamagePSC_LeftArm;
var export editinline ParticleSystemComponent BattleDamagePSC_Weapon;
var export editinline ParticleSystemComponent BattleDamagePSC_LowerSpike;
var export editinline ParticleSystemComponent BattleDamagePSC_UpperSpike;
var export editinline ParticleSystemComponent BattleDamagePSC_BackSpike;
var ParticleSystem BattleDamageFX_Sparks_LowDmg;
var ParticleSystem BattleDamageFX_Sparks_MidDmg;
var ParticleSystem BattleDamageFX_Sparks_HighDmg;
var ParticleSystem BattleDamageFX_Tentacle_LowDmg;
var ParticleSystem BattleDamageFX_Tentacle_MidDmg;
var ParticleSystem BattleDamageFX_Tentacle_HighDmg;
var ParticleSystem BattleDamageFX_Smoke_HighDmg;
var float TickDialogInterval;
var protected const float FootstepCameraShakePitchAmplitude;
var protected const float FootstepCameraShakeRollAmplitude;
var int LastFXBattlePhase;
var array<PatriarchBattlePhaseInfo> BattlePhases;
var float SprintCooldownTime;
var float TentacleGrabCooldownTime;
var float MissileAttackCooldownTime;
var float MortarAttackCooldownTime;
var float ChargeAttackCooldownTime;
var float MinigunAttackCooldownTime;
var int MaxRageAttacks;
var int TentacleDamage;
var class<KFDamageType> TentacleDamageType;
var class<KFDamageType> HeavyBumpDamageType;
var float BarrelSpinSpeed;
var repnotify Actor GunTarget;
var class<KFProj_Missile_Patriarch> MissileProjectileClass;
var class<KFProj_Missile_Patriarch> MortarProjectileClass;
var array<Patriarch_MortarTarget> MortarTargets;
var float MinMortarRangeSQ;
var float MaxMortarRangeSQ;
var float FleeSprintSpeedModifier;
var float CloakPercent;
var float CloakSpeed;
var float DeCloakSpeed;
var int NumFleeAndHealEnemyBumps;
var float LastFleeAndHealEnemyBumpTime;

replication
{
     if(bNetDirty)
        GunTarget, bInFleeAndHealMode;
}

simulated event ReplicatedEvent(name VarName)
{
    switch(VarName)
    {
        case 'bIsCloakingSpottedByTeam':
            UpdateGameplayMICParams();
            break;
        case 'bIsCloaking':
            ClientCloakingStateUpdated();
            break;
        case 'GunTarget':
            SetGunTracking(GunTarget != none);
            break;
        default:
            break;
    }
    super.ReplicatedEvent(VarName);
}

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    AddDefaultInventory();
    if(Weapon != none)
    {
        Weapon.GotoState('Active');
    }
    if(WeaponAttachment != none)
    {
        WeaponAttachment.ShootBlendInTime = 0;
        WeaponAttachment.ShootBlendOutTime = 0.01;
    }
    AmbientAkComponent.CachedObjectPosition = Location;
    SetPawnAmbientSound(AmbientBreathingEvent);
    if(WorldInfo.NetMode != NM_Client)
    {
        SetTimer(2, false, 'Timer_TickPatriarchDialog');
    }
}

simulated function SetCharacterArch(KFCharacterInfoBase Info, optional bool bForce)
{
    local int I;
    local KFCharacterInfo_Monster MonsterInfo;

    super(KFPawn_Monster).SetCharacterArch(Info);
    if((WorldInfo.NetMode != NM_DedicatedServer) && Mesh != none)
    {
        I = 0;
        J0x5A:

        if(I < 3)
        {
            HealingSyringeMICs[I] = HealingSyringeMeshes[I].CreateAndSetMaterialInstanceConstant(0);
            HealingSyringeMeshes[I].SetShadowParent(Mesh);
            Mesh.AttachComponent(HealingSyringeMeshes[I], name("SyringeAttach0" $ string(I + 1)));
            ++ I;
            goto J0x5A;
        }
        Mesh.AttachComponentToSocket(BoilLightComponent, BoilLightSocketName);
        UpdateBattlePhaseLights();
        BoilLightComponent.SetEnabled(true);
        MonsterInfo = KFCharacterInfo_Monster(Info);
        if(MonsterInfo != none)
        {
            if(MaterialInstanceConstant(MonsterInfo.Skins[0]) != none)
            {
                BodyMaterial = MaterialInstanceConstant(MonsterInfo.Skins[0]);
            }
            if(MaterialInstanceConstant(MonsterInfo.Skins[1]) != none)
            {
                BodyAltMaterial = MaterialInstanceConstant(MonsterInfo.Skins[1]);
            }
        }
    }
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super(KFPawn_Monster).PostInitAnimTree(SkelComp);
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        BarrelSpinSkelCtrl = KFSkelControl_SpinBone(SkelComp.FindSkelControl('BarrelSpin'));
        BarrelSpinSkelCtrl.SetSkelControlActive(false);
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) || bUseServerSideGunTracking)
    {
        GunTrackingSkelCtrl = SkelControlLookAt(SkelComp.FindSkelControl('GunTracking'));
        GunTrackingSkelCtrl.SetSkelControlActive(false);
    }
}

function PossessedBy(Controller C, bool bVehicleTransition)
{
    super.PossessedBy(C, bVehicleTransition);
    SetPhaseCooldowns(0);
}

function class<KFDamageType> GetBumpAttackDamageType()
{
    return HeavyBumpDamageType;
}

simulated function SetFleeAndHealMode(bool bNewFleeAndHealStatus)
{
    bInFleeAndHealMode = bNewFleeAndHealStatus;
    if(Role == ROLE_Authority)
    {
        if(bNewFleeAndHealStatus)
        {
            SprintSpeed = default.SprintSpeed * FleeSprintSpeedModifier;
            SetTimer(0.25, true, 'FleeAndHealBump');            
        }
        else
        {
            SprintSpeed = default.SprintSpeed;
            ClearTimer('FleeAndHealBump');
        }
        NumFleeAndHealEnemyBumps = 0;
        LastFleeAndHealEnemyBumpTime = WorldInfo.TimeSeconds;
        bForceNetUpdate = true;
    }
    if(!bNewFleeAndHealStatus)
    {
        bHealedThisPhase = false;
    }
}

function SummonChildren()
{
    local KFAIWaveInfo MinionWave;
    local KFGameInfo MyKFGameInfo;

    MyKFGameInfo = KFGameInfo(WorldInfo.Game);
    MyKFGameInfo.GetAIDirector().bForceFrustration = true;
    MinionWave = GetWaveInfo(CurrentBattlePhase, MyKFGameInfo.GetModifiedGameDifficulty());
    if(MinionWave != none)
    {
        if(MyKFGameInfo.SpawnManager != none)
        {
            MyKFGameInfo.SpawnManager.LeftoverSpawnSquad.Length = 0;
            MyKFGameInfo.SpawnManager.SummonBossMinions(MinionWave.Squads, GetNumMinionsToSpawn());
        }
    }
}

function bool CanSummonChildren()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanSummonMinions;
}

simulated function ANIMNOTIFY_GrabSyringe()
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        CurrentSyringeMeshNum = CurrentBattlePhase - 2;
        Mesh.DetachComponent(HealingSyringeMeshes[CurrentSyringeMeshNum]);
        Mesh.AttachComponent(HealingSyringeMeshes[CurrentSyringeMeshNum], 'Syringe');
    }
}

simulated function ANIMNOTIFY_SpawnedKActor(KFKActorSpawnable NewKActor, AnimNodeSequence AnimSeqInstigator)
{
    local MaterialInstanceConstant SyringeMIC;

    if(CurrentSyringeMeshNum < 0)
    {
        return;
    }
    SyringeMIC = NewKActor.StaticMeshComponent.CreateAndSetMaterialInstanceConstant(0);
    SyringeMIC.SetScalarParameterValue('Scalar_GlowIntensity', 0.02 + FClamp((0.98 * SyringeInjectTimeRemaining) / SyringeInjectTimeDuration, 0, 0.98));
    NewKActor.StaticMeshComponent.SetLightingChannels(HealingSyringeMeshes[CurrentSyringeMeshNum].LightingChannels);
    NewKActor.StaticMeshComponent.bCastDynamicShadow = false;
    Mesh.DetachComponent(HealingSyringeMeshes[CurrentSyringeMeshNum]);
    HealingSyringeMeshes[CurrentSyringeMeshNum] = none;
    HealingSyringeMICs[CurrentSyringeMeshNum] = none;
    CurrentSyringeMeshNum = -1;
}

simulated function BreakOffSyringe(int SyringeNum)
{
    local KFKActorSpawnable NewKActor;
    local Vector BoneLoc, LinearVel, AngularVel;
    local Quat BoneQuat;
    local Rotator BoneRot;
    local name SyringeBoneName;

    SyringeBoneName = name("SyringeAttach0" $ string(SyringeNum + 1));
    BoneLoc = Mesh.GetBoneLocation(SyringeBoneName);
    BoneQuat = Mesh.GetBoneQuaternion(SyringeBoneName);
    BoneRot = QuatToRotator(BoneQuat);
    NewKActor = Spawn(Class'KFKActorSpawnable', self,, BoneLoc, BoneRot + HealingSyringeMeshes[SyringeNum].Rotation);
    if(NewKActor != none)
    {
        NewKActor.StaticMeshComponent.SetStaticMesh(HealingSyringeMeshes[SyringeNum].StaticMesh);
        NewKActor.LifeSpan = 30 * FClamp(WorldInfo.DestructionLifetimeScale, 0.1, 2);
        LinearVel.X = RandRange(-300, -100);
        LinearVel.Y = RandRange(-300, -100);
        NewKActor.StaticMeshComponent.SetRBLinearVelocity(Velocity + QuatRotateVector(BoneQuat, LinearVel));
        AngularVel.X = RandRange(3000, 6000);
        AngularVel.Y = RandRange(3000, 6000);
        AngularVel.Z = RandRange(3000, 6000);
        NewKActor.StaticMeshComponent.SetRBAngularVelocity(QuatRotateVector(BoneQuat, AngularVel));
        NewKActor.StaticMeshComponent.WakeRigidBody();
        NewKActor.StaticMeshComponent.SetLightingChannels(HealingSyringeMeshes[SyringeNum].LightingChannels);
        NewKActor.StaticMeshComponent.bCastDynamicShadow = true;
        NewKActor.StaticMeshComponent.bAllowPerObjectShadows = true;
        NewKActor.StaticMeshComponent.PerObjectShadowCullDistance = 4000;
    }
    Mesh.DetachComponent(HealingSyringeMeshes[SyringeNum]);
    HealingSyringeMeshes[SyringeNum] = none;
    HealingSyringeMICs[SyringeNum] = none;
}

simulated event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    local KFPawn KFP;

    super(KFPawn_Monster).Bump(Other, OtherComp, HitNormal);
    if(((((Role == ROLE_Authority) && bInFleeAndHealMode) && MyKFAIC != none) && !IsDoingSpecialMove()) && Other.GetTeamNum() != GetTeamNum())
    {
        KFP = KFPawn(Other);
        if(KFP != none)
        {
            if((WorldInfo.TimeSeconds - LastFleeAndHealEnemyBumpTime) > 1)
            {
                ++ NumFleeAndHealEnemyBumps;
                LastFleeAndHealEnemyBumpTime = WorldInfo.TimeSeconds;
                if(NumFleeAndHealEnemyBumps > 2)
                {
                    NumFleeAndHealEnemyBumps = 0;
                    KFAIController_ZedPatriarch(MyKFAIC).ForceHeal();
                }
            }
        }
    }
}

function FleeAndHealBump()
{
    local KFPawn KFP;
    local Vector ClosestPoint;
    local float ClosestDist;
    local KFAIController_ZedPatriarch KFAICP;

    if((((MyKFAIC == none) || MyKFAIC.Enemy == none) || MyKFAIC.RouteGoal == none) || IsDoingSpecialMove(18))
    {
        return;
    }
    KFAICP = KFAIController_ZedPatriarch(MyKFAIC);
    foreach WorldInfo.AllPawns(Class'KFPawn', KFP, Location, 300)
    {
        if((KFP != self) && KFP.IsAliveAndWell())
        {
            ClosestDist = PointDistToSegment(KFP.Location, Location, KFAICP.RouteGoal.Location, ClosestPoint);
            if(ClosestDist < ((GetCollisionRadius()) * 1.5))
            {
                KFAICP.DoHeavyBump(KFP, Normal(KFP.Location - Location));
            }
        }        
    }    
}

function bool DesireSprintingInThisPhase()
{
    return BattlePhases[CurrentBattlePhase - 1].bAllowedToSprint;
}

function IncrementBattlePhase()
{
    ++ CurrentBattlePhase;
    bHealedThisPhase = true;
    SetPhaseCooldowns(CurrentBattlePhase - 1);
    OnBattlePhaseChanged();
    bForceNetUpdate = true;
}

simulated function OnBattlePhaseChanged()
{
    if((WorldInfo.NetMode == NM_DedicatedServer) || Health <= 0)
    {
        return;
    }
    super.OnBattlePhaseChanged();
    UpdateBattlePhaseLights();
    UpdateBattlePhaseMaterials();
    UpdateBattlePhaseFX();
}

function SetPhaseCooldowns(int BattlePhase)
{
    SprintCooldownTime = BattlePhases[BattlePhase].SprintCooldownTime;
    TentacleGrabCooldownTime = BattlePhases[BattlePhase].TentacleGrabCooldownTime;
    MinigunAttackCooldownTime = BattlePhases[BattlePhase].MinigunAttackCooldownTime;
    MissileAttackCooldownTime = BattlePhases[BattlePhase].MissileAttackCooldownTime;
    ChargeAttackCooldownTime = BattlePhases[BattlePhase].ChargeAttackCooldownTime;
    TentacleDamage = BattlePhases[BattlePhase].TentacleDamage;
    MaxRageAttacks = BattlePhases[BattlePhase].MaxRageAttacks;
}

function StartWeaponCooldown()
{
    if((Controller != none) && KFAIController_ZedPatriarch(Controller) != none)
    {
        KFAIController_ZedPatriarch(Controller).LastSuccessfulAttackTime = WorldInfo.TimeSeconds;
    }
}

function bool CanChargeAttack()
{
    return !bIsCloaking && BattlePhases[CurrentBattlePhase - 1].bCanChargeAttack;
}

function bool CanTentacleGrab()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanTentacleGrab;
}

function bool CanMissileAttack()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanUseMissiles;
}

function bool CanMortarAttack()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanUseMortar;
}

function bool CanDoMortarBarrage()
{
    return BattlePhases[CurrentBattlePhase - 1].bCanDoMortarBarrage;
}

function bool CanBlock()
{
    local KFAIController_ZedPatriarch MyPatController;

    if((bIsCloaking || bInFleeAndHealMode) || !super(KFPawn_Monster).CanBlock())
    {
        return false;
    }
    if(!IsHumanControlled())
    {
        MyPatController = KFAIController_ZedPatriarch(Controller);
        if(MyPatController.bFleeing || MyPatController.bWantsToFlee)
        {
            return false;
        }
    }
    return true;
}

simulated function bool CanMoveWhenMinigunning()
{
    local KFGameReplicationInfo KFGRI;

    KFGRI = KFGameReplicationInfo(WorldInfo.GRI);
    if((KFGRI != none) && BattlePhases[CurrentBattlePhase - 1].bCanMoveWhenMinigunning[KFGRI.GetModifiedGameDifficulty()])
    {
        return true;
    }
    return LocalIsOnePlayerLeftInTeamGame();
}

simulated function SpinMinigunBarrels(bool bEnableSpin)
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        bSpinBarrels = bEnableSpin;
        if(bEnableSpin && BarrelSpinSkelCtrl != none)
        {
            BarrelSpinSkelCtrl.SetSkelControlActive(true);
        }
    }
}

simulated function SetGunTracking(bool bEnableTracking)
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        bGunTracking = bEnableTracking;
        GunTrackingSkelCtrl.SetSkelControlActive(bEnableTracking);
    }
    if(Role == ROLE_Authority)
    {
        if((bEnableTracking && Controller != none) && Controller.Enemy != none)
        {
            GunTarget = Controller.Enemy;            
        }
        else
        {
            GunTarget = none;
        }
    }
    bForceNetUpdate = true;
}

simulated event Vector GetWeaponStartTraceLocation(optional Weapon CurrentWeapon)
{
    local Vector SocketLoc;

    Mesh.GetSocketWorldLocationAndRotation('LeftMuzzleFlash', SocketLoc);
    return SocketLoc;
}

simulated function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    local Vector SocketLoc, EndTrace;
    local Rotator ActualAimRot, SocketRot;

    if(bSprayingFire)
    {
        Mesh.GetSocketWorldLocationAndRotation('LeftMuzzleFlash', SocketLoc, SocketRot);
        return SocketRot;
    }
    ActualAimRot = super(KFPawn).GetAdjustedAimFor(W, StartFireLoc);
    EndTrace = StartFireLoc + (vector(ActualAimRot) * W.GetTraceRange());
    Mesh.GetSocketWorldLocationAndRotation('LeftMuzzleFlash', SocketLoc, SocketRot);
    if((vector(SocketRot) Dot Normal(EndTrace - StartFireLoc)) < 0.96)
    {
        return SocketRot;
    }
    return ActualAimRot;
}

function class<KFProj_Missile_Patriarch> GetMissileClass()
{
    return MissileProjectileClass;
}

function GetMissileAimDirAndTargetLoc(int MissileNum, Vector MissileLoc, Rotator MissileRot, out Vector AimDir, out Vector TargetLoc)
{
    local Vector X, Y, Z;
    local int EnemyIndex;
    local KFAIController_ZedPatriarch MyPatController;
    local KFPawn EnemyPawn;

    MyPatController = KFAIController_ZedPatriarch(Controller);
    if(MyPatController == none)
    {
        return;
    }
    if(MyPatController.Enemy == none)
    {
        MyPatController.ForceSetEnemy(MyPatController.GetClosestEnemy());
    }
    if(MyPatController.Enemy == none)
    {
        EndSpecialMove();
        return;
    }
    EnemyPawn = KFPawn(MyPatController.Enemy);
    if(!MyPatController.CanSee(EnemyPawn))
    {
        EnemyIndex = MyPatController.RecentlySeenEnemyList.Find('TrackedEnemy', EnemyPawn;
        if(EnemyIndex != -1)
        {
            TargetLoc = MyPatController.RecentlySeenEnemyList[EnemyIndex].LastVisibleLocation;            
        }
        else
        {
            EnemyIndex = MyPatController.HiddenEnemies.Find('TrackedEnemy', EnemyPawn;
            if(EnemyIndex != -1)
            {
                TargetLoc = MyPatController.HiddenEnemies[EnemyIndex].LastVisibleLocation;                
            }
            else
            {
                TargetLoc = EnemyPawn.Location;
            }
        }        
    }
    else
    {
        TargetLoc = EnemyPawn.Location;
    }
    TargetLoc += (vect(0, 0, -1) * (EnemyPawn.GetCollisionHeight() * 0.25));
    if(!FastTrace(TargetLoc, MissileLoc,, true))
    {
        TargetLoc = EnemyPawn.Location + (vect(0, 0, 1) * EnemyPawn.BaseEyeHeight);
    }
    GetAxes(MissileRot, X, Y, Z);
    AimDir = Normal((TargetLoc - MissileLoc) + (Z * 6));
}

function class<KFProj_Missile_Patriarch> GetMortarClass()
{
    return MortarProjectileClass;
}

function bool CollectMortarTargets(optional bool bInitialTarget, optional bool bForceInitialTarget)
{
    local int NumTargets, I;
    local KFPawn KFP;
    local float TargetDistSQ;
    local Vector MortarVelocity, MortarStartLoc, TargetLoc, TargetProjection;
    local KFAIController_ZedPatriarch MyPatController;

    MyPatController = KFAIController_ZedPatriarch(Controller);
    MortarStartLoc = Location + (vect(0, 0, 1) * (GetCollisionHeight()));
    NumTargets = ((bInitialTarget) ? 0 : 1);
    I = 0;
    J0x72:

    if(I < MyPatController.HiddenEnemies.Length)
    {
        KFP = MyPatController.HiddenEnemies[I].TrackedEnemy;
        if(!KFP.IsAliveAndWell() || MortarTargets.Find('TargetPawn', KFP != -1)
        {            
        }
        else
        {
            TargetLoc = KFP.Location + (vect(0, 0, -1) * (KFP.GetCollisionHeight() * 0.8));
            TargetProjection = MortarStartLoc - TargetLoc;
            TargetDistSQ = VSizeSq(TargetProjection);
            if((TargetDistSQ > MinMortarRangeSQ) && TargetDistSQ < MaxMortarRangeSQ)
            {
                TargetLoc += (Normal(TargetProjection) * KFP.GetCollisionRadius());
                if(SuggestTossVelocity(MortarVelocity, TargetLoc, MortarStartLoc, MortarProjectileClass.default.Speed, 500, 1, vect(0, 0, 0),, (GetGravityZ()) * 0.8))
                {
                    if(!FastTrace(MortarStartLoc + (Normal(vect(0, 0, 1) + (Normal(TargetLoc - MortarStartLoc) * 0.9)) * FMax(VSize(MortarVelocity) * 0.55, 800)), MortarStartLoc,, true))
                    {                        
                    }
                    else
                    {
                        MortarTargets.Insert(NumTargets, 1;
                        MortarTargets[NumTargets].TargetPawn = KFP;
                        MortarTargets[NumTargets].TargetVelocity = MortarVelocity;
                        if(bInitialTarget || NumTargets == 2)
                        {
                            return true;
                        }
                        ++ NumTargets;
                    }
                }
            }
        }
        ++ I;
        goto J0x72;
    }
    if(((bForceInitialTarget || !bInitialTarget) && NumTargets < 2) && MyPatController.RecentlySeenEnemyList.Length > 0)
    {
        I = 0;
        J0x41A:

        if((I < MyPatController.RecentlySeenEnemyList.Length) && NumTargets < 3)
        {
            KFP = MyPatController.RecentlySeenEnemyList[I].TrackedEnemy;
            if(!KFP.IsAliveAndWell() || MortarTargets.Find('TargetPawn', KFP != -1)
            {                
            }
            else
            {
                TargetLoc = KFP.Location + (vect(0, 0, -1) * (KFP.GetCollisionHeight() * 0.8));
                TargetProjection = MortarStartLoc - TargetLoc;
                TargetDistSQ = VSizeSq(TargetProjection);
                if((TargetDistSQ > MinMortarRangeSQ) && TargetDistSQ < MaxMortarRangeSQ)
                {
                    TargetLoc += (Normal(TargetProjection) * KFP.GetCollisionRadius());
                    if(SuggestTossVelocity(MortarVelocity, TargetLoc, MortarStartLoc, MortarProjectileClass.default.Speed, 500, 1, vect(0, 0, 0),, (GetGravityZ()) * 0.8))
                    {
                        if(!FastTrace(MortarStartLoc + (Normal(vect(0, 0, 1) + (Normal(TargetLoc - MortarStartLoc) * 0.9)) * FMax(VSize(MortarVelocity) * 0.55, 800)), MortarStartLoc,, true))
                        {                            
                        }
                        else
                        {
                            MortarTargets.Insert(NumTargets, 1;
                            MortarTargets[NumTargets].TargetPawn = KFP;
                            MortarTargets[NumTargets].TargetVelocity = MortarVelocity;
                            if(bInitialTarget)
                            {
                                return true;
                            }
                            ++ NumTargets;
                        }
                    }
                }
            }
            ++ I;
            goto J0x41A;
        }
    }
    return false;
}

function PreMortarAttack();

function ClearMortarTargets()
{
    MortarTargets.Length = 0;
}

function Patriarch_MortarTarget GetMortarTarget(int MortarNum)
{
    if(MortarNum >= MortarTargets.Length)
    {
        return MortarTargets[Rand(MortarTargets.Length)];
    }
    return MortarTargets[MortarNum];
}

function GetMortarAimDirAndTargetLoc(int MissileNum, Vector MissileLoc, Rotator MissileRot, out Vector AimDir, out Vector TargetLoc, out float MissileSpeed)
{
    local Patriarch_MortarTarget MissileTarget;
    local Vector X, Y, Z;

    GetAxes(MissileRot, X, Y, Z);
    MissileTarget = GetMortarTarget(MissileNum);
    TargetLoc = MissileTarget.TargetPawn.Location + (vect(0, 0, -1) * MissileTarget.TargetPawn.GetCollisionHeight());
    AimDir = Normal(vect(0, 0, 1) + Normal(MissileTarget.TargetVelocity));
    MissileSpeed = VSize(MissileTarget.TargetVelocity);
}

simulated event Tick(float DeltaTime)
{
    local float MinCloakPct, Intensity, BoilPulseSin;
    local LinearColor ActualBoilColor;

    super(KFPawn_Monster).Tick(DeltaTime);
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(BarrelSpinSkelCtrl != none)
        {
            if(bSpinBarrels)
            {
                if(BarrelSpinSpeed < 300000)
                {
                    BarrelSpinSpeed = FMin(BarrelSpinSpeed + (DeltaTime * 200000), 500000);
                    BarrelSpinSkelCtrl.RotationRate.Roll = int(BarrelSpinSpeed);
                }                
            }
            else
            {
                if(BarrelSpinSpeed > 0)
                {
                    BarrelSpinSpeed = FMax(BarrelSpinSpeed - (DeltaTime * 150000), 0);
                    BarrelSpinSkelCtrl.RotationRate.Roll = int(BarrelSpinSpeed);
                    if(BarrelSpinSpeed == 0)
                    {
                        BarrelSpinSkelCtrl.SetSkelControlActive(false);
                    }
                }
            }
        }
        if(((ActiveSyringe > -1) && HealingSyringeMICs[ActiveSyringe] != none) && SyringeInjectTimeRemaining > 0)
        {
            SyringeInjectTimeRemaining -= DeltaTime;
            Intensity = FClamp(SyringeInjectTimeRemaining / SyringeInjectTimeDuration, 0, 1);
            HealingSyringeMICs[ActiveSyringe].SetScalarParameterValue('Scalar_GlowIntensity', Intensity);            
        }
        else
        {
            ActiveSyringe = -1;
        }
        if(bPulseBoils && !bIsCloaking)
        {
            if(BoilPulseAccum > 1)
            {
                BoilPulseAccum = -1;
            }
            BoilPulseSin = Abs(BoilPulseAccum);
            ActualBoilColor = Multiply_LinearColorFloat(BoilColors[3], BoilPulseSin);
            CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', ActualBoilColor);
            BoilPulseAccum += (DeltaTime * BoilPulseRate);            
        }
        else
        {
            BoilPulseSin = 1;
        }
        if(CharacterMICs[0].Parent != SpottedMaterial)
        {
            MinCloakPct = GetMinCloakPct();
            if(!bIsCloaking)
            {
                if(CloakPercent < 1)
                {
                    CloakPercent = FMin(CloakPercent + (DeltaTime * DeCloakSpeed), 1);
                    if(CloakPercent == 1)
                    {
                        UpdateGameplayMICParams();                        
                    }
                    else
                    {
                        CharacterMICs[0].SetScalarParameterValue('Transparency', CloakPercent);
                        CharacterMICs[1].SetScalarParameterValue('Transparency', CloakPercent);
                    }
                    if(bPulseBoils)
                    {
                        BoilLightComponent.SetLightProperties((BoilLightBrightness[CurrentBattlePhase - 1] * BoilPulseSin) * CloakPercent);
                    }
                    UpdateHealingSyringeTransparency();                    
                }
                else
                {
                    if(bPulseBoils)
                    {
                        BoilLightComponent.SetLightProperties(BoilLightBrightness[CurrentBattlePhase - 1] * BoilPulseSin);
                    }
                }                
            }
            else
            {
                if(CloakPercent > MinCloakPct)
                {
                    CloakPercent = FMax(CloakPercent - (DeltaTime * CloakSpeed), MinCloakPct);
                    CharacterMICs[0].SetScalarParameterValue('Transparency', CloakPercent);
                    CharacterMICs[1].SetScalarParameterValue('Transparency', CloakPercent);
                    if(BoilLightComponent.bEnabled)
                    {
                        BoilLightComponent.SetLightProperties(BoilLightBrightness[CurrentBattlePhase - 1] * CloakPercent);
                    }
                    UpdateHealingSyringeTransparency();
                    if((CloakPercent == 0) && BoilLightComponent.bEnabled)
                    {
                        BoilLightComponent.SetEnabled(false);
                        Mesh.DetachComponent(BoilLightComponent);
                    }
                }
            }
        }
    }
    UpdateGunTrackingSkelCtrl(DeltaTime);
}

simulated function UpdateGunTrackingSkelCtrl(float DeltaTime)
{
    if(GunTrackingSkelCtrl != none)
    {
        if(bGunTracking && GunTarget != none)
        {
            GunTrackingSkelCtrl.DesiredTargetLocation = GunTarget.Location;
            GunTrackingSkelCtrl.InterpolateTargetLocation(DeltaTime);            
        }
        else
        {
            GunTrackingSkelCtrl.SetSkelControlActive(false);
        }
    }
}

protected simulated function float GetMinCloakPct()
{
    return 0;
}

simulated function UpdateHealingSyringeTransparency()
{
    if(HealingSyringeMICs[0] != none)
    {
        HealingSyringeMICs[0].SetScalarParameterValue('Transparency', CloakPercent);
    }
    if(HealingSyringeMICs[1] != none)
    {
        HealingSyringeMICs[1].SetScalarParameterValue('Transparency', CloakPercent);
    }
    if(HealingSyringeMICs[2] != none)
    {
        HealingSyringeMICs[2].SetScalarParameterValue('Transparency', CloakPercent);
    }
}

simulated event NotifyGoreMeshActive()
{
    if((WorldInfo.NetMode != NM_DedicatedServer) && Mesh != none)
    {
        CharacterMICs[0] = Mesh.CreateAndSetMaterialInstanceConstant(0);
        CharacterMICs[1] = Mesh.CreateAndSetMaterialInstanceConstant(1);
        super(KFPawn_Monster).NotifyGoreMeshActive();
    }
}

function SetCloaked(bool bNewCloaking)
{
    if(bCanCloak && bNewCloaking != bIsCloaking)
    {
        if(bNewCloaking && (IsImpaired()) || IsIncapacitated())
        {
            return;
        }
        if(((MaxHeadChunkGoreWhileAlive == 0) && bIsCloaking != bNewCloaking) && IsAliveAndWell())
        {
            if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
            {
                KFGameInfo(WorldInfo.Game).DialogManager.PlaySpotCloakDialog(self, bNewCloaking);
            }
        }
        bIsCloaking = bNewCloaking;
        if(bIsCloaking)
        {
            bIsCloakingSpottedByLP = false;
            bIsCloakingSpottedByTeam = false;
            LastSpottedStatusUpdate = WorldInfo.TimeSeconds - 0.2;
        }
        if(WorldInfo.NetMode != NM_DedicatedServer)
        {
            if((bIsCloaking || bIsCloakingSpottedByLP) || bIsCloakingSpottedByTeam)
            {
                UpdateGameplayMICParams();
            }
        }
        super(KFPawn_Monster).SetCloaked(bNewCloaking);
    }
}

simulated function ClientCloakingStateUpdated()
{
    if(bIsCloaking)
    {
        ClearBloodDecals();
        UpdateGameplayMICParams();
        bIsCloakingSpottedByLP = false;
        bIsCloakingSpottedByTeam = false;
        LastSpottedStatusUpdate = WorldInfo.TimeSeconds - 0.2;        
    }
    else
    {
        if(bIsCloakingSpottedByLP || bIsCloakingSpottedByTeam)
        {
            UpdateGameplayMICParams();
        }
    }
}

function OnStackingAfflictionChanged(byte Id)
{
    local KFAIController_ZedPatriarch MyPatController;

    super(KFPawn_Monster).OnStackingAfflictionChanged(Id);
    if((Role == ROLE_Authority) && IsAliveAndWell())
    {
        if(Id == 0)
        {
            if(!bInFleeAndHealMode && !IsHumanControlled())
            {
                MyPatController = KFAIController_ZedPatriarch(Controller);
                if(!MyPatController.bWantsToFlee && !MyPatController.bFleeing)
                {
                    MyPatController.bSprintUntilAttack = false;
                    MyPatController.LastSprintTime = WorldInfo.TimeSeconds;
                }
                MyPatController.CachedChargeTarget = none;
                MyPatController.bWantsToCharge = false;
                MyPatController.LastChargeAttackTime = WorldInfo.TimeSeconds;
            }
            if(bIsCloaking)
            {
                SetCloaked(false);
            }
        }
    }
}

function CausePanicWander()
{
    local KFAIController_ZedPatriarch MyPatController;

    if(bInFleeAndHealMode)
    {
        return;
    }
    if(!IsHumanControlled())
    {
        MyPatController = KFAIController_ZedPatriarch(Controller);
        if(MyPatController.bWantsToFlee || MyPatController.bFleeing)
        {
            return;
        }
    }
    super(KFPawn_Monster).CausePanicWander();
}

simulated event UpdateSpottedStatus()
{
    local bool bOldSpottedByLP;
    local KFPlayerController LocalPC;
    local KFPerk LocalPerk;
    local float DistanceSq, Range;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    bOldSpottedByLP = bIsCloakingSpottedByLP;
    bIsCloakingSpottedByLP = false;
    LocalPC = KFPlayerController(GetALocalPlayerController());
    if(LocalPC != none)
    {
        LocalPerk = LocalPC.GetPerk();
    }
    if((((((LocalPC != none) && LocalPC.Pawn != none) && LocalPC.Pawn.IsAliveAndWell()) && LocalPerk != none) && LocalPerk.bCanSeeCloakedZeds) && (WorldInfo.TimeSeconds - LastRenderTime) < 1)
    {
        DistanceSq = VSizeSq(LocalPC.Pawn.Location - Location);
        Range = LocalPerk.GetCloakDetectionRange();
        if(DistanceSq < Square(Range))
        {
            bIsCloakingSpottedByLP = true;
            if(LocalPerk.IsCallOutActive())
            {
                LocalPC.ServerCallOutPawnCloaking(self);
            }
        }
    }
    if(!bIsCloakingSpottedByTeam)
    {
        if(bIsCloakingSpottedByLP != bOldSpottedByLP)
        {
            UpdateGameplayMICParams();
        }
    }
}

function CallOutCloaking(optional KFPlayerController CallOutController)
{
    bIsCloakingSpottedByTeam = true;
    UpdateGameplayMICParams();
    SetTimer(2, false, 'CallOutCloakingExpired');
}

function CallOutCloakingExpired()
{
    bIsCloakingSpottedByTeam = false;
    UpdateGameplayMICParams();
}

simulated function UpdateGameplayMICParams()
{
    local int I;
    local bool bIsSpotted, bWasCloaked;

    super.UpdateGameplayMICParams();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        bIsSpotted = bIsCloakingSpottedByLP || bIsCloakingSpottedByTeam;
        if((!bIsCloaking || IsImpaired()) && CharacterMICs[0].Parent != BodyMaterial)
        {
            bWasCloaked = (CharacterMICs[0].Parent == SpottedMaterial) || CharacterMICs[0].Parent == CloakedBodyMaterial;
            CharacterMICs[0].SetParent(BodyMaterial);
            CharacterMICs[1].SetParent(BodyAltMaterial);
            I = 0;
            J0x16A:

            if(I < HealingSyringeMICs.Length)
            {
                if(HealingSyringeMICs[I] != none)
                {
                    HealingSyringeMICs[I].SetParent(default.HealingSyringeMeshes[I].Materials[0]);
                }
                ++ I;
                goto J0x16A;
            }
            Mesh.AttachComponentToSocket(BoilLightComponent, BoilLightSocketName);
            BoilLightComponent.SetEnabled(true);
            Mesh.CastShadow = true;
            Mesh.SetPerObjectShadows(true);
            if(bWasCloaked)
            {
                SetDamageFXActive(true);
                PlayStealthSoundLoopEnd();
                DoCloakFX();
            }
            I = 0;
            J0x2C5:

            if(I < 3)
            {
                if(ThirdPersonAttachments[I] != none)
                {
                    ThirdPersonAttachments[I].SetHidden(false);
                }
                ++ I;
                goto J0x2C5;
            }            
        }
        else
        {
            if((bIsCloaking && bIsSpotted) && CharacterMICs[0].Parent != SpottedMaterial)
            {
                CloakPercent = 1;
                CharacterMICs[0].SetParent(SpottedMaterial);
                CharacterMICs[1].SetParent(SpottedMaterial);
                I = 0;
                J0x3E3:

                if(I < HealingSyringeMICs.Length)
                {
                    if(HealingSyringeMICs[I] != none)
                    {
                        HealingSyringeMICs[I].SetParent(SpottedMaterial);
                    }
                    ++ I;
                    goto J0x3E3;
                }
                Mesh.CastShadow = false;
                Mesh.SetPerObjectShadows(false);
                SetDamageFXActive(false);
                I = 0;
                J0x4AB:

                if(I < 3)
                {
                    if(ThirdPersonAttachments[I] != none)
                    {
                        ThirdPersonAttachments[I].SetHidden(true);
                    }
                    ++ I;
                    goto J0x4AB;
                }                
            }
            else
            {
                if((bIsCloaking && !bIsSpotted) && CharacterMICs[0].Parent != CloakedBodyMaterial)
                {
                    CharacterMICs[0].SetParent(CloakedBodyMaterial);
                    CharacterMICs[1].SetParent(CloakedBodyAltMaterial);
                    I = 0;
                    J0x5BC:

                    if(I < HealingSyringeMICs.Length)
                    {
                        if(HealingSyringeMICs[I] != none)
                        {
                            HealingSyringeMICs[I].SetParent(CloakedBodyAltMaterial);
                        }
                        ++ I;
                        goto J0x5BC;
                    }
                    PlayStealthSoundLoop();
                    DoCloakFX();
                    Mesh.CastShadow = false;
                    Mesh.SetPerObjectShadows(false);
                    SetDamageFXActive(false);
                    I = 0;
                    J0x698:

                    if(I < 3)
                    {
                        if(ThirdPersonAttachments[I] != none)
                        {
                            ThirdPersonAttachments[I].SetHidden(true);
                        }
                        ++ I;
                        goto J0x698;
                    }
                }
            }
        }
    }
}

simulated function DoCloakFX()
{
    local editinline ParticleSystemComponent CloakPSC;

    CloakPSC = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(CloakFX, Mesh, CloakFXSocketName, true);
    CloakPSC.SetAbsolute(false, true, false);
}

simulated function UpdateBattlePhaseMaterials()
{
    if((((CharacterMICs[0] == none) || CharacterMICs[1] == none) || bIsCloakingSpottedByLP) || bIsCloakingSpottedByTeam)
    {
        return;
    }
    switch(CurrentBattlePhase)
    {
        case 1:
            CharacterMICs[0].SetScalarParameterValue('Scalar_BattleGrime', 0);
            CharacterMICs[0].SetScalarParameterValue('Scalar_GlowFlashing', 0);
            CharacterMICs[0].SetVectorParameterValue('Vector_GlowColor', MechColors[0]);
            CharacterMICs[1].SetScalarParameterValue('Scalar_BattleGrime', 0);
            CharacterMICs[1].SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 0);
            CharacterMICs[1].SetScalarParameterValue('Scalar_GlowFlashing', 0);
            CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', BoilColors[0]);
            break;
        case 2:
            CharacterMICs[0].SetScalarParameterValue('Scalar_BattleGrime', 0.3);
            CharacterMICs[0].SetScalarParameterValue('Scalar_GlowFlashing', 0.25);
            CharacterMICs[0].SetVectorParameterValue('Vector_GlowColor', MechColors[1]);
            CharacterMICs[1].SetScalarParameterValue('Scalar_BattleGrime', 0.25);
            CharacterMICs[1].SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1);
            CharacterMICs[1].SetScalarParameterValue('Scalar_GlowFlashing', 0);
            CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', BoilColors[1]);
            break;
        case 3:
            CharacterMICs[0].SetScalarParameterValue('Scalar_BattleGrime', 0.7);
            CharacterMICs[0].SetScalarParameterValue('Scalar_GlowFlashing', 0.5);
            CharacterMICs[0].SetVectorParameterValue('Vector_GlowColor', MechColors[2]);
            CharacterMICs[1].SetScalarParameterValue('Scalar_BattleGrime', 0.5);
            CharacterMICs[1].SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1.2);
            CharacterMICs[1].SetScalarParameterValue('Scalar_GlowFlashing', 0);
            CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', BoilColors[2]);
            break;
        case 4:
            CharacterMICs[0].SetScalarParameterValue('Scalar_BattleGrime', 1.1);
            CharacterMICs[0].SetScalarParameterValue('Scalar_GlowFlashing', 0.75);
            CharacterMICs[0].SetVectorParameterValue('Vector_GlowColor', MechColors[3]);
            CharacterMICs[1].SetScalarParameterValue('Scalar_BattleGrime', 0.75);
            CharacterMICs[1].SetScalarParameterValue('Scalar_Damage_Blood_Contrast', 1.3);
            CharacterMICs[1].SetScalarParameterValue('Scalar_GlowFlashing', 0);
            CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', BoilColors[3]);
            bPulseBoils = true;
            break;
        default:
            break;
    }
}

simulated function UpdateBattlePhaseLights()
{
    local LinearColor LinearBoilColor;
    local Color BoilColor;
    local byte BattlePhaseArrayNum;

    if(Health <= 0)
    {
        return;
    }
    BattlePhaseArrayNum = byte(CurrentBattlePhase - 1);
    LinearBoilColor = Multiply_LinearColorFloat(BoilColors[BattlePhaseArrayNum], 0.6);
    BoilColor.R = byte(255 * LinearBoilColor.R);
    BoilColor.G = byte(255 * LinearBoilColor.G);
    BoilColor.B = byte(255 * LinearBoilColor.B);
    BoilColor.A = 255;
    BoilLightComponent.SetLightProperties(BoilLightBrightness[BattlePhaseArrayNum], BoilColor);
}

simulated function UpdateBattlePhaseFX()
{
    if((((Health <= 0) || WorldInfo.MyEmitterPool == none) || CurrentBattlePhase == 1) || LastFXBattlePhase == CurrentBattlePhase)
    {
        return;
    }
    switch(CurrentBattlePhase)
    {
        case 2:
            BattleDamagePSC_LeftFoot = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_LowDmg, Mesh, BattleDamageFXSocketName_LeftFoot, true);
            BattleDamagePSC_LeftArm = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_MidDmg, Mesh, BattleDamageFXSocketName_LeftArm, true);
            BattleDamagePSC_UpperSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_LowDmg, Mesh, BattleDamageFXSocketName_UpperSpike, true);
            break;
        case 3:
            DetachEmitter(BattleDamagePSC_LeftFoot);
            DetachEmitter(BattleDamagePSC_LeftArm);
            DetachEmitter(BattleDamagePSC_UpperSpike);
            BattleDamagePSC_LeftFoot = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_HighDmg, Mesh, BattleDamageFXSocketName_LeftFoot, true);
            BattleDamagePSC_LeftHip = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_HighDmg, Mesh, BattleDamageFXSocketName_LeftHip, true);
            BattleDamagePSC_LeftArm = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_MidDmg, Mesh, BattleDamageFXSocketName_LeftArm, true);
            BattleDamagePSC_Weapon = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_LowDmg, Mesh, BattleDamageFXSocketName_Weapon, true);
            BattleDamagePSC_UpperSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_MidDmg, Mesh, BattleDamageFXSocketName_UpperSpike, true);
            BattleDamagePSC_BackSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_MidDmg, Mesh, BattleDamageFXSocketName_BackSpike, true);
            break;
        case 4:
            DetachEmitter(BattleDamagePSC_Weapon);
            DetachEmitter(BattleDamagePSC_LeftArm);
            DetachEmitter(BattleDamagePSC_UpperSpike);
            DetachEmitter(BattleDamagePSC_BackSpike);
            BattleDamagePSC_LeftKnee = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Sparks_HighDmg, Mesh, BattleDamageFXSocketName_LeftKnee, true);
            BattleDamagePSC_LeftArm = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Smoke_HighDmg, Mesh, BattleDamageFXSocketName_LeftArm, true);
            BattleDamagePSC_Weapon = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Smoke_HighDmg, Mesh, BattleDamageFXSocketName_Weapon, true);
            BattleDamagePSC_LowerSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_MidDmg, Mesh, BattleDamageFXSocketName_LowerSpike, true);
            BattleDamagePSC_UpperSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_HighDmg, Mesh, BattleDamageFXSocketName_UpperSpike, true);
            BattleDamagePSC_BackSpike = WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(BattleDamageFX_Tentacle_MidDmg, Mesh, BattleDamageFXSocketName_BackSpike, true);
            break;
        default:
            break;
    }
    if(bIsCloaking)
    {
        SetDamageFXActive(false);
    }
    LastFXBattlePhase = CurrentBattlePhase;
}

simulated function SetDamageFXActive(bool bEnable)
{
    if(Health <= 0)
    {
        if(BattleDamagePSC_LeftFoot != none)
        {
            BattleDamagePSC_LeftFoot.SetActive(false);
        }
        if(BattleDamagePSC_LeftKnee != none)
        {
            BattleDamagePSC_LeftKnee.SetActive(false);
        }
        if(BattleDamagePSC_LeftHip != none)
        {
            BattleDamagePSC_LeftHip.SetActive(false);
        }
        if(BattleDamagePSC_LeftArm != none)
        {
            BattleDamagePSC_LeftArm.SetActive(false);
        }
        if(BattleDamagePSC_Weapon != none)
        {
            BattleDamagePSC_Weapon.SetActive(false);
        }
        if(BattleDamagePSC_LowerSpike != none)
        {
            BattleDamagePSC_LowerSpike.SetActive(false);
        }
        if(BattleDamagePSC_UpperSpike != none)
        {
            BattleDamagePSC_UpperSpike.SetActive(false);
        }
        if(BattleDamagePSC_BackSpike != none)
        {
            BattleDamagePSC_BackSpike.SetActive(false);
        }
        return;
    }
    if(BattleDamagePSC_LeftFoot != none)
    {
        BattleDamagePSC_LeftFoot.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_LeftKnee != none)
    {
        BattleDamagePSC_LeftKnee.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_LeftHip != none)
    {
        BattleDamagePSC_LeftHip.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_LeftArm != none)
    {
        BattleDamagePSC_LeftArm.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_Weapon != none)
    {
        BattleDamagePSC_Weapon.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_LowerSpike != none)
    {
        BattleDamagePSC_LowerSpike.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_UpperSpike != none)
    {
        BattleDamagePSC_UpperSpike.SetHidden(!bEnable);
    }
    if(BattleDamagePSC_BackSpike != none)
    {
        BattleDamagePSC_BackSpike.SetHidden(!bEnable);
    }
}

simulated function PlayTakeHitEffects(Vector HitDirection, Vector HitLocation, optional bool bUseHitImpulse)
{
    bUseHitImpulse = true;
    super(KFPawn_Monster).PlayTakeHitEffects(HitDirection, HitLocation, bUseHitImpulse);
    if(((!bIsCloaking || CharacterMICs[0].Parent == SpottedMaterial) || CloakPercent > CloakShimmerAmount) || (WorldInfo.TimeSeconds - LastCloakShimmerTime) < 0.1)
    {
        return;
    }
    LastCloakShimmerTime = WorldInfo.TimeSeconds;
    CloakPercent = FClamp(CloakPercent + CloakShimmerAmount, 0, 0.8);
}

simulated function KFSkinTypeEffects GetHitZoneSkinTypeEffects(int HitZoneIdx)
{
    if(bIsCloaking)
    {
        return CharacterArch.ImpactSkins[4];
    }
    return super(KFPawn).GetHitZoneSkinTypeEffects(HitZoneIdx);
}

function bool CanInjureHitZone(class<DamageType> DamageType, int HitZoneIdx)
{
    local class<KFDamageType> KFDmgType;
    local name HitZoneName;

    if(bPlayedDeath)
    {
        KFDmgType = class<KFDamageType>(DamageType);
        HitZoneName = HitZones[HitZoneIdx].ZoneName;
        if((KFDmgType != none) && KFDmgType.static.CanDismemberHitZone(HitZoneName))
        {
            return true;
        }
    }
    return false;
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    local int I;

    bSpinBarrels = false;
    SetGunTracking(false);
    SetCloaked(false);
    bCanCloak = false;
    if((WorldInfo.NetMode != NM_DedicatedServer) && CurrentBattlePhase < 4)
    {
        I = CurrentBattlePhase - 1;
        J0x7F:

        if(I < HealingSyringeMeshes.Length)
        {
            if(I == CurrentSyringeMeshNum)
            {                
            }
            else
            {
                if(HealingSyringeMeshes[I] == none)
                {                    
                }
                else
                {
                    BreakOffSyringe(I);
                }
            }
            ++ I;
            goto J0x7F;
        }
    }
    super(KFPawn_Monster).PlayDying(DamageType, HitLoc);
    ClearMortarTargets();
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        SetDamageFXActive(false);
    }
    Mesh.HideBoneByName('Syringe', 0);
}

simulated function TerminateEffectsOnDeath()
{
    bPulseBoils = false;
    if((CharacterMICs.Length > 0) && CharacterMICs[0] != none)
    {
        CharacterMICs[0].SetVectorParameterValue('Vector_GlowColor', DeadMechColor);
        CharacterMICs[0].SetScalarParameterValue('Scalar_GlowFlashing', 0);
    }
    if((CharacterMICs.Length > 1) && CharacterMICs[1] != none)
    {
        CharacterMICs[1].SetVectorParameterValue('Vector_GlowColor', DeadBoilColor);
        CharacterMICs[1].SetScalarParameterValue('Scalar_GlowFlashing', 0);
    }
    BoilLightComponent.SetEnabled(false);
    DetachComponent(BoilLightComponent);
    PlayStealthSoundLoopEnd();
    super.TerminateEffectsOnDeath();
}

function CauseHeadTrauma(optional float BleedOutTime)
{
    BleedOutTime = 5;
    super.CauseHeadTrauma(BleedOutTime);
    if((bIsHeadless && IsAliveAndWell()) && !IsDoingSpecialMove())
    {
        SetCloaked(false);
    }
}

simulated event PlayFootStepSound(int FootDown)
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        if(IsHumanControlled() && IsLocallyControlled())
        {
            FootstepCameraShake.RotOscillation.Pitch.Amplitude = 0;
            FootstepCameraShake.RotOscillation.Roll.Amplitude = 0;            
        }
        else
        {
            FootstepCameraShake.RotOscillation.Pitch.Amplitude = FootstepCameraShakePitchAmplitude;
            FootstepCameraShake.RotOscillation.Roll.Amplitude = FootstepCameraShakeRollAmplitude;
            FootstepCameraShakeInnerRadius = default.FootstepCameraShakeInnerRadius;
            FootstepCameraShakeOuterRadius = default.FootstepCameraShakeOuterRadius;
            if(!bIsSprinting || VSizeSq(Velocity) < 10000)
            {
                FootstepCameraShake.RotOscillation.Pitch.Amplitude *= 0.75;
                FootstepCameraShake.RotOscillation.Roll.Amplitude *= 0.75;
            }
        }
    }
    super(KFPawn_Monster).PlayFootStepSound(FootDown);
}

simulated function SetWeaponAmbientSound(AkEvent NewAmbientSound, optional AkEvent FirstPersonAmbientSound)
{
    if((Controller != none) && Controller.IsInState('ZedVictory'))
    {
        NewAmbientSound = none;
        FirstPersonAmbientSound = none;
    }
    super(KFPawn).SetWeaponAmbientSound(NewAmbientSound, FirstPersonAmbientSound);
}

function int GetSpotterDialogID()
{
    if(bIsCloaking && MaxHeadChunkGoreWhileAlive == 0)
    {
        return 135;
    }
    return 125;
}

simulated function PlayStealthSoundLoop()
{
    if((WorldInfo.NetMode != NM_DedicatedServer) && !CloakedAkComponent.IsPlaying(CloakedLoop))
    {
        CloakedAkComponent.PlayEvent(CloakedLoop, true, true);
    }
}

simulated function PlayStealthSoundLoopEnd()
{
    if((WorldInfo.NetMode != NM_DedicatedServer) && CloakedAkComponent.IsPlaying(CloakedLoop))
    {
        CloakedAkComponent.PlayEvent(CloakedLoopEnd, true, true);
    }
}

function PlayMinigunWarnDialog()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyMinigunWarnDialog(self);
    }
}

function PlayMinigunAttackDialog()
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyMinigunAttackDialog(self);
    }
}

function PlayGrabbedPlayerDialog(KFPawn_Human Target)
{
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPattyTentaclePullDialog(self);
    }
    if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
    {
        KFGameInfo(WorldInfo.Game).DialogManager.PlayPlayerGrabbedByPatriarchDialog(Target);
    }
}

function Timer_TickPatriarchDialog()
{
    if(!IsAliveAndWell())
    {
        return;
    }
    if(!IsDoingSpecialMove())
    {
        if(((Role == ROLE_Authority) && KFGameInfo(WorldInfo.Game) != none) && KFGameInfo(WorldInfo.Game).DialogManager != none)
        {
            KFGameInfo(WorldInfo.Game).DialogManager.PlayPatriarchTickDialog(self);
        }
    }
    SetTimer(TickDialogInterval, false, 'Timer_TickPatriarchDialog');
}

function PlayBossMusic()
{
    if(KFGameInfo(WorldInfo.Game) != none)
    {
        KFGameInfo(WorldInfo.Game).ForcePatriarchMusicTrack();
    }
}

defaultproperties
{
    begin object name=CloakedAkComponent0 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_ZedPatriarch.CloakedAkComponent0'
    CloakedAkComponent=CloakedAkComponent0
    CloakedLoop=AkEvent'WW_ZED_Patriarch.Play_Patriarch_Cloak'
    CloakedLoopEnd=AkEvent'WW_ZED_Patriarch.Stop_Patriarch_Cloak'
    BodyMaterial=MaterialInstanceConstant'ZED_Patriarch_MAT.ZED_Patriarch_Mech_M'
    BodyAltMaterial=MaterialInstanceConstant'ZED_Patriarch_MAT.ZED_Patriarch_M'
    SpottedMaterial=MaterialInstanceConstant'ZED_Stalker_MAT.ZED_Stalker_Visible_MAT'
    CloakedBodyMaterial=MaterialInstanceConstant'ZED_Patriarch_MAT.ZED_Patriarch_Mech_Cloak_M'
    CloakedBodyAltMaterial=MaterialInstanceConstant'ZED_Patriarch_MAT.ZED_Patriarch_Cloak_M'
    begin object name=KFSyringeStaticMeshComponent1 class=StaticMeshComponent
        StaticMesh=StaticMesh'ZED_Patriarch_MESH.CHR_Patriarch_Syringe'
        Materials=/* Array type was not detected. */
        ReplacementPrimitive=none
        MaxDrawDistance=4000
        CachedMaxDrawDistance=4000
        bAcceptsDynamicDecals=false
        bUseOnePassLightingOnTranslucency=true
        CollideActors=false
        BlockRigidBody=false
        AlwaysLoadOnServer=false
        Rotation=(Pitch=16384,Yaw=0,Roll=0)
        PerObjectShadowCullDistance=4000
        bAllowPerObjectShadows=true
    object end
    // Reference: StaticMeshComponent'Default__KFPawn_ZedPatriarch.KFSyringeStaticMeshComponent1'
    HealingSyringeMeshes(0)=KFSyringeStaticMeshComponent1
    begin object name=KFSyringeStaticMeshComponent2 class=StaticMeshComponent
        StaticMesh=StaticMesh'ZED_Patriarch_MESH.CHR_Patriarch_Syringe'
        Materials=/* Array type was not detected. */
        ReplacementPrimitive=none
        MaxDrawDistance=4000
        CachedMaxDrawDistance=4000
        bAcceptsDynamicDecals=false
        bUseOnePassLightingOnTranslucency=true
        CollideActors=false
        BlockRigidBody=false
        AlwaysLoadOnServer=false
        Rotation=(Pitch=16384,Yaw=0,Roll=0)
        PerObjectShadowCullDistance=4000
        bAllowPerObjectShadows=true
    object end
    // Reference: StaticMeshComponent'Default__KFPawn_ZedPatriarch.KFSyringeStaticMeshComponent2'
    HealingSyringeMeshes(1)=KFSyringeStaticMeshComponent2
    begin object name=KFSyringeStaticMeshComponent3 class=StaticMeshComponent
        StaticMesh=StaticMesh'ZED_Patriarch_MESH.CHR_Patriarch_Syringe'
        Materials=/* Array type was not detected. */
        ReplacementPrimitive=none
        MaxDrawDistance=4000
        CachedMaxDrawDistance=4000
        bAcceptsDynamicDecals=false
        bUseOnePassLightingOnTranslucency=true
        CollideActors=false
        BlockRigidBody=false
        AlwaysLoadOnServer=false
        Rotation=(Pitch=16384,Yaw=0,Roll=0)
        PerObjectShadowCullDistance=4000
        bAllowPerObjectShadows=true
    object end
    // Reference: StaticMeshComponent'Default__KFPawn_ZedPatriarch.KFSyringeStaticMeshComponent3'
    HealingSyringeMeshes(2)=KFSyringeStaticMeshComponent3
    CurrentSyringeMeshNum=-1
    ActiveSyringe=-1
    SyringeInjectTimeDuration=0.16
    MechColors[0]=(R=0,G=0,B=0,A=1)
    MechColors[1]=(R=0.19,G=0.12,B=0,A=1)
    MechColors[2]=(R=0.48,G=0.076,B=0,A=1)
    MechColors[3]=(R=0.79,G=0,B=0,A=1)
    DeadMechColor=(R=0.05,G=0,B=0,A=1)
    BoilColors[0]=(R=0,G=0.28,B=0.09,A=1)
    BoilColors[1]=(R=0.72,G=0.73,B=0.25,A=1)
    BoilColors[2]=(R=0.54,G=0.079,B=0,A=1)
    BoilColors[3]=(R=0.85,G=0,B=0.003,A=1)
    DeadBoilColor=(R=0.05,G=0,B=0,A=1)
    bUseServerSideGunTracking=true
    BoilPulseRate=2.5
    BoilLightBrightness[0]=2.6
    BoilLightBrightness[1]=2.7
    BoilLightBrightness[2]=2.8
    BoilLightBrightness[3]=2.9
    BoilLightSocketName=BoilLightSocket
    begin object name=BoilLightComponent0 class=PointLightComponent
        Radius=190
        FalloffExponent=10
        Brightness=2
        LightColor=(B=50,G=200,R=50,A=255)
        bEnabled=false
        CastShadows=false
        bCastPerObjectShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFPawn_ZedPatriarch.BoilLightComponent0'
    BoilLightComponent=BoilLightComponent0
    CloakFX=ParticleSystem'ZED_Patriarch_EMIT.FX_Patriarch_Cloaking_01'
    CloakFXSocketName=CloakFXSocket
    CloakShimmerAmount=0.6
    BattleDamageFXSocketName_LeftHip=FX_LeftHip
    BattleDamageFXSocketName_LeftKnee=FX_LeftKnee
    BattleDamageFXSocketName_LeftFoot=FX_LeftFoot
    BattleDamageFXSocketName_LeftArm=FX_LeftArm
    BattleDamageFXSocketName_Weapon=MissileCenter
    BattleDamageFXSocketName_LowerSpike=FX_Right_Arm_Spike
    BattleDamageFXSocketName_UpperSpike=FX_Upper_Back_Spike
    BattleDamageFXSocketName_BackSpike=FX_Back_Spike
    BattleDamageFX_Sparks_LowDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Pat_Sparks_LowD_01'
    BattleDamageFX_Sparks_MidDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Pat_sparks_MidD_01'
    BattleDamageFX_Sparks_HighDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Pat_Sparks_HighD_01'
    BattleDamageFX_Tentacle_LowDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Patriarch_tentacle_LowD_01'
    BattleDamageFX_Tentacle_MidDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Patriarch_tentacle_MidD_01'
    BattleDamageFX_Tentacle_HighDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Patriarch_tentacle_HighD_01'
    BattleDamageFX_Smoke_HighDmg=ParticleSystem'ZED_Patriarch_EMIT.FX_Pat_smoke_HighD_01'
    TickDialogInterval=0.5
    FootstepCameraShakePitchAmplitude=120
    FootstepCameraShakeRollAmplitude=60
    LastFXBattlePhase=1
    BattlePhases(0)=bAllowedToSprint=true,SprintCooldownTime=3,bCanTentacleGrab=false,TentacleGrabCooldownTime=0,bCanUseMissiles=true,MissileAttackCooldownTime=10,bCanUseMortar=false,MortarAttackCooldownTime=0,bCanDoMortarBarrage=false,bCanChargeAttack=true,ChargeAttackCooldownTime=14,MaxRageAttacks=0,TentacleDamage=0,MinigunAttackCooldownTime=2.25,bCanSummonMinions=true,bCanMoveWhenMinigunning=(
/* Exception thrown while deserializing bCanMoveWhenMinigunning
System.InvalidOperationException: Nullable object must have a value.
   at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */,
/* Exception thrown while deserializing bCanMoveWhenMinigunning
System.InvalidOperationException: Nullable object must have a value.
   at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */,
/* Exception thrown while deserializing bCanMoveWhenMinigunning
System.InvalidOperationException: Nullable object must have a value.
   at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */,
/* Exception thrown while deserializing bCanMoveWhenMinigunning
System.InvalidOperationException: Nullable object must have a value.
   at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */),
/* Exception thrown while deserializing BattlePhases
System.ArgumentException: Requested value '0_509' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    BattlePhases(1)=
/* Exception thrown while deserializing BattlePhases
System.ArgumentException: Requested value '0_3' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    BattlePhases(2)=
/* Exception thrown while deserializing BattlePhases
System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    BattlePhases(3)=
/* Exception thrown while deserializing BattlePhases
System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    TentacleDamageType=Class'KFDT_Slashing_PatTentacle'
    HeavyBumpDamageType=Class'KFDT_HeavyZedBump'
    MissileProjectileClass=Class'KFProj_Missile_Patriarch'
    MortarProjectileClass=Class'KFProj_Mortar_Patriarch'
    MinMortarRangeSQ=160000
    MaxMortarRangeSQ=6000000
    FleeSprintSpeedModifier=1.25
    CloakPercent=1
    CloakSpeed=3
    DeCloakSpeed=4.5
    SummonWaves[0]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Normal_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Normal_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Normal_Three')
    SummonWaves[1]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Hard_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Hard_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Hard_Three')
    SummonWaves[2]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Suicidal_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Suicidal_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_Suicidal_Three')
    SummonWaves[3]=(PhaseOneWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_HOE_One',PhaseTwoWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_HOE_Two',PhaseThreeWave=KFAIWaveInfo'GP_Spawning_ARCH.Special.Pat_Minions_HOE_Three')
    NumMinionsToSpawn=(X=6,Y=10)
    CurrentBattlePhase=1
    BossCaptionStrings=/* Array type was not detected. */
    bLargeZed=true
    bCanGrabAttack=true
    MonsterArchPath="ZED_ARCH.ZED_Patriarch_Archetype"
    HeadlessBleedOutTime=6
    ParryResistance=4
    begin object name=MeleeHelper class=KFMeleeHelperAI
        BaseDamage=55
        MyDamageType=Class'KFDT_Bludgeon_Patriarch'
        MomentumTransfer=40000
        MaxHitRange=375
    object end
    // Reference: KFMeleeHelperAI'Default__KFPawn_ZedPatriarch.MeleeHelper'
    MeleeAttackHelper=MeleeHelper
    DoshValue=500
    XPValues[0]=1291
    XPValues[1]=1694
    XPValues[2]=1790
    XPValues[3]=1843
    WeakSpotSocketNames=/* Array type was not detected. */
    DamageTypeModifiers=/* Array type was not detected. */
    DifficultySettings=Class'KFDifficulty_Patriarch'
    BumpDamageType=Class'KFGame.KFDT_NPCBump_Large'
    FootstepCameraShakeInnerRadius=200
    FootstepCameraShakeOuterRadius=1000
    begin object name=FootstepCameraShake0 class=CameraShake
        bSingleInstance=true
        OscillationDuration=0.25
        RotOscillation=(Pitch=(Amplitude=120,Frequency=60),Roll=(Amplitude=60,Frequency=40))
    object end
    // Reference: CameraShake'Default__KFPawn_ZedPatriarch.FootstepCameraShake0'
    FootstepCameraShake=FootstepCameraShake0
    SprintAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.SprintAkComponent0'
    HeadShotAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.HeadshotAkComponent0'
    OnDeathAchievementID=130
    ShrinkEffectModifier=0.15
    PawnAnimInfo=KFPawnAnimInfo'ZED_Patriarch_ANIM.Patriarch_AnimGroup'
    LocalizationKey=KFPawn_ZedPatriarch
    begin object name=ThirdPersonHead0 class=SkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: SkeletalMeshComponent'Default__KFPawn_ZedPatriarch.ThirdPersonHead0'
    ThirdPersonHeadMeshComponent=ThirdPersonHead0
    bEnableAimOffset=true
    bCanCloak=true
    HitZones=/* Array type was not detected. */
    PenetrationResistance=4
    begin object name=Afflictions class=KFAfflictionManager
        AfflictionClasses=/* Array type was not detected. */
        FireFullyCharredDuration=50
        FireCharPercentThreshhold=0.35
    object end
    // Reference: KFAfflictionManager'Default__KFPawn_ZedPatriarch.Afflictions'
    AfflictionHandler=Afflictions
    IncapSettings=/* Array type was not detected. */
    KnockdownImpulseScale=1
    SprintSpeed=650
    DefaultInventory=/* Array type was not detected. */
    begin object name=FirstPersonArms class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedPatriarch.FirstPersonArms'
    ArmsMesh=FirstPersonArms
    begin object name=SpecialMoveHandler class=KFSpecialMoveHandler
        SpecialMoveClasses=/* Array type was not detected. */
    object end
    // Reference: KFSpecialMoveHandler'Default__KFPawn_ZedPatriarch.SpecialMoveHandler'
    SpecialMoveHandler=SpecialMoveHandler
    AmbientAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.AmbientAkSoundComponent_1'
    WeaponAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.AmbientAkSoundComponent'
    WeaponAmbientEchoHandler=KFWeaponAmbientEchoHandler'Default__KFPawn_ZedPatriarch.WeaponAmbientEchoHandler'
    SecondaryWeaponAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.SecondaryWeaponAkSoundComponent'
    FootstepAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.FootstepAkSoundComponent'
    DialogAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.DialogAkSoundComponent'
    PowerUpAkComponent=AkComponent'Default__KFPawn_ZedPatriarch.PowerUpAkSoundComponent'
    DamageRecoveryTimeHeavy=0.65
    DamageRecoveryTimeMedium=0.85
    Mass=400
    GroundSpeed=260
    Health=3750
    ControllerClass=Class'KFAIController_ZedPatriarch'
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedPatriarch.KFPawnSkeletalMeshComponent'
    Mesh=KFPawnSkeletalMeshComponent
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedPatriarch.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__KFPawn_ZedPatriarch.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedPatriarch.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__KFPawn_ZedPatriarch.Arrow'
    Components(2)=Arrow
    begin object name=KFPawnSkeletalMeshComponent class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFPawn_ZedPatriarch.KFPawnSkeletalMeshComponent'
    Components(3)=KFPawnSkeletalMeshComponent
    Components(4)=AkComponent'Default__KFPawn_ZedPatriarch.AmbientAkSoundComponent'
    Components(5)=AkComponent'Default__KFPawn_ZedPatriarch.AmbientAkSoundComponent_1'
    Components(6)=AkComponent'Default__KFPawn_ZedPatriarch.FootstepAkSoundComponent'
    Components(7)=AkComponent'Default__KFPawn_ZedPatriarch.DialogAkSoundComponent'
    Components(8)=AkComponent'Default__KFPawn_ZedPatriarch.PowerUpAkSoundComponent'
    Components(9)=AkComponent'Default__KFPawn_ZedPatriarch.SecondaryWeaponAkSoundComponent'
    Components(10)=AkComponent'Default__KFPawn_ZedPatriarch.SprintAkComponent0'
    Components(11)=AkComponent'Default__KFPawn_ZedPatriarch.HeadshotAkComponent0'
    begin object name=CloakedAkComponent0 class=AkComponent
        BoneName=Dummy
        bStopWhenOwnerDestroyed=true
        bForceOcclusionUpdateInterval=true
        OcclusionUpdateInterval=0.2
    object end
    // Reference: AkComponent'Default__KFPawn_ZedPatriarch.CloakedAkComponent0'
    Components(12)=CloakedAkComponent0
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=55
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__KFPawn_ZedPatriarch.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    RotationRate=(Pitch=50000,Yaw=50000,Roll=50000)
}