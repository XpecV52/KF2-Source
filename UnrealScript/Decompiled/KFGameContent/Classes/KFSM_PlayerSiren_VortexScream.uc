/*******************************************************************************
 * KFSM_PlayerSiren_VortexScream generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFSM_PlayerSiren_VortexScream extends KFSM_GrappleCombined;

var const AkEvent VortexLoopAkEvent;
var const AkEvent VortexLoopEndAkEvent;
var const AkEvent VortexGrabAkEvent;
var const AkEvent VortexGrabEndAkEvent;
var const Vector2D ViewPitchConstraints;
var const float VortexCheckTime;
var const float MaxRangeSQ;
var const float MinGrabTargetFOV;
var protected float FollowerAttachTime;
var const ParticleSystem VortexEffect;
var export editinline transient ParticleSystemComponent VortexPSC;
var const float VortexDuration;
var const float MinVortexDuration;
var protected bool bVortexCanBeInterrupted;
var protected float InterpViewPitch;
var const float ViewRotInterpSpeed;
var protected float InterpolatedRotation;
var const float DamageOverDuration;
var protected int FollowerDamagePerSec;
var const class<KFDamageType> VortexDamageType;

protected function bool InternalCanDoSpecialMove()
{
    if(KFPOwner.bIsSprinting)
    {
        KFPOwner.SetSprinting(false);
    }
    if(KFPOwner.Physics != 1)
    {
        return false;
    }
    return super.InternalCanDoSpecialMove();
}

function SpecialMoveStarted(bool bForced, name PrevMove)
{
    local KFPawn_Monster MonsterOwner;

    super.SpecialMoveStarted(bForced, PrevMove);
    MonsterOwner = KFPawn_Monster(KFPOwner);
    bAlignFollowerLookSameDirAsMe = default.bAlignFollowerLookSameDirAsMe;
    bAlignFollowerRotation = default.bAlignFollowerRotation;
    bAlignPawns = false;
    Follower = none;
    InterpViewPitch = 0;
    FollowerAttachTime = 0;
    if(MonsterOwner.Role == ROLE_Authority)
    {
        MonsterOwner.SetTimer(VortexCheckTime, true, 'Timer_CheckVortex', self);
        FollowerDamagePerSec = MonsterOwner.GetRallyBoostDamage(int(DamageOverDuration / VortexDuration));
    }
    bVortexCanBeInterrupted = false;
    bPendingStopFire = false;
    if(MonsterOwner.IsLocallyControlled())
    {
        MonsterOwner.SetTimer(MinVortexDuration, false, 'Timer_VortexInterrupt', self);
    }
    MonsterOwner.BumpFrequency = 0;
    MonsterOwner.ViewPitchMin = ViewPitchConstraints.X;
    MonsterOwner.ViewPitchMax = ViewPitchConstraints.Y;
    if(MonsterOwner.IK_Look_Head == none)
    {
        MonsterOwner.IK_Look_Head = SkelControlLookAt(MonsterOwner.Mesh.FindSkelControl('HeadLook'));
    }
    MonsterOwner.bCanHeadTrack = true;
    MonsterOwner.bIsHeadTrackingActive = true;
    MonsterOwner.MyLookAtInfo.LookAtPct = 1;
    MonsterOwner.MyLookAtInfo.BlendOut = 0.33;
    MonsterOwner.MyLookAtInfo.BlendIn = 0.2;
    if(MonsterOwner.WorldInfo.NetMode != NM_DedicatedServer)
    {
        VortexPSC = MonsterOwner.WorldInfo.MyEmitterPool.SpawnEmitterMeshAttachment(VortexEffect, MonsterOwner.Mesh, 'VortexSocket', true);
        VortexPSC.SetAbsolute(false, true);
        VortexPSC.SetRotation(MonsterOwner.Rotation);
        MonsterOwner.PostAkEvent(VortexLoopAkEvent, true, true, true);
    }
}

function PlayGrabAnim()
{
    PlaySpecialMoveAnim(GrabStartAnimName, 0,,,, true);
}

function Tick(float DeltaTime)
{
    local Vector EffectLoc;
    local Rotator ViewRot, Projection, DesiredRotation;

    if(KFPOwner != none)
    {
        if(Follower == none)
        {
            if(KFPOwner.WorldInfo.NetMode != NM_DedicatedServer)
            {
                if((PCOwner != none) && PCOwner.PlayerCamera != none)
                {
                    ViewRot = PCOwner.PlayerCamera.CameraCache.POV.Rotation;
                    KFPOwner.MyLookAtInfo.ForcedLookAtLocation = PCOwner.PlayerCamera.CameraCache.POV.Location + (vector(ViewRot) * 5000);                    
                }
                else
                {
                    if(InterpViewPitch == 0)
                    {
                        InterpViewPitch = GetUncompressedViewPitch();                        
                    }
                    else
                    {
                        InterpViewPitch = FInterpTo(InterpViewPitch, GetUncompressedViewPitch(), DeltaTime, 15);
                    }
                    ViewRot = KFPOwner.GetViewRotation();
                    ViewRot.Pitch = int(InterpViewPitch);
                    KFPOwner.MyLookAtInfo.ForcedLookAtLocation = KFPOwner.GetPawnViewLocation() + (vector(ViewRot) * 5000);
                }
                VortexPSC.SetRotation(rotator(KFPOwner.MyLookAtInfo.ForcedLookAtLocation - KFPOwner.Location));
            }            
        }
        else
        {
            KFPOwner.Mesh.GetSocketWorldLocationAndRotation('VortexSocket', EffectLoc);
            Projection = rotator(Follower.Location - EffectLoc);
            if(VortexPSC != none)
            {
                VortexPSC.SetRotation(RInterpTo(VortexPSC.GetRotation(), Projection, DeltaTime, ViewRotInterpSpeed));
            }
            DesiredRotation = KFPOwner.Rotation;
            DesiredRotation.Yaw = int(FInterpTo(float(KFPOwner.Rotation.Yaw), float(Projection.Yaw), DeltaTime, ViewRotInterpSpeed));
            ForcePawnRotation(KFPOwner, DesiredRotation, false);
            if(KFPOwner.WorldInfo.NetMode != NM_DedicatedServer)
            {
                KFPOwner.MyLookAtInfo.ForcedLookAtLocation = Follower.Location;
            }
        }
    }
}

function float GetUncompressedViewPitch()
{
    return float(NormalizeRotAxis(KFPOwner.RemoteViewPitch << 8));
}

function ProcessViewRotation(float DeltaTime, out Rotator out_ViewRotation, out Rotator out_DeltaRot)
{
    if(Follower != none)
    {
        out_ViewRotation = RInterpTo(out_ViewRotation, KFPOwner.Rotation, DeltaTime, ViewRotInterpSpeed);
        out_DeltaRot = rot(0, 0, 0);
    }
}

function Timer_CheckVortex()
{
    local KFPawn KFP, BestTarget;
    local Vector CameraNormal, Projection, TraceStart, GrabLocation;
    local float FOV, DistSq, BestDistSq;

    if((PCOwner == none) || PCOwner.PlayerCamera == none)
    {
        return;
    }
    CameraNormal = vector(PCOwner.PlayerCamera.CameraCache.POV.Rotation);
    TraceStart = KFPOwner.Location + (KFPOwner.BaseEyeHeight * vect(0, 0, 1));
    foreach KFPOwner.WorldInfo.AllPawns(Class'KFPawn', KFP)
    {
        if((KFP.GetTeamNum() != KFPOwner.GetTeamNum()) && CanInteractWithPawn(KFP))
        {
            Projection = KFP.Location - TraceStart;
            DistSq = VSizeSq(Projection);
            if(DistSq <= MaxRangeSQ)
            {
                FOV = CameraNormal Dot Normal(Projection);
                if(FOV > MinGrabTargetFOV)
                {
                    GrabLocation = KFP.Location + (KFP.BaseEyeHeight * vect(0, 0, 1));
                    if((IsPawnPathClear(KFPOwner, KFP, GrabLocation, TraceStart, vect(2, 2, 2),, true)) && IsPawnPathClear(KFPOwner, KFP, GrabLocation, TraceStart,,, true))
                    {
                        if((BestTarget == none) || DistSq < BestDistSq)
                        {
                            BestDistSq = DistSq;
                            BestTarget = KFP;
                        }
                    }
                }
            }
        }        
    }    
    if(BestTarget != none)
    {
        FollowerAttachTime = KFPOwner.WorldInfo.TimeSeconds;
        KFPOwner.DoSpecialMove(KFPOwner.SpecialMove, true, BestTarget);
        Timer_DamageFollower();
        KFPOwner.SetTimer(1, true, 'Timer_DamageFollower', self);
        KFPOwner.ClearTimer('Timer_CheckVortex', self);
    }
}

function InteractionPawnUpdated()
{
    if(KFPOwner.InteractionPawn != none)
    {
        bAlignPawns = true;
        CheckReadyToStartInteraction();        
    }
    else
    {
        KFPOwner.EndSpecialMove();
    }
}

function StartInteraction()
{
    if(Follower != none)
    {
        bAlignPawns = true;
        Follower.AirSpeed = 10000;
        Follower.SetPhysics(4);
        SetLockPawnRotation(true);
        if(KFPOwner.WorldInfo.NetMode != NM_DedicatedServer)
        {
            KFPOwner.PostAkEvent(VortexGrabAkEvent, true, true, true);
        }
        ++ KFPlayerReplicationInfoVersus(KFPOwner.PlayerReplicationInfo).ZedGrabs;
    }
    super.StartInteraction();
}

function Timer_DamageFollower()
{
    local Vector GrabLocation, GrabDirection;

    if((KFPOwner.WorldInfo.TimeSeconds - FollowerAttachTime) >= VortexDuration)
    {
        KFPOwner.EndSpecialMove();
        return;
    }
    if((Follower != none) && !Follower.bPlayedDeath)
    {
        GrabDirection = Normal(KFPOwner.Location - Follower.Location);
        GrabLocation = Follower.Location + (GrabDirection * Follower.CylinderComponent.CollisionRadius);
        Follower.TakeDamage(FollowerDamagePerSec, KFPOwner.Controller, GrabLocation, GrabDirection, VortexDamageType,, KFPOwner);
        if(Follower.bPlayedDeath || Follower.Health <= 0)
        {
            KFPOwner.EndSpecialMove();
            return;
        }
        KFPawn_Monster(KFPOwner).MeleeAttackHelper.PlayMeleeHitEffects(Follower, GrabLocation, GrabDirection, false);
    }
}

function SpecialMoveFlagsUpdated()
{
    if(KFPOwner.SpecialMoveFlags == 254)
    {
        KFPOwner.EndSpecialMove();        
    }
    else
    {
        super.SpecialMoveFlagsUpdated();
    }
}

function AnimEndNotify(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    super(KFSpecialMove).AnimEndNotify(SeqNode, PlayedTime, ExcessTime);
}

function OnFollowerLeavingSpecialMove()
{
    super.OnFollowerLeavingSpecialMove();
    ResetFollowerPhysics();
}

function ResetFollowerPhysics()
{
    if(Follower != none)
    {
        Follower.AirSpeed = Follower.default.AirSpeed;
        if(Follower.Physics == 4)
        {
            Follower.SetPhysics(2);
        }
    }
}

function SpecialMoveEnded(name PrevMove, name NextMove)
{
    if(VortexPSC != none)
    {
        VortexPSC.DeactivateSystem();
        VortexPSC = none;
    }
    ResetFollowerPhysics();
    SetLockPawnRotation(false);
    if(KFPOwner != none)
    {
        if(KFPOwner.WorldInfo.NetMode != NM_DedicatedServer)
        {
            if(Follower != none)
            {
                KFPOwner.PostAkEvent(VortexGrabEndAkEvent, true, true, true);                
            }
            else
            {
                KFPOwner.PostAkEvent(VortexLoopEndAkEvent, true, true, true);
            }
        }
        KFPOwner.bIsHeadTrackingActive = false;
        KFPOwner.MyLookAtInfo.ForcedLookAtLocation = vect(0, 0, 0);
        KFPOwner.ViewPitchMin = KFPOwner.default.ViewPitchMin;
        KFPOwner.ViewPitchMax = KFPOwner.default.ViewPitchMax;
        if(KFPOwner.Role == ROLE_Authority)
        {
            KFPawn_Monster(PawnOwner).BumpFrequency = KFPawn_Monster(PawnOwner).default.BumpFrequency;
            KFPOwner.ClearTimer('Timer_CheckVortex', self);
            KFPOwner.ClearTimer('Timer_DamageFollower', self);
            KFPOwner.ClearTimer('Timer_VortexInterrupt', self);
        }
    }
    super.SpecialMoveEnded(PrevMove, NextMove);
}

function Timer_VortexInterrupt()
{
    bVortexCanBeInterrupted = true;
    if(bPendingStopFire)
    {
        SpecialMoveButtonReleased();
    }
}

function SpecialMoveButtonRetriggered()
{
    bPendingStopFire = false;
}

function SpecialMoveButtonReleased()
{
    bPendingStopFire = true;
    if(!bVortexCanBeInterrupted)
    {
        return;
    }
    KFPOwner.DoSpecialMove(KFPOwner.SpecialMove, true,, 254);
    if((KFPOwner.Role < ROLE_Authority) && KFPOwner.IsLocallyControlled())
    {
        KFPOwner.ServerDoSpecialMove(KFPOwner.SpecialMove, true,, 254);
    }
}

defaultproperties
{
    VortexLoopAkEvent=AkEvent'WW_ZED_Siren.Play_Siren_Pull_Start'
    VortexLoopEndAkEvent=AkEvent'WW_ZED_Siren.Stop_Siren_Pull_Start'
    VortexGrabAkEvent=AkEvent'WW_ZED_Siren.Play_Siren_Pull_Hit'
    VortexGrabEndAkEvent=AkEvent'WW_ZED_Siren.Stop_Siren_Pull_Hit'
    ViewPitchConstraints=(X=-8192,Y=8192)
    VortexCheckTime=0.14
    MaxRangeSQ=1562500
    MinGrabTargetFOV=0.96
    VortexEffect=ParticleSystem'VFX_TEX_THREE.FX_Siren_Pull_Long_01'
    VortexDuration=5
    MinVortexDuration=1
    ViewRotInterpSpeed=0.5
    DamageOverDuration=24
    VortexDamageType=Class'KFDT_Sonic_VortexScream'
    GrabStartAnimName=Player_Pull
    FollowerSpecialMove=ESpecialMove.SM_SirenVortexVictim
    bAlignLeaderLocation=false
    bAlignFollowerZ=true
    bStopAlignFollowerRotationAtGoal=false
    bRetryCollisionCheck=false
    AlignDistance=360
    AlignDistanceThreshold=4
    AlignSpeedModifier=0.04
    Handle=KFSM_PlayerSiren_VortexScream
}