/*******************************************************************************
 * KFProj_Thrown_C4 generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFProj_Thrown_C4 extends KFProjectile
    hidecategories(Navigation);

enum EImpactResult
{
    EIR_None,
    EIR_Stick,
    EIR_Bounce,
    EIR_MAX
};

var repnotify Actor StuckToActor;
var int StuckToBoneIdx;
var transient Vector StuckToLocation;
var transient Rotator StuckToRotation;
var Actor PrevStuckToActor;
var KFImpactEffectInfo ImpactEffectInfo;
/** How much to offset the emitter mesh when the grenade has landed so that it doesn't penetrate the ground */
var() Vector LandedTranslationOffset;
/** sound to play on "impact" */
var() AkEvent StickAkEvent;
/** "beep" sound to play (on an interval) when instigator is within blast radius */
var() AkEvent ProximityAlertAkEvent;
/** Time between proximity beeps */
var() float ProximityAlertInterval;
/** Time between proximity beeps when the instigator is within "fatal" radius */
var() float ProximityAlertIntervalClose;
var transient float ProximityAlertTimer;
var export editinline StaticMeshComponent ChargeMesh;
var MaterialInstanceConstant ChargeMIC;
var export editinline PointLightComponent BlinkLightComp;
var LinearColor BlinkColorOn;
var LinearColor BlinkColorOff;
var float BlinkTime;
var ParticleSystem BlinkFX;
var export editinline ParticleSystemComponent BlinkPSC;

replication
{
     if(bNetInitial || !bNetOwner)
        StuckToActor, StuckToBoneIdx, 
        StuckToLocation, StuckToRotation;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'StuckToActor')
    {
        if(StuckToActor == none)
        {
            RestartMovement();            
        }
        else
        {
            if(StuckToActor != PrevStuckToActor)
            {
                ReplicatedStick(StuckToActor, StuckToBoneIdx);
            }
        }        
    }
    else
    {
        super.ReplicatedEvent(VarName);
    }
}

simulated function PostBeginPlay()
{
    if(WorldInfo.NetMode != NM_Client)
    {
        if(InstigatorController != none)
        {
            Class'KFGameplayPoolManager'.static.GetPoolManager().AddProjectileToPool(self, 0);            
        }
        else
        {
            Destroy();
            return;
        }
    }
    super.PostBeginPlay();
    ProximityAlertTimer = ProximityAlertInterval;
    AdjustCanDisintigrate();
    ChargeMIC = ChargeMesh.CreateAndSetMaterialInstanceConstant(0);
}

simulated event Tick(float DeltaTime)
{
    local int I;
    local Pawn P;
    local KFFracturedMeshActor FracMesh;
    local KFDoorActor door;
    local KFDestructibleActor Destructible;
    local Actor StuckTo;

    super(Actor).Tick(DeltaTime);
    StuckTo = StuckToActor;
    if(StuckTo != none)
    {
        UpdateAlert(DeltaTime);
        if(StuckTo.bTearOff)
        {
            RestartMovement();
            return;
        }
        P = Pawn(StuckTo);
        if(P != none)
        {
            if(P.Mesh.IsBoneHidden(StuckToBoneIdx))
            {
                RestartMovement();
            }
            return;
        }
        if(StuckTo.bDeleteMe || StuckTo.bPendingDelete)
        {
            RestartMovement();
            return;
        }
        FracMesh = KFFracturedMeshActor(StuckTo);
        if((FracMesh != none) && FracMesh.bHasLostChunk)
        {
            RestartMovement();
            return;
        }
        door = KFDoorActor(StuckTo);
        if((door != none) && !door.bDoorMoveCompleted || door.bIsDestroyed)
        {
            RestartMovement();
            return;
        }
        Destructible = KFDestructibleActor(StuckTo);
        if(Destructible != none)
        {
            I = 0;
            J0x251:

            if(I < Destructible.SubObjects.Length)
            {
                if((Destructible.SubObjects[I].Mesh == LastTouchComponent) && Destructible.SubObjects[I].Health <= 0)
                {
                    RestartMovement();
                    return;
                }
                ++ I;
                goto J0x251;
            }
        }
    }
}

simulated function UpdateAlert(float DeltaTime)
{
    local Vector ToInstigator, BBoxCenter;
    local float DistToInstigator, DamageScale;
    local Actor TraceActor;
    local Box BBox;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(bHasExploded || bHasDisintegrated)
    {
        return;
    }
    if(ProximityAlertTimer <= float(0))
    {
        return;
    }
    ProximityAlertTimer -= DeltaTime;
    if(ProximityAlertTimer > float(0))
    {
        return;
    }
    ProximityAlertTimer = ProximityAlertInterval;
    if((Instigator != none) && Instigator.IsLocallyControlled())
    {
        ToInstigator = Instigator.Location - Location;
        DistToInstigator = VSize(ToInstigator);
        if(DistToInstigator <= ExplosionTemplate.DamageRadius)
        {
            Instigator.GetComponentsBoundingBox(BBox);
            BBoxCenter = (BBox.Min + BBox.Max) * 0.5;
            TraceActor = Class'GameExplosionActor'.static.StaticTraceExplosive(BBoxCenter, Location + vect(0, 0, 20), self);
            if((TraceActor == none) || TraceActor == Instigator)
            {
                DamageScale = FClamp(1 - (DistToInstigator / ExplosionTemplate.DamageRadius), 0, 1);
                DamageScale = DamageScale ** ExplosionTemplate.DamageFalloffExponent;
                if((ExplosionTemplate.Damage * DamageScale) > float(Instigator.Health))
                {
                    ProximityAlertTimer = ProximityAlertIntervalClose;
                }
                PlaySoundBase(ProximityAlertAkEvent, true);
            }
        }
    }
    BlinkOn();
}

simulated function BlinkOn()
{
    if(BlinkPSC == none)
    {
        BlinkPSC = WorldInfo.MyEmitterPool.SpawnEmitter(BlinkFX, Location + ((vect(0, 0, 4) + vect(8, 0, 0)) >> Rotation),, self,,, true);
    }
    BlinkPSC.SetFloatParameter('Glow', 1);
    ChargeMIC.SetVectorParameterValue('Vector_GlowColor', BlinkColorOn);
    BlinkLightComp.SetEnabled(true);
    SetTimer(BlinkTime, false, 'BlinkOff');
}

simulated function BlinkOff()
{
    if(BlinkPSC != none)
    {
        BlinkPSC.SetFloatParameter('Glow', 0);
    }
    ChargeMIC.SetVectorParameterValue('Vector_GlowColor', BlinkColorOff);
    BlinkLightComp.SetEnabled(false);
}

simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
{
    TryStick(HitNormal, HitLocation, Other);
}

simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    TryStick(HitNormal,, Wall);
}

simulated function TryStick(Vector HitNormal, optional Vector HitLocation, optional Actor HitActor)
{
    local TraceHitInfo HitInfo;

    if(((Instigator == none) || !Instigator.IsLocallyControlled()) || (Physics == 0) && StuckToActor != none)
    {
        return;
    }
    GetImpactInfo(Velocity, HitLocation, HitNormal, HitInfo);
    switch(GetImpactResult(HitActor, HitInfo.HitComponent))
    {
        case 1:
            Stick(HitActor, HitLocation, HitNormal, HitInfo);
            break;
        default:
            break;
    }
}

simulated function KFProj_Thrown_C4.EImpactResult GetImpactResult(Actor HitActor, PrimitiveComponent HitComp)
{
    local KFPawn_Human KFP;
    local KFDestructibleActor D;
    local editinline StaticMeshComponent StaticMeshComp;

    if(HitActor == none)
    {
        return 1;
    }
    if((HitActor.RemoteRole == ROLE_None) && !HitActor.bWorldGeometry)
    {
        return 0;
    }
    if(((HitActor.bTearOff || HitActor.bDeleteMe) || HitActor.bPendingDelete) || HitActor == PrevStuckToActor)
    {
        return 0;
    }
    StaticMeshComp = StaticMeshComponent(HitComp);
    if(StaticMeshComp != none)
    {
        return ((StaticMeshComp.CanBecomeDynamic()) ? 0 : 1);
    }
    KFP = KFPawn_Human(HitActor);
    if(KFP != none)
    {
        return 0;
    }
    D = KFDestructibleActor(HitActor);
    if(D != none)
    {
        return ((D.ReplicationMode == 2) ? 0 : 1);
    }
    return 1;
}

simulated function Stick(Actor HitActor, Vector HitLocation, Vector HitNormal, const out TraceHitInfo HitInfo)
{
    local int BoneIdx;
    local Rotator StickRot;

    if(ProjEffects != none)
    {
        ProjEffects.SetTranslation(LandedTranslationOffset);
    }
    bReplicateMovement = false;
    bOnlyDirtyReplication = true;
    NetUpdateFrequency = 0.25;
    bForceNetUpdate = true;
    if(!IsZero(HitLocation))
    {
        SetLocation(HitLocation);
    }
    StickRot = CalculateStickOrientation(HitNormal);
    SetRotation(StickRot);
    BoneIdx = -1;
    if(HitInfo.BoneName != 'None')
    {
        BoneIdx = GetBoneIndexFromActor(HitActor, HitInfo.BoneName);
    }
    StickToActor(HitActor, HitInfo.HitComponent, BoneIdx, true);
    if(Role < ROLE_Authority)
    {
        ServerStick(HitActor, BoneIdx, StuckToLocation, StuckToRotation);
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        PlaySoundBase(StickAkEvent);
    }
}

simulated function GetImpactInfo(Vector in_Velocity, out Vector out_HitLocation, out Vector out_HitNormal, out TraceHitInfo out_HitInfo)
{
    local Vector VelNorm, VelScaled;

    VelNorm = Normal(in_Velocity);
    VelScaled = VelNorm * float(30);
    Trace(out_HitLocation, out_HitNormal, Location + VelScaled, Location - VelScaled,,, out_HitInfo, 1);
}

simulated function StickToActor(Actor StickTo, PrimitiveComponent HitComp, int BoneIdx, optional bool bCalculateRelativeLocRot)
{
    local editinline SkeletalMeshComponent SkelMeshComp;
    local name BoneName;

    StopMovement();
    PrevStuckToActor = StuckToActor;
    StuckToActor = StickTo;
    StuckToBoneIdx = BoneIdx;
    if(BoneIdx != -1)
    {
        SkelMeshComp = SkeletalMeshComponent(HitComp);
        BoneName = SkelMeshComp.GetBoneName(BoneIdx);
        if(bCalculateRelativeLocRot)
        {
            SkelMeshComp.TransformToBoneSpace(BoneName, Location, Rotation, StuckToLocation, StuckToRotation);
        }
        SetBase(StickTo,, SkelMeshComp, BoneName);
        SetRelativeLocation(StuckToLocation);
        SetRelativeRotation(StuckToRotation);        
    }
    else
    {
        if(bCalculateRelativeLocRot)
        {
            StuckToLocation = Location;
            StuckToRotation = Rotation;            
        }
        else
        {
            SetLocation(StuckToLocation);
            SetRotation(StuckToRotation);
        }
        SetBase(StickTo);
    }
}

simulated function SkeletalMeshComponent GetActorSkeletalMesh(Actor StickActor)
{
    local Pawn P;
    local SkeletalMeshActor SM;

    P = Pawn(StickActor);
    if(P != none)
    {
        return P.Mesh;
    }
    SM = SkeletalMeshActor(StickActor);
    if(SM != none)
    {
        return SM.SkeletalMeshComponent;
    }
    return none;
}

reliable server function ServerStick(Actor StickTo, int BoneIdx, Vector StickLoc, Rotator StickRot)
{
    StuckToLocation = StickLoc;
    StuckToRotation = StickRot;
    bForceNetUpdate = true;
    ReplicatedStick(StickTo, BoneIdx);
}

simulated function ReplicatedStick(Actor StickTo, int BoneIdx)
{
    StickToActor(StickTo, GetActorSkeletalMesh(StickTo), BoneIdx);
}

simulated function int GetBoneIndexFromActor(Actor HitActor, name BoneName)
{
    local Pawn P;
    local SkeletalMeshActor SM;

    P = Pawn(HitActor);
    if(P != none)
    {
        return P.Mesh.MatchRefBone(BoneName);
    }
    SM = SkeletalMeshActor(HitActor);
    if(SM != none)
    {
        return SM.SkeletalMeshComponent.MatchRefBone(BoneName);
    }
    return -1;
}

simulated function GetBoneLocationFromActor(Actor HitActor, int BoneIdx, out Vector BoneLoc)
{
    local name BoneName;
    local Pawn P;
    local SkeletalMeshActor SM;

    P = Pawn(HitActor);
    if(P != none)
    {
        BoneName = P.Mesh.GetBoneName(BoneIdx);
        BoneLoc = P.Mesh.GetBoneLocation(BoneName);
        return;
    }
    SM = SkeletalMeshActor(HitActor);
    if(SM != none)
    {
        BoneName = SM.SkeletalMeshComponent.GetBoneName(BoneIdx);
        BoneLoc = SM.SkeletalMeshComponent.GetBoneLocation(BoneName);
        return;
    }
}

simulated function StopMovement()
{
    SetPhysics(0);
}

simulated function RestartMovement()
{
    PrevStuckToActor = StuckToActor;
    StuckToActor = none;
    StuckToBoneIdx = -1;
    StuckToLocation = vect(0, 0, 0);
    StuckToRotation = rot(0, 0, 0);
    SetBase(none);
    SetPhysics(default.Physics);
    bReplicateMovement = true;
    NetUpdateFrequency = default.NetUpdateFrequency;
    bOnlyDirtyReplication = false;
    bForceNetUpdate = true;
}

function Detonate()
{
    local KFWeap_Thrown_C4 C4WeaponOwner;
    local Vector ExplosionNormal;

    if(Role == ROLE_Authority)
    {
        C4WeaponOwner = KFWeap_Thrown_C4(Owner);
        if(C4WeaponOwner != none)
        {
            C4WeaponOwner.RemoveDeployedCharge(,, self);
        }
    }
    ExplosionNormal = vect(0, 0, 1) >> Rotation;
    Explode(Location, ExplosionNormal);
}

simulated function Explode(Vector HitLocation, Vector HitNormal)
{
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        BlinkOff();
    }
    super.Explode(HitLocation, HitNormal);
}

simulated function Disintegrate(Rotator InDisintegrateEffectRotation)
{
    local KFWeap_Thrown_C4 C4WeaponOwner;

    if(Role == ROLE_Authority)
    {
        C4WeaponOwner = KFWeap_Thrown_C4(Owner);
        if(C4WeaponOwner != none)
        {
            C4WeaponOwner.RemoveDeployedCharge(,, self);
        }
    }
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        BlinkOff();
    }
    super.Disintegrate(InDisintegrateEffectRotation);
}

protected simulated function PrepareExplosionTemplate()
{
    Class'KFPerk_Demolitionist'.static.PrepareExplosive(Instigator, self);
    super.PrepareExplosionTemplate();
}

protected simulated function SetExplosionActorClass()
{
    local KFPlayerReplicationInfo InstigatorPRI;

    if((WorldInfo.TimeDilation < 1) && Instigator != none)
    {
        InstigatorPRI = KFPlayerReplicationInfo(Instigator.PlayerReplicationInfo);
        if(InstigatorPRI != none)
        {
            if(InstigatorPRI.bNukeActive && Class'KFPerk_Demolitionist'.static.ProjectileShouldNuke(self))
            {
                ExplosionActorClass = Class'KFPerk_Demolitionist'.static.GetNukeExplosionActorClass();
            }
        }
    }
    super.SetExplosionActorClass();
}

function Timer_Explode()
{
    Detonate();
}

simulated event Destroyed()
{
    if(WorldInfo.NetMode != NM_Client)
    {
        if(InstigatorController != none)
        {
            Class'KFGameplayPoolManager'.static.GetPoolManager().RemoveProjectileFromPool(self, 0);
        }
    }
    super.Destroyed();
}

simulated function OnInstigatorControllerLeft()
{
    if(WorldInfo.NetMode != NM_Client)
    {
        SetTimer((1 + float(Rand(5))) + FRand(), false, 'Timer_Explode');
    }
}

defaultproperties
{
    StuckToBoneIdx=-1
    ImpactEffectInfo=KFImpactEffectInfo'WEP_C4_ARCH.C4_Projectile_Impacts'
    StickAkEvent=AkEvent'WW_WEP_EXP_C4.Play_WEP_EXP_C4_Handling_Place'
    ProximityAlertAkEvent=AkEvent'WW_WEP_EXP_C4.Play_WEP_EXP_C4_Prox_Beep'
    ProximityAlertInterval=1
    ProximityAlertIntervalClose=0.5
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        StaticMesh=StaticMesh'WEP_3P_C4_MESH.Wep_C4_Projectile'
        ReplacementPrimitive=none
        bCastDynamicShadow=false
        CollideActors=false
        LightingChannels=(Dynamic=true)
    object end
    // Reference: StaticMeshComponent'Default__KFProj_Thrown_C4.StaticMeshComponent0'
    ChargeMesh=StaticMeshComponent0
    begin object name=BlinkPointLight class=PointLightComponent
        Radius=300
        FalloffExponent=10
        Translation=(X=8,Y=0,Z=4)
        Brightness=4
        LightColor=(B=63,G=63,R=255,A=255)
        bEnabled=false
        CastShadows=false
        CastStaticShadows=false
        CastDynamicShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFProj_Thrown_C4.BlinkPointLight'
    BlinkLightComp=BlinkPointLight
    BlinkColorOn=(R=1,G=0,B=0,A=1)
    BlinkColorOff=(R=0,G=0,B=0,A=1)
    BlinkTime=0.2
    BlinkFX=ParticleSystem'WEP_C4_EMIT.FX_C4_Glow'
    bAlwaysReplicateExplosion=true
    bCanDisintegrate=true
    AlwaysRelevantDistanceSquared=6250000
    GlassShatterType=FracturedMeshGlassShatterType.FMGS_ShatterDamaged
    TossZ=100
    ExplosionActorClass=Class'KFExplosionActorC4'
    begin object name=ExploTemplate0 class=KFGameExplosion
        ExplosionEffects=KFImpactEffectInfo'WEP_C4_ARCH.C4_Explosion'
        Damage=820
        DamageRadius=400
        DamageFalloffExponent=2
        MyDamageType=Class'KFDT_Explosive_C4'
        KnockDownStrength=0
        ExplosionSound=AkEvent'WW_WEP_EXP_C4.Play_WEP_EXP_C4_Explosion'
        ExploLight=PointLightComponent'Default__KFProj_Thrown_C4.ExplosionPointLight'
        ExploLightFadeOutTime=0.2
        CamShake=KFCameraShake'FX_CameraShake_Arch.Grenades.Default_Grenade'
        CamShakeInnerRadius=200
        CamShakeFalloff=1.5
    object end
    // Reference: KFGameExplosion'Default__KFProj_Thrown_C4.ExploTemplate0'
    ExplosionTemplate=ExploTemplate0
    ProjDisintegrateTemplate=ParticleSystem'ZED_Siren_EMIT.FX_Siren_grenade_disable_01'
    AltExploEffects=KFImpactEffectInfo'WEP_C4_ARCH.C4_Explosion_Concussive_Force'
    Speed=1200
    MaxSpeed=1200
    bBlockedByInstigator=false
    bIgnoreFoliageTouch=true
    DamageRadius=0
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
        CollideActors=true
        BlockNonZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFProj_Thrown_C4.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
        CollideActors=true
        BlockNonZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFProj_Thrown_C4.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=BlinkPointLight class=PointLightComponent
        Radius=300
        FalloffExponent=10
        Translation=(X=8,Y=0,Z=4)
        Brightness=4
        LightColor=(B=63,G=63,R=255,A=255)
        bEnabled=false
        CastShadows=false
        CastStaticShadows=false
        CastDynamicShadows=false
        LightingChannels=(Outdoor=true)
    object end
    // Reference: PointLightComponent'Default__KFProj_Thrown_C4.BlinkPointLight'
    Components(1)=BlinkPointLight
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        StaticMesh=StaticMesh'WEP_3P_C4_MESH.Wep_C4_Projectile'
        ReplacementPrimitive=none
        bCastDynamicShadow=false
        CollideActors=false
        LightingChannels=(Dynamic=true)
    object end
    // Reference: StaticMeshComponent'Default__KFProj_Thrown_C4.StaticMeshComponent0'
    Components(2)=StaticMeshComponent0
    Physics=EPhysics.PHYS_Falling
    bNetTemporary=false
    bCollideComplex=true
    bBounce=true
    LifeSpan=0
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
        CollideActors=true
        BlockNonZeroExtent=false
    object end
    // Reference: CylinderComponent'Default__KFProj_Thrown_C4.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}