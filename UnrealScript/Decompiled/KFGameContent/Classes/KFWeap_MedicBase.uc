/*******************************************************************************
 * KFWeap_MedicBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KFWeap_MedicBase extends KFWeapon
    abstract
    config(Game)
    hidecategories(Navigation,Advanced,Collision,Mobile,Movement,Object,Physics,Attachment,Debug);

const ShootDartAnim = 'Shoot_Dart';
const ShootDartIronAnim = 'Shoot_Iron_Dart';

var class<DamageType> HealingDartDamageType;
/** How much to heal for when using this weapon */
var(Healing) int HealAmount;
/** How many points of heal ammo to recharge per second */
var(Healing) float HealFullRechargeSeconds;
var float HealingIncrement;
var float HealRechargePerSecond;
var AkEvent HealImpactSoundPlayEvent;
var AkEvent HurtImpactSoundPlayEvent;
/** Sound to play when the weapon is fired */
var(Sounds) WeaponFireSndInfo DartFireSnd;
/**  
 *How long after we shoot a healing dart before a zed can grab us.
 *  Prevents us from missing healing shots from being grabbed
 */
var(Weapon) float HealDartShotWeakZedGrabCooldown;
/** The frequency with which we will check for a lock */
var(Locking) float LockCheckTime;
/** How far out should we be considering actors for a lock */
var(Locking) float LockRange;
/** How long does the player need to target an actor to lock on to it */
var(Locking) float LockAcquireTime;
/** Once locked, how long can the player go without painting the object before they lose the lock */
var(Locking) float LockTolerance;
var bool bLockedOnTarget;
var bool bTargetLockingActive;
var repnotify Actor LockedTarget;
var repnotify Actor PendingLockedTarget;
/** angle for locking for lock targets */
var(Locking) float LockAim;
var AkBaseSoundObject LockAcquiredSoundFirstPerson;
var AkBaseSoundObject LockTargetingStopEvent;
var AkBaseSoundObject LockTargetingStopEventFirstPerson;
var AkBaseSoundObject LockLostSoundFirstPerson;
var AkBaseSoundObject LockTargetingSoundFirstPerson;
var float PendingLockAcquireTimeLeft;
var float PendingLockTimeout;
var float LockedOnTimeout;
var class<KFGFxWorld_MedicOptics> OpticsUIClass;
var KFGFxWorld_MedicOptics OpticsUI;
var byte StoredPrimaryAmmo;
var byte StoredSecondaryAmmo;

replication
{
     if(bNetDirty && Role == ROLE_Authority)
        LockedTarget, PendingLockedTarget, 
        bLockedOnTarget;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'LockedTarget')
    {
        if(OpticsUI != none)
        {
            if((LockedTarget == none) && PendingLockedTarget == none)
            {
                OpticsUI.ClearLockOn();                
            }
            else
            {
                if(LockedTarget != none)
                {
                    OpticsUI.LockedOn();
                }
            }
        }        
    }
    else
    {
        if(VarName == 'PendingLockedTarget')
        {
            if(OpticsUI != none)
            {
                if((PendingLockedTarget == none) && LockedTarget == none)
                {
                    OpticsUI.ClearLockOn();                    
                }
                else
                {
                    if(PendingLockedTarget != none)
                    {
                        OpticsUI.StartLockOn();
                    }
                }
            }            
        }
        else
        {
            super(Actor).ReplicatedEvent(VarName);
            if(VarName == 'SpareAmmoCount')
            {
                AmmoCount[1] = byte(SpareAmmoCount[1]);
            }
        }
    }
}

simulated event Tick(float DeltaTime)
{
    if(AmmoCount[1] < MagazineCapacity[1])
    {
        HealAmmoRegeneration(DeltaTime);
    }
    if((Instigator != none) && Instigator.Weapon == self)
    {
        UpdateOpticsUI();
    }
    super.Tick(DeltaTime);
}

simulated function AltFireMode()
{
    if(!Instigator.IsLocallyControlled())
    {
        return;
    }
    StartFire(1);
}

simulated function ConsumeAmmo(byte FireModeNum)
{
    if(FireModeNum != 1)
    {
        super.ConsumeAmmo(FireModeNum);
        return;
    }
    if(Role == ROLE_Authority)
    {
        if((MagazineCapacity[1] > 0) && AmmoCount[1] > 0)
        {
            AmmoCount[1] = byte(Max(AmmoCount[1] - AmmoCost[1], 0));
            SpareAmmoCount[1] = Max(SpareAmmoCount[1] - AmmoCost[1], 0);
        }
    }
}

simulated function ProcessInstantHitEx(byte FiringMode, ImpactInfo Impact, optional int NumHits, optional out float out_PenetrationVal, optional int ImpactNum)
{
    local KFPawn HealTarget;
    local KFPlayerController Healer;

    HealTarget = KFPawn(Impact.HitActor);
    Healer = KFPlayerController(Instigator.Controller);
    if(((FiringMode == 1) && HealTarget != none) && WorldInfo.GRI.OnSameTeam(Instigator, HealTarget))
    {
        if(Healer != none)
        {
            Healer.AddShotsHit(1);
        }
        HealTarget.HealDamage(HealAmount, Instigator.Controller, HealingDartDamageType);
        if(((HealImpactSoundPlayEvent != none) && HealTarget != none) && !bSuppressSounds)
        {
            HealTarget.PlaySoundBase(HealImpactSoundPlayEvent, false, false,, Impact.HitLocation);
        }        
    }
    else
    {
        if(((HurtImpactSoundPlayEvent != none) && HealTarget != none) && !bSuppressSounds)
        {
            HealTarget.PlaySoundBase(HurtImpactSoundPlayEvent, false, false,, Impact.HitLocation);
        }
        super.ProcessInstantHitEx(FiringMode, Impact, NumHits, out_PenetrationVal);
    }
}

simulated function KFProjectile SpawnProjectile(class<KFProjectile> KFProjClass, Vector RealStartLoc, Vector AimDir)
{
    local KFProjectile SpawnedProjectile;

    SpawnedProjectile = super.SpawnProjectile(KFProjClass, RealStartLoc, AimDir);
    if(bLockedOnTarget && KFProj_HealingDart(SpawnedProjectile) != none)
    {
        KFProj_HealingDart(SpawnedProjectile).SeekTarget = LockedTarget;
    }
    return SpawnedProjectile;
}

simulated function StartFire(byte FireModeNum)
{
    if((FireModeNum == 1) && !HasAmmo(FireModeNum, AmmoCost[1]))
    {
        return;
    }
    super.StartFire(FireModeNum);
}

function GivenTo(Pawn thisPawn, optional bool bDoNotActivate)
{
    super.GivenTo(thisPawn, bDoNotActivate);
    if((Role == ROLE_Authority) && !thisPawn.IsLocallyControlled())
    {
        StartHealRecharge();
    }
}

function StartHealRecharge()
{
    local KFPerk InstigatorPerk;
    local float UsedHealRechargeTime;

    if(Role == ROLE_Authority)
    {
        InstigatorPerk = GetPerk();
        UsedHealRechargeTime = HealFullRechargeSeconds;
        InstigatorPerk.ModifyHealerRechargeTime(UsedHealRechargeTime);
        HealRechargePerSecond = float(MagazineCapacity[1]) / UsedHealRechargeTime;
        HealingIncrement = 0;
    }
}

function HealAmmoRegeneration(float DeltaTime)
{
    if(Role == ROLE_Authority)
    {
        HealingIncrement += (HealRechargePerSecond * DeltaTime);
        if(SpareAmmoCount[1] > AmmoCount[1])
        {
            SpareAmmoCount[1] = AmmoCount[1];
        }
        if((HealingIncrement >= 1) && SpareAmmoCount[1] < MagazineCapacity[1])
        {
            ++ SpareAmmoCount[1];
            AmmoCount[1] = byte(SpareAmmoCount[1]);
            HealingIncrement -= 1;
        }
    }
}

simulated function bool HasAnyAmmo()
{
    if((HasSpareAmmo()) || HasAmmo(0))
    {
        return true;
    }
    return false;
}

function AdjustLockTarget(Actor NewLockTarget)
{
    if(LockedTarget == NewLockTarget)
    {
        return;
    }
    if(NewLockTarget == none)
    {
        if(bLockedOnTarget)
        {
            bLockedOnTarget = false;
            LockedTarget = none;
            if((OpticsUI != none) && PendingLockedTarget == none)
            {
                OpticsUI.ClearLockOn();
            }
            if(bUsingSights)
            {
                ClientPlayTargetingSound(LockLostSoundFirstPerson);
            }
        }        
    }
    else
    {
        bLockedOnTarget = true;
        LockedTarget = NewLockTarget;
        if(OpticsUI != none)
        {
            OpticsUI.LockedOn();
        }
        ClientPlayTargetingSound(LockAcquiredSoundFirstPerson);
    }
}

simulated function bool CanLockOnTo(Actor TA)
{
    local Pawn PawnTarget;

    PawnTarget = Pawn(TA);
    if(((((((TA == none) || !TA.bProjTarget) || TA.bDeleteMe) || PawnTarget == none) || TA == Instigator) || PawnTarget.Health <= 0) || PawnTarget.Health >= PawnTarget.HealthMax)
    {
        return false;
    }
    return WorldInfo.GRI.OnSameTeam(Instigator, TA);
}

function bool AllowTargetLockOn()
{
    return !Instigator.bNoWeaponFiring;
}

function CheckTargetLock()
{
    local Actor BestTarget, HitActor, TA;
    local Vector StartTrace, EndTrace, Aim, HitLocation, HitNormal;

    local Rotator AimRot;
    local float bestAim, bestDist;

    if(((Instigator == none) || Instigator.Controller == none) || self != Instigator.Weapon)
    {
        return;
    }
    if(!AllowTargetLockOn())
    {
        AdjustLockTarget(none);
        PendingLockedTarget = none;
        return;
    }
    if(LockedTarget != none)
    {
        if(LockedTarget.bDeleteMe)
        {
            AdjustLockTarget(none);
        }
    }
    BestTarget = none;
    Instigator.Controller.GetPlayerViewPoint(StartTrace, AimRot);
    Aim = vector(AimRot);
    EndTrace = StartTrace + (Aim * LockRange);
    HitActor = Trace(HitLocation, HitNormal, EndTrace, StartTrace, true,,, 1);
    if((HitActor == none) || !CanLockOnTo(HitActor))
    {
        bestAim = LockAim;
        bestDist = 0;
        TA = Instigator.Controller.PickTarget(Class'Pawn', bestAim, bestDist, Aim, StartTrace, LockRange, true);
        if((TA != none) && CanLockOnTo(TA))
        {
            HitActor = Trace(HitLocation, HitNormal, TA.Location, StartTrace, true,,, 1);
            if((KFFracturedMeshActor(HitActor) != none) || KFDestructibleActor(HitActor) != none)
            {
                BestTarget = none;                
            }
            else
            {
                BestTarget = TA;
            }
        }        
    }
    else
    {
        BestTarget = HitActor;
    }
    if(BestTarget != none)
    {
        if(BestTarget == LockedTarget)
        {
            LockedOnTimeout = LockTolerance;            
        }
        else
        {
            if(PendingLockedTarget != BestTarget)
            {
                PendingLockedTarget = BestTarget;
                PendingLockTimeout = LockTolerance;
                PendingLockAcquireTimeLeft = LockAcquireTime;
                if(OpticsUI != none)
                {
                    OpticsUI.StartLockOn();
                }
                if(bUsingSights)
                {
                    ClientPlayTargetingSound(LockTargetingSoundFirstPerson);
                }
            }
        }
        if(PendingLockedTarget != none)
        {
            PendingLockAcquireTimeLeft -= LockCheckTime;
            if((PendingLockedTarget == BestTarget) && PendingLockAcquireTimeLeft <= float(0))
            {
                AdjustLockTarget(PendingLockedTarget);
                PendingLockedTarget = none;
            }
        }        
    }
    else
    {
        if(PendingLockedTarget != none)
        {
            PendingLockTimeout -= LockCheckTime;
            if((PendingLockTimeout <= float(0)) || !CanLockOnTo(PendingLockedTarget))
            {
                PendingLockedTarget = none;
                if(OpticsUI != none)
                {
                    OpticsUI.ClearLockOn();
                }
            }
        }
    }
    if((LockedTarget != none) && BestTarget != LockedTarget)
    {
        LockedOnTimeout -= LockCheckTime;
        if((LockedOnTimeout <= 0) || !CanLockOnTo(LockedTarget))
        {
            AdjustLockTarget(none);
        }
    }
}

unreliable client simulated function ClientPlayTargetingSound(AkBaseSoundObject Sound)
{
    if((Sound != none) && !bSuppressSounds)
    {
        if((Instigator != none) && Instigator.IsHumanControlled())
        {
            PlaySoundBase(Sound, true);
        }
    }
}

simulated function PlayFiringSound(byte FireModeNum)
{
    if(!bPlayingLoopingFireSnd)
    {
        if(FireModeNum == 1)
        {
            WeaponPlayFireSound(DartFireSnd.DefaultCue, DartFireSnd.FirstPersonCue);            
        }
        else
        {
            super.PlayFiringSound(FireModeNum);
            return;
        }
    }
    MakeNoise(1, 'PlayerFiring');
}

simulated function name GetWeaponFireAnim(byte FireModeNum)
{
    if(FireModeNum == 1)
    {
        return ((bUsingSights) ? 'Shoot_Iron_Dart' : 'Shoot_Dart');
    }
    return super.GetWeaponFireAnim(FireModeNum);
}

reliable client simulated function ClientWeaponSet(bool bOptionalSet, optional bool bDoNotActivate)
{
    local KFInventoryManager KFIM;

    super.ClientWeaponSet(bOptionalSet, bDoNotActivate);
    if(OpticsUI == none)
    {
        KFIM = KFInventoryManager(InvManager);
        if(KFIM != none)
        {
            OpticsUI = KFGFxWorld_MedicOptics(KFIM.GetOpticsUIMovie(OpticsUIClass));
        }
    }
    StartHealRecharge();
}

function ItemRemovedFromInvManager()
{
    local KFInventoryManager KFIM;
    local KFWeap_MedicBase KFW;

    super.ItemRemovedFromInvManager();
    if(OpticsUI != none)
    {
        KFIM = KFInventoryManager(InvManager);
        if(KFIM != none)
        {
            foreach KFIM.InventoryActors(Class'KFWeap_MedicBase', KFW)
            {
                if((KFW != self) && KFW.OpticsUI.Class == OpticsUI.Class)
                {                    
                    return;
                }                
            }            
            KFIM.RemoveOpticsUIMovie(OpticsUI.Class);
            OpticsUI.Close();
            OpticsUI = none;
        }
    }
}

simulated function AttachWeaponTo(SkeletalMeshComponent MeshCpnt, optional name SocketName)
{
    super.AttachWeaponTo(MeshCpnt, SocketName);
    if(OpticsUI != none)
    {
        OpticsUI.SetPause(false);
        OpticsUI.ClearLockOn();
        UpdateOpticsUI(true);
        OpticsUI.SetShotPercentCost(float(AmmoCost[1]));
    }
}

simulated function DetachWeapon()
{
    local Pawn OwnerPawn;

    super.DetachWeapon();
    OwnerPawn = Pawn(Owner);
    if((OwnerPawn != none) && OwnerPawn.Weapon == self)
    {
        if(OpticsUI != none)
        {
            OpticsUI.SetPause();
        }
    }
}

simulated function UpdateOpticsUI(optional bool bForceUpdate)
{
    if((OpticsUI != none) && OpticsUI.OpticsContainer != none)
    {
        if((AmmoCount[0] != StoredPrimaryAmmo) || bForceUpdate)
        {
            StoredPrimaryAmmo = AmmoCount[0];
            OpticsUI.SetPrimaryAmmo(StoredPrimaryAmmo);
        }
        if((AmmoCount[1] != StoredSecondaryAmmo) || bForceUpdate)
        {
            StoredSecondaryAmmo = AmmoCount[1];
            OpticsUI.SetHealerCharge(StoredSecondaryAmmo);
        }
        if(OpticsUI.MinPercentPerShot != float(AmmoCost[1]))
        {
            OpticsUI.SetShotPercentCost(float(AmmoCost[1]));
        }
    }
}

static simulated event SetTraderWeaponStats(out array<STraderItemWeaponStats> WeaponStats)
{
    super.SetTraderWeaponStats(WeaponStats);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 8;
    WeaponStats[WeaponStats.Length - 1].StatValue = float(default.HealAmount);
    WeaponStats.Length = WeaponStats.Length + 1;
    WeaponStats[WeaponStats.Length - 1].StatType = 9;
    WeaponStats[WeaponStats.Length - 1].StatValue = default.HealFullRechargeSeconds;
}

simulated state WeaponSingleFiring
{
    simulated function FireAmmunition()
    {
        if(CurrentFireMode == 1)
        {
            SetWeakZedGrabCooldownOnPawn(HealDartShotWeakZedGrabCooldown);
            StartHealRecharge();
        }
        super.FireAmmunition();
    }
    stop;    
}

auto simulated state Inactive
{
    simulated function BeginState(name PreviousStateName)
    {
        super.BeginState(PreviousStateName);
        if(Role == ROLE_Authority)
        {
            bTargetLockingActive = false;
            AdjustLockTarget(none);
            ClearTimer('CheckTargetLock');
        }
        PendingLockedTarget = none;
    }

    simulated function EndState(name NextStateName)
    {
        super.EndState(NextStateName);
        if(Role == ROLE_Authority)
        {
            bTargetLockingActive = true;
            SetTimer(LockCheckTime, true, 'CheckTargetLock');
        }
    }
    stop;    
}

simulated state WeaponSprinting
{
    ignores AllowTargetLockOn;
    stop;    
}

defaultproperties
{
    HealingDartDamageType=Class'KFDT_Dart_Healing'
    HealAmount=20
    HealFullRechargeSeconds=15
    HealImpactSoundPlayEvent=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Dart_Heal'
    HurtImpactSoundPlayEvent=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Dart_Hurt'
    DartFireSnd=(DefaultCue=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Dart_Fire_3P',FirstPersonCue=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Dart_Fire_1P')
    HealDartShotWeakZedGrabCooldown=0.5
    LockCheckTime=0.1
    LockRange=50000
    LockAcquireTime=0.2
    LockTolerance=0.2
    LockAim=0.98
    LockAcquiredSoundFirstPerson=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Alert_Locked_1P'
    LockLostSoundFirstPerson=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Alert_Lost_1P'
    LockTargetingSoundFirstPerson=AkEvent'WW_WEP_SA_MedicDart.Play_WEP_SA_Medic_Alert_Locking_1P'
    OpticsUIClass=Class'KFGame.KFGFxWorld_MedicOptics'
    MagazineCapacity[1]=100
    bCanRefillSecondaryAmmo=false
    AimCorrectionSize=40
    AmmoCost=/* Array type was not detected. */
    SpareAmmoCount[1]=100
    MeleeAttackHelper=KFMeleeHelperWeapon'Default__KFWeap_MedicBase.MeleeHelper'
    FiringStatesArray=/* Array type was not detected. */
    WeaponFireTypes=/* Array type was not detected. */
    WeaponProjectiles=/* Array type was not detected. */
    FireInterval=/* Array type was not detected. */
    Spread=/* Array type was not detected. */
    InstantHitDamageTypes=/* Array type was not detected. */
    begin object name=FirstPersonMesh class=KFSkeletalMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: KFSkeletalMeshComponent'Default__KFWeap_MedicBase.FirstPersonMesh'
    Mesh=FirstPersonMesh
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_MedicBase.StaticPickupComponent'
    DroppedPickupMesh=StaticPickupComponent
    begin object name=StaticPickupComponent class=StaticMeshComponent
        ReplacementPrimitive=none
    object end
    // Reference: StaticMeshComponent'Default__KFWeap_MedicBase.StaticPickupComponent'
    PickupFactoryMesh=StaticPickupComponent
}