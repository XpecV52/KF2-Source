/*******************************************************************************
 * ParticleModuleRequired generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class ParticleModuleRequired extends ParticleModule
    native(Particle)
    editinlinenew
    hidecategories(Object,Object,Cascade);

enum EParticleSortMode
{
    PSORTMODE_None,
    PSORTMODE_ViewProjDepth,
    PSORTMODE_DistanceToView,
    PSORTMODE_Age_OldestFirst,
    PSORTMODE_Age_NewestFirst,
    PSORTMODE_MAX
};

enum EEmitterNormalsMode
{
    ENM_CameraFacing,
    ENM_Spherical,
    ENM_Cylindrical,
    ENM_MAX
};

/** The material to utilize for the emitter at this LOD level. */
var(Emitter) MaterialInterface Material;
/**  
 *The screen alignment to utilize for the emitter at this LOD level.
 *       One of the following:
 *       PSA_Square                      - Uniform scale (via SizeX) facing the camera
 *       PSA_Rectangle           - Non-uniform scale (via SizeX and SizeY) facing the camera
 *       PSA_Velocity            - Orient the particle towards both the camera and the direction 
 *                                                 the particle is moving. Non-uniform scaling is allowed.
 *       PSA_TypeSpecific        - Use the alignment method indicated int he type data module.
 */
var(Emitter) ParticleSpriteEmitter.EParticleScreenAlignment ScreenAlignment;
/**  
 *The sorting mode to use for this emitter.
 *       PSORTMODE_None                          - No sorting required.
 *       PSORTMODE_ViewProjDepth         - Sort by view projected depth of the particle.
 *       PSORTMODE_DistanceToView        - Sort by distance of particle to view in world space.
 *       PSORTMODE_Age_OldestFirst       - Sort by age, oldest drawn first.
 *       PSORTMODE_Age_NewestFirst       - Sort by age, newest drawn first.
 */
var(Emitter) ParticleModuleRequired.EParticleSortMode SortMode;
var ParticleEmitter.EParticleBurstMethod ParticleBurstMethod;
/**  
 *The interpolation method to used for the SubUV image selection.
 *       One of the following:
 *       PSUVIM_None                     - Do not apply SubUV modules to this emitter. 
 *       PSUVIM_Linear           - Smoothly transition between sub-images in the given order, 
 *                                                 with no blending between the current and the next
 *       PSUVIM_Linear_Blend     - Smoothly transition between sub-images in the given order, 
 *                                                 blending between the current and the next 
 *       PSUVIM_Random           - Pick the next image at random, with no blending between 
 *                                                 the current and the next 
 *       PSUVIM_Random_Blend     - Pick the next image at random, blending between the current 
 *                                                 and the next
 */
var(SubUV) ParticleEmitter.EParticleSubUVInterpMethod InterpolationMethod;
/** Normal generation mode for this emitter LOD. */
var(Normals) ParticleModuleRequired.EEmitterNormalsMode EmitterNormalsMode;
/** If TRUE, negative size values will flip the sprite image on that axis */
var(Emitter) bool bAllowImageFlipping;
/**  
 *If bAllowImageFlipping is enabled, and the alignment mode is square, than when
 *       TRUE, a -X size value will flip both the U and V. When FALSE, the sign of the
 *       Y size will still determine image flipping on V.
 */
var(Emitter) bool bSquareImageFlipping;
/** If TRUE, update the emitter in local space */
var(Emitter) bool bUseLocalSpace;
/** If TRUE, kill the emitter when the particle system is deactivated */
var(Emitter) bool bKillOnDeactivate;
/** If TRUE, kill the emitter when it completes */
var(Emitter) bool bKillOnCompleted;
var deprecated bool bRequiresSorting;
/**  
 *If TRUE, the EmitterTime for the emitter will be calculated by
 *       modulating the SecondsSinceCreation by the EmitterDuration. As
 *       this can lead to issues w/ looping and variable duration, a new
 *       approach has been implemented. 
 *       If FALSE, this new approach is utilized, and the EmitterTime is
 *       simply incremented by DeltaTime each tick. When the emitter 
 *       loops, it adjusts the EmitterTime by the current EmitterDuration
 *       resulting in proper looping/delay behavior.
 */
var(Emitter) bool bUseLegacyEmitterTime;
/** Whether to enable particles' culling for near distance. Works only with sprite/SubUV emitter. */
var(DistanceCulling) bool bEnableNearParticleCulling;
/** Whether to enable particles' culling for far distance. Works only with sprite/SubUV emitter. */
var(DistanceCulling) bool bEnableFarParticleCulling;
/**  
 *If TRUE, select the emitter duration from the range 
 *               [EmitterDurationLow..EmitterDuration]
 */
var(Duration) bool bEmitterDurationUseRange;
/** If TRUE, recalculate the emitter duration on each loop. */
var(Duration) bool bDurationRecalcEachLoop;
/**  
 *If TRUE, select the emitter delay from the range 
 *               [EmitterDelayLow..EmitterDelay]
 */
var(Delay) bool bEmitterDelayUseRange;
/** If TRUE, the emitter will be delayed only on the first loop. */
var(Delay) bool bDelayFirstLoopOnly;
/** Whether to scale the UV or not - ie, the model wasn't setup with sub uvs */
var(SubUV) bool bScaleUV;
var bool bDirectUV;
/** Override the system MacroUV settings */
var(MacroUV) bool bOverrideSystemMacroUV;
/**  
 *If TRUE, use the MaxDrawCount to limit the number of particles rendered.
 *       NOTE: This does not limit the number spawned/updated, only what is drawn.
 */
var(Rendering) bool bUseMaxDrawCount;
/** Ensures that movement generated from the orbit module is applied to velocity-aligned particles */
var(Emitter) bool bOrbitModuleAffectsVelocityAlignment;
/** Near cull distance. Alpha=0.0f, NearCullDistance < NearFadeDistance. Particles closer than this distance are almost free to rendering by GPU. */
var(DistanceCulling) float NearCullDistance;
/** Near fade distance. Alpha=Initial. Fade transition from NearCullDistance. */
var(DistanceCulling) float NearFadeDistance;
/** Far fade distance. Alpha=Initial. Fade transition to FarCullDistance. */
var(DistanceCulling) float FarFadeDistance;
/** Far cull distance. Alpha=0.0f, FarFadeDistance < FarCullDistance. Particles further than this distance are almost free to rendering by GPU. */
var(DistanceCulling) float FarCullDistance;
/**  
 *How long, in seconds, the emitter will run before looping.
 *       If set to 0, the emitter will never loop.
 */
var(Duration) float EmitterDuration;
/** The low end of the emitter duration if using a range. */
var(Duration) float EmitterDurationLow;
/**  
 *The number of times to loop the emitter.
 *       0 indicates loop continuously
 */
var(Duration) int EmitterLoops;
var RawDistributionFloat SpawnRate;
var noclear export array<export ParticleBurst> BurstList;
/** Indicates the time (in seconds) that this emitter should be delayed in the particle system. */
var(Delay) float EmitterDelay;
/** The low end of the emitter delay if using a range. */
var(Delay) float EmitterDelayLow;
/** The number of sub-images horizontally in the texture */
var(SubUV) int SubImages_Horizontal;
/** The number of sub-images vertically in the texture */
var(SubUV) int SubImages_Vertical;
var float RandomImageTime;
/** The number of times to change a random image over the life of the particle. */
var(SubUV) int RandomImageChanges;
/** Local space position that UVs generated with the ParticleMacroUV material node will be centered on. */
var(MacroUV) Vector MacroUVPosition;
/** World space radius that UVs generated with the ParticleMacroUV material node will tile based on. */
var(MacroUV) float MacroUVRadius;
/**  
 *The maximum number of particles to DRAW for this emitter.
 *       If set to 0, it will use whatever number are present.
 */
var(Rendering) int MaxDrawCount;
var float DownsampleThresholdScreenFraction;
/**  
 *When EmitterNormalsMode is ENM_Spherical, particle normals are created to face away from NormalsSphereCenter. 
 * NormalsSphereCenter is in local space.
 */
var(Normals) Vector NormalsSphereCenter;
/**  
 *When EmitterNormalsMode is ENM_Cylindrical, 
 * particle normals are created to face away from the cylinder going through NormalsSphereCenter in the direction NormalsCylinderDirection. 
 * NormalsCylinderDirection is in local space.
 */
var(Normals) Vector NormalsCylinderDirection;

defaultproperties
{
    bUseLegacyEmitterTime=true
    bUseMaxDrawCount=true
    NearCullDistance=10
    NearFadeDistance=150
    FarFadeDistance=2000
    FarCullDistance=2100
    EmitterDuration=1
    SpawnRate=Distribution=DistributionFloatConstant'Default__ParticleModuleRequired.RequiredDistributionSpawnRate',Type=0,Op=1,LookupTableNumElements=1,LookupTableChunkSize=1,LookupTable=/* Array type was not detected. */,0=/* Unknown default property type! */,
/* Exception thrown while deserializing SpawnRate
System.ArgumentException: Requested value '3rd' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    SubImages_Horizontal=1
    SubImages_Vertical=1
    MaxDrawCount=500
    NormalsSphereCenter=(X=0,Y=0,Z=100)
    NormalsCylinderDirection=(X=0,Y=0,Z=1)
    bSpawnModule=true
    bUpdateModule=true
}