/*******************************************************************************
 * PickupFactory generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class PickupFactory extends NavigationPoint
    abstract
    native
    nativereplication
    placeable
    hidecategories(Navigation,Lighting,LightColor,Force)
    classgroup(Pickups);

var bool bOnlyReplicateHidden;
var repnotify bool bPickupHidden;
var bool bPredictRespawns;
var bool bIsSuperItem;
var bool bRespawnPaused;
var repnotify class<Inventory> InventoryType;
var float RespawnEffectTime;
var float MaxDesireability;
var export editinline PrimitiveComponent PickupMesh;
var PickupFactory ReplacementFactory;
var PickupFactory OriginalFactory;

replication
{
     if(bNetDirty && Role == ROLE_Authority)
        bPickupHidden;

     if(bNetInitial && Role == ROLE_Authority)
        InventoryType;
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'bPickupHidden')
    {
        if(bPickupHidden)
        {
            SetPickupHidden();            
        }
        else
        {
            SetPickupVisible();
        }        
    }
    else
    {
        if(VarName == 'InventoryType')
        {
            InitializePickup();
        }
    }
}

simulated event PreBeginPlay()
{
    InitializePickup();
    super(Actor).PreBeginPlay();
}

simulated function InitializePickup()
{
    if(InventoryType == none)
    {
        WarnInternal("No inventory type for" @ string(self));
        return;
    }
    bPredictRespawns = InventoryType.default.bPredictRespawns;
    MaxDesireability = InventoryType.default.MaxDesireability;
    SetPickupMesh();
    bIsSuperItem = InventoryType.default.bDelayedSpawn;
}

simulated event SetInitialState()
{
    bScriptInitialized = true;
    if(InventoryType == none)
    {
        WarnInternal("Disabling as no inventory type for " $ string(self));
        GotoState('Disabled');        
    }
    else
    {
        if(bIsSuperItem)
        {
            GotoState('WaitingForMatch');            
        }
        else
        {
            super(Actor).SetInitialState();
        }
    }
}

simulated function ShutDown()
{
    GotoState('Disabled');
}

simulated function SetPickupMesh()
{
    if(InventoryType.default.PickupFactoryMesh != none)
    {
        if(PickupMesh != none)
        {
            DetachComponent(PickupMesh);
            PickupMesh = none;
        }
        PickupMesh = new (self) InventoryType.default.PickupFactoryMesh.Class (InventoryType.default.PickupFactoryMesh);
        AttachComponent(PickupMesh);
        if(bPickupHidden)
        {
            SetPickupHidden();            
        }
        else
        {
            SetPickupVisible();
        }
    }
}

function Reset()
{
    if(bIsSuperItem)
    {
        GotoState('Sleeping');        
    }
    else
    {
        GotoState('Pickup');
    }
    super(Actor).Reset();
}

function bool CheckForErrors()
{
    local Actor HitActor;
    local Vector HitLocation, HitNormal;

    HitActor = Trace(HitLocation, HitNormal, Location - vect(0, 0, 10), Location, false);
    if(HitActor == none)
    {
        LogInternal(string(self) $ " FLOATING");
        return true;
    }
    return super(Actor).CheckForErrors();
}

function SetRespawn()
{
    if((InventoryType.default.RespawnTime != float(0)) && WorldInfo.Game.ShouldRespawn(self))
    {
        StartSleeping();        
    }
    else
    {
        GotoState('Disabled');
    }
}

function StartSleeping()
{
    GotoState('Sleeping');
}

event float DetourWeight(Pawn Other, float PathWeight)
{
    return ((ReplacementFactory != none) ? ReplacementFactory.DetourWeight(Other, PathWeight) : 0);
}

function SpawnCopyFor(Pawn Recipient)
{
    local Inventory Inv;

    Inv = Spawn(InventoryType);
    if(Inv != none)
    {
        Inv.GiveTo(Recipient);
        Inv.AnnouncePickup(Recipient);
    }
}

function bool ReadyToPickup(float MaxWait)
{
    return false;
}

function GiveTo(Pawn P)
{
    SpawnCopyFor(P);
    PickedUpBy(P);
}

function PickedUpBy(Pawn P)
{
    SetRespawn();
    TriggerEventClass(Class'SeqEvent_PickupStatusChange', P, 1);
    if((P.Controller != none) && P.Controller.MoveTarget == self)
    {
        P.SetAnchor(self);
        P.Controller.MoveTimer = -1;
    }
}

function RecheckValidTouch();

function float GetRespawnTime()
{
    return InventoryType.default.RespawnTime;
}

function RespawnEffect();

simulated function SetPickupHidden()
{
    bForceNetUpdate = true;
    bPickupHidden = true;
    if(PickupMesh != none)
    {
        PickupMesh.SetHidden(true);
    }
}

simulated function SetPickupVisible()
{
    bForceNetUpdate = true;
    bPickupHidden = false;
    if(PickupMesh != none)
    {
        PickupMesh.SetHidden(false);
    }
}

event Destroyed()
{
    if(OriginalFactory != none)
    {
        OriginalFactory.ReplacementFactory = ReplacementFactory;
    }
    if(ReplacementFactory != none)
    {
        ReplacementFactory.OriginalFactory = OriginalFactory;
    }
}

function bool DelayRespawn()
{
    return false;
}

auto state Pickup
{
    event float DetourWeight(Pawn Other, float PathWeight)
    {
        return InventoryType.static.DetourWeight(Other, PathWeight);
    }

    function bool ReadyToPickup(float MaxWait)
    {
        return true;
    }

    function bool ValidTouch(Pawn Other)
    {
        if((Other == none) || !Other.bCanPickupInventory)
        {
            return false;            
        }
        else
        {
            if(Other.Controller == none)
            {
                SetTimer(0.2, false, 'RecheckValidTouch');
                return false;                
            }
            else
            {
                if(!FastTrace(Other.Location, Location))
                {
                    SetTimer(0.5, false, 'RecheckValidTouch');
                    return false;
                }
            }
        }
        if(WorldInfo.Game.PickupQuery(Other, InventoryType, self))
        {
            return true;
        }
        return false;
    }

    function RecheckValidTouch()
    {
        CheckTouching();
    }

    event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
    {
        local Pawn P;

        P = Pawn(Other);
        if((P != none) && ValidTouch(P))
        {
            GiveTo(P);
        }
    }

    function CheckTouching()
    {
        local Pawn P;

        foreach TouchingActors(Class'Pawn', P)
        {
            Touch(P, none, Location, Normal(Location - P.Location));            
        }        
    }

    event BeginState(name PreviousStateName)
    {
        TriggerEventClass(Class'SeqEvent_PickupStatusChange', none, 0);
    }
Begin:

    CheckTouching();
    stop;        
}

state WaitingForMatch
{
    ignores Touch;

    function MatchStarting()
    {
        GotoState('Sleeping');
    }

    event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
    }
    stop;    
}

state Sleeping
{
    ignores Touch, StartSleeping;

    function bool ReadyToPickup(float MaxWait)
    {
        return ((bPredictRespawns && !bRespawnPaused) && LatentFloat <= MaxWait) && LatentFloat > 0;
    }

    event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
    }

    event EndState(name NextStateName)
    {
        SetPickupVisible();
    }
Begin:

    bRespawnPaused = true;
    J0x0C:

    if(DelayRespawn())
    {
        Sleep(1);
        goto J0x0C;
    }
    bRespawnPaused = false;
    Sleep((GetRespawnTime()) - RespawnEffectTime);
Respawn:


    RespawnEffect();
    Sleep(RespawnEffectTime);
    GotoState('Pickup');
    stop;                
}

state Disabled
{
    ignores Reset, StartSleeping;

    function bool ReadyToPickup(float MaxWait)
    {
        return false;
    }

    simulated event SetInitialState()
    {
        bScriptInitialized = true;
    }

    simulated event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
        SetCollision(false, false);
    }

    simulated event EndState(name NextStateName)
    {
        SetPickupVisible();
    }
    stop;    
}

defaultproperties
{
    bOnlyReplicateHidden=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__PickupFactory.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__PickupFactory.PathRenderer'
    Components(4)=PathRenderer
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_TouchAll
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bStatic=false
    bIgnoreEncroachers=true
    bAlwaysRelevant=true
    bCollideWhenPlacing=false
    bCollideActors=true
    NetUpdateFrequency=1
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
    SupportedEvents(6)=class'SeqEvent_PickupStatusChange'
}