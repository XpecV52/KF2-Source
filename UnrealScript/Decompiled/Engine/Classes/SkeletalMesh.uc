/*******************************************************************************
 * SkeletalMesh generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SkeletalMesh extends Object
    native(SkeletalMesh)
    noexport
    hidecategories(Object);

enum BoneBreakOption
{
    BONEBREAK_SoftPreferred,
    BONEBREAK_AutoDetect,
    BONEBREAK_RigidPreferred,
    BONEBREAK_MAX
};

enum TriangleSortOption
{
    TRISORT_None,
    TRISORT_CenterRadialDistance,
    TRISORT_Random,
    TRISORT_MergeContiguous,
    TRISORT_Custom,
    TRISORT_CustomLeftRight,
    TRISORT_MAX
};

enum ClothMovementScaleGen
{
    ECMDM_DistToFixedVert,
    ECMDM_VertexBoneWeight,
    ECMDM_Empty,
    ECMDM_MAX
};

enum TriangleSortAxis
{
    TSA_X_Axis,
    TSA_Y_Axis,
    TSA_Z_Axis,
    TSA_MAX
};

enum SkeletalMeshOptimizationImportance
{
    SMOI_Off,
    SMOI_Lowest,
    SMOI_Low,
    SMOI_Normal,
    SMOI_High,
    SMOI_Highest,
    SMOI_MAX
};

enum SkeletalMeshOptimizationType
{
    SMOT_NumOfTriangles,
    SMOT_MaxDeviation,
    SMOT_MAX
};

enum SkeletalMeshOptimizationNormalMode
{
    SMONM_Recalculate,
    SMONM_RecalculateSoft,
    SMONM_RecalculateHard,
    SMONM_MAX
};

enum ClothBoneType
{
    CLOTHBONE_Fixed,
    CLOTHBONE_BreakableAttachment,
    CLOTHBONE_TearLine,
    CLOTHBONE_MAX
};

enum SoftBodyBoneType
{
    SOFTBODYBONE_Fixed,
    SOFTBODYBONE_BreakableAttachment,
    SOFTBODYBONE_TwoWayAttachment,
    SOFTBODYBONE_MAX
};

struct native ApexClothingLodInfo
{
    /** The mesh section that the clothing submesh will override. */
    var() editfixedsize array<int> ClothingSectionInfo;

    structdefaultproperties
    {
        ClothingSectionInfo=none
    }
};

struct native ApexClothingAssetInfo
{
    /** Graphical Lod Info for the clothing asset */
    var() editfixedsize array<ApexClothingLodInfo> ClothingLodInfo;
    var name ClothingAssetName;

    structdefaultproperties
    {
        ClothingLodInfo=none
        ClothingAssetName=None
    }
};

struct native BoneMirrorInfo
{
    /** The bone to mirror. */
    var() int SourceIndex<ArrayClamp=RefSkeleton>;
    /** Axis the bone is mirrored across. */
    var() Core.Object.EAxis BoneFlipAxis;

    structdefaultproperties
    {
        SourceIndex=0
        BoneFlipAxis=EAxis.AXIS_NONE
    }
};

struct native BoneMirrorExport
{
    /** Structure to export/import bone mirroring information */
    var() name BoneName;
    /** Structure to export/import bone mirroring information */
    var() name SourceBoneName;
    /** Structure to export/import bone mirroring information */
    var() Core.Object.EAxis BoneFlipAxis;

    structdefaultproperties
    {
        BoneName=None
        SourceBoneName=None
        BoneFlipAxis=EAxis.AXIS_NONE
    }
};

struct TriangleSortSettings
{
    /** Struct containing triangle sort settings for a particular section */
    var() SkeletalMesh.TriangleSortOption TriangleSorting;
    /** Struct containing triangle sort settings for a particular section */
    var() SkeletalMesh.TriangleSortAxis CustomLeftRightAxis;
    /** Struct containing triangle sort settings for a particular section */
    var() name CustomLeftRightBoneName;

    structdefaultproperties
    {
        TriangleSorting=TriangleSortOption.TRISORT_None
        CustomLeftRightAxis=TriangleSortAxis.TSA_X_Axis
        CustomLeftRightBoneName=None
    }
};

struct native SkeletalMeshLODInfo
{
    /** Indicates when to use this LOD. A smaller number means use this LOD when further away. */
    var() float DisplayFactor;
    /** Used to avoid 'flickering' when on LOD boundary. Only taken into account when moving from complex->simple. */
    var() float LODHysteresis;
    /** Mapping table from this LOD's materials to the SkeletalMesh materials array. */
    var() editfixedsize array<int> LODMaterialMap;
    /** Per-section control over whether to enable shadow casting. */
    var() editfixedsize array<bool> bEnableShadowCasting;
    var deprecated array<deprecated SkeletalMesh.TriangleSortOption> TriangleSorting;
    /** Per-section sorting options */
    var() editfixedsize array<TriangleSortSettings> TriangleSortSettings;
    /** Use compressed position XYZs(4 bytes saving 8 bytes). This is only useful for GPU skinning. */
    var() bool bDisableCompressions;
    var bool bHasBeenSimplified;

    structdefaultproperties
    {
        DisplayFactor=0
        LODHysteresis=0
        LODMaterialMap=none
        bEnableShadowCasting=none
        TriangleSortSettings=none
        bDisableCompressions=false
        bHasBeenSimplified=false
    }
};

struct native SkeletalMeshOptimizationSettings
{
    var float MaxDeviationPercentage;
    var SkeletalMesh.SkeletalMeshOptimizationImportance SilhouetteImportance;
    var SkeletalMesh.SkeletalMeshOptimizationImportance TextureImportance;
    var SkeletalMesh.SkeletalMeshOptimizationImportance ShadingImportance;
    var SkeletalMesh.SkeletalMeshOptimizationImportance SkinningImportance;
    var deprecated SkeletalMesh.SkeletalMeshOptimizationNormalMode NormalMode;
    var float BoneReductionRatio;
    var int MaxBonesPerVertex;
    var SkeletalMesh.SkeletalMeshOptimizationType ReductionMethod;
    var float NumOfTrianglesPercentage;
    var float WeldingThreshold;
    var bool bRecalcNormals;
    var float NormalsThreshold;

    structdefaultproperties
    {
        MaxDeviationPercentage=0
        SilhouetteImportance=SkeletalMeshOptimizationImportance.SMOI_Off
        TextureImportance=SkeletalMeshOptimizationImportance.SMOI_Off
        ShadingImportance=SkeletalMeshOptimizationImportance.SMOI_Off
        SkinningImportance=SkeletalMeshOptimizationImportance.SMOI_Off
        BoneReductionRatio=0
        MaxBonesPerVertex=0
        ReductionMethod=SkeletalMeshOptimizationType.SMOT_NumOfTriangles
        NumOfTrianglesPercentage=0
        WeldingThreshold=0
        bRecalcNormals=false
        NormalsThreshold=0
    }
};

struct native ClothSpecialBoneInfo
{
    /** The bone name to attach to a cloth vertex */
    var() name BoneName;
    /** The type of attachment */
    var() SkeletalMesh.ClothBoneType BoneType;
    var const array<int> AttachedVertexIndices;

    structdefaultproperties
    {
        BoneName=None
        BoneType=ClothBoneType.CLOTHBONE_Fixed
        AttachedVertexIndices=none
    }
};

struct native Sphere
{
    var() Vector Center;
    var() float Radius;

    structdefaultproperties
    {
        Center=(X=0,Y=0,Z=0)
        Radius=0
    }
};

struct native SoftBodyTetraLink
{
    var int Index;
    var Vector Bary;

    structdefaultproperties
    {
        Index=0
        Bary=(X=0,Y=0,Z=0)
    }
};

struct native SoftBodySpecialBoneInfo
{
    /** The bone name to attach to a cloth vertex */
    var() name BoneName;
    /** The type of attachment */
    var() SkeletalMesh.SoftBodyBoneType BoneType;
    var const array<int> AttachedVertexIndices;

    structdefaultproperties
    {
        BoneName=None
        BoneType=SoftBodyBoneType.SOFTBODYBONE_Fixed
        AttachedVertexIndices=none
    }
};

var() native const BoxSphereBounds Bounds;
/** List of materials applied to this mesh. */
var() native const array<MaterialInterface> Materials;
/** List of clothing assets associated with each material int this mesh. */
var() editfixedsize array<ApexClothingAsset> ClothingAssets;
/** List of Clothing LOD and the mapping of clothing to skeletal mesh section */
var() editfixedsize array<ApexClothingAssetInfo> ClothingLodMap;
/** Origin in original coordinate system */
var() native const Vector Origin;
/** Amount to rotate when importing (mostly for yawing) */
var() native const Rotator RotOrigin;
var native const array<int> RefSkeleton;
var native const int SkeletalDepth;
var native const map<0, 0> NameIndexMap;
var private native const IndirectArray_Mirror LODModels;
var private native const Pointer SourceData;
var native const array<BoneAtom> RefBasesInvMatrix;
/** List of bones that should be mirrored. */
var() editfixedsize array<BoneMirrorInfo> SkelMirrorTable;
var() Core.Object.EAxis SkelMirrorAxis;
var() Core.Object.EAxis SkelMirrorFlipAxis;
var array<SkeletalMeshSocket> Sockets;
/** Array of bone names that break for use in game/editor */
var() native const editconst array<editconst string> BoneBreakNames;
/** Match with BoneBreakNames array */
var() native const array<SkeletalMesh.BoneBreakOption> BoneBreakOptions;
/** Struct containing information for each LOD level, such as materials to use, whether to cast shadows, and when use the LOD. */
var() editfixedsize array<SkeletalMeshLODInfo> LODInfo;
var array<SkeletalMeshOptimizationSettings> OptimizationSettings;
/** For each bone specified here, all triangles rigidly weighted to that bone are entered into a kDOP, allowing per-poly collision checks. */
var() array<name> PerPolyCollisionBones;
/** For each of these bones, find the parent that is in PerPolyCollisionBones and add its polys to that bone. */
var() array<name> AddToParentPerPolyCollisionBone;
var private native const array<int> PerPolyBoneKDOPs;
/** If true, include triangles that are soft weighted to bones. */
var() bool bPerPolyUseSoftWeighting;
/** If true, use PhysicsAsset for line collision checks. If false, use per-poly bone collision (if present). */
var() bool bUseSimpleLineCollision;
/** If true, use PhysicsAsset for extent (swept box) collision checks. If false, use per-poly bone collision (if present). */
var() bool bUseSimpleBoxCollision;
/** All meshes default to GPU skinning. Set to True to enable CPU skinning. If CPU skinning is enabled, bUsePackedPosition can't be enabled */
var() const bool bForceCPUSkinning;
/** If true, use 32 bit UVs. If false, use 16 bit UVs to save memory */
var() const bool bUseFullPrecisionUVs;
var bool bHasBeenSimplified;
/** The FaceFX asset the skeletal mesh uses for FaceFX operations. */
var() FaceFXAsset FaceFXAsset;
/** Asset used for previewing bounds in AnimSetViewer. Makes setting up LOD distance factors more reliable. */
var() editoronly PhysicsAsset BoundsPreviewAsset;
/** Asset used for previewing morph target animations in AnimSetViewer. Only for editor. */
var() editoronly array<editoronly MorphTargetSet> PreviewMorphSets;
/** LOD bias to use for PC. */
var() int LODBiasPC;
/** LOD bias to use for PS3. */
var() int LODBiasPS3;
/** LOD bias to use for Xbox 360. */
var() int LODBiasXbox360;
/** LOD bias to use for Orbis. */
var() int LODBiasOrbis;
/** Path to the resource used to construct this skeletal mesh */
var() editoronly const editconst string SourceFilePath;
/** Date/Time-stamp of the file from the last import */
var() editoronly const editconst string SourceFileTimestamp;
var native const transient array<Pointer> ClothMesh;
var native const transient array<float> ClothMeshScale;
var const array<int> ClothToGraphicsVertMap;
var const array<float> ClothMovementScale;
/** Method to use to generate the ClothMovementScale table */
var(Cloth) SkeletalMesh.ClothMovementScaleGen ClothMovementScaleGenMode;
/** How far a simulated vertex can move from its animated location */
var(Cloth) float ClothToAnimMeshMaxDist;
/** If TRUE, simulated verts are limited to a certain distance from */
var(Cloth) bool bLimitClothToAnimMesh;
var const array<int> ClothWeldingMap;
var const int ClothWeldingDomain;
var const array<int> ClothWeldedIndices;
/** Forces the Welding Code to be turned off even if the mesh has doubled vertices */
var(ClothAdvanced) const bool bForceNoWelding;
var const int NumFreeClothVerts;
var const array<int> ClothIndexBuffer;
/** Vertices with any weight to these bones are considered 'cloth'. */
var(Cloth) const array<name> ClothBones;
/** If greater than 1, will generate smaller meshes internally, used to improve simulation time and reduce stretching. */
var(Cloth) const int ClothHierarchyLevels;
/** Enable constraints that attempt to minimize curvature or folding of the cloth. */
var(Cloth) const bool bEnableClothBendConstraints;
/** Enable damping forces on the cloth. */
var(Cloth) const bool bEnableClothDamping;
/** Enable center of mass damping of cloth internal velocities. */
var(Cloth) const bool bUseClothCOMDamping;
/** Controls strength of springs that attempts to keep particles in the cloth together. */
var(Cloth) const float ClothStretchStiffness<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
/**  
 *Controls strength of springs that stop the cloth from bending. 
 *       bEnableClothBendConstraints must be true to take affect.
 */
var(Cloth) const float ClothBendStiffness<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
/**  
 *This is multiplied by the size of triangles sharing a point to calculate the points mass.
 *       This cannot be modified after the cloth has been created.
 */
var(Cloth) const float ClothDensity;
/** How thick the cloth is considered when doing collision detection. */
var(Cloth) const float ClothThickness;
/**  
 *Controls how much damping force is applied to cloth particles.
 *       bEnableClothDamping must be true to take affect.
 */
var(Cloth) const float ClothDamping<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
/** Increasing the number of solver iterations improves how accurately the cloth is simulated, but will also slow down simulation. */
var(Cloth) const int ClothIterations;
/** If ClothHierarchyLevels is more than 0, this number controls the number of iterations of the hierarchical solver. */
var(Cloth) const int ClothHierarchicalIterations;
/** Controls movement of cloth when in contact with other bodies. */
var(Cloth) const float ClothFriction<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
/**  
 *Controls the size of the grid cells a cloth is divided into when performing broadphase collision. 
 * The cell size is relative to the AABB of the cloth.
 */
var(ClothAdvanced) const float ClothRelativeGridSpacing;
/** Adjusts the internal "air" pressure of the cloth. Only has affect when bEnableClothPressure. */
var(ClothAdvanced) const float ClothPressure;
/** Response coefficient for cloth/rb collision */
var(ClothAdvanced) const float ClothCollisionResponseCoefficient;
/** How much an attachment to a rigid body influences the cloth */
var(ClothAdvanced) const float ClothAttachmentResponseCoefficient;
/** How much extension an attachment can undergo before it tears/breaks */
var(ClothAdvanced) const float ClothAttachmentTearFactor;
/**  
 *Maximum linear velocity at which cloth can go to sleep.
 * If negative, the global default will be used.
 */
var(ClothAdvanced) const float ClothSleepLinearVelocity;
/** If bHardStretchLimit is TRUE, how much stretch is allowed in the cloth. 1.0 is no stretch (but will cause jitter) */
var(Cloth) const float HardStretchLimitFactor;
/**  
 *If TRUE, limit the total amount of stretch that is allowed in the cloth, based on HardStretchLimitFactor. 
 *       Note that bLimitClothToAnimMesh must be TRUE for this to work.
 */
var(Cloth) const bool bHardStretchLimit;
/**  
 *Enable orthogonal bending resistance to minimize curvature or folding of the cloth. 
 *  This technique uses angular springs instead of distance springs as used in
 *  'bEnableClothBendConstraints'. This mode is slower but independent of stretching resistance.
 */
var(ClothAdvanced) const bool bEnableClothOrthoBendConstraints;
/** Enables cloth self collision. */
var(ClothAdvanced) const bool bEnableClothSelfCollision;
/** Enables pressure support. Simulates inflated objects like balloons. */
var(ClothAdvanced) const bool bEnableClothPressure;
/** Enables two way collision with rigid-bodies. */
var(ClothAdvanced) const bool bEnableClothTwoWayCollision;
/**  
 *Vertices with any weight to these bones are considered cloth with special behavoir, currently
 * they are attached to the physics asset with fixed or breakable attachments or tearlines.
 */
var(ClothAdvanced) const array<ClothSpecialBoneInfo> ClothSpecialBones;
/**  
 *Enable cloth line/extent/point checks. 
 * Note: line checks are performed with a raycast against the cloth, but point and swept extent checks are performed against the cloth AABB
 */
var(Cloth) const bool bEnableClothLineChecks;
/** Whether cloth simulation should be wrapped inside a Rigid Body and only be used upon impact */
var(ClothAdvanced) const bool bClothMetal;
/** Threshold for when deformation is allowed */
var(ClothAdvanced) const float ClothMetalImpulseThreshold;
/** Amount by which colliding objects are brought closer to the cloth */
var(ClothAdvanced) const float ClothMetalPenetrationDepth;
/** Maximum deviation of cloth particles from initial position */
var(ClothAdvanced) const float ClothMetalMaxDeformationDistance;
/**  
 *Used to enable cloth tearing. Note, extra vertices/indices must be reserved using ClothTearReserve 
 *  Also cloth tearing is not available when welding is enabled.
 */
var(Cloth) const bool bEnableClothTearing;
/** Stretch factor beyond which a cloth edge/vertex will tear. Should be greater than 1. */
var(Cloth) const float ClothTearFactor;
/** Number of vertices/indices to set aside to accomodate new triangles created as a result of tearing */
var(Cloth) const int ClothTearReserve;
/** Any cloth vertex that exceeds its valid bounds will be deleted if bEnableValidBounds is set. Tune ValidBoundMin and ValidBoundMax if valid bound is enabled. */
var(Cloth) bool bEnableValidBounds;
/** The minimum coordinates triplet of the cloth valid bound */
var(Cloth) Vector ValidBoundsMin;
/** The maximum coordinates triplet of the cloth valid bound */
var(Cloth) Vector ValidBoundsMax;
/** Only for PhysX 3.x. Need to explicitly add spheres or capsules to the cloth collision system. An array of spheres colliding with this cloth */
var(ClothCollisionData) array<Sphere> ClothCollisionSpheres;
/**  
 *Only for PhysX 3.x. Capsule indices (into the ClothCollisionSpheres array). E.g: A pair of (0, 1) will create 1 capsule from sphere 0 and sphere 1 in the ClothCollisionSpheres. Another pair of (1, 2) will create another capsule from sphere 1 and sphere 2. 
 *Can contain spheres with different radii to create tapered capsules.
 */
var(ClothCollisionData) array<int> ClothCollisionCapsuleIndices;
var native const Map_Mirror ClothTornTriMap;
var const array<int> SoftBodySurfaceToGraphicsVertMap;
var const array<int> SoftBodySurfaceIndices;
var const array<Vector> SoftBodyTetraVertsUnscaled;
var const array<int> SoftBodyTetraIndices;
var const array<SoftBodyTetraLink> SoftBodyTetraLinks;
var native const transient array<Pointer> CachedSoftBodyMeshes;
var native const transient array<float> CachedSoftBodyMeshScales;
/** Vertices with any weight to these bones are considered 'soft-body'. */
var(SoftBody) const array<name> SoftBodyBones;
/**  
 *Vertices with any weight to these bones are considered softbody with special behavoir, currently
 * they are attached to the physics asset with fixed or breakable attachments.
 */
var(SoftBody) const array<SoftBodySpecialBoneInfo> SoftBodySpecialBones;
/** Defines how strongly the soft-body resists motion that changes the rest volume. Range (0,1]. */
var(SoftBody) const float SoftBodyVolumeStiffness;
/** Defines how strongly the soft-body resists stretching motions. Range (0,1]. */
var(SoftBody) const float SoftBodyStretchingStiffness;
/** Density of the soft-body (mass per volume). */
var(SoftBody) const float SoftBodyDensity;
/** Size of the soft-body particles used for collision detection. */
var(SoftBody) const float SoftBodyParticleRadius;
/**  
 *Controls how much damping force is applied to soft-body particles.
 *       bEnableSoftBodyDamping must be true to take affect.
 */
var(SoftBody) const float SoftBodyDamping;
/** Increasing the number of solver iterations improves how accurately the soft-body is simulated, but will also slow down simulation. */
var(SoftBody) const int SoftBodySolverIterations;
/** Controls movement of soft-body when in contact with other bodies. */
var(SoftBody) const float SoftBodyFriction;
/**  
 *Controls the size of the grid cells a soft-body is divided into when performing broadphase collision. 
 * The cell size is relative to the AABB of the soft-body.
 */
var(SoftBody) const float SoftBodyRelativeGridSpacing;
/**  
 *Maximum linear velocity at which a soft-body can go to sleep.
 * If negative, the global default will be used.
 */
var(SoftBody) const float SoftBodySleepLinearVelocity;
/** Enables soft-body self collision. */
var(SoftBody) const bool bEnableSoftBodySelfCollision;
/**  
 *Defines a factor for the impulse transfer from the soft body to attached rigid bodies. 
 * bEnableSoftBodyTwoWayCollision must be true to take effect.
 */
var(SoftBody) const float SoftBodyAttachmentResponse;
/**  
 *Defines a factor for the impulse transfer from the soft body to colliding rigid bodies. 
 * bEnableSoftBodyTwoWayCollision must be true to take effect.
 */
var(SoftBody) const float SoftBodyCollisionResponse;
/**  
 *Controls how much the original graphics mesh is simplified before it is used
 * to seed to tetrahedron-mesh generator.
 */
var(SoftBody) const float SoftBodyDetailLevel<ClampMin=0.0|ClampMax=1.0>;
/** Controls how many tetrahedra are generated to approximate the surface-mesh. */
var(SoftBody) const int SoftBodySubdivisionLevel<ClampMin=1.0>;
/**  
 *If enabled, an iso-surface is generated around the original graphics-mesh before
 * the tetrahedron-mesh is created.
 */
var(SoftBody) const bool bSoftBodyIsoSurface;
/** Enable damping forces on the softbody. */
var(SoftBody) const bool bEnableSoftBodyDamping;
/** Enable center of mass damping of SoftBody internal velocities. */
var(SoftBody) const bool bUseSoftBodyCOMDamping;
/**  
 *Specifies the maximum distance a tetra-vertex is allowed to have from the 
 *  surface-mesh to still end up attached to a bone.
 */
var(SoftBody) const float SoftBodyAttachmentThreshold;
/** Enables two way collision with rigid-bodies. */
var(SoftBody) const bool bEnableSoftBodyTwoWayCollision;
/** How much extension an attachment can undergo before it tears/breaks */
var(SoftBody) const float SoftBodyAttachmentTearFactor;
/** Enable soft body line checks. */
var(SoftBody) const bool bEnableSoftBodyLineChecks;
var bool bHasVertexColors;
var native const array<bool> GraphicsIndexIsCloth;
var native const array<float> CachedStreamingTextureFactors;
/**  
 *Allows artists to adjust the distance where textures using UV 0 are streamed in/out.
 * 1.0 is the default, whereas a higher value increases the streamed-in resolution.
 */
var() const float StreamingDistanceMultiplier;
var native const transient int ReleaseResourcesFence;
var const transient QWord SkelMeshRUID;
/** When enabled the material in the APEX clothing asset will override the skeletal mesh material. */
var(ApexClothing) const bool bUseClothingAssetMaterial;

defaultproperties
{
    SkelMirrorAxis=EAxis.AXIS_X
    SkelMirrorFlipAxis=EAxis.AXIS_Z
    bUseSimpleLineCollision=true
    bUseSimpleBoxCollision=true
    ClothStretchStiffness=1
    ClothBendStiffness=1
    ClothDensity=1
    ClothThickness=0.5
    ClothDamping=0.5
    ClothIterations=2
    ClothHierarchicalIterations=2
    ClothFriction=0.5
    ClothRelativeGridSpacing=1
    ClothPressure=1
    ClothCollisionResponseCoefficient=0.2
    ClothAttachmentResponseCoefficient=0.2
    ClothAttachmentTearFactor=1.5
    ClothSleepLinearVelocity=-1
    HardStretchLimitFactor=1.1
    ClothMetalImpulseThreshold=10
    ClothTearFactor=3.5
    ClothTearReserve=128
    SoftBodyVolumeStiffness=1
    SoftBodyStretchingStiffness=1
    SoftBodyDensity=1
    SoftBodyParticleRadius=0.1
    SoftBodyDamping=0.5
    SoftBodySolverIterations=5
    SoftBodyFriction=0.5
    SoftBodyRelativeGridSpacing=1
    SoftBodySleepLinearVelocity=-1
    SoftBodyAttachmentResponse=0.2
    SoftBodyCollisionResponse=0.2
    SoftBodyDetailLevel=0.5
    SoftBodySubdivisionLevel=4
    bSoftBodyIsoSurface=true
    SoftBodyAttachmentThreshold=0.5
    bEnableSoftBodyTwoWayCollision=true
    SoftBodyAttachmentTearFactor=1.5
    StreamingDistanceMultiplier=1
}