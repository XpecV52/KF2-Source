/*******************************************************************************
 * Camera generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Camera extends Actor
    transient
    native(Camera)
    notplaceable
    hidecategories(Navigation);

const MAX_ACTIVE_CAMERA_ANIMS = 8;

enum EViewTargetBlendFunction
{
    VTBlend_Linear,
    VTBlend_Cubic,
    VTBlend_EaseIn,
    VTBlend_EaseOut,
    VTBlend_EaseInOut,
    VTBlend_MAX
};

enum ECameraAnimPlaySpace
{
    CAPS_CameraLocal,
    CAPS_World,
    CAPS_UserDefined,
    CAPS_MAX
};

struct native TCameraCache
{
    var float TimeStamp;
    var TPOV POV;

    structdefaultproperties
    {
        TimeStamp=0
        POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90)
    }
};

struct native TViewTarget
{
    /** Target Actor used to compute ideal POV */
    var() Actor Target;
    /** Controller of Target (only for non Locally controlled Pawns) */
    var() Controller Controller;
    /** Point of View */
    var() TPOV POV;
    /** Aspect ratio */
    var() float AspectRatio;
    /** PlayerReplicationInfo (used to follow same player through pawn transitions, etc., when spectating) */
    var() PlayerReplicationInfo PRI;

    structdefaultproperties
    {
        Target=none
        Controller=none
        POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90)
        AspectRatio=0
        PRI=none
    }
};

struct native ViewTargetTransitionParams
{
    /** Total duration of blend to pending view target.  0 means no blending. */
    var() float BlendTime;
    /** Function to apply to the blend parameter */
    var() Camera.EViewTargetBlendFunction BlendFunction;
    /** Exponent, used by certain blend functions to control the shape of the curve. */
    var() float BlendExp;
    /**  
     *If TRUE, lock outgoing viewtarget to last frame's camera position for the remainder of the blend.
     *         This is useful if you plan to teleport the viewtarget, but want to keep the camera motion smooth.
     */
    var() bool bLockOutgoing;

    structdefaultproperties
    {
        BlendTime=0
        BlendFunction=EViewTargetBlendFunction.VTBlend_Cubic
        BlendExp=2
        bLockOutgoing=false
    }
};

var PlayerController PCOwner;
var name CameraStyle;
var float DefaultFOV;
var bool bLockedFOV;
var bool bConstrainAspectRatio;
var bool bEnableFading;
var bool bFadeAudio;
var transient bool bForceDisableTemporalAA;
var bool bEnableColorScaling;
var bool bEnableColorScaleInterp;
var bool bUseClientSideCameraUpdates;
var bool bDebugClientSideCamera;
var bool bShouldSendClientSideCameraUpdate;
var float LockedFOV;
var float UnmodifiedFOV;
var float ConstrainedAspectRatio;
var float DefaultAspectRatio;
var float OffAxisYawAngle;
var float OffAxisPitchAngle;
var Color FadeColor;
var float FadeAmount;
var float CamOverridePostProcessAlpha;
var PostProcessSettings CamPostProcessSettings;
var RenderingPerformanceOverrides RenderingOverrides;
var Vector ColorScale;
var Vector DesiredColorScale;
var Vector OriginalColorScale;
var float ColorScaleInterpDuration;
var float ColorScaleInterpStartTime;
var TCameraCache CameraCache;
var TCameraCache LastFrameCameraCache;
var TViewTarget ViewTarget;
var TViewTarget PendingViewTarget;
var float BlendTimeToGo;
var ViewTargetTransitionParams BlendParams;
var array<CameraModifier> ModifierList;
var float FreeCamDistance;
var Vector FreeCamOffset;
var Vector2D FadeAlpha;
var float FadeTime;
var float FadeTimeRemaining;
var protected transient array<EmitterCameraLensEffectBase> CameraLensEffects;
/** Camera modifier for cone-driven screen shakes */
var() editinline transient CameraModifier_CameraShake CameraShakeCamMod;
/** Class to use when instantiating screenshake modifier object.  Provided to support overrides. */
var() protected class<CameraModifier_CameraShake> CameraShakeCamModClass;
var protected CameraAnimInst AnimInstPool[8];
var protected array<CameraAnimInst> ActiveAnims;
var protected array<CameraAnimInst> FreeAnims;
var protected transient DynamicCameraActor AnimCameraActor;

protected function CameraModifier CreateCameraModifier(class<CameraModifier> ModifierClass)
{
    local CameraModifier NewMod;

    NewMod = new (Outer) ModifierClass;
    NewMod.Init();
    NewMod.AddCameraModifier(self);
    return NewMod;
}

function PostBeginPlay()
{
    local int Idx;

    super.PostBeginPlay();
    if((CameraShakeCamMod == none) && CameraShakeCamModClass != none)
    {
        CameraShakeCamMod = CameraModifier_CameraShake(CreateCameraModifier(CameraShakeCamModClass));
    }
    Idx = 0;
    J0x5B:

    if(Idx < 8)
    {
        AnimInstPool[Idx] = new (self) Class'CameraAnimInst';
        FreeAnims[Idx] = AnimInstPool[Idx];
        ++ Idx;
        goto J0x5B;
    }
    AnimCameraActor = Spawn(Class'DynamicCameraActor', self,,,,, true);
}

event Destroyed()
{
    AnimCameraActor.Destroy();
    super.Destroyed();
}

// Export UCamera::execApplyCameraModifiers(FFrame&, void* const)
native function ApplyCameraModifiers(float DeltaTime, out TPOV OutPOV);

function InitializeFor(PlayerController PC)
{
    CameraCache.POV.FOV = DefaultFOV;
    PCOwner = PC;
    SetViewTarget(PC.ViewTarget);
    SetDesiredColorScale(WorldInfo.DefaultColorScale, 5);
    UpdateCamera(0);
}

function float GetFOVAngle()
{
    if(bLockedFOV)
    {
        return LockedFOV;
    }
    return CameraCache.POV.FOV;
}

function SetFOV(float NewFOV)
{
    if((NewFOV < float(1)) || NewFOV > float(170))
    {
        bLockedFOV = false;
        return;
    }
    bLockedFOV = true;
    LockedFOV = NewFOV;
}

function SetUnmodifiedFOV(float NewFOV)
{
    UnmodifiedFOV = NewFOV;
}

function float GetActualFOV()
{
    return GetFOVAngle();
}

final function GetCameraViewPoint(out Vector OutCamLoc, out Rotator OutCamRot)
{
    OutCamLoc = CameraCache.POV.Location;
    OutCamRot = CameraCache.POV.Rotation;
}

final function Rotator GetCameraRotation()
{
    return CameraCache.POV.Rotation;
}

simulated function SetDesiredColorScale(Vector NewColorScale, float InterpTime)
{
    if(!bEnableColorScaling)
    {
        bEnableColorScaling = true;
        ColorScale.X = 1;
        ColorScale.Y = 1;
        ColorScale.Z = 1;
    }
    if(NewColorScale != ColorScale)
    {
        OriginalColorScale = ColorScale;
        DesiredColorScale = NewColorScale;
        ColorScaleInterpStartTime = WorldInfo.TimeSeconds;
        ColorScaleInterpDuration = InterpTime;
        bEnableColorScaleInterp = true;
    }
}

simulated event UpdateCamera(float DeltaTime)
{
    if((PCOwner.IsLocalPlayerController() || !bUseClientSideCameraUpdates) || bDebugClientSideCamera)
    {
        DoUpdateCamera(DeltaTime);
        if((WorldInfo.NetMode == NM_Client) && bShouldSendClientSideCameraUpdate)
        {
            PCOwner.ServerUpdateCamera(CameraCache.POV.Location, (CameraCache.POV.Rotation.Pitch & 65535) + ((CameraCache.POV.Rotation.Yaw & 65535) << 16));
            bShouldSendClientSideCameraUpdate = false;
        }
    }
}

simulated function DoUpdateCamera(float DeltaTime)
{
    local TPOV NewPOV;
    local float DurationPct, BlendPct;

    if(bEnableColorScaleInterp)
    {
        BlendPct = FClamp((WorldInfo.TimeSeconds - ColorScaleInterpStartTime) / ColorScaleInterpDuration, 0, 1);
        ColorScale = VLerp(OriginalColorScale, DesiredColorScale, BlendPct);
        if(BlendPct == 1)
        {
            bEnableColorScaleInterp = false;
        }
    }
    bConstrainAspectRatio = false;
    CamOverridePostProcessAlpha = 0;
    if((PendingViewTarget.Target == none) || !BlendParams.bLockOutgoing)
    {
        CheckViewTarget(ViewTarget);
        UpdateViewTarget(ViewTarget, DeltaTime);
    }
    NewPOV = ViewTarget.POV;
    ConstrainedAspectRatio = ViewTarget.AspectRatio;
    if(PendingViewTarget.Target != none)
    {
        BlendTimeToGo -= DeltaTime;
        bConstrainAspectRatio = false;
        CheckViewTarget(PendingViewTarget);
        UpdateViewTarget(PendingViewTarget, DeltaTime);
        if(BlendTimeToGo > float(0))
        {
            DurationPct = (BlendParams.BlendTime - BlendTimeToGo) / BlendParams.BlendTime;
            switch(BlendParams.BlendFunction)
            {
                case 0:
                    BlendPct = Lerp(0, 1, DurationPct);
                    break;
                case 1:
                    BlendPct = FCubicInterp(0, 0, 1, 0, DurationPct);
                    break;
                case 2:
                    BlendPct = FInterpEaseIn(0, 1, DurationPct, BlendParams.BlendExp);
                    break;
                case 3:
                    BlendPct = FInterpEaseOut(0, 1, DurationPct, BlendParams.BlendExp);
                    break;
                case 4:
                    BlendPct = FInterpEaseInOut(0, 1, DurationPct, BlendParams.BlendExp);
                    break;
                default:
                    break;
            }
            NewPOV = BlendViewTargets(ViewTarget, PendingViewTarget, BlendPct);            
        }
        else
        {
            ViewTarget = PendingViewTarget;
            PendingViewTarget.Target = none;
            PendingViewTarget.Controller = none;
            BlendTimeToGo = 0;
            NewPOV = PendingViewTarget.POV;
        }
        if(bConstrainAspectRatio)
        {
            ConstrainedAspectRatio = PendingViewTarget.AspectRatio;
        }
    }
    FillCameraCache(NewPOV);
    if(bEnableFading && FadeTimeRemaining > 0)
    {
        FadeTimeRemaining = FMax(FadeTimeRemaining - DeltaTime, 0);
        if(FadeTime > 0)
        {
            FadeAmount = FadeAlpha.X + ((1 - (FadeTimeRemaining / FadeTime)) * (FadeAlpha.Y - FadeAlpha.X));
        }
        if(bFadeAudio)
        {
            ApplyAudioFade();
            if(FadeAmount == float(0))
            {
                bFadeAudio = false;
            }
        }
    }
}

// Export UCamera::execApplyAudioFade(FFrame&, void* const)
native function ApplyAudioFade();

final function TPOV BlendViewTargets(const out TViewTarget A, const out TViewTarget B, float Alpha)
{
    local TPOV POV;

    POV.Location = VLerp(A.POV.Location, B.POV.Location, Alpha);
    POV.FOV = Lerp(A.POV.FOV, B.POV.FOV, Alpha);
    POV.Rotation = RLerp(A.POV.Rotation, B.POV.Rotation, Alpha, true);
    return POV;
}

final function FillCameraCache(const out TPOV NewPOV)
{
    if(CameraCache.TimeStamp != WorldInfo.TimeSeconds)
    {
        LastFrameCameraCache = CameraCache;
    }
    CameraCache.TimeStamp = WorldInfo.TimeSeconds;
    CameraCache.POV = NewPOV;
}

// Export UCamera::execCheckViewTarget(FFrame&, void* const)
native function CheckViewTarget(out TViewTarget VT);

function UpdateViewTarget(out TViewTarget OutVT, float DeltaTime)
{
    local Vector Loc, pos, HitLocation, HitNormal;
    local Rotator Rot;
    local Actor HitActor;
    local CameraActor CamActor;
    local bool bDoNotApplyModifiers;
    local TPOV OrigPOV;
    local Pawn TPawn;

    if(((PendingViewTarget.Target != none) && OutVT == ViewTarget) && BlendParams.bLockOutgoing)
    {
        return;
    }
    OrigPOV = OutVT.POV;
    OutVT.POV.FOV = DefaultFOV;
    CamActor = CameraActor(OutVT.Target);
    if(CamActor != none)
    {
        CamActor.GetCameraView(DeltaTime, OutVT.POV);
        bConstrainAspectRatio = bConstrainAspectRatio || CamActor.bConstrainAspectRatio;
        OutVT.AspectRatio = CamActor.AspectRatio;
        CamOverridePostProcessAlpha = CamActor.CamOverridePostProcessAlpha;
        CamPostProcessSettings = CamActor.CamOverridePostProcess;        
    }
    else
    {
        TPawn = Pawn(OutVT.Target);
        if((TPawn == none) || !TPawn.CalcCamera(DeltaTime, OutVT.POV.Location, OutVT.POV.Rotation, OutVT.POV.FOV))
        {
            bDoNotApplyModifiers = true;
            switch(CameraStyle)
            {
                case 'Fixed':
                    OutVT.POV = OrigPOV;
                    break;
                case 'ThirdPerson':
                case 'FreeCam':
                case 'FreeCam_Default':
                    Loc = OutVT.Target.Location;
                    Rot = OutVT.Target.Rotation;
                    if((TPawn != none) && TPawn.Mesh != none)
                    {
                        Loc += ((TPawn.Mesh.Translation - TPawn.default.Mesh.Translation) >> OutVT.Target.Rotation);
                    }
                    if((CameraStyle == 'FreeCam') || CameraStyle == 'FreeCam_Default')
                    {
                        Rot = PCOwner.Rotation;
                    }
                    if(OutVT.Target != PCOwner)
                    {
                        Loc += (FreeCamOffset >> Rot);
                        pos = Loc - (vector(Rot) * FreeCamDistance);                        
                    }
                    else
                    {
                        pos = Loc;
                    }
                    HitActor = Trace(HitLocation, HitNormal, pos, Loc, false, vect(12, 12, 12));
                    OutVT.POV.Location = ((HitActor == none) ? pos : HitLocation);
                    OutVT.POV.Rotation = Rot;
                    break;
                case 'FirstPerson':
                default:
                    OutVT.Target.GetActorEyesViewPoint(OutVT.POV.Location, OutVT.POV.Rotation);
                    if((TPawn != none) && TPawn.Mesh != none)
                    {
                        OutVT.POV.Location += ((TPawn.Mesh.Translation - TPawn.default.Mesh.Translation) >> OutVT.Target.Rotation);
                    }
                    break;
                    break;
            }
        }
    }
    if(!bDoNotApplyModifiers)
    {
        ApplyCameraModifiers(DeltaTime, OutVT.POV);
    }
}

// Export UCamera::execSetViewTarget(FFrame&, void* const)
native final function SetViewTarget(Actor NewViewTarget, optional ViewTargetTransitionParams TransitionParams);

function ProcessViewRotation(float DeltaTime, out Rotator OutViewRotation, out Rotator OutDeltaRot)
{
    local int ModifierIdx;

    ModifierIdx = 0;
    J0x0B:

    if(ModifierIdx < ModifierList.Length)
    {
        if(ModifierList[ModifierIdx] != none)
        {
            if(ModifierList[ModifierIdx].ProcessViewRotation(ViewTarget.Target, DeltaTime, OutViewRotation, OutDeltaRot))
            {
                goto J0xB0;
            }
        }
        ++ ModifierIdx;
        goto J0x0B;
    }
    J0xB0:

}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Vector EyesLoc;
    local Rotator EyesRot;
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawText((("	Camera Style:" $ string(CameraStyle)) @ "main ViewTarget:") $ string(ViewTarget.Target));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText((((("   CamLoc:" $ string(CameraCache.POV.Location)) @ "CamRot:") $ string(CameraCache.POV.Rotation)) @ "FOV:") $ string(GetFOVAngle()));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText("   AspectRatio:" $ string(ConstrainedAspectRatio));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(ViewTarget.Target != none)
    {
        ViewTarget.Target.GetActorEyesViewPoint(EyesLoc, EyesRot);
        Canvas.DrawText((("   EyesLoc:" $ string(EyesLoc)) @ "EyesRot:") $ string(EyesRot));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
}

function EmitterCameraLensEffectBase FindCameraLensEffect(class<EmitterCameraLensEffectBase> LensEffectEmitterClass)
{
    local EmitterCameraLensEffectBase LensEffect;

    foreach CameraLensEffects(LensEffect,)
    {
        if(!LensEffect.bDeleteMe && ((LensEffect.Class == LensEffectEmitterClass) || LensEffect.EmittersToTreatAsSame.Find(LensEffectEmitterClass != -1) || LensEffectEmitterClass.default.EmittersToTreatAsSame.Find(LensEffect.Class != -1)
        {            
            return LensEffect;
        }        
    }    
    return none;
}

function AddCameraLensEffect(class<EmitterCameraLensEffectBase> LensEffectEmitterClass)
{
    local Vector CamLoc;
    local Rotator CamRot;
    local EmitterCameraLensEffectBase LensEffect;

    if(LensEffectEmitterClass != none)
    {
        if(!LensEffectEmitterClass.default.bAllowMultipleInstances)
        {
            LensEffect = FindCameraLensEffect(LensEffectEmitterClass);
            if(LensEffect != none)
            {
                LensEffect.NotifyRetriggered();
            }
        }
        if(LensEffect == none)
        {
            LensEffect = Spawn(LensEffectEmitterClass, PCOwner.GetViewTarget());
            if(LensEffect != none)
            {
                GetCameraViewPoint(CamLoc, CamRot);
                LensEffect.UpdateLocation(CamLoc, CamRot, GetActualFOV());
                LensEffect.RegisterCamera(self);
                CameraLensEffects.AddItem(LensEffect;
            }
        }
    }
}

function RemoveCameraLensEffect(EmitterCameraLensEffectBase Emitter)
{
    CameraLensEffects.RemoveItem(Emitter;
}

function ClearCameraLensEffects()
{
    local EmitterCameraLensEffectBase LensEffect;

    foreach CameraLensEffects(LensEffect,)
    {
        LensEffect.Destroy();        
    }    
    CameraLensEffects.Length = 0;
}

function PlayCameraShake(CameraShake Shake, float Scale, optional Camera.ECameraAnimPlaySpace PlaySpace, optional Rotator UserPlaySpaceRot)
{
    PlaySpace = 0;    
    if(Shake != none)
    {
        CameraShakeCamMod.AddCameraShake(Shake, Scale, PlaySpace, UserPlaySpaceRot);
    }
}

function StopCameraShake(CameraShake Shake)
{
    if(Shake != none)
    {
        CameraShakeCamMod.RemoveCameraShake(Shake);
    }
}

static function float CalcRadialShakeScale(Camera Cam, Vector Epicenter, float InnerRadius, float OuterRadius, float Falloff)
{
    local Vector POVLoc;
    local float DistPct;

    POVLoc = Cam.Location;
    if(InnerRadius < OuterRadius)
    {
        DistPct = (VSize(Epicenter - POVLoc) - InnerRadius) / (OuterRadius - InnerRadius);
        DistPct = 1 - FClamp(DistPct, 0, 1);
        return DistPct ** Falloff;        
    }
    else
    {
        return ((VSize(Epicenter - POVLoc) < InnerRadius) ? 1 : 0);
    }
}

static function PlayWorldCameraShake(CameraShake Shake, Actor ShakeInstigator, Vector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bTryForceFeedback, optional bool bOrientShakeTowardsEpicenter)
{
    local PlayerController PC;
    local float ShakeScale;
    local Rotator CamRot;
    local Vector CamLoc;

    if(ShakeInstigator != none)
    {
        foreach ShakeInstigator.LocalPlayerControllers(Class'PlayerController', PC)
        {
            if(PC.PlayerCamera != none)
            {
                ShakeScale = CalcRadialShakeScale(PC.PlayerCamera, Epicenter, InnerRadius, OuterRadius, Falloff);
                if(bOrientShakeTowardsEpicenter && PC.Pawn != none)
                {
                    PC.PlayerCamera.GetCameraViewPoint(CamLoc, CamRot);
                    PC.ClientPlayCameraShake(Shake, ShakeScale, bTryForceFeedback, 2, rotator(Epicenter - CamLoc));
                    continue;
                }
                PC.ClientPlayCameraShake(Shake, ShakeScale, bTryForceFeedback);
            }            
        }        
    }
}

function ClearAllCameraShakes()
{
    CameraShakeCamMod.RemoveAllCameraShakes();
}

// Export UCamera::execPlayCameraAnim(FFrame&, void* const)
native simulated function CameraAnimInst PlayCameraAnim(CameraAnim Anim, optional float Rate, optional float Scale, optional float BlendInTime, optional float BlendOutTime, optional bool bLoop, optional bool bRandomStartTime, optional float Duration, optional bool bSingleInstance)
{
    Rate = 1;
    Scale = 1;                                                                    
}

// Export UCamera::execStopAllCameraAnims(FFrame&, void* const)
native simulated function StopAllCameraAnims(optional bool bImmediate);

// Export UCamera::execStopAllCameraAnimsByType(FFrame&, void* const)
native simulated function StopAllCameraAnimsByType(CameraAnim Anim, optional bool bImmediate);

// Export UCamera::execStopCameraAnim(FFrame&, void* const)
native simulated function StopCameraAnim(CameraAnimInst AnimInst, optional bool bImmediate);

defaultproperties
{
    DefaultFOV=90
    bUseClientSideCameraUpdates=true
    DefaultAspectRatio=1.33333
    CamPostProcessSettings=(bOverride_EnableBloom=false,bOverride_EnableDOF=false,bOverride_EnableMotionBlur=false,bOverride_EnableSceneEffect=false,bOverride_AllowAmbientOcclusion=false,bOverride_OverrideRimShaderColor=false,bOverride_EnableDistanceFog=false,bOverride_Bloom_Scale=true,bOverride_Bloom_Threshold=true,bOverride_Bloom_Tint=true,bOverride_Bloom_ScreenBlendThreshold=true,bOverride_Bloom_InterpolationDuration=true,bOverride_DOF_FalloffExponent=true,bOverride_DOF_BlurKernelSize=true,bOverride_DOF_BlurBloomKernelSize=true,bOverride_DOF_MaxNearBlurAmount=true,bOverride_DOF_MinBlurAmount=false,bOverride_DOF_MaxFarBlurAmount=true,bOverride_DOF_FocusType=true,bOverride_DOF_FocusInnerRadius=true,bOverride_DOF_FocusDistance=true,bOverride_DOF_FocusPosition=true,bOverride_DOF_InterpolationDuration=true,bOverride_DOF_BokehTexture=false,bOverride_MotionBlur_MaxVelocity=false,bOverride_MotionBlur_Amount=false,bOverride_MotionBlur_FullMotionBlur=false,bOverride_MotionBlur_CameraRotationThreshold=false,bOverride_MotionBlur_CameraTranslationThreshold=false,bOverride_MotionBlur_InterpolationDuration=false,bOverride_Scene_Desaturation=true,bOverride_Scene_Colorize=false,bOverride_Scene_TonemapperScale=false,bOverride_Scene_ImageGrainScale=false,bOverride_Scene_HighLights=true,bOverride_Scene_MidTones=true,bOverride_Scene_Shadows=true,bOverride_Scene_InterpolationDuration=true,bOverride_Scene_ColorGradingLUT=false,bOverride_RimShader_Color=true,bOverride_RimShader_InterpolationDuration=true,bOverride_MobileColorGrading=false,bEnableBloom=true,bEnableDOF=false,bEnableMotionBlur=true,bEnableSceneEffect=true,bAllowAmbientOcclusion=true,bOverrideRimShaderColor=false,bEnableDistanceFog=false,TripwireSettings=(bOverride_DOF_FocalDistance=false,DOF_FocalDistance=1000,bOverride_DOF_SharpRadius=false,DOF_SharpRadius=800,bOverride_DOF_FocalRadius=false,DOF_FocalRadius=1200,bOverride_DOF_MinBlurSize=false,DOF_MinBlurSize=0,bOverride_DOF_MaxNearBlurSize=false,DOF_MaxNearBlurSize=0,bOverride_DOF_MaxFarBlurSize=false,DOF_MaxFarBlurSize=0,bOverride_DOF_ExpFalloff=false,DOF_ExpFalloff=1,DOF_FG_SharpRadius=75,DOF_FG_FocalRadius=150,DOF_FG_MinBlurSize=0,DOF_FG_MaxNearBlurSize=0,DOF_FG_ExpFalloff=1,bOverride_Bloom_Intensity=false,Bloom_Intensity=1.05,bOverride_Bloom_Width=false,Bloom_Width=4,bOverride_Bloom_Exposure=false,Bloom_Exposure=1.25,bOverride_Bloom_Threshold=false,Bloom_Threshold=0.6,Bloom_InterpolationDuration=1,NoiseIntensity=1,bOverride_Fog_Start_Distance=false,Fog_Start_Distance=0,bOverride_Fog_MaxStrength_Distance=false,Fog_MaxStrength_Distance=10000,bOverride_Fog_AnimationCutoff_Distance=false,Fog_AnimationCutoff_Distance=8000,bOverride_Fog_Intensity=false,Fog_Intensity=0.3,bOverride_Fog_MinAmount=false,Fog_MinAmount=0.1,bOverride_Fog_Color=false,Fog_Color=(R=1,G=1,B=1,A=1),Fog_InterpolationDuration=3,MB_TileMaxEnabled=true,bForceGameplayDOF=false,bForceGameplayBloom=false,bForceGameplayImageGrain=false,bForceGameplayTranslucencyTint=false,bEnableScreenSpaceReflections=true,bBlurEnabled=false,BlurStrength=0),LegacySettings=(Bloom_Scale=1,Bloom_Threshold=1,Bloom_InterpolationDuration=1,DOF_BlurBloomKernelSize=16,DOF_FalloffExponent=4,DOF_BlurKernelSize=16,DOF_MaxNearBlurAmount=1,DOF_MinBlurAmount=0,DOF_MaxFarBlurAmount=1,DOF_FocusType=EFocusType.FOCUS_Distance,DOF_FocusInnerRadius=2000,DOF_FocusDistance=0,DOF_FocusPosition=(X=0,Y=0,Z=0),DOF_InterpolationDuration=1,DOF_BokehTexture=none,MotionBlur_MaxVelocity=1,MotionBlur_Amount=0.5,MotionBlur_FullMotionBlur=true,MotionBlur_CameraRotationThreshold=45,MotionBlur_CameraTranslationThreshold=10000,MotionBlur_InterpolationDuration=1,RimShader_Color=(R=0.47044,G=0.585973,B=0.827726,A=1),RimShader_InterpolationDuration=1,Scene_ImageGrainScale=0,MobileColorGrading=(TransitionTime=1,Blend=0,Desaturation=0,HighLights=(R=0.7,G=0.7,B=0.7,A=1),MidTones=(R=0,G=0,B=0,A=1),Shadows=(R=0,G=0,B=0,A=1)),MobilePostProcess=(bOverride_Mobile_BlurAmount=false,bOverride_Mobile_TransitionTime=false,bOverride_Mobile_Bloom_Scale=false,bOverride_Mobile_Bloom_Threshold=false,bOverride_Mobile_Bloom_Tint=false,bOverride_Mobile_DOF_Distance=false,bOverride_Mobile_DOF_MinRange=false,bOverride_Mobile_DOF_MaxRange=false,bOverride_Mobile_DOF_NearBlurFactor=false,bOverride_Mobile_DOF_FarBlurFactor=false,Mobile_BlurAmount=16,Mobile_TransitionTime=1,Mobile_Bloom_Scale=0.5,Mobile_Bloom_Threshold=0.75,Mobile_Bloom_Tint=(R=1,G=1,B=1,A=1),Mobile_DOF_Distance=1500,Mobile_DOF_MinRange=600,Mobile_DOF_MaxRange=1200,Mobile_DOF_NearBlurFactor=1,Mobile_DOF_FarBlurFactor=1)),Bloom_Tint=(B=255,G=255,R=255,A=0),Bloom_ScreenBlendThreshold=10,Scene_Desaturation=0,Scene_Colorize=(X=1,Y=1,Z=1),Scene_TonemapperScale=1,Scene_HighLights=(X=1,Y=1,Z=1),Scene_MidTones=(X=1,Y=1,Z=1),Scene_Shadows=(X=0,Y=0,Z=0),Scene_InterpolationDuration=0,ColorGrading_LookupTable=none,ColorGradingLUT=(LUTTextures=none,LUTWeights=none))
    RenderingOverrides=(bAllowAmbientOcclusion=true,bAllowDominantWholeSceneDynamicShadows=true,bAllowMotionBlurSkinning=true,bAllowTemporalAA=true,bAllowLightShafts=true)
    CameraCache=(TimeStamp=0,POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90))
    LastFrameCameraCache=(TimeStamp=0,POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90))
    ViewTarget=(Target=none,Controller=none,POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90),AspectRatio=0,PRI=none)
    PendingViewTarget=(Target=none,Controller=none,POV=(Location=(X=0,Y=0,Z=0),Rotation=(Pitch=0,Yaw=0,Roll=0),FOV=90),AspectRatio=0,PRI=none)
    BlendParams=(BlendTime=0,BlendFunction=EViewTargetBlendFunction.VTBlend_Cubic,BlendExp=2,bLockOutgoing=false)
    FreeCamDistance=256
    CameraShakeCamModClass=Class'CameraModifier_CameraShake'
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bHidden=true
}