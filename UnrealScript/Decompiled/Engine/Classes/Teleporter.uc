/*******************************************************************************
 * Teleporter generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Teleporter extends NavigationPoint
    native
    placeable
    hidecategories(Navigation,Lighting,LightColor,Force);

/** ----------------------------------------------------------------------------- Teleporter URL can be one of the following forms: TeleporterName            Teleports to a named teleporter in this level.          if none, acts only as a teleporter destination LevelName/TeleporterName     Teleports to a different level on this server. Unreal:Server.domain.com/LevelName/TeleporterName     Teleports to a different server on the net. */
var() string URL;
/** ----------------------------------------------------------------------------- Product the user must have installed in order to enter the teleporter. */
var() name ProductRequired;
/** ----------------------------------------------------------------------------- Teleporter destination flags. */
var() bool bChangesVelocity;
/** Sets yaw to teleporter's Rotation.Yaw */
var() bool bChangesYaw;
/** Reverses X-component of velocity. */
var() bool bReversesX;
/** Reverses Y-component of velocity. */
var() bool bReversesY;
/** Reverses Z-component of velocity. Teleporter flags */
var() bool bReversesZ;
/** whether this Teleporter works on vehicles */
var() bool bEnabled;
var() bool bCanTeleportVehicles;
/** ----------------------------------------------------------------------------- Teleporter destination directions. */
var() Vector TargetVelocity;
var float LastFired;

replication
{
     if(Role == ROLE_Authority)
        URL, bEnabled;

     if(bNetInitial && Role == ROLE_Authority)
        TargetVelocity, bChangesVelocity, 
        bChangesYaw, bReversesX, 
        bReversesY, bReversesZ;
}

// Export UTeleporter::execCanTeleport(FFrame&, void* const)
native function bool CanTeleport(Actor A);

event PostBeginPlay()
{
    if(URL ~= "")
    {
        SetCollision(false, false);
    }
    super(Actor).PostBeginPlay();
}

simulated event bool Accept(Actor Incoming, Actor Source)
{
    local Rotator NewRot, oldRot;
    local float Mag;
    local Vector oldDir;
    local Controller C;

    if(Incoming == none)
    {
        return false;
    }
    Disable('Touch');
    NewRot = Incoming.Rotation;
    if(bChangesYaw)
    {
        oldRot = Incoming.Rotation;
        NewRot.Yaw = Rotation.Yaw;
        if(Source != none)
        {
            NewRot.Yaw += ((32768 + Incoming.Rotation.Yaw) - Source.Rotation.Yaw);
        }
    }
    if(Pawn(Incoming) != none)
    {
        if(Role == ROLE_Authority)
        {
            foreach WorldInfo.AllControllers(Class'Controller', C)
            {
                if(C.Enemy == Incoming)
                {
                    C.EnemyJustTeleported();
                }                
            }            
        }
        if(!Pawn(Incoming).SetLocation(Location))
        {
            LogInternal((string(self) $ " Teleport failed for ") $ string(Incoming));
            return false;
        }
        if((Role == ROLE_Authority) || (WorldInfo.TimeSeconds - LastFired) > 0.5)
        {
            NewRot.Roll = 0;
            Pawn(Incoming).SetRotation(NewRot);
            Pawn(Incoming).SetViewRotation(NewRot);
            Pawn(Incoming).ClientSetRotation(NewRot);
            LastFired = WorldInfo.TimeSeconds;
        }
        if(Pawn(Incoming).Controller != none)
        {
            Pawn(Incoming).Controller.MoveTimer = -1;
            Pawn(Incoming).SetAnchor(self);
            Pawn(Incoming).SetMoveTarget(self);
        }
        Incoming.PlayTeleportEffect(false, true);        
    }
    else
    {
        if(!Incoming.SetLocation(Location))
        {
            Enable('Touch');
            return false;
        }
        if(bChangesYaw)
        {
            Incoming.SetRotation(NewRot);
        }
    }
    Enable('Touch');
    if(bChangesVelocity)
    {
        Incoming.Velocity = TargetVelocity;        
    }
    else
    {
        if(bChangesYaw)
        {
            if(Incoming.Physics == 1)
            {
                oldRot.Pitch = 0;
            }
            oldDir = vector(oldRot);
            Mag = Incoming.Velocity Dot oldDir;
            Incoming.Velocity = (Incoming.Velocity - (Mag * oldDir)) + (Mag * vector(Incoming.Rotation));
        }
        if(bReversesX)
        {
            Incoming.Velocity.X *= -1;
        }
        if(bReversesY)
        {
            Incoming.Velocity.Y *= -1;
        }
        if(bReversesZ)
        {
            Incoming.Velocity.Z *= -1;
        }
    }
    Incoming.PostTeleport(self);
    return true;
}

event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    if(!bEnabled || Other == none)
    {
        return;
    }
    if((CanTeleport(Other)) && !Other.PreTeleport(self))
    {
        PendingTouch = Other.PendingTouch;
        Other.PendingTouch = self;
    }
}

simulated event PostTouch(Actor Other)
{
    local Teleporter D, Dest;
    local int I;

    if((InStr(URL, "/") >= 0) || InStr(URL, "#") >= 0)
    {
        if(((Role == ROLE_Authority) && Pawn(Other) != none) && Pawn(Other).IsHumanControlled())
        {
            WorldInfo.Game.SendPlayer(PlayerController(Pawn(Other).Controller), URL);
        }        
    }
    else
    {
        foreach AllActors(Class'Teleporter', D)
        {
            if((string(D.Tag) ~= URL) && D != self)
            {
                Dest[I] = D;
                ++ I;
                if(I > 16)
                {
                    break;
                }
            }            
        }        
        I = Rand(I);
        if(Dest[I] != none)
        {
            if(Other.IsA('Pawn'))
            {
                Other.PlayTeleportEffect(true, true);
            }
            Dest[I].Accept(Other, self);
        }
    }
}

event Actor SpecialHandling(Pawn Other)
{
    if(((bEnabled && Other.Controller.RouteCache.Length > 1) && Teleporter(Other.Controller.RouteCache[1]) != none) && string(Other.Controller.RouteCache[1].Tag) ~= URL)
    {
        if(IsOverlapping(Other))
        {
            PostTouch(Other);
        }
        return self;
    }
    return none;
}

defaultproperties
{
    bChangesYaw=true
    bEnabled=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_Teleport'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_Teleport'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__Teleporter.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__Teleporter.PathRenderer'
    Components(4)=PathRenderer
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_TouchAll
    bCollideActors=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80
        CollisionRadius=40
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}