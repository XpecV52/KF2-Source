/*******************************************************************************
 * LadderVolume generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class LadderVolume extends PhysicsVolume
    native
    placeable
    hidecategories(Navigation,Object,Movement,Display);

var() Rotator WallDir;
var Vector LookDir;
var Vector ClimbDir;
var const Ladder LadderList;
/** if true, won't push into/keep player against geometry in lookdir */
var() bool bNoPhysicalLadder;
/** add top and bottom ladders automatically */
var() bool bAutoPath;
/** if true, players on ladder can strafe sideways */
var() bool bAllowLadderStrafing;
var Pawn PendingClimber;
var export editinline ArrowComponent WallDirArrow;

simulated event PostBeginPlay()
{
    local Ladder L, M;
    local Vector Dir;

    super.PostBeginPlay();
    LookDir = vector(WallDir);
    if(!bAutoPath && LookDir.Z != float(0))
    {
        ClimbDir = vect(0, 0, 1);
        L = LadderList;
        J0x7E:

        if(L != none)
        {
            M = LadderList;
            J0xA0:

            if(M != none)
            {
                if(M != L)
                {
                    Dir = Normal(M.Location - L.Location);
                    if((Dir Dot ClimbDir) < float(0))
                    {
                        Dir *= float(-1);
                    }
                    ClimbDir += Dir;
                }
                M = M.LadderList;
                goto J0xA0;
            }
            L = L.LadderList;
            goto J0x7E;
        }
        ClimbDir = Normal(ClimbDir);
        if((ClimbDir Dot vect(0, 0, 1)) < float(0))
        {
            ClimbDir *= float(-1);
        }
    }
}

function bool InUse(Pawn Ignored)
{
    local Pawn StillClimbing;

    foreach TouchingActors(Class'Pawn', StillClimbing)
    {
        if(((StillClimbing != Ignored) && StillClimbing.bCollideActors) && StillClimbing.bBlockActors)
        {            
            return true;
        }        
    }    
    if(PendingClimber != none)
    {
        if(((((PendingClimber.Controller == none) || !PendingClimber.bCollideActors) || !PendingClimber.bBlockActors) || Ladder(PendingClimber.Controller.MoveTarget) == none) || Ladder(PendingClimber.Controller.MoveTarget).MyLadder != self)
        {
            PendingClimber = none;
        }
    }
    return (PendingClimber != none) && PendingClimber != Ignored;
}

simulated event PawnEnteredVolume(Pawn P)
{
    local Rotator PawnRot;

    super.PawnEnteredVolume(P);
    if(!P.CanGrabLadder())
    {
        return;
    }
    PawnRot = P.Rotation;
    PawnRot.Pitch = 0;
    if(((vector(PawnRot) Dot LookDir) > 0.9) || (AIController(P.Controller) != none) && Ladder(P.Controller.MoveTarget) != none)
    {
        P.ClimbLadder(self);        
    }
    else
    {
        if(!P.bDeleteMe && P.Controller != none)
        {
            Spawn(Class'PotentialClimbWatcher', P);
        }
    }
}

simulated event PawnLeavingVolume(Pawn P)
{
    local Controller C;

    if(P.OnLadder != self)
    {
        return;
    }
    super.PawnLeavingVolume(P);
    P.OnLadder = none;
    P.EndClimbLadder(self);
    if(P == PendingClimber)
    {
        PendingClimber = none;
    }
    if(!InUse(P))
    {
        foreach WorldInfo.AllControllers(Class'Controller', C)
        {
            if((C.bPreparingMove && Ladder(C.MoveTarget) != none) && Ladder(C.MoveTarget).MyLadder == self)
            {
                C.bPreparingMove = false;
                PendingClimber = C.Pawn;                
                return;
            }            
        }        
    }
}

simulated event PhysicsChangedFor(Actor Other)
{
    if(((((Other.Physics == 2) || Other.Physics == 9) || Other.bDeleteMe) || Pawn(Other) == none) || Pawn(Other).Controller == none)
    {
        return;
    }
    Spawn(Class'PotentialClimbWatcher', Other);
}

defaultproperties
{
    ClimbDir=(X=0,Y=0,Z=1)
    bAutoPath=true
    bAllowLadderStrafing=true
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(B=150,G=100,R=150,A=255)
        ArrowSize=5
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__LadderVolume.Arrow'
    WallDirArrow=Arrow
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    BrushComponent=BrushComponent0
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    Components(0)=BrushComponent0
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(B=150,G=100,R=150,A=255)
        ArrowSize=5
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__LadderVolume.Arrow'
    Components(1)=Arrow
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    CollisionComponent=BrushComponent0
}