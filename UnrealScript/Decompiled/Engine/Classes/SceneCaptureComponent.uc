/*******************************************************************************
 * SceneCaptureComponent generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SceneCaptureComponent extends ActorComponent
    abstract
    native
    hidecategories(Object);

enum ESceneCaptureViewMode
{
    SceneCapView_Lit,
    SceneCapView_Unlit,
    SceneCapView_LitNoShadows,
    SceneCapView_Wire,
    SceneCapView_MAX
};

/** Turn the scene capture on/off */
var(Capture) bool bEnabled;
/** toggle scene post-processing */
var(Capture) bool bEnablePostProcess;
/** toggle fog */
var(Capture) bool bEnableFog;
/** If TRUE then use the main scene's post process settings when capturing */
var(Capture) bool bUseMainScenePostProcessSettings;
/** if true, skip updating the scene capture if the users of the texture have not been rendered recently */
var(Capture) bool bSkipUpdateIfTextureUsersOccluded;
/** if true, skip updating the scene capture if the Owner of the component has not been rendered recently */
var(Capture) bool bSkipUpdateIfOwnerOccluded;
/**  
 *if true, skip the depth prepass when rendering the scene capture.
 *    The prepass CPU cost is not worth the GPU savings when the scene capture is small.
 */
var(Capture) bool bSkipRenderingDepthPrepass;
/** background color */
var(Capture) Color ClearColor;
/** how to draw the scene */
var(Capture) SceneCaptureComponent.ESceneCaptureViewMode ViewMode;
/** NOT IMPLEMENTED! level-of-detail setting */
var(Capture) int SceneLOD;
/**  
 *rate to capture the scene,
 * TimeBetweenCaptures = Max( 1/FrameRate, DeltaTime),
 * if the FrameRate is 0 then the scene is captured only once
 */
var(Capture) const float FrameRate;
/** Chain of post process effects for this post process view */
var(Capture) PostProcessChain PostProcess;
/** if > 0, skip updating the scene capture if the Owner is further than this many units away from the viewer */
var(Capture) float MaxUpdateDist;
/**  
 *if > 0, sets a maximum render distance override.  Can be used to cull distant objects from a reflection if
 *   the reflecting plane is in an enclosed area like a hallway or room
 */
var(Capture) float MaxViewDistanceOverride;
/**  
 *if > 0, skip streaming texture updates for the scene capture if the Owner is further than this many units away from the viewer.
 * if == 0, then view information for this scene capture is not used by texture streaming manager for updates.
 */
var(Capture) float MaxStreamingUpdateDist;
var private native const transient Pointer CaptureInfo;
var private native const transient Pointer ViewState;
var noimport duplicatetransient native const transient array<Pointer> PostProcessProxies;

// Export USceneCaptureComponent::execSetFrameRate(FFrame&, void* const)
native final function SetFrameRate(float NewFrameRate);

// Export USceneCaptureComponent::execSetEnabled(FFrame&, void* const)
native final simulated function SetEnabled(bool bEnable);

defaultproperties
{
    bEnabled=true
    bSkipRenderingDepthPrepass=true
    ClearColor=(B=0,G=0,R=0,A=255)
    ViewMode=ESceneCaptureViewMode.SceneCapView_LitNoShadows
    FrameRate=30
}