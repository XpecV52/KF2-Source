/*******************************************************************************
 * UIRoot generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class UIRoot extends Object
    abstract
    native(UserInterface)
    config(Engine)
    hidecategories(Object,UIRoot);

const DEFAULT_SIZE_X = 1024;
const DEFAULT_SIZE_Y = 768;
const MAX_SUPPORTED_GAMEPADS = 24;

enum EInputPlatformType
{
    IPT_PC,
    IPT_360,
    IPT_PS3,
    IPT_MAX
};

struct native UIRangeData
{
    /** the current value of this UIRange */
    var(Range) float CurrentValue;
    /** The minimum value for this UIRange.  The value of this UIRange must be greater than or equal to this value. */
    var(Range) float MinValue;
    /** The maximum value for this UIRange.  The value of this UIRange must be less than or equal to this value. */
    var(Range) float MaxValue;
    /**  
     *Controls the amount to increment or decrement this UIRange's value when used by widgets that support "nudging".
     *        If NudgeValue is zero, reported NudgeValue will be 1% of MaxValue - MinValue.
     */
    var(Range) float NudgeValue;
    /** Indicates whether the values in this UIRange should be treated as ints. */
    var(Range) bool bIntRange;

    structdefaultproperties
    {
        CurrentValue=0
        MinValue=0
        MaxValue=0
        NudgeValue=0
        bIntRange=false
    }
};

struct native TextureCoordinates
{
    /** Coordinates for mapping an individual texture of a texture atlas */
    var() float U;
    /** Coordinates for mapping an individual texture of a texture atlas */
    var() float V;
    /** Coordinates for mapping an individual texture of a texture atlas */
    var() float UL;
    /** Coordinates for mapping an individual texture of a texture atlas */
    var() float VL;

    structdefaultproperties
    {
        U=0
        V=0
        UL=0
        VL=0
    }
};

struct native InputKeyAction
{
    /** the input key name that will activate the action */
    var() name InputKeyName;
    /** the state (pressed, released, etc.) that will activate the action */
    var() Core.Object.EInputEvent InputKeyState;
    var array<SeqOpOutputInputLink> TriggeredOps;
    var deprecated array<deprecated SequenceOp> ActionsToExecute;

    structdefaultproperties
    {
        InputKeyName=None
        InputKeyState=EInputEvent.IE_Released
        TriggeredOps=none
    }
};

struct native transient InputEventParameters
{
    var init const transient int PlayerIndex;
    var init const transient int ControllerId;
    var init const transient name InputKeyName;
    var init const transient Core.Object.EInputEvent EventType;
    var init const transient float InputDelta;
    var init const transient float DeltaTime;
    var init const transient bool bAltPressed;
    var init const transient bool bCtrlPressed;
    var init const transient bool bShiftPressed;

    structdefaultproperties
    {
        PlayerIndex=0
        ControllerId=0
        InputKeyName=None
        EventType=EInputEvent.IE_Pressed
        InputDelta=0
        DeltaTime=0
        bAltPressed=false
        bCtrlPressed=false
        bShiftPressed=false
    }
};

struct native transient SubscribedInputEventParameters extends InputEventParameters
{
    var init const transient name InputAliasName;
};

struct native UIAxisEmulationDefinition
{
    var name AxisInputKey;
    var name AdjacentAxisInputKey;
    var bool bEmulateButtonPress;
    var name InputKeyToEmulate[2];

    structdefaultproperties
    {
        AxisInputKey=None
        AdjacentAxisInputKey=None
        bEmulateButtonPress=false
        InputKeyToEmulate[0]=None
        InputKeyToEmulate[1]=None
    }
};

struct native export RawInputKeyEventData
{
    var name InputKeyName;
    var byte ModifierKeyFlags;

    structdefaultproperties
    {
        InputKeyName=None
        ModifierKeyFlags=56
    }
};

var config array<config string> BadCapsLocContexts;

// Export UUIRoot::execGetInputPlatformType(FFrame&, void* const)
native static final function UIRoot.EInputPlatformType GetInputPlatformType(optional LocalPlayer OwningPlayer);

// Export UUIRoot::execGetCurrentUIController(FFrame&, void* const)
native static final function UIInteraction GetCurrentUIController();

// Export UUIRoot::execGetSceneClient(FFrame&, void* const)
native static final function GameUISceneClient GetSceneClient();

static final function UIDataStore StaticResolveDataStore(name DataStoreTag, optional LocalPlayer InPlayerOwner)
{
    local UIDataStore Result;
    local DataStoreClient DSClient;

    DSClient = Class'UIInteraction'.static.GetDataStoreClient();
    if(DSClient != none)
    {
        Result = DSClient.FindDataStore(DataStoreTag, InPlayerOwner);
    }
    return Result;
}

static final function OnlineGameInterface GetOnlineGameInterface()
{
    local OnlineSubsystem OnlineSub;
    local OnlineGameInterface Result;

    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        Result = OnlineSub.GameInterface;        
    }
    else
    {
        LogInternal("GetOnlinePlayerInterfaceEx: Unable to find OnlineSubSystem!");
    }
    return Result;
}

static final function OnlinePlayerInterface GetOnlinePlayerInterface()
{
    local OnlineSubsystem OnlineSub;
    local OnlinePlayerInterface Result;

    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        Result = OnlineSub.PlayerInterface;        
    }
    else
    {
        LogInternal("GetOnlinePlayerInterfaceEx: Unable to find OnlineSubSystem!");
    }
    return Result;
}

static final function OnlinePlayerInterfaceEx GetOnlinePlayerInterfaceEx()
{
    local OnlineSubsystem OnlineSub;
    local OnlinePlayerInterfaceEx PlayerIntEx;

    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        PlayerIntEx = OnlineSub.PlayerInterfaceEx;        
    }
    else
    {
        LogInternal("GetOnlinePlayerInterfaceEx: Unable to find OnlineSubSystem!");
    }
    return PlayerIntEx;
}

static final function string SafeCaps(string StringToCap)
{
    if(default.BadCapsLocContexts.Find(GetLanguage() != -1)
    {
        return StringToCap;
    }
    return Caps(StringToCap);
}
