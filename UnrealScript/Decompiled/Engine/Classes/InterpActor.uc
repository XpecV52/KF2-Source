/*******************************************************************************
 * InterpActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class InterpActor extends DynamicSMActor
    native
    placeable
    hidecategories(Navigation)
    classgroup(Common);

struct CheckpointRecord
{
    var Vector Location;
    var Rotator Rotation;
    var Actor.ECollisionType CollisionType;
    var bool bHidden;
    var bool bIsShutdown;
    var bool bNeedsPositionReplication;

    structdefaultproperties
    {
        Location=(X=0,Y=0,Z=0)
        Rotation=(Pitch=0,Yaw=0,Roll=0)
        CollisionType=ECollisionType.COLLIDE_CustomDefault
        bHidden=false
        bIsShutdown=false
        bNeedsPositionReplication=false
    }
};

var bool bShouldSaveForCheckpoint;
var bool bMonitorMover;
var bool bMonitorZVelocity;
/** if set this mover blows up projectiles when it encroaches them */
var() bool bDestroyProjectilesOnEncroach;
/** if set, this mover keeps going if it encroaches an Actor in PHYS_RigidBody. */
var() bool bContinueOnEncroachPhysicsObject;
/** true by default, prevents mover from completing the movement that would leave it encroaching another actor */
var() bool bStopOnEncroach;
/**  
 *This is used for having the Actor ShadowParent all of the components that are "SetBased" onto it.  This allows LDs to
 * take InterpActors in the level and then SetBase a ton of other meshes to them and not incur multiple shadow casters.
 */
var() bool bShouldShadowParentAllAttachedActors;
var bool bIsLift;
var NavigationPoint MyMarker;
var float MaxZVelocity;
var float StayOpenTime;
/** sound played when the mover is interpolated forward */
var() SoundCue OpenSound;
/** looping sound while opening */
var() SoundCue OpeningAmbientSound;
/** sound played when mover finished moving forward */
var() SoundCue OpenedSound;
/** sound played when the mover is interpolated in reverse */
var() SoundCue CloseSound;
/** looping sound while closing */
var() SoundCue ClosingAmbientSound;
/** sound played when mover finished moving backward */
var() SoundCue ClosedSound;
var export editinline AudioComponent AmbientSoundComponent;

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    if(bShouldShadowParentAllAttachedActors)
    {
        SetShadowParentOnAllAttachedComponents(StaticMeshComponent, LightEnvironment);
    }
    if((OpeningAmbientSound != none) || ClosingAmbientSound != none)
    {
        AmbientSoundComponent = new (self) Class'AudioComponent';
        AttachComponent(AmbientSoundComponent);
    }
    if((Base != none) && bHardAttach || (BaseSkelComponent != none) && BaseBoneName != 'None')
    {
        bShouldSaveForCheckpoint = false;
    }
}

event bool EncroachingOn(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;
    local Pawn P;
    local Vector Height, HitLocation, HitNormal;
    local bool bLandingPawn;

    if(bContinueOnEncroachPhysicsObject && Other.Physics == 10)
    {
        return false;
    }
    if(Other.bDestroyedByInterpActor)
    {
        Other.Destroy();
        return false;
    }
    if((Other.Base == self) || (Normal(Velocity) Dot Normal(Other.Location - Location)) >= 0)
    {
        P = Pawn(Other);
        if(P != none)
        {
            if((P.Physics == 2) && Velocity.Z > 0)
            {
                Height = P.GetCollisionHeight() * vect(0, 0, 1);
                if(TraceComponent(HitLocation, HitNormal, StaticMeshComponent, P.Location - Height, P.Location + Height, P.GetCollisionExtent()))
                {
                    if(P.Location.Z < Location.Z)
                    {
                        P.SetLocation(HitLocation + Height);
                    }
                    bLandingPawn = true;
                }                
            }
            else
            {
                if((((P.Base != self) && P.Controller != none) && P.Controller.PendingMover != none) && P.Controller.PendingMover == self)
                {
                    P.Controller.UnderLift(LiftCenter(MyMarker));
                }
            }            
        }
        else
        {
            if(bDestroyProjectilesOnEncroach && Other.IsA('Projectile'))
            {
                Projectile(Other).Explode(Other.Location, -Normal(Velocity));
                return false;
            }
        }
        if(!bLandingPawn)
        {
            I = 0;
            J0x464:

            if(I < GeneratedEvents.Length)
            {
                MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
                if(MoverEvent != none)
                {
                    MoverEvent.NotifyEncroachingOn(Other);
                }
                ++ I;
                goto J0x464;
            }
            return bStopOnEncroach;
        }
    }
    return false;
}

event RanInto(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    if(bDestroyProjectilesOnEncroach && Other.IsA('Projectile'))
    {
        Projectile(Other).Explode(Other.Location, -Normal(Velocity));        
    }
    else
    {
        if(Other.bDestroyedByInterpActor)
        {
            Other.Destroy();            
        }
        else
        {
            if(bIsLift)
            {
                return;                
            }
            else
            {
                I = 0;
                J0xE2:

                if(I < GeneratedEvents.Length)
                {
                    MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
                    if(MoverEvent != none)
                    {
                        MoverEvent.NotifyEncroachingOn(Other);
                    }
                    ++ I;
                    goto J0xE2;
                }
            }
        }
    }
}

event Attach(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    if(!IsTimerActive('FinishedOpen'))
    {
        I = 0;
        J0x24:

        if(I < GeneratedEvents.Length)
        {
            MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
            if(MoverEvent != none)
            {
                MoverEvent.NotifyAttached(Other);
            }
            ++ I;
            goto J0x24;
        }
    }
}

event Detach(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    I = 0;
    J0x0B:

    if(I < GeneratedEvents.Length)
    {
        MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
        if(MoverEvent != none)
        {
            MoverEvent.NotifyDetached(Other);
        }
        ++ I;
        goto J0x0B;
    }
}

function Restart()
{
    local Actor A;

    foreach BasedActors(Class'Actor', A)
    {
        Attach(A);        
    }    
}

function FinishedOpen()
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    I = 0;
    J0x0B:

    if(I < GeneratedEvents.Length)
    {
        MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
        if(MoverEvent != none)
        {
            MoverEvent.NotifyFinishedOpen();
        }
        ++ I;
        goto J0x0B;
    }
}

simulated function PlayMovingSound(bool bClosing)
{
    local SoundCue SoundToPlay, AmbientToPlay;

    if(bClosing)
    {
        SoundToPlay = CloseSound;
        AmbientToPlay = OpeningAmbientSound;        
    }
    else
    {
        SoundToPlay = OpenSound;
        AmbientToPlay = ClosingAmbientSound;
    }
    if(SoundToPlay != none)
    {
        PlaySound(SoundToPlay, true);
    }
    if(AmbientToPlay != none)
    {
        AmbientSoundComponent.Stop();
        AmbientSoundComponent.SoundCue = AmbientToPlay;
        AmbientSoundComponent.Play();
    }
}

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst)
{
    ClearTimer('Restart');
    ClearTimer('FinishedOpen');
    PlayMovingSound(InterpAction.bReversePlayback);
    bShouldSaveForCheckpoint = true;
}

simulated event InterpolationFinished(SeqAct_Interp InterpAction)
{
    local DoorMarker DoorNav;
    local Controller C;
    local SoundCue StoppedSound;

    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.Stop();
    }
    StoppedSound = ((InterpAction.bReversePlayback) ? ClosedSound : OpenedSound);
    if(StoppedSound != none)
    {
        PlaySound(StoppedSound, true);
    }
    DoorNav = DoorMarker(MyMarker);
    if(InterpAction.bReversePlayback)
    {
        if(Attached.Length > 0)
        {
            SetTimer(StayOpenTime, false, 'Restart');
        }
        if(DoorNav != none)
        {
            DoorNav.MoverClosed();
        }        
    }
    else
    {
        SetTimer(StayOpenTime, false, 'FinishedOpen');
        if(DoorNav != none)
        {
            DoorNav.MoverOpened();
        }
    }
    if(bMonitorMover)
    {
        foreach WorldInfo.AllControllers(Class'Controller', C)
        {
            if(C.PendingMover == self)
            {
                C.MoverFinished();
            }            
        }        
    }
    if(InterpAction.bNoResetOnRewind && InterpAction.bRewindOnPlay)
    {
        ForceNetRelevant();
        bUpdateSimulatedPosition = true;
        bReplicateMovement = true;
    }
}

simulated event InterpolationChanged(SeqAct_Interp InterpAction)
{
    PlayMovingSound(InterpAction.bReversePlayback);
}

simulated function ShutDown()
{
    super(Actor).ShutDown();
    bShouldSaveForCheckpoint = true;
}

function bool ShouldSaveForCheckpoint()
{
    return bShouldSaveForCheckpoint || RemoteRole == ROLE_SimulatedProxy;
}

function CreateCheckpointRecord(out CheckpointRecord Record)
{
    Record.Location = Location;
    Record.Rotation = Rotation;
    Record.bHidden = bHidden;
    Record.CollisionType = ReplicatedCollisionType;
    Record.bNeedsPositionReplication = (RemoteRole == ROLE_SimulatedProxy) && bUpdateSimulatedPosition;
    Record.bIsShutdown = (Physics == 0) && bHidden;
}

function ApplyCheckpointRecord(const out CheckpointRecord Record)
{
    local Actor OldBase;
    local editinline SkeletalMeshComponent OldBaseComp;
    local name OldBaseBoneName;
    local array<Actor> OldAttached;
    local array<Vector> OldLocations;
    local int I;

    if(Record.bIsShutdown)
    {
        ShutDown();        
    }
    else
    {
        OldAttached = Attached;
        J0x40:

        if(I < OldAttached.Length)
        {
            if((OldAttached[I] != none) && OldAttached[I].bJustTeleported)
            {
                OldLocations[I] = OldAttached[I].Location;
                ++ I;                
            }
            else
            {
                OldAttached.Remove(I, 1;
            }
            goto J0x40;
        }
        OldBase = Base;
        OldBaseComp = BaseSkelComponent;
        OldBaseBoneName = BaseBoneName;
        SetLocation(Record.Location);
        SetRotation(Record.Rotation);
        SetBase(OldBase,, OldBaseComp, OldBaseBoneName);
        I = 0;
        J0x1A2:

        if(I < OldAttached.Length)
        {
            if(OldAttached[I] != none)
            {
                OldAttached[I].SetLocation(OldLocations[I]);
                OldAttached[I].SetBase(self);
            }
            ++ I;
            goto J0x1A2;
        }
        if(Record.CollisionType != ReplicatedCollisionType)
        {
            SetCollisionType(Record.CollisionType);
            ForceNetRelevant();
        }
        if(Record.bHidden != bHidden)
        {
            SetHidden(Record.bHidden);
            SetForcedInitialReplicatedProperty(BoolProperty'bHidden', bHidden == default.bHidden);
            ForceNetRelevant();
        }
        if(Record.bNeedsPositionReplication)
        {
            bUpdateSimulatedPosition = true;
            bReplicateMovement = true;
            ForceNetRelevant();
        }
    }
    bShouldSaveForCheckpoint = true;
}

defaultproperties
{
    bShouldSaveForCheckpoint=true
    bDestroyProjectilesOnEncroach=true
    bContinueOnEncroachPhysicsObject=true
    bStopOnEncroach=true
    bShouldShadowParentAllAttachedActors=true
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=255,G=0,R=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    StaticMeshComponent=StaticMeshComponent0
    LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
    Components(0)=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=255,G=0,R=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    Components(1)=StaticMeshComponent0
    Physics=EPhysics.PHYS_Interpolating
    RemoteRole=ENetRole.ROLE_None
    bNoDelete=true
    bAlwaysRelevant=true
    bOnlyDirtyReplication=true
    bBlocksTeleport=true
    NetUpdateFrequency=1
    NetPriority=2.7
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=255,G=0,R=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    CollisionComponent=StaticMeshComponent0
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
    SupportedEvents(6)=class'SeqEvent_Mover'
}