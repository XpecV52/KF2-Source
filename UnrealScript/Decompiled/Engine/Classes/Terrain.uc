/*******************************************************************************
 * Terrain generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Terrain extends Info
    native(Terrain)
    notplaceable
    hidecategories(Navigation);

struct TerrainHeight
{
};

struct TerrainInfoData
{
};

struct TerrainWeightedMaterial
{
};

struct TerrainLayer
{
    /** The name of the layer, for UI display purposes. */
    var() string Name;
    /** The TerrainLayerSetup, which declares the material(s) used in the layer. */
    var() TerrainLayerSetup Setup;
    var int AlphaMapIndex;
    /** Whether the layer should be highlighted when rendered. */
    var() bool Highlighted;
    /**  
     *Whether the layer should be wireframe highlighted when rendered.
     *               CURRENTLY NOT IMPLEMENTED
     */
    var() bool WireframeHighlighted;
    /** Whether the layer is hidden (not rendered). */
    var() bool Hidden;
    /** The color to highlight the layer with. */
    var() Color HighlightColor;
    /** The color to wireframe highlight the layer with. */
    var() Color WireframeColor;
    var int MinX;
    var int MinY;
    var int MaxX;
    var int MaxY;

    structdefaultproperties
    {
        Name=""
        Setup=none
        AlphaMapIndex=-1
        Highlighted=false
        WireframeHighlighted=false
        Hidden=false
        HighlightColor=(B=255,G=255,R=255,A=0)
        WireframeColor=(B=0,G=0,R=0,A=0)
        MinX=0
        MinY=0
        MaxX=0
        MaxY=0
    }
};

struct AlphaMap
{
};

struct TerrainDecorationInstance
{
    var export editinline PrimitiveComponent Component;
    var float X;
    var float Y;
    var float Scale;
    var int Yaw;

    structdefaultproperties
    {
        Component=none
        X=0
        Y=0
        Scale=0
        Yaw=0
    }
};

struct TerrainDecoration
{
    /** The factory used to generate the decoration mesh. */
    var() editinline PrimitiveComponentFactory Factory;
    /** The min scale to apply to the source mesh. */
    var() float MinScale;
    /** The max scale to apply to the source mesh. */
    var() float MaxScale;
    /** The density to use when applying the mesh to the terrain. */
    var() float Density;
    /**  
     *The amount to rotate the mesh to match the slope of the terrain
     *               where it is being placed. If 1.0, the mesh will match the slope
     *               exactly.
     */
    var() float SlopeRotationBlend;
    /** The value to use to seed the random number generator. */
    var() int RandSeed;
    var array<TerrainDecorationInstance> Instances;

    structdefaultproperties
    {
        Factory=none
        MinScale=1
        MaxScale=1
        Density=0.01
        SlopeRotationBlend=0
        RandSeed=0
        Instances=none
    }
};

struct TerrainDecoLayer
{
    /** The name of the DecoLayer, for UI display purposes. */
    var() string Name;
    /** The decoration(s) to apply for this layer. */
    var() array<TerrainDecoration> Decorations;
    var int AlphaMapIndex;

    structdefaultproperties
    {
        Name=""
        Decorations=none
        AlphaMapIndex=-1
    }
};

struct TerrainMaterialResource
{
};

struct native CachedTerrainMaterialArray
{
    var native const array<Pointer> CachedMaterials;
};

struct SelectedTerrainVertex
{
    var int X;
    var int Y;
    var int Weight;

    structdefaultproperties
    {
        X=0
        Y=0
        Weight=0
    }
};

var private native const array<TerrainHeight> Heights;
var private native const array<TerrainInfoData> InfoData;
/** Array of the terrain layers applied to the terrain */
var() const array<TerrainLayer> Layers;
/**  
 *The index of the layer that supplies the normal map for the whole terrain.
 *       If this is -1, the terrain will compile the normal property the old way
 *               (all normal maps blended together).
 *       If this is a valid index into the layer array, it will compile the normal
 *               property only for the material(s) contained in said layer.
 */
var() int NormalMapLayer;
/** Array of the decoration layers applied */
var() const array<TerrainDecoLayer> DecoLayers;
var native const array<AlphaMap> AlphaMaps;
var nontransactional const export editinline array<export editinline TerrainComponent> TerrainComponents;
var const int NumSectionsX;
var const int NumSectionsY;
var private native const array<TerrainWeightedMaterial> WeightedMaterials;
var private native const array<TerrainWeightMapTexture> WeightedTextureMaps;
/**  
 *The maximum number of quads in a single row/column of a tessellated patch.
 *  Must be a power of two, 1 <= MaxTesselationLevel <= 16
 */
var() int MaxTesselationLevel;
/**  
 *The minimum number of quads in a tessellated patch.
 *       Must be a power of two, 1 <= MaxTesselationLevel
 */
var() int MinTessellationLevel;
/**  
 *The scale factor to apply to the distance used in determining the tessellation
 *       level to utilize when rendering a patch.
 *               TessellationLevel = SomeFunction((Patch distance to camera) TesselationDistanceScale)
 */
var() float TesselationDistanceScale;
/**  
 *The radius from the view origin that terrain tessellation checks should be performed.
 *       If less than 0, the general setting from the engine configuration will be used.
 *       If 0.0, every component will be checked for tessellation changes each frame.
 */
var() float TessellationCheckDistance;
/** The tessellation level to utilize when performing collision checks with non-zero extents. */
var(Collision) int CollisionTesselationLevel;
var native const CachedTerrainMaterialArray CachedTerrainMaterials[2];
var const int NumVerticesX;
var const int NumVerticesY;
/**  
 *The number of patches in a single row of the terrain's patch grid.
 *  PostEditChange clamps this to be >= 1.
 *       Note that if you make this and/or NumPatchesY smaller, it will destroy the height-map/alpha-map
 *       data which is no longer used by the patches.If you make the dimensions larger, it simply fills
 *       in the new height-map/alpha-map data with zero.
 */
var() int NumPatchesX;
/**  
 *The number of patches in a single column of the terrain's patch grid.
 *  PostEditChange clamps this to be >= 1.
 */
var() int NumPatchesY;
/**  
 *For rendering and collision, split the terrain into components with a maximum size of
 *               (MaxComponentSize,MaxComponentSize) patches.
 *       The terrain is split up into rectangular groups of patches called terrain components for rendering.
 *       MaxComponentSize is the maximum number of patches in a single row/column of a terrain component.
 *       Generally, all components will be MaxComponentSize patches square, but on terrains with a patch
 *       resolution which isn't a multiple of MaxComponentSize, there will be some components along the edges
 *       which are smaller.
 * 
 *       This is limited by the MaxTesselationLevel, to prevent the vertex buffer for a fully tessellated
 *       component from being > 65536 vertices.
 *       For a MaxTesselationLevel of 16, MaxComponentSize is limited to <= 15.
 *       For a MaxTesselationLevel of 8, MaxComponentSize is limited to <= 31.
 * 
 *       PostEditChange clamps this to be >= 1.
 */
var() int MaxComponentSize;
/**  
 *The resolution to cache lighting at, in texels/patch.
 *       A separate shadow-map is used for each terrain component, which is up to
 *       (MaxComponentSize StaticLightingResolution + 1) pixels on a side.
 *       Must be a power of two, 1 <= StaticLightingResolution <= MaxTesselationLevel.
 */
var(Lighting) int StaticLightingResolution;
/**  
 *If true, the light/shadow map size is no longer restricted...
 *       The size of the light map will be (per component):
 *               INT LightMapSizeX = Component->SectionSizeX StaticLightingResolution + 1;
 *               INT LightMapSizeY = Component->SectionSizeY StaticLightingResolution + 1;
 * 
 *       So, the maximum size of a light/shadow map for a component will be:
 *               MaxMapSizeX = MaxComponentSize StaticLightingResolution + 1
 *               MaxMapSizeY = MaxComponentSize StaticLightingResolution + 1
 * 
 *       Be careful with the setting of StaticLightingResolution when this mode is enabled.
 *       It will be quite easy to run up a massive texture requirement on terrain!
 */
var(Lighting) bool bIsOverridingLightResolution;
/**  
 *If true, the lightmap generation will be performed using the bilinear filtering
 *       that all other lightmap generation in the engine uses.
 */
var(Lighting) bool bBilinearFilterLightmapGeneration;
/**  
 *Whether terrain should cast shadows.
 * 
 * Property is propagated to terrain components
 */
var(Lighting) bool bCastShadow;
/**  
 *If true, forces all static lights to use light-maps for direct lighting on the terrain, regardless of
 * the light's UseDirectLightMap property.
 * 
 * Property is propagated to terrain components .
 */
var(Lighting) const bool bForceDirectLightMap;
/**  
 *If false, primitive does not cast dynamic shadows.
 * 
 * Property is propagated to terrain components .
 */
var(Lighting) const bool bCastDynamicShadow;
/** If TRUE, enable specular on this terrain. */
var(Lighting) bool bEnableSpecular;
/**  
 *If false, primitive does not block rigid body physics.
 * 
 * Property is propagated to terrain components.
 */
var(Collision) const bool bBlockRigidBody;
/** If true, this allows rigid bodies to go underneath visible areas of the terrain. This adds some physics cost. */
var(Collision) const bool bAllowRigidBodyUnderneath;
/**  
 *If false, primitive does not accept dynamic lights, aka lights with HasStaticShadowing() == FALSE
 * 
 * Property is propagated to terrain components.
 */
var(Lighting) const bool bAcceptsDynamicLights;
/** Whether to utilize morping terrain or not */
var() bool bMorphingEnabled;
/** Whether to utilize morping gradients or not (bMorphingEnabled must be true for this to matter) */
var() bool bMorphingGradientsEnabled;
var bool bLocked;
var bool bHeightmapLocked;
var bool bShowingCollision;
/** Base UVs from world origin, to avoid layering seams in adjacent terrains */
var() bool bUseWorldOriginTextureUVs;
/** Tells the terrain to render in wireframe. */
var() bool bShowWireframe;
/** PhysicalMaterial to use for entire terrain */
var(Physics) const PhysicalMaterial TerrainPhysMaterialOverride;
/** Lighting channels controlling light/ primitive interaction. Only allows interaction if at least one channel is shared */
var(Lighting) const LightingChannelContainer LightingChannels;
/** Lightmass settings for the terrain */
var(Lightmass) LightmassPrimitiveSettings LightmassSettings<ScriptOrder=true>;
var native const Pointer ReleaseResourcesFence;
/** Editor-viewing tessellation level */
var() transient int EditorTessellationLevel;
var transient array<SelectedTerrainVertex> SelectedVertices;
/** The color to use when rendering the wireframe of the terrain. */
var() Color WireframeColor;
var private editoronly const Guid LightingGuid;

// Export UTerrain::execCalcLayerBounds(FFrame&, void* const)
native final function CalcLayerBounds();

simulated event PostBeginPlay()
{
    local int I;

    CalcLayerBounds();
    I = 0;
    J0x15:

    if(I < Layers.Length)
    {
        if(Layers[I].Setup != none)
        {
            Layers[I].Setup.PostBeginPlay();
        }
        ++ I;
        goto J0x15;
    }
}

defaultproperties
{
    NormalMapLayer=-1
    MaxTesselationLevel=4
    MinTessellationLevel=1
    TesselationDistanceScale=1
    TessellationCheckDistance=-1
    CollisionTesselationLevel=1
    NumPatchesX=1
    NumPatchesY=1
    MaxComponentSize=16
    StaticLightingResolution=4
    bBilinearFilterLightmapGeneration=true
    bCastShadow=true
    bForceDirectLightMap=true
    bCastDynamicShadow=true
    bBlockRigidBody=true
    bAcceptsDynamicLights=true
    LightingChannels=(bInitialized=true,BSP=false,Static=false,Dynamic=false,CompositeDynamic=false,Skybox=false,Unnamed_1=false,Unnamed_2=false,Unnamed_3=false,Unnamed_4=false,Unnamed_5=false,Unnamed_6=false,Cinematic_1=false,Cinematic_2=false,Cinematic_3=false,Cinematic_4=false,Cinematic_5=false,Cinematic_6=false,Cinematic_7=false,Cinematic_8=false,Cinematic_9=false,Cinematic_10=false,Gameplay_1=false,Gameplay_2=false,Gameplay_3=false,Gameplay_4=false,Crowd=false,Indoor=false,Outdoor=true)
    LightmassSettings=(bUseTwoSidedLighting=false,bShadowIndirectOnly=false,bUseEmissiveForStaticLighting=false,EmissiveLightFalloffExponent=2,EmissiveLightExplicitInfluenceRadius=0,EmissiveBoost=1,DiffuseBoost=1,SpecularBoost=1,FullyOccludedSamplesFraction=1)
    WireframeColor=(B=255,G=255,R=0,A=0)
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_Terrain'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Terrain.Sprite'
    Components(0)=Sprite
    DrawScale3D=(X=256,Y=256,Z=256)
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bStatic=true
    bHidden=false
    bNoDelete=true
    bWorldGeometry=true
    bCollideActors=true
    bBlockActors=true
    bEdShouldSnap=true
}