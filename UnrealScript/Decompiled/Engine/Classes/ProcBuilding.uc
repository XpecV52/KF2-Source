/*******************************************************************************
 * ProcBuilding generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class ProcBuilding extends Volume
    native(ProcBuilding)
    placeable
    hidecategories(Navigation,Object,Movement,Display);

const ROOF_MINZ = 0.7;
const PROCBUILDING_VERSION = 1;

enum EScopeEdge
{
    EPSA_Top,
    EPSA_Bottom,
    EPSA_Left,
    EPSA_Right,
    EPSA_None,
    EPSA_MAX
};

enum EPBCornerType
{
    EPBC_Default,
    EPBC_Chamfer,
    EPBC_Round,
    EPBC_MAX
};

enum EBuildingStatsBrowserColumns
{
    BSBC_Name,
    BSBC_Ruleset,
    BSBC_NumStaticMeshComps,
    BSBC_NumInstancedStaticMeshComps,
    BSBC_NumInstancedTris,
    BSBC_LightmapMemBytes,
    BSBC_ShadowmapMemBytes,
    BSBC_LODDiffuseMemBytes,
    BSBC_LODLightingMemBytes,
    BSBC_MAX
};

struct native PBScope2D
{
    var Matrix ScopeFrame;
    var float DimX;
    var float DimZ;

    structdefaultproperties
    {
        ScopeFrame=(XPlane=(W=0,X=0,Y=0,Z=0),YPlane=(W=0,X=0,Y=0,Z=0),ZPlane=(W=0,X=0,Y=0,Z=0),WPlane=(W=0,X=0,Y=0,Z=0))
        DimX=0
        DimZ=0
    }
};

struct native PBScopeProcessInfo
{
    var ProcBuilding OwningBuilding;
    var ProcBuildingRuleset Ruleset;
    var name RulesetVariation;
    var bool bGenerateLODPoly;
    var bool bPartOfNonRect;

    structdefaultproperties
    {
        OwningBuilding=none
        Ruleset=none
        RulesetVariation=None
        bGenerateLODPoly=false
        bPartOfNonRect=false
    }
};

struct native PBFaceUVInfo
{
    var Vector2D Offset;
    var Vector2D Size;

    structdefaultproperties
    {
        Offset=(X=0,Y=0)
        Size=(X=0,Y=0)
    }
};

struct native PBEdgeInfo
{
    var Vector EdgeEnd;
    var Vector EdgeStart;
    var int ScopeAIndex;
    var ProcBuilding.EScopeEdge ScopeAEdge;
    var int ScopeBIndex;
    var ProcBuilding.EScopeEdge ScopeBEdge;
    var float EdgeAngle;

    structdefaultproperties
    {
        EdgeEnd=(X=0,Y=0,Z=0)
        EdgeStart=(X=0,Y=0,Z=0)
        ScopeAIndex=0
        ScopeAEdge=EScopeEdge.EPSA_Top
        ScopeBIndex=0
        ScopeBEdge=EScopeEdge.EPSA_Top
        EdgeAngle=0
    }
};

struct native PBMeshCompInfo
{
    var export editinline StaticMeshComponent MeshComp;
    var int TopLevelScopeIndex;

    structdefaultproperties
    {
        MeshComp=none
        TopLevelScopeIndex=0
    }
};

struct native PBFracMeshCompInfo
{
    var export editinline FracturedStaticMeshComponent FracMeshComp;
    var int TopLevelScopeIndex;

    structdefaultproperties
    {
        FracMeshComp=none
        TopLevelScopeIndex=0
    }
};

struct native PBMaterialParam
{
    /** Name of parameter to set in all building MICs */
    var() name ParamName;
    /** Value to set parameter to in all building MICs */
    var() LinearColor Color;

    structdefaultproperties
    {
        ParamName=None
        Color=(R=0,G=0,B=0,A=1)
    }
};

struct native PBMemUsageInfo
{
    var ProcBuilding Building;
    var ProcBuildingRuleset Ruleset;
    var int NumStaticMeshComponent;
    var int NumInstancedStaticMeshComponents;
    var int NumInstancedTris;
    var int LightmapMemBytes;
    var int ShadowmapMemBytes;
    var int LODDiffuseMemBytes;
    var int LODLightingMemBytes;

    structdefaultproperties
    {
        Building=none
        Ruleset=none
        NumStaticMeshComponent=0
        NumInstancedStaticMeshComponents=0
        NumInstancedTris=0
        LightmapMemBytes=0
        ShadowmapMemBytes=0
        LODDiffuseMemBytes=0
        LODLightingMemBytes=0
    }
};

/** Pointer to ruleset in package used to build facade geometry for building */
var() editoronly ProcBuildingRuleset Ruleset;
/** Array of information about each component making up the final building */
var() const editconst array<editconst PBMeshCompInfo> BuildingMeshCompInfos;
/** Array of information about each fractured mesh making up the final building */
var() const editconst array<editconst PBFracMeshCompInfo> BuildingFracMeshCompInfos;
/** Component used to display simple one-mesh version of building */
var() const editconst export editinline StaticMeshComponent SimpleMeshComp;
/** If TRUE, generate a poly to fill the hole on the top of the building */
var() bool bGenerateRoofMesh;
/** If TRUE, generate a poly to fill the hole on the bottom of the building volume */
var() bool bGenerateFloorMesh;
/** If TRUE, meshing rules are applied to roof of building, instead of just leaving it as a flat poly */
var() bool bApplyRulesToRoof;
/** If TRUE, meshing rules are applied to floor of building, instead of just leaving it as a flat poly */
var() bool bApplyRulesToFloor;
/** If TRUE, wall scopes will be split at each roof/floor level in the building group. */
var() bool bSplitWallsAtRoofLevels;
/** If TRUE, wall scopes will be split when another wall ends in the middle of a face. */
var() bool bSplitWallsAtWallEdges;
var transient bool bQuickEdited;
/** Controls if the simple brush has collision. */
var() bool bBuildingBrushCollision;
/** If TRUE, show face->edge relationships when this building is selected. */
var(Debug) bool bDebugDrawEdgeInfo;
/** If TRUE, show scopes extracted from brushes. */
var(Debug) bool bDebugDrawScopes;
var const export editinline array<export editinline StaticMeshComponent> LODMeshComps;
var editoronly array<editoronly PBFaceUVInfo> LODMeshUVInfos;
var editoronly array<editoronly PBScope2D> TopLevelScopes;
var int NumMeshedTopLevelScopes;
var editoronly array<editoronly PBFaceUVInfo> TopLevelScopeUVInfos;
var editoronly array<editoronly PBScopeProcessInfo> TopLevelScopeInfos;
var editoronly array<editoronly PBEdgeInfo> EdgeInfos;
var float MaxFacadeZ;
var float MinFacadeZ;
var transient array<ProcBuilding> OverlappingBuildings;
/** Distance at which MassiveLOD will kick in and change between high detail meshes and the SimpleMeshComp / LowLODPersistentActor */
var() float SimpleMeshMassiveLODDistance;
/** Amount to pull back from the face to render from (caging depth). Nearby meshes closer than this will be rendered into the buildings RTT. */
var() float RenderToTexturePullBackAmount;
/** Light map resolution used for generated roof plane mesh */
var() int RoofLightmapRes;
/** Light map resolution used for generated non-rectangular wall meshes */
var() int NonRectWallLightmapRes;
/** Amount to scale the resolution of LOD color and lighting textures, generated using render-to-texture */
var() editoronly float LODRenderToTextureScale<UIMin=0.25|UIMax=4.0>;
/** Name of the parameter 'swatch' (stored in the Ruleset) that is applied to this building */
var() name ParamSwatchName;
/** Optional parameters than are set on all MICs applied to building. */
var() array<PBMaterialParam> BuildingMaterialParams;
var editoronly array<editoronly MaterialInstanceConstant> BuildingMatParamMICs;
/** Since we want the low lod mesh of the building to be always loaded, we need an actor in the P map (or other always loaded level); this is that actor */
var() duplicatetransient crosslevelpassive const editconst StaticMeshActor LowLODPersistentActor;
var export editinline transient StaticMeshComponent CurrentSimpleMeshComp;
var transient Actor CurrentSimpleMeshActor;
var editoronly array<editoronly ProcBuilding> AttachedBuildings;
var const int BuildingInstanceVersion;

// Export UProcBuilding::execClearBuildingMeshes(FFrame&, void* const)
native function ClearBuildingMeshes();

// Export UProcBuilding::execFindComponentsForTopLevelScope(FFrame&, void* const)
native function array<editinline StaticMeshComponent> FindComponentsForTopLevelScope(int TopLevelScopeIndex);

// Export UProcBuilding::execGetBaseMostBuilding(FFrame&, void* const)
native function ProcBuilding GetBaseMostBuilding();

// Export UProcBuilding::execGetAllGroupedProcBuildings(FFrame&, void* const)
native function GetAllGroupedProcBuildings(out array<ProcBuilding> OutSet);

// Export UProcBuilding::execBreakFractureComponent(FFrame&, void* const)
native function BreakFractureComponent(FracturedStaticMeshComponent Comp, Vector BoxMin, Vector BoxMax);

// Export UProcBuilding::execFindEdgeForTopLevelScope(FFrame&, void* const)
native function int FindEdgeForTopLevelScope(int TopLevelScopeIndex, ProcBuilding.EScopeEdge Edge);

defaultproperties
{
    bGenerateRoofMesh=true
    bSplitWallsAtRoofLevels=true
    bSplitWallsAtWallEdges=true
    bBuildingBrushCollision=true
    SimpleMeshMassiveLODDistance=10000
    RenderToTexturePullBackAmount=125
    RoofLightmapRes=64
    NonRectWallLightmapRes=64
    LODRenderToTextureScale=1
    LowLODPersistentActor=none
    BrushColor=(B=135,G=255,R=222,A=255)
    bColored=true
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_BlockingVolume
        BlockActors=true
        BlockRigidBody=true
        bDisableAllRigidBody=false
    object end
    // Reference: BrushComponent'Default__ProcBuilding.BrushComponent0'
    BrushComponent=BrushComponent0
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_BlockingVolume
        BlockActors=true
        BlockRigidBody=true
        bDisableAllRigidBody=false
    object end
    // Reference: BrushComponent'Default__ProcBuilding.BrushComponent0'
    Components(0)=BrushComponent0
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bHidden=false
    bWorldGeometry=true
    bRouteBeginPlayEvenIfStatic=false
    bGameRelevant=true
    bMovable=false
    bBlockActors=true
    bForceOctreeSNFilter=true
    bPathColliding=true
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_BlockingVolume
        BlockActors=true
        BlockRigidBody=true
        bDisableAllRigidBody=false
    object end
    // Reference: BrushComponent'Default__ProcBuilding.BrushComponent0'
    CollisionComponent=BrushComponent0
}