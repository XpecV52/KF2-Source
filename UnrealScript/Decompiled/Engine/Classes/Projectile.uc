/*******************************************************************************
 * Projectile generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Projectile extends Actor
    abstract
    native
    notplaceable
    hidecategories(Navigation);

/** Initial speed of projectile. */
var() float Speed;
/** Limit on speed of projectile (0 means no limit). */
var() float MaxSpeed;
var bool bSwitchToZeroCollision;
var bool bBlockedByInstigator;
var bool bBegunPlay;
var bool bRotationFollowsVelocity;
var bool bIgnoreFoliageTouch;
var Actor ZeroCollider;
var export editinline PrimitiveComponent ZeroColliderComponent;
/** Damage done by the projectile */
var() float Damage;
/** Radius of effect in which damage is applied. */
var() float DamageRadius;
/** Momentum magnitude imparted by impacting projectile. */
var() float MomentumTransfer;
var class<DamageType> MyDamageType;
/** Sound made when projectile is spawned. */
var() SoundCue SpawnSound;
/** Sound made when projectile hits something. */
var() SoundCue ImpactSound;
var Controller InstigatorController;
var Actor ImpactedActor;
var float NetCullDistanceSquared;
var export editinline CylinderComponent CylinderComponent;

event bool EncroachingOn(Actor Other)
{
    if(Brush(Other) != none)
    {
        return true;
    }
    return false;
}

event PreBeginPlay()
{
    if(Instigator != none)
    {
        InstigatorController = Instigator.Controller;
    }
    super.PreBeginPlay();
    if(((!bDeleteMe && InstigatorController != none) && InstigatorController.ShotTarget != none) && InstigatorController.ShotTarget.Controller != none)
    {
        InstigatorController.ShotTarget.Controller.ReceiveProjectileWarning(self);
    }
}

simulated event PostBeginPlay()
{
    bBegunPlay = true;
}

// Export UProjectile::execInit(FFrame&, void* const)
native function Init(Vector Direction);

// Export UProjectile::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

simulated function bool CanSplash()
{
    return bBegunPlay;
}

function Reset()
{
    Destroy();
}

simulated function bool ProjectileHurtRadius(Vector HurtOrigin, Vector HitNormal)
{
    local Vector AltOrigin, TraceHitLocation, TraceHitNormal;
    local Actor TraceHitActor;

    if(bHurtEntry)
    {
        return false;
    }
    AltOrigin = HurtOrigin;
    if((ImpactedActor != none) && ImpactedActor.bWorldGeometry)
    {
        AltOrigin = HurtOrigin + ((2 * Class'Pawn'.default.MaxStepHeight) * HitNormal);
        TraceHitActor = Trace(TraceHitLocation, TraceHitNormal, AltOrigin, HurtOrigin, false,,, 1);
        if(TraceHitActor == none)
        {
            AltOrigin = HurtOrigin + (Class'Pawn'.default.MaxStepHeight * HitNormal);            
        }
        else
        {
            AltOrigin = HurtOrigin + (0.5 * (TraceHitLocation - HurtOrigin));
        }
    }
    return HurtRadius(Damage, DamageRadius, MyDamageType, MomentumTransfer, AltOrigin);
}

simulated function bool HurtRadius(float DamageAmount, float InDamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, optional Actor IgnoredActor, optional Controller InstigatedByController, optional bool bDoFullDamage)
{
    local bool bCausedDamage, bResult;

    InstigatedByController = ((Instigator != none) ? Instigator.Controller : none);    
    if(bHurtEntry)
    {
        return false;
    }
    bCausedDamage = false;
    if(InstigatedByController == none)
    {
        InstigatedByController = InstigatorController;
    }
    if((ImpactedActor != none) && ImpactedActor != self)
    {
        ImpactedActor.TakeRadiusDamage(InstigatedByController, DamageAmount, InDamageRadius, DamageType, Momentum, HurtOrigin, true, self);
        bCausedDamage = ImpactedActor.bProjTarget;
    }
    bResult = super.HurtRadius(DamageAmount, InDamageRadius, DamageType, Momentum, HurtOrigin, ImpactedActor, InstigatedByController, bDoFullDamage);
    return bResult || bCausedDamage;
}

singular simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    if((Other == none) || Other.bDeleteMe)
    {
        return;
    }
    if(bIgnoreFoliageTouch && InteractiveFoliageActor(Other) != none)
    {
        return;
    }
    if((Other.StopsProjectile(self) && (Role == ROLE_Authority) || bBegunPlay) && bBlockedByInstigator || Other != Instigator)
    {
        ImpactedActor = Other;
        ProcessTouch(Other, HitLocation, HitNormal);
        ImpactedActor = none;
    }
}

simulated function ProcessTouch(Actor Other, Vector HitLocation, Vector HitNormal)
{
    if(Other != Instigator)
    {
        if(!Other.bStatic && DamageRadius == 0)
        {
            Other.TakeDamage(int(Damage), InstigatorController, Location, MomentumTransfer * Normal(Velocity), MyDamageType,, self);
        }
        Explode(HitLocation, HitNormal);
    }
}

singular simulated event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    local KActorFromStatic NewKActor;
    local editinline StaticMeshComponent HitStaticMesh;

    super.HitWall(HitNormal, Wall, WallComp);
    if(Wall.bWorldGeometry)
    {
        HitStaticMesh = StaticMeshComponent(WallComp);
        if((HitStaticMesh != none) && HitStaticMesh.CanBecomeDynamic())
        {
            NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitStaticMesh);
            if(NewKActor != none)
            {
                Wall = NewKActor;
            }
        }
    }
    ImpactedActor = Wall;
    if(!Wall.bStatic && DamageRadius == float(0))
    {
        Wall.TakeDamage(int(Damage), InstigatorController, Location, MomentumTransfer * Normal(Velocity), MyDamageType,, self);
    }
    Explode(Location, HitNormal);
    ImpactedActor = none;
}

simulated event EncroachedBy(Actor Other)
{
    HitWall(Normal(Location - Other.Location), Other, none);
}

simulated function Explode(Vector HitLocation, Vector HitNormal)
{
    if((Damage > float(0)) && DamageRadius > float(0))
    {
        if(Role == ROLE_Authority)
        {
            MakeNoise(1);
        }
        ProjectileHurtRadius(HitLocation, HitNormal);
    }
    Destroy();
}

final simulated function RandSpin(float spinRate)
{
    RotationRate.Yaw = int(((spinRate * float(2)) * FRand()) - spinRate);
    RotationRate.Pitch = int(((spinRate * float(2)) * FRand()) - spinRate);
    RotationRate.Roll = int(((spinRate * float(2)) * FRand()) - spinRate);
}

function bool IsStationary()
{
    return false;
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    Explode(Location, vect(0, 0, 1));
}

simulated function float GetTimeToLocation(Vector TargetLoc)
{
    return VSize(TargetLoc - Location) / Speed;
}

static simulated function float StaticGetTimeToLocation(Vector TargetLoc, Vector StartLoc, Controller RequestedBy)
{
    return VSize(TargetLoc - StartLoc) / default.Speed;
}

static simulated function float GetRange()
{
    if(default.LifeSpan == 0)
    {
        return 15000;        
    }
    else
    {
        return default.MaxSpeed * default.LifeSpan;
    }
}

simulated function ApplyFluidSurfaceImpact(FluidSurfaceActor Fluid, Vector HitLocation)
{
    super.ApplyFluidSurfaceImpact(Fluid, HitLocation);
    if(CanSplash())
    {
        if((((WorldInfo.NetMode != NM_DedicatedServer) && Instigator != none) && Instigator.IsPlayerPawn()) && Instigator.IsLocallyControlled())
        {
            WorldInfo.MyEmitterPool.SpawnEmitter(Fluid.ProjectileEntryEffect, HitLocation, rotator(vect(0, 0, 1)), self);
        }
    }
}

defaultproperties
{
    Speed=2000
    MaxSpeed=2000
    bBlockedByInstigator=true
    DamageRadius=220
    MyDamageType=Class'DamageType'
    NetCullDistanceSquared=4E+08
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Projectile.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Projectile.CollisionCylinder'
    Components(0)=CollisionCylinder
    Physics=EPhysics.PHYS_Projectile
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bNetTemporary=true
    bReplicateInstigator=true
    bGameRelevant=true
    bCanBeDamaged=true
    bCollideActors=true
    bCollideWorld=true
    NetPriority=2.5
    LifeSpan=14
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=0
        CollisionRadius=0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Projectile.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}