/*******************************************************************************
 * Pawn generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Pawn extends Actor
    abstract
    native(Pawn)
    nativereplication
    config(Game)
    placeable
    hidecategories(Navigation)
    implements(Interface_Speaker);

enum EPathSearchType
{
    PST_Default,
    PST_Breadth,
    PST_NewBestPathTo,
    PST_Constraint,
    PST_MAX
};

struct native ScalarParameterInterpStruct
{
    /** Name of parameter to change */
    var() name ParameterName;
    /** Desired Parameter Value */
    var() float ParameterValue;
    /** Desired Interpolation Time */
    var() float InterpTime;
    /** Time before interpolation starts */
    var() float WarmupTime;

    structdefaultproperties
    {
        ParameterName=None
        ParameterValue=0
        InterpTime=0
        WarmupTime=0
    }
};

var private native const noexport Pointer VfTable_IInterface_Speaker;
var const float MaxStepHeight;
var const float MaxJumpHeight;
var const float WalkableFloorZ;
var const float LedgeCheckThreshold;
var const Vector PartialLedgeMoveDir;
var repnotify editinline Controller Controller;
var const Pawn NextPawn;
var float NetRelevancyTime;
var PlayerController LastRealViewer;
var Actor LastViewer;
var bool bScriptTickSpecial;
var bool bUpAndOut;
var bool bIsWalking;
var bool bWantsToCrouch;
var const bool bIsCrouched;
var const bool bTryToUncrouch;
/** if true, this pawn is capable of crouching */
var() bool bCanCrouch;
var bool bCrawler;
var const bool bReducedSpeed;
var bool bJumpCapable;
var bool bCanJump;
var bool bCanWalk;
var bool bCanSwim;
var bool bCanFly;
var bool bCanClimbLadders;
var bool bCanStrafe;
var bool bAvoidLedges;
var bool bStopAtLedges;
var bool bAllowLedgeOverhang;
var const bool bPartiallyOverLedge;
var const bool bSimulateGravity;
var bool bIgnoreForces;
var bool bCanWalkOffLedges;
var bool bCanBeBaseForPawns;
var const bool bSimGravityDisabled;
var bool bDirectHitWall;
var const bool bPushesRigidBodies;
var bool bForceFloorCheck;
var bool bForceKeepAnchor;
var config bool bCanMantle;
var config bool bCanClimbUp;
var bool bCanClimbCeilings;
var config bool bCanSwatTurn;
var config bool bCanLeap;
var config bool bCanCoverSlip;
var globalconfig bool bDisplayPathErrors;
var bool bCanPickupInventory;
var bool bAmbientCreature;
/** can hear sounds from line-of-sight sources (which are close enough to hear) bLOSHearing=true is like UT/Unreal hearing */
var(AI) bool bLOSHearing;
/** can hear sounds through walls (but muffled - sound distance increased to double plus 4x the distance through walls */
var(AI) bool bMuffledHearing;
/** if true, Pawn won't be possessed at game start */
var(AI) bool bDontPossess;
var bool bRollToDesired;
var bool bStationary;
var bool bCachedRelevant;
var bool bNoWeaponFiring;
var bool bModifyReachSpecCost;
var bool bModifyNavPointDest;
var bool bPathfindsAsVehicle;
var bool bPrevBypassSimulatedClientPhysics;
var bool bRunPhysicsWithNoController;
var bool bForceMaxAccel;
var bool bLimitFallAccel;
var bool bReplicateHealthToAll;
var bool bForceRMVelocity;
var bool bForceRegularVelocity;
var bool bPlayedDeath;
var private const bool bDesiredRotationSet;
var private const bool bLockDesiredRotation;
var private const bool bUnlockWhenReached;
var bool bNeedsBaseTickedFirst;
var repnotify transient bool bUsedByMatinee;
var bool bRootMotionFromInterpCurve;
/** debug */
var(Debug) bool bDebugShowCameraLocation;
/**  
 *Set this to TRUE if riding on a moving base that you know is clear from non-moving world obstructions.
 *  This can solve move-order dependencies when riding a mover, and it's faster.
 */
var() bool bFastAttachedMove;
var bool bCanJumpOverWalls;
var bool bDebugCrawlerPhysics;
var(Movement) Actor.EPhysics WalkingPhysics;
var Pawn.EPathSearchType PathSearchType;
var const byte RemoteViewPitch;
var repnotify byte FlashCount;
var repnotify byte FiringMode;
var transient byte LightingVolumeEnterCount;
var const float UncrouchTime;
var float CrouchHeight;
var float CrouchRadius;
var const int FullHeight;
var float NonPreferredVehiclePathMultiplier;
var PathConstraint PathConstraintList;
var PathGoalEvaluator PathGoalList;
var float DesiredSpeed;
var float MaxDesiredSpeed;
/** max distance at which a makenoise(1.0) loudness sound can be heard */
var(AI) float HearingThreshold;
/** -1 to 1 ->Used within specific states for varying reaction to stimuli */
var(AI) float Alertness;
/** Maximum seeing distance. */
var(AI) float SightRadius;
/** Cosine of limits of peripheral vision. */
var(AI) float PeripheralVision;
var const float AvgPhysicsTime;
var float Mass;
var float Buoyancy;
var float MeleeRange;
var const NavigationPoint Anchor;
var const int AnchorItem;
var const NavigationPoint LastAnchor;
var float FindAnchorFailedTime;
var float LastValidAnchorTime;
var float DestinationOffset;
var float NextPathRadius;
var Vector SerpentineDir;
var float SerpentineDist;
var float SerpentineTime;
var float SpawnTime;
var int MaxPitchLimit;
var float GroundSpeed;
var float WaterSpeed;
var float AirSpeed;
var float LadderSpeed;
var float AccelRate;
var float JumpZ;
var float OutofWaterZ;
var float MaxOutOfWaterStepHeight;
var float AirControl;
var float WalkingPct;
var float MovementSpeedModifier;
var float CrouchedPct;
var float MaxFallSpeed;
var float AIMaxFallSpeedFactor;
/** Base eye height above collision center. */
var(Camera) float BaseEyeHeight;
/** Current eye height, adjusted for bobbing and stairs. */
var(Camera) float EyeHeight;
var Vector Floor;
var float SplashTime;
var transient PhysicsVolume HeadVolume;
/** amount of health this Pawn has */
var() int Health;
/** normal maximum health of Pawn - defaults to default.Health unless explicitly set otherwise */
var() int HealthMax;
var float BreathTime;
var float UnderWaterTime;
var float LastPainTime;
var float KismetDeathDelayTime;
var Vector RMVelocity;
var const Vector noise1spot;
var const float noise1time;
var const Pawn noise1other;
var const float noise1loudness;
var const Vector noise2spot;
var const float noise2time;
var const Pawn noise2other;
var const float noise2loudness;
var float SoundDampening;
var float DamageScaling;
var const localized string MenuName;
var class<AIController> ControllerClass;
var repnotify editinline PlayerReplicationInfo PlayerReplicationInfo;
var LadderVolume OnLadder;
var name LandMovementState;
var name WaterMovementState;
var PlayerStart LastStartSpot;
var float LastStartTime;
var Vector TakeHitLocation;
var class<DamageType> HitDamageType;
var Vector TearOffMomentum;
var() export editinline SkeletalMeshComponent Mesh;
var export editinline CylinderComponent CylinderComponent;
/** Unreal units */
var() float RBPushRadius;
var() float RBPushStrength;
var repnotify Vehicle DrivenVehicle;
var float AlwaysRelevantDistanceSquared;
/** Radius that is checked for nearby vehicles when pressing use */
var() float VehicleCheckRadius;
var Controller LastHitBy;
var() float ViewPitchMin;
var() float ViewPitchMax;
var int AllowedYawError;
/** In future I will uncomment this change. Currently Actor has the variable. */
var(Movement) const Rotator DesiredRotation;
var class<InventoryManager> InventoryManagerClass;
var repnotify InventoryManager InvManager;
var Weapon Weapon;
var repnotify Vector FlashLocation;
var Vector LastFiringFlashLocation;
var int ShotCount;
var export editinline PrimitiveComponent PreRagdollCollisionComponent;
var RB_BodyInstance PhysicsPushBody;
var int FailedLandingCount;
var transient array<AnimNodeSlot> SlotNodes;
var transient array<InterpGroup> InterpGroupList;
var protected export editinline transient AudioComponent FacialAudioComp;
var protected transient MaterialInstanceConstant MIC_PawnMat;
var protected transient MaterialInstanceConstant MIC_PawnHair;
var() array<ScalarParameterInterpStruct> ScalarParameterInterpArray;
var RootMotionCurve RootMotionInterpCurve;
var float RootMotionInterpRate;
var float RootMotionInterpCurrentTime;
var Vector RootMotionInterpCurveLastValue;

replication
{
     if(bNetDirty)
        DrivenVehicle, FlashLocation, 
        HitDamageType, PlayerReplicationInfo, 
        TakeHitLocation, bFastAttachedMove, 
        bIsWalking, bSimulateGravity, 
        bUsedByMatinee;

     if(bNetDirty && bNetOwner || bReplicateHealthToAll)
        Health;

     if(bNetDirty && bNetOwner)
        AccelRate, AirControl, 
        AirSpeed, Controller, 
        GroundSpeed, InvManager, 
        JumpZ, WaterSpeed;

     if((bNetDirty && bNetOwner) && bNetInitial)
        bCanSwatTurn;

     if(bNetDirty && !bNetOwner || bDemoRecording)
        FiringMode, FlashCount, 
        bIsCrouched;

     if(bTearOff && bNetDirty)
        TearOffMomentum;

     if(!bNetOwner || bDemoRecording)
        RemoteViewPitch;

     if(bNetInitial && !bNetOwner)
        bRootMotionFromInterpCurve;

     if((bNetInitial && !bNetOwner) && bRootMotionFromInterpCurve)
        RootMotionInterpCurrentTime, RootMotionInterpCurveLastValue, 
        RootMotionInterpRate;

     if((Role == ROLE_Authority) && bNetDirty)
        HealthMax;
}

// Export UPawn::execPickWallAdjust(FFrame&, void* const)
native final function bool PickWallAdjust(Vector WallHitNormal, Actor HitActor);

// Export UPawn::execSetDesiredRotation(FFrame&, void* const)
native final function bool SetDesiredRotation(Rotator TargetDesiredRotation, optional bool InLockDesiredRotation, optional bool InUnlockWhenReached, optional float InterpolationTime, optional bool bResetRotationRate)
{
    InLockDesiredRotation = false;
    InUnlockWhenReached = false;
    InterpolationTime = -1;
    bResetRotationRate = true;                            
}

// Export UPawn::execLockDesiredRotation(FFrame&, void* const)
native final function LockDesiredRotation(bool Lock, optional bool InUnlockWhenReached)
{
    InUnlockWhenReached = false;                
}

// Export UPawn::execResetDesiredRotation(FFrame&, void* const)
native final function ResetDesiredRotation();

// Export UPawn::execCheckDesiredRotation(FFrame&, void* const)
native final function CheckDesiredRotation();

// Export UPawn::execIsDesiredRotationInUse(FFrame&, void* const)
native final function bool IsDesiredRotationInUse();

// Export UPawn::execIsDesiredRotationLocked(FFrame&, void* const)
native final function bool IsDesiredRotationLocked();

// Export UPawn::execReachedMyDestination(FFrame&, void* const)
native function bool ReachedMyDestination(const out Vector TestPosition, const out Vector Dest, Actor GoalActor);

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    super.PostInitAnimTree(SkelComp);
    if(SkelComp == Mesh)
    {
        ClearAnimNodes();
        CacheAnimNodes();
    }
}

// Export UPawn::execCacheAnimNodes(FFrame&, void* const)
native simulated event CacheAnimNodes();

simulated function ClearAnimNodes()
{
    SlotNodes.Length = 0;
}

// Export UPawn::execUpdateAnimSetList(FFrame&, void* const)
native final simulated function UpdateAnimSetList();

simulated event BuildScriptAnimSetList();

// Export UPawn::execAddAnimSets(FFrame&, void* const)
native final simulated function AddAnimSets(const out array<AnimSet> CustomAnimSets);

simulated event AnimSetListUpdated();

simulated event bool RestoreAnimSetsToDefault()
{
    Mesh.AnimSets = default.Mesh.AnimSets;
    return true;
}

simulated event BeginAnimControl(InterpGroup InInterpGroup)
{
    MAT_BeginAnimControl(InInterpGroup);
}

// Export UPawn::execMAT_BeginAnimControl(FFrame&, void* const)
native function MAT_BeginAnimControl(InterpGroup InInterpGroup);

simulated event FinishAnimControl(InterpGroup InInterpGroup)
{
    MAT_FinishAnimControl(InInterpGroup);
}

// Export UPawn::execMAT_FinishAnimControl(FFrame&, void* const)
native function MAT_FinishAnimControl(InterpGroup InInterpGroup);

simulated event SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
    MAT_SetAnimPosition(SlotName, ChannelIndex, InAnimSeqName, InPosition, bFireNotifies, bLooping, bEnableRootMotion);
}

// Export UPawn::execMAT_SetAnimPosition(FFrame&, void* const)
native function MAT_SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);

// Export UPawn::execMAT_SetAnimWeights(FFrame&, void* const)
native function MAT_SetAnimWeights(array<AnimSlotInfo> SlotInfos);

// Export UPawn::execMAT_SetMorphWeight(FFrame&, void* const)
native function MAT_SetMorphWeight(name MorphNodeName, float MorphWeight);

// Export UPawn::execMAT_SetSkelControlScale(FFrame&, void* const)
native function MAT_SetSkelControlScale(name SkelControlName, float Scale);

// Export UPawn::execMAT_SetSkelControlStrength(FFrame&, void* const)
native function MAT_SetSkelControlStrength(name SkelControlName, float ControlStrength);

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst)
{
    super.InterpolationStarted(InterpAction, GroupInst);
}

simulated event InterpolationFinished(SeqAct_Interp InterpAction)
{
    super.InterpolationFinished(InterpAction);
}

simulated function BeginAIGroup();

simulated function FinishAIGroup();

event MAT_BeginAIGroup(Vector StartLoc, Rotator StartRot)
{
    SetLocation(StartLoc);
    SetRotation(StartRot);
    BeginAIGroup();
    bUsedByMatinee = true;
}

event MAT_FinishAIGroup()
{
    FinishAIGroup();
    bUsedByMatinee = false;
}

simulated event bool PlayActorFaceFXAnim(FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay)
{
    return Mesh.PlayFaceFXAnim(AnimSet, SeqName, GroupName, SoundCueToPlay, AkEventToPlay);
}

event StopActorFaceFXAnim()
{
    Mesh.StopFaceFXAnim();
}

simulated event AudioComponent GetFaceFXAudioComponent()
{
    return FacialAudioComp;
}

simulated function bool IsActorPlayingFaceFXAnim()
{
    return (Mesh != none) && Mesh.IsPlayingFaceFXAnim();
}

simulated function bool CanActorPlayFaceFXAnim()
{
    return true;
}

simulated function OnPlayFaceFXAnim(SeqAct_PlayFaceFXAnim inAction)
{
    Mesh.PlayFaceFXAnim(inAction.FaceFXAnimSetRef, inAction.FaceFXAnimName, inAction.FaceFXGroupName, inAction.SoundCueToPlay, inAction.AkEventToPlay);
}

simulated function FaceFXAudioFinished(AudioComponent AC);

event FaceFXAsset GetActorFaceFXAsset()
{
    if((Mesh.SkeletalMesh != none) && !Mesh.bDisableFaceFX)
    {
        return Mesh.SkeletalMesh.FaceFXAsset;        
    }
    else
    {
        return none;
    }
}

event SetMorphWeight(name MorphNodeName, float MorphWeight)
{
    MAT_SetMorphWeight(MorphNodeName, MorphWeight);
}

event SetSkelControlScale(name SkelControlName, float Scale)
{
    MAT_SetSkelControlScale(SkelControlName, Scale);
}

simulated event ReplicatedEvent(name VarName)
{
    super.ReplicatedEvent(VarName);
    if(VarName == 'FlashCount')
    {
        FlashCountUpdated(Weapon, FlashCount, true);        
    }
    else
    {
        if(VarName == 'FlashLocation')
        {
            FlashLocationUpdated(Weapon, FlashLocation, true);            
        }
        else
        {
            if(VarName == 'FiringMode')
            {
                FiringModeUpdated(Weapon, FiringMode, true);                
            }
            else
            {
                if(VarName == 'DrivenVehicle')
                {
                    if(DrivenVehicle != none)
                    {
                        NotifyTeamChanged();
                    }                    
                }
                else
                {
                    if(VarName == 'PlayerReplicationInfo')
                    {
                        NotifyTeamChanged();                        
                    }
                    else
                    {
                        if(VarName == 'Controller')
                        {
                            if((Controller != none) && Controller.Pawn == none)
                            {
                                Controller.Pawn = self;
                                if((PlayerController(Controller) != none) && PlayerController(Controller).ViewTarget == Controller)
                                {
                                    PlayerController(Controller).SetViewTarget(self);
                                }
                            }                            
                        }
                        else
                        {
                            if(VarName == 'bUsedByMatinee')
                            {
                                if(bUsedByMatinee)
                                {
                                    BeginAIGroup();                                    
                                }
                                else
                                {
                                    FinishAIGroup();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Export UPawn::execIsAliveAndWell(FFrame&, void* const)
native final simulated function bool IsAliveAndWell();

// Export UPawn::execAdjustDestination(FFrame&, void* const)
native final function Vector AdjustDestination(Actor GoalActor, optional Vector Dest);

// Export UPawn::execValidAnchor(FFrame&, void* const)
native final function bool ValidAnchor();

// Export UPawn::execSuggestJumpVelocity(FFrame&, void* const)
native function bool SuggestJumpVelocity(out Vector JumpVelocity, Vector Destination, Vector Start, optional bool bRequireFallLanding);

// Export UPawn::execGetFallDuration(FFrame&, void* const)
native function float GetFallDuration();

// Export UPawn::execIsValidEnemyTargetFor(FFrame&, void* const)
native function bool IsValidEnemyTargetFor(const PlayerReplicationInfo PRI, bool bNoPRIisEnemy);

// Export UPawn::execIsValidTeamTargetFor(FFrame&, void* const)
native function bool IsValidTeamTargetFor(const PlayerReplicationInfo PRI);

function bool CanAITargetThisPawn(Controller TargetingController)
{
    return true;
}

// Export UPawn::execIsInvisible(FFrame&, void* const)
native function bool IsInvisible();

// Export UPawn::execSetRemoteViewPitch(FFrame&, void* const)
native final function SetRemoteViewPitch(int NewRemoteViewPitch);

// Export UPawn::execSetAnchor(FFrame&, void* const)
native function SetAnchor(NavigationPoint NewAnchor);

// Export UPawn::execGetBestAnchor(FFrame&, void* const)
native function NavigationPoint GetBestAnchor(Actor TestActor, Vector TestLocation, bool bStartPoint, bool bOnlyCheckVisible, out float out_Dist);

// Export UPawn::execReachedDestination(FFrame&, void* const)
native function bool ReachedDestination(Actor Goal);

// Export UPawn::execReachedPoint(FFrame&, void* const)
native function bool ReachedPoint(Vector Point, Actor NewAnchor);

// Export UPawn::execForceCrouch(FFrame&, void* const)
native function ForceCrouch();

// Export UPawn::execSetPushesRigidBodies(FFrame&, void* const)
native function SetPushesRigidBodies(bool NewPush);

// Export UPawn::execReachedDesiredRotation(FFrame&, void* const)
native final function bool ReachedDesiredRotation();

// Export UPawn::execGetBoundingCylinder(FFrame&, void* const)
native function GetBoundingCylinder(out float CollisionRadius, out float CollisionHeight);

// Export UPawn::execInitRagdoll(FFrame&, void* const)
native function bool InitRagdoll();

// Export UPawn::execTermRagdoll(FFrame&, void* const)
native function bool TermRagdoll();

function bool SpecialMoveTo(NavigationPoint Start, NavigationPoint End, Actor Next);

event bool SpecialMoveThruEdge(Pylon.ENavMeshEdgeType EdgeType, int Dir, Vector MoveStart, Vector MoveDest, optional Actor RelActor, optional int RelItem, optional NavigationHandle NavHandle);

simulated function SetBaseEyeheight()
{
    if(!bIsCrouched)
    {
        BaseEyeHeight = default.BaseEyeHeight;        
    }
    else
    {
        BaseEyeHeight = FMin(0.8 * CrouchHeight, CrouchHeight - float(10));
    }
}

function PlayerChangedTeam()
{
    Died(none, Class'DamageType', Location);
}

function Reset()
{
    if((Controller == none) || Controller.bIsPlayer)
    {
        DetachFromController();
        Destroy();        
    }
    else
    {
        super.Reset();
    }
}

function bool StopFiring()
{
    if(Weapon != none)
    {
        Weapon.StopFire(Weapon.CurrentFireMode);
    }
    return true;
}

simulated function StartFire(byte FireModeNum)
{
    if(bNoWeaponFiring)
    {
        return;
    }
    if(Weapon != none)
    {
        Weapon.StartFire(FireModeNum);
    }
}

simulated function StopFire(byte FireModeNum)
{
    if(Weapon != none)
    {
        Weapon.StopFire(FireModeNum);
    }
}

simulated function byte GetWeaponFiringMode(Weapon InWeapon)
{
    return FiringMode;
}

simulated function SetFiringMode(Weapon InWeapon, byte InFiringMode)
{
    if(FiringMode != InFiringMode)
    {
        FiringMode = InFiringMode;
        bForceNetUpdate = true;
        FiringModeUpdated(InWeapon, FiringMode, false);
    }
}

simulated function FiringModeUpdated(Weapon InWeapon, byte InFiringMode, bool bViaReplication)
{
    if(InWeapon != none)
    {
        InWeapon.FireModeUpdated(InFiringMode, bViaReplication);
    }
}

simulated function IncrementFlashCount(Weapon InWeapon, byte InFiringMode)
{
    bForceNetUpdate = true;
    ++ FlashCount;
    if(FlashCount == 0)
    {
        FlashCount += 2;
    }
    SetFiringMode(InWeapon, InFiringMode);
    FlashCountUpdated(InWeapon, FlashCount, false);
}

simulated function FlashCountUpdated(Weapon InWeapon, byte InFlashCount, bool bViaReplication)
{
    if(InFlashCount > 0)
    {
        WeaponFired(InWeapon, bViaReplication);        
    }
    else
    {
        WeaponStoppedFiring(InWeapon, bViaReplication);
    }
}

simulated function ClearFlashCount(Weapon InWeapon)
{
    if(FlashCount != 0)
    {
        bForceNetUpdate = true;
        FlashCount = 0;
        FlashCountUpdated(InWeapon, FlashCount, false);
    }
}

simulated function SetFlashLocation(Weapon InWeapon, byte InFiringMode, Vector NewLoc)
{
    if(NewLoc == LastFiringFlashLocation)
    {
        NewLoc += vect(0, 0, 1);
    }
    if(NewLoc == vect(0, 0, 0))
    {
        NewLoc = vect(0, 0, 1);
    }
    bForceNetUpdate = true;
    FlashLocation = NewLoc;
    LastFiringFlashLocation = NewLoc;
    SetFiringMode(InWeapon, InFiringMode);
    FlashLocationUpdated(InWeapon, FlashLocation, false);
}

function ClearFlashLocation(Weapon InWeapon)
{
    if(!IsZero(FlashLocation))
    {
        bForceNetUpdate = true;
        FlashLocation = vect(0, 0, 0);
        FlashLocationUpdated(InWeapon, FlashLocation, false);
    }
}

simulated function FlashLocationUpdated(Weapon InWeapon, Vector InFlashLocation, bool bViaReplication)
{
    if(!IsZero(InFlashLocation))
    {
        WeaponFired(InWeapon, bViaReplication, InFlashLocation);        
    }
    else
    {
        WeaponStoppedFiring(InWeapon, bViaReplication);
    }
}

simulated function WeaponFired(Weapon InWeapon, bool bViaReplication, optional Vector HitLocation)
{
    ++ ShotCount;
    if(InWeapon != none)
    {
        InWeapon.PlayFireEffects(GetWeaponFiringMode(InWeapon), HitLocation);
    }
}

simulated function WeaponStoppedFiring(Weapon InWeapon, bool bViaReplication)
{
    ShotCount = 0;
    if(InWeapon != none)
    {
        InWeapon.StopFireEffects(GetWeaponFiringMode(InWeapon));
    }
}

function bool BotFire(bool bFinished)
{
    StartFire(0);
    return true;
}

function bool CanAttack(Actor Other)
{
    if(Weapon == none)
    {
        return false;
    }
    return Weapon.CanAttack(Other);
}

function bool TooCloseToAttack(Actor Other)
{
    return false;
}

function bool FireOnRelease()
{
    if(Weapon != none)
    {
        return Weapon.FireOnRelease();
    }
    return false;
}

function bool HasRangedAttack()
{
    return Weapon != none;
}

function bool IsFiring()
{
    if(Weapon != none)
    {
        return Weapon.IsFiring();
    }
    return false;
}

function bool NeedToTurn(Vector targ)
{
    local Vector LookDir, AimDir;

    LookDir = vector(Rotation);
    LookDir.Z = 0;
    LookDir = Normal(LookDir);
    AimDir = targ - Location;
    AimDir.Z = 0;
    AimDir = Normal(AimDir);
    return (LookDir Dot AimDir) < 0.93;
}

simulated function string GetHumanReadableName()
{
    if(PlayerReplicationInfo != none)
    {
        return PlayerReplicationInfo.PlayerName;
    }
    return MenuName;
}

function PlayTeleportEffect(bool bOut, bool bSound)
{
    MakeNoise(1);
}

simulated function NotifyTeamChanged();

function PossessedBy(Controller C, bool bVehicleTransition)
{
    Controller = C;
    NetPriority = 3;
    NetUpdateFrequency = 100;
    bForceNetUpdate = true;
    if(C.PlayerReplicationInfo != none)
    {
        PlayerReplicationInfo = C.PlayerReplicationInfo;
    }
    UpdateControllerOnPossess(bVehicleTransition);
    SetOwner(Controller);
    EyeHeight = BaseEyeHeight;
    if(C.IsA('PlayerController'))
    {
        if(WorldInfo.NetMode != NM_Standalone)
        {
            RemoteRole = ROLE_AutonomousProxy;
        }
        if(Weapon != none)
        {
            Weapon.ClientWeaponSet(false);
        }        
    }
    else
    {
        RemoteRole = default.RemoteRole;
    }
    if(Weapon != none)
    {
        Weapon.CacheAIController();
    }
}

function UpdateControllerOnPossess(bool bVehicleTransition)
{
    if(!bVehicleTransition)
    {
        Controller.SetRotation(Rotation);
    }
}

function UnPossessed()
{
    bForceNetUpdate = true;
    if(DrivenVehicle != none)
    {
        NetUpdateFrequency = 5;
    }
    PlayerReplicationInfo = none;
    SetOwner(none);
    Controller = none;
}

simulated function name GetDefaultCameraMode(PlayerController RequestedBy)
{
    if(((RequestedBy != none) && RequestedBy.PlayerCamera != none) && RequestedBy.PlayerCamera.CameraStyle == 'Fixed')
    {
        return 'Fixed';
    }
    return 'FirstPerson';
}

function DropToGround()
{
    bCollideWorld = true;
    if(Health > 0)
    {
        SetCollision(true, true);
        SetPhysics(2);
        if(IsHumanControlled())
        {
            Controller.GotoState(LandMovementState);
        }
    }
}

function bool CanGrabLadder()
{
    return ((bCanClimbLadders && Controller != none) && Physics != 9) && (Physics != 2) || Abs(Velocity.Z) <= JumpZ;
}

function bool RecommendLongRangedAttack()
{
    return false;
}

function float RangedAttackTime()
{
    return 0;
}

event SetWalking(bool bNewIsWalking)
{
    if(bNewIsWalking != bIsWalking)
    {
        bIsWalking = bNewIsWalking;
    }
}

simulated function bool CanSplash()
{
    if((((WorldInfo.TimeSeconds - SplashTime) > 0.15) && (Physics == 2) || Physics == 4) && Abs(Velocity.Z) > float(100))
    {
        SplashTime = WorldInfo.TimeSeconds;
        return true;
    }
    return false;
}

function EndClimbLadder(LadderVolume OldLadder)
{
    if(Controller != none)
    {
        Controller.EndClimbLadder();
    }
    if(Physics == 9)
    {
        SetPhysics(2);
    }
}

function ClimbLadder(LadderVolume L)
{
    OnLadder = L;
    SetRotation(OnLadder.WallDir);
    SetPhysics(9);
    if(IsHumanControlled())
    {
        Controller.GotoState('PlayerClimbing');
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local string T;
    local Canvas Canvas;
    local AnimTree AnimTreeRootNode;
    local int I;

    Canvas = HUD.Canvas;
    if(PlayerReplicationInfo == none)
    {
        Canvas.DrawText("NO PLAYERREPLICATIONINFO", false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);        
    }
    else
    {
        PlayerReplicationInfo.DisplayDebug(HUD, out_YL, out_YPos);
    }
    super.DisplayDebug(HUD, out_YL, out_YPos);
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawText("Health " $ string(Health));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(HUD.ShouldDisplayDebug('AI'))
    {
        Canvas.DrawText((((("Anchor " $ string(Anchor)) $ " Serpentine Dist ") $ string(SerpentineDist)) $ " Time ") $ string(SerpentineTime));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Physics'))
    {
        T = (((("Floor " $ string(Floor)) $ " DesiredSpeed ") $ string(DesiredSpeed)) $ " Crouched ") $ string(bIsCrouched);
        if((OnLadder != none) || Physics == 9)
        {
            T = (T $ " on ladder ") $ string(OnLadder);
        }
        Canvas.DrawText(T);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        T = "Collision Component:" @ string(CollisionComponent);
        Canvas.DrawText(T);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        T = "bForceMaxAccel:" @ string(bForceMaxAccel);
        Canvas.DrawText(T);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        if(Mesh != none)
        {
            T = (("RootMotionMode:" @ string(Mesh.RootMotionMode)) @ "RootMotionVelocity:") @ string(Mesh.RootMotionVelocity);
            Canvas.DrawText(T);
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('Camera'))
    {
        Canvas.DrawText((("EyeHeight " $ string(EyeHeight)) $ " BaseEyeHeight ") $ string(BaseEyeHeight));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    if(Controller == none)
    {
        Canvas.SetDrawColor(255, 0, 0);
        Canvas.DrawText("NO CONTROLLER");
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        HUD.PlayerOwner.DisplayDebug(HUD, out_YL, out_YPos);        
    }
    else
    {
        Controller.DisplayDebug(HUD, out_YL, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Weapon'))
    {
        if(Weapon == none)
        {
            Canvas.SetDrawColor(0, 255, 0);
            Canvas.DrawText("NO WEAPON");
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);            
        }
        else
        {
            Weapon.DisplayDebug(HUD, out_YL, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('animation'))
    {
        if((Mesh != none) && Mesh.Animations != none)
        {
            AnimTreeRootNode = AnimTree(Mesh.Animations);
            if(AnimTreeRootNode != none)
            {
                Canvas.DrawText("AnimGroups count:" @ string(AnimTreeRootNode.AnimGroups.Length));
                out_YPos += out_YL;
                Canvas.SetPos(4, out_YPos);
                I = 0;
                J0xA55:

                if(I < AnimTreeRootNode.AnimGroups.Length)
                {
                    Canvas.DrawText(((((" GroupName:" @ string(AnimTreeRootNode.AnimGroups[I].GroupName)) @ "NodeCount:") @ string(AnimTreeRootNode.AnimGroups[I].SeqNodes.Length)) @ "RateScale:") @ string(AnimTreeRootNode.AnimGroups[I].RateScale));
                    out_YPos += out_YL;
                    Canvas.SetPos(4, out_YPos);
                    ++ I;
                    goto J0xA55;
                }
            }
        }
    }
}

// Export UPawn::execIsHumanControlled(FFrame&, void* const)
native final simulated function bool IsHumanControlled(optional Controller PawnController);

// Export UPawn::execIsLocallyControlled(FFrame&, void* const)
native final simulated function bool IsLocallyControlled();

// Export UPawn::execIsPlayerPawn(FFrame&, void* const)
native simulated function bool IsPlayerPawn();

simulated function bool IsFirstPerson()
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    return (PC != none) && PC.UsingFirstPersonCamera();
}

simulated function ProcessViewRotation(float DeltaTime, out Rotator out_ViewRotation, out Rotator out_DeltaRot)
{
    out_ViewRotation += out_DeltaRot;
    out_DeltaRot = rot(0, 0, 0);
    if(PlayerController(Controller) != none)
    {
        out_ViewRotation = PlayerController(Controller).LimitViewRotation(out_ViewRotation, ViewPitchMin, ViewPitchMax);
    }
}

simulated event GetActorEyesViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    out_Location = GetPawnViewLocation();
    out_Rotation = GetViewRotation();
}

// Export UPawn::execGetViewRotation(FFrame&, void* const)
native simulated event Rotator GetViewRotation();

// Export UPawn::execGetPawnViewLocation(FFrame&, void* const)
native simulated event Vector GetPawnViewLocation();

simulated event Vector GetWeaponStartTraceLocation(optional Weapon CurrentWeapon)
{
    local Vector POVLoc;
    local Rotator POVRot;

    if(Controller != none)
    {
        Controller.GetPlayerViewPoint(POVLoc, POVRot);
        return POVLoc;
    }
    return GetPawnViewLocation();
}

singular simulated event Rotator GetBaseAimRotation()
{
    local Vector POVLoc;
    local Rotator POVRot;

    if((Controller != none) && !InFreeCam())
    {
        Controller.GetPlayerViewPoint(POVLoc, POVRot);
        return POVRot;
    }
    POVRot = Rotation;
    if(POVRot.Pitch == 0)
    {
        POVRot.Pitch = RemoteViewPitch << 8;
    }
    return POVRot;
}

simulated event bool InFreeCam()
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    return ((PC != none) && PC.PlayerCamera != none) && (PC.PlayerCamera.CameraStyle == 'FreeCam') || PC.PlayerCamera.CameraStyle == 'FreeCam_Default';
}

simulated function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    if((Controller == none) || Role < ROLE_Authority)
    {
        return GetBaseAimRotation();
    }
    return Controller.GetAdjustedAimFor(W, StartFireLoc);
}

simulated function SetViewRotation(Rotator NewRotation)
{
    if(Controller != none)
    {
        Controller.SetRotation(NewRotation);        
    }
    else
    {
        SetRotation(NewRotation);
    }
}

function bool InGodMode()
{
    return (Controller != none) && Controller.bGodMode;
}

function SetMoveTarget(Actor NewTarget)
{
    if(Controller != none)
    {
        Controller.MoveTarget = NewTarget;
    }
}

function bool LineOfSightTo(Actor Other)
{
    return (Controller != none) && Controller.LineOfSightTo(Other);
}

function HandlePickup(Inventory Inv)
{
    MakeNoise(0.2);
    if(Controller != none)
    {
        Controller.HandlePickup(Inv);
    }
}

event ClientMessage(coerce string S, optional name Type)
{
    if(PlayerController(Controller) != none)
    {
        PlayerController(Controller).ClientMessage(S, Type);
    }
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    if(Role == ROLE_Authority)
    {
        Health = -1;
        Died(none, dmgType, Location);
        if(dmgType == none)
        {
            SetPhysics(0);
            SetHidden(true);
            LifeSpan = FMin(LifeSpan, 1);
        }
    }
}

singular simulated event OutsideWorldBounds()
{
    if((Role == ROLE_Authority) && PlayerController(Controller) == none)
    {
        Destroy();        
    }
    else
    {
        if(Role == ROLE_Authority)
        {
            KilledBy(self);
        }
        SetPhysics(ROLE_None);
        SetHidden(true);
        LifeSpan = FMin(LifeSpan, 1);
    }
}

simulated function UnCrouch()
{
    if(bIsCrouched || bWantsToCrouch)
    {
        ShouldCrouch(false);
    }
}

function ShouldCrouch(bool bCrouch)
{
    bWantsToCrouch = bCrouch;
}

simulated event EndCrouch(float HeightAdjust)
{
    EyeHeight -= HeightAdjust;
    SetBaseEyeheight();
}

simulated event StartCrouch(float HeightAdjust)
{
    EyeHeight += HeightAdjust;
    SetBaseEyeheight();
}

function HandleMomentum(Vector Momentum, Vector HitLocation, class<DamageType> DamageType, optional TraceHitInfo HitInfo)
{
    AddVelocity(Momentum, HitLocation, DamageType, HitInfo);
}

function AddVelocity(Vector NewVelocity, Vector HitLocation, class<DamageType> DamageType, optional TraceHitInfo HitInfo)
{
    if(bIgnoreForces || NewVelocity == vect(0, 0, 0))
    {
        return;
    }
    if((Physics == 1) || ((Physics == 9) || Physics == 8) && NewVelocity.Z > default.JumpZ)
    {
        SetPhysics(2);
    }
    if((Velocity.Z > default.JumpZ) && NewVelocity.Z > float(0))
    {
        NewVelocity.Z *= 0.5;
    }
    Velocity += NewVelocity;
}

function KilledBy(Pawn EventInstigator)
{
    local Controller Killer;

    Health = 0;
    if(EventInstigator != none)
    {
        Killer = EventInstigator.Controller;
        LastHitBy = none;
    }
    Died(Killer, Class'DmgType_Suicided', Location);
}

function TakeFallingDamage()
{
    local float EffectiveSpeed;

    if(Velocity.Z < (-0.5 * MaxFallSpeed))
    {
        if(Role == ROLE_Authority)
        {
            MakeNoise(1);
            if(Velocity.Z < (float(-1) * MaxFallSpeed))
            {
                EffectiveSpeed = Velocity.Z;
                if(TouchingWaterVolume())
                {
                    EffectiveSpeed += float(100);
                }
                if(EffectiveSpeed < (float(-1) * MaxFallSpeed))
                {
                    TakeDamage(int((float(-100) * (EffectiveSpeed + MaxFallSpeed)) / MaxFallSpeed), none, Location, vect(0, 0, 0), Class'DmgType_Fell');
                }
            }
        }        
    }
    else
    {
        if(Velocity.Z < (-1.4 * JumpZ))
        {
            MakeNoise(0.5);            
        }
        else
        {
            if(Velocity.Z < (-0.8 * JumpZ))
            {
                MakeNoise(0.2);
            }
        }
    }
}

function Restart();

simulated function ClientRestart()
{
    ZeroMovementVariables();
    SetBaseEyeheight();
}

function ClientSetRotation(Rotator NewRotation)
{
    if(Controller != none)
    {
        Controller.ClientSetRotation(NewRotation);
    }
}

final simulated event UpdatePawnRotation(Rotator NewRotation)
{
    FaceRotation(NewRotation, 0);
}

simulated function FaceRotation(Rotator NewRotation, float DeltaTime)
{
    if(!InFreeCam())
    {
        if(Physics == 9)
        {
            NewRotation = OnLadder.WallDir;            
        }
        else
        {
            if((Physics == 1) || Physics == 2)
            {
                NewRotation.Pitch = 0;
            }
        }
        SetRotation(NewRotation);
    }
}

event bool EncroachingOn(Actor Other)
{
    if(Other.bWorldGeometry || Other.bBlocksTeleport)
    {
        return true;
    }
    if(((Controller == none) || !Controller.bIsPlayer) && Pawn(Other) != none)
    {
        return true;
    }
    return false;
}

event EncroachedBy(Actor Other)
{
    if((Pawn(Other) != none) && Vehicle(Other) == none)
    {
        gibbedBy(Other);
    }
}

function gibbedBy(Actor Other)
{
    if(Role < ROLE_Authority)
    {
        return;
    }
    if(Pawn(Other) != none)
    {
        Died(Pawn(Other).Controller, Class'DmgType_Telefragged', Location);        
    }
    else
    {
        Died(none, Class'DmgType_Telefragged', Location);
    }
}

function JumpOffPawn()
{
    Velocity += ((float(100) + CylinderComponent.CollisionRadius) * VRand());
    if(VSize2D(Velocity) > FMax(500, GroundSpeed))
    {
        Velocity = FMax(500, GroundSpeed) * Normal(Velocity);
    }
    Velocity.Z = 200 + CylinderComponent.CollisionHeight;
    SetPhysics(2);
}

event StuckOnPawn(Pawn OtherPawn);

singular event BaseChange()
{
    local DynamicSMActor Dyn;

    if((Pawn(Base) != none) && (DrivenVehicle == none) || !DrivenVehicle.IsBasedOn(Base))
    {
        if(!Pawn(Base).CanBeBaseForPawn(self))
        {
            Pawn(Base).CrushedBy(self);
            JumpOffPawn();
        }
    }
    Dyn = DynamicSMActor(Base);
    if((Dyn != none) && !Dyn.CanBasePawn(self))
    {
        JumpOffPawn();
    }
}

simulated function bool CanBeBaseForPawn(Pawn aPawn)
{
    return bCanBeBaseForPawns;
}

function CrushedBy(Pawn OtherPawn)
{
    TakeDamage(int(((float(1) - (OtherPawn.Velocity.Z / float(400))) * OtherPawn.Mass) / Mass), OtherPawn.Controller, Location, vect(0, 0, 0), Class'DmgType_Crushed');
}

function DetachFromController(optional bool bDestroyController)
{
    local Controller OldController;

    if((Controller != none) && Controller.Pawn == self)
    {
        OldController = Controller;
        Controller.PawnDied(self);
        if(Controller != none)
        {
            Controller.UnPossess();
        }
        if(((bDestroyController && OldController != none) && !OldController.bDeleteMe) && !OldController.bIsPlayer)
        {
            OldController.Destroy();
        }
        Controller = none;
    }
}

simulated event Destroyed()
{
    DetachFromController();
    if(InvManager != none)
    {
        InvManager.Destroy();
    }
    if(WorldInfo.NetMode == NM_Client)
    {
        return;
    }
    SetAnchor(none);
    Weapon = none;
    ClearPathStep();
    super.Destroyed();
}

simulated event PreBeginPlay()
{
    if(HealthMax == 0)
    {
        HealthMax = default.Health;
    }
    super.PreBeginPlay();
    Instigator = self;
    SetDesiredRotation(Rotation);
    EyeHeight = BaseEyeHeight;
}

event PostBeginPlay()
{
    super.PostBeginPlay();
    SplashTime = 0;
    SpawnTime = WorldInfo.TimeSeconds;
    EyeHeight = BaseEyeHeight;
    if((WorldInfo.bStartup && Health > 0) && !bDontPossess)
    {
        SpawnDefaultController();
    }
    if(FacialAudioComp != none)
    {
        FacialAudioComp.__OnAudioFinished__Delegate = FaceFXAudioFinished;
    }
    if(((Role == ROLE_Authority) && InvManager == none) && InventoryManagerClass != none)
    {
        InvManager = Spawn(InventoryManagerClass, self);
        if(InvManager == none)
        {
            LogInternal(((("Warning! Couldn't spawn InventoryManager" @ string(InventoryManagerClass)) @ "for") @ string(self)) @ (GetHumanReadableName()));            
        }
        else
        {
            InvManager.SetupFor(self);
        }
    }
    ClearPathStep();
}

function SpawnDefaultController()
{
    if(Controller != none)
    {
        LogInternal((("SpawnDefaultController" @ string(self)) @ ", Controller != None") @ string(Controller));
        return;
    }
    if(ControllerClass != none)
    {
        Controller = Spawn(ControllerClass);
    }
    if(Controller != none)
    {
        Controller.Possess(self, false);
    }
}

simulated event ReceivedNewEvent(SequenceEvent Evt)
{
    if(Controller != none)
    {
        Controller.ReceivedNewEvent(Evt);
    }
    super.ReceivedNewEvent(Evt);
}

function OnAssignController(SeqAct_AssignController inAction)
{
    if(inAction.ControllerClass != none)
    {
        if(Controller != none)
        {
            DetachFromController(true);
        }
        Controller = Spawn(inAction.ControllerClass);
        Controller.Possess(self, false);
        if(Controller.IsA('AIController'))
        {
            ControllerClass = class<AIController>(Controller.Class);
        }        
    }
    else
    {
        WarnInternal("Assign controller w/o a class specified!");
    }
}

simulated function OnGiveInventory(SeqAct_GiveInventory inAction)
{
    local int Idx;
    local class<Inventory> InvClass;

    if(inAction.bClearExisting)
    {
        InvManager.DiscardInventory();
    }
    if(inAction.InventoryList.Length > 0)
    {
        Idx = 0;
        J0x71:

        if(Idx < inAction.InventoryList.Length)
        {
            InvClass = inAction.InventoryList[Idx];
            if(InvClass != none)
            {
                if(FindInventoryType(InvClass, false) == none)
                {
                    CreateInventory(InvClass);
                }                
            }
            else
            {
                inAction.ScriptLog("WARNING: Attempting to give NULL inventory!");
            }
            ++ Idx;
            goto J0x71;
        }        
    }
    else
    {
        inAction.ScriptLog("WARNING: Give Inventory without any inventory specified!");
    }
}

function Gasp();

function SetMovementPhysics()
{
    if(PhysicsVolume.bWaterVolume)
    {
        SetPhysics(3);        
    }
    else
    {
        if(Physics != 2)
        {
            SetPhysics(2);
        }
    }
}

function AdjustDamage(out int InDamage, out Vector Momentum, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, TraceHitInfo HitInfo, Actor DamageCauser);

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    bCanRepairArmor = true;
    bMessageHealer = true;
    if((Health > 0) && Health < HealthMax)
    {
        Health = Min(HealthMax, Health + Amount);
        return true;        
    }
    else
    {
        return false;
    }
}

function PruneDamagedBoneList(out array<name> Bones);

event bool TakeRadiusDamageOnBones(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, array<name> Bones)
{
    local int Idx;
    local TraceHitInfo HitInfo;
    local bool bResult;
    local float DamageScale, Dist;
    local Vector Dir, BoneLoc;

    PruneDamagedBoneList(Bones);
    Idx = 0;
    J0x1E:

    if(Idx < Bones.Length)
    {
        HitInfo.BoneName = Bones[Idx];
        HitInfo.HitComponent = Mesh;
        BoneLoc = Mesh.GetBoneLocation(Bones[Idx]);
        Dir = BoneLoc - HurtOrigin;
        Dist = VSize(Dir);
        Dir = Normal(Dir);
        if(bFullDamage)
        {
            DamageScale = 1;            
        }
        else
        {
            DamageScale = 1 - (Dist / DamageRadius);
        }
        if(DamageScale > 0)
        {
            TakeDamage(int(DamageScale * BaseDamage), InstigatedBy, BoneLoc, (DamageScale * Momentum) * Dir, DamageType, HitInfo, DamageCauser);
        }
        bResult = true;
        ++ Idx;
        goto J0x1E;
    }
    return bResult;
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum, Actor DamageCauser)
{
    if(Controller != none)
    {
        Controller.NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
    }
}

function Controller SetKillInstigator(Controller InstigatedBy, class<DamageType> DamageType)
{
    if((InstigatedBy != none) && InstigatedBy != Controller)
    {
        return InstigatedBy;        
    }
    else
    {
        if(DamageType.default.bCausedByWorld && LastHitBy != none)
        {
            return LastHitBy;
        }
    }
    return InstigatedBy;
}

event TakeDamage(int Damage, Controller InstigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int actualDamage;
    local PlayerController PC;
    local Controller Killer;

    if((Role < ROLE_Authority) || Health <= 0)
    {
        return;
    }
    if(DamageType == none)
    {
        if(InstigatedBy == none)
        {
            WarnInternal("No damagetype for damage with no instigator");            
        }
        else
        {
            WarnInternal((("No damagetype for damage by " $ string(InstigatedBy.Pawn)) $ " with weapon ") $ string(InstigatedBy.Pawn.Weapon));
        }
        DamageType = Class'DamageType';
    }
    Damage = Max(Damage, 0);
    if((Physics == 0) && DrivenVehicle == none)
    {
        SetMovementPhysics();
    }
    if((Physics == 1) && DamageType.default.bExtraMomentumZ)
    {
        Momentum.Z = FMax(Momentum.Z, 0.4 * VSize(Momentum));
    }
    Momentum = Momentum / Mass;
    if(DrivenVehicle != none)
    {
        DrivenVehicle.AdjustDriverDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType);
    }
    actualDamage = Damage;
    WorldInfo.Game.ReduceDamage(actualDamage, self, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser);
    AdjustDamage(actualDamage, Momentum, InstigatedBy, HitLocation, DamageType, HitInfo, DamageCauser);
    super.TakeDamage(actualDamage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    Health -= actualDamage;
    if(HitLocation == vect(0, 0, 0))
    {
        HitLocation = Location;
    }
    if(Health <= 0)
    {
        PC = PlayerController(Controller);
        if(PC != none)
        {
            PC.ClientPlayForceFeedbackWaveform(DamageType.default.KilledFFWaveform);
        }
        Killer = SetKillInstigator(InstigatedBy, DamageType);
        TearOffMomentum = Momentum;
        Died(Killer, DamageType, HitLocation);        
    }
    else
    {
        HandleMomentum(Momentum, HitLocation, DamageType, HitInfo);
        NotifyTakeHit(InstigatedBy, HitLocation, actualDamage, DamageType, Momentum, DamageCauser);
        if(DrivenVehicle != none)
        {
            DrivenVehicle.NotifyDriverTakeHit(InstigatedBy, HitLocation, actualDamage, DamageType, Momentum);
        }
        if((InstigatedBy != none) && InstigatedBy != Controller)
        {
            LastHitBy = InstigatedBy;
        }
    }
    PlayHit(float(actualDamage), InstigatedBy, HitLocation, DamageType, Momentum, HitInfo);
    MakeNoise(1, 'TakeDamage');
}

// Export UPawn::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

simulated function TeamInfo GetTeam()
{
    if((Controller != none) && Controller.PlayerReplicationInfo != none)
    {
        return Controller.PlayerReplicationInfo.Team;        
    }
    else
    {
        if(PlayerReplicationInfo != none)
        {
            return PlayerReplicationInfo.Team;            
        }
        else
        {
            if((DrivenVehicle != none) && DrivenVehicle.PlayerReplicationInfo != none)
            {
                return DrivenVehicle.PlayerReplicationInfo.Team;                
            }
            else
            {
                return none;
            }
        }
    }
}

simulated event bool IsSameTeam(Pawn Other)
{
    return ((Other != none) && Other.GetTeam() != none) && Other.GetTeam() == (GetTeam());
}

function ThrowWeaponOnDeath()
{
    ThrowActiveWeapon();
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local SeqAct_Latent Action;

    if(DamageType == none)
    {
        DamageType = Class'DamageType';
    }
    if((bDeleteMe || WorldInfo.Game == none) || WorldInfo.Game.bLevelChange)
    {
        return false;
    }
    if((DamageType.default.bCausedByWorld && (Killer == none) || Killer == Controller) && LastHitBy != none)
    {
        Killer = LastHitBy;
    }
    if(WorldInfo.Game.PreventDeath(self, Killer, DamageType, HitLocation))
    {
        Health = Max(Health, 1);
        return false;
    }
    Health = Min(0, Health);
    if(default.KismetDeathDelayTime > float(0))
    {
        DelayTriggerDeath();        
    }
    else
    {
        TriggerEventClass(Class'SeqEvent_Death', self);
    }
    KismetDeathDelayTime = default.KismetDeathDelayTime + WorldInfo.TimeSeconds;
    foreach LatentActions(Action,)
    {
        Action.AbortFor(self);        
    }    
    LatentActions.Length = 0;
    if(DrivenVehicle != none)
    {
        Velocity = DrivenVehicle.Velocity;
        DrivenVehicle.DriverDied(DamageType);        
    }
    else
    {
        if(Weapon != none)
        {
            Weapon.HolderDied();
            ThrowWeaponOnDeath();
        }
    }
    if(Controller != none)
    {
        WorldInfo.Game.Killed(Killer, Controller, self, DamageType);        
    }
    else
    {
        WorldInfo.Game.Killed(Killer, Controller(Owner), self, DamageType);
    }
    DrivenVehicle = none;
    if(InvManager != none)
    {
        InvManager.OwnerDied();
    }
    if(IsHumanControlled())
    {
        PlayerController(Controller).ForceDeathUpdate();
    }
    NetUpdateFrequency = default.NetUpdateFrequency;
    PlayDying(DamageType, HitLocation);
    return true;
}

function DelayTriggerDeath()
{
    TriggerEventClass(Class'SeqEvent_Death', self);
}

event Falling();

event Landed(Vector HitNormal, Actor FloorActor)
{
    TakeFallingDamage();
    if(Health > 0)
    {
        PlayLanded(Velocity.Z);
    }
    LastHitBy = none;
}

event TickSpecial(float DeltaTime);

event HeadVolumeChange(PhysicsVolume newHeadVolume)
{
    if((WorldInfo.NetMode == NM_Client) || Controller == none)
    {
        return;
    }
    if((HeadVolume != none) && HeadVolume.bWaterVolume)
    {
        if(!newHeadVolume.bWaterVolume)
        {
            if((Controller.bIsPlayer && BreathTime > float(0)) && BreathTime < float(8))
            {
                Gasp();
            }
            BreathTime = -1;
        }        
    }
    else
    {
        if(newHeadVolume.bWaterVolume)
        {
            BreathTime = UnderWaterTime;
        }
    }
}

function bool TouchingWaterVolume()
{
    local PhysicsVolume V;

    foreach TouchingActors(Class'PhysicsVolume', V)
    {
        if(V.bWaterVolume)
        {            
            return true;
        }        
    }    
    return false;
}

event BreathTimer()
{
    if(HeadVolume.bWaterVolume)
    {
        if(((Health < 0) || WorldInfo.NetMode == NM_Client) || DrivenVehicle != none)
        {
            return;
        }
        TakeDrowningDamage();
        if(Health > 0)
        {
            BreathTime = 2;
        }        
    }
    else
    {
        BreathTime = 0;
    }
}

function TakeDrowningDamage();

function bool CheckWaterJump(out Vector WallNormal)
{
    local Actor HitActor;
    local Vector HitLocation, HitNormal, Checkpoint, Start, checkNorm, Extent;

    if(AIController(Controller) != none)
    {
        if((Controller.InLatentExecution(Controller.503) && Controller.MoveTarget != none) && !Controller.MoveTarget.PhysicsVolume.bWaterVolume)
        {
            Checkpoint = Normal(Controller.MoveTarget.Location - Location);            
        }
        else
        {
            Checkpoint = Acceleration;
        }
        Checkpoint.Z = 0;
    }
    if(Checkpoint == vect(0, 0, 0))
    {
        Checkpoint = vector(Rotation);
    }
    Checkpoint.Z = 0;
    checkNorm = Normal(Checkpoint);
    Checkpoint = Location + ((1.2 * CylinderComponent.CollisionRadius) * checkNorm);
    Extent = CylinderComponent.CollisionRadius * vect(1, 1, 0);
    Extent.Z = CylinderComponent.CollisionHeight;
    HitActor = Trace(HitLocation, HitNormal, Checkpoint, Location, true, Extent,, 8);
    if((HitActor != none) && Pawn(HitActor) == none)
    {
        WallNormal = float(-1) * HitNormal;
        Start = Location;
        Start.Z += MaxOutOfWaterStepHeight;
        Checkpoint = Start + ((3.2 * CylinderComponent.CollisionRadius) * WallNormal);
        HitActor = Trace(HitLocation, HitNormal, Checkpoint, Start, true,,, 8);
        if((HitActor == none) || HitNormal.Z > 0.7)
        {
            return true;
        }
    }
    return false;
}

function bool DoJump(bool bUpdating)
{
    if(((bJumpCapable && !bIsCrouched) && !bWantsToCrouch) && ((Physics == 1) || Physics == 9) || Physics == 8)
    {
        if(Physics == 8)
        {
            Velocity = Velocity + (JumpZ * Floor);            
        }
        else
        {
            if(Physics == 9)
            {
                Velocity.Z = 0;                
            }
            else
            {
                if(bIsWalking)
                {
                    Velocity.Z = default.JumpZ;                    
                }
                else
                {
                    Velocity.Z = JumpZ;
                }
            }
        }
        if(((Base != none) && !Base.bWorldGeometry) && Base.Velocity.Z > 0)
        {
            Velocity.Z += Base.Velocity.Z;
        }
        SetPhysics(2);
        return true;
    }
    return false;
}

function PlayDyingSound();

function PlayHit(float Damage, Controller InstigatedBy, Vector HitLocation, class<DamageType> DamageType, Vector Momentum, TraceHitInfo HitInfo)
{
    if((Damage <= float(0)) && (Controller == none) || !Controller.bGodMode)
    {
        return;
    }
    LastPainTime = WorldInfo.TimeSeconds;
}

simulated function TurnOff()
{
    if(Role == ROLE_Authority)
    {
        RemoteRole = ROLE_SimulatedProxy;
    }
    if((WorldInfo.NetMode != NM_DedicatedServer) && Mesh != none)
    {
        Mesh.bPauseAnims = true;
        if(Physics == 10)
        {
            Mesh.PhysicsWeight = 1;
            Mesh.bUpdateKinematicBonesFromAnimation = false;
        }
    }
    SetCollision(true, false);
    bNoWeaponFiring = true;
    Velocity = vect(0, 0, 0);
    SetPhysics(0);
    bIgnoreForces = true;
    if(Weapon != none)
    {
        Weapon.StopFire(Weapon.CurrentFireMode);
    }
}

function SetDyingPhysics()
{
    if(Physics != 10)
    {
        SetPhysics(2);
    }
}

simulated function PlayDying(class<DamageType> DamageType, Vector HitLoc)
{
    GotoState('Dying');
    bReplicateMovement = false;
    bTearOff = true;
    Velocity += TearOffMomentum;
    SetDyingPhysics();
    bPlayedDeath = true;
    KismetDeathDelayTime = default.KismetDeathDelayTime + WorldInfo.TimeSeconds;
}

simulated event TornOff()
{
    if(!bPlayedDeath)
    {
        PlayDying(HitDamageType, TakeHitLocation);
    }
}

event PlayFootStepSound(int FootDown);

function bool CannotJumpNow()
{
    return false;
}

function PlayLanded(float ImpactVel);

// Export UPawn::execGetVehicleBase(FFrame&, void* const)
native function Vehicle GetVehicleBase();

function Suicide()
{
    KilledBy(self);
}

simulated function bool CanThrowWeapon()
{
    return (Weapon != none) && Weapon.CanThrow();
}

simulated event StartDriving(Vehicle V)
{
    StopFiring();
    if(Health <= 0)
    {
        return;
    }
    DrivenVehicle = V;
    bForceNetUpdate = true;
    ShouldCrouch(false);
    bIgnoreForces = true;
    bCanTeleport = false;
    BreathTime = 0;
    V.AttachDriver(self);
}

simulated event StopDriving(Vehicle V)
{
    if(Mesh != none)
    {
        Mesh.SetCullDistance(default.Mesh.CachedMaxDrawDistance);
        Mesh.SetShadowParent(none);
    }
    bForceNetUpdate = true;
    if(V != none)
    {
        V.StopFiring();
    }
    if(Physics == 10)
    {
        return;
    }
    DrivenVehicle = none;
    bIgnoreForces = false;
    SetHardAttach(false);
    bCanTeleport = true;
    bCollideWorld = true;
    if(V != none)
    {
        V.DetachDriver(self);
    }
    SetCollision(true, true);
    if(Role == ROLE_Authority)
    {
        if(PhysicsVolume.bWaterVolume && Health > 0)
        {
            SetPhysics(3);            
        }
        else
        {
            SetPhysics(2);
        }
        SetBase(none);
        SetHidden(false);
    }
}

function AddDefaultInventory();

final event Inventory CreateInventory(class<Inventory> NewInvClass, optional bool bDoNotActivate)
{
    if(InvManager != none)
    {
        return InvManager.CreateInventory(NewInvClass, bDoNotActivate);
    }
    return none;
}

final simulated function Inventory FindInventoryType(class<Inventory> DesiredClass, optional bool bAllowSubclass)
{
    return ((InvManager != none) ? InvManager.FindInventoryType(DesiredClass, bAllowSubclass) : none);
}

simulated function DrawHUD(HUD H)
{
    if(InvManager != none)
    {
        InvManager.DrawHUD(H);
    }
}

function ThrowActiveWeapon(optional bool bDestroyWeap)
{
    if(Weapon != none)
    {
        TossInventory(Weapon);
    }
}

function TossInventory(Inventory Inv, optional Vector ForceVelocity)
{
    local Vector POVLoc, TossVel;
    local Rotator POVRot;
    local Vector X, Y, Z;

    if(ForceVelocity != vect(0, 0, 0))
    {
        TossVel = ForceVelocity;        
    }
    else
    {
        GetActorEyesViewPoint(POVLoc, POVRot);
        TossVel = vector(POVRot);
        TossVel = (TossVel * ((Velocity Dot TossVel) + float(500))) + vect(0, 0, 200);
    }
    GetAxes(Rotation, X, Y, Z);
    Inv.DropFrom((Location + ((0.8 * CylinderComponent.CollisionRadius) * X)) - ((0.5 * CylinderComponent.CollisionRadius) * Y), TossVel);
}

simulated function SetActiveWeapon(Weapon NewWeapon)
{
    if(InvManager != none)
    {
        InvManager.SetCurrentWeapon(NewWeapon);
    }
}

simulated function PlayWeaponSwitch(Weapon OldWeapon, Weapon NewWeapon);

function bool CheatWalk()
{
    UnderWaterTime = default.UnderWaterTime;
    SetCollision(true, true);
    SetPhysics(2);
    bCollideWorld = true;
    SetPushesRigidBodies(default.bPushesRigidBodies);
    return true;
}

function bool CheatGhost()
{
    UnderWaterTime = -1;
    SetCollision(false, false);
    bCollideWorld = false;
    SetPushesRigidBodies(false);
    return true;
}

function bool CheatFly()
{
    UnderWaterTime = default.UnderWaterTime;
    SetCollision(true, true);
    bCollideWorld = true;
    return true;
}

simulated function float GetCollisionRadius()
{
    return ((CylinderComponent != none) ? CylinderComponent.CollisionRadius : 0);
}

simulated function float GetCollisionHeight()
{
    return ((CylinderComponent != none) ? CylinderComponent.CollisionHeight : 0);
}

final simulated function Vector GetCollisionExtent()
{
    local Vector Extent;

    Extent = (GetCollisionRadius()) * vect(1, 1, 0);
    Extent.Z = GetCollisionHeight();
    return Extent;
}

function bool IsStationary()
{
    return false;
}

event SpawnedByKismet()
{
    if(Controller != none)
    {
        Controller.SpawnedByKismet();
    }
}

function DoKismetAttachment(Actor Attachment, SeqAct_AttachToActor Action)
{
    local bool bOldCollideActors, bOldBlockActors, bValidBone, bValidSocket;

    if((Mesh != none) && Action.BoneName != 'None')
    {
        bValidSocket = Mesh.GetSocketByName(Action.BoneName) != none;
        bValidBone = Mesh.MatchRefBone(Action.BoneName) != -1;
        if(!bValidBone && !bValidSocket)
        {
            LogInternal((((((((string(WorldInfo.TimeSeconds) @ string(Class)) @ string(GetFuncName())) @ "bone or socket") @ string(Action.BoneName)) @ "not found on actor") @ string(self)) @ "with mesh") @ string(Mesh));
        }
    }
    if(bValidBone || bValidSocket)
    {
        bOldCollideActors = Attachment.bCollideActors;
        bOldBlockActors = Attachment.bBlockActors;
        Attachment.SetCollision(false, false);
        Attachment.SetHardAttach(Action.bHardAttach);
        if(bValidBone && !bValidSocket)
        {
            if(Action.bUseRelativeOffset)
            {
                Attachment.SetLocation(Mesh.GetBoneLocation(Action.BoneName));
            }
            if(Action.bUseRelativeRotation)
            {
                Attachment.SetRotation(QuatToRotator(Mesh.GetBoneQuaternion(Action.BoneName)));
            }
        }
        Attachment.SetBase(self,, Mesh, Action.BoneName);
        if(Action.bUseRelativeRotation)
        {
            Attachment.SetRelativeRotation(Attachment.RelativeRotation + Action.RelativeRotation);
        }
        if(Action.bUseRelativeOffset)
        {
            Attachment.SetRelativeLocation(Attachment.RelativeLocation + Action.RelativeOffset);
        }
        Attachment.SetCollision(bOldCollideActors, bOldBlockActors);        
    }
    else
    {
        super.DoKismetAttachment(Attachment, Action);
    }
}

function float GetDamageScaling()
{
    return DamageScaling;
}

function OnSetMaterial(SeqAct_SetMaterial Action)
{
    if(Mesh != none)
    {
        Mesh.SetMaterial(Action.MaterialIndex, Action.NewMaterial);
    }
}

simulated function OnTeleport(SeqAct_Teleport Action)
{
    local array<Object> objVars;

    Action.GetObjectVars(objVars, "Destination");
    if(!HandleTeleport(objVars, Action.bUpdateRotation, Action.bCheckOverlap,, Action.TeleportVolumes))
    {
        WarnInternal("failed to handle teleport kismet action properly" @ string(Action));
    }
}

simulated function bool HandleTeleport(array<Object> DestList, bool bUpdateRotation, bool bCheckOverlap, optional float TeleportDistance, optional array<Volume> TeleportVolumes, optional int PreferredDestIndex)
{
    local int Idx, Cnt;
    local Actor destActor, tempActor, A;
    local Controller C;
    local bool bOccupiedDest, bColliding;
    local Vector Extent;

    Extent = GetCollisionExtent();
    bOccupiedDest = false;
    if(DestList.Length > 0)
    {
        Idx = ((PreferredDestIndex >= 0) ? PreferredDestIndex : 0);
        if(Idx >= DestList.Length)
        {
            Idx = 0;
            PreferredDestIndex = 0;
        }
        Cnt = 0;
        J0x91:

        tempActor = Actor(DestList[Idx]);
        if(tempActor != none)
        {
            C = Controller(tempActor);
            if((C != none) && C.Pawn != none)
            {
                tempActor = C.Pawn;
            }
            if(bCheckOverlap)
            {
                bColliding = false;
                foreach VisibleCollidingActors(Class'Actor', A, Extent.X * 2, tempActor.Location, false, Extent, true)
                {
                    if(IsBlockedBy(A))
                    {
                        bColliding = true;
                        break;
                    }                    
                }                
                bOccupiedDest = bColliding;
            }
            destActor = tempActor;
            if((!bCheckOverlap || !bOccupiedDest) && destActor != none)
            {
                goto J0x2AB;
            }
        }
        ++ Idx;
        if(Idx >= DestList.Length)
        {
            Idx = 0;
        }
        ++ Cnt;
        if(!((Idx == PreferredDestIndex) || Cnt >= DestList.Length))
            goto J0x91;
        J0x2AB:
        
    }
    else
    {
        WarnInternal("Unable to teleport - no destination list given");
    }
    if((destActor != none) && Class'SeqAct_Teleport'.static.ShouldTeleport(self, destActor.Location, TeleportDistance, TeleportVolumes))
    {
        if(SetLocation(destActor.Location))
        {
            if(!IsLocallyControlled() && PlayerController(Controller) != none)
            {
                PlayerController(Controller).ClientSetLocation(destActor.Location, Rotation);
            }
            PlayTeleportEffect(false, true);
            if(bUpdateRotation)
            {
                SetRotation(destActor.Rotation);
                if(Controller != none)
                {
                    Controller.SetRotation(destActor.Rotation);
                    Controller.ClientSetRotation(destActor.Rotation);
                }
            }
            if(Controller != none)
            {
                Controller.OnTeleport(none);
            }
            return true;
        }
        WarnInternal("Unable to teleport to" @ string(destActor));
        return false;
    }
    if(destActor == none)
    {
        WarnInternal("Unable to teleport - no destination given");
        return false;
    }
    return true;
}

final event MessagePlayer(coerce string msg)
{
    local PlayerController PC;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        PC.ClientMessage(msg);        
    }    
}

simulated event BecomeViewTarget(PlayerController PC)
{
    if(PhysicsVolume != none)
    {
        PhysicsVolume.NotifyPawnBecameViewTarget(self, PC);
    }
    if(!bReplicateHealthToAll && WorldInfo.NetMode != NM_Client)
    {
        PC.ForceSingleNetUpdateFor(self);
    }
}

event SoakPause()
{
    local PlayerController PC;

    foreach WorldInfo.LocalPlayerControllers(Class'PlayerController', PC)
    {
        PC.SoakPause(self);
        break;        
    }    
}

// Export UPawn::execClearConstraints(FFrame&, void* const)
native function ClearConstraints();

// Export UPawn::execAddPathConstraint(FFrame&, void* const)
native function AddPathConstraint(PathConstraint Constraint);

// Export UPawn::execAddGoalEvaluator(FFrame&, void* const)
native function AddGoalEvaluator(PathGoalEvaluator Evaluator);

function PathConstraint CreatePathConstraint(class<PathConstraint> ConstraintClass)
{
    return new (self) ConstraintClass;
}

function PathGoalEvaluator CreatePathGoalEvaluator(class<PathGoalEvaluator> GoalEvalClass)
{
    return new (self) GoalEvalClass;
}

// Export UPawn::execIncrementPathStep(FFrame&, void* const)
native function IncrementPathStep(int Cnt, Canvas C);

// Export UPawn::execIncrementPathChild(FFrame&, void* const)
native function IncrementPathChild(int Cnt, Canvas C);

// Export UPawn::execDrawPathStep(FFrame&, void* const)
native function DrawPathStep(Canvas C);

// Export UPawn::execClearPathStep(FFrame&, void* const)
native function ClearPathStep();

simulated function ZeroMovementVariables()
{
    Velocity = vect(0, 0, 0);
    Acceleration = vect(0, 0, 0);
}

simulated function SetCinematicMode(bool bInCinematicMode);

// Export UPawn::execSetRootMotionInterpCurrentTime(FFrame&, void* const)
native function SetRootMotionInterpCurrentTime(float inTime, optional float DeltaTime, optional bool bUpdateSkelPose);

// Export UPawn::execSetScalarParameterInterp(FFrame&, void* const)
native final simulated function SetScalarParameterInterp(const out ScalarParameterInterpStruct ScalarParameterInterp);

simulated event Speak(SoundCue Cue)
{
    PlaySound(Cue, true);
}

simulated function OnSetVelocity(SeqAct_SetVelocity Action)
{
    super.OnSetVelocity(Action);
    if(Action.VelocityMag == float(0))
    {
        Acceleration = vect(0, 0, 0);        
    }
    else
    {
        Acceleration = Velocity / 0.2;
    }
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels);

state Dying
{
    ignores Bump, HitWall, HeadVolumeChange, PhysicsVolumeChange, Falling, BreathTimer, 
	    FellOutOfWorld, PlayWeaponSwitch, PlayNextAnimation, BaseChange, Landed, 
	    Died;

    singular simulated event OutsideWorldBounds()
    {
        SetPhysics(0);
        SetHidden(true);
        LifeSpan = FMin(LifeSpan, 1);
    }

    event Timer()
    {
        if(!PlayerCanSeeMe())
        {
            Destroy();            
        }
        else
        {
            SetTimer(2, false);
        }
    }

    event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
    {
        SetPhysics(2);
        if((Physics == 0) && Momentum.Z < float(0))
        {
            Momentum.Z *= float(-1);
        }
        Velocity += ((float(3) * Momentum) / (Mass + float(200)));
        if(DamageType == none)
        {
            DamageType = Class'DamageType';
        }
        Health -= Damage;
    }

    event BeginState(name PreviousStateName)
    {
        local Actor A;
        local array<SequenceEvent> TouchEvents;
        local int I;

        if(bTearOff && WorldInfo.NetMode == NM_DedicatedServer)
        {
            LifeSpan = 2;            
        }
        else
        {
            SetTimer(5, false);
            LifeSpan = 25;
        }
        SetDyingPhysics();
        SetCollision(true, false);
        if(Controller != none)
        {
            if(Controller.bIsPlayer)
            {
                DetachFromController();                
            }
            else
            {
                DetachFromController(true);
            }
        }
        foreach TouchingActors(Class'Actor', A)
        {
            if(A.FindEventsOfClass(Class'SeqEvent_Touch', TouchEvents))
            {
                I = 0;
                J0x116:

                if(I < TouchEvents.Length)
                {
                    SeqEvent_Touch(TouchEvents[I]).NotifyTouchingPawnDied(self);
                    ++ I;
                    goto J0x116;
                }
                TouchEvents.Length = 0;
            }            
        }        
        foreach BasedActors(Class'Actor', A)
        {
            A.PawnBaseDied();            
        }        
    }
Begin:

    Sleep(0.2);
    PlayDyingSound();
    stop;        
}

defaultproperties
{
    MaxStepHeight=35
    MaxJumpHeight=96
    WalkableFloorZ=0.7
    LedgeCheckThreshold=4
    bJumpCapable=true
    bCanJump=true
    bCanWalk=true
    bAllowLedgeOverhang=true
    bSimulateGravity=true
    bLOSHearing=true
    bModifyNavPointDest=true
    bLimitFallAccel=true
    WalkingPhysics=EPhysics.PHYS_Walking
    CrouchHeight=40
    CrouchRadius=34
    NonPreferredVehiclePathMultiplier=1
    DesiredSpeed=1
    MaxDesiredSpeed=1
    HearingThreshold=2800
    SightRadius=5000
    AvgPhysicsTime=0.1
    Mass=100
    MaxPitchLimit=3072
    GroundSpeed=600
    WaterSpeed=300
    AirSpeed=600
    LadderSpeed=200
    AccelRate=2048
    JumpZ=420
    OutofWaterZ=420
    MaxOutOfWaterStepHeight=40
    AirControl=0.05
    WalkingPct=0.5
    MovementSpeedModifier=1
    CrouchedPct=0.5
    MaxFallSpeed=1200
    AIMaxFallSpeedFactor=1
    BaseEyeHeight=64
    EyeHeight=54
    Health=100
    noise1time=-10
    noise2time=-10
    SoundDampening=1
    DamageScaling=1
    ControllerClass=Class'AIController'
    LandMovementState=PlayerWalking
    WaterMovementState=PlayerSwimming
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=78
        CollisionRadius=34
        ReplacementPrimitive=none
        CollideActors=true
        BlockActors=true
    object end
    // Reference: CylinderComponent'Default__Pawn.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    RBPushRadius=10
    RBPushStrength=50
    VehicleCheckRadius=150
    ViewPitchMin=-16384
    ViewPitchMax=16383
    AllowedYawError=2000
    InventoryManagerClass=Class'InventoryManager'
    RootMotionInterpRate=1
    begin object name=Sprite class=SpriteComponent
        SpriteCategoryName=Pawns
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__Pawn.Sprite'
    Components(0)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=78
        CollisionRadius=34
        ReplacementPrimitive=none
        CollideActors=true
        BlockActors=true
    object end
    // Reference: CylinderComponent'Default__Pawn.CollisionCylinder'
    Components(1)=CollisionCylinder
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(B=255,G=200,R=150,A=255)
        bTreatAsASprite=true
        SpriteCategoryName=Pawns
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__Pawn.Arrow'
    Components(2)=Arrow
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bUpdateSimulatedPosition=true
    bCanBeDamaged=true
    bShouldBaseAtStartup=true
    bCanTeleport=true
    bCollideActors=true
    bCollideWorld=true
    bBlockActors=true
    bProjTarget=true
    NetPriority=2
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=78
        CollisionRadius=34
        ReplacementPrimitive=none
        CollideActors=true
        BlockActors=true
    object end
    // Reference: CylinderComponent'Default__Pawn.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    RotationRate=(Pitch=20000,Yaw=20000,Roll=20000)
}