/*******************************************************************************
 * InventoryManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class InventoryManager extends Actor
    native
    notplaceable
    hidecategories(Navigation);

var Inventory InventoryChain;
var Weapon PendingWeapon;
var Weapon LastAttemptedSwitchToWeapon;
var bool bMustHoldWeapon;
var private array<int> PendingFire;

replication
{
     if((((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty) && bNetOwner)
        InventoryChain;
}

event PostBeginPlay()
{
    super.PostBeginPlay();
    Instigator = Pawn(Owner);
}

simulated function int GetPendingFireLength(Weapon InWeapon)
{
    return PendingFire.Length;
}

simulated function SetPendingFire(Weapon InWeapon, int InFiringMode)
{
    if(InFiringMode < PendingFire.Length)
    {
        PendingFire[InFiringMode] = 1;
    }
}

simulated function ClearPendingFire(Weapon InWeapon, int InFiringMode)
{
    if(InFiringMode < PendingFire.Length)
    {
        PendingFire[InFiringMode] = 0;
    }
}

final simulated function bool IsPendingFire(Weapon InWeapon, int InFiringMode)
{
    return bool(PendingFire[InFiringMode]);
}

simulated function ClearAllPendingFire(Weapon InWeapon)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PendingFire.Length)
    {
        PendingFire[I] = 0;
        ++ I;
        goto J0x0B;
    }
}

// Export UInventoryManager::execInventoryActors(FFrame&, void* const)
native final iterator function InventoryActors(class<Inventory> BaseClass, out Inventory Inv);

function SetupFor(Pawn P)
{
    Instigator = P;
    SetOwner(P);
}

event Destroyed()
{
    DiscardInventory();
}

function bool HandlePickupQuery(class<Inventory> ItemClass, Actor Pickup)
{
    local Inventory Inv;

    if(InventoryChain == none)
    {
        return true;
    }
    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Inv.DenyPickupQuery(ItemClass, Pickup))
        {            
            return false;
        }        
    }    
    return true;
}

simulated event Inventory FindInventoryType(class<Inventory> DesiredClass, optional bool bAllowSubclass)
{
    local Inventory Inv;

    foreach InventoryActors(DesiredClass, Inv)
    {
        if(bAllowSubclass || Inv.Class == DesiredClass)
        {            
            return Inv;
        }        
    }    
    return none;
}

simulated function Inventory CreateInventory(class<Inventory> NewInventoryItemClass, optional bool bDoNotActivate)
{
    local Inventory Inv;

    if(NewInventoryItemClass != none)
    {
        Inv = Spawn(NewInventoryItemClass, Owner);
        if(Inv != none)
        {
            if(!AddInventory(Inv, bDoNotActivate))
            {
                WarnInternal("InventoryManager::CreateInventory - Couldn't Add newly created inventory" @ string(Inv));
                Inv.Destroy();
                Inv = none;
            }            
        }
        else
        {
            WarnInternal("InventoryManager::CreateInventory - Couldn't spawn inventory" @ string(NewInventoryItemClass));
        }
    }
    return Inv;
}

simulated function bool AddInventory(Inventory NewItem, optional bool bDoNotActivate)
{
    local Inventory Item, LastItem;

    if((NewItem != none) && !NewItem.bDeleteMe)
    {
        if(InventoryChain == none)
        {
            InventoryChain = NewItem;            
        }
        else
        {
            Item = InventoryChain;
            J0x6E:

            if(Item != none)
            {
                if(Item == NewItem)
                {
                    return false;
                }
                LastItem = Item;
                Item = Item.Inventory;
                goto J0x6E;
            }
            LastItem.Inventory = NewItem;
        }
        LogInternal(((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "adding") @ string(NewItem)) @ "bDoNotActivate:") @ string(bDoNotActivate), 'Inventory');
        NewItem.SetOwner(Instigator);
        NewItem.Instigator = Instigator;
        NewItem.InvManager = self;
        NewItem.GivenTo(Instigator, bDoNotActivate);
        Instigator.TriggerEventClass(Class'SeqEvent_GetInventory', NewItem);
        return true;
    }
    return false;
}

simulated function RemoveFromInventory(Inventory ItemToRemove)
{
    local Inventory Item;
    local bool bFound;

    if(ItemToRemove != none)
    {
        if(InventoryChain == ItemToRemove)
        {
            bFound = true;
            InventoryChain = ItemToRemove.Inventory;            
        }
        else
        {
            Item = InventoryChain;
            J0x70:

            if(Item != none)
            {
                if(Item.Inventory == ItemToRemove)
                {
                    bFound = true;
                    Item.Inventory = ItemToRemove.Inventory;
                    goto J0x122;
                }
                Item = Item.Inventory;
                goto J0x70;
            }
        }
        J0x122:

        if(bFound)
        {
            ItemToRemove.ItemRemovedFromInvManager();
            ItemToRemove.SetOwner(none);
            ItemToRemove.Inventory = none;
        }
        if(ItemToRemove == Instigator.Weapon)
        {
            Instigator.Weapon = none;
        }
        if((Instigator.Health > 0) && Instigator.Weapon == none)
        {
            if((PendingWeapon != none) && PendingWeapon != ItemToRemove)
            {
                LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Removed current weapon while changing weapons, call ChangedWeapon", 'Inventory');
                ChangedWeapon();                
            }
            else
            {
                if(Instigator.Controller != none)
                {
                    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Calling ClientSwitchToBestWeapon to make sure a weapon is brought up", 'Inventory');
                    Instigator.Controller.ClientSwitchToBestWeapon(true);
                }
            }
        }
    }
}

simulated event DiscardInventory()
{
    local Inventory Inv;
    local Vector TossVelocity;
    local bool bBelowKillZ;

    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
    bBelowKillZ = (Instigator == none) || Instigator.Location.Z < WorldInfo.KillZ;
    foreach InventoryActors(Class'Inventory', Inv)
    {
        if(Inv.bDropOnDeath && !bBelowKillZ)
        {
            TossVelocity = vector(Instigator.GetViewRotation());
            TossVelocity = ((TossVelocity * ((Instigator.Velocity Dot TossVelocity) + 500)) + (250 * VRand())) + vect(0, 0, 250);
            Inv.DropFrom(Instigator.Location, TossVelocity);
            continue;
        }
        Inv.Destroy();        
    }    
    Instigator.Weapon = none;
    PendingWeapon = none;
}

function OwnerDied()
{
    Destroy();
    if(Instigator.InvManager == self)
    {
        Instigator.InvManager = none;
    }
}

simulated function DrawHUD(HUD H);

simulated function float GetWeaponRatingFor(Weapon W)
{
    local float Rating;

    if(!W.HasAnyAmmo())
    {
        return -1;
    }
    if(!Instigator.IsHumanControlled())
    {
        Rating = W.GetAIRating();
        if(((W == Instigator.Weapon) && Instigator.Controller != none) && Instigator.Controller.Enemy != none)
        {
            Rating += 0.21;
        }        
    }
    else
    {
        Rating = 1;
    }
    return Rating;
}

simulated function Weapon GetBestWeapon(optional bool bForceADifferentWeapon, optional bool allow9mm)
{
    local Weapon W, BestWeapon;
    local float Rating, BestRating;

    foreach InventoryActors(Class'Weapon', W)
    {
        if(W.HasAnyAmmo())
        {
            if(bForceADifferentWeapon && W == Instigator.Weapon)
            {
                continue;                
            }
            Rating = W.GetWeaponRating();
            if((BestWeapon == none) || Rating > BestRating)
            {
                BestWeapon = W;
                BestRating = Rating;
            }
        }        
    }    
    return BestWeapon;
}

simulated function SwitchToBestWeapon(optional bool bForceADifferentWeapon, optional bool check_9mm_logic)
{
    local Weapon BestWeapon;

    check_9mm_logic = false;
    LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "bForceADifferentWeapon:") @ string(bForceADifferentWeapon), 'Inventory');
    if((bForceADifferentWeapon || PendingWeapon == none) || AIController(Instigator.Controller) != none)
    {
        BestWeapon = GetBestWeapon(bForceADifferentWeapon);
        if(BestWeapon == none)
        {
            return;
        }
        if(BestWeapon == Instigator.Weapon)
        {
            BestWeapon = none;
            PendingWeapon = none;
            Instigator.Weapon.Activate();
        }
    }
    Instigator.Controller.StopFiring();
    SetCurrentWeapon(BestWeapon);
}

simulated function PrevWeapon()
{
    local Weapon CandidateWeapon, StartWeapon, W;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(W == StartWeapon)
        {
            break;
        }
        CandidateWeapon = W;        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            CandidateWeapon = W;            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

simulated function NextWeapon()
{
    local Weapon StartWeapon, CandidateWeapon, W;
    local bool bBreakNext;

    StartWeapon = Instigator.Weapon;
    if(PendingWeapon != none)
    {
        StartWeapon = PendingWeapon;
    }
    foreach InventoryActors(Class'Weapon', W)
    {
        if(bBreakNext || StartWeapon == none)
        {
            CandidateWeapon = W;
            break;
        }
        if(W == StartWeapon)
        {
            bBreakNext = true;
        }        
    }    
    if(CandidateWeapon == none)
    {
        foreach InventoryActors(Class'Weapon', W)
        {
            CandidateWeapon = W;
            break;            
        }        
    }
    if(CandidateWeapon == Instigator.Weapon)
    {
        return;
    }
    SetCurrentWeapon(CandidateWeapon);
}

reliable client simulated function SetCurrentWeapon(Weapon DesiredWeapon)
{
    InternalSetCurrentWeapon(DesiredWeapon);
    if(Role < ROLE_Authority)
    {
        ServerSetCurrentWeapon(DesiredWeapon);
    }
}

reliable server function ServerSetCurrentWeapon(Weapon DesiredWeapon)
{
    InternalSetCurrentWeapon(DesiredWeapon);
}

private final simulated function InternalSetCurrentWeapon(Weapon DesiredWeapon)
{
    local Weapon PrevWeapon;

    PrevWeapon = Instigator.Weapon;
    LogInternal(((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PrevWeapon:") @ string(PrevWeapon)) @ "DesiredWeapon:") @ string(DesiredWeapon), 'Inventory');
    if(((PrevWeapon != none) && DesiredWeapon == PrevWeapon) && !PrevWeapon.IsInState('WeaponPuttingDown'))
    {
        if(!DesiredWeapon.IsInState('Inactive') && !DesiredWeapon.IsInState('PendingClientWeaponSet'))
        {
            LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "DesiredWeapon == PrevWeapon - abort") @ string(DesiredWeapon.GetStateName()), 'Inventory');
            return;
        }
    }
    SetPendingWeapon(DesiredWeapon);
    if((((PrevWeapon != none) && PrevWeapon != DesiredWeapon) && !PrevWeapon.bDeleteMe) && !PrevWeapon.IsInState('Inactive'))
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Try to put down previous weapon first.", 'Inventory');
        PrevWeapon.TryPutDown();        
    }
    else
    {
        ChangedWeapon();
    }
}

simulated function SetPendingWeapon(Weapon DesiredWeapon)
{
    LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "SetPendingWeapon to") @ string(DesiredWeapon), 'Inventory');
    PendingWeapon = DesiredWeapon;
}

simulated function bool CancelWeaponChange()
{
    LogInternal((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PendingWeapon:'") $ string(PendingWeapon)) $ "'", 'Inventory');
    if((PendingWeapon == none) && bMustHoldWeapon)
    {
        PendingWeapon = Instigator.Weapon;
    }
    return false;
}

simulated function ClearPendingWeapon()
{
    LogInternal((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PendingWeapon:'") $ string(PendingWeapon)) $ "'", 'Inventory');
    if(PendingWeapon != none)
    {
        PendingWeapon.GotoState('Inactive');
        PendingWeapon = none;
    }
}

simulated function ChangedWeapon()
{
    local Weapon OldWeapon;

    OldWeapon = Instigator.Weapon;
    LogInternal(((((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PendingWeapon:'") $ string(PendingWeapon)) $ "'") @ "bMustHoldWeapon:'") $ string(bMustHoldWeapon)) $ "'", 'Inventory');
    if((PendingWeapon == none) && bMustHoldWeapon)
    {
        if(OldWeapon != none)
        {
            OldWeapon.Activate();
            PendingWeapon = OldWeapon;
        }
    }
    LogInternal(((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "switch from") @ string(OldWeapon)) @ "to") @ string(PendingWeapon), 'Inventory');
    Instigator.Weapon = PendingWeapon;
    Instigator.PlayWeaponSwitch(OldWeapon, PendingWeapon);
    if(PendingWeapon != none)
    {
        PendingWeapon.Instigator = Instigator;
        if(WorldInfo.Game != none)
        {
            Instigator.MakeNoise(0.1, 'ChangedWeapon');
        }
        PendingWeapon.Activate();
        PendingWeapon = none;
    }
    if(Instigator.Controller != none)
    {
        Instigator.Controller.NotifyChangedWeapon(OldWeapon, Instigator.Weapon);
    }
}

simulated function ClientWeaponSet(Weapon NewWeapon, bool bOptionalSet, optional bool bDoNotActivate)
{
    local Weapon OldWeapon;

    LogInternal(((((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "NewWeapon:") @ string(NewWeapon)) @ "bOptionalSet:") @ string(bOptionalSet)) @ "bDoNotActivate:") @ string(bDoNotActivate), 'Inventory');
    if(!bDoNotActivate)
    {
        OldWeapon = Instigator.Weapon;
        if(((OldWeapon == none) || OldWeapon.bDeleteMe) || OldWeapon.IsInState('Inactive'))
        {
            LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "OldWeapon == None or Inactive - Set new weapon right away") @ string(NewWeapon), 'Inventory');
            SetCurrentWeapon(NewWeapon);
            return;
        }
        if(OldWeapon == NewWeapon)
        {
            if(NewWeapon.IsInState('PendingClientWeaponSet'))
            {
                LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "OldWeapon == NewWeapon - but in PendingClientWeaponSet, so reset.") @ string(NewWeapon), 'Inventory');
                SetCurrentWeapon(NewWeapon);                
            }
            else
            {
                LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "OldWeapon == NewWeapon - abort") @ string(NewWeapon), 'Inventory');
            }
            return;
        }
        if(bOptionalSet)
        {
            if(OldWeapon.DenyClientWeaponSet() || Instigator.IsHumanControlled() && PlayerController(Instigator.Controller).bNeverSwitchOnPickup)
            {
                LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "bOptionalSet && (DenyClientWeaponSet() || bNeverSwitchOnPickup) - abort") @ string(NewWeapon), 'Inventory');
                LastAttemptedSwitchToWeapon = NewWeapon;
                return;
            }
        }
        if(((PendingWeapon == none) || !PendingWeapon.HasAnyAmmo()) || PendingWeapon.GetWeaponRating() < NewWeapon.GetWeaponRating())
        {
            if(!Instigator.Weapon.HasAnyAmmo() || Instigator.Weapon.GetWeaponRating() < NewWeapon.GetWeaponRating())
            {
                LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Switch to new weapon:") @ string(NewWeapon), 'Inventory');
                SetCurrentWeapon(NewWeapon);
                return;
            }
        }
    }
    LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Send to inactive state") @ string(NewWeapon), 'Inventory');
    NewWeapon.GotoState('Inactive');
}

simulated function UpdateController()
{
    local Inventory Item;
    local Weapon Weap;

    Item = InventoryChain;
    J0x13:

    if(Item != none)
    {
        Weap = Weapon(Item);
        if(Weap != none)
        {
            Weap.CacheAIController();
        }
        Item = Item.Inventory;
        goto J0x13;
    }
}

defaultproperties
{
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bHidden=true
    bOnlyRelevantToOwner=true
    bReplicateInstigator=true
    bReplicateMovement=false
    bOnlyDirtyReplication=true
    NetPriority=1.4
}