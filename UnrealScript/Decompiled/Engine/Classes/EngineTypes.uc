/*******************************************************************************
 * EngineTypes generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class EngineTypes extends Object
    abstract
    native;

enum EPathFindingError
{
    PATHERROR_STARTPOLYNOTFOUND,
    PATHERROR_GOALPOLYNOTFOUND,
    PATHERROR_ANCHORPYLONNOTFOUND,
    PATHERROR_NOPATHFOUND,
    PATHERROR_COMPUTEVALIDFINALDEST_FAIL,
    PATHERROR_GETNEXTMOVELOCATION_FAIL,
    PATHERROR_MOVETIMEOUT,
    PATHERROR_MAX
};

enum EBlendMode
{
    BLEND_Opaque,
    BLEND_Masked,
    BLEND_Translucent,
    BLEND_Additive,
    BLEND_Modulate,
    BLEND_ModulateAndAdd,
    BLEND_SoftMasked,
    BLEND_AlphaComposite,
    BLEND_DitheredTranslucent,
    BLEND_MAX
};

enum EMaterialLightingModel
{
    MLM_Phong,
    MLM_NonDirectional,
    MLM_Unlit,
    MLM_SHPRT,
    MLM_Custom,
    MLM_Anisotropic,
    MLM_MAX
};

enum EMaterialTessellationMode
{
    MTM_NoTessellation,
    MTM_FlatTessellation,
    MTM_PNTriangles,
    MTM_MAX
};

enum EMobileValueSource
{
    MVS_Constant,
    MVS_VertexColorRed,
    MVS_VertexColorGreen,
    MVS_VertexColorBlue,
    MVS_VertexColorAlpha,
    MVS_BaseTextureRed,
    MVS_BaseTextureGreen,
    MVS_BaseTextureBlue,
    MVS_BaseTextureAlpha,
    MVS_MaskTextureRed,
    MVS_MaskTextureGreen,
    MVS_MaskTextureBlue,
    MVS_MaskTextureAlpha,
    MVS_NormalTextureAlpha,
    MVS_EmissiveTextureRed,
    MVS_EmissiveTextureGreen,
    MVS_EmissiveTextureBlue,
    MVS_EmissiveTextureAlpha,
    MVS_MAX
};

enum EMobileTextureBlendFactorSource
{
    MTBFS_VertexColor,
    MTBFS_MaskTexture,
    MTBFS_MAX
};

enum EMobileTexCoordsSource
{
    MTCS_TexCoords0,
    MTCS_TexCoords1,
    MTCS_TexCoords2,
    MTCS_TexCoords3,
    MTCS_MAX
};

enum EMobileAlphaValueSource
{
    MAVS_DiffuseTextureAlpha,
    MAVS_MaskTextureRed,
    MAVS_MaskTextureGreen,
    MAVS_MaskTextureBlue,
    MAVS_MAX
};

enum EMobileColorMultiplySource
{
    MCMS_None,
    MCMS_BaseTextureRed,
    MCMS_BaseTextureGreen,
    MCMS_BaseTextureBlue,
    MCMS_BaseTextureAlpha,
    MCMS_MaskTextureRed,
    MCMS_MaskTextureGreen,
    MCMS_MaskTextureBlue,
    MCMS_MaskTextureAlpha,
    MCMS_MAX
};

enum EMobileEmissiveColorSource
{
    MECS_EmissiveTexture,
    MECS_BaseTexture,
    MECS_Constant,
    MECS_MAX
};

enum EMobileEnvironmentBlendMode
{
    MEBM_Add,
    MEBM_Lerp,
    MEBM_MAX
};

enum EMobileSpecularMask
{
    MSM_Constant,
    MSM_Luminance,
    MSM_DiffuseRed,
    MSM_DiffuseGreen,
    MSM_DiffuseBlue,
    MSM_DiffuseAlpha,
    MSM_MaskTextureRGB,
    MSM_MaskTextureRed,
    MSM_MaskTextureGreen,
    MSM_MaskTextureBlue,
    MSM_MaskTextureAlpha,
    MSM_MAX
};

enum EMobileAmbientOcclusionSource
{
    MAOS_Disabled,
    MAOS_VertexColorRed,
    MAOS_VertexColorGreen,
    MAOS_VertexColorBlue,
    MAOS_VertexColorAlpha,
    MAOS_MAX
};

enum ELightingBuildQuality
{
    Quality_Preview,
    Quality_Medium,
    Quality_High,
    Quality_Production,
    Quality_NoGlobalIllumination,
    Quality_MAX
};

enum EPrecomputedVisibilityBuildType
{
    BuildType_IncrementalBuild,
    BuildType_FullRebuild,
    BuildType_DoNotBuild,
    BuildType_MAX
};

struct native SubtitleCue
{
    /** The text too appear in the subtitle. */
    var() const localized string Text;
    /** The time at which the subtitle is to be displayed, in seconds relative to the beginning of the line. */
    var() const localized float Time;

    structdefaultproperties
    {
        Text=""
        Time=0
    }
};

struct native LocalizedSubtitle
{
    var string LanguageExt;
    var array<SubtitleCue> Subtitles;
    var bool bMature;
    var bool bManualWordWrap;
    var bool bSingleLine;

    structdefaultproperties
    {
        LanguageExt=""
        Subtitles=none
        bMature=false
        bManualWordWrap=false
        bSingleLine=false
    }
};

struct LightMapRef
{
    var private native const Pointer Reference;
};

struct native DominantShadowInfo
{
    var Matrix WorldToLight;
    var Matrix LightToWorld;
    var Box LightSpaceImportanceBounds;
    var int ShadowMapSizeX;
    var int ShadowMapSizeY;

    structdefaultproperties
    {
        WorldToLight=(XPlane=(W=0,X=0,Y=0,Z=0),YPlane=(W=0,X=0,Y=0,Z=0),ZPlane=(W=0,X=0,Y=0,Z=0),WPlane=(W=0,X=0,Y=0,Z=0))
        LightToWorld=(XPlane=(W=0,X=0,Y=0,Z=0),YPlane=(W=0,X=0,Y=0,Z=0),ZPlane=(W=0,X=0,Y=0,Z=0),WPlane=(W=0,X=0,Y=0,Z=0))
        LightSpaceImportanceBounds=(Min=(X=0,Y=0,Z=0),Max=(X=0,Y=0,Z=0),IsValid=0)
        ShadowMapSizeX=0
        ShadowMapSizeY=0
    }
};

struct native LightmassLightSettings
{
    /** Scale factor for the indirect lighting */
    var(General) float IndirectLightingScale<UIMin=0.0|UIMax=4.0>;
    /** 0 will be completely desaturated, 1 will be unchanged */
    var(General) float IndirectLightingSaturation<UIMin=0.0|UIMax=4.0>;
    /** Controls the falloff of shadow penumbras */
    var(General) float ShadowExponent<UIMin=0.1|UIMax=4.0>;

    structdefaultproperties
    {
        IndirectLightingScale=1
        IndirectLightingSaturation=1
        ShadowExponent=2
    }
};

struct native LightmassPointLightSettings extends LightmassLightSettings
{
    /** The radius of the light's emissive surface, not the light's influence. */
    var(Point) float LightSourceRadius<UIMin=8.0|UIMax=1024.0>;

    structdefaultproperties
    {
        LightSourceRadius=100
        IndirectLightingScale=0
        IndirectLightingSaturation=0
        ShadowExponent=0
    }
};

struct native LightmassDirectionalLightSettings extends LightmassLightSettings
{
    /** Angle that the directional light's emissive surface extends relative to a receiver, affects penumbra sizes. */
    var(Directional) float LightSourceAngle;

    structdefaultproperties
    {
        LightSourceAngle=3
        IndirectLightingScale=0
        IndirectLightingSaturation=0
        ShadowExponent=0
    }
};

struct LightmassPrimitiveSettings
{
    /** If TRUE, this object will be lit as if it receives light from both sides of its polygons. */
    var() bool bUseTwoSidedLighting;
    /** If TRUE, this object will only shadow indirect lighting. */
    var() bool bShadowIndirectOnly;
    /** If TRUE, allow using the emissive for static lighting. */
    var() bool bUseEmissiveForStaticLighting;
    /** Direct lighting falloff exponent for mesh area lights created from emissive areas on this primitive. */
    var() float EmissiveLightFalloffExponent;
    /**  
     *Direct lighting influence radius.
     *        The default is 0, which means the influence radius should be automatically generated based on the emissive light brightness.
     *        Values greater than 0 override the automatic method.
     */
    var() float EmissiveLightExplicitInfluenceRadius;
    /** Scales the emissive contribution of all materials applied to this object. */
    var() float EmissiveBoost;
    /** Scales the diffuse contribution of all materials applied to this object. */
    var() float DiffuseBoost;
    var float SpecularBoost;
    /** Fraction of samples taken that must be occluded in order to reach full occlusion. */
    var() float FullyOccludedSamplesFraction;

    structdefaultproperties
    {
        bUseTwoSidedLighting=false
        bShadowIndirectOnly=false
        bUseEmissiveForStaticLighting=false
        EmissiveLightFalloffExponent=2
        EmissiveLightExplicitInfluenceRadius=0
        EmissiveBoost=1
        DiffuseBoost=1
        SpecularBoost=1
        FullyOccludedSamplesFraction=1
    }
};

struct native LightmassDebugOptions
{
    /**  
     *If FALSE, UnrealLightmass.exe is launched automatically (default)
     *               If TRUE, it must be launched manually (e.g. through a debugger) with the -debug command line parameter.
     */
    var() bool bDebugMode;
    /** If TRUE, all participating Lightmass agents will report back detailed stats to the log. */
    var() bool bStatsEnabled;
    /** If TRUE, BSP surfaces split across model components are joined into 1 mapping */
    var() bool bGatherBSPSurfacesAcrossComponents;
    /** The tolerance level used when gathering BSP surfaces. */
    var() float CoplanarTolerance;
    /** If TRUE, deterministic lighting mode will be used. */
    var() bool bUseDeterministicLighting;
    /**  
     *If TRUE, Lightmass will import mappings immediately as they complete.
     *               It will not process them, however.
     */
    var() bool bUseImmediateImport;
    /**  
     *If TRUE, Lightmass will process appropriate mappings as they are imported.
     *               NOTE: Requires ImmediateMode be enabled to actually work.
     */
    var() bool bImmediateProcessMappings;
    /** If TRUE, Lightmass will sort mappings by texel cost. */
    var() bool bSortMappings;
    /** If TRUE, the generate coefficients will be dumped to binary files. */
    var() bool bDumpBinaryFiles;
    /**  
     *If TRUE, Lightmass will write out BMPs for each generated material property
     *               sample to <GAME>\ScreenShots\Materials.
     */
    var() bool bDebugMaterials;
    /** If TRUE, Lightmass will pad the calculated mappings to reduce/eliminate seams. */
    var() bool bPadMappings;
    /**  
     *If TRUE, will fill padding of mappings with a color rather than the sampled edges.
     *               Means nothing if bPadMappings is not enabled...
     */
    var() bool bDebugPaddings;
    /**  
     *If TRUE, only the mapping containing a debug texel will be calculated, all others
     *        will be set to white
     */
    var() bool bOnlyCalcDebugTexelMappings;
    /** If TRUE, color lightmaps a random color */
    var() bool bUseRandomColors;
    /** If TRUE, a green border will be placed around the edges of mappings */
    var() bool bColorBordersGreen;
    /**  
     *If TRUE, Lightmass will overwrite lightmap data with a shade of red relating to
     *        how long it took to calculate the mapping (Red = Time / ExecutionTimeDivisor)
     */
    var() bool bColorByExecutionTime;
    /** The amount of time that will be count as full red when bColorByExecutionTime is enabled */
    var() float ExecutionTimeDivisor;
    var bool bInitialized;

    structdefaultproperties
    {
        bDebugMode=false
        bStatsEnabled=false
        bGatherBSPSurfacesAcrossComponents=true
        CoplanarTolerance=0.001
        bUseDeterministicLighting=true
        bUseImmediateImport=true
        bImmediateProcessMappings=true
        bSortMappings=true
        bDumpBinaryFiles=false
        bDebugMaterials=false
        bPadMappings=true
        bDebugPaddings=false
        bOnlyCalcDebugTexelMappings=false
        bUseRandomColors=false
        bColorBordersGreen=false
        bColorByExecutionTime=false
        ExecutionTimeDivisor=15
        bInitialized=false
    }
};

struct native SwarmDebugOptions
{
    /**  
     *If TRUE, Swarm will distribute jobs.
     *               If FALSE, only the local machine will execute the jobs.
     */
    var() bool bDistributionEnabled;
    /**  
     *If TRUE, Swarm will force content to re-export rather than using the cached version.
     *               If FALSE, Swarm will attempt to use the cached version.
     */
    var() bool bForceContentExport;
    var bool bInitialized;

    structdefaultproperties
    {
        bDistributionEnabled=true
        bForceContentExport=false
        bInitialized=false
    }
};

struct native RootMotionCurve
{
    /** Name of the animation this curve is associated with */
    var() name AnimName;
    /** List of vectors offset from the start of the curve */
    var() InterpCurveVector Curve;
    /** The max input value of the curve */
    var() float MaxCurveTime;

    structdefaultproperties
    {
        AnimName=None
        Curve=(Points=none,InterpMethod=EInterpMethodType.IMT_UseFixedTangentEvalAndNewAutoTangents)
        MaxCurveTime=0
    }
};

struct native PrimitiveMaterialRef
{
    var export editinline PrimitiveComponent Primitive;
    var int MaterialIndex;

    structdefaultproperties
    {
        Primitive=none
        MaterialIndex=0
    }
};

struct native PostProcessMaterialRef
{
    var MaterialEffect Effect;

    structdefaultproperties
    {
        Effect=none
    }
};

struct native MaterialReferenceList
{
    /** used by matinee material parameter tracks to hold material references to modify */
    var() MaterialInterface TargetMaterial;
    var edithide array<PrimitiveMaterialRef> AffectedMaterialRefs;
    var edithide array<PostProcessMaterialRef> AffectedPPChainMaterialRefs;

    structdefaultproperties
    {
        TargetMaterial=none
        AffectedMaterialRefs=none
        AffectedPPChainMaterialRefs=none
    }
};

struct native VelocityObstacleStat
{
    var Vector Position;
    var Vector Velocity;
    var float Radius;
    var int Priority;

    structdefaultproperties
    {
        Position=(X=0,Y=0,Z=0)
        Velocity=(X=0,Y=0,Z=0)
        Radius=0
        Priority=0
    }
};
