/*******************************************************************************
 * Controller generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Controller extends Actor
    abstract
    native(Controller)
    nativereplication
    notplaceable
    hidecategories(Navigation)
    implements(Interface_NavigationHandle);

const LATENT_MOVETOWARD = 503;

struct native VisiblePortalInfo
{
    var Actor Source;
    var Actor Destination;

    structdefaultproperties
    {
        Source=none
        Destination=none
    }
};

var private native const noexport Pointer VfTable_IInterface_NavigationHandle;
var repnotify editinline Pawn Pawn;
var repnotify editinline PlayerReplicationInfo PlayerReplicationInfo;
var const int PlayerNum;
var private const Controller NextController;
var bool bIsPlayer;
var bool bGodMode;
var bool bSoaking;
var bool bSlowerZAcquire;
var bool bNotifyPostLanded;
var bool bNotifyApex;
var bool bOverrideSearchStart;
var bool bAdvancedTactics;
var bool bCanDoSpecial;
var bool bAdjusting;
var bool bPreparingMove;
var bool bForceStrafe;
var const bool bLOSflag;
var bool bSkipExtraLOSChecks;
var bool bNotifyFallingHitWall;
var bool bEarlyOutOfSighTestsForSameType;
var bool bReachedLatentMoveGoal;
var bool bAdjustFromWalls;
var bool bPreciseDestination;
var bool bSeeFriendly;
var bool bUsingPathLanes;
var input byte bFire;
var input byte bAltFire;
var float MinHitWall;
var class<NavigationHandle> NavigationHandleClass;
var editinline NavigationHandle NavigationHandle;
var Vector OverrideSearchStart;
var float MoveTimer;
var Actor MoveTarget;
var BasedPosition DestinationPosition;
var BasedPosition FocalPosition;
var Actor Focus;
var Actor GoalList[4];
var BasedPosition AdjustPosition;
var NavigationPoint StartSpot;
var array<NavigationPoint> RouteCache;
var ReachSpec CurrentPath;
var ReachSpec NextRoutePath;
var Vector CurrentPathDir;
var Actor RouteGoal;
var float RouteDist;
var float LastRouteFind;
var InterpActor PendingMover;
var Actor FailedMoveTarget;
var int MoveFailureCount;
var float GroundPitchTime;
var Pawn ShotTarget;
var const Actor LastFailedReach;
var const float FailedReachTime;
var const Vector FailedReachLocation;
var float SightCounter;
var float SightCounterInterval;
var NavigationPoint LastNavGoalReached;
var float InUseNodeCostMultiplier;
var int HighJumpNodeCostModifier;
var float MaxMoveTowardPawnTargetTime;
var Pawn Enemy;
var array<VisiblePortalInfo> VisiblePortals;
var float LaneOffset;
var const Rotator OldBasedRotation;
var Vector NavMeshPath_SearchExtent_Modifier;

replication
{
     if(bNetDirty && Role == ROLE_Authority)
        Pawn, PlayerReplicationInfo;
}

// Export UController::execIsLocalPlayerController(FFrame&, void* const)
native function bool IsLocalPlayerController();

// Export UController::execIsLocalController(FFrame&, void* const)
native function bool IsLocalController();

// Export UController::execRouteCache_Empty(FFrame&, void* const)
native function RouteCache_Empty();

// Export UController::execRouteCache_AddItem(FFrame&, void* const)
native function RouteCache_AddItem(NavigationPoint Nav);

// Export UController::execRouteCache_InsertItem(FFrame&, void* const)
native function RouteCache_InsertItem(NavigationPoint Nav, optional int Idx)
{
    Idx = 0;                
}

// Export UController::execRouteCache_RemoveItem(FFrame&, void* const)
native function RouteCache_RemoveItem(NavigationPoint Nav);

// Export UController::execRouteCache_RemoveIndex(FFrame&, void* const)
native function RouteCache_RemoveIndex(int InIndex, optional int Count)
{
    Count = 1;                
}

// Export UController::execSetFocalPoint(FFrame&, void* const)
native final function SetFocalPoint(Vector FP, optional bool bOffsetFromBase);

// Export UController::execGetFocalPoint(FFrame&, void* const)
native final function Vector GetFocalPoint();

// Export UController::execSetDestinationPosition(FFrame&, void* const)
native final function SetDestinationPosition(Vector Dest, optional bool bOffsetFromBase);

// Export UController::execGetDestinationPosition(FFrame&, void* const)
native final function Vector GetDestinationPosition();

// Export UController::execSetAdjustLocation(FFrame&, void* const)
native final function SetAdjustLocation(Vector NewLoc, bool bAdjust, optional bool bOffsetFromBase);

// Export UController::execGetAdjustLocation(FFrame&, void* const)
native final function Vector GetAdjustLocation();

event NotifyPathChanged();

event FailedToFindAnchor();

event JumpedOverWall(Vector WallHitNormal, optional Actor Wall);

event NotifyFailMove(string Reason);

event AILog_Internal(coerce string LogText, optional name LogCategory, optional bool bForce, optional bool BugIt, optional bool bSkipExtraInfo);

event PauseAndShowMsg(optional string MsgTxt, optional Vector TeleportToLocation);

simulated event BeginAnimControl(InterpGroup InInterpGroup)
{
    Pawn.BeginAnimControl(InInterpGroup);
}

simulated event SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
    Pawn.SetAnimPosition(SlotName, ChannelIndex, InAnimSeqName, InPosition, bFireNotifies, bLooping, bEnableRootMotion);
}

simulated event FinishAnimControl(InterpGroup InInterpGroup)
{
    Pawn.FinishAnimControl(InInterpGroup);
}

event bool PlayActorFaceFXAnim(FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay)
{
    return Pawn.PlayActorFaceFXAnim(AnimSet, GroupName, SeqName, SoundCueToPlay, AkEventToPlay);
}

event StopActorFaceFXAnim()
{
    Pawn.StopActorFaceFXAnim();
}

event SetMorphWeight(name MorphNodeName, float MorphWeight)
{
    Pawn.SetMorphWeight(MorphNodeName, MorphWeight);
}

event SetSkelControlScale(name SkelControlName, float Scale)
{
    Pawn.SetSkelControlScale(SkelControlName, Scale);
}

event PostBeginPlay()
{
    super.PostBeginPlay();
    if(!bDeleteMe && WorldInfo.NetMode != NM_Client)
    {
        if(bIsPlayer)
        {
            InitPlayerReplicationInfo();
        }
        InitNavigationHandle();
    }
    SightCounter = SightCounterInterval * FRand();
}

function Reset()
{
    super.Reset();
    Enemy = none;
    StartSpot = none;
    bAdjusting = false;
    bPreparingMove = false;
    MoveTimer = -1;
    MoveTarget = none;
    CurrentPath = none;
    RouteGoal = none;
}

reliable client simulated function ClientSetLocation(Vector NewLocation, Rotator NewRotation)
{
    SetRotation(NewRotation);
    if(Pawn != none)
    {
        if((Rotation.Pitch > Pawn.MaxPitchLimit) && Rotation.Pitch < (65536 - Pawn.MaxPitchLimit))
        {
            if(Rotation.Pitch < 32768)
            {
                NewRotation.Pitch = Pawn.MaxPitchLimit;                
            }
            else
            {
                NewRotation.Pitch = 65536 - Pawn.MaxPitchLimit;
            }
        }
        NewRotation.Roll = 0;
        Pawn.SetRotation(NewRotation);
        Pawn.SetLocation(NewLocation);
    }
}

reliable client simulated function ClientSetRotation(Rotator NewRotation, optional bool bResetCamera)
{
    SetRotation(NewRotation);
    if(Pawn != none)
    {
        NewRotation.Pitch = 0;
        NewRotation.Roll = 0;
        Pawn.SetRotation(NewRotation);
    }
}

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'PlayerReplicationInfo')
    {
        if(PlayerReplicationInfo != none)
        {
            PlayerReplicationInfo.ClientInitialize(self);
        }        
    }
    else
    {
        super.ReplicatedEvent(VarName);
    }
}

function OnPossess(SeqAct_Possess inAction)
{
    local Pawn OldPawn;
    local Vehicle V;

    V = Vehicle(Pawn);
    if(inAction.bTryToLeaveVehicle && V != none)
    {
        V.DriverLeave(true);
    }
    if(inAction.PawnToPossess != none)
    {
        V = Vehicle(inAction.PawnToPossess);
        if((Pawn != none) && V != none)
        {
            V.TryToDrive(Pawn);            
        }
        else
        {
            OldPawn = Pawn;
            UnPossess();
            Possess(inAction.PawnToPossess, false);
            if(inAction.bKillOldPawn && OldPawn != none)
            {
                OldPawn.Destroy();
            }
        }
    }
}

event Possess(Pawn inPawn, bool bVehicleTransition)
{
    if(inPawn.Controller != none)
    {
        inPawn.Controller.UnPossess();
    }
    inPawn.PossessedBy(self, bVehicleTransition);
    Pawn = inPawn;
    SetFocalPoint(Pawn.Location + (float(512) * vector(Pawn.Rotation)), true);
    Restart(bVehicleTransition);
    if(Pawn.Weapon == none)
    {
        ClientSwitchToBestWeapon();
    }
}

event UnPossess()
{
    if(Pawn != none)
    {
        Pawn.UnPossessed();
        Pawn = none;
    }
}

function PawnDied(Pawn inPawn)
{
    local int Idx;

    if(inPawn != Pawn)
    {
        return;
    }
    TriggerEventClass(Class'SeqEvent_Death', self);
    Idx = 0;
    J0x3B:

    if(Idx < LatentActions.Length)
    {
        if(LatentActions[Idx] != none)
        {
            LatentActions[Idx].AbortFor(self);
        }
        ++ Idx;
        goto J0x3B;
    }
    LatentActions.Length = 0;
    if(Pawn != none)
    {
        SetLocation(Pawn.Location);
        Pawn.UnPossessed();
    }
    Pawn = none;
    if(bIsPlayer)
    {
        if(!GamePlayEndedState())
        {
            GotoState('Dead');
        }        
    }
    else
    {
        Destroy();
    }
}

function bool GamePlayEndedState()
{
    return false;
}

event NotifyPostLanded();

event Destroyed()
{
    if(Role == ROLE_Authority)
    {
        if(bIsPlayer && WorldInfo.Game != none)
        {
            WorldInfo.Game.Logout(self);
        }
        if(PlayerReplicationInfo != none)
        {
            if(!PlayerReplicationInfo.bOnlySpectator && PlayerReplicationInfo.Team != none)
            {
                PlayerReplicationInfo.Team.RemoveFromTeam(self);
            }
            CleanupPRI();
        }
    }
    super.Destroyed();
}

function CleanupPRI()
{
    PlayerReplicationInfo.Destroy();
    PlayerReplicationInfo = none;
}

function Restart(bool bVehicleTransition)
{
    Pawn.Restart();
    if(!bVehicleTransition)
    {
        Enemy = none;
    }
    if((bVehicleTransition == false) && Pawn.InvManager != none)
    {
        Pawn.InvManager.UpdateController();
    }
}

// Export UController::execBeyondFogDistance(FFrame&, void* const)
native final function bool BeyondFogDistance(Vector ViewPoint, Vector OtherPoint);

function EnemyJustTeleported()
{
    LineOfSightTo(Enemy);
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum);

function InitPlayerReplicationInfo()
{
    PlayerReplicationInfo = Spawn(WorldInfo.Game.PlayerReplicationInfoClass, self,, vect(0, 0, 0), rot(0, 0, 0));
    if(PlayerReplicationInfo.PlayerName == "")
    {
        PlayerReplicationInfo.PlayerName = Class'GameInfo'.default.DefaultPlayerName;
    }
}

// Export UController::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

reliable server function ServerRestartPlayer()
{
    if((WorldInfo.NetMode != NM_Client) && Pawn != none)
    {
        ServerGivePawn();
    }
}

function ServerGivePawn();

function SetCharacter(string inCharacter);

function GameHasEnded(optional Actor EndGameFocus, optional bool bIsWinner)
{
    GotoState('RoundEnded');
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageTyp)
{
    if(Pawn != none)
    {
        Pawn.TriggerEventClass(Class'SeqEvent_SeeDeath', KilledPawn);
    }
    if(Enemy == KilledPawn)
    {
        Enemy = none;
    }
}

function NotifyProjLanded(Projectile Proj)
{
    if((Proj != none) && Pawn != none)
    {
        Pawn.TriggerEventClass(Class'SeqEvent_ProjectileLanded', Proj);
    }
}

function WarnProjExplode(Projectile Proj);

event float RatePickup(Actor PickupHolder, class<Inventory> inPickup);

function bool FireWeaponAt(Actor inActor);

event StopFiring()
{
    bFire = 0;
    if(Pawn != none)
    {
        Pawn.StopFiring();
    }
}

function RoundHasEnded(optional Actor EndRoundFocus)
{
    GotoState('RoundEnded');
}

function HandlePickup(Inventory Inv);

function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    if(Pawn != none)
    {
        return Pawn.GetBaseAimRotation();
    }
    return Rotation;
}

function InstantWarnTarget(Actor InTarget, Weapon FiredWeapon, Vector FireDir)
{
    local Pawn P;

    P = Pawn(InTarget);
    if((P != none) && P.Controller != none)
    {
        P.Controller.ReceiveWarning(Pawn, -1, FireDir);
    }
}

function ReceiveWarning(Pawn shooter, float projSpeed, Vector FireDir);

function ReceiveProjectileWarning(Projectile Proj);

exec function SwitchToBestWeapon(optional bool bForceNewWeapon)
{
    if((Pawn == none) || Pawn.InvManager == none)
    {
        return;
    }
    Pawn.InvManager.SwitchToBestWeapon(bForceNewWeapon);
}

reliable client simulated function ClientSwitchToBestWeapon(optional bool bForceNewWeapon)
{
    SwitchToBestWeapon(bForceNewWeapon);
}

function NotifyChangedWeapon(Weapon PrevWeapon, Weapon NewWeapon);

// Export UController::execLineOfSightTo(FFrame&, void* const)
native(514) final function bool LineOfSightTo(Actor Other, optional Vector chkLocation, optional bool bTryAlternateTargetLoc);

// Export UController::execCanSee(FFrame&, void* const)
native(533) final function bool CanSee(Pawn Other);

// Export UController::execCanSeeByPoints(FFrame&, void* const)
native(537) final function bool CanSeeByPoints(Vector ViewLocation, Vector TestLocation, Rotator ViewRotation);

// Export UController::execPickTarget(FFrame&, void* const)
native(531) final function Pawn PickTarget(class<Pawn> TargetClass, out float bestAim, out float bestDist, Vector FireDir, Vector projStart, float MaxRange, optional bool bTargetTeammates)
{
    bTargetTeammates = false;                                    
}

event HearNoise(float Loudness, Actor NoiseMaker, optional name NoiseType);

event SeePlayer(Pawn Seen);

event SeeMonster(Pawn Seen);

event EnemyNotVisible();

// Export UController::execMoveTo(FFrame&, void* const)
native(500) final latent function MoveTo(Vector NewDestination, optional Actor ViewFocus, optional float DestinationOffset, optional bool bShouldWalk)
{
    bShouldWalk = ((Pawn != none) ? Pawn.bIsWalking : false);                        
}

// Export UController::execMoveToDirectNonPathPos(FFrame&, void* const)
native final latent function MoveToDirectNonPathPos(Vector NewDestination, optional Actor ViewFocus, optional float DestinationOffset, optional bool bShouldWalk)
{
    bShouldWalk = ((Pawn != none) ? Pawn.bIsWalking : false);                        
}

// Export UController::execMoveToward(FFrame&, void* const)
native(502) final latent function MoveToward(Actor NewTarget, optional Actor ViewFocus, optional float DestinationOffset, optional bool bUseStrafing, optional bool bShouldWalk)
{
    bShouldWalk = ((Pawn != none) ? Pawn.bIsWalking : false);                            
}

event SetupSpecialPathAbilities();

// Export UController::execFinishRotation(FFrame&, void* const)
native(508) final latent function FinishRotation();

// Export UController::execFindPathTo(FFrame&, void* const)
native(518) final function Actor FindPathTo(Vector aPoint, optional int MaxPathLength, optional bool bReturnPartial);

// Export UController::execFindPathToward(FFrame&, void* const)
native(517) final function Actor FindPathToward(Actor anActor, optional bool bWeightDetours, optional int MaxPathLength, optional bool bReturnPartial);

// Export UController::execFindPathTowardNearest(FFrame&, void* const)
native final function Actor FindPathTowardNearest(class<NavigationPoint> GoalClass, optional bool bWeightDetours, optional int MaxPathLength, optional bool bReturnPartial);

// Export UController::execFindRandomDest(FFrame&, void* const)
native(525) final function NavigationPoint FindRandomDest();

// Export UController::execFindPathToIntercept(FFrame&, void* const)
native final function Actor FindPathToIntercept(Pawn P, Actor InRouteGoal, optional bool bWeightDetours, optional int MaxPathLength, optional bool bReturnPartial);

// Export UController::execPointReachable(FFrame&, void* const)
native(521) final function bool PointReachable(Vector aPoint);

// Export UController::execActorReachable(FFrame&, void* const)
native(520) final function bool ActorReachable(Actor anActor);

event MoveUnreachable(Vector AttemptedDest, Actor AttemptedTarget);

// Export UController::execPickWallAdjust(FFrame&, void* const)
native(526) final function bool PickWallAdjust(Vector HitNormal);

// Export UController::execWaitForLanding(FFrame&, void* const)
native(527) final latent function WaitForLanding(optional float waitDuration);

event LongFall();

// Export UController::execEndClimbLadder(FFrame&, void* const)
native function EndClimbLadder();

event MayFall(bool bFloor, Vector FloorNormal);

event bool AllowDetourTo(NavigationPoint N)
{
    return true;
}

function WaitForMover(InterpActor M)
{
    PendingMover = M;
    M.bMonitorMover = true;
    bPreparingMove = true;
    Pawn.Acceleration = vect(0, 0, 0);
}

event bool MoverFinished()
{
    if(((Pawn == none) || PendingMover.MyMarker == none) || PendingMover.MyMarker.ProceedWithMove(Pawn))
    {
        PendingMover = none;
        bPreparingMove = false;
        return true;
    }
    return false;
}

function UnderLift(LiftCenter Lift);

event bool HandlePathObstruction(Actor BlockedBy);

simulated event GetPlayerViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    out_Location = Location;
    out_Rotation = Rotation;
}

simulated event GetActorEyesViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    if(Pawn != none)
    {
        Pawn.GetActorEyesViewPoint(out_Location, out_Rotation);        
    }
    else
    {
        out_Location = Location;
        out_Rotation = Rotation;
    }
}

simulated function bool IsAimingAt(Actor ATarget, float Epsilon)
{
    local Vector Loc;
    local Rotator Rot;

    GetPlayerViewPoint(Loc, Rot);
    return (Normal(ATarget.Location - Loc) Dot vector(Rot)) >= Epsilon;
}

simulated function bool LandingShake()
{
    return false;
}

event NotifyPhysicsVolumeChange(PhysicsVolume NewVolume);

event bool NotifyHeadVolumeChange(PhysicsVolume NewVolume);

event bool NotifyLanded(Vector HitNormal, Actor FloorActor);

event bool NotifyHitWall(Vector HitNormal, Actor Wall);

event NotifyFallingHitWall(Vector HitNormal, Actor Wall);

event bool NotifyBump(Actor Other, Vector HitNormal);

event NotifyJumpApex();

event NotifyMissedJump();

event ReachedPreciseDestination();

// Export UController::execInLatentExecution(FFrame&, void* const)
native final function bool InLatentExecution(int LatentActionNumber);

// Export UController::execStopLatentExecution(FFrame&, void* const)
native final function StopLatentExecution();

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    if(Pawn == none)
    {
        if(PlayerReplicationInfo == none)
        {
            Canvas.DrawText("NO PLAYERREPLICATIONINFO", false);            
        }
        else
        {
            PlayerReplicationInfo.DisplayDebug(HUD, out_YL, out_YPos);
        }
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        super.DisplayDebug(HUD, out_YL, out_YPos);
        return;
    }
    Canvas.SetDrawColor(255, 0, 0);
    Canvas.DrawText((("CONTROLLER " $ (GetItemName(string(self)))) $ " Pawn ") $ (GetItemName(string(Pawn))));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText(" bPreciseDestination:" @ string(bPreciseDestination));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(HUD.ShouldDisplayDebug('AI'))
    {
        if(Enemy != none)
        {
            Canvas.DrawText((("     STATE: " $ string(GetStateName())) $ " Enemy ") $ Enemy.GetHumanReadableName(), false);            
        }
        else
        {
            Canvas.DrawText(("     STATE: " $ string(GetStateName())) $ " NO Enemy ", false);
        }
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
}

simulated function string GetHumanReadableName()
{
    if(PlayerReplicationInfo != none)
    {
        return PlayerReplicationInfo.PlayerName;        
    }
    else
    {
        return GetItemName(string(self));
    }
}

function bool IsDead();

simulated function OnTeleport(SeqAct_Teleport Action)
{
    if(Action != none)
    {
        if(Pawn != none)
        {
            Pawn.OnTeleport(Action);            
        }
        else
        {
            super.OnTeleport(Action);
        }
    }
}

function OnAttachToActor(SeqAct_AttachToActor Action)
{
    if(Pawn != none)
    {
        Pawn.OnAttachToActor(Action);        
    }
    else
    {
        super.OnAttachToActor(Action);
    }
}

function OnToggleGodMode(SeqAct_ToggleGodMode inAction)
{
    if(inAction.InputLinks[0].bHasImpulse)
    {
        bGodMode = true;        
    }
    else
    {
        if(inAction.InputLinks[1].bHasImpulse)
        {
            bGodMode = false;            
        }
        else
        {
            bGodMode = !bGodMode;
        }
    }
}

simulated function OnSetPhysics(SeqAct_SetPhysics Action)
{
    if(Pawn != none)
    {
        Pawn.OnSetPhysics(Action);        
    }
    else
    {
        super.OnSetPhysics(Action);
    }
}

simulated function OnSetVelocity(SeqAct_SetVelocity Action)
{
    if(Pawn != none)
    {
        Pawn.OnSetVelocity(Action);        
    }
    else
    {
        super.OnSetVelocity(Action);
    }
}

simulated function NotifyCoverDisabled(CoverLink Link, int SlotIdx, optional bool bAdjacentIdx);

simulated event NotifyCoverAdjusted();

simulated function bool NotifyCoverClaimViolation(Controller NewClaim, CoverLink Link, int SlotIdx);

simulated function OnModifyHealth(SeqAct_ModifyHealth Action)
{
    if(Pawn != none)
    {
        Pawn.OnModifyHealth(Action);
    }
}

function NotifyAddInventory(Inventory NewItem);

simulated function OnToggleHidden(SeqAct_ToggleHidden Action)
{
    if(Pawn != none)
    {
        Pawn.OnToggleHidden(Action);
    }
}

event bool IsSpectating()
{
    return false;
}

event bool IsInCombat(optional bool bForceCheck);

event CurrentLevelUnloaded();

function SendMessage(PlayerReplicationInfo Recipient, name MessageType, float Wait, optional class<DamageType> DamageType);

function ReadyForLift();

simulated function InitNavigationHandle()
{
    if(NavigationHandleClass != none)
    {
        NavigationHandle = new (self) NavigationHandleClass;
    }
}

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst)
{
    if(Pawn != none)
    {
        Pawn.InterpolationStarted(InterpAction, GroupInst);
    }
    super.InterpolationStarted(InterpAction, GroupInst);
}

simulated event InterpolationFinished(SeqAct_Interp InterpAction)
{
    if(Pawn != none)
    {
        Pawn.InterpolationFinished(InterpAction);
    }
    super.InterpolationFinished(InterpAction);
}

event bool GeneratePathToActor(Actor Goal, optional float WithinDistance, optional bool bAllowPartialPath);

event bool GeneratePathToLocation(Vector Goal, optional float WithinDistance, optional bool bAllowPartialPath);

state Dead
{
    ignores SeePlayer, HearNoise, KilledBy;

    function bool IsDead()
    {
        return true;
    }

    function PawnDied(Pawn P)
    {
        if(WorldInfo.NetMode != NM_Client)
        {
            WarnInternal(string(self) @ "Pawndied while dead");
            ScriptTrace();
        }
    }

    reliable server function ServerRestartPlayer()
    {
        if(WorldInfo.NetMode == NM_Client)
        {
            return;
        }
        if(Pawn != none)
        {
            UnPossess();
        }
        WorldInfo.Game.RestartPlayer(self);
    }
    stop;    
}

state RoundEnded
{
    ignores SeePlayer, HearNoise, KilledBy, NotifyBump, HitWall, NotifyPhysicsVolumeChange, 
	    NotifyHeadVolumeChange, Falling, TakeDamage, ReceiveWarning;

    function bool GamePlayEndedState()
    {
        return true;
    }

    event BeginState(name PreviousStateName)
    {
        if(Pawn != none)
        {
            Pawn.TurnOff();
            StopFiring();
            if(!bIsPlayer)
            {
                Pawn.UnPossessed();
                Pawn = none;
            }
        }
        if(!bIsPlayer)
        {
            Destroy();
        }
    }
    stop;    
}

defaultproperties
{
    bSlowerZAcquire=true
    MinHitWall=-1
    NavigationHandleClass=Class'NavigationHandle'
    SightCounterInterval=0.2
    MaxMoveTowardPawnTargetTime=1.2
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    bHidden=true
    bOnlyRelevantToOwner=true
    bHiddenEd=true
    RotationRate=(Pitch=30000,Yaw=30000,Roll=2048)
}