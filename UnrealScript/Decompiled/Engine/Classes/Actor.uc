/*******************************************************************************
 * Actor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Actor extends Object
    abstract
    native
    nativereplication
    hidecategories(Navigation);

const TRACEFLAG_Bullet = 1;
const TRACEFLAG_PhysicsVolumes = 2;
const TRACEFLAG_SkipMovers = 4;
const TRACEFLAG_Blocking = 8;
const TRACEFLAG_ForceController = 16;
const REP_RBLOCATION_ERROR_TOLERANCE_SQ = 16.0f;
const MINFLOORZ = 0.7;
const ACTORMAXSTEPHEIGHT = 35.0;
const RBSTATE_LINVELSCALE = 10.0;
const RBSTATE_ANGVELSCALE = 1000.0;
const RB_None = 0x00;
const RB_NeedsUpdate = 0x01;
const RB_Sleeping = 0x02;

enum EPhysics
{
    PHYS_None,
    PHYS_Walking,
    PHYS_Falling,
    PHYS_Swimming,
    PHYS_Flying,
    PHYS_Rotating,
    PHYS_Projectile,
    PHYS_Interpolating,
    PHYS_Spider,
    PHYS_Ladder,
    PHYS_RigidBody,
    PHYS_SoftBody,
    PHYS_NavMeshWalking,
    PHYS_Unused,
    PHYS_Custom,
    PHYS_MAX
};

enum EMoveDir
{
    MD_Stationary,
    MD_Forward,
    MD_Backward,
    MD_Left,
    MD_Right,
    MD_Up,
    MD_Down,
    MD_MAX
};

enum EActorMetricsType
{
    METRICS_VERTS,
    METRICS_TRIS,
    METRICS_SECTIONS,
    METRICS_MAX
};

enum ENetRole
{
    ROLE_None,
    ROLE_SimulatedProxy,
    ROLE_AutonomousProxy,
    ROLE_Authority,
    ROLE_MAX
};

enum ECollisionType
{
    COLLIDE_CustomDefault,
    COLLIDE_NoCollision,
    COLLIDE_BlockAll,
    COLLIDE_BlockWeapons,
    COLLIDE_TouchAll,
    COLLIDE_TouchWeapons,
    COLLIDE_BlockAllButWeapons,
    COLLIDE_TouchAllButWeapons,
    COLLIDE_BlockWeaponsKickable,
    COLLIDE_MAX
};

enum ETravelType
{
    TRAVEL_Absolute,
    TRAVEL_Partial,
    TRAVEL_Relative,
    TRAVEL_MAX
};

enum EDoubleClickDir
{
    DCLICK_None,
    DCLICK_Left,
    DCLICK_Right,
    DCLICK_Forward,
    DCLICK_Back,
    DCLICK_Active,
    DCLICK_Done,
    DCLICK_MAX
};

enum EZedTimeType
{
    ZTT_ClientEffect,
    ZTT_Always,
    ZTT_Never,
    ZTT_Manual,
    ZTT_MAX
};

struct native TimerData
{
    var bool bLoop;
    var bool bPaused;
    var name FuncName;
    var float Rate;
    var float Count;
    var float TimerTimeDilation;
    var Object TimerObj;

    structdefaultproperties
    {
        bLoop=false
        bPaused=false
        FuncName=None
        Rate=0
        Count=0
        TimerTimeDilation=1
        TimerObj=none
    }
};

struct native transient TraceHitInfo
{
    var init Material Material;
    var init PhysicalMaterial PhysMaterial;
    var init int Item;
    var init int LevelIndex;
    var init name BoneName;
    var init export editinline PrimitiveComponent HitComponent;

    structdefaultproperties
    {
        Material=none
        PhysMaterial=none
        Item=0
        LevelIndex=0
        BoneName=None
        HitComponent=none
    }
};

struct native transient ImpactInfo
{
    var init Actor HitActor;
    var init Vector HitLocation;
    var init Vector HitNormal;
    var init Vector RayDir;
    var init Vector StartTrace;
    var init TraceHitInfo HitInfo;

    structdefaultproperties
    {
        HitActor=none
        HitLocation=(X=0,Y=0,Z=0)
        HitNormal=(X=0,Y=0,Z=0)
        RayDir=(X=0,Y=0,Z=0)
        StartTrace=(X=0,Y=0,Z=0)
        HitInfo=(Material=none,PhysMaterial=none,Item=0,LevelIndex=0,BoneName=None,HitComponent=none)
    }
};

struct native transient AnimSlotInfo
{
    var init name SlotName;
    var init array<float> ChannelWeights;

    structdefaultproperties
    {
        SlotName=None
        ChannelWeights=none
    }
};

struct native transient AnimSlotDesc
{
    var init name SlotName;
    var init int NumChannels;

    structdefaultproperties
    {
        SlotName=None
        NumChannels=0
    }
};

struct RigidBodyState
{
    var Vector Position;
    var Quat Quaternion;
    var Vector LinVel;
    var Vector AngVel;
    var byte bNewData;

    structdefaultproperties
    {
        Position=(X=0,Y=0,Z=0)
        Quaternion=(W=0,X=0,Y=0,Z=0)
        LinVel=(X=0,Y=0,Z=0)
        AngVel=(X=0,Y=0,Z=0)
        bNewData=0
    }
};

struct RigidBodyContactInfo
{
    var Vector ContactPosition;
    var Vector ContactNormal;
    var float ContactPenetration;
    var Vector ContactVelocity[2];
    var PhysicalMaterial PhysMaterial[2];

    structdefaultproperties
    {
        ContactPosition=(X=0,Y=0,Z=0)
        ContactNormal=(X=0,Y=0,Z=0)
        ContactPenetration=0
        ContactVelocity[0]=(X=0,Y=0,Z=0)
        ContactVelocity[1]=(X=0,Y=0,Z=0)
        PhysMaterial[0]=none
        PhysMaterial[1]=none
    }
};

struct CollisionImpactData
{
    var array<RigidBodyContactInfo> ContactInfos;
    var Vector TotalNormalForceVector;
    var Vector TotalFrictionForceVector;

    structdefaultproperties
    {
        ContactInfos=none
        TotalNormalForceVector=(X=0,Y=0,Z=0)
        TotalFrictionForceVector=(X=0,Y=0,Z=0)
    }
};

struct native PhysEffectInfo
{
    /** Struct used to pass back information for physical impact effect */
    var() float Threshold;
    /** Struct used to pass back information for physical impact effect */
    var() float ReFireDelay;
    /** Struct used to pass back information for physical impact effect */
    var() ParticleSystem Effect;
    /** Struct used to pass back information for physical impact effect */
    var() AkBaseSoundObject Sound;

    structdefaultproperties
    {
        Threshold=0
        ReFireDelay=0
        Effect=none
        Sound=none
    }
};

struct native atomicwhencooked immutablewhencooked ActorReference
{
    /** Struct used for cross level actor references */
    var() Actor Actor;
    /** Struct used for cross level actor references */
    var() const editconst Guid Guid;

    structdefaultproperties
    {
        Actor=none
        Guid=(A=0,B=0,C=0,D=0)
    }
};

struct native atomicwhencooked immutablewhencooked NavReference
{
    var() NavigationPoint Nav;
    var() const editconst Guid Guid;

    structdefaultproperties
    {
        Nav=none
        Guid=(A=0,B=0,C=0,D=0)
    }
};

struct native BasedPosition
{
    /** Struct for handling positions relative to a base actor, which is potentially moving */
    var() Actor Base;
    /** Struct for handling positions relative to a base actor, which is potentially moving */
    var() Vector Position;
    var Vector CachedBaseLocation;
    var Rotator CachedBaseRotation;
    var Vector CachedTransPosition;

    structdefaultproperties
    {
        Base=none
        Position=(X=0,Y=0,Z=0)
        CachedBaseLocation=(X=0,Y=0,Z=0)
        CachedBaseRotation=(Pitch=0,Yaw=0,Roll=0)
        CachedTransPosition=(X=0,Y=0,Z=0)
    }
};

var private const export editinline array<export editinline ActorComponent> Components;
var private const export editinline transient array<export editinline ActorComponent> AllComponents;
/** Actor's location; use Move or SetLocation to change. */
var(Movement) const Vector Location;
/** The actor's rotation; use SetRotation to change. */
var(Movement) const Rotator Rotation;
/** Scaling factor, 1.0=normal size. */
var(Display) repnotify interp const float DrawScale<UIMin=0.1|UIMax=4.0>;
/** Scaling vector, (1.0,1.0,1.0)=normal size. */
var(Display) interp const Vector DrawScale3D;
/** Offset from box center for drawing. */
var(Display) const Vector PrePivot;
/** Color to tint the icon for this actor */
var(Display) editoronly Color EditorIconColor;
var private native const RenderCommandFence DetachFence;
var float CustomTimeDilation;
/** Priority Parameters Actor's current physics mode. */
var(Movement) const Actor.EPhysics Physics;
var Actor.ENetRole RemoteRole;
var Actor.ENetRole Role;
/** enum for LDs to select collision options - sets Actor flags and that of our CollisionComponent via PostEditChange() */
var(Collision) const transient Actor.ECollisionType CollisionType;
var transient Actor.ECollisionType ReplicatedCollisionType;
var const Core.Object.ETickingGroup TickGroup;
var const Actor Owner;
/** Actor we're standing on. */
var(Attachment) const Actor Base;
var const array<TimerData> Timers;
var const bool bStatic;
var(Display) const bool bHidden;
var const bool bNoDelete;
var const bool bDeleteMe;
var const transient bool bTicked;
var const bool bOnlyOwnerSee;
var const bool bTickIsDisabled;
var bool bWorldGeometry;
var bool bIgnoreRigidBodyPawns;
var bool bOrientOnSlope;
var const bool bIgnoreEncroachers;
var bool bPushedByEncroachers;
var bool bDestroyedByInterpActor;
var const bool bRouteBeginPlayEvenIfStatic;
var const bool bIsMoving;
var bool bAlwaysEncroachCheck;
var bool bHasAlternateTargetLocation;
/** If TRUE, PHYS_Walking will attempt to step up onto this object when it hits it */
var(Collision) bool bCanStepUpOn;
var const bool bNetTemporary;
var const bool bOnlyRelevantToOwner;
var transient bool bNetDirty;
var bool bAlwaysRelevant;
var bool bReplicateInstigator;
var bool bReplicateMovement;
var bool bSkipActorPropertyReplication;
var bool bUpdateSimulatedPosition;
var bool bTearOff;
var bool bOnlyDirtyReplication;
var(Physics) bool bAllowFluidSurfaceInteraction;
var transient bool bDemoRecording;
var bool bDemoOwner;
var bool bForceDemoRelevant;
var const bool bNetInitialRotation;
var bool bReplicateRigidBodyLocation;
var bool bKillDuringLevelTransition;
var const bool bExchangedRoles;
/** If true, texture streaming code iterates over all StaticMeshComponents found on this actor when building texture streaming information. */
var(Advanced) bool bConsiderAllStaticMeshComponentsForStreaming;
/** debug */
var(Debug) bool bDebug;
var bool bPostRenderIfNotVisible;
var transient bool bForceNetUpdate;
var const transient bool bPendingNetUpdate;
/**  
 *Uses 'hard' attachment code. bBlockActor must also be false.
 *       This actor cannot then move relative to base (setlocation etc.).
 *       Dont set while currently based on something!
 */
var(Attachment) const bool bHardAttach;
/** If TRUE, this actor ignores the effects of changes in its  base's rotation on its location and rotation. */
var(Attachment) bool bIgnoreBaseRotation;
/** If TRUE, BaseSkelComponent is used as the shadow parent for this actor. */
var(Attachment) bool bShadowParented;
/**  
 *If TRUE, Skip moveactor collision check for this actor moving as a result of its base, to which it is hard attached moving
 * - only if this actor doesn't block actors.
 */
var(Attachment) bool bSkipAttachedMoves;
var bool bCanBeAdheredTo;
var bool bCanBeFrictionedTo;
var bool bHurtEntry;
var bool bGameRelevant;
var const bool bMovable;
var bool bDestroyInPainVolume;
var bool bCanBeDamaged;
var bool bShouldBaseAtStartup;
var bool bPendingDelete;
var bool bCanTeleport;
var const bool bAlwaysTick;
var(Navigation) bool bBlocksNavigation;
/**  
 *mirrored copy of CollisionComponent's BlockRigidBody for the Actor property window for LDs (so it's next to CollisionType)
 * purely for editing convenience and not used at all by the physics code
 */
var(Collision) const transient bool BlockRigidBody;
var bool bCollideWhenPlacing;
var const bool bCollideActors;
var bool bCollideWorld;
/** Ignore Simple Collision on Static Meshes, and collide per Poly. */
var(Collision) bool bCollideComplex;
var bool bBlockActors;
var bool bProjTarget;
var bool bBlocksTeleport;
var bool bMoveIgnoresDestruction;
var bool bProjectileMoveSingleBlocking;
/**  
 *For encroachers, don't do the overlap check when they move. You will not get touch events for this actor moving, but it is much faster.
 *       So if you want touch events from volumes or triggers you need to set this to be FALSE.
 *       This is an optimisation for large numbers of PHYS_RigidBody actors for example.
 */
var(Collision) bool bNoEncroachCheck;
var bool bCollideAsEncroacher;
/** If true, do a zero-extent trace each frame from old to new Location when in PHYS_RigidBody. If it hits the world (ie might be tunneling), call FellOutOfWorld. */
var(Collision) bool bPhysRigidBodyOutOfWorldCheck;
var const transient bool bComponentOutsideWorld;
var bool bForceOctreeSNFilter;
var bool bForceOctreeMNFilter;
var const transient bool bRigidBodyWasAwake;
var bool bCallRigidBodyWakeEvents;
var bool bBounce;
var const bool bJustTeleported;
/** Enable this actor to receive the OnMobileTouch event when a player touches this actor when using a touch screen device */
var(Mobile) bool bEnableMobileTouch;
var const bool bNetInitial;
var const bool bNetOwner;
var const bool bHiddenEd;
var const bool bEditable;
var const deprecated bool bHiddenEdGroup;
var const bool bHiddenEdLayer;
var const bool bHiddenEdCustom;
var editoronly transient bool bHiddenEdTemporary;
var editoronly transient bool bHiddenEdLevel;
var editoronly transient bool bHiddenEdScene;
/** Snap to grid in editor. */
var(Advanced) bool bEdShouldSnap;
var const transient bool bTempEditor;
/** this actor should collide (if bWorldGeometry && bBlockActors is true) during path building (ignored if bStatic is true, as actor will always collide during path building) */
var(Collision) bool bPathColliding;
var transient bool bPathTemp;
var bool bScriptInitialized;
/** always allow Kismet to modify this Actor, even if it's static and not networked (e.g. for server side only stuff) */
var(Advanced) bool bLockLocation;
var const bool bForceAllowKismetModification;
var(Debug) bool bDebugEffectIsRelevant;
/** Load this actor if PhysXLevel is 0 (PhysX hardware acceleration off) */
var(Advanced) bool bLoadIfPhysXLevel0;
/** Load this actor if PhysXLevel is 1 (Low PhysX hardware acceleration) */
var(Advanced) bool bLoadIfPhysXLevel1;
/** Load this actor if PhysXLevel is 2 (High PhysX hardware acceleration) */
var(Advanced) bool bLoadIfPhysXLevel2;
/** Indicates PHYS_Spider Pawns can have their base set to this  (set automatically during editor path build) */
var(Collision) bool bCrawlable;
/** Don't check collision against this actor for audio occlusion */
var(Collision) bool bIgnoreAudioOcclusion<EditCondition=bOverride_OcclusionFlags>;
var const bool bIgnoreNetRelevancyCollision<EditCondition=bOverride_OcclusionFlags>;
/** If set, bIgnoreNetRelevancyCollision & bIgnoreAudioOcclusion are set manually */
var(Collision) bool bOverride_OcclusionFlags;
var const transient int SkelMeshCompTickTag;
var const transient int NetTag;
var const float NetUpdateTime;
var float NetUpdateFrequency;
var float NetPriority;
var const transient float LastNetUpdateTime;
var float TimeSinceLastTick;
var Pawn Instigator;
var const transient WorldInfo WorldInfo;
var float LifeSpan;
var const float CreationTime;
var transient float LastRenderTime;
/** Actor's tag name. */
var(Object) name Tag;
var name InitialState;
/** Actor's layer name. */
var(Object) name Layer;
var deprecated name Group;
var transient QWord HiddenEditorViews;
var const transient array<Actor> Touching;
var const transient array<Actor> Children;
var const float LatentFloat;
var const AnimNodeSequence LatentSeqNode;
var const transient PhysicsVolume PhysicsVolume;
var Vector Velocity;
var Vector Acceleration;
var const transient Vector AngularVelocity;
/** Attachment related variables */
var(Attachment) export editinline SkeletalMeshComponent BaseSkelComponent;
var(Attachment) name BaseBoneName;
var const array<Actor> Attached;
var const Vector RelativeLocation;
var const Rotator RelativeRotation;
/** ----------------------------------------------------------------------------- Collision. Collision primitive. */
var(Collision) editconst export editinline PrimitiveComponent CollisionComponent;
var native int OverlapTag;
/**  
 *PLEASE NOTE DesiredRotation is removed
 *  This DesiredRotation is moved to Pawn to remove redundant variables usage. (i.e. between Pawn and Controller)
 *  Pawn now handles all DesiredRotation and it is only one place.
 *  All Actor's DesiredRotation won't work anymore - Use RotationRate to control Actor's rotation
 */
var(Movement) Rotator RotationRate;
var Actor PendingTouch;
var class<LocalMessage> MessageClass;
var const array< class<SequenceEvent> > SupportedEvents;
var const array<SequenceEvent> GeneratedEvents;
var array<SeqAct_Latent> LatentActions;
var private transient float ActorTimeSeconds;

replication
{
     if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && ((RemoteRole == ROLE_AutonomousProxy) && bNetInitial) || ((RemoteRole == ROLE_SimulatedProxy) && bNetInitial || bUpdateSimulatedPosition) && (Base == none) || Base.bWorldGeometry)
        Location, Rotation;

     if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && RemoteRole == ROLE_SimulatedProxy)
        Base;

     if((((((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && bNetInitial || bUpdateSimulatedPosition) && RemoteRole == ROLE_SimulatedProxy) && Base != none) && !Base.bWorldGeometry)
        RelativeLocation, RelativeRotation;

     if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && (RemoteRole == ROLE_SimulatedProxy) && bNetInitial || bUpdateSimulatedPosition)
        Physics, Velocity;

     if((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority)
        bHardAttach;

     if(((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        bHidden;

     if((((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty) && bCollideActors || bCollideWorld)
        bBlockActors, bProjTarget;

     if((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority)
        RemoteRole, Role, 
        bNetOwner, bTearOff;

     if((((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty) && bReplicateInstigator)
        Instigator;

     if(((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        DrawScale, ReplicatedCollisionType, 
        bCollideActors, bCollideWorld;

     if(((bNetOwner && !bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        Owner;
}

// Export UActor::execForceUpdateComponents(FFrame&, void* const)
native function ForceUpdateComponents(optional bool bCollisionUpdate, optional bool bTransformOnly)
{
    bCollisionUpdate = false;
    bTransformOnly = true;                
}

// Export UActor::execConsoleCommand(FFrame&, void* const)
native function string ConsoleCommand(string Command, optional bool bWriteToLog)
{
    bWriteToLog = true;                
}

// Export UActor::execSleep(FFrame&, void* const)
native(256) final latent function Sleep(float Seconds);

// Export UActor::execFinishAnim(FFrame&, void* const)
native(261) final latent function FinishAnim(AnimNodeSequence SeqNode, optional bool bFinishOnBlendOut);

// Export UActor::execSetCollision(FFrame&, void* const)
native(262) final function SetCollision(optional bool bNewColActors, optional bool bNewBlockActors, optional bool bNewIgnoreEncroachers);

// Export UActor::execSetCollisionSize(FFrame&, void* const)
native(283) final function SetCollisionSize(float NewRadius, float NewHeight);

// Export UActor::execSetCollisionType(FFrame&, void* const)
native final function SetCollisionType(Actor.ECollisionType NewCollisionType);

// Export UActor::execSetDrawScale(FFrame&, void* const)
native final function SetDrawScale(float NewScale);

// Export UActor::execSetDrawScale3D(FFrame&, void* const)
native final function SetDrawScale3D(Vector NewScale3D);

// Export UActor::execMove(FFrame&, void* const)
native(266) final function bool Move(Vector Delta);

// Export UActor::execSetLocation(FFrame&, void* const)
native(267) final function bool SetLocation(Vector NewLocation);

// Export UActor::execSetRotation(FFrame&, void* const)
native(299) final function bool SetRotation(Rotator NewRotation);

// Export UActor::execMovingWhichWay(FFrame&, void* const)
native function Actor.EMoveDir MovingWhichWay(out float Amount);

// Export UActor::execSetZone(FFrame&, void* const)
native final function SetZone(bool bForceRefresh);

// Export UActor::execSetRelativeRotation(FFrame&, void* const)
native final function bool SetRelativeRotation(Rotator NewRotation);

// Export UActor::execSetRelativeLocation(FFrame&, void* const)
native final function bool SetRelativeLocation(Vector NewLocation);

// Export UActor::execSetHardAttach(FFrame&, void* const)
native final function SetHardAttach(optional bool bNewHardAttach);

// Export UActor::execSetShadowParentOnAllAttachedComponents(FFrame&, void* const)
native simulated function SetShadowParentOnAllAttachedComponents(PrimitiveComponent MyPrimComp, LightEnvironmentComponent MyLightEnv);

// Export UActor::execfixedTurn(FFrame&, void* const)
native final function int fixedTurn(int Current, int Desired, int DeltaRate);

// Export UActor::execMoveSmooth(FFrame&, void* const)
native(3969) final function bool MoveSmooth(Vector Delta);

// Export UActor::execAutonomousPhysics(FFrame&, void* const)
native(3971) final function AutonomousPhysics(float DeltaSeconds);

// Export UActor::execGetTerminalVelocity(FFrame&, void* const)
native function float GetTerminalVelocity();

// Export UActor::execSetBase(FFrame&, void* const)
native(298) final function SetBase(Actor NewBase, optional Vector NewFloor, optional SkeletalMeshComponent SkelComp, optional name AttachName);

// Export UActor::execSetOwner(FFrame&, void* const)
native(272) final function SetOwner(Actor NewOwner);

// Export UActor::execFindBase(FFrame&, void* const)
native function FindBase();

// Export UActor::execSearchForBaseBelow(FFrame&, void* const)
native function SearchForBaseBelow(float HeightBelow, out Actor NewBase, out Vector HitNormal);

// Export UActor::execIsBasedOn(FFrame&, void* const)
native final function bool IsBasedOn(Actor TestActor);

// Export UActor::execGetBaseMost(FFrame&, void* const)
native function Actor GetBaseMost();

// Export UActor::execIsOwnedBy(FFrame&, void* const)
native final function bool IsOwnedBy(Actor TestActor);

// Export UActor::execGetAggregateBaseVelocity(FFrame&, void* const)
native final function Vector GetAggregateBaseVelocity(optional Actor TestBase);

simulated event ReplicatedEvent(name VarName);

// Export UActor::execSetForcedInitialReplicatedProperty(FFrame&, void* const)
native final function SetForcedInitialReplicatedProperty(Property PropToReplicate, bool bAdd);

// Export UActor::execVect2BP(FFrame&, void* const)
native static final function Vect2BP(out BasedPosition BP, Vector pos, optional Actor ForcedBase);

// Export UActor::execBP2Vect(FFrame&, void* const)
native static final function Vector BP2Vect(BasedPosition BP);

// Export UActor::execSetBasedPosition(FFrame&, void* const)
native static final function SetBasedPosition(out BasedPosition BP, Vector pos, optional Actor ForcedBase);

// Export UActor::execGetBasedPosition(FFrame&, void* const)
native static final function Vector GetBasedPosition(BasedPosition BP);

// Export UActor::execFlushPersistentDebugLines(FFrame&, void* const)
native static final function FlushPersistentDebugLines();

// Export UActor::execDrawDebugLine(FFrame&, void* const)
native static final function DrawDebugLine(Vector LineStart, Vector LineEnd, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugPoint(FFrame&, void* const)
native static final function DrawDebugPoint(Vector Position, float Size, LinearColor PointColor, optional bool bPersistentLines);

// Export UActor::execDrawDebugBox(FFrame&, void* const)
native static final function DrawDebugBox(Vector Center, Vector Extent, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugStar(FFrame&, void* const)
native static final function DrawDebugStar(Vector Position, float Size, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCoordinateSystem(FFrame&, void* const)
native static final function DrawDebugCoordinateSystem(Vector AxisLoc, Rotator AxisRot, float Scale, optional bool bPersistentLines);

// Export UActor::execDrawDebugSphere(FFrame&, void* const)
native static final function DrawDebugSphere(Vector Center, float Radius, int Segments, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCylinder(FFrame&, void* const)
native static final function DrawDebugCylinder(Vector Start, Vector End, float Radius, int Segments, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCone(FFrame&, void* const)
native static final function DrawDebugCone(Vector Origin, Vector Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, Color DrawColor, optional bool bPersistentLines);

// Export UActor::execDrawDebugString(FFrame&, void* const)
native static final function DrawDebugString(Vector TextLocation, coerce string Text, optional Actor TestBaseActor, optional Color TextColor, optional float Duration)
{
    Duration = -1;                            
}

// Export UActor::execDrawDebugFrustrum(FFrame&, void* const)
native static final function DrawDebugFrustrum(const out Matrix FrustumToWorld, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execFlushDebugStrings(FFrame&, void* const)
native static final exec function FlushDebugStrings();

// Export UActor::execChartData(FFrame&, void* const)
native final function ChartData(string DataName, float DataValue);

// Export UActor::execSetHidden(FFrame&, void* const)
native final function SetHidden(bool bNewHidden);

// Export UActor::execSetOnlyOwnerSee(FFrame&, void* const)
native final function SetOnlyOwnerSee(bool bNewOnlyOwnerSee);

// Export UActor::execSetPhysics(FFrame&, void* const)
native(3970) final function SetPhysics(Actor.EPhysics newPhysics);

// Export UActor::execClock(FFrame&, void* const)
native final function Clock(out float Time);

// Export UActor::execUnClock(FFrame&, void* const)
native final function UnClock(out float Time);

// Export UActor::execAttachComponent(FFrame&, void* const)
native final function AttachComponent(ActorComponent NewComponent);

// Export UActor::execDetachComponent(FFrame&, void* const)
native final function DetachComponent(ActorComponent ExComponent);

// Export UActor::execReattachComponent(FFrame&, void* const)
native final function ReattachComponent(ActorComponent ComponentToReattach);

// Export UActor::execSetTickGroup(FFrame&, void* const)
native final function SetTickGroup(Core.Object.ETickingGroup NewTickGroup);

// Export UActor::execSetTickIsDisabled(FFrame&, void* const)
native final function SetTickIsDisabled(bool bInDisabled);

event Destroyed();

event GainedChild(Actor Other);

event LostChild(Actor Other);

event Tick(float DeltaTime);

event Timer();

event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    TriggerEventClass(Class'SeqEvent_HitWall', Wall);
}

event Falling();

event Landed(Vector HitNormal, Actor FloorActor);

event PhysicsVolumeChange(PhysicsVolume NewVolume);

event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal);

event PostTouch(Actor Other);

event UnTouch(Actor Other);

event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal);

event BaseChange();

event Attach(Actor Other);

event Detach(Actor Other);

event Actor SpecialHandling(Pawn Other);

event CollisionChanged();

event bool EncroachingOn(Actor Other);

event EncroachedBy(Actor Other);

event RanInto(Actor Other);

event OnWakeRBPhysics();

event OnSleepRBPhysics();

// Export UActor::execClampRotation(FFrame&, void* const)
native final simulated function bool ClampRotation(out Rotator out_Rot, Rotator rBase, Rotator rUpperLimits, Rotator rLowerLimits);

simulated event bool OverRotated(out Rotator out_Desired, out Rotator out_Actual);

function bool UsedBy(Pawn User)
{
    return TriggerEventClass(Class'SeqEvent_Used', User, -1);
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    SetPhysics(0);
    SetHidden(true);
    SetCollision(false, false);
    Destroy();
}

simulated event OutsideWorldBounds()
{
    Destroy();
}

simulated function VolumeBasedDestroy(PhysicsVolume PV)
{
    Destroy();
}

// Export UActor::execTrace(FFrame&, void* const)
native(277) final function Actor Trace(out Vector HitLocation, out Vector HitNormal, Vector TraceEnd, optional Vector TraceStart, optional bool bTraceActors, optional Vector Extent, optional out TraceHitInfo HitInfo, optional int ExtraTraceFlags);

// Export UActor::execTraceComponent(FFrame&, void* const)
native final function bool TraceComponent(out Vector HitLocation, out Vector HitNormal, PrimitiveComponent InComponent, Vector TraceEnd, optional Vector TraceStart, optional Vector Extent, optional out TraceHitInfo HitInfo, optional bool bComplexCollision);

// Export UActor::execPointCheckComponent(FFrame&, void* const)
native final function bool PointCheckComponent(PrimitiveComponent InComponent, Vector PointLocation, Vector PointExtent);

// Export UActor::execFastTrace(FFrame&, void* const)
native(548) final function bool FastTrace(Vector TraceEnd, optional Vector TraceStart, optional Vector BoxExtent, optional bool bTraceBullet);

// Export UActor::execTraceAllPhysicsAssetInteractions(FFrame&, void* const)
native final function bool TraceAllPhysicsAssetInteractions(SkeletalMeshComponent SkelMeshComp, Vector EndTrace, Vector StartTrace, out array<ImpactInfo> out_Hits, optional Vector Extent, optional bool bTraceHitZones);

// Export UActor::execFindSpot(FFrame&, void* const)
native final function bool FindSpot(Vector BoxExtent, out Vector SpotLocation);

// Export UActor::execContainsPoint(FFrame&, void* const)
native final function bool ContainsPoint(Vector Spot);

// Export UActor::execIsOverlapping(FFrame&, void* const)
native final function bool IsOverlapping(Actor A);

// Export UActor::execGetComponentsBoundingBox(FFrame&, void* const)
native final function GetComponentsBoundingBox(out Box ActorBox);

// Export UActor::execGetBoundingCylinder(FFrame&, void* const)
native function GetBoundingCylinder(out float CollisionRadius, out float CollisionHeight);

// Export UActor::execIsBlockedBy(FFrame&, void* const)
native final function bool IsBlockedBy(const Actor Other);

// Export UActor::execSpawn(FFrame&, void* const)
native final function Actor Spawn(class<Actor> SpawnClass, optional Actor SpawnOwner, optional name SpawnTag, optional Vector SpawnLocation, optional Rotator SpawnRotation, optional Actor ActorTemplate, optional bool bNoCollisionFail);

// Export UActor::execDestroy(FFrame&, void* const)
native(279) final function bool Destroy();

event TornOff();

// Export UActor::execSetTimer(FFrame&, void* const)
native(280) final function SetTimer(float InRate, optional bool inbLoop, optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                            
}

// Export UActor::execClearTimer(FFrame&, void* const)
native final function ClearTimer(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execClearAllTimers(FFrame&, void* const)
native final function ClearAllTimers(optional Object inObj);

// Export UActor::execPauseTimer(FFrame&, void* const)
native final function PauseTimer(bool bPause, optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                        
}

// Export UActor::execIsTimerActive(FFrame&, void* const)
native final function bool IsTimerActive(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execGetTimerCount(FFrame&, void* const)
native final function float GetTimerCount(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execGetTimerRate(FFrame&, void* const)
native final function float GetTimerRate(optional name TimerFuncName, optional Object inObj)
{
    TimerFuncName = 'Timer';                    
}

final simulated function float GetRemainingTimeForTimer(optional name TimerFuncName, optional Object inObj)
{
    local float Count, Rate;

    TimerFuncName = 'Timer';    
    Rate = GetTimerRate(TimerFuncName, inObj);
    if(Rate != -1)
    {
        Count = GetTimerCount(TimerFuncName, inObj);
        return Rate - Count;
    }
    return -1;
}

// Export UActor::execModifyTimerTimeDilation(FFrame&, void* const)
native final function ModifyTimerTimeDilation(const name TimerName, const float InTimerTimeDilation, optional Object inObj);

// Export UActor::execResetTimerTimeDilation(FFrame&, void* const)
native final function ResetTimerTimeDilation(const name TimerName, optional Object inObj);

// Export UActor::execCreateAudioComponent(FFrame&, void* const)
native final function AudioComponent CreateAudioComponent(SoundCue InSoundCue, optional bool bPlay, optional bool bStopWhenOwnerDestroyed, optional bool bUseLocation, optional Vector SourceLocation, optional bool bAttachToSelf)
{
    bAttachToSelf = true;                                
}

// Export UActor::execPlaySound(FFrame&, void* const)
native final function PlaySound(SoundCue InSoundCue, optional bool bNotReplicated, optional bool bNoRepToOwner, optional bool bStopWhenOwnerDestroyed, optional Vector SoundLocation, optional bool bNoRepToRelevant);

// Export UActor::execPlayAkEvent(FFrame&, void* const)
native final function PlayAkEvent(AkEvent InSoundCue, optional bool bNotReplicated, optional bool bNoRepToOwner, optional bool bStopWhenOwnerDestroyed, optional Vector SoundLocation, optional bool bNoRepToRelevant);

// Export UActor::execPlaySoundBase(FFrame&, void* const)
native final function PlaySoundBase(AkBaseSoundObject InSoundCue, optional bool bNotReplicated, optional bool bNoRepToOwner, optional bool bStopWhenOwnerDestroyed, optional Vector SoundLocation, optional bool bNoRepToRelevant, optional Rotator SoundRotation);

// Export UActor::execPostAkEvent(FFrame&, void* const)
native final function PostAkEvent(AkEvent InAkEvent, optional bool bIsOccluded, optional bool bIsSpatialized, optional bool bStopWhenOwnerDestroyed);

// Export UActor::execPostAkEventAtLocation(FFrame&, void* const)
native final function PostAkEventAtLocation(AkEvent InAkEvent, Vector SoundLocation, optional bool bIsOccluded);

// Export UActor::execPostAkEventOnBone(FFrame&, void* const)
native final function PostAkEventOnBone(AkEvent InAkEvent, name BoneName, optional bool bIsOccluded, optional bool bIsSpatialized);

// Export UActor::execStopAkEventsOnBone(FFrame&, void* const)
native final function StopAkEventsOnBone(name BoneName);

// Export UActor::execSetRTPCValue(FFrame&, void* const)
native final function SetRTPCValue(name InRTPC, float targetvalue, optional bool bGlobal);

// Export UActor::execGetAKRotation(FFrame&, void* const)
native simulated function Rotator GetAKRotation();

// Export UActor::execSetState(FFrame&, void* const)
native final function SetState(name InStateGroup, name InState);

// Export UActor::execSetSwitch(FFrame&, void* const)
native final function SetSwitch(name InSwitchGroup, name InSwitch);

// Export UActor::execPostTrigger(FFrame&, void* const)
native final function PostTrigger(name InTrigger);

// Export UActor::execActivateOcclusion(FFrame&, void* const)
native final function ActivateOcclusion(bool bInActivate);

// Export UActor::execMakeNoise(FFrame&, void* const)
native(512) final function MakeNoise(float Loudness, optional name NoiseType);

// Export UActor::execPlayerCanSeeMe(FFrame&, void* const)
native(532) final function bool PlayerCanSeeMe(optional bool bForceLOSCheck);

// Export UActor::execSuggestTossVelocity(FFrame&, void* const)
native final function bool SuggestTossVelocity(out Vector TossVelocity, Vector Destination, Vector Start, float TossSpeed, optional float BaseTossZ, optional float DesiredZPct, optional Vector CollisionSize, optional float TerminalVelocity, optional float OverrideGravityZ, optional bool bOnlyTraceUp);

// Export UActor::execCalculateMinSpeedTrajectory(FFrame&, void* const)
native final function bool CalculateMinSpeedTrajectory(out Vector out_Velocity, Vector End, Vector Start, float MaxTossSpeed, float MinTossSpeed, optional Vector CollisionSize, optional float TerminalVelocity, optional float GravityZ, optional bool bOnlyTraceUp)
{
    GravityZ = GetGravityZ();                                                
}

// Export UActor::execGetDestination(FFrame&, void* const)
native final function Vector GetDestination(Controller C);

function bool PreTeleport(Teleporter InTeleporter);

function PostTeleport(Teleporter OutTeleporter);

// Export UActor::execGetURLMap(FFrame&, void* const)
native(547) final function string GetURLMap();

// Export UActor::execAllActors(FFrame&, void* const)
native(304) final iterator function AllActors(class<Actor> BaseClass, out Actor Actor, optional class<Interface> InterfaceClass);

// Export UActor::execDynamicActors(FFrame&, void* const)
native(313) final iterator function DynamicActors(class<Actor> BaseClass, out Actor Actor, optional class<Interface> InterfaceClass);

// Export UActor::execChildActors(FFrame&, void* const)
native(305) final iterator function ChildActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execBasedActors(FFrame&, void* const)
native(306) final iterator function BasedActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execTouchingActors(FFrame&, void* const)
native(307) final iterator function TouchingActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execTraceActors(FFrame&, void* const)
native(309) final iterator function TraceActors(class<Actor> BaseClass, out Actor Actor, out Vector HitLoc, out Vector HitNorm, Vector End, optional Vector Start, optional Vector Extent, optional out TraceHitInfo HitInfo, optional int ExtraTraceFlags);

// Export UActor::execVisibleActors(FFrame&, void* const)
native(311) final iterator function VisibleActors(class<Actor> BaseClass, out Actor Actor, optional float Radius, optional Vector Loc);

// Export UActor::execVisibleCollidingActors(FFrame&, void* const)
native(312) final iterator function VisibleCollidingActors(class<Actor> BaseClass, out Actor Actor, float Radius, optional Vector Loc, optional bool bIgnoreHidden, optional Vector Extent, optional bool bTraceActors, optional class<Interface> InterfaceClass, optional out TraceHitInfo HitInfo);

// Export UActor::execCollidingActors(FFrame&, void* const)
native(321) final iterator function CollidingActors(class<Actor> BaseClass, out Actor Actor, float Radius, optional Vector Loc, optional bool bUseOverlapCheck, optional class<Interface> InterfaceClass, optional out TraceHitInfo HitInfo);

// Export UActor::execOverlappingActors(FFrame&, void* const)
native final iterator function OverlappingActors(class<Actor> BaseClass, out Actor out_Actor, float Radius, optional Vector Loc, optional bool bIgnoreHidden);

// Export UActor::execComponentList(FFrame&, void* const)
native final iterator function ComponentList(class<ActorComponent> BaseClass, out ActorComponent out_Component);

// Export UActor::execAllOwnedComponents(FFrame&, void* const)
native final iterator function AllOwnedComponents(class<Component> BaseClass, out ActorComponent OutComponent);

// Export UActor::execLocalPlayerControllers(FFrame&, void* const)
native final iterator function LocalPlayerControllers(class<PlayerController> BaseClass, out PlayerController PC);

// Export UActor::execGetALocalPlayerController(FFrame&, void* const)
native final function PlayerController GetALocalPlayerController();

event PreBeginPlay()
{
    if(((!bGameRelevant && !bStatic) && WorldInfo.NetMode != NM_Client) && !WorldInfo.Game.CheckRelevance(self))
    {
        if(bNoDelete)
        {
            ShutDown();            
        }
        else
        {
            Destroy();
        }
    }
}

event BroadcastLocalizedMessage(class<LocalMessage> InMessageClass, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    WorldInfo.Game.BroadcastLocalized(self, InMessageClass, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
}

event BroadcastLocalizedTeamMessage(int TeamIndex, class<LocalMessage> InMessageClass, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    WorldInfo.Game.BroadcastLocalizedTeam(TeamIndex, self, InMessageClass, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
}

event PostBeginPlay();

simulated event SetInitialState()
{
    bScriptInitialized = true;
    if(InitialState != 'None')
    {
        GotoState(InitialState);        
    }
    else
    {
        GotoState('Auto');
    }
}

simulated event ConstraintBrokenNotify(Actor ConOwner, RB_ConstraintSetup ConSetup, RB_ConstraintInstance ConInstance);

simulated event NotifySkelControlBeyondLimit(SkelControlLookAt LookAt);

simulated function bool StopsProjectile(Projectile P)
{
    return bProjTarget || bBlockActors;
}

simulated function bool HurtRadius(float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, optional Actor IgnoredActor, optional Controller InstigatedByController, optional bool bDoFullDamage)
{
    local Actor Victim;
    local bool bCausedDamage;
    local TraceHitInfo HitInfo;
    local editinline StaticMeshComponent HitComponent;
    local KActorFromStatic NewKActor;

    InstigatedByController = ((Instigator != none) ? Instigator.Controller : none);    
    if(bHurtEntry)
    {
        return false;
    }
    bHurtEntry = true;
    bCausedDamage = false;
    foreach VisibleCollidingActors(Class'Actor', Victim, DamageRadius, HurtOrigin,,,,, HitInfo)
    {
        if(Victim.bWorldGeometry)
        {
            HitComponent = StaticMeshComponent(HitInfo.HitComponent);
            if((HitComponent != none) && HitComponent.CanBecomeDynamic())
            {
                NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitComponent);
                if(NewKActor != none)
                {
                    Victim = NewKActor;
                }
            }
        }
        if(((!Victim.bWorldGeometry && Victim != self) && Victim != IgnoredActor) && Victim.bCanBeDamaged || Victim.bProjTarget)
        {
            Victim.TakeRadiusDamage(InstigatedByController, BaseDamage, DamageRadius, DamageType, Momentum, HurtOrigin, bDoFullDamage, self);
            bCausedDamage = bCausedDamage || Victim.bProjTarget;
        }        
    }    
    bHurtEntry = false;
    return bCausedDamage;
}

function KilledBy(Pawn EventInstigator);

event TakeDamage(int DamageAmount, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int Idx;
    local SeqEvent_TakeDamage dmgEvent;

    Idx = 0;
    J0x0D:

    if(Idx < GeneratedEvents.Length)
    {
        dmgEvent = SeqEvent_TakeDamage(GeneratedEvents[Idx]);
        if(dmgEvent != none)
        {
            dmgEvent.HandleDamage(self, EventInstigator, DamageType, DamageAmount);
        }
        ++ Idx;
        goto J0x0D;
    }
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType, optional bool bCanRepairArmor, optional bool bMessageHealer)
{
    bCanRepairArmor = true;
    bMessageHealer = true;
}

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    local float ColRadius, ColHeight, DamageScale, Dist, ScaledDamage;

    local Vector Dir;

    DamageFalloffExponent = 1;
    GetBoundingCylinder(ColRadius, ColHeight);
    Dir = Location - HurtOrigin;
    Dist = VSize(Dir);
    Dir = Normal(Dir);
    if(bFullDamage)
    {
        DamageScale = 1;        
    }
    else
    {
        Dist = FMax(Dist - ColRadius, 0);
        DamageScale = FClamp(1 - (Dist / DamageRadius), 0, 1);
        DamageScale = DamageScale ** DamageFalloffExponent;
    }
    if(DamageScale > 0)
    {
        AdjustRadiusDamage(BaseDamage, DamageScale, HurtOrigin);
        ScaledDamage = DamageScale * BaseDamage;
        TakeDamage(int(ScaledDamage), InstigatedBy, Location - ((0.5 * (ColHeight + ColRadius)) * Dir), (DamageScale * Momentum) * Dir, DamageType,, DamageCauser);
    }
}

final simulated function CheckHitInfo(out TraceHitInfo HitInfo, PrimitiveComponent FallBackComponent, Vector Dir, out Vector out_HitLocation)
{
    local Vector out_NewHitLocation, out_HitNormal, TraceEnd, TraceStart;
    local TraceHitInfo newHitInfo;

    if((SkeletalMeshComponent(HitInfo.HitComponent) != none) && HitInfo.BoneName != 'None')
    {
        return;
    }
    if((HitInfo.HitComponent == none) || (SkeletalMeshComponent(HitInfo.HitComponent) == none) && SkeletalMeshComponent(FallBackComponent) != none)
    {
        HitInfo.HitComponent = FallBackComponent;
    }
    if((SkeletalMeshComponent(HitInfo.HitComponent) != none) && HitInfo.BoneName == 'None')
    {
        if(IsZero(Dir))
        {
            Dir = vector(Rotation);
        }
        if(IsZero(out_HitLocation))
        {
            out_HitLocation = Location;
        }
        TraceStart = out_HitLocation - (float(128) * Normal(Dir));
        TraceEnd = out_HitLocation + (float(128) * Normal(Dir));
        if(TraceComponent(out_NewHitLocation, out_HitNormal, HitInfo.HitComponent, TraceEnd, TraceStart, vect(0, 0, 0), newHitInfo))
        {
            HitInfo.BoneName = newHitInfo.BoneName;
            HitInfo.PhysMaterial = newHitInfo.PhysMaterial;
            out_HitLocation = out_NewHitLocation;
        }
    }
}

// Export UActor::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

event DebugFreezeGame(optional Actor ActorToLookAt)
{
    local PlayerController PC;

    ScriptTrace();
    PC = GetALocalPlayerController();
    if(PC != none)
    {        
        PC.ConsoleCommand("PlayersOnly");
        if(ActorToLookAt != none)
        {
            PC.SetViewTarget(ActorToLookAt);
        }
    }
}

function bool CheckForErrors();

event BecomeViewTarget(PlayerController PC);

event EndViewTarget(PlayerController PC);

simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
{
    local Vector HitNormal;
    local float Radius, Height;

    GetBoundingCylinder(Radius, Height);
    if(Trace(out_CamLoc, HitNormal, Location - ((vector(out_CamRot) * Radius) * float(20)), Location, false) == none)
    {
        out_CamLoc = Location - ((vector(out_CamRot) * Radius) * float(20));        
    }
    else
    {
        out_CamLoc = Location + (Height * vector(Rotation));
    }
    return false;
}

simulated function string GetItemName(string FullName)
{
    local int pos;

    pos = InStr(FullName, ".");
    J0x1B:

    if(pos != -1)
    {
        FullName = Right(FullName, (Len(FullName) - pos) - 1);
        pos = InStr(FullName, ".");
        goto J0x1B;
    }
    return FullName;
}

simulated function string GetHumanReadableName()
{
    return GetItemName(string(Class));
}

static function ReplaceText(out string Text, string Replace, string With)
{
    local int I;
    local string Input;

    Input = Text;
    Text = "";
    I = InStr(Input, Replace);
    J0x40:

    if(I != -1)
    {
        Text = (Text $ Left(Input, I)) $ With;
        Input = Mid(Input, I + Len(Replace));
        I = InStr(Input, Replace);
        goto J0x40;
    }
    Text = Text $ Input;
}

static function string GetLocalString(optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2)
{
    return "";
}

function MatchStarting();

function string GetDebugName()
{
    return GetItemName(string(self));
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local string T;
    local Actor A;
    local float MyRadius, MyHeight;
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    Canvas.SetPos(4, out_YPos);
    Canvas.SetDrawColor(255, 0, 0);
    T = GetDebugName();
    if(bDeleteMe)
    {
        T = T $ " DELETED (bDeleteMe == true)";
    }
    if(T != "")
    {
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    Canvas.SetDrawColor(255, 255, 255);
    if(HUD.ShouldDisplayDebug('net'))
    {
        if(WorldInfo.NetMode != NM_Standalone)
        {
            T = (((("ROLE:" @ string(Role)) @ "RemoteRole:") @ string(RemoteRole)) @ "NetMode:") @ string(WorldInfo.NetMode);
            if(bTearOff)
            {
                T = T @ "Tear Off";
            }
            Canvas.DrawText(T, false);
            out_YPos += out_YL;
            Canvas.SetPos(4, out_YPos);
        }
    }
    Canvas.DrawText((("Location:" @ string(Location)) @ "Rotation:") @ string(Rotation), false);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(HUD.ShouldDisplayDebug('Physics'))
    {
        T = (((((("Physics" @ (GetPhysicsName())) @ "in physicsvolume") @ (GetItemName(string(PhysicsVolume)))) @ "on base") @ (GetItemName(string(Base)))) @ "gravity") @ string(GetGravityZ());
        if(bBounce)
        {
            T = T $ " - will bounce";
        }
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((((((((("bHardAttach:" @ string(bHardAttach)) @ "RelativeLoc:") @ string(RelativeLocation)) @ "RelativeRot:") @ string(RelativeRotation)) @ "SkelComp:") @ string(BaseSkelComponent)) @ "Bone:") @ string(BaseBoneName), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((((("Velocity:" @ string(Velocity)) @ "Speed:") @ string(VSize(Velocity))) @ "Speed2D:") @ string(VSize2D(Velocity)), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Acceleration:" @ string(Acceleration), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    if(HUD.ShouldDisplayDebug('Collision'))
    {
        Canvas.DrawColor.B = 0;
        GetBoundingCylinder(MyRadius, MyHeight);
        Canvas.DrawText((("Collision Radius:" @ string(MyRadius)) @ "Height:") @ string(MyHeight));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((((("Collides with Actors:" @ string(bCollideActors)) @ " world:") @ string(bCollideWorld)) @ "proj. target:") @ string(bProjTarget));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText("Blocks Actors:" @ string(bBlockActors));
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        T = "Touching ";
        foreach TouchingActors(Class'Actor', A)
        {
            T = (T $ (GetItemName(string(A)))) $ " ";            
        }        
        if(T == "Touching ")
        {
            T = "Touching nothing";
        }
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    Canvas.DrawColor.B = 255;
    Canvas.DrawText(" STATE:" @ string(GetStateName()), false);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText(((" Instigator:" @ (GetItemName(string(Instigator)))) @ "Owner:") @ (GetItemName(string(Owner))));
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
}

simulated function string GetPhysicsName()
{
    switch(Physics)
    {
        case 0:
            return "None";
            break;
        case 1:
            return "Walking";
            break;
        case 2:
            return "Falling";
            break;
        case 3:
            return "Swimming";
            break;
        case 4:
            return "Flying";
            break;
        case 5:
            return "Rotating";
            break;
        case 6:
            return "Projectile";
            break;
        case 7:
            return "Interpolating";
            break;
        case 8:
            return "Spider";
            break;
        case 9:
            return "Ladder";
            break;
        case 10:
            return "RigidBody";
            break;
        case 13:
            return "Unused";
            break;
        case 14:
            return "Custom";
            break;
        default:
            break;
    }
    return "Unknown";
}

simulated event ModifyHearSoundComponent(AudioComponent AC);

simulated event AudioComponent GetFaceFXAudioComponent()
{
    return none;
}

event Reset();

function bool IsInPain()
{
    local PhysicsVolume V;

    foreach TouchingActors(Class'PhysicsVolume', V)
    {
        if(V.bPainCausing && V.DamagePerSec > float(0))
        {            
            return true;
        }        
    }    
    return false;
}

function PlayTeleportEffect(bool bOut, bool bSound);

simulated function bool CanSplash()
{
    return false;
}

simulated function ApplyFluidSurfaceImpact(FluidSurfaceActor Fluid, Vector HitLocation)
{
    local float Radius, Height, AdjustedVelocity;

    if(bAllowFluidSurfaceInteraction)
    {
        AdjustedVelocity = 0.01 * Abs(Velocity.Z);
        GetBoundingCylinder(Radius, Height);
        Fluid.FluidComponent.ApplyForce(HitLocation, AdjustedVelocity * Fluid.FluidComponent.ForceImpact, Radius * 0.3, true);
    }
}

simulated function bool EffectIsRelevant(Vector SpawnLocation, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance)
{
    VisibleCullDistance = 5000;
    HiddenCullDistance = 350;
    if(SpawnLocation == Location)
    {
        return ActorEffectIsRelevant(Instigator, bForceDedicated, VisibleCullDistance, HiddenCullDistance);        
    }
    else
    {
        return ImpactEffectIsRelevant(Instigator, SpawnLocation, bForceDedicated, VisibleCullDistance, HiddenCullDistance);
    }
}

simulated function bool ActorEffectIsRelevant(Pawn EffectInstigator, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance)
{
    local PlayerController P;
    local float DistSq;
    local Vector CameraLoc;
    local Rotator CameraRot;

    VisibleCullDistance = 5000;
    HiddenCullDistance = 350;
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        if(bDebugEffectIsRelevant && bForceDedicated)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - dedicated server");
        }
        return bForceDedicated;
    }
    if((bForceDedicated && WorldInfo.NetMode == NM_ListenServer) && WorldInfo.Game.NumPlayers > 1)
    {
        return true;
    }
    if(((EffectInstigator != none) && EffectInstigator.IsHumanControlled()) && EffectInstigator.IsLocallyControlled())
    {
        return true;
    }
    DistSq = 1E+10;
    foreach LocalPlayerControllers(Class'PlayerController', P)
    {
        if(P.GetViewTarget() == self)
        {            
            return true;
        }
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        DistSq = FMin(DistSq, VSizeSq(Location - CameraLoc) * Square(P.LODDistanceFactor));        
    }    
    if(DistSq > (VisibleCullDistance * VisibleCullDistance))
    {
        if(bDebugEffectIsRelevant && true)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - VisibleCullDistance");
        }
        return false;        
    }
    else
    {
        if(DistSq < (HiddenCullDistance * HiddenCullDistance))
        {
            return true;
        }
    }
    return (WorldInfo.TimeSeconds - LastRenderTime) < 0.3;
}

simulated function bool ImpactEffectIsRelevant(Pawn EffectInstigator, Vector SpawnLocation, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance, optional bool bSkipLOSCheck)
{
    local PlayerController P;
    local float DistSq, InViewThreshold;
    local bool bIsInViewFrustrum;
    local Vector CameraLoc;
    local Rotator CameraRot;

    VisibleCullDistance = 5000;
    HiddenCullDistance = 350;    
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        if(bDebugEffectIsRelevant && bForceDedicated)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - dedicated server");
        }
        return bForceDedicated;
    }
    if((bForceDedicated && WorldInfo.NetMode == NM_ListenServer) && WorldInfo.Game.NumPlayers > 1)
    {
        return true;
    }
    if(((EffectInstigator != none) && EffectInstigator.IsHumanControlled()) && EffectInstigator.IsLocallyControlled())
    {
        return true;
    }
    DistSq = 1E+10;
    foreach LocalPlayerControllers(Class'PlayerController', P)
    {
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        DistSq = FMin(DistSq, VSizeSq(SpawnLocation - CameraLoc) * Square(P.LODDistanceFactor));        
    }    
    if(DistSq > (VisibleCullDistance * VisibleCullDistance))
    {
        if(bDebugEffectIsRelevant && true)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - VisibleCullDistance");
        }
        return false;        
    }
    else
    {
        if(DistSq < (HiddenCullDistance * HiddenCullDistance))
        {
            return true;
        }
    }
    bIsInViewFrustrum = false;
    foreach LocalPlayerControllers(Class'PlayerController', P)
    {
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        InViewThreshold = Cos(P.GetFOVAngle()) - 0.1;
        if((Normal(SpawnLocation - CameraLoc) Dot vector(CameraRot)) > InViewThreshold)
        {
            if(bSkipLOSCheck || FastTrace(SpawnLocation, CameraLoc))
            {
                bIsInViewFrustrum = true;
                break;
            }
        }        
    }    
    if(bDebugEffectIsRelevant && bIsInViewFrustrum)
    {
        DebugMessagePlayer("EffectIsRelevant FAILED - Outside View Frustrum");
    }
    return bIsInViewFrustrum;
}

final event DebugMessagePlayer(coerce string msg)
{
    local PlayerController PC;

    LogInternal(("!!!!" @ msg) @ "!!!!");
    ScriptTrace();
    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        PC.ClientMessage(msg);        
    }    
}

simulated function bool TriggerEventClass(class<SequenceEvent> InEventClass, Actor InInstigator, optional int ActivateIndex, optional bool bTest, optional out array<SequenceEvent> ActivatedEvents)
{
    local array<int> ActivateIndices;

    ActivateIndex = -1;        
    if(ActivateIndex >= 0)
    {
        ActivateIndices[0] = ActivateIndex;
    }
    return ActivateEventClass(InEventClass, InInstigator, GeneratedEvents, ActivateIndices, bTest, ActivatedEvents);
}

simulated event ReceivedNewEvent(SequenceEvent Evt);

simulated function bool TriggerGlobalEventClass(class<SequenceEvent> InEventClass, Actor InInstigator, optional int ActivateIndex)
{
    local array<SequenceObject> EventsToActivate;
    local array<int> ActivateIndices;
    local Sequence GameSeq;
    local bool bResult;
    local int I;

    ActivateIndex = -1;
    if(ActivateIndex >= 0)
    {
        ActivateIndices[0] = ActivateIndex;
    }
    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(InEventClass, true, EventsToActivate);
        I = 0;
        J0xA2:

        if(I < EventsToActivate.Length)
        {
            if(SequenceEvent(EventsToActivate[I]).CheckActivate(self, InInstigator,, ActivateIndices))
            {
                bResult = true;
            }
            ++ I;
            goto J0xA2;
        }
    }
    return bResult;
}

final simulated function bool ActivateEventClass(class<SequenceEvent> InClass, Actor InInstigator, const out array<SequenceEvent> EventList, const optional out array<int> ActivateIndices, optional bool bTest, optional out array<SequenceEvent> ActivatedEvents)
{
    local SequenceEvent Evt;

    ActivatedEvents.Length = 0;
    foreach EventList(Evt,)
    {
        if(ClassIsChildOf(Evt.Class, InClass) && Evt.CheckActivate(self, InInstigator, bTest, ActivateIndices))
        {
            ActivatedEvents.AddItem(Evt;
        }        
    }    
    return ActivatedEvents.Length > 0;
}

final simulated function bool FindEventsOfClass(class<SequenceEvent> EventClass, optional out array<SequenceEvent> out_EventList, optional bool bIncludeDisabled)
{
    local SequenceEvent Evt;
    local bool bFoundEvent;

    foreach GeneratedEvents(Evt,)
    {
        if((((Evt != none) && Evt.bEnabled || bIncludeDisabled) && ClassIsChildOf(Evt.Class, EventClass)) && (Evt.MaxTriggerCount == 0) || Evt.MaxTriggerCount > Evt.TriggerCount)
        {
            out_EventList.AddItem(Evt;
            bFoundEvent = true;
        }        
    }    
    return bFoundEvent;
}

final simulated function ClearLatentAction(class<SeqAct_Latent> actionClass, optional bool bAborted, optional SeqAct_Latent exceptionAction)
{
    local int Idx;

    Idx = 0;
    J0x0D:

    if(Idx < LatentActions.Length)
    {
        if(LatentActions[Idx] == none)
        {
            LatentActions.Remove(-- Idx, 1;            
        }
        else
        {
            if(ClassIsChildOf(LatentActions[Idx].Class, actionClass) && LatentActions[Idx] != exceptionAction)
            {
                if(bAborted)
                {
                    LatentActions[Idx].AbortFor(self);
                }
                LatentActions.Remove(-- Idx, 1;
            }
        }
        ++ Idx;
        goto J0x0D;
    }
}

simulated function OnDestroy(SeqAct_Destroy Action)
{
    local int AttachIdx, IgnoreIdx;
    local Actor A;

    if(Action.bDestroyBasedActors)
    {
        AttachIdx = 0;
        J0x2D:

        if(AttachIdx < Attached.Length)
        {
            A = Attached[AttachIdx];
            IgnoreIdx = 0;
            J0x6D:

            if(IgnoreIdx < Action.IgnoreBasedClasses.Length)
            {
                if(ClassIsChildOf(A.Class, Action.IgnoreBasedClasses[IgnoreIdx]))
                {
                    A = none;
                    goto J0x102;
                }
                ++ IgnoreIdx;
                goto J0x6D;
            }
            J0x102:

            if(A == none)
            {                
            }
            else
            {
                A.OnDestroy(Action);
            }
            ++ AttachIdx;
            goto J0x2D;
        }
    }
    if(bNoDelete || Role < ROLE_Authority)
    {
        ShutDown();        
    }
    else
    {
        if(!bDeleteMe)
        {
            Destroy();
        }
    }
}

event ForceNetRelevant()
{
    if(((RemoteRole == ROLE_None) && bNoDelete) && !bStatic)
    {
        RemoteRole = ROLE_SimulatedProxy;
        bAlwaysRelevant = true;
        NetUpdateFrequency = 0.1;
    }
    bForceNetUpdate = true;
}

// Export UActor::execSetNetUpdateTime(FFrame&, void* const)
native final function SetNetUpdateTime(float NewUpdateTime);

simulated event ShutDown()
{
    SetPhysics(0);
    SetCollision(false, false);
    if(CollisionComponent != none)
    {
        CollisionComponent.SetBlockRigidBody(false);
    }
    SetHidden(true);
    SetTickIsDisabled(true);
    ForceNetRelevant();
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(BoolProperty'bCollideActors', bCollideActors == default.bCollideActors);
        SetForcedInitialReplicatedProperty(BoolProperty'bBlockActors', bBlockActors == default.bBlockActors);
        SetForcedInitialReplicatedProperty(BoolProperty'bHidden', bHidden == default.bHidden);
        SetForcedInitialReplicatedProperty(ByteProperty'Physics', Physics == default.Physics);
    }
    NetUpdateFrequency = 0.1;
    bForceNetUpdate = true;
}

// Export UActor::execPrestreamTextures(FFrame&, void* const)
native function PrestreamTextures(float Seconds, bool bEnableStreaming, optional int CinematicTextureGroups)
{
    CinematicTextureGroups = 0;                    
}

simulated function OnModifyHealth(SeqAct_ModifyHealth Action)
{
    local Controller InstigatorController;
    local Pawn InstigatorPawn;

    InstigatorController = Controller(Action.Instigator);
    if(InstigatorController == none)
    {
        InstigatorPawn = Pawn(Action.Instigator);
        if(InstigatorPawn != none)
        {
            InstigatorController = InstigatorPawn.Controller;
        }
    }
    if(Action.bHeal)
    {
        HealDamage(int(Action.Amount), InstigatorController, Action.DamageType);        
    }
    else
    {
        TakeDamage(int(Action.Amount), InstigatorController, Location, vector(Rotation) * -Action.Momentum, Action.DamageType);
    }
}

simulated function OnTeleport(SeqAct_Teleport Action)
{
    local array<Object> objVars;
    local int Idx;
    local Actor destActor, tempActor, A;
    local Controller C;
    local bool bOccupiedDest, bColliding;
    local float ColRadius, ColHeight;
    local Vector Extent;

    GetBoundingCylinder(ColRadius, ColHeight);
    Extent.X = ColRadius;
    Extent.Y = ColRadius;
    Extent.Z = ColHeight;
    bOccupiedDest = false;
    Action.GetObjectVars(objVars, "Destination");
    Idx = 0;
    J0xDA:

    if(Idx < objVars.Length)
    {
        tempActor = Actor(objVars[Idx]);
        if(tempActor == none)
        {            
        }
        else
        {
            C = Controller(tempActor);
            if((C != none) && C.Pawn != none)
            {
                tempActor = C.Pawn;
            }
            if(Action.bCheckOverlap)
            {
                bColliding = false;
                foreach VisibleCollidingActors(Class'Actor', A, ColRadius * 2, tempActor.Location, false, Extent, true)
                {
                    if(IsBlockedBy(A))
                    {
                        bColliding = true;
                        break;
                    }                    
                }                
                bOccupiedDest = bColliding;
            }
            destActor = tempActor;
            if((!Action.bCheckOverlap || !bOccupiedDest) && destActor != none)
            {
                goto J0x2CA;
            }
        }
        ++ Idx;
        goto J0xDA;
    }
    J0x2CA:

    if((destActor != none) && Action.ShouldTeleport(self, destActor.Location, Action.TeleportDistance, Action.TeleportVolumes))
    {
        if(SetLocation(destActor.Location))
        {
            PlayTeleportEffect(false, true);
            if(Action.bUpdateRotation)
            {
                SetRotation(destActor.Rotation);
            }
            ForceNetRelevant();
            bUpdateSimulatedPosition = true;
            bNetDirty = true;            
        }
        else
        {
            WarnInternal("Unable to teleport to" @ string(destActor));
        }        
    }
    else
    {
        if(destActor != none)
        {
            WarnInternal("Unable to teleport to" @ string(destActor));
        }
    }
}

simulated function OnSetVelocity(SeqAct_SetVelocity Action)
{
    local Vector V;
    local float Mag;

    Mag = Action.VelocityMag;
    if(Mag <= 0)
    {
        Mag = VSize(Action.VelocityDir);
    }
    V = Normal(Action.VelocityDir) * Mag;
    if(Action.bVelocityRelativeToActorRotation)
    {
        V = V >> Rotation;
    }
    Velocity = V;
    if((Physics == 10) && CollisionComponent != none)
    {
        CollisionComponent.SetRBLinearVelocity(Velocity);
    }
}

simulated function OnSetBlockRigidBody(SeqAct_SetBlockRigidBody Action)
{
    if(CollisionComponent != none)
    {
        if(Action.InputLinks[0].bHasImpulse)
        {
            CollisionComponent.SetBlockRigidBody(true);            
        }
        else
        {
            if(Action.InputLinks[1].bHasImpulse)
            {
                CollisionComponent.SetBlockRigidBody(false);
            }
        }
    }
}

simulated function OnSetPhysics(SeqAct_SetPhysics Action)
{
    ForceNetRelevant();
    SetPhysics(Action.newPhysics);
    if(RemoteRole != ROLE_None)
    {
        if(Physics != 0)
        {
            bUpdateSimulatedPosition = true;
            if(bOnlyDirtyReplication)
            {
                bNetDirty = true;
            }
        }
        SetForcedInitialReplicatedProperty(ByteProperty'Physics', Physics == default.Physics);
    }
}

function OnChangeCollision(SeqAct_ChangeCollision Action)
{
    if(Action.ObjInstanceVersion < Action.GetObjClassVersion())
    {
        SetCollision(Action.bCollideActors, Action.bBlockActors, Action.bIgnoreEncroachers);        
    }
    else
    {
        SetCollisionType(Action.CollisionType);
    }
    ForceNetRelevant();
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(BoolProperty'bCollideActors', bCollideActors == default.bCollideActors);
        SetForcedInitialReplicatedProperty(BoolProperty'bBlockActors', bBlockActors == default.bBlockActors);
    }
}

simulated function OnToggleHidden(SeqAct_ToggleHidden Action)
{
    local int AttachIdx, IgnoreIdx;
    local Actor A;

    if(Action.bToggleBasedActors)
    {
        AttachIdx = 0;
        J0x2D:

        if(AttachIdx < Attached.Length)
        {
            A = Attached[AttachIdx];
            IgnoreIdx = 0;
            J0x6D:

            if(IgnoreIdx < Action.IgnoreBasedClasses.Length)
            {
                if(ClassIsChildOf(A.Class, Action.IgnoreBasedClasses[IgnoreIdx]))
                {
                    A = none;
                    goto J0x102;
                }
                ++ IgnoreIdx;
                goto J0x6D;
            }
            J0x102:

            if(A == none)
            {                
            }
            else
            {
                A.OnToggleHidden(Action);
            }
            ++ AttachIdx;
            goto J0x2D;
        }
    }
    if(Action.InputLinks[0].bHasImpulse)
    {
        SetHidden(true);        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            SetHidden(false);            
        }
        else
        {
            SetHidden(!bHidden);
        }
    }
    ForceNetRelevant();
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(BoolProperty'bHidden', bHidden == default.bHidden);
    }
}

function OnAttachToActor(SeqAct_AttachToActor Action)
{
    local int Idx;
    local Actor Attachment;
    local Controller C;
    local array<Object> objVars;

    Action.GetObjectVars(objVars, "Attachment");
    Idx = 0;
    J0x3F:

    if((Idx < objVars.Length) && Attachment == none)
    {
        Attachment = Actor(objVars[Idx]);
        C = Controller(Attachment);
        if((C != none) && C.Pawn != none)
        {
            Attachment = C.Pawn;
        }
        if(Attachment != none)
        {
            if(Action.bDetach)
            {
                Attachment.SetBase(none);
                Attachment.SetHardAttach(false);                
            }
            else
            {
                C = Controller(self);
                if((C != none) && C.Pawn != none)
                {
                    C.Pawn.DoKismetAttachment(Attachment, Action);                    
                }
                else
                {
                    DoKismetAttachment(Attachment, Action);
                }
            }
        }
        ++ Idx;
        goto J0x3F;
    }
}

function DoKismetAttachment(Actor Attachment, SeqAct_AttachToActor Action)
{
    local bool bOldCollideActors, bOldBlockActors;
    local Vector X, Y, Z;

    Attachment.SetBase(none);
    Attachment.SetHardAttach(Action.bHardAttach);
    if(Action.bUseRelativeOffset || Action.bUseRelativeRotation)
    {
        bOldCollideActors = Attachment.bCollideActors;
        bOldBlockActors = Attachment.bBlockActors;
        Attachment.SetCollision(false, false);
        if(Action.bUseRelativeRotation)
        {
            Attachment.SetRotation(Rotation + Action.RelativeRotation);
        }
        if(Action.bUseRelativeOffset)
        {
            GetAxes(Rotation, X, Y, Z);
            Attachment.SetLocation(((Location + (Action.RelativeOffset.X * X)) + (Action.RelativeOffset.Y * Y)) + (Action.RelativeOffset.Z * Z));
        }
        Attachment.SetCollision(bOldCollideActors, bOldBlockActors);
    }
    Attachment.SetBase(self);
    Attachment.ForceNetRelevant();
    Attachment.bNetDirty = true;
    if((Attachment.RemoteRole != ROLE_None) && Attachment.bStatic || Attachment.bNoDelete)
    {
        Attachment.SetForcedInitialReplicatedProperty(StructProperty'RelativeLocation', Attachment.RelativeLocation == Attachment.default.RelativeLocation);
        Attachment.SetForcedInitialReplicatedProperty(StructProperty'RelativeRotation', Attachment.RelativeRotation == Attachment.default.RelativeRotation);
    }
}

event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime);

event OnAnimPlay(AnimNodeSequence SeqNode);

event BeginAnimControl(InterpGroup InInterpGroup);

event SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);

event FinishAnimControl(InterpGroup InInterpGroup);

event bool PlayActorFaceFXAnim(FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay);

event StopActorFaceFXAnim();

event SetMorphWeight(name MorphNodeName, float MorphWeight);

event SetSkelControlScale(name SkelControlName, float Scale);

event TickSkelControl(float DeltaTime, SkeletalMeshComponent SkelComp, SkelControlBase SkelCtrl);

simulated function bool IsActorPlayingFaceFXAnim()
{
    return false;
}

simulated function bool CanActorPlayFaceFXAnim()
{
    return true;
}

event FaceFXAsset GetActorFaceFXAsset();

function bool IsStationary()
{
    return true;
}

simulated event GetActorEyesViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    out_Location = Location;
    out_Rotation = Rotation;
}

// Export UActor::execIsPlayerOwned(FFrame&, void* const)
native simulated function bool IsPlayerOwned();

function PawnBaseDied();

// Export UActor::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

simulated event byte ScriptGetTeamNum()
{
    return 255;
}

simulated function NotifyLocalPlayerTeamReceived();

simulated function FindGoodEndView(PlayerController PC, out Rotator GoodRotation)
{
    GoodRotation = PC.Rotation;
}

// Export UActor::execGetTargetLocation(FFrame&, void* const)
native simulated function Vector GetTargetLocation(optional Actor RequestedBy, optional bool bRequestAlternateLoc);

event SpawnedByKismet();

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst);

simulated event InterpolationFinished(SeqAct_Interp InterpAction);

simulated event InterpolationChanged(SeqAct_Interp InterpAction);

event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex);

event OnRanOver(SVehicle Vehicle, PrimitiveComponent RunOverComponent, int WheelIndex);

// Export UActor::execSetHUDLocation(FFrame&, void* const)
native simulated function SetHUDLocation(Vector NewHUDLocation);

// Export UActor::execNativePostRenderFor(FFrame&, void* const)
native simulated function NativePostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir);

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir);

simulated event RootMotionModeChanged(SkeletalMeshComponent SkelComp);

simulated event RootMotionProcessed(SkeletalMeshComponent SkelComp);

simulated event RootMotionExtracted(SkeletalMeshComponent SkelComp, out BoneAtom ExtractedRootMotionDelta);

event PostInitAnimTree(SkeletalMeshComponent SkelComp);

// Export UActor::execGetPackageGuid(FFrame&, void* const)
native static final function Guid GetPackageGuid(name PackageName);

simulated event OnRigidBodySpringOverextension(RB_BodyInstance BodyInstance);

// Export UActor::execIsInPersistentLevel(FFrame&, void* const)
native final function bool IsInPersistentLevel(optional bool bIncludeLevelStreamingPersistent);

simulated function GetAimFrictionExtent(out float Width, out float Height, out Vector Center)
{
    if(bCanBeFrictionedTo)
    {
        GetBoundingCylinder(Width, Height);        
    }
    else
    {
        Width = 0;
        Height = 0;
    }
    Center = Location;
}

simulated function GetAimAdhesionExtent(out float Width, out float Height, out Vector Center)
{
    if(bCanBeAdheredTo)
    {
        GetBoundingCylinder(Width, Height);        
    }
    else
    {
        Width = 0;
        Height = 0;
    }
    Center = Location;
}

event bool PlayParticleEffect(const AnimNotify_PlayParticleEffect AnimNotifyData)
{
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        LogInternal("(Actor): PlayParticleEffect on dedicated server!");
        return true;
    }
    return false;
}

event bool CreateForceField(const AnimNotify_ForceField AnimNotifyData)
{
    return false;
}

event TrailsNotify(const AnimNotify_Trails AnimNotifyData);

event TrailsNotifyTick(const AnimNotify_Trails AnimNotifyData);

event TrailsNotifyEnd(const AnimNotify_Trails AnimNotifyData);

// Export UActor::execGetAnimTrailParticleSystem(FFrame&, void* const)
native function ParticleSystem GetAnimTrailParticleSystem(const AnimNotify_Trails AnimNotifyData);

// Export UActor::execSupportsKismetModification(FFrame&, void* const)
native final function bool SupportsKismetModification(SequenceOp AskingOp, out string Reason);

simulated event AnimTreeUpdated(SkeletalMeshComponent SkelMesh);

simulated event PostDemoRewind();

simulated event ReplicationEnded();

// Export UActor::execGetAvoidanceVector(FFrame&, void* const)
native final function Vector GetAvoidanceVector(const out array<Actor> Obstacles, Vector GoalLocation, float CollisionRadius, float MaxSpeed, optional int NumSamples, optional float VelocityStepRate, optional float MaxTimeTilOverlap)
{
    NumSamples = 8;
    VelocityStepRate = 0.1;
    MaxTimeTilOverlap = 1;                                    
}

// Export UActor::execWillOverlap(FFrame&, void* const)
native final function bool WillOverlap(Vector PosA, Vector VelA, Vector PosB, Vector VelB, float StepSize, float Radius, out float Time);

// Export UActor::execShouldBeHiddenBySHOW_NavigationNodes(FFrame&, void* const)
native function bool ShouldBeHiddenBySHOW_NavigationNodes();

function bool IsMobileTouchEnabled()
{
    return bEnableMobileTouch && bCollideActors;
}

event bool OnMobileTouch(PlayerController InPC, Vector2D TouchLocation)
{
    TriggerEventClass(Class'SeqEvent_MobileTouch', InPC, 0);
    return true;
}

// Export UActor::execGetActorMetrics(FFrame&, void* const)
native simulated function int GetActorMetrics(Actor.EActorMetricsType MetricsType);

// Export UActor::execGetActorSpriteComponent(FFrame&, void* const)
native function SpriteComponent GetActorSpriteComponent();

function AdjustRadiusDamage(out float InBaseDamage, float DamageScale, Vector HurtOrigin);

// Export UActor::execGetActorTimeSeconds(FFrame&, void* const)
native final function float GetActorTimeSeconds();

// Export UActor::execActorTimeSince(FFrame&, void* const)
native final function float ActorTimeSince(float Time);

defaultproperties
{
    DrawScale=1
    DrawScale3D=(X=1,Y=1,Z=1)
    EditorIconColor=(B=255,G=255,R=255,A=255)
    CustomTimeDilation=1
    Role=ENetRole.ROLE_Authority
    CollisionType=ECollisionType.COLLIDE_NoCollision
    ReplicatedCollisionType=ECollisionType.None
    bPushedByEncroachers=true
    bRouteBeginPlayEvenIfStatic=true
    bCanStepUpOn=true
    bReplicateMovement=true
    bAllowFluidSurfaceInteraction=true
    bSkipAttachedMoves=true
    bMovable=true
    bJustTeleported=true
    bEditable=true
    bLoadIfPhysXLevel0=true
    bLoadIfPhysXLevel1=true
    bLoadIfPhysXLevel2=true
    NetUpdateFrequency=100
    NetPriority=1
    MessageClass=Class'LocalMessage'
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
}