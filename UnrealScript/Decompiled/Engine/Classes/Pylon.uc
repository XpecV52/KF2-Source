/*******************************************************************************
 * Pylon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Pylon extends NavigationPoint
    native
    placeable
    hidecategories(Navigation,Lighting,LightColor,Force,Lighting,LightColor,Force)
    implements(EditorLinkSelectionInterface,Interface_NavigationHandle);

enum ENavMeshEdgeType
{
    NAVEDGE_UnknownType,
    NAVEDGE_Normal,
    NAVEDGE_Mantle,
    NAVEDGE_Coverslip,
    NAVEDGE_SwatTurn,
    NAVEDGE_DropDown,
    NAVEDGE_PathObject,
    NAVEDGE_BackRefDummy,
    NAVEDGE_Jump,
    NAVEDGE_CrossPylon,
    NAVEDGE_OneWayEdge,
    NAVEDGE_MAX
};

struct native atomicwhencooked immutablewhencooked PolyReference
{
    var ActorReference OwningPylon;
    var private int PolyId;
    var private native Pointer CachedPoly;

    structdefaultproperties
    {
        OwningPylon=(Actor=none,Guid=(A=0,B=0,C=0,D=0))
        PolyId=0
    }
};

var private native const noexport Pointer VfTable_IEditorLinkSelectionInterface;
var private native const noexport Pointer VfTable_IInterface_NavigationHandle;
var native const Pointer NavMeshPtr;
var native const Pointer ObstacleMesh;
var native const Pointer DynamicObstacleMesh;
var native const transient Pointer WorkingSetPtr;
var private native const transient Pointer PathObjectsThatAffectThisPylon;
var const transient array<Vector> NextPassSeedList;
var native const OctreeElementId OctreeId;
var native const Pointer OctreeIWasAddedTo;
var const Pylon NextPylon;
/** A list of volumes within which is valid to explore Note this trumps expansion radius */
var(MeshGeneration) array<Volume> ExpansionVolumes;
/** radius within which expansion will be allowed.  Note if this pylon has an expansion volume linked to it, this parameter has no effect */
var(MeshGeneration) float ExpansionRadius;
var const float MaxExpansionRadius;
var export editinline DrawPylonRadiusComponent PylonRadiusPreview;
var bool bImportedMesh;
var bool bUseExpansionSphereOverride;
var bool bNeedsCostCheck;
var transient bool bPylonInHighLevelPath;
/** Generate NavMesh using Recast */
var(MeshGeneration) bool bUseRecast<bShowOnlyWhenTrue=bAllowRecastGenerator>;
var transient bool bAllowRecastGenerator;
/** Nav Mesh Overloads ONLY WORKS FOR RECAST BUILDS */
var(NavMeshOverloads) bool bAllowNavMeshOverLoads;
/** when this is TRUE a dashed-red line will be drawn across the gap of a one-way edge to highlight those situations */
var(NavMeshOverloads) bool bHightlightOneWayReachSpecs;
var(Debug) bool bDrawEdgePolys;
var(Debug) bool bDrawPolyBounds;
var(Display) bool bRenderInShowPaths;
var(Display) bool bDrawWalkableSurface;
var(Display) bool bDrawObstacleSurface;
/** Show Obstacle mesh as solid polys instead of lines with "show paths" in game */
var(Display) bool bSolidObstaclesInGame;
var transient bool bBuildThisPylon;
var bool bDisabled;
var bool bForceObstacleMeshCollision;
var Vector ExpansionSphereCenter;
var export editinline NavMeshRenderingComponent RenderingComp;
var const export editinline transient SpriteComponent BrokenSprite;
/**  
 *Imposter pylon - this is another pylon which at some point will replace this one due to a gameplay event or some such.  Meshbuild of this
 *  pylon will ignore collisions with the imposter pylon (e.g. build through it)
 */
var(MeshGeneration) array<Pylon> ImposterPylons;
/** when this pylon is being built, disable collision for these actors */
var(MeshGeneration) array<Actor> OnBuild_DisableCollisionForThese;
/** when this pylon is being built, enable collision for these actors */
var(MeshGeneration) array<Actor> OnBuild_EnableCollisionForThese;
var(MeshGeneration) float MaxPolyHeight_Optional;
var byte NavMeshGenerator;
/** How long and wide the building blocks for nav mesh simplifaction, smaller means more detail, but more build time, like 1.3X for every %50 reduction is size, and maybe more memory */
var(NavMeshOverloads) float Recast_CellSize<ClampMin=5.0|ClampMax=100.0>;
/** How tall the building blocks for nav mesh simplifaction, smaller means more detail, but more build time, like 1.3X for every %50 reduction is size, and maybe more memory */
var(NavMeshOverloads) float Recast_CellHeight<ClampMin=5.0|ClampMax=150.0>;
/** DO NOT USE YET!!! it works but does not give the results we want yet */
var(NavMeshOverloads) float Recast_AgentMaxSlope<ClampMin=0.0|ClampMax=90.0>;
/** USE WITH CARE, changes the height that the nav mesh conciders (STATIC) obstacles, but does not take into concideration what the actual pawns step up height is, so if you set this to 100 and the pawns step up height was only 45 he would get stuck */
var(NavMeshOverloads) float NavMeshGen_MaxStepHeight<ClampMin=1.0|ClampMax=500.0>;
/** DO NOT USE YET!!!! way to many changes to know all effects yet!!!! */
var(NavMeshOverloads) float NavMeshGen_MinPolyArea;
var transient array<KAggregateGeom> VoxelFilterBounds;
var transient array<Matrix> VoxelFilterTM;
var const float BufferEpsilonToAddedToBoundsBoxForDropEdgeCheck;
/** debug */
var(Debug) int DebugEdgeCount;
var transient Vector DebugPathExtent;
var transient Vector DebugPathStartLocation;

// Export UPylon::execOnPylonStatusChange(FFrame&, void* const)
native function OnPylonStatusChange();

// Export UPylon::execUpdateMeshForPreExistingNavMeshObstacles(FFrame&, void* const)
native function UpdateMeshForPreExistingNavMeshObstacles();

// Export UPylon::execFlushDynamicEdges(FFrame&, void* const)
native function FlushDynamicEdges();

function Vector GetTestPathExtent()
{
    local class<Scout> ScoutClass;
    local Vector Extent;

    ScoutClass = class<Scout>(DynamicLoadObject(Class'Engine'.default.ScoutClassName, Class'Class'));
    Extent.X = ScoutClass.default.PathSizes[0].Radius;
    Extent.Y = ScoutClass.default.PathSizes[0].Radius;
    Extent.Z = ScoutClass.default.PathSizes[0].Height;
    return Extent;
}

function VerifyTopLevelConnections()
{
    local NavigationHandle DebugHandle;
    local int I, PtIdx;
    local Pylon NeighborPylon;
    local array<Vector> pts, Dst_Pts;
    local bool bFoundPath;

    DebugHandle = new (self) Class'NavigationHandle';
    DebugPathStartLocation = Location;
    DebugPathExtent = GetTestPathExtent();
    DebugHandle.GetValidPositionsForBox(Location, DebugPathExtent.X * float(10), DebugPathExtent, false, pts, 5);
    if(pts.Length == 0)
    {
        LogInternal(("PATH CONNECTION FAILURE!" @ string(self)) @ "Could not get valid start path location");
        DrawDebugLine(Location, Location + vect(0, 0, 100), 255, 255, 0, true);
        return;
    }
    I = 0;
    J0x13C:

    if(I < PathList.Length)
    {
        NeighborPylon = Pylon(PathList[I].End.Actor);
        if(NeighborPylon != none)
        {
            DebugHandle.GetValidPositionsForBox(NeighborPylon.Location, DebugPathExtent.X * float(10), DebugPathExtent, false, Dst_Pts, 1);
            if(Dst_Pts.Length < 1)
            {
                LogInternal((("PATH CONNECTION FAILURE!" @ string(self)) @ "Could not get valid dest path location to ") @ string(NeighborPylon));
                DrawDebugLine(NeighborPylon.Location, NeighborPylon.Location + vect(0, 0, 100), 255, 255, 0, true);                
            }
            else
            {
                bFoundPath = false;
                PtIdx = 0;
                J0x309:

                if(PtIdx < pts.Length)
                {
                    DebugPathStartLocation = pts[PtIdx];
                    Class'NavMeshPath_Toward'.static.TowardPoint(DebugHandle, Dst_Pts[0]);
                    Class'NavMeshGoal_At'.static.AtLocation(DebugHandle, Dst_Pts[0]);
                    if(DebugHandle.FindPath())
                    {
                        bFoundPath = true;
                        goto J0x3E8;
                    }
                    ++ PtIdx;
                    goto J0x309;
                }
                J0x3E8:

                if(!bFoundPath)
                {
                    LogInternal((((((((("PATH CONNECTION FAILURE!" @ string(self)) @ "Location:'") $ string(Location)) $ "'") @ "failed to path to ") @ string(NeighborPylon)) @ "Dst_Pts[0]:'") $ string(Dst_Pts[0])) $ "'");
                    DrawDebugLine(Location, Dst_Pts[0], 255, 0, 0, true);
                    DrawDebugCoordinateSystem(Location, rot(0, 0, 0), 15, true);
                }
            }
        }
        ++ I;
        goto J0x13C;
    }
}

event NotifyPathChanged();

function PostBeginPlay()
{
    super(Actor).PostBeginPlay();
    SetEnabled(!bBlocked);
}

event SetEnabled(bool bEnabled)
{
    bDisabled = !bEnabled;
    bForceObstacleMeshCollision = bDisabled;
    OnPylonStatusChange();
}

event bool IsEnabled()
{
    return !bDisabled;
}

function OnToggle(SeqAct_Toggle Action)
{
    if(Action.InputLinks[0].bHasImpulse)
    {
        SetEnabled(true);        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            SetEnabled(false);            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                SetEnabled(!IsEnabled());
            }
        }
    }
}

// Export UPylon::execCanReachPylon(FFrame&, void* const)
native function bool CanReachPylon(Pylon DestPylon, Controller C);

defaultproperties
{
    ExpansionRadius=2048
    MaxExpansionRadius=7168
    begin object name=DrawPylonRadius0 class=DrawPylonRadiusComponent
        ReplacementPrimitive=none
    object end
    // Reference: DrawPylonRadiusComponent'Default__Pylon.DrawPylonRadius0'
    PylonRadiusPreview=DrawPylonRadius0
    bRenderInShowPaths=true
    bDrawWalkableSurface=true
    bDrawObstacleSurface=true
    begin object name=NavMeshRenderer class=NavMeshRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: NavMeshRenderingComponent'Default__Pylon.NavMeshRenderer'
    RenderingComp=NavMeshRenderer
    begin object name=Sprite3 class=SpriteComponent
        Sprite=Texture2D'EditorResources.BadPylon'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite3'
    BrokenSprite=Sprite3
    Recast_CellSize=25
    Recast_CellHeight=10
    Recast_AgentMaxSlope=45
    NavMeshGen_MaxStepHeight=40
    BufferEpsilonToAddedToBoundsBoxForDropEdgeCheck=10
    DebugEdgeCount=-1
    bDestinationOnly=true
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Pylon.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.Pylon'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.Pylon'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__Pylon.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Pylon.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__Pylon.PathRenderer'
    Components(4)=PathRenderer
    begin object name=NavMeshRenderer class=NavMeshRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: NavMeshRenderingComponent'Default__Pylon.NavMeshRenderer'
    Components(5)=NavMeshRenderer
    begin object name=DrawPylonRadius0 class=DrawPylonRadiusComponent
        ReplacementPrimitive=none
    object end
    // Reference: DrawPylonRadiusComponent'Default__Pylon.DrawPylonRadius0'
    Components(6)=DrawPylonRadius0
    begin object name=Sprite3 class=SpriteComponent
        Sprite=Texture2D'EditorResources.BadPylon'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__Pylon.Sprite3'
    Components(7)=Sprite3
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__Pylon.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}