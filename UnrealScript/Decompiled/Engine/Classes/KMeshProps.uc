/*******************************************************************************
 * KMeshProps generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KMeshProps extends Object
    native
    noexport;

struct KSphereElem
{
    /** KAggregateGeom and all Elems are in UNREAL scale. InertiaTensor, COMOffset & Volume are in PHYSICS scale. */
    var() editconst Matrix TM;
    /** KAggregateGeom and all Elems are in UNREAL scale. InertiaTensor, COMOffset & Volume are in PHYSICS scale. */
    var() editconst float Radius;
    /** Disable rigid body collision for this shape. */
    var() bool bNoRBCollision;
    /** Check against this shape even when per-poly collision is being used. */
    var() bool bPerPolyShape;
    /** Disable UE's LineCheck collision with this shape and use it only for RBCollision.  Note: Opposite of a HitZone */
    var() bool bNoUECollision;
    /**  
     *When tracing HitZone collision return this name instead of the default bone name.  Allows us to have 
     *        multiple named collision zones assigned to the same bone.
     */
    var() name HitZoneName;

    structdefaultproperties
    {
        TM=(XPlane=(W=0,X=1,Y=0,Z=0),YPlane=(W=0,X=0,Y=1,Z=0),ZPlane=(W=0,X=0,Y=0,Z=1),WPlane=(W=1,X=0,Y=0,Z=0))
        Radius=1
        bNoRBCollision=false
        bPerPolyShape=false
        bNoUECollision=false
        HitZoneName=None
    }
};

struct KBoxElem
{
    var() editconst Matrix TM;
    /** Disable rigid body collision for this shape. */
    var() editconst float X;
    /** Disable rigid body collision for this shape. */
    var() editconst float Y;
    /** Disable rigid body collision for this shape. */
    var() editconst float Z;
    /** Disable rigid body collision for this shape. */
    var() bool bNoRBCollision;
    /** Check against this shape even when per-poly collision is being used. */
    var() bool bPerPolyShape;
    /** Disable UE's LineCheck collision with this shape and use it only for RBCollision.  Note: Opposite of a HitZone */
    var() bool bNoUECollision;
    /**  
     *When tracing HitZone collision return this name instead of the default bone name.  Allows us to have 
     *        multiple named collision zones assigned to the same bone.
     */
    var() name HitZoneName;

    structdefaultproperties
    {
        TM=(XPlane=(W=0,X=1,Y=0,Z=0),YPlane=(W=0,X=0,Y=1,Z=0),ZPlane=(W=0,X=0,Y=0,Z=1),WPlane=(W=1,X=0,Y=0,Z=0))
        X=1
        Y=1
        Z=1
        bNoRBCollision=false
        bPerPolyShape=false
        bNoUECollision=false
        HitZoneName=None
    }
};

struct KSphylElem
{
    /** The transform assumes the sphyl axis points down Z. */
    var() editconst Matrix TM;
    /** The transform assumes the sphyl axis points down Z. */
    var() editconst float Radius;
    /** The transform assumes the sphyl axis points down Z. */
    var() editconst float Length;
    /** Disable rigid body collision for this shape. */
    var() bool bNoRBCollision;
    /** Check against this shape even when per-poly collision is being used. */
    var() bool bPerPolyShape;
    /** Disable UE's LineCheck collision with this shape and use it only for RBCollision.  Note: Opposite of a HitZone */
    var() bool bNoUECollision;
    /**  
     *When tracing HitZone collision return this name instead of the default bone name.  Allows us to have 
     *        multiple named collision zones assigned to the same bone.
     */
    var() name HitZoneName;

    structdefaultproperties
    {
        TM=(XPlane=(W=0,X=1,Y=0,Z=0),YPlane=(W=0,X=0,Y=1,Z=0),ZPlane=(W=0,X=0,Y=0,Z=1),WPlane=(W=1,X=0,Y=0,Z=0))
        Radius=1
        Length=1
        bNoRBCollision=false
        bPerPolyShape=false
        bNoUECollision=false
        HitZoneName=None
    }
};

struct KConvexElem
{
    var array<Vector> VertexData;
    var array<Plane> PermutedVertexData;
    var array<int> FaceTriData;
    var array<Vector> EdgeDirections;
    var array<Vector> FaceNormalDirections;
    var array<Plane> FacePlaneData;
    var Box ElemBox;

    structdefaultproperties
    {
        VertexData=none
        PermutedVertexData=none
        FaceTriData=none
        EdgeDirections=none
        FaceNormalDirections=none
        FacePlaneData=none
        ElemBox=(Min=(X=0,Y=0,Z=0),Max=(X=0,Y=0,Z=0),IsValid=0)
    }
};

struct KAggregateGeom
{
    var() editfixedsize array<KSphereElem> SphereElems;
    var() editfixedsize array<KBoxElem> BoxElems;
    var() editfixedsize array<KSphylElem> SphylElems;
    var() editfixedsize array<KConvexElem> ConvexElems;
    var() editfixedsize array<KConvexElem> BoxMirrorConvexElems;
    var noimport nontransactional native Pointer RenderInfo;
    /** Collision against this geom will not specially handle the "close and parallel" case.  Special-case. */
    var() bool bSkipCloseAndParallelChecks;

    structdefaultproperties
    {
        SphereElems=none
        BoxElems=none
        SphylElems=none
        ConvexElems=none
        BoxMirrorConvexElems=none
        bSkipCloseAndParallelChecks=false
    }
};

/** User-entered offset. UNREAL UNITS */
var() Vector COMNudge;
var() KAggregateGeom AggGeom;
