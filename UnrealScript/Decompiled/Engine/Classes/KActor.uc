/*******************************************************************************
 * KActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class KActor extends DynamicSMActor
    native(Physics)
    nativereplication
    placeable
    classgroup(Physics);

var() bool bDamageAppliesImpulse;
var() repnotify bool bWakeOnLevelStart;
var bool bCurrentSlide;
var bool bSlideActive;
/** Enable 'Stay upright' torque, that tries to keep Z axis of KActor pointing along world Z */
var(StayUprightSpring) bool bEnableStayUprightSpring;
/** If TRUE limit the maximum speed this object can move. */
var() bool bLimitMaxPhysicsVelocity;
var transient bool bNeedsRBStateReplication;
var bool bDisableClientSidePawnInteractions;
var export editinline ParticleSystemComponent ImpactEffectComponent;
var export editinline AudioComponent ImpactSoundComponent;
var export editinline AudioComponent ImpactSoundComponent2;
var float LastImpactTime;
var PhysEffectInfo ImpactEffectInfo;
var export editinline ParticleSystemComponent SlideEffectComponent;
var export editinline AudioComponent SlideSoundComponent;
var float LastSlideTime;
var PhysEffectInfo SlideEffectInfo;
/** Torque applied to try and keep KActor horizontal. */
var(StayUprightSpring) float StayUprightTorqueFactor;
/** Max torque that can be applied to try and keep KActor horizontal */
var(StayUprightSpring) float StayUprightMaxTorque;
/** If bLimitMaxPhysicsVelocity is TRUE, this is how fast the object can move. */
var() float MaxPhysicsVelocity;
var native const RigidBodyState RBState;
var native const float AngErrorAccumulator;
var repnotify Vector ReplicatedDrawScale3D;
var transient Vector InitialLocation;
var transient Rotator InitialRotation;

replication
{
     if(bNeedsRBStateReplication && Role == ROLE_Authority)
        RBState;

     if(bNetInitial && Role == ROLE_Authority)
        ReplicatedDrawScale3D, bWakeOnLevelStart;
}

// Export UKActor::execGetKActorPhysMaterial(FFrame&, void* const)
native final function PhysicalMaterial GetKActorPhysMaterial();

// Export UKActor::execResolveRBState(FFrame&, void* const)
native final function ResolveRBState();

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    if(bWakeOnLevelStart && StaticMeshComponent != none)
    {
        StaticMeshComponent.WakeRigidBody();        
    }
    else
    {
        bNeedsRBStateReplication = !bNoDelete;
    }
    ReplicatedDrawScale3D = DrawScale3D * 1000;
    if((StaticMeshComponent != none) && StaticMeshComponent.bNotifyRigidBodyCollision)
    {
        SetPhysicalCollisionProperties();
    }
    InitialLocation = Location;
    InitialRotation = Rotation;
    if((bDisableClientSidePawnInteractions && Role != ROLE_Authority) && StaticMeshComponent != none)
    {
        StaticMeshComponent.SetRBCollidesWithChannel(2, false);
    }
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    ShutDown();
    super(Actor).FellOutOfWorld(dmgType);
}

simulated event Destroyed()
{
    if(ImpactEffectInfo.Sound != none)
    {
        if(ImpactSoundComponent != none)
        {
            ImpactSoundComponent.bAutoDestroy = true;
        }
        if(ImpactSoundComponent2 != none)
        {
            ImpactSoundComponent2.bAutoDestroy = true;
        }
    }
    if(SlideEffectInfo.Sound != none)
    {
        SlideSoundComponent.bAutoDestroy = true;
    }
    super(Actor).Destroyed();
}

simulated function SetPhysicalCollisionProperties()
{
    local PhysicalMaterial PhysMat;

    PhysMat = GetKActorPhysMaterial();
    ImpactEffectInfo = PhysMat.FindPhysEffectInfo(0);
    SlideEffectInfo = PhysMat.FindPhysEffectInfo(1);
    if(ImpactEffectInfo.Effect != none)
    {
        ImpactEffectComponent = new (self) Class'ParticleSystemComponent';
        ImpactEffectComponent.bAutoActivate = false;
        ImpactEffectComponent.SetTemplate(ImpactEffectInfo.Effect);
    }
    if(SlideEffectInfo.Effect != none)
    {
        SlideEffectComponent = new (self) Class'ParticleSystemComponent';
        SlideEffectComponent.bAutoActivate = false;
        SlideEffectComponent.SetTemplate(SlideEffectInfo.Effect);
    }
}

simulated event SpawnedByKismet()
{
    if(StaticMeshComponent.bNotifyRigidBodyCollision)
    {
        SetPhysicalCollisionProperties();
    }
    InitialLocation = Location;
    InitialRotation = Rotation;
}

simulated event ReplicatedEvent(name VarName)
{
    local Vector NewDrawScale3D;

    if(VarName == 'bWakeOnLevelStart')
    {
        if(bWakeOnLevelStart)
        {
            StaticMeshComponent.WakeRigidBody();
        }        
    }
    else
    {
        if(VarName == 'ReplicatedDrawScale3D')
        {
            NewDrawScale3D = ReplicatedDrawScale3D / 1000;
            SetDrawScale3D(NewDrawScale3D);            
        }
        else
        {
            super.ReplicatedEvent(VarName);
        }
    }
}

event ApplyImpulse(Vector ImpulseDir, float ImpulseMag, Vector HitLocation, optional TraceHitInfo HitInfo, optional class<DamageType> DamageType)
{
    local Vector AppliedImpulse;

    AppliedImpulse = Normal(ImpulseDir) * ImpulseMag;
    if(HitInfo.HitComponent != none)
    {
        HitInfo.HitComponent.AddImpulse(AppliedImpulse, HitLocation, HitInfo.BoneName);        
    }
    else
    {
        CollisionComponent.AddImpulse(AppliedImpulse, HitLocation);
    }
}

event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    super(Actor).TakeDamage(Damage, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if(bDamageAppliesImpulse && DamageType.default.KDamageImpulse > float(0))
    {
        if(VSize(Momentum) < 0.001)
        {
            LogInternal("Zero momentum to KActor.TakeDamage");
            return;
        }
        ApplyImpulse(Momentum, DamageType.default.KDamageImpulse, HitLocation, HitInfo, DamageType);
    }
}

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    local int Idx;
    local SeqEvent_TakeDamage DmgEvt;

    DamageFalloffExponent = 1;
    Idx = 0;
    J0x14:

    if(Idx < GeneratedEvents.Length)
    {
        DmgEvt = SeqEvent_TakeDamage(GeneratedEvents[Idx]);
        if(DmgEvt != none)
        {
            DmgEvt.HandleDamage(self, InstigatedBy, DamageType, int(BaseDamage));
        }
        ++ Idx;
        goto J0x14;
    }
    if((bDamageAppliesImpulse && DamageType.default.RadialDamageImpulse > float(0)) && Role == ROLE_Authority)
    {
        CollisionComponent.AddRadialImpulse(HurtOrigin, DamageRadius, DamageType.default.RadialDamageImpulse, 1, DamageType.default.bRadialDamageVelChange);
    }
}

simulated function OnToggle(SeqAct_Toggle Action)
{
    if(Action.InputLinks[0].bHasImpulse)
    {
        StaticMeshComponent.WakeRigidBody();
    }
}

simulated function OnTeleport(SeqAct_Teleport inAction)
{
    local array<Object> objVars;
    local int Idx;
    local Actor destActor;

    inAction.GetObjectVars(objVars, "Destination");
    Idx = 0;
    J0x40:

    if((Idx < objVars.Length) && destActor == none)
    {
        destActor = Actor(objVars[Idx]);
        ++ Idx;
        goto J0x40;
    }
    if(destActor != none)
    {
        StaticMeshComponent.SetRBPosition(destActor.Location);
        StaticMeshComponent.SetRBRotation(destActor.Rotation);
        PlayTeleportEffect(false, true);
    }
}

simulated function Reset()
{
    StaticMeshComponent.SetRBLinearVelocity(vect(0, 0, 0));
    StaticMeshComponent.SetRBAngularVelocity(vect(0, 0, 0));
    StaticMeshComponent.SetRBPosition(InitialLocation);
    StaticMeshComponent.SetRBRotation(InitialRotation);
    if(!bWakeOnLevelStart)
    {
        StaticMeshComponent.PutRigidBodyToSleep();        
    }
    else
    {
        StaticMeshComponent.WakeRigidBody();
    }
    ResolveRBState();
    bForceNetUpdate = true;
    super(Actor).Reset();
}

defaultproperties
{
    bDamageAppliesImpulse=true
    bNeedsRBStateReplication=true
    bDisableClientSidePawnInteractions=true
    StayUprightTorqueFactor=1000
    StayUprightMaxTorque=1500
    MaxPhysicsVelocity=350
    ReplicatedDrawScale3D=(X=1000,Y=1000,Z=1000)
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=128,G=255,R=0,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__KActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        BlockRigidBody=true
        bBlockFootPlacement=false
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__KActor.StaticMeshComponent0'
    StaticMeshComponent=StaticMeshComponent0
    LightEnvironment=DynamicLightEnvironmentComponent'Default__KActor.MyLightEnvironment'
    bPawnCanBaseOn=false
    bSafeBaseIfAsleep=true
    Components(0)=DynamicLightEnvironmentComponent'Default__KActor.MyLightEnvironment'
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=128,G=255,R=0,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__KActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        BlockRigidBody=true
        bBlockFootPlacement=false
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__KActor.StaticMeshComponent0'
    Components(1)=StaticMeshComponent0
    Physics=EPhysics.PHYS_RigidBody
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    TickGroup=ETickingGroup.TG_PostAsyncWork
    bNoDelete=true
    bAlwaysRelevant=true
    bUpdateSimulatedPosition=true
    bNetInitialRotation=true
    bBlocksNavigation=true
    bCollideActors=true
    bBlockActors=true
    bProjTarget=true
    bBlocksTeleport=true
    bNoEncroachCheck=true
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(B=128,G=255,R=0,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__KActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        BlockRigidBody=true
        bBlockFootPlacement=false
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__KActor.StaticMeshComponent0'
    CollisionComponent=StaticMeshComponent0
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
    SupportedEvents(6)=class'SeqEvent_RigidBodyCollision'
}