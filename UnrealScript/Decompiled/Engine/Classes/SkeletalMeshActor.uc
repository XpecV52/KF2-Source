/*******************************************************************************
 * SkeletalMeshActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SkeletalMeshActor extends Actor
    native(Anim)
    placeable
    hidecategories(Navigation)
    classgroup(SkeletalMeshes);

struct CheckpointRecord
{
    var bool bReplicated;
    var bool bHidden;
    var bool bSavedPosition;
    var Vector Location;
    var Rotator Rotation;

    structdefaultproperties
    {
        bReplicated=false
        bHidden=false
        bSavedPosition=false
        Location=(X=0,Y=0,Z=0)
        Rotation=(Pitch=0,Yaw=0,Roll=0)
    }
};

struct native SkelMeshActorControlTarget
{
    /** Name of SkelControl to update */
    var() name ControlName;
    /** Actor to use for location of skel control target. */
    var() Actor TargetActor;

    structdefaultproperties
    {
        ControlName=None
        TargetActor=none
    }
};

var() bool bDamageAppliesImpulse;
/** Whether or not this actor should respond to anim notifies - CURRENTLY ONLY AFFECTS PlayParticleEffect NOTIFIES */
var() bool bShouldDoAnimNotifies;
/** @hack: force saving positional data in checkpoint - some uses in Matinee require this */
var() bool bForceSaveInCheckpoint;
var deprecated bool bCollideActors_OldValue;
/** If TRUE, attachments are set to use this actors mesh as a shadow parent and share this actors light environment */
var() bool bShouldShadowParentAllAttachedActors;
var() export editinline SkeletalMeshComponent SkeletalMeshComponent;
var() const editconst export editinline LightEnvironmentComponent LightEnvironment;
var export editinline AudioComponent FacialAudioComp;
var repnotify transient SkeletalMesh ReplicatedMesh;
var repnotify MaterialInterface ReplicatedMaterial0;
var repnotify MaterialInterface ReplicatedMaterial1;
/** Set of skel controls to update targets of, based on Actor location */
var() array<SkelMeshActorControlTarget> ControlTargets;
var transient array<InterpGroup> InterpGroupList;
var private transient name SavedAnimSeqName;
var private transient float SavedCurrentTime;

replication
{
     if(Role == ROLE_Authority)
        ReplicatedMaterial0, ReplicatedMaterial1, 
        ReplicatedMesh;
}

simulated event PostBeginPlay()
{
    if((Role == ROLE_Authority) && SkeletalMeshComponent != none)
    {
        ReplicatedMesh = SkeletalMeshComponent.SkeletalMesh;
    }
    if(bShouldShadowParentAllAttachedActors)
    {
        SetShadowParentOnAllAttachedComponents(SkeletalMeshComponent, LightEnvironment);
    }
    if((SkeletalMeshComponent != none) && SkeletalMeshComponent.PhysicsAssetInstance != none)
    {
        SkeletalMeshComponent.PhysicsAssetInstance.SetFullAnimWeightBonesFixed(false, SkeletalMeshComponent);
    }
    if(bHidden)
    {
        SkeletalMeshComponent.SetClothFrozen(true);
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        SetTickIsDisabled(true);
    }
}

simulated event Destroyed()
{
    super.Destroyed();
    InterpGroupList.Length = 0;
    UpdateAnimSetList();
}

// Export USkeletalMeshActor::execUpdateAnimSetList(FFrame&, void* const)
native simulated function UpdateAnimSetList();

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'ReplicatedMesh')
    {
        SkeletalMeshComponent.SetSkeletalMesh(ReplicatedMesh);        
    }
    else
    {
        if(VarName == 'ReplicatedMaterial0')
        {
            SkeletalMeshComponent.SetMaterial(0, ReplicatedMaterial0);            
        }
        else
        {
            if(VarName == 'ReplicatedMaterial1')
            {
                SkeletalMeshComponent.SetMaterial(1, ReplicatedMaterial1);                
            }
            else
            {
                super.ReplicatedEvent(VarName);
            }
        }
    }
}

simulated function OnToggle(SeqAct_Toggle Action)
{
    local AnimNodeSequence SeqNode;

    SeqNode = AnimNodeSequence(SkeletalMeshComponent.Animations);
    if(SeqNode != none)
    {
        if(Action.InputLinks[0].bHasImpulse)
        {
            if(!SeqNode.bPlaying)
            {
                SeqNode.PlayAnim(SeqNode.bLooping, SeqNode.Rate, 0);
            }            
        }
        else
        {
            if(Action.InputLinks[1].bHasImpulse)
            {
                if(SeqNode.bPlaying)
                {
                    SeqNode.StopAnim();
                }                
            }
            else
            {
                if(Action.InputLinks[2].bHasImpulse)
                {
                    if(SeqNode.bPlaying)
                    {
                        SeqNode.StopAnim();                        
                    }
                    else
                    {
                        SeqNode.PlayAnim(SeqNode.bLooping, SeqNode.Rate, 0);
                    }
                }
            }
        }
    }
}

function OnSetMaterial(SeqAct_SetMaterial Action)
{
    SkeletalMeshComponent.SetMaterial(Action.MaterialIndex, Action.NewMaterial);
    if(Action.MaterialIndex == 0)
    {
        ReplicatedMaterial0 = Action.NewMaterial;
        ForceNetRelevant();
    }
    if(Action.MaterialIndex == 1)
    {
        ReplicatedMaterial1 = Action.NewMaterial;
        ForceNetRelevant();
    }
}

simulated event BeginAnimControl(InterpGroup InInterpGroup)
{
    MAT_BeginAnimControl(InInterpGroup);
}

// Export USkeletalMeshActor::execMAT_BeginAnimControl(FFrame&, void* const)
native function MAT_BeginAnimControl(InterpGroup InInterpGroup);

simulated event SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
    local AnimNodeSequence SeqNode;

    SkeletalMeshComponent.LastRenderTime = WorldInfo.TimeSeconds;
    SeqNode = AnimNodeSequence(SkeletalMeshComponent.Animations);
    if(SeqNode != none)
    {
        if((SeqNode.AnimSeqName != InAnimSeqName) || SeqNode.AnimSeq == none)
        {
            SeqNode.SetAnim(InAnimSeqName);
        }
        SeqNode.bLooping = bLooping;
        SeqNode.SetPosition(InPosition, bFireNotifies);
    }
}

simulated event FinishAnimControl(InterpGroup InInterpGroup)
{
    MAT_FinishAnimControl(InInterpGroup);
}

// Export USkeletalMeshActor::execMAT_FinishAnimControl(FFrame&, void* const)
native function MAT_FinishAnimControl(InterpGroup InInterpGroup);

simulated event bool PlayActorFaceFXAnim(FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay)
{
    return SkeletalMeshComponent.PlayFaceFXAnim(AnimSet, SeqName, GroupName, SoundCueToPlay, AkEventToPlay);
}

simulated event StopActorFaceFXAnim()
{
    SkeletalMeshComponent.StopFaceFXAnim();
}

simulated event AudioComponent GetFaceFXAudioComponent()
{
    return FacialAudioComp;
}

simulated function OnPlayFaceFXAnim(SeqAct_PlayFaceFXAnim inAction)
{
    local PlayerController PC;

    SkeletalMeshComponent.PlayFaceFXAnim(inAction.FaceFXAnimSetRef, inAction.FaceFXAnimName, inAction.FaceFXGroupName, inAction.SoundCueToPlay, inAction.AkEventToPlay);
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(NetConnection(PC.Player) != none)
        {
            PC.ClientPlayActorFaceFXAnim(self, inAction.FaceFXAnimSetRef, inAction.FaceFXGroupName, inAction.FaceFXAnimName, inAction.SoundCueToPlay, inAction.AkEventToPlay);
        }        
    }    
}

simulated event FaceFXAsset GetActorFaceFXAsset()
{
    if((SkeletalMeshComponent.SkeletalMesh != none) && !SkeletalMeshComponent.bDisableFaceFX)
    {
        return SkeletalMeshComponent.SkeletalMesh.FaceFXAsset;        
    }
    else
    {
        return none;
    }
}

simulated function bool IsActorPlayingFaceFXAnim()
{
    return (SkeletalMeshComponent != none) && SkeletalMeshComponent.IsPlayingFaceFXAnim();
}

event OnSetMesh(SeqAct_SetMesh Action)
{
    if(Action.MeshType == 1)
    {
        if((Action.NewSkeletalMesh != none) && Action.NewSkeletalMesh != SkeletalMeshComponent.SkeletalMesh)
        {
            SkeletalMeshComponent.SetSkeletalMesh(Action.NewSkeletalMesh);
            ReplicatedMesh = Action.NewSkeletalMesh;
        }
    }
}

simulated event OnUpdatePhysBonesFromAnim(SeqAct_UpdatePhysBonesFromAnim Action)
{
    if(Action.InputLinks[0].bHasImpulse)
    {
        SkeletalMeshComponent.ForceSkelUpdate();
        SkeletalMeshComponent.UpdateRBBonesFromSpaceBases(true, true);
        SkeletalMeshComponent.ForceApexClothingTeleportAndReset();        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            if(SkeletalMeshComponent.PhysicsAssetInstance != none)
            {
                SkeletalMeshComponent.PhysicsAssetInstance.SetAllBodiesFixed(true);
            }            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                if(SkeletalMeshComponent.PhysicsAssetInstance != none)
                {
                    SkeletalMeshComponent.PhysicsAssetInstance.SetFullAnimWeightBonesFixed(false, SkeletalMeshComponent);
                }
            }
        }
    }
}

simulated event OnSetSkelControlTarget(SeqAct_SetSkelControlTarget Action)
{
    local int I;

    if((Action.SkelControlName == 'None') || Action.TargetActors.Length == 0)
    {
        return;
    }
    I = 0;
    J0x60:

    if(I < ControlTargets.Length)
    {
        if(ControlTargets[I].ControlName == Action.SkelControlName)
        {
            ControlTargets[I].TargetActor = Actor(Action.TargetActors[Rand(Action.TargetActors.Length)]);
            return;
        }
        ++ I;
        goto J0x60;
    }
    ControlTargets.Length = ControlTargets.Length + 1;
    ControlTargets[ControlTargets.Length - 1].ControlName = Action.SkelControlName;
    ControlTargets[ControlTargets.Length - 1].TargetActor = Actor(Action.TargetActors[Rand(Action.TargetActors.Length)]);
}

function DoKismetAttachment(Actor Attachment, SeqAct_AttachToActor Action)
{
    local bool bOldCollideActors, bOldBlockActors, bValidBone, bValidSocket;

    if((SkeletalMeshComponent != none) && Action.BoneName != 'None')
    {
        bValidSocket = SkeletalMeshComponent.GetSocketByName(Action.BoneName) != none;
        bValidBone = SkeletalMeshComponent.MatchRefBone(Action.BoneName) != -1;
        if(!bValidBone && !bValidSocket)
        {
            LogInternal((((((((string(WorldInfo.TimeSeconds) @ string(Class)) @ string(GetFuncName())) @ "bone or socket") @ string(Action.BoneName)) @ "not found on actor") @ string(self)) @ "with mesh") @ string(SkeletalMeshComponent));
        }
    }
    if(bValidBone || bValidSocket)
    {
        bOldCollideActors = Attachment.bCollideActors;
        bOldBlockActors = Attachment.bBlockActors;
        Attachment.SetCollision(false, false);
        Attachment.SetHardAttach(Action.bHardAttach);
        if(bValidBone && !bValidSocket)
        {
            if(Action.bUseRelativeOffset)
            {
                Attachment.SetLocation(SkeletalMeshComponent.GetBoneLocation(Action.BoneName));
            }
            if(Action.bUseRelativeRotation)
            {
                Attachment.SetRotation(QuatToRotator(SkeletalMeshComponent.GetBoneQuaternion(Action.BoneName)));
            }
        }
        Attachment.SetBase(self,, SkeletalMeshComponent, Action.BoneName);
        if(Action.bUseRelativeRotation)
        {
            Attachment.SetRelativeRotation(Attachment.RelativeRotation + Action.RelativeRotation);
        }
        if(Action.bUseRelativeOffset)
        {
            Attachment.SetRelativeLocation(Attachment.RelativeLocation + Action.RelativeOffset);
        }
        Attachment.SetCollision(bOldCollideActors, bOldBlockActors);        
    }
    else
    {
        super.DoKismetAttachment(Attachment, Action);
    }
}

simulated event TakeDamage(int Damage, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local Vector ApplyImpulse;

    super.TakeDamage(Damage, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    if(bDamageAppliesImpulse && DamageType.default.KDamageImpulse > float(0))
    {
        if(VSize(Momentum) < 0.001)
        {
            LogInternal("Zero momentum to SkeletalMeshActor.TakeDamage");
            return;
        }
        ApplyImpulse = Normal(Momentum) * DamageType.default.KDamageImpulse;
        if(HitInfo.HitComponent != none)
        {
            HitInfo.HitComponent.AddImpulse(ApplyImpulse, HitLocation, HitInfo.BoneName);
        }
    }
}

function bool ShouldSaveForCheckpoint()
{
    return ((RemoteRole != ROLE_None) || bForceSaveInCheckpoint) || IsInPersistentLevel(true);
}

function CreateCheckpointRecord(out CheckpointRecord Record)
{
    Record.bReplicated = RemoteRole != ROLE_None;
    Record.bHidden = bHidden;
    if(bForceSaveInCheckpoint || IsInPersistentLevel(true))
    {
        Record.bSavedPosition = true;
        Record.Location = Location;
        Record.Rotation = Rotation;
    }
}

function ApplyCheckpointRecord(const out CheckpointRecord Record)
{
    SetHidden(Record.bHidden);
    if(Record.bSavedPosition)
    {
        SetLocation(Record.Location);
        SetRotation(Record.Rotation);
    }
    if(Record.bReplicated)
    {
        ForceNetRelevant();
        if(RemoteRole != ROLE_None)
        {
            SetForcedInitialReplicatedProperty(BoolProperty'bHidden', bHidden == default.bHidden);
        }
    }
}

event bool PlayParticleEffect(const AnimNotify_PlayParticleEffect AnimNotifyData)
{
    local Vector Loc;
    local Rotator Rot;
    local editinline ParticleSystemComponent PSC;
    local bool bPlayNonExtreme;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        LogInternal("(SkeletalMeshActor): PlayParticleEffect on dedicated server!");
        return true;
    }
    bPlayNonExtreme = (AnimNotifyData.bIsExtremeContent == true) && WorldInfo.GRI.ShouldShowGore() == false;
    if((bShouldDoAnimNotifies == false) || bPlayNonExtreme && AnimNotifyData.PSNonExtremeContentTemplate == none)
    {
        return true;
    }
    if(AnimNotifyData.bAttach == true)
    {
        PSC = new (self) Class'ParticleSystemComponent';
        if(bPlayNonExtreme)
        {
            PSC.SetTemplate(AnimNotifyData.PSNonExtremeContentTemplate);            
        }
        else
        {
            PSC.SetTemplate(AnimNotifyData.PSTemplate);
        }
        if(AnimNotifyData.SocketName != 'None')
        {
            SkeletalMeshComponent.AttachComponentToSocket(PSC, AnimNotifyData.SocketName);            
        }
        else
        {
            if(AnimNotifyData.BoneName != 'None')
            {
                SkeletalMeshComponent.AttachComponent(PSC, AnimNotifyData.BoneName);
            }
        }
        PSC.ActivateSystem();
        PSC.__OnSystemFinished__Delegate = SkelMeshActorOnParticleSystemFinished;        
    }
    else
    {
        if(AnimNotifyData.SocketName != 'None')
        {
            SkeletalMeshComponent.GetSocketWorldLocationAndRotation(AnimNotifyData.SocketName, Loc, Rot);            
        }
        else
        {
            if(AnimNotifyData.BoneName != 'None')
            {
                Loc = SkeletalMeshComponent.GetBoneLocation(AnimNotifyData.BoneName);
                Rot = QuatToRotator(SkeletalMeshComponent.GetBoneQuaternion(AnimNotifyData.BoneName));                
            }
            else
            {
                Loc = Location;
                Rot = rot(0, 0, 1);
            }
        }
        PSC = WorldInfo.MyEmitterPool.SpawnEmitter(AnimNotifyData.PSTemplate, Loc, Rot);
    }
    if((PSC != none) && AnimNotifyData.BoneSocketModuleActorName != 'None')
    {
        PSC.SetLightingChannels(SkeletalMeshComponent.LightingChannels);
        PSC.SetActorParameter(AnimNotifyData.BoneSocketModuleActorName, self);
    }
    return true;
}

simulated function SkelMeshActorOnParticleSystemFinished(ParticleSystemComponent PSC)
{
    SkeletalMeshComponent.DetachComponent(PSC);
}

event bool CreateForceField(const AnimNotify_ForceField AnimNotifyData)
{
    local editinline NxForceFieldComponent NewForceFieldComponent;

    NewForceFieldComponent = new (SkeletalMeshComponent) AnimNotifyData.ForceFieldComponent.Class (AnimNotifyData.ForceFieldComponent);
    NewForceFieldComponent.DoInitRBPhys();
    if(AnimNotifyData.SocketName != 'None')
    {
        SkeletalMeshComponent.AttachComponentToSocket(NewForceFieldComponent, AnimNotifyData.SocketName);        
    }
    else
    {
        if(AnimNotifyData.BoneName != 'None')
        {
            SkeletalMeshComponent.AttachComponent(NewForceFieldComponent, AnimNotifyData.BoneName);
        }
    }
    return true;
}

defaultproperties
{
    bShouldDoAnimNotifies=true
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__SkeletalMeshActor.AnimNodeSeq0'
        bUpdateSkelWhenNotRendered=false
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__SkeletalMeshActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        CollideActors=true
        BlockZeroExtent=true
        LightingChannels=(bInitialized=true,Indoor=true,Outdoor=true)
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: SkeletalMeshComponent'Default__SkeletalMeshActor.SkeletalMeshComponent0'
    SkeletalMeshComponent=SkeletalMeshComponent0
    LightEnvironment=DynamicLightEnvironmentComponent'Default__SkeletalMeshActor.MyLightEnvironment'
    FacialAudioComp=AudioComponent'Default__SkeletalMeshActor.FaceAudioComponent'
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__SkeletalMeshActor.AnimNodeSeq0'
        bUpdateSkelWhenNotRendered=false
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__SkeletalMeshActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        CollideActors=true
        BlockZeroExtent=true
        LightingChannels=(bInitialized=true,Indoor=true,Outdoor=true)
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: SkeletalMeshComponent'Default__SkeletalMeshActor.SkeletalMeshComponent0'
    Components(0)=SkeletalMeshComponent0
    Components(1)=AudioComponent'Default__SkeletalMeshActor.FaceAudioComponent'
    bNoDelete=true
    bProjTarget=true
    bNoEncroachCheck=true
    bEdShouldSnap=true
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__SkeletalMeshActor.AnimNodeSeq0'
        bUpdateSkelWhenNotRendered=false
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__SkeletalMeshActor.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        CollideActors=true
        BlockZeroExtent=true
        LightingChannels=(bInitialized=true,Indoor=true,Outdoor=true)
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
    object end
    // Reference: SkeletalMeshComponent'Default__SkeletalMeshActor.SkeletalMeshComponent0'
    CollisionComponent=SkeletalMeshComponent0
}