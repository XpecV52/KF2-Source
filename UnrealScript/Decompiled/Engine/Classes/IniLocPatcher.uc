/*******************************************************************************
 * IniLocPatcher generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class IniLocPatcher extends Object
    native
    config(Engine);

struct native IniLocFileEntry
{
    var string Filename;
    var string DLName;
    var string HashCode;
    var bool bIsUnicode;
    var OnlineSubsystem.EOnlineEnumerationReadState ReadState;

    structdefaultproperties
    {
        Filename=""
        DLName=""
        HashCode=""
        bIsUnicode=false
        ReadState=EOnlineEnumerationReadState.OERS_NotStarted
    }
};

var config array<config IniLocFileEntry> Files;
var config bool bRequestEmsFileList;
var config int MaxCachedFileAge;
var transient OnlineTitleFileInterface TitleFileInterface;
var transient OnlineTitleFileCacheInterface TitleFileCacheInterface;
var array< delegate<OnReadTitleFileComplete> > ReadTitleFileCompleteDelegates;
var delegate<OnReadTitleFileComplete> __OnReadTitleFileComplete__Delegate;
var delegate<OnAllTitleFilesCompleted> __OnAllTitleFilesCompleted__Delegate;

delegate OnReadTitleFileComplete(bool bWasSuccessful, string Filename);

delegate OnAllTitleFilesCompleted();

function Init()
{
    local OnlineSubsystem OnlineSub;
    local int Index;

    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        TitleFileInterface = OnlineSub.TitleFileInterface;
        if(NotEqual_InterfaceInterface(TitleFileInterface, (none)))
        {
            TitleFileInterface.AddReadTitleFileCompleteDelegate(OnDownloadFileComplete);            
        }
        else
        {
            Index = 0;
            J0xBF:

            if(Index < Files.Length)
            {
                Files[Index].ReadState = 3;
                ++ Index;
                goto J0xBF;
            }
        }
        TitleFileCacheInterface = OnlineSub.TitleFileCacheInterface;
        if(NotEqual_InterfaceInterface(TitleFileCacheInterface, (none)))
        {
            TitleFileCacheInterface.AddLoadTitleFileCompleteDelegate(OnFileCacheLoadComplete);
            TitleFileCacheInterface.AddSaveTitleFileCompleteDelegate(OnFileCacheSaveComplete);
        }
    }
}

function DownloadFiles()
{
    local int FileIdx;

    if(bRequestEmsFileList)
    {
        if((MaxCachedFileAge > 0) && NotEqual_InterfaceInterface(TitleFileCacheInterface, (none)))
        {
            TitleFileCacheInterface.DeleteTitleFiles(float(MaxCachedFileAge));
        }
        TitleFileInterface.AddRequestTitleFileListCompleteDelegate(OnRequestTitleFileListComplete);
        TitleFileInterface.RequestTitleFileList();        
    }
    else
    {
        FileIdx = 0;
        J0xC8:

        if(FileIdx < Files.Length)
        {
            Files[FileIdx].DLName = Files[FileIdx].Filename;
            ++ FileIdx;
            goto J0xC8;
        }
        StartLoadingFiles();
    }
}

function OnRequestTitleFileListComplete(bool bWasSuccessful, string ResultStr)
{
    local JsonObject Root;
    local int JsonObjectIdx;
    local IniLocFileEntry RequestFileEntry;

    TitleFileInterface.ClearRequestTitleFileListCompleteDelegate(OnRequestTitleFileListComplete);
    if(bWasSuccessful)
    {
        Root = Class'JsonObject'.static.DecodeJson(ResultStr);
        if(Root != none)
        {
            Files.Length = 0;
            JsonObjectIdx = 0;
            J0x96:

            if(JsonObjectIdx < Root.ObjectArray.Length)
            {
                RequestFileEntry.Filename = Root.ObjectArray[JsonObjectIdx].GetStringValue("file_name");
                RequestFileEntry.DLName = Root.ObjectArray[JsonObjectIdx].GetStringValue("dl_name");
                RequestFileEntry.HashCode = Root.ObjectArray[JsonObjectIdx].GetStringValue("hash_code");
                RequestFileEntry.bIsUnicode = (InStr(RequestFileEntry.Filename, ".ini",, true) == -1) && InStr(RequestFileEntry.Filename, ".int",, true) == -1;
                Files.AddItem(RequestFileEntry;
                ++ JsonObjectIdx;
                goto J0x96;
            }
            StartLoadingFiles();            
        }
        else
        {
            LogInternal(((((((("(" $ string(Name)) $ ") IniLocPatcher::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Download of file list failed. Bad json.") @ "ResultStr=") $ ResultStr);
        }        
    }
    else
    {
        LogInternal(((((("(" $ string(Name)) $ ") IniLocPatcher::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Download of file list failed.");
    }
}

function StartLoadingFiles()
{
    local int Index;

    if(bRequestEmsFileList)
    {
        if(NotEqual_InterfaceInterface(TitleFileCacheInterface, (none)))
        {
            Index = 0;
            J0x38:

            if(Index < Files.Length)
            {
                if(Files[Index].ReadState == 0)
                {
                    Files[Index].ReadState = 1;
                    if(!TitleFileCacheInterface.LoadTitleFile(Files[Index].DLName))
                    {
                        if((Files[Index].ReadState != 2) && Files[Index].ReadState != 3)
                        {
                            Files[Index].ReadState = 1;                            
                        }
                        else
                        {
                            Files[Index].ReadState = 3;
                        }
                    }
                }
                ++ Index;
                goto J0x38;
            }
        }        
    }
    else
    {
        if(NotEqual_InterfaceInterface(TitleFileInterface, (none)))
        {
            Index = 0;
            J0x1EA:

            if(Index < Files.Length)
            {
                if(Files[Index].ReadState == 0)
                {
                    Files[Index].Filename = UpdateLocFileName(Files[Index].Filename);
                    if(TitleFileInterface.ReadTitleFile(Files[Index].DLName))
                    {
                        Files[Index].ReadState = 1;                        
                    }
                    else
                    {
                        Files[Index].ReadState = 3;
                    }
                }
                ++ Index;
                goto J0x1EA;
            }
        }
    }
}

function OnDownloadFileComplete(bool bWasSuccessful, string Filename)
{
    local bool bSuccessLoad;
    local int Index;
    local array<byte> FileData;

    Index = 0;
    J0x0B:

    if(Index < Files.Length)
    {
        if(Files[Index].DLName == Filename)
        {
            if(bWasSuccessful)
            {
                if(TitleFileInterface.GetTitleFileContents(Filename, FileData) && FileData.Length > 0)
                {
                    bSuccessLoad = true;
                    Files[Index].ReadState = 2;
                    if(bRequestEmsFileList && NotEqual_InterfaceInterface(TitleFileCacheInterface, (none)))
                    {
                        TitleFileCacheInterface.SaveTitleFile(Files[Index].DLName, Files[Index].Filename, FileData);
                    }
                    TitleFileInterface.ClearDownloadedFile(Filename);
                    ProcessIniLocFile(Files[Index].Filename, Files[Index].bIsUnicode, FileData);                    
                }
                else
                {
                    Files[Index].ReadState = 3;
                }                
            }
            else
            {
                LogInternal(((("Failed to download the file from system interface." @ "DLName=") $ Files[Index].DLName) @ "Filename=") $ Files[Index].Filename);
                Files[Index].ReadState = 3;
            }
            goto J0x315;
        }
        ++ Index;
        goto J0x0B;
    }
    J0x315:

    TriggerDownloadCompleteDelegates(bSuccessLoad, Filename);
}

function OnFileCacheLoadComplete(bool bWasSuccessful, string Filename)
{
    local int Index;
    local array<byte> FileData;
    local bool bRequiresDownload;

    bRequiresDownload = true;
    Index = 0;
    J0x17:

    if(Index < Files.Length)
    {
        if(Files[Index].DLName == Filename)
        {
            if(bWasSuccessful)
            {
                if(TitleFileCacheInterface.GetTitleFileHash(Filename) == Files[Index].HashCode)
                {
                    if(TitleFileCacheInterface.GetTitleFileContents(Filename, FileData) && FileData.Length > 0)
                    {
                        Files[Index].ReadState = 2;
                        bRequiresDownload = false;
                        if(InStr(Files[Index].Filename, ".bin", false, true) == -1)
                        {
                            ProcessIniLocFile(Files[Index].Filename, Files[Index].bIsUnicode, FileData);
                            TitleFileCacheInterface.ClearCachedFile(Filename);
                        }
                    }                    
                }
                else
                {
                    LogInternal(((("Hash for file cache entry not valid." @ "DLName=") $ Files[Index].DLName) @ "Filename=") $ Files[Index].Filename);
                }
            }
            goto J0x2A9;
        }
        ++ Index;
        goto J0x17;
    }
    J0x2A9:

    if(bRequiresDownload)
    {
        TitleFileCacheInterface.DeleteTitleFile(Filename);
        if(NotEqual_InterfaceInterface(TitleFileInterface, (none)) && TitleFileInterface.ReadTitleFile(Filename))
        {
            Files[Index].ReadState = 1;            
        }
        else
        {
            Files[Index].ReadState = 3;
        }        
    }
    else
    {
        TriggerDownloadCompleteDelegates(true, Filename);
    }
}

function OnFileCacheSaveComplete(bool bWasSuccessful, string Filename)
{
    local string LogicalName;

    LogicalName = TitleFileCacheInterface.GetTitleFileLogicalName(Filename);
    if(InStr(LogicalName, ".bin", false, true) == -1)
    {
        TitleFileCacheInterface.ClearCachedFile(Filename);
    }
}

function TriggerDownloadCompleteDelegates(bool bSuccess, string Filename)
{
    local int Index;
    local delegate<OnReadTitleFileComplete> OnReadTitleFileComplete;

    Index = 0;
    J0x0B:

    if(Index < ReadTitleFileCompleteDelegates.Length)
    {
        if(ReadTitleFileCompleteDelegates[Index] != none)
        {
            OnReadTitleFileComplete = ReadTitleFileCompleteDelegates[Index];
            OnReadTitleFileComplete(bSuccess, Filename);
        }
        ++ Index;
        goto J0x0B;
    }
    CheckForAllFilesComplete();
}

function CheckForAllFilesComplete()
{
    local int Index;
    local bool bAllFilesComplete;

    bAllFilesComplete = true;
    Index = 0;
    J0x17:

    if(Index < Files.Length)
    {
        if((Files[Index].ReadState == 0) || Files[Index].ReadState == 1)
        {
            bAllFilesComplete = false;
        }
        ++ Index;
        goto J0x17;
    }
    if(bAllFilesComplete)
    {
        OnAllTitleFilesCompleted();
    }
}

// Export UIniLocPatcher::execProcessIniLocFile(FFrame&, void* const)
native function ProcessIniLocFile(string Filename, bool bIsUnicode, const out array<byte> FileData);

function AddFileToDownload(string Filename)
{
    local int FileIndex;

    FileIndex = Files.Find('Filename', Filename;
    if(FileIndex == -1)
    {
        FileIndex = Files.Length;
        Files.Length = FileIndex + 1;
        Files[FileIndex].Filename = Filename;
        Files[FileIndex].DLName = Filename;
        Files[FileIndex].bIsUnicode = (InStr(Filename, ".ini",, true) == -1) && InStr(Filename, ".int",, true) == -1;        
    }
    else
    {
        Files[FileIndex].ReadState = 0;
    }
    DownloadFiles();
}

function AddReadFileDelegate(delegate<OnReadTitleFileComplete> ReadTitleFileCompleteDelegate)
{
    if(ReadTitleFileCompleteDelegate != none && ReadTitleFileCompleteDelegates.Find(ReadTitleFileCompleteDelegate == -1)
    {
        ReadTitleFileCompleteDelegates.AddItem(ReadTitleFileCompleteDelegate;
    }
}

function ClearReadFileDelegate(delegate<OnReadTitleFileComplete> ReadTitleFileCompleteDelegate)
{
    local int RemoveIndex;

    RemoveIndex = ReadTitleFileCompleteDelegates.Find(ReadTitleFileCompleteDelegate;
    if(RemoveIndex != -1)
    {
        ReadTitleFileCompleteDelegates.Remove(RemoveIndex, 1;
    }
}

function ClearCachedFiles()
{
    local int Index;

    Index = 0;
    J0x0B:

    if(Index < Files.Length)
    {
        Files[Index].ReadState = 0;
        ++ Index;
        goto J0x0B;
    }
    if(NotEqual_InterfaceInterface(TitleFileInterface, (none)))
    {
        TitleFileInterface.ClearDownloadedFiles();
    }
    if(NotEqual_InterfaceInterface(TitleFileCacheInterface, (none)))
    {
        TitleFileCacheInterface.ClearCachedFiles();
    }
}

// Export UIniLocPatcher::execUpdateLocFileName(FFrame&, void* const)
native function string UpdateLocFileName(string Filename);
