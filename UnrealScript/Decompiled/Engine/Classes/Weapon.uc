/*******************************************************************************
 * Weapon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Weapon extends Inventory
    abstract
    native
    config(Game)
    notplaceable
    hidecategories(Navigation);

enum EWeaponFireType
{
    EWFT_InstantHit,
    EWFT_Projectile,
    EWFT_Custom,
    EWFT_None,
    EWFT_MAX
};

var byte CurrentFireMode;
var array<name> FiringStatesArray;
var array<Weapon.EWeaponFireType> WeaponFireTypes;
var array< class<Projectile> > WeaponProjectiles;
/** Holds the amount of time a single shot takes */
var() array<float> FireInterval;
/** How much of a spread between shots */
var() array<float> Spread;
/** How much damage does a given instanthit shot do */
var() array<float> InstantHitDamage;
/** momentum transfer scaling for instant hit damage */
var() array<float> InstantHitMomentum;
var array< class<DamageType> > InstantHitDamageTypes;
/** How long does it take to Equip this weapon */
var() float EquipTime;
/** How long does it take to put this weapon down */
var() float PutDownTime;
/** Holds an offest for spawning protectile effects. */
var() Vector FireOffset;
var bool bWeaponPutDown;
var bool bCanThrow;
var bool bWasOptionalSet;
var bool bWasDoNotActivate;
var bool bInstantHit;
var bool bMeleeWeapon;
/** Range of Weapon, used for Traces (InstantFire, ProjectileFire, AdjustAim...) */
var() float WeaponRange;
/** Weapon Mesh */
var() export editinline MeshComponent Mesh;
/** When no duration is specified, speed to play anims. */
var() float DefaultAnimSpeed;
var config float Priority;
var protectedwrite AIController AIController;
var array<byte> ShouldFireOnRelease;
var float AIRating;
var float CachedMaxRange;

simulated function bool ShouldOwnerWalk()
{
    return false;
}

simulated function float GetModifiedFOVAngle()
{
    if(PlayerController(Instigator.Controller) != none)
    {
        return PlayerController(Instigator.Controller).GetFOVAngle();
    }
}

simulated function bool ShouldWeaponIgnoreStartFire()
{
    return false;
}

simulated event Destroyed()
{
    DetachWeapon();
    super.Destroyed();
}

function ItemRemovedFromInvManager()
{
    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
    GotoState('Inactive');
    ForceEndFire();
    DetachWeapon();
    ClientWeaponThrown();
    super.ItemRemovedFromInvManager();
    if((Instigator != none) && Instigator.Weapon == self)
    {
        Instigator.Weapon = none;
    }
}

function HolderDied()
{
    ServerStopFire(CurrentFireMode);
}

simulated function bool DoOverrideNextWeapon()
{
    return false;
}

simulated function bool DoOverridePrevWeapon()
{
    return false;
}

function DropFrom(Vector StartLocation, Vector StartVelocity)
{
    if(!CanThrow())
    {
        return;
    }
    GotoState('Inactive');
    ForceEndFire();
    DetachWeapon();
    super.DropFrom(StartLocation, StartVelocity);
    AIController = none;
}

simulated function bool CanThrow()
{
    return bCanThrow;
}

reliable client simulated function ClientWeaponThrown()
{
    LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
    if(WorldInfo.NetMode == NM_Client)
    {
        GotoState('Inactive');
        if((Instigator != none) && Instigator.Weapon == self)
        {
            Instigator.Weapon = none;
        }
        ForceEndFire();
        DetachWeapon();
    }
}

simulated event bool IsFiring()
{
    return false;
}

simulated function bool DenyClientWeaponSet()
{
    return false;
}

simulated function DrawHUD(HUD H, Canvas C);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local array<string> DebugInfo;
    local int I;

    GetWeaponDebug(DebugInfo);
    HUD.Canvas.SetDrawColor(0, 255, 0);
    I = 0;
    J0x59:

    if(I < DebugInfo.Length)
    {
        HUD.Canvas.DrawText("  " @ DebugInfo[I]);
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        ++ I;
        goto J0x59;
    }
}

simulated function GetWeaponDebug(out array<string> DebugInfo)
{
    local string T;
    local int I;

    DebugInfo[DebugInfo.Length] = (((((("Weapon:" $ (GetItemName(string(self)))) @ "State:") $ string(GetStateName())) @ "Instigator:") $ string(Instigator)) @ "Owner:") $ string(Owner);
    DebugInfo[DebugInfo.Length] = (((("IsFiring():" $ string(IsFiring())) @ "CurrentFireMode:") $ string(CurrentFireMode)) @ "bWeaponPutDown:") $ string(bWeaponPutDown);
    if(Instigator != none)
    {
        DebugInfo[DebugInfo.Length] = (((("ShotCount:" $ string(Instigator.ShotCount)) @ "FlashCount:") $ string(Instigator.FlashCount)) @ "FlashLocation:") $ string(Instigator.FlashLocation);
    }
    T = "PendingFires:";
    I = 0;
    J0x1BE:

    if(I < GetPendingFireLength())
    {
        T = (T $ string(PendingFire(I))) $ " ";
        ++ I;
        goto J0x1BE;
    }
    DebugInfo[DebugInfo.Length] = T;
    if(Timers.Length > 0)
    {
        I = 0;
        J0x24C:

        if(I < Timers.Length)
        {
            DebugInfo[DebugInfo.Length] = (((("Timer" @ string(Timers[I].FuncName)) @ string(Timers[I].Count)) @ string(Timers[I].Rate)) @ string(int((Timers[I].Count / Timers[I].Rate) * float(100)))) $ "%";
            ++ I;
            goto J0x24C;
        }
    }
}

function ConsumeAmmo(byte FireModeNum);

function int AddAmmo(int Amount);

simulated function bool HasAmmo(byte FireModeNum, optional int Amount)
{
    return true;
}

simulated function bool HasAnyAmmo()
{
    return true;
}

final simulated function int GetPendingFireLength()
{
    if(InvManager != none)
    {
        return InvManager.GetPendingFireLength(self);
    }
    return 0;
}

final simulated function bool PendingFire(int FireMode)
{
    if(InvManager != none)
    {
        return InvManager.IsPendingFire(self, FireMode);
    }
    return false;
}

final simulated function SetPendingFire(int FireMode)
{
    if(InvManager != none)
    {
        InvManager.SetPendingFire(self, FireMode);
    }
}

final simulated function ClearPendingFire(int FireMode)
{
    if(InvManager != none)
    {
        InvManager.ClearPendingFire(self, FireMode);
    }
}

function class<Projectile> GetProjectileClass()
{
    return ((CurrentFireMode < WeaponProjectiles.Length) ? WeaponProjectiles[CurrentFireMode] : none);
}

simulated function Rotator AddSpread(Rotator BaseAim)
{
    local Vector X, Y, Z;
    local float CurrentSpread, RandY, RandZ;

    CurrentSpread = Spread[CurrentFireMode];
    if(CurrentSpread == float(0))
    {
        return BaseAim;        
    }
    else
    {
        GetAxes(BaseAim, X, Y, Z);
        RandY = FRand() - 0.5;
        RandZ = Sqrt(0.5 - Square(RandY)) * (FRand() - 0.5);
        return rotator((X + ((RandY * CurrentSpread) * Y)) + ((RandZ * CurrentSpread) * Z));
    }
}

simulated function float MaxRange()
{
    local int I;

    if(CachedMaxRange > float(0))
    {
        return CachedMaxRange;
    }
    if(bInstantHit)
    {
        CachedMaxRange = WeaponRange;
    }
    I = 0;
    J0x46:

    if(I < WeaponProjectiles.Length)
    {
        if(WeaponProjectiles[I] != none)
        {
            CachedMaxRange = FMax(CachedMaxRange, WeaponProjectiles[I].static.GetRange());
        }
        ++ I;
        goto J0x46;
    }
    return CachedMaxRange;
}

function float GetAIRating()
{
    return AIRating;
}

simulated function float GetWeaponRating()
{
    if(InvManager != none)
    {
        return InvManager.GetWeaponRatingFor(self);
    }
    if(!HasAnyAmmo())
    {
        return -1;
    }
    return 1;
}

function bool CanAttack(Actor Other)
{
    return true;
}

function bool FireOnRelease()
{
    return (ShouldFireOnRelease.Length > 0) && ShouldFireOnRelease[CurrentFireMode] != 0;
}

simulated function AnimNodeSequence GetWeaponAnimNodeSeq()
{
    local AnimTree Tree;
    local AnimNodeSequence AnimSeq;
    local editinline SkeletalMeshComponent SkelMesh;

    SkelMesh = SkeletalMeshComponent(Mesh);
    if(SkelMesh != none)
    {
        Tree = AnimTree(SkelMesh.Animations);
        if(Tree != none)
        {
            AnimSeq = AnimNodeSequence(Tree.Children[0].Anim);            
        }
        else
        {
            AnimSeq = AnimNodeSequence(SkelMesh.Animations);
        }
        return AnimSeq;
    }
    return none;
}

simulated function PlayWeaponAnimation(name Sequence, float fDesiredDuration, optional bool bLoop, optional SkeletalMeshComponent SkelMesh)
{
    local AnimNodeSequence WeapNode;
    local AnimTree Tree;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    if(SkelMesh == none)
    {
        SkelMesh = SkeletalMeshComponent(Mesh);
    }
    if((SkelMesh == none) || (GetWeaponAnimNodeSeq()) == none)
    {
        return;
    }
    if(fDesiredDuration > 0)
    {
        SkelMesh.PlayAnim(Sequence, fDesiredDuration, bLoop);        
    }
    else
    {
        Tree = AnimTree(SkelMesh.Animations);
        if(Tree != none)
        {
            WeapNode = AnimNodeSequence(Tree.Children[0].Anim);            
        }
        else
        {
            WeapNode = AnimNodeSequence(SkelMesh.Animations);
        }
        WeapNode.SetAnim(Sequence);
        WeapNode.PlayAnim(bLoop, DefaultAnimSpeed);
    }
}

simulated function StopWeaponAnimation()
{
    local AnimNodeSequence AnimSeq;

    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        return;
    }
    AnimSeq = GetWeaponAnimNodeSeq();
    if(AnimSeq != none)
    {
        AnimSeq.StopAnim();
    }
}

simulated function PlayFireEffects(byte FireModeNum, optional Vector HitLocation);

simulated function StopFireEffects(byte FireModeNum);

simulated function float GetFireInterval(byte FireModeNum)
{
    return ((FireInterval[FireModeNum] > float(0)) ? FireInterval[FireModeNum] : 0.01);
}

simulated function TimeWeaponFiring(byte FireModeNum)
{
    if(!IsTimerActive('RefireCheckTimer'))
    {
        SetTimer(GetFireInterval(FireModeNum), true, 'RefireCheckTimer');
    }
}

simulated function RefireCheckTimer();

simulated function TimeWeaponPutDown()
{
    SetTimer(((PutDownTime > float(0)) ? PutDownTime : 0.01), false, 'WeaponIsDown');
}

simulated function TimeWeaponEquipping()
{
    SetTimer(((EquipTime > float(0)) ? EquipTime : 0.01), false, 'WeaponEquipped');
}

simulated function Activate()
{
    if(!IsFiring())
    {
        GotoState('WeaponEquipping');
    }
}

simulated function PutDownWeapon()
{
    GotoState('WeaponPuttingDown');
}

function bool DenyPickupQuery(class<Inventory> ItemClass, Actor Pickup)
{
    if(ItemClass == Class)
    {
        return true;
    }
    return false;
}

simulated function WeaponEmpty();

simulated function IncrementFlashCount()
{
    if(Instigator != none)
    {
        Instigator.IncrementFlashCount(self, CurrentFireMode);
    }
}

simulated function ClearFlashCount()
{
    if(Instigator != none)
    {
        Instigator.ClearFlashCount(self);
    }
}

function SetFlashLocation(Vector HitLocation)
{
    if(Instigator != none)
    {
        Instigator.SetFlashLocation(self, CurrentFireMode, HitLocation);
    }
}

function ClearFlashLocation()
{
    if(Instigator != none)
    {
        Instigator.ClearFlashLocation(self);
    }
}

simulated function AttachWeaponTo(SkeletalMeshComponent MeshCpnt, optional name SocketName);

simulated function DetachWeapon();

reliable client simulated function ClientGivenTo(Pawn NewOwner, bool bDoNotActivate)
{
    super.ClientGivenTo(NewOwner, bDoNotActivate);
    ClientWeaponSet(true, bDoNotActivate);
}

reliable client simulated function ClientWeaponSet(bool bOptionalSet, optional bool bDoNotActivate)
{
    LogInternal(((((((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "bOptionalSet:") @ string(bOptionalSet)) @ "bDoNotActivate:") @ string(bDoNotActivate)) @ "Instigator:") @ string(Instigator)) @ "InvManager:") @ string(InvManager), 'Inventory');
    bWasOptionalSet = bOptionalSet;
    bWasDoNotActivate = bDoNotActivate;
    if(Instigator == none)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Instigator == None, going to PendingClientWeaponSet", 'Inventory');
        GotoState('PendingClientWeaponSet');
        return;
    }
    if(InvManager == none)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "InvManager == None, going to PendingClientWeaponSet", 'Inventory');
        GotoState('PendingClientWeaponSet');
        return;
    }
    InvManager.ClientWeaponSet(self, bOptionalSet, bDoNotActivate);
}

simulated function StartFire(byte FireModeNum)
{
    if((Instigator == none) || !Instigator.bNoWeaponFiring)
    {
        if(Role < ROLE_Authority)
        {
            ServerStartFire(FireModeNum);
        }
        BeginFire(FireModeNum);
    }
}

reliable server function ServerStartFire(byte FireModeNum)
{
    if((Instigator == none) || !Instigator.bNoWeaponFiring)
    {
        BeginFire(FireModeNum);
    }
}

simulated function BeginFire(byte FireModeNum)
{
    LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "FireModeNum:") @ string(FireModeNum), 'Inventory');
    SetPendingFire(FireModeNum);
}

simulated function StopFire(byte FireModeNum)
{
    EndFire(FireModeNum);
    if(Role < ROLE_Authority)
    {
        ServerStopFire(FireModeNum);
    }
}

reliable server function ServerStopFire(byte FireModeNum)
{
    EndFire(FireModeNum);
}

simulated function EndFire(byte FireModeNum)
{
    ClearPendingFire(FireModeNum);
}

simulated function ForceEndFire()
{
    local int I, Num;

    if(InvManager != none)
    {
        Num = GetPendingFireLength();
        I = 0;
        J0x2E:

        if(I < Num)
        {
            if(PendingFire(I))
            {
                EndFire(byte(I));
            }
            ++ I;
            goto J0x2E;
        }
    }
}

simulated function SendToFiringState(byte FireModeNum)
{
    if(FireModeNum >= FiringStatesArray.Length)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Invalid FireModeNum", 'Inventory');
        return;
    }
    if((FiringStatesArray[FireModeNum] == 'None') || WeaponFireTypes[FireModeNum] == 3)
    {
        return;
    }
    SetCurrentFireMode(FireModeNum);
    LogInternal((((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ string(FireModeNum)) @ "Sending to state:") @ string(FiringStatesArray[FireModeNum]), 'Inventory');
    GotoState(FiringStatesArray[FireModeNum]);
}

simulated function SetCurrentFireMode(byte FiringModeNum)
{
    CurrentFireMode = FiringModeNum;
    if(Instigator != none)
    {
        Instigator.SetFiringMode(self, FiringModeNum);
    }
}

simulated function FireModeUpdated(byte FiringMode, bool bViaReplication);

simulated function FireAmmunition()
{
    ConsumeAmmo(CurrentFireMode);
    switch(WeaponFireTypes[CurrentFireMode])
    {
        case 0:
            InstantFire();
            break;
        case 1:
            ProjectileFire();
            break;
        case 2:
            CustomFire();
            break;
        default:
            break;
    }
    NotifyWeaponFired(CurrentFireMode);
}

simulated function Rotator GetAdjustedAim(Vector StartFireLoc)
{
    local Rotator R;

    if(Instigator != none)
    {
        R = Instigator.GetAdjustedAimFor(self, StartFireLoc);
    }
    return AddSpread(R);
}

simulated event float GetTraceRange()
{
    return WeaponRange;
}

simulated function Actor GetTraceOwner()
{
    return ((Instigator != none) ? Instigator : self);
}

simulated function ImpactInfo CalcWeaponFire(Vector StartTrace, Vector EndTrace, optional out array<ImpactInfo> ImpactList, optional Vector Extent)
{
    local Vector HitLocation, HitNormal, Dir;
    local Actor HitActor;
    local TraceHitInfo HitInfo;
    local ImpactInfo CurrentImpact;
    local PortalTeleporter Portal;
    local float HitDist;
    local bool bOldBlockActors, bOldCollideActors;

    HitActor = GetTraceOwner().Trace(HitLocation, HitNormal, EndTrace, StartTrace, true, Extent, HitInfo, 1);
    if(HitActor == none)
    {
        HitLocation = EndTrace;
    }
    CurrentImpact.HitActor = HitActor;
    CurrentImpact.HitLocation = HitLocation;
    CurrentImpact.HitNormal = HitNormal;
    CurrentImpact.RayDir = Normal(EndTrace - StartTrace);
    CurrentImpact.StartTrace = StartTrace;
    CurrentImpact.HitInfo = HitInfo;
    ImpactList[ImpactList.Length] = CurrentImpact;
    if(HitActor != none)
    {
        if(PassThroughDamage(HitActor))
        {
            HitActor.bProjTarget = false;
            bOldCollideActors = HitActor.bCollideActors;
            bOldBlockActors = HitActor.bBlockActors;
            if(HitActor.IsA('Pawn'))
            {
                HitActor.SetCollision(false, false);                
                CalcWeaponFire(HitLocation, EndTrace, ImpactList, Extent);                
            }
            else
            {
                if(bOldBlockActors)
                {
                    HitActor.SetCollision(bOldCollideActors, false);
                }
                CurrentImpact = CalcWeaponFire(HitLocation, EndTrace, ImpactList, Extent);
            }
            HitActor.bProjTarget = true;
            HitActor.SetCollision(bOldCollideActors, bOldBlockActors);            
        }
        else
        {
            Portal = PortalTeleporter(HitActor);
            if((Portal != none) && Portal.SisterPortal != none)
            {
                Dir = EndTrace - StartTrace;
                HitDist = VSize(HitLocation - StartTrace);
                StartTrace = Portal.TransformHitLocation(HitLocation);
                EndTrace = StartTrace + Portal.TransformVectorDir(Normal(Dir) * (VSize(Dir) - HitDist));                
                CalcWeaponFire(StartTrace, EndTrace, ImpactList, Extent);
            }
        }
    }
    return CurrentImpact;
}

simulated function bool PassThroughDamage(Actor HitActor)
{
    return (!HitActor.bBlockActors && HitActor.IsA('Trigger') || HitActor.IsA('TriggerVolume')) || HitActor.IsA('InteractiveFoliageActor');
}

simulated function InstantFire()
{
    local Vector StartTrace, EndTrace;
    local array<ImpactInfo> ImpactList;
    local int Idx;
    local ImpactInfo RealImpact;

    StartTrace = Instigator.GetWeaponStartTraceLocation();
    EndTrace = StartTrace + (vector(GetAdjustedAim(StartTrace)) * (GetTraceRange()));
    RealImpact = CalcWeaponFire(StartTrace, EndTrace, ImpactList);
    if(Role == ROLE_Authority)
    {
        SetFlashLocation(RealImpact.HitLocation);
    }
    Idx = 0;
    J0xD5:

    if(Idx < ImpactList.Length)
    {
        ProcessInstantHit(CurrentFireMode, ImpactList[Idx]);
        ++ Idx;
        goto J0xD5;
    }
}

simulated function ProcessInstantHit(byte FiringMode, ImpactInfo Impact, optional int NumHits)
{
    local int TotalDamage;
    local KActorFromStatic NewKActor;
    local editinline StaticMeshComponent HitStaticMesh;

    if(Impact.HitActor != none)
    {
        NumHits = Max(NumHits, 1);
        TotalDamage = int(InstantHitDamage[CurrentFireMode] * float(NumHits));
        if(Impact.HitActor.bWorldGeometry)
        {
            HitStaticMesh = StaticMeshComponent(Impact.HitInfo.HitComponent);
            if((HitStaticMesh != none) && HitStaticMesh.CanBecomeDynamic())
            {
                NewKActor = Class'KActorFromStatic'.static.MakeDynamic(HitStaticMesh);
                if(NewKActor != none)
                {
                    Impact.HitActor = NewKActor;
                }
            }
        }
        Impact.HitActor.TakeDamage(TotalDamage, Instigator.Controller, Impact.HitLocation, InstantHitMomentum[FiringMode] * Impact.RayDir, InstantHitDamageTypes[FiringMode], Impact.HitInfo, self);
    }
}

simulated function Projectile ProjectileFire()
{
    local Vector StartTrace, EndTrace, RealStartLoc, AimDir;
    local ImpactInfo TestImpact;
    local Projectile SpawnedProjectile;

    IncrementFlashCount();
    if(Role == ROLE_Authority)
    {
        StartTrace = Instigator.GetWeaponStartTraceLocation();
        AimDir = vector(GetAdjustedAim(StartTrace));
        RealStartLoc = GetPhysicalFireStartLoc(AimDir);
        if(StartTrace != RealStartLoc)
        {
            EndTrace = StartTrace + (AimDir * (GetTraceRange()));
            TestImpact = CalcWeaponFire(StartTrace, EndTrace);
            AimDir = Normal(TestImpact.HitLocation - RealStartLoc);
        }
        SpawnedProjectile = Spawn(GetProjectileClass(), self,, RealStartLoc);
        if((SpawnedProjectile != none) && !SpawnedProjectile.bDeleteMe)
        {
            SpawnedProjectile.Init(AimDir);
        }
        return SpawnedProjectile;
    }
    return none;
}

simulated function CustomFire();

simulated event Vector GetMuzzleLoc()
{
    if(Instigator != none)
    {
        return Instigator.GetPawnViewLocation() + (FireOffset >> Instigator.GetViewRotation());
    }
    return Location;
}

// Export UWeapon::execGetPhysicalFireStartLoc(FFrame&, void* const)
native simulated event Vector GetPhysicalFireStartLoc(optional Vector AimDir);

simulated function bool TryPutDown()
{
    bWeaponPutDown = true;
    return true;
}

simulated function bool CanProcessPendingFire(name PrevStateName, byte FireModeNum)
{
    return true;
}

simulated function HandleFinishedFiring()
{
    GotoState('Active');
}

function NotifyWeaponFired(byte FireMode)
{
    if(AIController != none)
    {
        AIController.NotifyWeaponFired(self, FireMode);
    }
}

function NotifyWeaponFinishedFiring(byte FireMode)
{
    if(AIController != none)
    {
        AIController.NotifyWeaponFinishedFiring(self, FireMode);
    }
}

simulated function bool ShouldRefire()
{
    if(!HasAmmo(CurrentFireMode))
    {
        return false;
    }
    return StillFiring(CurrentFireMode);
}

simulated function bool StillFiring(byte FireMode)
{
    return PendingFire(FireMode);
}

simulated function WeaponIsDown();

simulated function CacheAIController()
{
    if(Instigator == none)
    {
        AIController = none;        
    }
    else
    {
        AIController = AIController(Instigator.Controller);
    }
}

simulated function float GetTargetDistance()
{
    local float VeryFar;
    local Vector HitLocation, HitNormal, projStart, TargetLoc, X, Y,
	    Z;

    local Rotator CameraRot;
    local PlayerController PC;

    VeryFar = 32768;
    PC = PlayerController(Instigator.Controller);
    PC.GetPlayerViewPoint(projStart, CameraRot);
    GetAxes(CameraRot, X, Y, Z);
    TargetLoc = projStart + (X * VeryFar);
    if(none == GetTraceOwner().Trace(HitLocation, HitNormal, TargetLoc, projStart, true,,, 1))
    {
        return VeryFar;
    }
    return (HitLocation - projStart) Dot X;
}

simulated function SetMeshLightingChannels(LightingChannelContainer NewLightingChannels);

auto state Inactive
{
    ignores BeginState, StartFire;

    reliable server function ServerStartFire(byte FireModeNum)
    {
        global.ServerStartFire(FireModeNum);
        WarnInternal((string(WorldInfo.TimeSeconds) @ string(Instigator)) @ "received ServerStartFire in Inactive State!!!");
        if((Instigator != none) && Instigator.Weapon == self)
        {
            WarnInternal(" - I'm the current weapon, so gotostate active and start firing");
            GotoState('Active');            
        }
        else
        {
            if((InvManager != none) && InvManager.PendingWeapon == self)
            {
                if(Instigator.Weapon.IsInState('WeaponPuttingDown'))
                {
                    WarnInternal(" - I'm the pending weapon, and current weapon is being put down, so force switch now");
                    Instigator.Weapon.WeaponIsDown();                    
                }
                else
                {
                    WarnInternal(" - I'm the pending weapon, but current weapon is NOT being put down, so resync client and server");
                    InvManager.SetCurrentWeapon(self);
                    InvManager.ServerSetCurrentWeapon(self);
                    if(((Instigator.Weapon != self) && InvManager.PendingWeapon == self) && Instigator.Weapon.IsInState('WeaponPuttingDown'))
                    {
                        Instigator.Weapon.WeaponIsDown();
                    }
                }                
            }
            else
            {
                if(Instigator != none)
                {
                    WarnInternal(" - I'm just in the inventory, so resync client and server");
                    InvManager.SetCurrentWeapon(self);
                    InvManager.ServerSetCurrentWeapon(self);
                    if(((Instigator.Weapon != self) && InvManager.PendingWeapon == self) && Instigator.Weapon.IsInState('WeaponPuttingDown'))
                    {
                        Instigator.Weapon.WeaponIsDown();
                    }
                }
            }
        }
    }

    reliable server function ServerStopFire(byte FireModeNum)
    {
        ClearPendingFire(FireModeNum);
    }

    simulated function bool TryPutDown()
    {
        return false;
    }
    stop;    
}

simulated state Active
{
    ignores Activate;

    simulated event BeginState(name PreviousStateName)
    {
        local int I;

        if(Role == ROLE_Authority)
        {
            CacheAIController();
        }
        if(bWeaponPutDown)
        {
            LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Weapon put down requested during transition, put it down now", 'Inventory');
            PutDownWeapon();            
        }
        else
        {
            if(!HasAnyAmmo())
            {
                WeaponEmpty();                
            }
            else
            {
                I = 0;
                J0x10F:

                if(I < GetPendingFireLength())
                {
                    if((CanProcessPendingFire(PreviousStateName, byte(I))) && PendingFire(I))
                    {
                        BeginFire(byte(I));
                        goto J0x186;
                    }
                    ++ I;
                    goto J0x10F;
                }
            }
        }
        J0x186:

    }

    simulated function BeginFire(byte FireModeNum)
    {
        if(!bDeleteMe && Instigator != none)
        {
            global.BeginFire(FireModeNum);
            if(PendingFire(FireModeNum) && HasAmmo(FireModeNum))
            {
                SendToFiringState(FireModeNum);
            }
        }
    }

    simulated function bool ReadyToFire(bool bFinished)
    {
        return true;
    }

    simulated function bool TryPutDown()
    {
        PutDownWeapon();
        return true;
    }
    stop;    
}

simulated state WeaponFiring
{
    simulated event bool IsFiring()
    {
        return true;
    }

    simulated function RefireCheckTimer()
    {
        if(bWeaponPutDown)
        {
            LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "Weapon put down requested during fire, put it down now", 'Inventory');
            PutDownWeapon();
            return;
        }
        if(ShouldRefire())
        {
            FireAmmunition();
            return;
        }
        HandleFinishedFiring();
    }

    simulated event BeginState(name PreviousStateName)
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "PreviousStateName:") @ string(PreviousStateName), 'Inventory');
        FireAmmunition();
        TimeWeaponFiring(CurrentFireMode);
    }

    simulated event EndState(name NextStateName)
    {
        LogInternal(((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "NextStateName:") @ string(NextStateName), 'Inventory');
        ClearFlashCount();
        ClearFlashLocation();
        ClearTimer('RefireCheckTimer');
        NotifyWeaponFinishedFiring(CurrentFireMode);
    }
    stop;    
}

simulated state WeaponEquipping
{
    ignores Activate;

    simulated event BeginState(name PreviousStateName)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
        TimeWeaponEquipping();
        bWeaponPutDown = false;
    }

    simulated event EndState(name NextStateName)
    {
        ClearTimer('WeaponEquipped');
    }

    simulated function WeaponEquipped()
    {
        if(bWeaponPutDown)
        {
            PutDownWeapon();
            return;
        }
        GotoState('Active');
    }
    stop;    
}

simulated state WeaponPuttingDown
{
    simulated event BeginState(name PreviousStateName)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
        TimeWeaponPutDown();
        bWeaponPutDown = false;
        ForceEndFire();
    }

    simulated function WeaponIsDown()
    {
        if(InvManager.CancelWeaponChange())
        {
            return;
        }
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
        DetachWeapon();
        GotoState('Inactive');
        InvManager.ChangedWeapon();
    }

    simulated function bool TryPutDown()
    {
        return false;
    }

    reliable client simulated function ClientWeaponThrown()
    {
        WeaponIsDown();
        global.ClientWeaponThrown();
    }

    simulated event EndState(name NextStateName)
    {
        LogInternal((((((((string(WorldInfo.TimeSeconds) @ "Self:") @ string(self)) @ "Instigator:") @ string(Instigator)) @ string(GetStateName())) $ "::") $ string(GetFuncName())) @ "", 'Inventory');
        ClearTimer('WeaponIsDown');
    }
    stop;    
}

state PendingClientWeaponSet
{
    simulated function PendingWeaponSetTimer()
    {
        ClientWeaponSet(bWasOptionalSet, bWasDoNotActivate);
    }

    simulated event BeginState(name PreviousStateName)
    {
        SetTimer(0.03, true, 'PendingWeaponSetTimer');
    }

    simulated event EndState(name NextStateName)
    {
        ClearTimer('PendingWeaponSetTimer');
    }
    stop;    
}

defaultproperties
{
    EquipTime=0.33
    PutDownTime=0.33
    bCanThrow=true
    WeaponRange=16384
    DefaultAnimSpeed=1
    Priority=-1
    AIRating=0.5
    ItemName="Weapon"
    RespawnTime=30
    Components=none
    bReplicateInstigator=true
    bOnlyDirtyReplication=false
}