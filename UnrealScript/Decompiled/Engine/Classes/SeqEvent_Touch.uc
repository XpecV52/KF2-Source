/*******************************************************************************
 * SeqEvent_Touch generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SeqEvent_Touch extends SequenceEvent
    native(Sequence)
    hidecategories(Object);

/** List of class types that are considered valid for this event */
var(TouchTypes) array< class<Actor> > ClassProximityTypes<AllowAbstract=>;
/** List of class types that are considered valid for this event */
var(TouchTypes) array< class<Actor> > IgnoredClassProximityTypes<AllowAbstract=>;
/** Force the player to be overlapping at the time of activation? */
var() bool bForceOverlapping;
/**  
 *Use Instigator, not actual Actor.
 * For projectiles, it returns the instigator.
 */
var() bool bUseInstigator;
/** whether dead (Health < 0) pawns can be considered touching */
var() bool bAllowDeadPawns;
var array<Actor> TouchedList;

// Export USeqEvent_Touch::execCheckTouchActivate(FFrame&, void* const)
native final function bool CheckTouchActivate(Actor InOriginator, Actor InInstigator, optional bool bTest);

// Export USeqEvent_Touch::execCheckUnTouchActivate(FFrame&, void* const)
native final function bool CheckUnTouchActivate(Actor InOriginator, Actor InInstigator, optional bool bTest);

event Toggled()
{
    local int Idx;

    if(bEnabled)
    {
        if(Originator != none)
        {
            Idx = 0;
            J0x27:

            if(Idx < Originator.Touching.Length)
            {
                CheckTouchActivate(Originator, Originator.Touching[Idx]);
                ++ Idx;
                goto J0x27;
            }
        }        
    }
    else
    {
        TouchedList.Length = 0;
    }
}

function NotifyTouchingPawnDied(Pawn P)
{
    if(!bAllowDeadPawns)
    {
        CheckUnTouchActivate(Originator, P);
    }
}

static event int GetObjClassVersion()
{
    return super(SequenceObject).GetObjClassVersion() + 1;
}

defaultproperties
{
    ClassProximityTypes(0)=class'Pawn'
    ClassProximityTypes(1)=class'ApexDestructibleActor'
    bForceOverlapping=true
    ReTriggerDelay=0.1
    OutputLinks(0)=(Links=none,LinkDesc="Touched",bHasImpulse=false,bDisabled=false,bDisabledPIE=false,LinkedOp=none,ActivateDelay=0,DrawY=0,bHidden=false,bMoving=false,bClampedMax=false,bClampedMin=false,OverrideDelta=0,PIEActivationTime=0,bIsActivated=false)
    OutputLinks(1)=(Links=none,LinkDesc="UnTouched",bHasImpulse=false,bDisabled=false,bDisabledPIE=false,LinkedOp=none,ActivateDelay=0,DrawY=0,bHidden=false,bMoving=false,bClampedMax=false,bClampedMin=false,OverrideDelta=0,PIEActivationTime=0,bIsActivated=false)
    OutputLinks(2)=(Links=none,LinkDesc="Empty",bHasImpulse=false,bDisabled=false,bDisabledPIE=false,LinkedOp=none,ActivateDelay=0,DrawY=0,bHidden=false,bMoving=false,bClampedMax=false,bClampedMin=false,OverrideDelta=0,PIEActivationTime=0,bIsActivated=false)
    ObjName="Touch"
    ObjCategory="Physics"
}