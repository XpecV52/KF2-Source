/*******************************************************************************
 * RB_BodyInstance generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class RB_BodyInstance extends Object
    native(Physics)
    hidecategories(Object);

var const export editinline transient PrimitiveComponent OwnerComponent;
var const int BodyIndex;
var Vector Velocity;
var Vector PreviousVelocity;
var native const int SceneIndex;
var native const Pointer BodyData;
var native const Pointer BoneSpring;
var native const Pointer BoneSpringKinActor;
/** Enable linear 'spring' between the physics body for this bone, and the world-space location of the animation bone. */
var(BoneSpring) bool bEnableBoneSpringLinear;
/** Enable angular 'spring' between the physics body for this bone, and the world-space location of the animation bone. */
var(BoneSpring) bool bEnableBoneSpringAngular;
/** If true, bone spring will automatically disable if it ever gets longer than the OverextensionThreshold. */
var(BoneSpring) bool bDisableOnOverextension;
/** Send notification to Owning Actor when overextended, by calling Actor::OnRigidBody */
var(BoneSpring) bool bNotifyOwnerOnOverextension;
/**  
 *This will teleport the whole PhysicsAssetInstance if this spring gets too long, to reduce to error to zero.
 *       Note - having this set on more than one body in a PhysicsAssetInstance will have unpredictable results.
 */
var(BoneSpring) bool bTeleportOnOverextension;
/**  
 *When using bone springs, connect them to a kinematic body and animate that, rather than animating the attachment location on the 'world'.
 *       This adds some overhead, but tracks rapidly moving targets better.
 */
var(BoneSpring) bool bUseKinActorForBoneSpring;
/**  
 *When using bone springs, connect them to the physics body of the Base's CollisionComponent.
 *       When using this option, SetBoneSpringTarget must be given a matrix for this bone relative to the other bone,
 *       rather than relative to the world.
 */
var(BoneSpring) bool bMakeSpringToBaseCollisionComponent;
/**  
 *This body should only collide with other bodies with their components marked bConsiderPawnForRBCollision.
 *       Useful for flappy bits you do not want to collide with the world.
 */
var(Physics) const bool bOnlyCollideWithPawns;
/** Enables physics response for this body (on by default).  If FALSE, contacts are still generated and reported. Useful for "sensor" bodies. */
var(Physics) const bool bEnableCollisionResponse;
/** Denotes body as a "push" body.  Also disables collision response, by definition. */
var(Physics) const bool bPushBody;
var private transient bool bForceUnfixed;
var private transient bool bInstanceAlwaysFullAnimWeight;
/** Strength of linear spring to animated bone. */
var(BoneSpring) const float BoneLinearSpring;
/** Damping on linear spring to animated bone. */
var(BoneSpring) const float BoneLinearDamping;
/** Strength of angular spring to animated bone. */
var(BoneSpring) const float BoneAngularSpring;
/** Damping on angular spring to animated bone. */
var(BoneSpring) const float BoneAngularDamping;
/** If bDisableOnOverextension is on, the bone spring will be disabled if it stretches more than this amount. */
var(BoneSpring) float OverextensionThreshold;
/**  
 *The force applied to the body to address custom gravity for the actor is multiplied CustomGravityFactor, allowing bodies to individually control how 
 *       custom gravity settings affectthem
 */
var() float CustomGravityFactor;
var transient float LastEffectPlayedTime;
/**  
 *Allows you to override the PhysicalMaterial to use for this body. 
 *       Due to the way the BodyInstance pooling works, this MUST BE LAST PROPERTY OF THE CLASS.
 */
var(Physics) const PhysicalMaterial PhysMaterialOverride;
/**  
 *Used for force-based collision filtering.  Note: this is NOT an additional filter on top of normal
 *       pairwise filtering.  It is essentially a new kind of reporting.  It can be used in conjuction
 *       with pairwise reporting, however.
 *       To disable this feature, set the threshold to a negative number.
 */
var(Physics) float ContactReportForceThreshold;
/** Per-instance scaling of mass */
var(Physics) float InstanceMassScale;
/** Per-instance scaling of linear/angular damping */
var(Physics) float InstanceDampingScale;

// Export URB_BodyInstance::execGetBodyMass(FFrame&, void* const)
native final function float GetBodyMass();

// Export URB_BodyInstance::execSetFixed(FFrame&, void* const)
native final function SetFixed(bool bNewFixed);

// Export URB_BodyInstance::execIsFixed(FFrame&, void* const)
native final function bool IsFixed();

// Export URB_BodyInstance::execIsValidBodyInstance(FFrame&, void* const)
native final function bool IsValidBodyInstance();

// Export URB_BodyInstance::execGetPhysicsAssetInstance(FFrame&, void* const)
native final function PhysicsAssetInstance GetPhysicsAssetInstance();

// Export URB_BodyInstance::execGetUnrealWorldTM(FFrame&, void* const)
native final function Matrix GetUnrealWorldTM();

// Export URB_BodyInstance::execGetUnrealWorldVelocity(FFrame&, void* const)
native final function Vector GetUnrealWorldVelocity();

// Export URB_BodyInstance::execGetUnrealWorldAngularVelocity(FFrame&, void* const)
native final function Vector GetUnrealWorldAngularVelocity();

// Export URB_BodyInstance::execGetUnrealWorldVelocityAtPoint(FFrame&, void* const)
native final function Vector GetUnrealWorldVelocityAtPoint(Vector Point);

// Export URB_BodyInstance::execEnableBoneSpring(FFrame&, void* const)
native final function EnableBoneSpring(bool bInEnableLinear, bool bInEnableAngular, const out Matrix InBoneTarget);

// Export URB_BodyInstance::execSetBoneSpringParams(FFrame&, void* const)
native final function SetBoneSpringParams(float InLinearSpring, float InLinearDamping, float InAngularSpring, float InAngularDamping);

// Export URB_BodyInstance::execSetBoneSpringTarget(FFrame&, void* const)
native final function SetBoneSpringTarget(const out Matrix InBoneTarget, bool bTeleport);

// Export URB_BodyInstance::execSetBlockRigidBody(FFrame&, void* const)
native final function SetBlockRigidBody(bool bNewBlockRigidBody);

// Export URB_BodyInstance::execSetPhysMaterialOverride(FFrame&, void* const)
native final function SetPhysMaterialOverride(PhysicalMaterial NewPhysMaterial);

// Export URB_BodyInstance::execEnableCollisionResponse(FFrame&, void* const)
native final function EnableCollisionResponse(bool bEnableResponse);

// Export URB_BodyInstance::execSetContactReportForceThreshold(FFrame&, void* const)
native final function SetContactReportForceThreshold(float Threshold);

// Export URB_BodyInstance::execUpdateMassProperties(FFrame&, void* const)
native final function UpdateMassProperties(RB_BodySetup Setup);

// Export URB_BodyInstance::execUpdateDampingProperties(FFrame&, void* const)
native final function UpdateDampingProperties();

defaultproperties
{
    bEnableCollisionResponse=true
    BoneLinearSpring=10
    BoneLinearDamping=0.1
    BoneAngularSpring=1
    BoneAngularDamping=0.1
    CustomGravityFactor=1
    ContactReportForceThreshold=100
    InstanceMassScale=1
    InstanceDampingScale=1
}