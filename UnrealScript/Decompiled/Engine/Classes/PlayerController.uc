/*******************************************************************************
 * PlayerController generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class PlayerController extends Controller
    native(Controller)
    nativereplication
    config(Game)
    notplaceable
    hidecategories(Navigation);

const MAXPOSITIONERRORSQUARED = 3.0;
const MAXNEARZEROVELOCITYSQUARED = 9.0;
const MAXVEHICLEPOSITIONERRORSQUARED = 900.0;
const CLIENTADJUSTUPDATECOST = 180.0;
const MAXCLIENTUPDATEINTERVAL = 0.25;

enum EInputTypes
{
    IT_XAxis,
    IT_YAxis,
    IT_MAX
};

enum EInputMatchAction
{
    IMA_GreaterThan,
    IMA_LessThan,
    IMA_MAX
};

enum EProgressMessageType
{
    PMT_Clear,
    PMT_Information,
    PMT_AdminMessage,
    PMT_DownloadProgress,
    PMT_ConnectionFailure,
    PMT_PeerConnectionFailure,
    PMT_PeerHostMigrationFailure,
    PMT_SocketFailure,
    PMT_MAX
};

struct native ClientAdjustment
{
    var float TimeStamp;
    var Actor.EPhysics newPhysics;
    var Vector NewLoc;
    var Vector NewVel;
    var Actor NewBase;
    var Vector NewFloor;
    var byte bAckGoodMove;

    structdefaultproperties
    {
        TimeStamp=0
        newPhysics=EPhysics.PHYS_None
        NewLoc=(X=0,Y=0,Z=0)
        NewVel=(X=0,Y=0,Z=0)
        NewBase=none
        NewFloor=(X=0,Y=0,Z=0)
        bAckGoodMove=0
    }
};

struct native ConnectedPeerInfo
{
    var UniqueNetId PlayerID;
    var OnlineSubsystem.ENATType NatType;
    var bool bLostConnectionToHost;

    structdefaultproperties
    {
        PlayerID=(Uid=none)
        NatType=ENATType.NAT_Unknown
        bLostConnectionToHost=false
    }
};

struct native InputEntry
{
    var PlayerController.EInputTypes Type;
    var float Value;
    var float TimeDelta;
    var PlayerController.EInputMatchAction Action;

    structdefaultproperties
    {
        Type=EInputTypes.IT_XAxis
        Value=0
        TimeDelta=0
        Action=EInputMatchAction.IMA_GreaterThan
    }
};

struct native InputMatchRequest
{
    var array<InputEntry> Inputs;
    var Actor MatchActor;
    var name MatchFuncName;
    var delegate<InputMatchDelegate> MatchDelegate;
    var name FailedFuncName;
    var name RequestName;
    var transient int MatchIdx;
    var transient float LastMatchTime;

    structdefaultproperties
    {
        Inputs=none
        MatchActor=none
        MatchFuncName=None
        t=None
        FailedFuncName=None
        RequestName=None
        MatchIdx=0
        LastMatchTime=0
    }
};

struct native DebugTextInfo
{
    var Actor SrcActor;
    var Vector SrcActorOffset;
    var Vector SrcActorDesiredOffset;
    var string DebugText;
    var transient float TimeRemaining;
    var float Duration;
    var Color TextColor;
    var bool bAbsoluteLocation;
    var bool bKeepAttachedToActor;
    var Vector OrigActorLocation;
    var Font Font;

    structdefaultproperties
    {
        SrcActor=none
        SrcActorOffset=(X=0,Y=0,Z=0)
        SrcActorDesiredOffset=(X=0,Y=0,Z=0)
        DebugText=""
        TimeRemaining=0
        Duration=0
        TextColor=(B=0,G=0,R=0,A=0)
        bAbsoluteLocation=false
        bKeepAttachedToActor=false
        OrigActorLocation=(X=0,Y=0,Z=0)
        Font=none
    }
};

var const Player Player;
/** Camera associated with this Player Controller */
var(Camera) editinline Camera PlayerCamera;
var const class<Camera> CameraClass;
var bool bFrozen;
var bool bPressedJump;
var bool bDoubleJump;
var bool bUpdatePosition;
var bool bUpdating;
var globalconfig bool bNeverSwitchOnPickup;
var bool bCheatFlying;
var bool bCameraPositionLocked;
var bool bShortConnectTimeOut;
var const bool bPendingDestroy;
var bool bWasSpeedHack;
var const bool bWasSaturated;
var globalconfig bool bAimingHelp;
var transient bool bCameraCut;
var bool bClientSimulatingViewTarget;
var bool bHasVoiceHandshakeCompleted;
var bool bCinematicMode;
var bool bInteractiveMode;
var bool bCinemaDisableInputMove;
var bool bCinemaDisableInputLook;
var bool bIgnoreNetworkMessages;
var config bool bShowKismetDrawText;
var bool bReplicateAllPawns;
var bool bIsUsingStreamingVolumes;
var bool bIsExternalUIOpen;
var bool bIsControllerConnected;
var bool bCheckSoundOcclusion;
var bool bDebugCameraAnims;
var bool bBlockCameraAnimsFromOverridingPostProcess;
var globalconfig bool bLogHearSoundOverflow;
var globalconfig bool bCheckRelevancyThroughPortals;
/** debug */
var(Debug) bool bDebugClientAdjustPosition;
var bool bDrawRelevancyChecks;
var float MaxResponseTime;
var float WaitDelay;
var Pawn AcknowledgedPawn;
var Actor.EDoubleClickDir DoubleClickDir;
var byte bIgnoreMoveInput;
var byte bIgnoreLookInput;
var input byte bRun;
var input byte bDuck;
var duplicatetransient const byte NetPlayerIndex;
var byte RelevancyCounter;
var const Actor ViewTarget;
var PlayerReplicationInfo RealViewTarget;
var transient InterpTrackInstDirector ControllingDirTrackInst;
var protected float FOVAngle;
var float DesiredFOV;
var float DefaultFOV;
var const float LODDistanceFactor;
var Rotator TargetViewRotation;
var float TargetEyeHeight;
var Rotator BlendedTargetViewRotation;
var HUD myHUD;
var HUD mySecondaryHUD;
var class<SavedMove> SavedMoveClass;
var SavedMove SavedMoves;
var SavedMove FreeMoves;
var SavedMove PendingMove;
var Vector LastAckedAccel;
var float CurrentTimeStamp;
var float LastUpdateTime;
var float ServerTimeStamp;
var float TimeMargin;
var float ClientUpdateTime;
var float MaxTimeMargin;
var float LastActiveTime;
var int ClientCap;
var deprecated float DynamicPingThreshold;
var float LastPingUpdate;
var float LastSpeedHackLog;
var ClientAdjustment PendingAdjustment;
var int GroundPitch;
var transient CheatManager CheatManager;
var class<CheatManager> CheatClass;
/** Object within playercontroller that manages player input. */
var() editinline transient PlayerInput PlayerInput;
var class<PlayerInput> InputClass;
var const Vector FailedPathStart;
var export editinline CylinderComponent CylinderComponent;
var config string ForceFeedbackManagerClassName;
var transient ForceFeedbackManager ForceFeedbackManager;
var transient array<Interaction> Interactions;
var array<UniqueNetId> VoiceMuteList;
var array<UniqueNetId> GameplayVoiceMuteList;
var array<UniqueNetId> VoicePacketFilter;
var array<ConnectedPeerInfo> ConnectedPeers;
var array<UniqueNetId> BestNextHostPeers;
var OnlineGameSearch MigratedSearchToJoin;
var OnlineSubsystem OnlineSub;
var OnlineVoiceInterface VoiceInterface;
var UIDataStore_OnlinePlayerData OnlinePlayerData;
var OnlineGameSearchResult CachedInviteResult;
var config float InteractDistance;
var name DelayedJoinSessionName;
var array<InputMatchRequest> InputRequests;
var float LastBroadcastTime;
var string LastBroadcastString[4];
var array<name> PendingMapChangeLevelNames;
var CoverReplicator MyCoverReplicator;
var private array<DebugTextInfo> DebugTextList;
var float SpectatorCameraSpeed;
var duplicatetransient const NetConnection PendingSwapConnection;
var float MinRespawnDelay;
var globalconfig int MaxConcurrentHearSounds;
var export editinline array<export editinline AudioComponent> HearSoundActiveComponents;
var export editinline array<export editinline AudioComponent> HearSoundPoolComponents;
var array<Actor> HiddenActors;
var float LastSpectatorStateSynchTime;
var array<UniqueNetId> VoiceSenders;
var array<UniqueNetId> VoiceReceivers;
var Rotator WeaponBufferRotation;
var delegate<OnMissingPeersUnregistered> __OnMissingPeersUnregistered__Delegate;
var delegate<CanUnpause> __CanUnpause__Delegate;
var delegate<InputMatchDelegate> __InputMatchDelegate__Delegate;

replication
{
     if(((bNetOwner && Role == ROLE_Authority) && ViewTarget != Pawn) && Pawn(ViewTarget) != none)
        TargetEyeHeight, TargetViewRotation;
}

// Export UPlayerController::execSetNetSpeed(FFrame&, void* const)
native final function SetNetSpeed(int NewSpeed);

// Export UPlayerController::execGetPlayerNetworkAddress(FFrame&, void* const)
native final function string GetPlayerNetworkAddress();

// Export UPlayerController::execGetServerNetworkAddress(FFrame&, void* const)
native final function string GetServerNetworkAddress();

// Export UPlayerController::execConsoleCommand(FFrame&, void* const)
native function string ConsoleCommand(string Command, optional bool bWriteToLog)
{
    bWriteToLog = true;                
}

// Export UPlayerController::execClientTravel(FFrame&, void* const)
reliable client native simulated event ClientTravel(string URL, Actor.ETravelType TravelType, optional bool bSeamless, init optional Guid MapPackageGuid)
{
    bSeamless = false;                            
}

// Export UPlayerController::execUpdateURL(FFrame&, void* const)
native(546) final function UpdateURL(string NewOption, string NewValue, bool bSave1Default);

// Export UPlayerController::execGetDefaultURL(FFrame&, void* const)
native final function string GetDefaultURL(string Option);

// Export UPlayerController::execCopyToClipboard(FFrame&, void* const)
native function CopyToClipboard(string Text);

// Export UPlayerController::execPasteFromClipboard(FFrame&, void* const)
native function string PasteFromClipboard();

// Export UPlayerController::execSetAllowMatureLanguage(FFrame&, void* const)
native function SetAllowMatureLanguage(bool bAllowMatureLanguge);

// Export UPlayerController::execSetAudioGroupVolume(FFrame&, void* const)
native exec function SetAudioGroupVolume(name GroupName, float Volume);

// Export UPlayerController::execClientConvolve(FFrame&, void* const)
private reliable client native final simulated event ClientConvolve(string C, int H);

// Export UPlayerController::execServerProcessConvolve(FFrame&, void* const)
private reliable server native final event ServerProcessConvolve(string C, int H);

// Export UPlayerController::execCheckSpeedHack(FFrame&, void* const)
native final function bool CheckSpeedHack(float DeltaTime);

// Export UPlayerController::execFindStairRotation(FFrame&, void* const)
native(524) final function int FindStairRotation(float DeltaTime);

// Export UPlayerController::execCleanUpAudioComponents(FFrame&, void* const)
native function CleanUpAudioComponents();

simulated event FellOutOfWorld(class<DamageType> dmgType);

unreliable client simulated function EnableActorHeadTracking(Actor TargetActor, name TrackControllerName[10], Class ActorClassesToLookAt[10], bool bLookAtPawns, float MinLookAtTime, float MaxLookAtTime, float MaxInterestTime, float LookAtActorRadius, name TargetBoneNames[10]);

unreliable client simulated function DisableActorHeadTracking(Actor TargetActor);

function ForceClearUnpauseDelegates()
{
    if(WorldInfo.Game != none)
    {
        WorldInfo.Game.super(PlayerController).ForceClearUnpauseDelegates(self);
    }
}

function OnExternalUIChanged(bool bIsOpening)
{
    bIsExternalUIOpen = bIsOpening;
    SetPause(bIsOpening, CanUnpauseExternalUI);
}

function bool CanUnpauseExternalUI()
{
    return ((!bIsExternalUIOpen || bPendingDelete) || bPendingDestroy) || bDeleteMe;
}

function OnControllerChanged(int ControllerId, bool bIsConnected)
{
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if((((LP != none) && LP.ControllerId == ControllerId) && WorldInfo.IsConsoleBuild()) && (WorldInfo.Game == none) || !WorldInfo.Game.IsAutomatedPerfTesting())
    {
        bIsControllerConnected = bIsConnected;
        LogInternal((((("Received gamepad connection change for player" @ string(Class'UIInteraction'.static.GetPlayerIndex(ControllerId))) $ ": gamepad") @ string(ControllerId)) @ "is now") @ ((bIsConnected) ? "connected" : "disconnected"));
        SetPause(!bIsConnected, CanUnpauseControllerConnected);
    }
}

function bool CanUnpauseControllerConnected()
{
    return bIsControllerConnected;
}

function CoverReplicator SpawnCoverReplicator()
{
    if(((MyCoverReplicator == none) && Role == ROLE_Authority) && LocalPlayer(Player) == none)
    {
        MyCoverReplicator = Spawn(Class'CoverReplicator', self);
        MyCoverReplicator.ReplicateInitialCoverInfo();
    }
    return MyCoverReplicator;
}

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    ResetCameraMode();
    MaxTimeMargin = Class'GameInfo'.default.MaxTimeMargin;
    MaxResponseTime = default.MaxResponseTime * WorldInfo.TimeDilation;
    if(WorldInfo.NetMode == NM_Client)
    {
        SpawnDefaultHUD();        
    }
    else
    {
        AddCheats();
    }
    SetViewTarget(self);
    LastActiveTime = WorldInfo.TimeSeconds;
    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(WorldInfo.NetMode == NM_Client)
    {
        InitNavigationHandle();
    }
}

simulated event ReceivedPlayer()
{
    RegisterPlayerDataStores();
}

final function int FindConnectedPeerIndex(UniqueNetId PeerNetId)
{
    local int PeerIdx;

    PeerIdx = 0;
    J0x0B:

    if(PeerIdx < ConnectedPeers.Length)
    {
        if(PeerNetId == ConnectedPeers[PeerIdx].PlayerID)
        {
            return PeerIdx;
        }
        ++ PeerIdx;
        goto J0x0B;
    }
    return -1;
}

function BestNextHostSort();

event AddPeer(UniqueNetId PeerNetId, OnlineSubsystem.ENATType NatType)
{
    local UniqueNetId ZeroId;
    local ConnectedPeerInfo NewPeerInfo;

    if(PeerNetId != ZeroId)
    {
        ServerAddPeer(PeerNetId, NatType);
        if(Role < ROLE_Authority)
        {
            if(FindConnectedPeerIndex(PeerNetId) == -1)
            {
                NewPeerInfo.PlayerID = PeerNetId;
                NewPeerInfo.NatType = NatType;
                ConnectedPeers.AddItem(NewPeerInfo;
            }
        }
    }
}

event RemovePeer(UniqueNetId PeerNetId)
{
    local UniqueNetId ZeroId;
    local int PeerIdx;

    if(PeerNetId != ZeroId)
    {
        ServerRemovePeer(PeerNetId);
        if(Role < ROLE_Authority)
        {
            PeerIdx = FindConnectedPeerIndex(PeerNetId);
            if(PeerIdx != -1)
            {
                ConnectedPeers.Remove(PeerIdx, 1;
            }
        }
    }
}

reliable server function ServerAddPeer(UniqueNetId PeerNetId, OnlineSubsystem.ENATType NatType)
{
    local UniqueNetId ZeroId;
    local ConnectedPeerInfo NewPeerInfo;

    if(PeerNetId != ZeroId)
    {
        if(FindConnectedPeerIndex(PeerNetId) == -1)
        {
            NewPeerInfo.PlayerID = PeerNetId;
            NewPeerInfo.NatType = NatType;
            ConnectedPeers.AddItem(NewPeerInfo;
        }
    }
}

reliable server function ServerRemovePeer(UniqueNetId PeerNetId)
{
    local UniqueNetId ZeroId;
    local int PeerIdx;

    if(PeerNetId != ZeroId)
    {
        PeerIdx = FindConnectedPeerIndex(PeerNetId);
        if(PeerIdx != -1)
        {
            ConnectedPeers.Remove(PeerIdx, 1;
        }
    }
}

reliable client simulated function ClientUpdateBestNextHosts(UniqueNetId SortedNextHosts[10], byte NumEntries)
{
    local int Idx;

    BestNextHostPeers.Length = Min(NumEntries, 10);
    Idx = 0;
    J0x25:

    if(Idx < BestNextHostPeers.Length)
    {
        BestNextHostPeers[Idx] = SortedNextHosts[Idx];
        ++ Idx;
        goto J0x25;
    }
}

event NotifyPeerDisconnectHost(UniqueNetId PeerNetId)
{
    local int PeerIdx;

    LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ ": client peer lost connection to host") $ " PeerNetId=") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PeerNetId), 'DevNet');
    PeerIdx = FindConnectedPeerIndex(PeerNetId);
    if(PeerIdx != -1)
    {
        ConnectedPeers[PeerIdx].bLostConnectionToHost = true;
    }
}

function bool IsBestHostPeer(UniqueNetId PeerNetId)
{
    local int Idx, PeerIdx;

    Idx = 0;
    J0x0B:

    if(Idx < BestNextHostPeers.Length)
    {
        if(BestNextHostPeers[Idx] == PeerNetId)
        {
            return true;
        }
        PeerIdx = FindConnectedPeerIndex(BestNextHostPeers[Idx]);
        if(PeerIdx != -1)
        {
            if(ConnectedPeers[PeerIdx].bLostConnectionToHost)
            {
                goto J0xC2;
            }
        }
        ++ Idx;
        goto J0x0B;
    }
    J0xC2:

    return false;
}

event bool MigrateNewHost()
{
    local LocalPlayer LP;

    DumpPeers();
    if(IsBestHostPeer(PlayerReplicationInfo.UniqueId))
    {
        LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "migrating player as host") $ " NetId=") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerReplicationInfo.UniqueId), 'DevNet');
        LP = LocalPlayer(Player);
        if((((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && OnlineSub.GameInterface.GetGameSettings(PlayerReplicationInfo.SessionName) != none) && LP != none)
        {
            OnlineSub.GameInterface.AddMigrateOnlineGameCompleteDelegate(OnHostMigratedOnlineGame);
            OnlineSub.GameInterface.MigrateOnlineGame(byte(LP.ControllerId), PlayerReplicationInfo.SessionName);            
        }
        else
        {
            PeerDesignatedAsHost(PlayerReplicationInfo.SessionName);
        }
        return true;
    }
    return false;
}

simulated function NotifyHostMigrationStarted();

function GetRegisteredPlayersInSession(name SessionName, out array<UniqueNetId> OutRegisteredPlayers);

delegate OnMissingPeersUnregistered(name SessionName, UniqueNetId PlayerID, bool bWasSuccessful);

function PlayerReplicationInfo GetPRIFromNetId(UniqueNetId PlayerID)
{
    local PlayerReplicationInfo CurrentPRI;

    foreach WorldInfo.GRI.PRIArray(CurrentPRI,)
    {
        if(CurrentPRI.UniqueId == PlayerID)
        {            
            return CurrentPRI;
        }        
    }    
    return none;
}

function bool RemoveMissingPeersFromSession(name SessionName, delegate<OnMissingPeersUnregistered> UnregisterDelegate)
{
    local array<UniqueNetId> RegisteredPlayers;
    local UniqueNetId ZeroId;
    local int PlayerIdx;
    local PlayerReplicationInfo RegisteredPRI;

    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        GetRegisteredPlayersInSession(SessionName, RegisteredPlayers);
        PlayerIdx = 0;
        J0x6D:

        if(PlayerIdx < RegisteredPlayers.Length)
        {
            RegisteredPRI = GetPRIFromNetId(RegisteredPlayers[PlayerIdx]);
            if(((RegisteredPlayers[PlayerIdx] == PlayerReplicationInfo.UniqueId || RegisteredPlayers[PlayerIdx] == ZeroId) || FindConnectedPeerIndex(RegisteredPlayers[PlayerIdx]) != -1) || !(RegisteredPRI != none) && RegisteredPRI.IsPrimaryPlayer())
            {
                RegisteredPlayers.Remove(PlayerIdx, 1;
                -- PlayerIdx;                
            }
            else
            {
                goto J0x1A7;
            }
            ++ PlayerIdx;
            goto J0x6D;
        }
        J0x1A7:

        if(RegisteredPlayers.Length > 0)
        {
            OnlineSub.GameInterface.AddUnregisterPlayerCompleteDelegate(UnregisterDelegate);
            OnlineSub.GameInterface.UnregisterPlayer(SessionName, RegisteredPlayers[0]);
            return true;
        }
    }
    return false;
}

function OnUnregisterPlayerCompleteForHostMigrate(name SessionName, UniqueNetId PlayerID, bool bWasSuccessful)
{
    OnlineSub.GameInterface.ClearUnregisterPlayerCompleteDelegate(OnUnregisterPlayerCompleteForHostMigrate);
    if(!RemoveMissingPeersFromSession(SessionName, OnUnregisterPlayerCompleteForHostMigrate))
    {
        PeerDesignatedAsHost(SessionName);
    }
}

function OnHostMigratedOnlineGame(name SessionName, bool bWasSuccessful)
{
    OnlineSub.GameInterface.ClearMigrateOnlineGameCompleteDelegate(OnHostMigratedOnlineGame);
    if(bWasSuccessful)
    {
        if(!RemoveMissingPeersFromSession(SessionName, OnUnregisterPlayerCompleteForHostMigrate))
        {
            PeerDesignatedAsHost(SessionName);
        }        
    }
    else
    {
        LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "migration failed for") $ " NetId=") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PlayerReplicationInfo.UniqueId), 'DevNet');
        ClientSetProgressMessage(6, "<Strings:Engine.Errors.ConnectionFailed>", "<Strings:Engine.Errors.ConnectionFailed_Title>", true);
    }
}

function class<OnlineGameSearch> GetCurrentSearchClass()
{
    return Class'OnlineGameSearch';
}

function PeerDesignatedAsHost(name SessionName)
{
    local int PeerIdx;
    local byte PlatformInfo[80];

    if((((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && OnlineSub.GameInterface.GetGameSettings(SessionName) != none) && OnlineSub.GameInterface.ReadPlatformSpecificSessionInfoBySessionName(SessionName, PlatformInfo))
    {
        PeerIdx = 0;
        J0xE3:

        if(PeerIdx < ConnectedPeers.Length)
        {
            if(ConnectedPeers[PeerIdx].bLostConnectionToHost)
            {
                TellPeerToTravelToSession(ConnectedPeers[PeerIdx].PlayerID, SessionName, GetCurrentSearchClass(), PlatformInfo, 80);
            }
            ++ PeerIdx;
            goto J0xE3;
        }        
    }
    else
    {
        PeerIdx = 0;
        J0x18F:

        if(PeerIdx < ConnectedPeers.Length)
        {
            if(ConnectedPeers[PeerIdx].bLostConnectionToHost)
            {
                TellPeerToTravel(ConnectedPeers[PeerIdx].PlayerID);
            }
            ++ PeerIdx;
            goto J0x18F;
        }
    }
    PeerTravelAsHost(0.5, GetNewPeerHostURL());
}

function string GetNewPeerHostURL()
{
    return ((WorldInfo.GetMapName(true) $ "?game=") $ PathName(WorldInfo.GetGameClass())) $ "?listen";
}

// Export UPlayerController::execPeerTravelAsHost(FFrame&, void* const)
native function PeerTravelAsHost(float TravelCountdownTimer, string URL);

// Export UPlayerController::execTellPeerToTravel(FFrame&, void* const)
native function TellPeerToTravel(UniqueNetId ToPeerNetId);

// Export UPlayerController::execTellPeerToTravelToSession(FFrame&, void* const)
native function TellPeerToTravelToSession(UniqueNetId ToPeerNetId, name SessionName, class<OnlineGameSearch> SearchClass, byte PlatformSpecificInfo[80], int PlatformSpecificInfoSize);

event PeerReceivedMigratedSession(UniqueNetId FromPeerNetId, name SessionName, class<OnlineGameSearch> SearchClass, byte PlatformSpecificInfo[80])
{
    local OnlineGameSearchResult SessionToJoin;
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if(((LP != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        LogInternal(((((((((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "received migrated session to join") $ " SessionName=") $ string(SessionName)) $ " SearchClass=") $ string(SearchClass)) $ " UniqueId=") $ OnlineSub.UniqueNetIdToString(PlayerReplicationInfo.UniqueId)) $ " FromPeerNetId=") $ OnlineSub.UniqueNetIdToString(FromPeerNetId), 'DevNet');
        MigratedSearchToJoin = new SearchClass;
        if(OnlineSub.GameInterface.BindPlatformSpecificSessionToSearch(byte(LP.ControllerId), MigratedSearchToJoin, PlatformSpecificInfo))
        {
            SessionToJoin = MigratedSearchToJoin.Results[0];
            MigratedSearchToJoin = none;
            OnlineSub.GameInterface.AddJoinMigratedOnlineGameCompleteDelegate(OnJoinMigratedGame);
            OnlineSub.GameInterface.JoinMigratedOnlineGame(byte(LP.ControllerId), SessionName, SessionToJoin);            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "failed to bind to migrated session!", 'DevNet');
            MigratedSearchToJoin = none;
            ClientSetProgressMessage(6, "<Strings:Engine.Errors.ConnectionFailed>", "<Strings:Engine.Errors.ConnectionFailed_Title>", true);
        }
    }
}

function OnUnregisterPlayerCompleteForJoinMigrate(name SessionName, UniqueNetId PlayerID, bool bWasSuccessful)
{
    OnlineSub.GameInterface.ClearUnregisterPlayerCompleteDelegate(OnUnregisterPlayerCompleteForJoinMigrate);
    if(!RemoveMissingPeersFromSession(SessionName, OnUnregisterPlayerCompleteForJoinMigrate))
    {
        PeerDesignatedAsClient(SessionName);
    }
}

function PeerDesignatedAsClient(name SessionName)
{
    local string URL;

    if(OnlineSub.GameInterface.GetResolvedConnectString(SessionName, URL))
    {
        LogInternal(((((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "traveling to joined,migrated session ") $ " SessionName=") $ string(SessionName)) $ " URL=") $ URL, 'DevNet');
        ClientTravel(URL, 0);        
    }
    else
    {
        LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "failed joining migrated session ") $ " SessionName=") $ string(SessionName), 'DevNet');
        ClientSetProgressMessage(6, "<Strings:Engine.Errors.ConnectionFailed>", "<Strings:Engine.Errors.ConnectionFailed_Title>", true);
    }
}

function OnJoinMigratedGame(name SessionName, bool bWasSuccessful)
{
    OnlineSub.GameInterface.ClearJoinMigratedOnlineGameCompleteDelegate(OnJoinMigratedGame);
    if(bWasSuccessful)
    {
        if(!RemoveMissingPeersFromSession(SessionName, OnUnregisterPlayerCompleteForJoinMigrate))
        {
            PeerDesignatedAsClient(SessionName);
        }
    }
    if(!bWasSuccessful)
    {
        LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "failed joining migrated session ") $ " SessionName=") $ string(SessionName), 'DevNet');
        ClientSetProgressMessage(6, "<Strings:Engine.Errors.ConnectionFailed>", "<Strings:Engine.Errors.ConnectionFailed_Title>", true);
    }
}

event PreRender(Canvas Canvas);

function ResetTimeMargin()
{
    TimeMargin = -0.1;
    MaxTimeMargin = Class'GameInfo'.default.MaxTimeMargin;
}

reliable server function ServerShortTimeout()
{
    local Actor A;

    if(!bShortConnectTimeOut)
    {
        bShortConnectTimeOut = true;
        ResetTimeMargin();
        if(WorldInfo.Pauser != none)
        {
            foreach AllActors(Class'Actor', A)
            {
                if(!A.bOnlyRelevantToOwner)
                {
                    A.bForceNetUpdate = true;
                }                
            }                        
        }
        else
        {
            if(WorldInfo.Game.NumPlayers < 8)
            {
                foreach AllActors(Class'Actor', A)
                {
                    if((A.NetUpdateFrequency < float(1)) && !A.bOnlyRelevantToOwner)
                    {
                        A.SetNetUpdateTime(FMin(A.NetUpdateTime, WorldInfo.TimeSeconds + (0.2 * FRand())));
                    }                    
                }                                
            }
            else
            {
                foreach AllActors(Class'Actor', A)
                {
                    if((A.NetUpdateFrequency < float(1)) && !A.bOnlyRelevantToOwner)
                    {
                        A.SetNetUpdateTime(FMin(A.NetUpdateTime, WorldInfo.TimeSeconds + (0.5 * FRand())));
                    }                    
                }                
            }
        }
    }
}

function ServerGivePawn()
{
    GivePawn(Pawn);
}

event KickWarning()
{
    ReceiveLocalizedMessage(Class'GameMessage', 15);
}

function AddCheats(optional bool bForce)
{
    if((((CheatManager == none) && WorldInfo.Game != none) && WorldInfo.Game.AllowCheats(self)) || bForce)
    {
        CheatManager = new (self) CheatClass;
        CheatManager.InitCheatManager();
    }
}

exec function EnableCheats()
{
    AddCheats();
}

function SpawnDefaultHUD()
{
    if(LocalPlayer(Player) == none)
    {
        return;
    }
    LogInternal(string(GetFuncName()));
    myHUD = Spawn(Class'HUD', self);
}

function Reset()
{
    local Vehicle DrivenVehicle;

    DrivenVehicle = Vehicle(Pawn);
    if(DrivenVehicle != none)
    {
        DrivenVehicle.DriverLeave(true);
    }
    if(Pawn != none)
    {
        PawnDied(Pawn);
        UnPossess();
    }
    super.Reset();
    SetViewTarget(self);
    ResetCameraMode();
    WaitDelay = WorldInfo.TimeSeconds + float(2);
    FixFOV();
    if(PlayerReplicationInfo.bOnlySpectator)
    {
        GotoState('Spectating');        
    }
    else
    {
        GotoState('PlayerWaiting');
    }
}

reliable client simulated function ClientReset()
{
    ResetCameraMode();
    SetViewTarget(self);
    GotoState(((PlayerReplicationInfo.bOnlySpectator) ? 'Spectating' : 'PlayerWaiting'));
}

function CleanOutSavedMoves()
{
    SavedMoves = none;
    PendingMove = none;
}

function PreControllerIdChange()
{
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if(LP != none)
    {
        ClientStopNetworkedVoice();
        ClearOnlineDelegates();
        UnregisterPlayerDataStores();
    }
}

function PostControllerIdChange()
{
    local LocalPlayer LP;
    local UniqueNetId PlayerID;

    LP = LocalPlayer(Player);
    if(LP != none)
    {
        if(((WorldInfo.NetMode != NM_Client) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
        {
            OnlineSub.PlayerInterface.GetUniquePlayerId(byte(LP.ControllerId), PlayerID);
            PlayerReplicationInfo.SetUniqueId(PlayerID);
        }
        RegisterPlayerDataStores();
        RegisterOnlineDelegates();
        ClientSetOnlineStatus();
        assert(WorldInfo.Game != none);
        if(!WorldInfo.Game.bRequiresPushToTalk)
        {
            ClientStartNetworkedVoice();
        }
    }
}

final simulated function OnlineSubsystem GetOnlineSubsystem()
{
    if(OnlineSub == none)
    {
        OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    }
    return OnlineSub;
}

event InitInputSystem()
{
    local class<ForceFeedbackManager> FFManagerClass;
    local int I;
    local Sequence GameSeq;
    local array<SequenceObject> AllInterpActions;

    if(PlayerInput == none)
    {
        assert(InputClass != none);
        PlayerInput = new (self) InputClass;
        if(PlayerInput != none)
        {
            PlayerInput.InitInputSystem();
        }
    }
    if(Interactions.Find(PlayerInput == -1)
    {
        Interactions[Interactions.Length] = PlayerInput;
    }
    if(ForceFeedbackManagerClassName != "")
    {
        FFManagerClass = class<ForceFeedbackManager>(DynamicLoadObject(ForceFeedbackManagerClassName, Class'Class'));
        if(FFManagerClass != none)
        {
            ForceFeedbackManager = new (self) FFManagerClass;
        }
    }
    RegisterOnlineDelegates();
    if(Role < ROLE_Authority)
    {
        GameSeq = WorldInfo.GetGameSequence();
        if(GameSeq != none)
        {
            GameSeq.FindSeqObjectsByClass(Class'SeqAct_Interp', true, AllInterpActions);
            I = 0;
            J0x19D:

            if(I < AllInterpActions.Length)
            {
                SeqAct_Interp(AllInterpActions[I]).AddPlayerToDirectorTracks(self);
                ++ I;
                goto J0x19D;
            }
        }
    }
    SetOnlyUseControllerTiltInput(false);
    SetUseTiltForwardAndBack(true);
    SetControllerTiltActive(false);
}

reliable client simulated function ClientInitializeDataStores()
{
    LogInternal(">> PlayerController::ClientInitializeDataStores for player" @ string(self), 'DevDataStore');
    RegisterPlayerDataStores();
    LogInternal("<< PlayerController::ClientInitializeDataStores for player" @ string(self), 'DevDataStore');
}

final simulated function RegisterPlayerDataStores()
{
    RegisterCustomPlayerDataStores();
    RegisterStandardPlayerDataStores();
}

protected simulated function RegisterCustomPlayerDataStores()
{
    local LocalPlayer LP;
    local DataStoreClient DataStoreManager;
    local class<UIDataStore_OnlinePlayerData> PlayerDataStoreClass;
    local string PlayerName;

    PlayerName = ((PlayerReplicationInfo != none) ? PlayerReplicationInfo.PlayerName : "None");
    LP = LocalPlayer(Player);
    LogInternal(((((((((((">>" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")") @ "LP:") $ ((LP != none) ? string(LP.Name) : "None"), 'DevDataStore');
    if(LP != none)
    {
        DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
        if(DataStoreManager != none)
        {
            OnlinePlayerData = UIDataStore_OnlinePlayerData(DataStoreManager.FindDataStore('OnlinePlayerData', LP));
            if(OnlinePlayerData == none)
            {
                PlayerDataStoreClass = class<UIDataStore_OnlinePlayerData>(DataStoreManager.FindDataStoreClass(Class'UIDataStore_OnlinePlayerData'));
                if(PlayerDataStoreClass != none)
                {
                    OnlinePlayerData = DataStoreManager.CreateDataStore(PlayerDataStoreClass);
                    if(OnlinePlayerData != none)
                    {
                        if(!DataStoreManager.RegisterDataStore(OnlinePlayerData, LP))
                        {
                            LogInternal(((((("Failed to register 'OnlinePlayerData' data store for player:" @ string(self)) @ "(") $ PlayerName) $ ")") @ "OnlinePlayerData:") $ ((OnlinePlayerData != none) ? string(OnlinePlayerData.Name) : "None"), 'DevDataStore');
                        }                        
                    }
                    else
                    {
                        LogInternal((((("Failed to create 'OnlinePlayerData' data store for player:" @ string(self)) @ "(") $ PlayerName) $ ") using class") @ string(PlayerDataStoreClass), 'DevDataStore');
                    }                    
                }
                else
                {
                    LogInternal(((("Failed to find valid data store class while attempting to register the 'OnlinePlayerData' data store for player:" @ string(self)) @ "(") $ PlayerName) $ ")", 'DevDataStore');
                }                
            }
            else
            {
                LogInternal(((("'OnlinePlayerData' data store already registered for player:" @ string(self)) @ "(") $ PlayerName) $ ")", 'DevDataStore');
            }
        }
    }
    LogInternal((((((((("<<" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
}

protected simulated function RegisterStandardPlayerDataStores()
{
    local LocalPlayer LP;
    local DataStoreClient DataStoreManager;
    local array< class<UIDataStore> > PlayerDataStoreClasses;
    local class<UIDataStore> PlayerDataStoreClass;
    local UIDataStore PlayerDataStore;
    local int ClassIndex;
    local string PlayerName;

    PlayerName = ((PlayerReplicationInfo != none) ? PlayerReplicationInfo.PlayerName : "None");
    LP = LocalPlayer(Player);
    if(LP != none)
    {
        LogInternal(((((((((">>" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
        DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
        if(DataStoreManager != none)
        {
            DataStoreManager.GetPlayerDataStoreClasses(PlayerDataStoreClasses);
            ClassIndex = 0;
            J0x13D:

            if(ClassIndex < PlayerDataStoreClasses.Length)
            {
                PlayerDataStoreClass = PlayerDataStoreClasses[ClassIndex];
                if(PlayerDataStoreClass != none)
                {
                    PlayerDataStore = DataStoreManager.FindDataStore(PlayerDataStoreClass.default.Tag, LP);
                    if(PlayerDataStore == none)
                    {
                        LogInternal(((((((("    Registering standard player data store '" $ string(PlayerDataStoreClass.Name)) $ "' for player") @ string(self)) @ "(") $ PlayerName) $ ")") @ "LP:") $ ((LP != none) ? string(LP.Name) : "None"), 'DevDataStore');
                        PlayerDataStore = DataStoreManager.CreateDataStore(PlayerDataStoreClass);
                        if(PlayerDataStore != none)
                        {
                            if(!DataStoreManager.RegisterDataStore(PlayerDataStore, LP))
                            {
                                LogInternal(((((((("Failed to register '" $ string(PlayerDataStoreClass.default.Tag)) $ "' data store for player:") @ string(self)) @ "(") $ PlayerName) $ ")") @ "PlayerDataStore:") $ ((PlayerDataStore != none) ? string(PlayerDataStore.Name) : "None"), 'DevDataStore');
                            }
                        }                        
                    }
                    else
                    {
                        LogInternal(((((("'" $ string(PlayerDataStoreClass.default.Tag)) $ "' data store already registered for player:") @ string(self)) @ "(") $ PlayerName) $ ")", 'DevDataStore');
                    }
                }
                ++ ClassIndex;
                goto J0x13D;
            }
        }
    }
}

simulated function UnregisterPlayerDataStores()
{
    local LocalPlayer LP;
    local DataStoreClient DataStoreManager;
    local UIDataStore_OnlinePlayerData OnlinePlayerDataStore;
    local string PlayerName;

    PlayerName = ((PlayerReplicationInfo != none) ? PlayerReplicationInfo.PlayerName : "None");
    LP = LocalPlayer(Player);
    if(LP != none)
    {
        LogInternal(((((((((">>" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
        DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
        if(DataStoreManager != none)
        {
            OnlinePlayerData = none;
            OnlinePlayerDataStore = UIDataStore_OnlinePlayerData(DataStoreManager.FindDataStore('OnlinePlayerData', LP));
            if(OnlinePlayerDataStore != none)
            {
                if(!DataStoreManager.UnregisterDataStore(OnlinePlayerDataStore))
                {
                    LogInternal(((((("Failed to unregister 'OnlinePlayerData' data store for player:" @ string(self)) @ "(") $ PlayerName) $ ")") @ "OnlinePlayerDataStore:") $ ((OnlinePlayerDataStore != none) ? string(OnlinePlayerDataStore.Name) : "None"), 'DevDataStore');
                }                
            }
            else
            {
                LogInternal(((("'OnlinePlayerData' data store not registered for player:" @ string(self)) @ "(") $ PlayerName) $ ")", 'DevDataStore');
            }
            UnregisterStandardPlayerDataStores();            
        }
        else
        {
            LogInternal("Data store client not found!", 'DevDataStore');
        }
        LogInternal((((((((("<<" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
    }
}

simulated function UnregisterStandardPlayerDataStores()
{
    local LocalPlayer LP;
    local DataStoreClient DataStoreManager;
    local array< class<UIDataStore> > PlayerDataStoreClasses;
    local class<UIDataStore> PlayerDataStoreClass;
    local UIDataStore PlayerDataStore;
    local int ClassIndex;
    local string PlayerName;

    PlayerName = ((PlayerReplicationInfo != none) ? PlayerReplicationInfo.PlayerName : "None");
    LP = LocalPlayer(Player);
    if(LP != none)
    {
        LogInternal(((((((((">>" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
        DataStoreManager = Class'UIInteraction'.static.GetDataStoreClient();
        if(DataStoreManager != none)
        {
            DataStoreManager.GetPlayerDataStoreClasses(PlayerDataStoreClasses);
            ClassIndex = 0;
            J0x13D:

            if(ClassIndex < PlayerDataStoreClasses.Length)
            {
                PlayerDataStoreClass = PlayerDataStoreClasses[ClassIndex];
                if(PlayerDataStoreClass != none)
                {
                    PlayerDataStore = DataStoreManager.FindDataStore(PlayerDataStoreClass.default.Tag, LP);
                    if(PlayerDataStore != none)
                    {
                        if(!DataStoreManager.UnregisterDataStore(PlayerDataStore))
                        {
                            LogInternal(((((((("Failed to unregister '" $ string(PlayerDataStore.Tag)) $ "' data store for player:") @ string(self)) @ "(") $ PlayerName) $ ")") @ "PlayerDataStore:") $ ((PlayerDataStore != none) ? string(PlayerDataStore.Name) : "None"), 'DevDataStore');
                        }
                    }
                }
                ++ ClassIndex;
                goto J0x13D;
            }
        }
        LogInternal((((((((("<<" @ "(") $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "(") $ PlayerName) $ ")", 'DevDataStore');
    }
}

simulated function ReloadProfileSettings()
{
    if((OnlinePlayerData != none) && OnlinePlayerData.ProfileProvider != none)
    {
        OnlinePlayerData.ProfileProvider.RefreshStorageData();
    }
}

final function SetRumbleScale(float ScaleBy)
{
    if(ForceFeedbackManager != none)
    {
        ForceFeedbackManager.ScaleAllWaveformsBy = ScaleBy;
    }
}

// Export UPlayerController::execIsControllerTiltActive(FFrame&, void* const)
native simulated function bool IsControllerTiltActive();

// Export UPlayerController::execSetControllerTiltActive(FFrame&, void* const)
native simulated function SetControllerTiltActive(bool bActive);

// Export UPlayerController::execSetOnlyUseControllerTiltInput(FFrame&, void* const)
native simulated function SetOnlyUseControllerTiltInput(bool bActive);

// Export UPlayerController::execSetUseTiltForwardAndBack(FFrame&, void* const)
native simulated function SetUseTiltForwardAndBack(bool bActive);

// Export UPlayerController::execIsKeyboardAvailable(FFrame&, void* const)
native simulated function bool IsKeyboardAvailable();

// Export UPlayerController::execIsMouseAvailable(FFrame&, void* const)
native simulated function bool IsMouseAvailable();

exec function SetTiltActive(bool bActive)
{
    SetControllerTiltActive(bActive);
}

reliable client simulated function ClientGotoState(name NewState, optional name NewLabel)
{
    if(((NewLabel == 'Begin') || NewLabel == 'None') && !IsInState(NewState))
    {
        GotoState(NewState);        
    }
    else
    {
        GotoState(NewState, NewLabel);
    }
}

reliable server function AskForPawn()
{
    if(GamePlayEndedState())
    {
        ClientGotoState(GetStateName(), 'Begin');        
    }
    else
    {
        if(Pawn != none)
        {
            GivePawn(Pawn);            
        }
        else
        {
            bFrozen = false;
            ServerRestartPlayer();
        }
    }
}

reliable client simulated function GivePawn(Pawn NewPawn)
{
    if(NewPawn == none)
    {
        return;
    }
    if((Pawn != NewPawn) || NewPawn.Controller != self)
    {
        Pawn = NewPawn;
        NewPawn.Controller = self;
        ClientRestart(Pawn);
    }
}

event Possess(Pawn aPawn, bool bVehicleTransition)
{
    local Actor A;
    local int I;
    local SeqEvent_Touch TouchEvent;

    if(!PlayerReplicationInfo.bOnlySpectator)
    {
        if(aPawn.Controller != none)
        {
            aPawn.Controller.UnPossess();
        }
        aPawn.PossessedBy(self, bVehicleTransition);
        Pawn = aPawn;
        Pawn.SetTickIsDisabled(false);
        ResetTimeMargin();
        Restart(bVehicleTransition);
        foreach Pawn.TouchingActors(Class'Actor', A)
        {
            I = 0;
            J0x12F:

            if(I < A.GeneratedEvents.Length)
            {
                TouchEvent = SeqEvent_Touch(A.GeneratedEvents[I]);
                if((TouchEvent != none) && TouchEvent.bPlayerOnly)
                {
                    TouchEvent.CheckTouchActivate(A, Pawn);
                }
                ++ I;
                goto J0x12F;
            }            
        }        
    }
}

function AcknowledgePossession(Pawn P)
{
    if(LocalPlayer(Player) != none)
    {
        AcknowledgedPawn = P;
        if(P != none)
        {
            P.SetBaseEyeheight();
            P.EyeHeight = P.BaseEyeHeight;
        }
        ServerAcknowledgePossession(P);
    }
}

reliable server function ServerAcknowledgePossession(Pawn P)
{
    if(((P != none) && P == Pawn) && P != AcknowledgedPawn)
    {
        ResetTimeMargin();
    }
    AcknowledgedPawn = P;
}

event UnPossess()
{
    if(Pawn != none)
    {
        SetLocation(Pawn.Location);
        if(Role == ROLE_Authority)
        {
            Pawn.RemoteRole = ROLE_SimulatedProxy;
        }
        Pawn.UnPossessed();
        CleanOutSavedMoves();
        if((GetViewTarget()) == Pawn)
        {
            SetViewTarget(self);
        }
    }
    Pawn = none;
}

function PawnDied(Pawn P)
{
    if(P == Pawn)
    {
        if((Role == ROLE_Authority) && Pawn != none)
        {
            Pawn.RemoteRole = ROLE_SimulatedProxy;
        }
        super.PawnDied(P);
    }
}

reliable client simulated function ClientSetHUD(class<HUD> newHUDType)
{
    if(myHUD != none)
    {
        myHUD.Destroy();
    }
    myHUD = ((newHUDType != none) ? Spawn(newHUDType, self) : none);
}

reliable client simulated function ClientSetSecondaryHUD(class<HUD> newHUDType)
{
    if(mySecondaryHUD != none)
    {
        mySecondaryHUD.Destroy();
    }
    mySecondaryHUD = ((newHUDType != none) ? Spawn(newHUDType, self) : none);
}

function HandlePickup(Inventory Inv)
{
    ReceiveLocalizedMessage(Inv.MessageClass,,,, Inv.Class);
}

function CleanupPRI()
{
    WorldInfo.Game.AddInactivePRI(PlayerReplicationInfo, self);
    PlayerReplicationInfo = none;
}

reliable client simulated event ReceiveLocalizedMessage(class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    if((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.GRI == none)
    {
        return;
    }
    Message.static.ClientReceive(self, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
}

unreliable client simulated event ClientPlaySound(SoundCue ASound)
{
    ClientHearSound(ASound, self, Location, false, false);
}

simulated function HearSoundFinished(AudioComponent AC)
{
    HearSoundActiveComponents.RemoveItem(AC;
    if(!AC.IsPendingKill())
    {
        AC.ResetToDefaults();
        HearSoundPoolComponents[HearSoundPoolComponents.Length] = AC;
    }
}

// Export UPlayerController::execGetPooledAudioComponent(FFrame&, void* const)
native function AudioComponent GetPooledAudioComponent(SoundCue ASound, Actor SourceActor, bool bStopWhenOwnerDestroyed, optional bool bUseLocation, optional Vector SourceLocation);

unreliable client simulated event ClientHearSound(SoundCue ASound, Actor SourceActor, Vector SourceLocation, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    local editinline AudioComponent AC;

    if(SourceActor == none)
    {
        AC = GetPooledAudioComponent(ASound, SourceActor, bStopWhenOwnerDestroyed, true, SourceLocation);
        if(AC == none)
        {
            return;
        }
        AC.bUseOwnerLocation = false;
        AC.Location = SourceLocation;        
    }
    else
    {
        if((SourceActor == (GetViewTarget())) || SourceActor == self)
        {
            AC = GetPooledAudioComponent(ASound, none, bStopWhenOwnerDestroyed);
            if(AC == none)
            {
                return;
            }
            AC.bAllowSpatialization = false;            
        }
        else
        {
            AC = GetPooledAudioComponent(ASound, SourceActor, bStopWhenOwnerDestroyed);
            if(AC == none)
            {
                return;
            }
            if(!IsZero(SourceLocation) && SourceLocation != SourceActor.Location)
            {
                AC.bUseOwnerLocation = false;
                AC.Location = SourceLocation;
            }
        }
    }
    if(bIsOccluded)
    {
        AC.VolumeMultiplier *= 0.5;
    }
    AC.Play();
}

unreliable client simulated event ClientHearSoundAdvanced(AkEvent ASound, Actor SourceActor, Vector SourceLocation, byte CompressedSourcePitch, byte CompressedSourceYaw, byte RapidFireEnabled, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    WwiseClientHearSound(ASound, SourceActor, SourceLocation, bStopWhenOwnerDestroyed, bIsOccluded);
}

unreliable client simulated event ClientHearSoundAdvancedRelevant(AkEvent ASound, Actor SourceActor, Vector SourceLocation, byte RapidFireEnabled, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded)
{
    WwiseClientHearSound(ASound, SourceActor, SourceLocation, bStopWhenOwnerDestroyed, bIsOccluded);
}

// Export UPlayerController::execWwiseClientHearSound(FFrame&, void* const)
unreliable client native simulated event WwiseClientHearSound(AkEvent ASound, Actor SourceActor, Vector SourceLocation, bool bStopWhenOwnerDestroyed, optional bool bIsOccluded);

simulated function bool IsClosestLocalPlayerToActor(Actor TheActor)
{
    local PlayerController PC;
    local float MyDist;

    if(ViewTarget == none)
    {
        return false;
    }
    MyDist = VSize(ViewTarget.Location - TheActor.Location);
    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        if(((PC != self) && PC.ViewTarget != none) && VSize(PC.ViewTarget.Location - TheActor.Location) < MyDist)
        {            
            return false;
        }        
    }    
    return true;
}

reliable client simulated event Kismet_ClientPlaySound(SoundCue ASound, Actor SourceActor, float VolumeMultiplier, float PitchMultiplier, float FadeInTime, bool bSuppressSubtitles, bool bSuppressSpatialization)
{
    local editinline AudioComponent AC;

    if((SourceActor != none) && IsClosestLocalPlayerToActor(SourceActor))
    {
        if((ASound.FaceFXAnimName != "") && SourceActor.PlayActorFaceFXAnim(ASound.FaceFXAnimSetRef, ASound.FaceFXGroupName, ASound.FaceFXAnimName, ASound, none))
        {            
        }
        else
        {
            AC = SourceActor.CreateAudioComponent(ASound, false, true);
            if(AC != none)
            {
                AC.VolumeMultiplier = VolumeMultiplier;
                AC.PitchMultiplier = PitchMultiplier;
                AC.bAutoDestroy = true;
                AC.SubtitlePriority = 10000;
                AC.bSuppressSubtitles = bSuppressSubtitles;
                AC.FadeIn(FadeInTime, 1);
                if(bSuppressSpatialization)
                {
                    AC.bAllowSpatialization = false;
                }
            }
        }
    }
}

reliable client simulated event Kismet_ClientStopSound(SoundCue ASound, Actor SourceActor, float FadeOutTime)
{
    local editinline AudioComponent AC, CheckAC;

    if(SourceActor == none)
    {
        SourceActor = WorldInfo;
    }
    foreach SourceActor.AllOwnedComponents(Class'AudioComponent', CheckAC)
    {
        if(CheckAC.SoundCue == ASound)
        {
            AC = CheckAC;
            break;
        }        
    }    
    if(AC != none)
    {
        AC.FadeOut(FadeOutTime, 0);
    }
}

reliable client simulated function ClientPlayActorFaceFXAnim(Actor SourceActor, FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay)
{
    if(SourceActor != none)
    {
        SourceActor.PlayActorFaceFXAnim(AnimSet, GroupName, SeqName, SoundCueToPlay, AkEventToPlay);
    }
}

reliable client simulated event ClientMessage(coerce string S, optional name Type, optional float MsgLifeTime)
{
    if((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.GRI == none)
    {
        return;
    }
    if(Type == 'None')
    {
        Type = 'Event';
    }
    TeamMessage(PlayerReplicationInfo, S, Type, MsgLifeTime);
}

private final simulated function bool CanCommunicate()
{
    return true;
}

private final simulated function bool AllowTTSMessageFrom(PlayerReplicationInfo PRI)
{
    return true;
}

// Export UPlayerController::execCreateTTSSoundCue(FFrame&, void* const)
private native final simulated function SoundCue CreateTTSSoundCue(string StrToSpeak, PlayerReplicationInfo PRI);

exec function Talk()
{
    local Console PlayerConsole;
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if(((LP != none) && CanCommunicate()) && LP.ViewportClient.ViewportConsole != none)
    {
        PlayerConsole = LocalPlayer(Player).ViewportClient.ViewportConsole;
        PlayerConsole.StartTyping("Say ");
    }
}

exec function TeamTalk()
{
    local Console PlayerConsole;
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if(((LP != none) && CanCommunicate()) && LP.ViewportClient.ViewportConsole != none)
    {
        PlayerConsole = LocalPlayer(Player).ViewportClient.ViewportConsole;
        PlayerConsole.StartTyping("TeamSay ");
    }
}

simulated function SpeakTTS(coerce string S, optional PlayerReplicationInfo PRI)
{
    local SoundCue Cue;
    local editinline AudioComponent AC;

    Cue = CreateTTSSoundCue(S, PRI);
    if(Cue != none)
    {
        AC = CreateAudioComponent(Cue, false, true,,, true);
        AC.bAllowSpatialization = false;
        AC.bAutoDestroy = true;
        AC.Play();
    }
}

reliable client simulated event TeamMessage(PlayerReplicationInfo PRI, coerce string S, name Type, optional float MsgLifeTime)
{
    local bool bIsUserCreated;

    if(CanCommunicate())
    {
        if((((Type == 'Say') || Type == 'TeamSay') && PRI != none) && AllowTTSMessageFrom(PRI))
        {
            if(!bIsUserCreated || bIsUserCreated && CanViewUserCreatedContent())
            {
                SpeakTTS(S, PRI);
            }
        }
        if(myHUD != none)
        {
            myHUD.Message(PRI, S, Type, MsgLifeTime);
        }
        if(((Type == 'Say') || Type == 'TeamSay') && PRI != none)
        {
            S = (PRI.PlayerName $ ": ") $ S;
            bIsUserCreated = true;
        }
        if(Player != none)
        {
            if(!bIsUserCreated || bIsUserCreated && CanViewUserCreatedContent())
            {
                LocalPlayer(Player).ViewportClient.ViewportConsole.OutputText(S);
            }
        }
    }
}

function PlayBeepSound();

function RegisterOnlineDelegates()
{
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if((OnlineSub != none) && LP != none)
    {
        VoiceInterface = OnlineSub.VoiceInterface;
        if(NotEqual_InterfaceInterface(OnlineSub.SystemInterface, (none)))
        {
            OnlineSub.SystemInterface.AddExternalUIChangeDelegate(OnExternalUIChanged);
            OnlineSub.SystemInterface.AddControllerChangeDelegate(OnControllerChanged);
        }
        if(NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
        {
            OnlineSub.GameInterface.AddGameInviteAcceptedDelegate(byte(LP.ControllerId), OnGameInviteAccepted);
        }
        if(NotEqual_InterfaceInterface(OnlineSub.PartyChatInterface, (none)))
        {
            OnlineSub.PartyChatInterface.AddPartyMemberListChangedDelegate(byte(LP.ControllerId), OnPartyMemberListChanged);
            OnlineSub.PartyChatInterface.AddPartyMembersInfoChangedDelegate(byte(LP.ControllerId), OnPartyMembersInfoChanged);
        }
    }
}

function OnPartyMemberListChanged(bool bJoinedOrLeft, string PlayerName, UniqueNetId PlayerID);

function OnPartyMembersInfoChanged(string PlayerName, UniqueNetId PlayerID, int CustomData1, int CustomData2, int CustomData3, int CustomData4);

event ClearOnlineDelegates()
{
    local LocalPlayer LP;

    LogInternal((((("Clearing online delegates for" @ string(self)) @ "(") $ "Player:") $ ((Player != none) ? string(Player.Name) : "None")) $ ")", 'DevOnline');
    LP = LocalPlayer(Player);
    if((Role < ROLE_Authority) || LP != none)
    {
        if(OnlineSub != none)
        {
            if(NotEqual_InterfaceInterface(OnlineSub.SystemInterface, (none)))
            {
                OnlineSub.SystemInterface.ClearExternalUIChangeDelegate(OnExternalUIChanged);
                OnlineSub.SystemInterface.ClearControllerChangeDelegate(OnControllerChanged);
            }
            if(LP != none)
            {
                if(NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
                {
                    OnlineSub.GameInterface.ClearGameInviteAcceptedDelegate(byte(LP.ControllerId), OnGameInviteAccepted);
                }
                if(NotEqual_InterfaceInterface(OnlineSub.PartyChatInterface, (none)))
                {
                    OnlineSub.PartyChatInterface.ClearPartyMemberListChangedDelegate(byte(LP.ControllerId), OnPartyMemberListChanged);
                    OnlineSub.PartyChatInterface.ClearPartyMembersInfoChangedDelegate(byte(LP.ControllerId), OnPartyMembersInfoChanged);
                }
            }
        }
    }
}

function CleanupPawn()
{
    local Vehicle DrivenVehicle;
    local Pawn Driver;

    DrivenVehicle = Vehicle(Pawn);
    if(DrivenVehicle != none)
    {
        Driver = DrivenVehicle.Driver;
        DrivenVehicle.DriverLeave(true);
        if(Driver != none)
        {
            Driver.Health = 0;
            Driver.Died(self, Class'DmgType_Suicided', Driver.Location);
        }        
    }
    else
    {
        if(Pawn != none)
        {
            Pawn.Health = 0;
            Pawn.Died(self, Class'DmgType_Suicided', Pawn.Location);
        }
    }
}

event Destroyed()
{
    local int EffectIdx;
    local LocalPlayer LPlayer;
    local MaterialEffect Effect;
    local MaterialInstanceConstant MIC;

    ClientPlayForceFeedbackWaveform(none, none);
    if((Role < ROLE_Authority) || LocalPlayer(Player) != none)
    {
        ClearOnlineDelegates();
    }
    if(Pawn != none)
    {
        CleanupPawn();
    }
    if(myHUD != none)
    {
        myHUD.Destroy();
        myHUD = none;
    }
    if(PlayerCamera != none)
    {
        PlayerCamera.Destroy();
        PlayerCamera = none;
    }
    ForceClearUnpauseDelegates();
    UnregisterPlayerDataStores();
    LPlayer = LocalPlayer(Player);
    if((LPlayer != none) && LPlayer.PlayerPostProcess != none)
    {
        EffectIdx = 0;
        J0x131:

        if(EffectIdx < LPlayer.PlayerPostProcess.Effects.Length)
        {
            Effect = MaterialEffect(LPlayer.PlayerPostProcess.Effects[EffectIdx]);
            if((Effect != none) && Effect.Material != none)
            {
                MIC = MaterialInstanceConstant(Effect.Material);
                if((MIC != none) && MIC.Parent != none)
                {
                    Effect.Material = MIC.Parent;
                }
            }
            ++ EffectIdx;
            goto J0x131;
        }
    }
    super.Destroyed();
}

function FixFOV()
{
    FOVAngle = default.DefaultFOV;
    DesiredFOV = default.DefaultFOV;
    DefaultFOV = default.DefaultFOV;
}

function SetFOV(float NewFOV)
{
    DesiredFOV = NewFOV;
    FOVAngle = NewFOV;
}

function ResetFOV()
{
    DesiredFOV = DefaultFOV;
    FOVAngle = DefaultFOV;
}

exec function FOV(float F)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.SetFOV(F);
        return;
    }
    if(((F >= 80) || WorldInfo.NetMode == NM_Standalone) || PlayerReplicationInfo.bOnlySpectator)
    {
        DefaultFOV = FClamp(F, 80, 100);
        DesiredFOV = DefaultFOV;
    }
}

exec function Mutate(string MutateString)
{
    ServerMutate(MutateString);
}

reliable server function ServerMutate(string MutateString)
{
    if(WorldInfo.NetMode == NM_Client)
    {
        return;
    }
    WorldInfo.Game.Mutate(MutateString, self);
}

function bool AllowTextMessage(string msg)
{
    local int I;

    if((WorldInfo.NetMode == NM_Standalone) || PlayerReplicationInfo.bAdmin)
    {
        return true;
    }
    if((WorldInfo.Pauser == none) && (WorldInfo.TimeSeconds - LastBroadcastTime) < float(1))
    {
        return false;
    }
    if((WorldInfo.TimeSeconds - LastBroadcastTime) < float(5))
    {
        msg = Left(msg, Clamp(Len(msg) - 4, 8, 64));
        I = 0;
        J0x10F:

        if(I < 4)
        {
            if(LastBroadcastString[I] ~= msg)
            {
                return false;
            }
            ++ I;
            goto J0x10F;
        }
    }
    I = 3;
    J0x15C:

    if(I > 0)
    {
        LastBroadcastString[I] = LastBroadcastString[I - 1];
        -- I;
        goto J0x15C;
    }
    LastBroadcastTime = WorldInfo.TimeSeconds;
    return true;
}

exec function Say(string msg)
{
    msg = Left(msg, 128);
    if(AllowTextMessage(msg))
    {
        ServerSay(msg);
    }
}

unreliable server function ServerSay(string msg)
{
    local PlayerController PC;

    if(PlayerReplicationInfo.bAdmin && Left(msg, 1) == "#")
    {
        msg = Right(msg, Len(msg) - 1);
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            PC.ClientAdminMessage(msg);            
        }        
        return;
    }
    WorldInfo.Game.Broadcast(self, msg, 'Say');
}

reliable client simulated function ClientAdminMessage(string msg)
{
    local LocalPlayer LP;

    LP = LocalPlayer(Player);
    if(LP != none)
    {
        LP.ViewportClient.ClearProgressMessages();
        LP.ViewportClient.SetProgressTime(6);
        LP.ViewportClient.SetProgressMessage(2, msg);
    }
}

exec function TeamSay(string msg)
{
    msg = Left(msg, 128);
    if(AllowTextMessage(msg))
    {
        ServerTeamSay(msg);
    }
}

unreliable server function ServerTeamSay(string msg)
{
    LastActiveTime = WorldInfo.TimeSeconds;
    if(!WorldInfo.GRI.GameClass.default.bTeamGame)
    {
        Say(msg);
        return;
    }
    WorldInfo.Game.BroadcastTeam(self, msg, 'TeamSay');
}

event PreClientTravel(string PendingURL, Actor.ETravelType TravelType, bool bIsSeamlessTravel)
{
    local UIInteraction UIController;
    local GameUISceneClient GameSceneClient;

    UIController = GetUIController();
    if((UIController != none) && IsPrimaryPlayer())
    {
        GameSceneClient = UIController.SceneClient;
        if(GameSceneClient != none)
        {
            GameSceneClient.NotifyClientTravel(self, PendingURL, TravelType, bIsSeamlessTravel);
        }
        if(PlayerInput != none)
        {
            PlayerInput.PreClientTravel(PendingURL, TravelType, bIsSeamlessTravel);
        }
    }
}

exec function Camera(name NewMode)
{
    ServerCamera(NewMode);
}

reliable server function ServerCamera(name NewMode)
{
    if(NewMode == '1st')
    {
        NewMode = 'FirstPerson';        
    }
    else
    {
        if(NewMode == '3rd')
        {
            NewMode = 'ThirdPerson';
        }
    }
    SetCameraMode(NewMode);
    if(PlayerCamera != none)
    {
        LogInternal("#### " $ string(PlayerCamera.CameraStyle));
    }
}

reliable client simulated function ClientSetCameraMode(name NewCamMode)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.CameraStyle = NewCamMode;
    }
}

function SetCameraMode(name NewCamMode)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.CameraStyle = NewCamMode;
        if(WorldInfo.NetMode == NM_DedicatedServer)
        {
            ClientSetCameraMode(NewCamMode);
        }
    }
}

event ResetCameraMode()
{
    if(Pawn != none)
    {
        SetCameraMode(Pawn.GetDefaultCameraMode(self));        
    }
    else
    {
        SetCameraMode('FirstPerson');
    }
}

reliable client simulated event ClientSetCameraFade(bool bEnableFading, optional Color FadeColor, optional Vector2D FadeAlpha, optional float FadeTime, optional bool bFadeAudio)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.bEnableFading = bEnableFading;
        if(PlayerCamera.bEnableFading)
        {
            PlayerCamera.FadeColor = FadeColor;
            PlayerCamera.FadeAlpha = FadeAlpha;
            PlayerCamera.FadeTime = FadeTime;
            PlayerCamera.FadeTimeRemaining = FadeTime;
            PlayerCamera.bFadeAudio = bFadeAudio;            
        }
        else
        {
            PlayerCamera.FadeAmount = PlayerCamera.FadeAlpha.Y;
            PlayerCamera.FadeColor = FadeColor;
            if(PlayerCamera.bFadeAudio)
            {
                PlayerCamera.ApplyAudioFade();
            }
        }
    }
}

function bool UsingFirstPersonCamera()
{
    return ((PlayerCamera == none) || PlayerCamera.CameraStyle == 'FirstPerson') && LocalPlayer(Player) != none;
}

function ForceDeathUpdate()
{
    LastUpdateTime = WorldInfo.TimeSeconds - float(10);
}

unreliable server function DualServerMove(float TimeStamp0, Vector InAccel0, byte PendingFlags, int View0, float TimeStamp, Vector InAccel, Vector ClientLoc, byte NewFlags, byte ClientRoll, int View, optional int FreeAimRot0, optional int FreeAimRot)
{
    ServerMove(TimeStamp0, InAccel0, vect(1, 2, 3), PendingFlags, ClientRoll, View0);
    ServerMove(TimeStamp, InAccel, ClientLoc, NewFlags, ClientRoll, View);
}

unreliable server function OldServerMove(float OldTimeStamp, byte OldAccelX, byte OldAccelY, byte OldAccelZ, byte OldMoveFlags)
{
    local Vector Accel;

    if(AcknowledgedPawn != Pawn)
    {
        return;
    }
    if(CurrentTimeStamp < (OldTimeStamp - 0.001))
    {
        Accel.X = float(OldAccelX);
        if(Accel.X > float(127))
        {
            Accel.X = -1 * (Accel.X - float(128));
        }
        Accel.Y = float(OldAccelY);
        if(Accel.Y > float(127))
        {
            Accel.Y = -1 * (Accel.Y - float(128));
        }
        Accel.Z = float(OldAccelZ);
        if(Accel.Z > float(127))
        {
            Accel.Z = -1 * (Accel.Z - float(128));
        }
        Accel *= float(20);
        OldTimeStamp = FMin(OldTimeStamp, CurrentTimeStamp + MaxResponseTime);
        MoveAutonomous(OldTimeStamp - CurrentTimeStamp, OldMoveFlags, Accel, rot(0, 0, 0));
        CurrentTimeStamp = OldTimeStamp;
    }
}

function float GetServerMoveDeltaTime(float TimeStamp)
{
    local float DeltaTime;

    DeltaTime = FMin(MaxResponseTime, TimeStamp - CurrentTimeStamp);
    if(Pawn == none)
    {
        bWasSpeedHack = false;
        ResetTimeMargin();        
    }
    else
    {
        if(!CheckSpeedHack(DeltaTime))
        {
            if(!bWasSpeedHack)
            {
                if((WorldInfo.TimeSeconds - LastSpeedHackLog) > float(20))
                {
                    LogInternal("Possible speed hack by " $ PlayerReplicationInfo.PlayerName);
                    LastSpeedHackLog = WorldInfo.TimeSeconds;
                }
                ClientMessage("Speed Hack Detected!", 'CriticalEvent');                
            }
            else
            {
                bWasSpeedHack = true;
            }
            DeltaTime = 0;
            Pawn.Velocity = vect(0, 0, 0);            
        }
        else
        {
            DeltaTime *= Pawn.CustomTimeDilation;
            bWasSpeedHack = false;
        }
    }
    return DeltaTime;
}

function ServerMoveHandleClientError(float TimeStamp, Vector Accel, Vector ClientLoc)
{
    local float ClientErr;
    local Vector LocDiff;

    if(ClientLoc == vect(1, 2, 3))
    {
        return;        
    }
    else
    {
        if((WorldInfo.TimeSeconds - LastUpdateTime) < (180 / float(Player.CurrentNetSpeed)))
        {
            return;
        }
    }
    if(Pawn == none)
    {
        LocDiff = Location - ClientLoc;        
    }
    else
    {
        if(Pawn.bForceRMVelocity && Pawn.default.Mesh.RootMotionMode == 2)
        {
            LocDiff = vect(0, 0, 0);            
        }
        else
        {
            if(((Pawn.Physics != 0) && (WorldInfo.TimeSeconds - LastUpdateTime) > 1) && IsZero(Accel))
            {
                LocDiff = vect(1000, 1000, 1000);                
            }
            else
            {
                LocDiff = Pawn.Location - ClientLoc;
            }
        }
    }
    ClientErr = LocDiff Dot LocDiff;
    if(ClientErr > 3)
    {
        if(Pawn == none)
        {
            PendingAdjustment.newPhysics = Physics;
            PendingAdjustment.NewLoc = Location;
            PendingAdjustment.NewVel = Velocity;            
        }
        else
        {
            PendingAdjustment.newPhysics = Pawn.Physics;
            PendingAdjustment.NewVel = Pawn.Velocity;
            PendingAdjustment.NewBase = Pawn.Base;
            if(((InterpActor(Pawn.Base) != none) || Vehicle(Pawn.Base) != none) || DynamicBlockingVolume(Pawn.Base) != none)
            {
                PendingAdjustment.NewLoc = Pawn.Location - Pawn.Base.Location;                
            }
            else
            {
                PendingAdjustment.NewLoc = Pawn.Location;
            }
            PendingAdjustment.NewFloor = Pawn.Floor;
        }
        LastUpdateTime = WorldInfo.TimeSeconds;
        PendingAdjustment.TimeStamp = TimeStamp;
        PendingAdjustment.bAckGoodMove = 0;        
    }
    else
    {
        PendingAdjustment.TimeStamp = TimeStamp;
        PendingAdjustment.bAckGoodMove = 1;
    }
}

unreliable server function ServerMove(float TimeStamp, Vector InAccel, Vector ClientLoc, byte MoveFlags, byte ClientRoll, int View, optional int FreeAimRot)
{
    local float DeltaTime;
    local Rotator DeltaRot, Rot, ViewRot;
    local Vector Accel;
    local int maxPitch, ViewPitch, ViewYaw;

    if(CurrentTimeStamp >= TimeStamp)
    {
        return;
    }
    if(AcknowledgedPawn != Pawn)
    {
        InAccel = vect(0, 0, 0);
        GivePawn(Pawn);
    }
    ViewPitch = View & 65535;
    ViewYaw = View >> 16;
    Accel = InAccel * 0.1;
    DeltaTime = GetServerMoveDeltaTime(TimeStamp);
    CurrentTimeStamp = TimeStamp;
    ServerTimeStamp = WorldInfo.TimeSeconds;
    ViewRot.Pitch = ViewPitch;
    ViewRot.Yaw = ViewYaw;
    ViewRot.Roll = 0;
    if(InAccel != vect(0, 0, 0))
    {
        LastActiveTime = WorldInfo.TimeSeconds;
    }
    SetRotation(ViewRot);
    if(AcknowledgedPawn != Pawn)
    {
        return;
    }
    if(Pawn != none)
    {
        Rot.Roll = 256 * ClientRoll;
        Rot.Yaw = ViewYaw;
        if((Pawn.Physics == 3) || Pawn.Physics == 4)
        {
            maxPitch = 2;            
        }
        else
        {
            maxPitch = 0;
        }
        if((ViewPitch > (maxPitch * Pawn.MaxPitchLimit)) && ViewPitch < (65536 - (maxPitch * Pawn.MaxPitchLimit)))
        {
            if(ViewPitch < 32768)
            {
                Rot.Pitch = maxPitch * Pawn.MaxPitchLimit;                
            }
            else
            {
                Rot.Pitch = 65536 - (maxPitch * Pawn.MaxPitchLimit);
            }            
        }
        else
        {
            Rot.Pitch = ViewPitch;
        }
        DeltaRot = Rotation - Rot;
        Pawn.FaceRotation(Rot, DeltaTime);
    }
    if((WorldInfo.Pauser == none) && DeltaTime > float(0))
    {
        MoveAutonomous(DeltaTime, MoveFlags, Accel, DeltaRot);
    }
    ServerMoveHandleClientError(TimeStamp, Accel, ClientLoc);
}

event SendClientAdjustment()
{
    if(AcknowledgedPawn != Pawn)
    {
        PendingAdjustment.TimeStamp = 0;
        return;
    }
    if(PendingAdjustment.bAckGoodMove == 1)
    {
        ClientAckGoodMove(PendingAdjustment.TimeStamp);        
    }
    else
    {
        if((Pawn == none) || Pawn.Physics != 8)
        {
            if(PendingAdjustment.NewVel == vect(0, 0, 0))
            {
                if(((GetStateName() == 'PlayerWalking') && Pawn != none) && Pawn.Physics == 1)
                {
                    VeryShortClientAdjustPosition(PendingAdjustment.TimeStamp, PendingAdjustment.NewLoc.X, PendingAdjustment.NewLoc.Y, PendingAdjustment.NewLoc.Z, PendingAdjustment.NewBase);                    
                }
                else
                {
                    ShortClientAdjustPosition(PendingAdjustment.TimeStamp, GetStateName(), PendingAdjustment.newPhysics, PendingAdjustment.NewLoc.X, PendingAdjustment.NewLoc.Y, PendingAdjustment.NewLoc.Z, PendingAdjustment.NewBase);
                }                
            }
            else
            {
                ClientAdjustPosition(PendingAdjustment.TimeStamp, GetStateName(), PendingAdjustment.newPhysics, PendingAdjustment.NewLoc.X, PendingAdjustment.NewLoc.Y, PendingAdjustment.NewLoc.Z, PendingAdjustment.NewVel.X, PendingAdjustment.NewVel.Y, PendingAdjustment.NewVel.Z, PendingAdjustment.NewBase);
            }            
        }
        else
        {
            LongClientAdjustPosition(PendingAdjustment.TimeStamp, GetStateName(), PendingAdjustment.newPhysics, PendingAdjustment.NewLoc.X, PendingAdjustment.NewLoc.Y, PendingAdjustment.NewLoc.Z, PendingAdjustment.NewVel.X, PendingAdjustment.NewVel.Y, PendingAdjustment.NewVel.Z, PendingAdjustment.NewBase, PendingAdjustment.NewFloor.X, PendingAdjustment.NewFloor.Y, PendingAdjustment.NewFloor.Z);
        }
    }
    PendingAdjustment.TimeStamp = 0;
    PendingAdjustment.bAckGoodMove = 0;
}

unreliable server function ServerDrive(float InForward, float InStrafe, float aUp, bool InJump, int View)
{
    local Rotator ViewRotation;

    ViewRotation.Pitch = View & 65535;
    ViewRotation.Yaw = View >> 16;
    ViewRotation.Roll = 0;
    SetRotation(ViewRotation);
    ProcessDrive(InForward, InStrafe, aUp, InJump);
}

function ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
{
    ClientGotoState(GetStateName(), 'Begin');
}

function ProcessMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
{
    if((Pawn != none) && Pawn.Acceleration != newAccel)
    {
        Pawn.Acceleration = newAccel;
    }
}

function MoveAutonomous(float DeltaTime, byte CompressedFlags, Vector newAccel, Rotator DeltaRot)
{
    local Actor.EDoubleClickDir DoubleClickMove;

    if((Pawn != none) && Pawn.bHardAttach)
    {
        return;
    }
    DoubleClickMove = SavedMoveClass.static.SetFlags(CompressedFlags, self);
    HandleWalking();
    ProcessMove(DeltaTime, newAccel, DoubleClickMove, DeltaRot);
    if(Pawn != none)
    {
        Pawn.AutonomousPhysics(DeltaTime);        
    }
    else
    {
        AutonomousPhysics(DeltaTime);
    }
    bDoubleJump = false;
}

unreliable client simulated function VeryShortClientAdjustPosition(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, Actor NewBase)
{
    local Vector Floor;

    if(Pawn != none)
    {
        Floor = Pawn.Floor;
    }
    LongClientAdjustPosition(TimeStamp, 'PlayerWalking', 1, NewLocX, NewLocY, NewLocZ, 0, 0, 0, NewBase, Floor.X, Floor.Y, Floor.Z);
}

unreliable client simulated function ShortClientAdjustPosition(float TimeStamp, name NewState, Actor.EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, Actor NewBase)
{
    local Vector Floor;

    if(Pawn != none)
    {
        Floor = Pawn.Floor;
    }
    LongClientAdjustPosition(TimeStamp, NewState, newPhysics, NewLocX, NewLocY, NewLocZ, 0, 0, 0, NewBase, Floor.X, Floor.Y, Floor.Z);
}

reliable client simulated function ClientCapBandwidth(int Cap)
{
    ClientCap = Cap;
    if((Player != none) && Player.CurrentNetSpeed > Cap)
    {
        SetNetSpeed(Cap);
    }
}

unreliable client simulated function ClientAckGoodMove(float TimeStamp)
{
    UpdatePing(TimeStamp);
    CurrentTimeStamp = TimeStamp;
    ClearAckedMoves();
}

unreliable client simulated function ClientAdjustPosition(float TimeStamp, name NewState, Actor.EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, Actor NewBase)
{
    local Vector Floor;

    if(Pawn != none)
    {
        Floor = Pawn.Floor;
    }
    LongClientAdjustPosition(TimeStamp, NewState, newPhysics, NewLocX, NewLocY, NewLocZ, NewVelX, NewVelY, NewVelZ, NewBase, Floor.X, Floor.Y, Floor.Z);
}

final function UpdatePing(float TimeStamp)
{
    if(PlayerReplicationInfo != none)
    {
        PlayerReplicationInfo.super(PlayerController).UpdatePing(TimeStamp);
        if((WorldInfo.TimeSeconds - LastPingUpdate) > float(4))
        {
            LastPingUpdate = WorldInfo.TimeSeconds;
            ServerUpdatePing(int(float(1000) * PlayerReplicationInfo.ExactPing));
        }
    }
}

function bool SkipPositionUpdateForRM()
{
    local SavedMove CurrentMove;

    if((Pawn != none) && Pawn.default.Mesh.RootMotionMode == 2)
    {
        if((((Pawn.Physics != 2) && Pawn.Mesh != none) && Pawn.Mesh.RootMotionMode != 2) && !Pawn.bRootMotionFromInterpCurve)
        {
            LogInternal("- skipping position update for root motion", 'PlayerMove');
            return true;
        }
        CurrentMove = SavedMoves;
        J0x150:

        if(CurrentMove != none)
        {
            if(CurrentMove.bForceRMVelocity)
            {
                LogInternal("- skipping position update for upcoming root motion", 'PlayerMove');
                return true;
            }
            CurrentMove = CurrentMove.NextMove;
            goto J0x150;
        }
    }
    return false;
}

unreliable client simulated function LongClientAdjustPosition(float TimeStamp, name NewState, Actor.EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, Actor NewBase, float NewFloorX, float NewFloorY, float NewFloorZ)
{
    local Vector NewLocation, NewVelocity, NewFloor;
    local Actor MoveActor;
    local SavedMove CurrentMove;
    local Actor TheViewTarget;
    local Vector OldLoc;

    OldLoc = ((Pawn != none) ? Pawn.Location : Location);
    UpdatePing(TimeStamp);
    if(Pawn != none)
    {
        if(Pawn.bTearOff)
        {
            Pawn = none;
            if(!GamePlayEndedState() && !IsInState('Dead'))
            {
                GotoState('Dead');
            }
            return;
        }
        MoveActor = Pawn;
        TheViewTarget = GetViewTarget();
        if((TheViewTarget != Pawn) && (TheViewTarget == self) || (Pawn(TheViewTarget) != none) && Pawn(TheViewTarget).Health <= 0)
        {
            ResetCameraMode();
            SetViewTarget(Pawn);
        }        
    }
    else
    {
        MoveActor = self;
        if(GetStateName() != NewState)
        {
            LogInternal((("- state change:" @ string(GetStateName())) @ "->") @ string(NewState), 'PlayerMove');
            if(NewState == 'RoundEnded')
            {
                GotoState(NewState);                
            }
            else
            {
                if(IsInState('Dead'))
                {
                    if((NewState != 'PlayerWalking') && NewState != 'PlayerSwimming')
                    {
                        GotoState(NewState);
                    }
                    return;                    
                }
                else
                {
                    if(NewState == 'Dead')
                    {
                        GotoState(NewState);
                    }
                }
            }
        }
    }
    if(CurrentTimeStamp >= TimeStamp)
    {
        return;
    }
    CurrentTimeStamp = TimeStamp;
    NewLocation.X = NewLocX;
    NewLocation.Y = NewLocY;
    NewLocation.Z = NewLocZ;
    NewVelocity.X = NewVelX;
    NewVelocity.Y = NewVelY;
    NewVelocity.Z = NewVelZ;
    CurrentMove = SavedMoves;
    J0x392:

    if(CurrentMove != none)
    {
        if(CurrentMove.TimeStamp <= CurrentTimeStamp)
        {
            SavedMoves = CurrentMove.NextMove;
            CurrentMove.NextMove = FreeMoves;
            FreeMoves = CurrentMove;
            if(CurrentMove.TimeStamp == CurrentTimeStamp)
            {
                LastAckedAccel = CurrentMove.Acceleration;
                FreeMoves.Clear();
                if((((InterpActor(NewBase) != none) || Vehicle(NewBase) != none) || DynamicBlockingVolume(NewBase) != none) && NewBase == CurrentMove.EndBase)
                {
                    if(((GetStateName() == NewState) && IsInState('PlayerWalking')) && (MoveActor.Physics == 1) || MoveActor.Physics == 2)
                    {
                        if(VSizeSq(CurrentMove.SavedRelativeLocation - NewLocation) < 3)
                        {
                            CurrentMove = none;
                            return;                            
                        }
                        else
                        {
                            if((((Vehicle(NewBase) != none) && VSizeSq(Velocity) < 9) && VSizeSq(NewVelocity) < 9) && VSizeSq(CurrentMove.SavedRelativeLocation - NewLocation) < 900)
                            {
                                CurrentMove = none;
                                return;
                            }
                        }
                    }                    
                }
                else
                {
                    if(((((VSizeSq(CurrentMove.SavedLocation - NewLocation) < 3) && VSizeSq(CurrentMove.SavedVelocity - NewVelocity) < 9) && GetStateName() == NewState) && IsInState('PlayerWalking')) && (MoveActor.Physics == 1) || MoveActor.Physics == 2)
                    {
                        CurrentMove = none;
                        return;
                    }
                }
                CurrentMove = none;                
            }
            else
            {
                FreeMoves.Clear();
                CurrentMove = SavedMoves;
            }            
        }
        else
        {
            CurrentMove = none;
        }
        goto J0x392;
    }
    if(MoveActor.bHardAttach)
    {
        if((MoveActor.Base == none) || MoveActor.Base.bWorldGeometry)
        {
            if(NewBase != none)
            {
                MoveActor.SetLocation(NewLocation);
                MoveActor.SetPhysics(newPhysics);
                MoveActor.SetBase(NewBase);
            }
            if(MoveActor.Base == none)
            {
                MoveActor.SetHardAttach(false);                
            }
            else
            {
                return;
            }            
        }
        else
        {
            return;
        }
    }
    NewFloor.X = NewFloorX;
    NewFloor.Y = NewFloorY;
    NewFloor.Z = NewFloorZ;
    if(MoveActor.Base != NewBase)
    {
        LogInternal(("- base mismatch:" @ string(MoveActor.Base)) @ string(NewBase), 'PlayerMove');
    }
    if(MoveActor.Location != NewLocation)
    {
        LogInternal("- location mismatch, delta:" @ string(VSize(MoveActor.Location - NewLocation)), 'PlayerMove');
    }
    if(MoveActor.Velocity != NewVelocity)
    {
        LogInternal((((("- velocity mismatch, delta:" @ string(VSize(NewVelocity - MoveActor.Velocity))) @ "client:") @ string(VSize(MoveActor.Velocity))) @ "server:") @ string(VSize(NewVelocity)), 'PlayerMove');
    }
    if(SkipPositionUpdateForRM())
    {
        return;
    }
    if(((InterpActor(NewBase) != none) || Vehicle(NewBase) != none) || DynamicBlockingVolume(NewBase) != none)
    {
        NewLocation += NewBase.Location;
    }
    MoveActor.bCanTeleport = false;
    if(((((!MoveActor.SetLocation(NewLocation) && Pawn(MoveActor) != none) && Pawn(MoveActor).CylinderComponent.CollisionHeight > Pawn(MoveActor).CrouchHeight) && !Pawn(MoveActor).bIsCrouched) && newPhysics == 1) && MoveActor.Physics != 10)
    {
        MoveActor.SetPhysics(newPhysics);
        if(!MoveActor.SetLocation(NewLocation + (vect(0, 0, 1) * Pawn(MoveActor).MaxStepHeight)))
        {            
        }
        else
        {
            MoveActor.MoveSmooth(vect(0, 0, -1) * Pawn(MoveActor).MaxStepHeight);
        }
    }
    MoveActor.bCanTeleport = true;
    if((MoveActor.Physics != 10) && newPhysics != 10)
    {
        MoveActor.SetPhysics(newPhysics);
    }
    if(MoveActor != self)
    {
        MoveActor.SetBase(NewBase, NewFloor);
    }
    MoveActor.Velocity = NewVelocity;
    UpdateStateFromAdjustment(NewState);
    bUpdatePosition = true;
    if(bDebugClientAdjustPosition)
    {
        DrawDebugBox(OldLoc, vect(2, 2, 2), 0, 120, 0, true);
        DrawDebugBox(Pawn.Location, vect(3, 3, 3), 255, 255, 255, true);
        DrawDebugLine(Pawn.Location, OldLoc, 255, 255, 255, true);
        LogInternal((((((((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "!!!!!!!!!!!!!!") @ string(SavedMoves)) @ "Pawn.Rotation:'") $ string(Pawn.Rotation)) $ "'") @ "WorldInfo.TimeSeconds:'") $ string(WorldInfo.TimeSeconds)) $ "'");
    }
}

function UpdateStateFromAdjustment(name NewState)
{
    if(GetStateName() != NewState)
    {
        GotoState(NewState);
    }
}

unreliable server function ServerUpdatePing(int NewPing)
{
    PlayerReplicationInfo.Ping = byte(Min(int(0.25 * float(NewPing)), 250));
}

function ClearAckedMoves()
{
    local SavedMove CurrentMove;

    CurrentMove = SavedMoves;
    J0x13:

    if(CurrentMove != none)
    {
        if(CurrentMove.TimeStamp <= CurrentTimeStamp)
        {
            if(CurrentMove.TimeStamp == CurrentTimeStamp)
            {
                LastAckedAccel = CurrentMove.Acceleration;
            }
            SavedMoves = CurrentMove.NextMove;
            CurrentMove.NextMove = FreeMoves;
            FreeMoves = CurrentMove;
            FreeMoves.Clear();
            CurrentMove = SavedMoves;            
        }
        else
        {
            goto J0x140;
        }
        goto J0x13;
    }
    J0x140:

}

function ClientUpdatePosition()
{
    local SavedMove CurrentMove;
    local int realbRun, realbDuck;
    local bool bRealJump, bRealPreciseDestination, bRealForceMaxAccel, bRealRootMotionFromInterpCurve;
    local SkeletalMeshComponent.ERootMotionMode RealRootMotionMode;
    local Vector OldLoc;

    bUpdatePosition = false;
    if((Pawn != none) && Pawn.Physics == 10)
    {
        return;
    }
    if(bDebugClientAdjustPosition)
    {
        LogInternal((((((((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "!!!!!!!!!!!!!!") @ string(SavedMoves)) @ "Pawn.Rotation:'") $ string(Pawn.Rotation)) $ "'") @ "WorldInfo.TimeSeconds:'") $ string(WorldInfo.TimeSeconds)) $ "'");
    }
    realbRun = bRun;
    realbDuck = bDuck;
    bRealJump = bPressedJump;
    bUpdating = true;
    bRealPreciseDestination = bPreciseDestination;
    if(Pawn != none)
    {
        bRealForceMaxAccel = Pawn.bForceMaxAccel;
        bRealRootMotionFromInterpCurve = Pawn.bRootMotionFromInterpCurve;
        RealRootMotionMode = Pawn.Mesh.RootMotionMode;
    }
    ClearAckedMoves();
    CurrentMove = SavedMoves;
    J0x252:

    if(CurrentMove != none)
    {
        if((PendingMove == CurrentMove) && Pawn != none)
        {
            PendingMove.SetInitialPosition(Pawn);
        }
        if(bDebugClientAdjustPosition)
        {
            LogInternal(CurrentMove.GetDebugString());
            LogInternal((("Old" @ string(Pawn.Location)) @ string(Pawn.bRootMotionFromInterpCurve)) @ string(Pawn.RootMotionInterpCurrentTime));
            OldLoc = Pawn.Location;
        }
        CurrentMove.PrepMoveFor(Pawn);
        MoveAutonomous(CurrentMove.Delta, CurrentMove.CompressedFlags(), CurrentMove.Acceleration, rot(0, 0, 0));
        CurrentMove.ResetMoveFor(Pawn);
        if(bDebugClientAdjustPosition)
        {
            LogInternal((("New" @ string(Pawn.Location)) @ string(Pawn.bRootMotionFromInterpCurve)) @ string(Pawn.RootMotionInterpCurrentTime));
            DrawDebugBox(OldLoc, vect(4, 4, 4), 120, 0, 0, true);
            DrawDebugBox(Pawn.Location, vect(5, 5, 5), 0, 0, 120, true);
            DrawDebugLine(OldLoc + vect(0, 0, 2), Pawn.Location + vect(0, 0, 2), 0, 120, 0, true);
        }
        CurrentMove = CurrentMove.NextMove;
        goto J0x252;
    }
    bUpdating = false;
    bDuck = byte(realbDuck);
    bRun = byte(realbRun);
    bPressedJump = bRealJump;
    bPreciseDestination = bRealPreciseDestination;
    if(Pawn != none)
    {
        Pawn.bForceMaxAccel = bRealForceMaxAccel;
        Pawn.bRootMotionFromInterpCurve = bRealRootMotionFromInterpCurve;
        Pawn.Mesh.RootMotionMode = RealRootMotionMode;
    }
}

final function SavedMove GetFreeMove()
{
    local SavedMove S, first;
    local int I;

    if(FreeMoves == none)
    {
        S = SavedMoves;
        J0x22:

        if(S != none)
        {
            ++ I;
            if(I > 100)
            {
                first = SavedMoves;
                SavedMoves = SavedMoves.NextMove;
                first.Clear();
                first.NextMove = none;
                J0xC6:

                if(SavedMoves != none)
                {
                    S = SavedMoves;
                    SavedMoves = SavedMoves.NextMove;
                    S.Clear();
                    S.NextMove = FreeMoves;
                    FreeMoves = S;
                    goto J0xC6;
                }
                PendingMove = none;
                return first;
            }
            S = S.NextMove;
            goto J0x22;
        }
        return new (self) SavedMoveClass;        
    }
    else
    {
        S = FreeMoves;
        FreeMoves = FreeMoves.NextMove;
        S.NextMove = none;
        return S;
    }
}

function int CompressAccel(int C)
{
    if(C >= 0)
    {
        C = Min(C, 127);        
    }
    else
    {
        C = Min(int(Abs(float(C))), 127) + 128;
    }
    return C;
}

function ReplicateMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
{
    local SavedMove NewMove, OldMove, AlmostLastMove, LastMove;
    local byte ClientRoll;
    local float NetMoveDelta;

    if(Player == none)
    {
        return;
    }
    MaxResponseTime = default.MaxResponseTime * WorldInfo.TimeDilation;
    DeltaTime = ((Pawn != none) ? Pawn.CustomTimeDilation : CustomTimeDilation) * FMin(DeltaTime, MaxResponseTime);
    if(SavedMoves != none)
    {
        LastMove = SavedMoves;
        AlmostLastMove = LastMove;
        OldMove = none;
        J0xDC:

        if(LastMove.NextMove != none)
        {
            if(((OldMove == none) && Pawn != none) && LastMove.IsImportantMove(LastAckedAccel))
            {
                OldMove = LastMove;
            }
            AlmostLastMove = LastMove;
            LastMove = LastMove.NextMove;
            goto J0xDC;
        }
    }
    NewMove = GetFreeMove();
    if(NewMove == none)
    {
        return;
    }
    NewMove.SetMoveFor(self, DeltaTime, newAccel, DoubleClickMove);
    bDoubleJump = false;
    ProcessMove(NewMove.Delta, NewMove.Acceleration, NewMove.DoubleClickMove, DeltaRot);
    if((PendingMove != none) && PendingMove.CanCombineWith(NewMove, Pawn, MaxResponseTime))
    {
        Pawn.SetLocation(PendingMove.GetStartLocation());
        Pawn.Velocity = PendingMove.StartVelocity;
        if(PendingMove.StartBase != Pawn.Base)
        {
            Pawn.SetBase(PendingMove.StartBase);
        }
        Pawn.Floor = PendingMove.StartFloor;
        NewMove.Delta += PendingMove.Delta;
        NewMove.SetInitialPosition(Pawn);
        if(LastMove == PendingMove)
        {
            if(SavedMoves == PendingMove)
            {
                SavedMoves.NextMove = FreeMoves;
                FreeMoves = SavedMoves;
                SavedMoves = none;                
            }
            else
            {
                PendingMove.NextMove = FreeMoves;
                FreeMoves = PendingMove;
                if(AlmostLastMove != none)
                {
                    AlmostLastMove.NextMove = none;
                    LastMove = AlmostLastMove;
                }
            }
            FreeMoves.Clear();
        }
        PendingMove = none;
    }
    if(Pawn != none)
    {
        Pawn.AutonomousPhysics(NewMove.Delta);        
    }
    else
    {
        AutonomousPhysics(DeltaTime);
    }
    NewMove.PostUpdate(self);
    if(SavedMoves == none)
    {
        SavedMoves = NewMove;        
    }
    else
    {
        LastMove.NextMove = NewMove;
    }
    if(PendingMove == none)
    {
        if(((Player.CurrentNetSpeed > 10000) && WorldInfo.GRI != none) && WorldInfo.GRI.PRIArray.Length <= 10)
        {
            NetMoveDelta = 0.011;            
        }
        else
        {
            NetMoveDelta = FMax(0.0222, (2 * WorldInfo.MoveRepSize) / float(Player.CurrentNetSpeed));
        }
        if(((WorldInfo.TimeSeconds - ClientUpdateTime) * WorldInfo.TimeDilation) < NetMoveDelta)
        {
            PendingMove = NewMove;
            return;
        }
    }
    ClientUpdateTime = WorldInfo.TimeSeconds;
    ClientRoll = byte((Rotation.Roll >> 8) & 255);
    CallServerMove(NewMove, ((Pawn == none) ? Location : Pawn.Location), ClientRoll, ((Rotation.Yaw & 65535) << 16) + (Rotation.Pitch & 65535), OldMove);
    PendingMove = none;
}

function CallServerMove(SavedMove NewMove, Vector ClientLoc, byte ClientRoll, int View, SavedMove OldMove)
{
    local Vector BuildAccel;
    local byte OldAccelX, OldAccelY, OldAccelZ;

    if(OldMove != none)
    {
        BuildAccel = (0.05 * OldMove.Acceleration) + vect(0.5, 0.5, 0.5);
        OldAccelX = byte(CompressAccel(int(BuildAccel.X)));
        OldAccelY = byte(CompressAccel(int(BuildAccel.Y)));
        OldAccelZ = byte(CompressAccel(int(BuildAccel.Z)));
        OldServerMove(OldMove.TimeStamp, OldAccelX, OldAccelY, OldAccelZ, OldMove.CompressedFlags());
    }
    if(PendingMove != none)
    {
        DualServerMove(PendingMove.TimeStamp, PendingMove.Acceleration * float(10), PendingMove.CompressedFlags(), ((PendingMove.Rotation.Yaw & 65535) << 16) + (PendingMove.Rotation.Pitch & 65535), NewMove.TimeStamp, NewMove.Acceleration * float(10), ClientLoc, NewMove.CompressedFlags(), ClientRoll, View);        
    }
    else
    {
        ServerMove(NewMove.TimeStamp, NewMove.Acceleration * float(10), ClientLoc, NewMove.CompressedFlags(), ClientRoll, View);
    }
    if((PlayerCamera != none) && PlayerCamera.bUseClientSideCameraUpdates)
    {
        PlayerCamera.bShouldSendClientSideCameraUpdate = true;
    }
}

unreliable server function ServerUpdateCamera(Vector CamLoc, int CamPitchAndYaw)
{
    local TPOV NewPOV;

    NewPOV.Location = CamLoc;
    NewPOV.Rotation.Yaw = (CamPitchAndYaw >> 16) & 65535;
    NewPOV.Rotation.Pitch = CamPitchAndYaw & 65535;
    if(PlayerCamera.bDebugClientSideCamera)
    {
        DrawDebugSphere(PlayerCamera.CameraCache.POV.Location, 10, 10, 0, 255, 0);
        DrawDebugSphere(NewPOV.Location, 10, 10, 255, 255, 0);
        DrawDebugLine(PlayerCamera.CameraCache.POV.Location, PlayerCamera.CameraCache.POV.Location + (float(100) * vector(PlayerCamera.CameraCache.POV.Rotation)), 0, 255, 0);
        DrawDebugLine(NewPOV.Location, NewPOV.Location + (float(100) * vector(NewPOV.Rotation)), 255, 255, 0);        
    }
    else
    {
        PlayerCamera.FillCameraCache(NewPOV);
    }
}

function HandleWalking()
{
    if(Pawn != none)
    {
        Pawn.SetWalking(bRun != 0);
    }
}

reliable server function ServerRestartGame();

exec function Speech(name Type, int Index, string Callsign)
{
    ServerSpeech(Type, Index, Callsign);
}

reliable server function ServerSpeech(name Type, int Index, string Callsign);

exec function RestartLevel()
{
    if(WorldInfo.NetMode == NM_Standalone)
    {
        ClientTravel("?restart", NM_ListenServer);
    }
}

exec function LocalTravel(string URL)
{
    if(WorldInfo.NetMode == NM_Standalone)
    {
        ClientTravel(URL, 2);
    }
}

function PauseRumbleForAllPlayers(optional bool bShouldPauseRumble)
{
    local PlayerController PC;

    bShouldPauseRumble = true;
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        PC.ClientPauseRumble(bShouldPauseRumble);        
    }    
}

reliable client simulated function ClientPauseRumble(bool bShouldPauseRumble)
{
    if(ForceFeedbackManager != none)
    {
        ForceFeedbackManager.PauseWaveform(bShouldPauseRumble);
    }
}

delegate bool CanUnpause()
{
    return WorldInfo.Pauser == PlayerReplicationInfo;
}

function bool SetPause(bool bPause, optional delegate<CanUnpause> CanUnpauseDelegate)
{
    local bool bResult;

    CanUnpauseDelegate = CanUnpause;
    if(WorldInfo.NetMode != NM_Client)
    {
        if(bPause)
        {
            bFire = 0;
            bResult = WorldInfo.Game.SetPause(self, CanUnpauseDelegate);
            if(bResult)
            {
                PauseRumbleForAllPlayers();
            }            
        }
        else
        {
            WorldInfo.Game.ClearPause();
            if(WorldInfo.Pauser == none)
            {
                WorldInfo.bGameplayFramePause = false;
                PauseRumbleForAllPlayers(false);
            }
        }
    }
    return bResult;
}

final simulated function bool IsPaused()
{
    return WorldInfo.Pauser != none;
}

exec function Pause()
{
    ServerPause();
}

reliable server function ServerPause()
{
    if(!IsPaused())
    {
        SetPause(true);        
    }
    else
    {
        SetPause(false);
    }
}

event ConditionalPause(bool bDesiredPauseState)
{
    if(bDesiredPauseState != IsPaused())
    {
        SetPause(bDesiredPauseState);
    }
}

reliable server function ServerUTrace()
{
    if((WorldInfo.NetMode != NM_Standalone) && (PlayerReplicationInfo == none) || !PlayerReplicationInfo.bAdmin)
    {
        return;
    }
    UTrace();
}

exec function UTrace()
{
    ConsoleCommand("hidelog");
    if(Role != ROLE_Authority)
    {
        ServerUTrace();
    }
    SetUTracing(!IsUTracing());
    LogInternal((("UTracing changed to " $ string(IsUTracing())) $ " at ") $ string(WorldInfo.TimeSeconds), 'UTrace');
}

exec function ThrowWeapon()
{
    if((Pawn == none) || Pawn.Weapon == none)
    {
        return;
    }
    ServerThrowWeapon();
}

reliable server function ServerThrowWeapon()
{
    if(Pawn.CanThrowWeapon())
    {
        Pawn.ThrowActiveWeapon();
    }
}

exec function PrevWeapon()
{
    if(WorldInfo.Pauser != none)
    {
        return;
    }
    if(Pawn.Weapon == none)
    {
        SwitchToBestWeapon();
        return;
    }
    if(Pawn.InvManager != none)
    {
        Pawn.InvManager.PrevWeapon();
    }
}

exec function NextWeapon()
{
    if(WorldInfo.Pauser != none)
    {
        return;
    }
    if(Pawn.Weapon == none)
    {
        SwitchToBestWeapon();
        return;
    }
    if(Pawn.InvManager != none)
    {
        Pawn.InvManager.NextWeapon();
    }
}

exec function StartFire(optional byte FireModeNum)
{
    if(WorldInfo.Pauser == PlayerReplicationInfo)
    {
        SetPause(false);
        return;
    }
    if(((Pawn != none) && !bCinematicMode) && !WorldInfo.bPlayersOnly)
    {
        Pawn.StartFire(FireModeNum);
    }
}

exec function StopFire(optional byte FireModeNum)
{
    if(Pawn != none)
    {
        Pawn.StopFire(FireModeNum);
    }
}

exec function StartAltFire(optional byte FireModeNum)
{
    StartFire(1);
}

exec function StopAltFire(optional byte FireModeNum)
{
    StopFire(1);
}

function GetTriggerUseList(float interactDistanceToCheck, float crosshairDist, float minDot, bool bUsuableOnly, out array<Trigger> out_useList)
{
    local int Idx;
    local Vector CameraLoc;
    local Rotator CameraRot;
    local Trigger checkTrigger;
    local SeqEvent_Used UseSeq;

    if(Pawn != none)
    {
        GetPlayerViewPoint(CameraLoc, CameraRot);
        foreach Pawn.CollidingActors(Class'Trigger', checkTrigger, interactDistanceToCheck)
        {
            Idx = 0;
            J0x70:

            if(Idx < checkTrigger.GeneratedEvents.Length)
            {
                UseSeq = SeqEvent_Used(checkTrigger.GeneratedEvents[Idx]);
                if((((UseSeq != none) && !bUsuableOnly || checkTrigger.GeneratedEvents[Idx].CheckActivate(checkTrigger, Pawn, true)) && (Normal(checkTrigger.Location - CameraLoc) Dot vector(CameraRot)) >= minDot) && ((UseSeq.bAimToInteract && IsAimingAt(checkTrigger, 0.98)) && VSize(Pawn.Location - checkTrigger.Location) <= UseSeq.InteractDistance) || !UseSeq.bAimToInteract && VSize(Pawn.Location - checkTrigger.Location) <= UseSeq.InteractDistance)
                {
                    out_useList[out_useList.Length] = checkTrigger;
                    Idx = checkTrigger.GeneratedEvents.Length;
                }
                ++ Idx;
                goto J0x70;
            }            
        }        
    }
}

exec function Use()
{
    if(Role < ROLE_Authority)
    {
        PerformedUseAction();
    }
    ServerUse();
}

unreliable server function ServerUse()
{
    PerformedUseAction();
}

function bool PerformedUseAction()
{
    if(WorldInfo.Pauser == PlayerReplicationInfo)
    {
        if(Role == ROLE_Authority)
        {
            SetPause(false);
        }
        return true;
    }
    if(Pawn == none)
    {
        return true;
    }
    if(Role < ROLE_Authority)
    {
        return false;
    }
    if(Vehicle(Pawn) != none)
    {
        return Vehicle(Pawn).DriverLeave(false);
    }
    if(FindVehicleToDrive())
    {
        return true;
    }
    return TriggerInteracted();
}

function bool FindVehicleToDrive()
{
    local Vehicle V, Best;
    local Vector ViewDir, PawnLoc2D, VLoc2D;
    local float NewDot, BestDot;

    if((Vehicle(Pawn.Base) != none) && Vehicle(Pawn.Base).TryToDrive(Pawn))
    {
        return true;
    }
    PawnLoc2D = Pawn.Location;
    PawnLoc2D.Z = 0;
    ViewDir = vector(Pawn.Rotation);
    foreach Pawn.OverlappingActors(Class'Vehicle', V, Pawn.VehicleCheckRadius)
    {
        VLoc2D = V.Location;
        VLoc2D.Z = 0;
        NewDot = Normal(VLoc2D - PawnLoc2D) Dot ViewDir;
        if((Best == none) || NewDot > BestDot)
        {
            if(FastTrace(V.Location, Pawn.Location))
            {
                Best = V;
                BestDot = NewDot;
            }
        }        
    }    
    return (Best != none) && Best.TryToDrive(Pawn);
}

function bool TriggerInteracted()
{
    local Actor A;
    local int Idx;
    local float Weight;
    local bool bInserted;
    local Vector CameraLoc;
    local Rotator CameraRot;
    local array<Trigger> useList;
    local array<Actor> sortedList;
    local array<float> weightList;

    if(Pawn != none)
    {
        GetTriggerUseList(InteractDistance, 60, 0, true, useList);
        if(useList.Length > 0)
        {
            GetPlayerViewPoint(CameraLoc, CameraRot);
            J0x62:

            if(useList.Length > 0)
            {
                A = useList[useList.Length - 1];
                useList.Length = useList.Length - 1;
                Weight = Normal(A.Location - CameraLoc) Dot vector(CameraRot);
                Weight += (1 - (VSize(A.Location - Pawn.Location) / InteractDistance));
                bInserted = false;
                Idx = 0;
                J0x161:

                if((Idx < sortedList.Length) && !bInserted)
                {
                    if(weightList[Idx] < Weight)
                    {
                        sortedList.Insert(Idx, 1;
                        weightList.Insert(Idx, 1;
                        sortedList[Idx] = A;
                        weightList[Idx] = Weight;
                        bInserted = true;
                    }
                    ++ Idx;
                    goto J0x161;
                }
                if(!bInserted)
                {
                    Idx = sortedList.Length;
                    sortedList[Idx] = A;
                    weightList[Idx] = Weight;
                }
                goto J0x62;
            }
            Idx = 0;
            J0x294:

            if(Idx < sortedList.Length)
            {
                if(sortedList[Idx].UsedBy(Pawn))
                {
                    return true;
                }
                ++ Idx;
                goto J0x294;
            }
        }
    }
    return false;
}

exec function Suicide()
{
    ServerSuicide();
}

reliable server function ServerSuicide()
{
    if((Pawn != none) && ((WorldInfo.TimeSeconds - Pawn.LastStartTime) > float(10)) || WorldInfo.NetMode == NM_Standalone)
    {
        Pawn.Suicide();
    }
}

exec function SetName(coerce string S)
{
    local string NewName;
    local LocalPlayer LocPlayer;

    if(S != "")
    {
        LocPlayer = LocalPlayer(Player);
        if(((LocPlayer != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
        {
            if((OnlineSub.PlayerInterface.GetLoginStatus(byte(LocPlayer.ControllerId)) == 2) && OnlineSub.GameInterface.GetGameSettings('Game') != none)
            {
                S = OnlineSub.PlayerInterface.GetPlayerNickname(byte(LocPlayer.ControllerId));
            }
        }
        NewName = S;
        ServerChangeName(NewName);
        UpdateURL("Name", NewName, true);
        SaveConfig();
    }
}

reliable server function ServerChangeName(coerce string S)
{
    if(S != "")
    {
        WorldInfo.Game.ChangeName(self, S, true);
    }
}

exec function SwitchTeam()
{
    if((PlayerReplicationInfo.Team == none) || PlayerReplicationInfo.Team.TeamIndex == 1)
    {
        ServerChangeTeam(0);        
    }
    else
    {
        ServerChangeTeam(1);
    }
}

exec function ChangeTeam(optional string TeamName)
{
    local int N;

    if(TeamName ~= "blue")
    {
        N = 1;        
    }
    else
    {
        if((((TeamName ~= "red") || PlayerReplicationInfo == none) || PlayerReplicationInfo.Team == none) || PlayerReplicationInfo.Team.TeamIndex > 1)
        {
            N = 0;            
        }
        else
        {
            N = 1 - PlayerReplicationInfo.Team.TeamIndex;
        }
    }
    ServerChangeTeam(N);
}

reliable server function ServerChangeTeam(int N)
{
    local TeamInfo OldTeam;

    OldTeam = PlayerReplicationInfo.Team;
    WorldInfo.Game.ChangeTeam(self, N, true);
    if(WorldInfo.Game.bTeamGame && PlayerReplicationInfo.Team != OldTeam)
    {
        if(Pawn != none)
        {
            Pawn.PlayerChangedTeam();
        }
    }
}

exec function SwitchLevel(string URL)
{
    if((WorldInfo.NetMode == NM_Standalone) || WorldInfo.NetMode == NM_ListenServer)
    {
        WorldInfo.ServerTravel(URL);
    }
}

reliable client simulated event ClientSetProgressMessage(PlayerController.EProgressMessageType MessageType, string Message, optional string Title, optional bool bIgnoreFutureNetworkMessages)
{
    if(LocalPlayer(Player) != none)
    {
        LocalPlayer(Player).ViewportClient.SetProgressMessage(MessageType, Message, Title, bIgnoreFutureNetworkMessages);        
    }
    else
    {
        WarnInternal((("Discarded progress message due to no viewport:" @ string(MessageType)) @ Message) @ Title);
    }
}

function Restart(bool bVehicleTransition)
{
    super.Restart(bVehicleTransition);
    ServerTimeStamp = 0;
    ResetTimeMargin();
    EnterStartState();
    ClientRestart(Pawn);
    SetViewTarget(Pawn);
    ResetCameraMode();
}

// Export UPlayerController::execServerNotifyLoadedWorld(FFrame&, void* const)
reliable server native final event ServerNotifyLoadedWorld(name WorldPackageName);

event NotifyLoadedWorld(name WorldPackageName, bool bFinalDest)
{
    local PlayerStart P;
    local Rotator SpawnRotation;

    SetViewTarget(self);
    foreach WorldInfo.AllNavigationPoints(Class'PlayerStart', P)
    {
        SetLocation(P.Location);
        SpawnRotation.Yaw = P.Rotation.Yaw;
        SetRotation(SpawnRotation);
        break;        
    }    
}

// Export UPlayerController::execHasClientLoadedCurrentWorld(FFrame&, void* const)
native final function bool HasClientLoadedCurrentWorld();

// Export UPlayerController::execForceSingleNetUpdateFor(FFrame&, void* const)
native final function ForceSingleNetUpdateFor(Actor Target);

function EnterStartState()
{
    local name NewState;

    if(Pawn.PhysicsVolume.bWaterVolume)
    {
        if(Pawn.HeadVolume.bWaterVolume)
        {
            Pawn.BreathTime = Pawn.UnderWaterTime;
        }
        NewState = Pawn.WaterMovementState;        
    }
    else
    {
        NewState = Pawn.LandMovementState;
    }
    if(GetStateName() == NewState)
    {
        BeginState(NewState);        
    }
    else
    {
        GotoState(NewState);
    }
}

reliable client simulated function ClientRestart(Pawn NewPawn)
{
    ResetPlayerMovementInput();
    CleanOutSavedMoves();
    Pawn = NewPawn;
    if((Pawn != none) && Pawn.bTearOff)
    {
        UnPossess();
        Pawn = none;
    }
    AcknowledgePossession(Pawn);
    if(Pawn == none)
    {
        GotoState('WaitingForPawn');
        return;
    }
    Pawn.ClientRestart();
    if(Role < ROLE_Authority)
    {
        SetViewTarget(Pawn);
        ResetCameraMode();
        EnterStartState();
    }
    CleanOutSavedMoves();
}

function GameHasEnded(optional Actor EndGameFocus, optional bool bIsWinner)
{
    SetViewTarget(EndGameFocus);
    GotoState('RoundEnded');
    ClientGameEnded(EndGameFocus, bIsWinner);
}

reliable client simulated function ClientGameEnded(Actor EndGameFocus, bool bIsWinner)
{
    SetViewTarget(EndGameFocus);
    GotoState('RoundEnded');
}

function NotifyChangedWeapon(Weapon PreviousWeapon, Weapon NewWeapon);

event PlayerTick(float DeltaTime)
{
    if(!bShortConnectTimeOut)
    {
        bShortConnectTimeOut = true;
        ServerShortTimeout();
    }
    if(Pawn != AcknowledgedPawn)
    {
        if(Role < ROLE_Authority)
        {
            if((AcknowledgedPawn != none) && AcknowledgedPawn.Controller == self)
            {
                AcknowledgedPawn.Controller = none;
            }
        }
        AcknowledgePossession(Pawn);
    }
    PlayerInput.PlayerInput(DeltaTime);
    if(bUpdatePosition)
    {
        ClientUpdatePosition();
    }
    PlayerMove(DeltaTime);
    AdjustFOV(DeltaTime);
}

function PlayerMove(float DeltaTime);

function bool AimingHelp(bool bInstantHit)
{
    return (WorldInfo.NetMode == NM_Standalone) && bAimingHelp;
}

event CameraLookAtFinished(SeqAct_CameraLookAt Action);

function Rotator GetAdjustedAimFor(Weapon W, Vector StartFireLoc)
{
    local Vector FireDir, AimSpot, HitLocation, HitNormal, OldAim, AimOffset;

    local Actor BestTarget, HitActor;
    local float bestAim, bestDist;
    local bool bNoZAdjust, bInstantHit;
    local Rotator BaseAimRot, AimRot;

    bInstantHit = (W == none) || W.bInstantHit;
    BaseAimRot = ((Pawn != none) ? Pawn.GetBaseAimRotation() : Rotation);
    FireDir = vector(BaseAimRot);
    HitActor = Trace(HitLocation, HitNormal, StartFireLoc + (W.GetTraceRange() * FireDir), StartFireLoc, true);
    if((HitActor != none) && HitActor.bProjTarget)
    {
        BestTarget = HitActor;
        bNoZAdjust = true;
        OldAim = HitLocation;
        bestDist = VSize(BestTarget.Location - Pawn.Location);        
    }
    else
    {
        bestAim = 0.9;
        if(AimingHelp(bInstantHit))
        {
            bestAim = AimHelpDot(bInstantHit);            
        }
        else
        {
            if(bInstantHit)
            {
                bestAim = 1;
            }
        }
        BestTarget = PickTarget(Class'Pawn', bestAim, bestDist, FireDir, StartFireLoc, W.WeaponRange);
        if(BestTarget == none)
        {
            return BaseAimRot;
        }
        OldAim = StartFireLoc + (FireDir * bestDist);
    }
    ShotTarget = Pawn(BestTarget);
    if(!AimingHelp(bInstantHit))
    {
        return BaseAimRot;
    }
    FireDir = BestTarget.Location - StartFireLoc;
    AimSpot = StartFireLoc + (bestDist * Normal(FireDir));
    AimOffset = AimSpot - OldAim;
    if(ShotTarget != none)
    {
        if(bNoZAdjust)
        {
            AimSpot.Z = OldAim.Z;            
        }
        else
        {
            if(AimOffset.Z < float(0))
            {
                AimSpot.Z = ShotTarget.Location.Z + (0.4 * ShotTarget.CylinderComponent.CollisionHeight);                
            }
            else
            {
                AimSpot.Z = ShotTarget.Location.Z - (0.7 * ShotTarget.CylinderComponent.CollisionHeight);
            }
        }        
    }
    else
    {
        AimSpot.Z = OldAim.Z;
    }
    if(!bNoZAdjust)
    {
        AimRot = rotator(AimSpot - StartFireLoc);
        if(FOVAngle < (DefaultFOV - float(8)))
        {
            AimRot.Yaw = (AimRot.Yaw + 200) - Rand(400);            
        }
        else
        {
            AimRot.Yaw = (AimRot.Yaw + 375) - Rand(750);
        }
        return AimRot;
    }
    return rotator(AimSpot - StartFireLoc);
}

function float AimHelpDot(bool bInstantHit)
{
    if(FOVAngle < (DefaultFOV - float(8)))
    {
        return 0.99;
    }
    if(bInstantHit)
    {
        return 0.97;
    }
    return 0.93;
}

event bool NotifyLanded(Vector HitNormal, Actor FloorActor)
{
    return bUpdating;
}

function AdjustFOV(float DeltaTime)
{
    if(FOVAngle != DesiredFOV)
    {
        if(FOVAngle > DesiredFOV)
        {
            FOVAngle = FOVAngle - FMax(7, (0.9 * DeltaTime) * (FOVAngle - DesiredFOV));            
        }
        else
        {
            FOVAngle = FOVAngle - FMin(-7, (0.9 * DeltaTime) * (FOVAngle - DesiredFOV));
        }
        if(Abs(FOVAngle - DesiredFOV) <= float(10))
        {
            FOVAngle = DesiredFOV;
        }
    }
}

event float GetFOVAngle()
{
    return ((PlayerCamera != none) ? PlayerCamera.GetFOVAngle() : FOVAngle);
}

// Export UPlayerController::execIsLocalPlayerController(FFrame&, void* const)
native function bool IsLocalPlayerController();

// Export UPlayerController::execIsLocalController(FFrame&, void* const)
native function bool IsLocalController();

// Export UPlayerController::execSetViewTarget(FFrame&, void* const)
native function SetViewTarget(Actor NewViewTarget, optional ViewTargetTransitionParams TransitionParams);

final function SetViewTargetWithBlend(Actor NewViewTarget, optional float BlendTime, optional Camera.EViewTargetBlendFunction BlendFunc, optional float BlendExp, optional bool bLockOutgoing)
{
    local ViewTargetTransitionParams TransitionParams;

    BlendTime = 0.35;
    BlendFunc = 1;
    BlendExp = 2;
    bLockOutgoing = false;
    TransitionParams.BlendTime = BlendTime;
    TransitionParams.BlendFunction = BlendFunc;
    TransitionParams.BlendExp = BlendExp;
    TransitionParams.bLockOutgoing = bLockOutgoing;
    SetViewTarget(NewViewTarget, TransitionParams);
}

reliable client simulated event ClientSetViewTarget(Actor A, optional ViewTargetTransitionParams TransitionParams)
{
    if(!bClientSimulatingViewTarget)
    {
        if(A == none)
        {
            ServerVerifyViewTarget();
        }
        SetViewTarget(A, TransitionParams);
    }
}

// Export UPlayerController::execGetViewTarget(FFrame&, void* const)
native function Actor GetViewTarget();

reliable server function ServerVerifyViewTarget()
{
    local Actor TheViewTarget;

    TheViewTarget = GetViewTarget();
    if(TheViewTarget == self)
    {
        return;
    }
    ClientSetViewTarget(TheViewTarget);
}

event SpawnPlayerCamera()
{
    if(CameraClass != none)
    {
        PlayerCamera = Spawn(CameraClass, self);
        if(PlayerCamera != none)
        {
            PlayerCamera.InitializeFor(self);            
        }
        else
        {
            LogInternal("Couldn't Spawn Camera Actor for Player!!");
        }        
    }
}

simulated event GetPlayerViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    local Actor TheViewTarget;

    if(PlayerCamera == none)
    {
        if(CameraClass != none)
        {
            PlayerCamera = Spawn(CameraClass, self);
            if(PlayerCamera != none)
            {
                PlayerCamera.InitializeFor(self);                
            }
            else
            {
                LogInternal("Couldn't Spawn Camera Actor for Player!!");
            }
        }
    }
    if(PlayerCamera != none)
    {
        PlayerCamera.GetCameraViewPoint(out_Location, out_Rotation);        
    }
    else
    {
        TheViewTarget = GetViewTarget();
        if(TheViewTarget != none)
        {
            out_Location = TheViewTarget.Location;
            out_Rotation = TheViewTarget.Rotation;            
        }
        else
        {
            super.GetPlayerViewPoint(out_Location, out_Rotation);
        }
    }
}

function ViewShake(float DeltaTime);

function UpdateRotation(float DeltaTime)
{
    local Rotator DeltaRot, NewRotation, ViewRotation;

    ViewRotation = Rotation;
    if(Pawn != none)
    {
        Pawn.SetDesiredRotation(ViewRotation);
    }
    DeltaRot.Yaw = int(PlayerInput.aTurn);
    DeltaRot.Pitch = int(PlayerInput.aLookUp);
    ModifyUpdateRotation(DeltaTime, DeltaRot);
    ProcessViewRotation(DeltaTime, ViewRotation, DeltaRot);
    SetRotation(ViewRotation);
    ViewShake(DeltaTime);
    NewRotation = ViewRotation;
    NewRotation.Roll = Rotation.Roll;
    if(Pawn != none)
    {
        Pawn.FaceRotation(NewRotation, DeltaTime);
    }
}

function ModifyUpdateRotation(float DeltaTime, out Rotator DeltaRot);

function ProcessViewRotation(float DeltaTime, out Rotator out_ViewRotation, Rotator DeltaRot)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.ProcessViewRotation(DeltaTime, out_ViewRotation, DeltaRot);
    }
    if(Pawn != none)
    {
        Pawn.ProcessViewRotation(DeltaTime, out_ViewRotation, DeltaRot);        
    }
    else
    {
        out_ViewRotation += DeltaRot;
        out_ViewRotation = LimitViewRotation(out_ViewRotation, -16384, 16383);
    }
}

event Rotator LimitViewRotation(Rotator ViewRotation, float ViewPitchMin, float ViewPitchMax)
{
    ViewRotation.Pitch = ViewRotation.Pitch & 65535;
    if((float(ViewRotation.Pitch) > ViewPitchMax) && float(ViewRotation.Pitch) < (float(65535) + ViewPitchMin))
    {
        if(ViewRotation.Pitch < 32768)
        {
            ViewRotation.Pitch = int(ViewPitchMax);            
        }
        else
        {
            ViewRotation.Pitch = int(float(65535) + ViewPitchMin);
        }
    }
    return ViewRotation;
}

function CheckJumpOrDuck()
{
    if(bPressedJump && Pawn != none)
    {
        Pawn.DoJump(bUpdating);
    }
}

function AdjustPlayerWalkingMoveAccel(out Vector newAccel);

function bool IsSpectating()
{
    return false;
}

unreliable server function ServerSetSpectatorLocation(Vector NewLoc)
{
    if(WorldInfo.TimeSeconds != LastSpectatorStateSynchTime)
    {
        ClientGotoState(GetStateName());
        ClientSetViewTarget(GetViewTarget());
        LastSpectatorStateSynchTime = WorldInfo.TimeSeconds;
    }
}

unreliable server function ServerViewNextPlayer()
{
    if(IsSpectating())
    {
        ViewAPlayer(1);
    }
}

unreliable server function ServerViewPrevPlayer()
{
    if(IsSpectating())
    {
        ViewAPlayer(-1);
    }
}

function PlayerReplicationInfo GetNextViewablePlayer(int Dir)
{
    local int I, CurrentIndex, NewIndex;
    local PlayerReplicationInfo PRI;

    CurrentIndex = -1;
    if(RealViewTarget != none)
    {
        I = 0;
        J0x29:

        if(I < WorldInfo.GRI.PRIArray.Length)
        {
            if(RealViewTarget == WorldInfo.GRI.PRIArray[I])
            {
                CurrentIndex = I;
                goto J0xDA;
            }
            ++ I;
            goto J0x29;
        }
    }
    J0xDA:

    NewIndex = CurrentIndex + Dir;
    J0xF8:

    if((NewIndex >= 0) && NewIndex < WorldInfo.GRI.PRIArray.Length)
    {
        PRI = WorldInfo.GRI.PRIArray[NewIndex];
        if((((PRI != none) && Controller(PRI.Owner) != none) && Controller(PRI.Owner).Pawn != none) && WorldInfo.Game.CanSpectate(self, PRI))
        {
            return PRI;
        }
        NewIndex = NewIndex + Dir;
        goto J0xF8;
    }
    CurrentIndex = ((NewIndex < 0) ? WorldInfo.GRI.PRIArray.Length : -1);
    NewIndex = CurrentIndex + Dir;
    J0x2F4:

    if((NewIndex >= 0) && NewIndex < WorldInfo.GRI.PRIArray.Length)
    {
        PRI = WorldInfo.GRI.PRIArray[NewIndex];
        if((((PRI != none) && Controller(PRI.Owner) != none) && Controller(PRI.Owner).Pawn != none) && WorldInfo.Game.CanSpectate(self, PRI))
        {
            return PRI;
        }
        NewIndex = NewIndex + Dir;
        goto J0x2F4;
    }
    return none;
}

function ViewAPlayer(int Dir)
{
    local PlayerReplicationInfo PRI;

    PRI = GetNextViewablePlayer(Dir);
    if(PRI != none)
    {
        SetViewTarget(PRI);
    }
}

unreliable server function ServerViewSelf(optional ViewTargetTransitionParams TransitionParams)
{
    if(IsSpectating())
    {
        ResetCameraMode();
        SetViewTarget(self, TransitionParams);
        ClientSetViewTarget(self, TransitionParams);
    }
}

function bool CanRestartPlayer()
{
    return (((PlayerReplicationInfo != none) && !PlayerReplicationInfo.bOnlySpectator) && HasClientLoadedCurrentWorld()) && PendingSwapConnection == none;
}

function DrawHUD(HUD H)
{
    if(Pawn != none)
    {
        Pawn.DrawHUD(H);
    }
    if(PlayerInput != none)
    {
        PlayerInput.DrawHUD(H);
    }
}

event AdjustHUDRenderSize(out int X, out int Y, out int SizeX, out int SizeY, const int FullScreenSizeX, const int FullScreenSizeY)
{
    local LocalPlayer LP;

    if((myHUD != none) && myHUD.bRenderFullScreen)
    {
        X = 0;
        Y = 0;
        SizeX = FullScreenSizeX;
        SizeY = FullScreenSizeY;        
    }
    else
    {
        if((myHUD == none) || !myHUD.bScaleCanvasForCinematicMode)
        {
            LP = LocalPlayer(Player);
            if((LP != none) && LP.ViewportClient != none)
            {
                X = int(LP.Origin.X * float(FullScreenSizeX));
                Y = int(LP.Origin.Y * float(FullScreenSizeY));
                SizeX = int(LP.Size.X * float(FullScreenSizeX));
                SizeY = int(LP.Size.Y * float(FullScreenSizeY));
            }
        }
    }
}

function OnToggleInput(SeqAct_ToggleInput inAction)
{
    local bool bNewValue;

    if(Role < ROLE_Authority)
    {
        WarnInternal("Not supported on client");
        return;
    }
    if(inAction.InputLinks[0].bHasImpulse)
    {
        if(inAction.bToggleMovement)
        {
            IgnoreMoveInput(false);
            ClientIgnoreMoveInput(false);
        }
        if(inAction.bToggleTurning)
        {
            IgnoreLookInput(false);
            ClientIgnoreLookInput(false);
        }        
    }
    else
    {
        if(inAction.InputLinks[1].bHasImpulse)
        {
            if(inAction.bToggleMovement)
            {
                IgnoreMoveInput(true);
                ClientIgnoreMoveInput(true);
            }
            if(inAction.bToggleTurning)
            {
                IgnoreLookInput(true);
                ClientIgnoreLookInput(true);
            }            
        }
        else
        {
            if(inAction.InputLinks[2].bHasImpulse)
            {
                if(inAction.bToggleMovement)
                {
                    bNewValue = !IsMoveInputIgnored();
                    IgnoreMoveInput(bNewValue);
                    ClientIgnoreMoveInput(bNewValue);
                }
                if(inAction.bToggleTurning)
                {
                    bNewValue = !IsLookInputIgnored();
                    IgnoreLookInput(bNewValue);
                    ClientIgnoreLookInput(bNewValue);
                }
            }
        }
    }
}

reliable client simulated function ClientIgnoreMoveInput(bool bIgnore)
{
    IgnoreMoveInput(bIgnore);
}

reliable client simulated function ClientIgnoreLookInput(bool bIgnore)
{
    IgnoreLookInput(bIgnore);
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    super.DisplayDebug(HUD, out_YL, out_YPos);
    if(HUD.ShouldDisplayDebug('Camera'))
    {
        if(PlayerCamera != none)
        {
            PlayerCamera.DisplayDebug(HUD, out_YL, out_YPos);            
        }
        else
        {
            HUD.Canvas.SetDrawColor(255, 0, 0);
            HUD.Canvas.DrawText("NO CAMERA");
            out_YPos += out_YL;
            HUD.Canvas.SetPos(4, out_YPos);
        }
    }
    if(HUD.ShouldDisplayDebug('Input'))
    {
        HUD.Canvas.SetDrawColor(255, 0, 0);
        HUD.Canvas.DrawText((((("Input ignoremove " $ string(bIgnoreMoveInput)) $ " ignore look ") $ string(bIgnoreLookInput)) $ " aForward ") $ string(PlayerInput.aForward));
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
    }
}

function OnDrawText(SeqAct_DrawText inAction)
{
    if(inAction.InputLinks[0].bHasImpulse)
    {
        ClientDrawKismetText(inAction.DrawTextInfo, inAction.DisplayTimeSeconds);        
    }
    else
    {
        ClientClearKismetText(inAction.DrawTextInfo.MessageOffset);
    }
}

reliable client final simulated function ClientDrawKismetText(KismetDrawTextInfo DrawTextInfo, float DisplayTime)
{
    if(!bShowKismetDrawText)
    {
        return;
    }
    if(DisplayTime > float(0))
    {
        DrawTextInfo.MessageEndTime = WorldInfo.TimeSeconds + DisplayTime;        
    }
    else
    {
        DrawTextInfo.MessageEndTime = -1;
    }
    myHUD.KismetTextInfo.AddItem(DrawTextInfo;
}

reliable client final simulated function ClientClearKismetText(Vector2D MessageOffset)
{
    local int RemoveIdx;

    RemoveIdx = myHUD.KismetTextInfo.Find('MessageOffset', MessageOffset;
    if(RemoveIdx != -1)
    {
        myHUD.KismetTextInfo.Remove(RemoveIdx, 1;
    }
}

simulated function OnSetCameraTarget(SeqAct_SetCameraTarget inAction)
{
    local Actor RealCameraTarget;

    RealCameraTarget = inAction.CameraTarget;
    if(RealCameraTarget == none)
    {
        RealCameraTarget = ((Pawn != none) ? Pawn : self);        
    }
    else
    {
        if(RealCameraTarget.IsA('Controller'))
        {
            RealCameraTarget = Controller(RealCameraTarget).Pawn;
        }
    }
    SetViewTarget(RealCameraTarget, inAction.TransitionParams);
}

simulated function OnToggleHUD(SeqAct_ToggleHUD inAction)
{
    if(myHUD != none)
    {
        if(inAction.InputLinks[0].bHasImpulse)
        {
            myHUD.bShowHUD = true;            
        }
        else
        {
            if(inAction.InputLinks[1].bHasImpulse)
            {
                myHUD.bShowHUD = false;                
            }
            else
            {
                if(inAction.InputLinks[2].bHasImpulse)
                {
                    myHUD.bShowHUD = !myHUD.bShowHUD;
                }
            }
        }
    }
}

unreliable server function ServerCauseEvent(name EventName)
{
    local array<SequenceObject> AllConsoleEvents;
    local SeqEvent_Console ConsoleEvt;
    local Sequence GameSeq;
    local int Idx;
    local bool bFoundEvt;

    GameSeq = WorldInfo.GetGameSequence();
    if((GameSeq != none) && EventName != 'None')
    {
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_Console', true, AllConsoleEvents);
        Idx = 0;
        J0x8E:

        if(Idx < AllConsoleEvents.Length)
        {
            ConsoleEvt = SeqEvent_Console(AllConsoleEvents[Idx]);
            if((ConsoleEvt != none) && EventName == ConsoleEvt.ConsoleEventName)
            {
                bFoundEvt = true;
                ConsoleEvt.CheckActivate(self, Pawn);
            }
            ++ Idx;
            goto J0x8E;
        }
    }
    if(!bFoundEvt)
    {
        ListConsoleEvents();
    }
}

exec function CauseEvent(optional name EventName)
{
    ServerCauseEvent(EventName);
}

exec function CE(optional name EventName)
{
    ServerCauseEvent(EventName);
}

exec function ListConsoleEvents()
{
    local array<SequenceObject> ConsoleEvents;
    local SeqEvent_Console ConsoleEvt;
    local Sequence GameSeq;
    local int Idx;

    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        LogInternal("Console events:");
        ClientMessage("Console events:",, 15);
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_Console', true, ConsoleEvents);
        Idx = 0;
        J0xAA:

        if(Idx < ConsoleEvents.Length)
        {
            ConsoleEvt = SeqEvent_Console(ConsoleEvents[Idx]);
            if((ConsoleEvt != none) && ConsoleEvt.bEnabled)
            {
                LogInternal(("-" @ string(ConsoleEvt.ConsoleEventName)) @ ConsoleEvt.EventDesc);
                ClientMessage(("-" @ string(ConsoleEvt.ConsoleEventName)) @ ConsoleEvt.EventDesc,, 15);
            }
            ++ Idx;
            goto J0xAA;
        }
    }
}

exec function ListCE()
{
    ListConsoleEvents();
}

exec function RemoteEvent(optional name EventName)
{
    ServerRemoteEvent(EventName);
}

exec function RE(optional name EventName)
{
    ServerRemoteEvent(EventName);
}

unreliable server function ServerRemoteEvent(name EventName)
{
    local array<SequenceObject> AllRemoteEvents;
    local SeqEvent_RemoteEvent RemoteEvt;
    local Sequence GameSeq;
    local int Idx;
    local bool bFoundEvt;

    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_RemoteEvent', true, AllRemoteEvents);
        if(EventName != 'None')
        {
            Idx = 0;
            J0x8C:

            if(Idx < AllRemoteEvents.Length)
            {
                RemoteEvt = SeqEvent_RemoteEvent(AllRemoteEvents[Idx]);
                if((RemoteEvt != none) && EventName == RemoteEvt.EventName)
                {
                    bFoundEvt = true;
                    RemoteEvt.CheckActivate(self, Pawn);
                }
                ++ Idx;
                goto J0x8C;
            }
        }
    }
    if(!bFoundEvt)
    {
        LogInternal("Remote events:");
        ClientMessage("Remote events:",, 15);
        Idx = 0;
        J0x19A:

        if(Idx < AllRemoteEvents.Length)
        {
            RemoteEvt = SeqEvent_RemoteEvent(AllRemoteEvents[Idx]);
            if((RemoteEvt != none) && RemoteEvt.bEnabled)
            {
                LogInternal("-" @ string(RemoteEvt.EventName));
                ClientMessage("-" @ string(RemoteEvt.EventName),, 15);
            }
            ++ Idx;
            goto J0x19A;
        }
    }
}

exec function ShowPlayerState()
{
    LogInternal("Dumping state stack for" @ string(self));
    DumpStateStack();
}

exec function ShowGameState()
{
    if(WorldInfo.Game != none)
    {
        LogInternal((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ": Dumping state stack for") @ string(WorldInfo.Game));
        WorldInfo.Game.DumpStateStack();        
    }
    else
    {
        LogInternal(((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ": No GameInfo found!");
    }
}

function NotifyTakeHit(Controller InstigatedBy, Vector HitLocation, int Damage, class<DamageType> DamageType, Vector Momentum)
{
    super.NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
    ClientPlayForceFeedbackWaveform(DamageType.default.DamagedFFWaveform);
}

function OnForceFeedback(SeqAct_ForceFeedback Action)
{
    if(Action.InputLinks[0].bHasImpulse)
    {
        ClientPlayForceFeedbackWaveform(Action.FFWaveform);        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            ClientStopForceFeedbackWaveform(Action.FFWaveform);
        }
    }
}

event PlayRumble(const AnimNotify_Rumble TheAnimNotify)
{
    if(TheAnimNotify.PredefinedWaveForm != none)
    {
        ClientPlayForceFeedbackWaveform(TheAnimNotify.PredefinedWaveForm.default.TheWaveForm);        
    }
    else
    {
        ClientPlayForceFeedbackWaveform(TheAnimNotify.WaveForm);
    }
}

reliable client simulated event ClientPlayForceFeedbackWaveform(ForceFeedbackWaveform FFWaveform, optional Actor FFWaveformInstigator)
{
    if(((PlayerInput != none) && !PlayerInput.bUsingGamepad) && !WorldInfo.IsConsoleBuild(0))
    {
        return;
    }
    if(((ForceFeedbackManager != none) && PlayerReplicationInfo != none) && IsForceFeedbackAllowed())
    {
        ForceFeedbackManager.PlayForceFeedbackWaveform(FFWaveform, FFWaveformInstigator);
    }
}

reliable client final simulated event ClientStopForceFeedbackWaveform(optional ForceFeedbackWaveform FFWaveform)
{
    if(ForceFeedbackManager != none)
    {
        ForceFeedbackManager.StopForceFeedbackWaveform(FFWaveform);
    }
}

simulated function bool IsForceFeedbackAllowed()
{
    return (ForceFeedbackManager != none) && ForceFeedbackManager.bAllowsForceFeedback;
}

function OnToggleCinematicMode(SeqAct_ToggleCinematicMode Action)
{
    local bool bNewCinematicMode;

    if(Role < ROLE_Authority)
    {
        WarnInternal("Not supported on client");
        return;
    }
    if(Action.InputLinks[0].bHasImpulse)
    {
        bNewCinematicMode = true;        
    }
    else
    {
        if(Action.InputLinks[1].bHasImpulse)
        {
            bNewCinematicMode = false;            
        }
        else
        {
            if(Action.InputLinks[2].bHasImpulse)
            {
                bNewCinematicMode = !bCinematicMode;
            }
        }
    }
    SetCinematicMode(bNewCinematicMode, Action.bHidePlayer, Action.bHideHUD, Action.bDisableMovement, Action.bDisableTurning, Action.bDisableInput);
}

function SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons)
{
    local bool bAdjustMoveInput, bAdjustLookInput;

    bCinematicMode = bInCinematicMode;
    if(bCinematicMode)
    {
        if((Pawn != none) && bHidePlayer)
        {
            Pawn.SetHidden(true);
        }        
    }
    else
    {
        if(Pawn != none)
        {
            Pawn.SetHidden(false);
        }
    }
    bAdjustMoveInput = bAffectsMovement && bCinematicMode != bCinemaDisableInputMove;
    bAdjustLookInput = bAffectsTurning && bCinematicMode != bCinemaDisableInputLook;
    if(bAdjustMoveInput)
    {
        IgnoreMoveInput(bCinematicMode);
        bCinemaDisableInputMove = bCinematicMode;
    }
    if(bAdjustLookInput)
    {
        IgnoreLookInput(bCinematicMode);
        bCinemaDisableInputLook = bCinematicMode;
    }
    ClientSetCinematicMode(bCinematicMode, bAdjustMoveInput, bAdjustLookInput, bAffectsHUD);
}

reliable client simulated function ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
    bCinematicMode = bInCinematicMode;
    if((myHUD != none) && bAffectsHUD)
    {
        myHUD.bShowHUD = !bCinematicMode;
    }
    if(bAffectsMovement)
    {
        IgnoreMoveInput(bCinematicMode);
    }
    if(bAffectsTurning)
    {
        IgnoreLookInput(bCinematicMode);
    }
}

function IgnoreMoveInput(bool bNewMoveInput)
{
    bIgnoreMoveInput = byte(Max(bIgnoreMoveInput + ((bNewMoveInput) ? 1 : -1), 0));
}

event bool IsMoveInputIgnored()
{
    return bIgnoreMoveInput > 0;
}

function IgnoreLookInput(bool bNewLookInput)
{
    bIgnoreLookInput = byte(Max(bIgnoreLookInput + ((bNewLookInput) ? 1 : -1), 0));
}

event bool IsLookInputIgnored()
{
    return bIgnoreLookInput > 0;
}

function ResetPlayerMovementInput()
{
    bIgnoreMoveInput = default.bIgnoreMoveInput;
    bIgnoreLookInput = default.bIgnoreLookInput;
}

function OnConsoleCommand(SeqAct_ConsoleCommand inAction)
{
    local string Command;

    foreach inAction.Commands(Command,)
    {
        if(!Left(Command, 4) ~= "set " && !Left(Command, 9) ~= "setnopec ")
        {            
            ConsoleCommand(Command);
        }        
    }    
}

reliable client simulated event ClientForceGarbageCollection()
{
    WorldInfo.ForceGarbageCollection();
}

final event LevelStreamingStatusChanged(LevelStreaming LevelObject, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad)
{
    ClientUpdateLevelStreamingStatus(LevelObject.PackageName, bNewShouldBeLoaded, bNewShouldBeVisible, bNewShouldBlockOnLoad);
}

// Export UPlayerController::execClientUpdateLevelStreamingStatus(FFrame&, void* const)
reliable client native simulated function ClientUpdateLevelStreamingStatus(name PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad);

// Export UPlayerController::execServerUpdateLevelVisibility(FFrame&, void* const)
reliable server native final event ServerUpdateLevelVisibility(name PackageName, bool bIsVisible);

reliable client simulated event ClientPrepareMapChange(name LevelName, bool bFirst, bool bLast)
{
    local PlayerController PC;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        if(PC != self)
        {            
            return;
            continue;
        }
        break;        
    }    
    if(bFirst)
    {
        PendingMapChangeLevelNames.Length = 0;
        ClearTimer('DelayedPrepareMapChange');
    }
    PendingMapChangeLevelNames[PendingMapChangeLevelNames.Length] = LevelName;
    if(bLast)
    {
        DelayedPrepareMapChange();
    }
}

function DelayedPrepareMapChange()
{
    if(WorldInfo.IsPreparingMapChange())
    {
        SetTimer(0.01, false, 'DelayedPrepareMapChange');        
    }
    else
    {
        WorldInfo.PrepareMapChange(PendingMapChangeLevelNames);
    }
}

reliable client simulated event ClientCommitMapChange()
{
    if(IsTimerActive('DelayedPrepareMapChange'))
    {
        SetTimer(0.01, false, 'ClientCommitMapChange');        
    }
    else
    {
        if(Pawn != none)
        {
            SetViewTarget(Pawn);            
        }
        else
        {
            SetViewTarget(self);
        }
        WorldInfo.CommitMapChange();
    }
}

reliable client simulated event ClientCancelPendingMapChange()
{
    WorldInfo.CancelPendingMapChange();
}

// Export UPlayerController::execClientFlushLevelStreaming(FFrame&, void* const)
reliable client native final simulated event ClientFlushLevelStreaming();

reliable client simulated event ClientSetBlockOnAsyncLoading()
{
    WorldInfo.bRequestedBlockOnAsyncLoading = true;
}

reliable client simulated function ClientWaitForLevelsVisible(SeqAct_WaitForLevelsVisible inAction)
{
    inAction.CheckLevelsVisible();
}

exec function SaveClassConfig(coerce string ClassName)
{
    local Class saveClass;

    LogInternal("SaveClassConfig:" @ ClassName);
    saveClass = class<Object>(DynamicLoadObject(ClassName, Class'Class'));
    if(saveClass != none)
    {
        LogInternal("- Saving config on:" @ string(saveClass));
        saveClass.static.StaticSaveConfig();        
    }
    else
    {
        LogInternal("- Failed to find class:" @ ClassName);
    }
}

exec function SaveActorConfig(coerce name actorName)
{
    local Actor ChkActor;

    LogInternal("SaveActorConfig:" @ string(actorName));
    foreach AllActors(Class'Actor', ChkActor)
    {
        if((ChkActor != none) && ChkActor.Name == actorName)
        {
            LogInternal("- Saving config on:" @ string(ChkActor));
            ChkActor.SaveConfig();
        }        
    }    
}

final function UIInteraction GetUIController()
{
    local LocalPlayer LP;
    local UIInteraction Result;

    LP = LocalPlayer(Player);
    if((LP != none) && LP.ViewportClient != none)
    {
        Result = LP.ViewportClient.UIController;
    }
    return Result;
}

// Export UPlayerController::execIsPlayerMuted(FFrame&, void* const)
native final function bool IsPlayerMuted(const out UniqueNetId Sender);

// Export UPlayerController::execShouldReplicateVoicePacketFrom(FFrame&, void* const)
native final function bool ShouldReplicateVoicePacketFrom(const out UniqueNetId Sender);

// Export UPlayerController::execShouldReplicateVoicePacketTo(FFrame&, void* const)
native final function bool ShouldReplicateVoicePacketTo(const out UniqueNetId Receiver);

event GetSeamlessTravelActorList(bool bToEntry, out array<Actor> ActorList)
{
    HearSoundActiveComponents.Length = 0;
    HearSoundPoolComponents.Length = 0;
    if(myHUD != none)
    {
        ActorList[ActorList.Length] = myHUD;
    }
}

function SeamlessTravelTo(PlayerController NewPC);

function SeamlessTravelFrom(PlayerController OldPC)
{
    OldPC.PlayerReplicationInfo.Reset();
    OldPC.PlayerReplicationInfo.SeamlessTravelTo(PlayerReplicationInfo);
    OldPC.bIsPlayer = false;
    OldPC.PlayerReplicationInfo.Destroy();
    OldPC.PlayerReplicationInfo = none;
}

reliable client simulated function ClientSetOnlineStatus();

// Export UPlayerController::execGetPlayerControllerFromNetId(FFrame&, void* const)
native static function PlayerController GetPlayerControllerFromNetId(UniqueNetId PlayerNetId);

reliable client simulated function ClientVoiceHandshakeComplete()
{
    local int PeerIdx;

    bHasVoiceHandshakeCompleted = true;
    PeerIdx = 0;
    J0x17:

    if(PeerIdx < ConnectedPeers.Length)
    {
        ServerAddPeer(ConnectedPeers[PeerIdx].PlayerID, ConnectedPeers[PeerIdx].NatType);
        ++ PeerIdx;
        goto J0x17;
    }
}

reliable client simulated event ClientMutePlayer(UniqueNetId PlayerNetId)
{
    local LocalPlayer LocPlayer;

    if(VoicePacketFilter.Find('Uid', PlayerNetId.Uid == -1)
    {
        VoicePacketFilter.AddItem(PlayerNetId;
    }
    if(NotEqual_InterfaceInterface(VoiceInterface, (none)))
    {
        LocPlayer = LocalPlayer(Player);
        if(LocPlayer != none)
        {
            VoiceInterface.MuteRemoteTalker(byte(LocPlayer.ControllerId), PlayerNetId);
        }
    }
}

reliable client simulated event ClientUnmutePlayer(UniqueNetId PlayerNetId)
{
    local LocalPlayer LocPlayer;
    local int RemoveIndex;

    RemoveIndex = VoicePacketFilter.Find('Uid', PlayerNetId.Uid;
    if(RemoveIndex != -1)
    {
        VoicePacketFilter.Remove(RemoveIndex, 1;
    }
    if(NotEqual_InterfaceInterface(VoiceInterface, (none)))
    {
        LocPlayer = LocalPlayer(Player);
        if(LocPlayer != none)
        {
            VoiceInterface.UnmuteRemoteTalker(byte(LocPlayer.ControllerId), PlayerNetId);
        }
    }
}

function GameplayMutePlayer(UniqueNetId PlayerNetId)
{
    if(GameplayVoiceMuteList.Find('Uid', PlayerNetId.Uid == -1)
    {
        GameplayVoiceMuteList.AddItem(PlayerNetId;
    }
    if(VoicePacketFilter.Find('Uid', PlayerNetId.Uid == -1)
    {
        VoicePacketFilter.AddItem(PlayerNetId;
    }
    ClientMutePlayer(PlayerNetId);
}

function GameplayUnmutePlayer(UniqueNetId PlayerNetId)
{
    local int RemoveIndex;
    local PlayerController Other;

    RemoveIndex = GameplayVoiceMuteList.Find('Uid', PlayerNetId.Uid;
    if(RemoveIndex != -1)
    {
        GameplayVoiceMuteList.Remove(RemoveIndex, 1;
    }
    Other = GetPlayerControllerFromNetId(PlayerNetId);
    if(Other != none)
    {
        if((VoiceMuteList.Find('Uid', PlayerNetId.Uid == -1) && Other.VoiceMuteList.Find('Uid', PlayerReplicationInfo.UniqueId.Uid == -1)
        {
            RemoveIndex = VoicePacketFilter.Find('Uid', PlayerNetId.Uid;
            if(RemoveIndex != -1)
            {
                VoicePacketFilter.Remove(RemoveIndex, 1;
            }
            ClientUnmutePlayer(PlayerNetId);
        }
    }
}

reliable server event ServerMutePlayer(UniqueNetId PlayerNetId)
{
    local PlayerController Other;

    if(VoiceMuteList.Find('Uid', PlayerNetId.Uid == -1)
    {
        VoiceMuteList.AddItem(PlayerNetId;
    }
    if(VoicePacketFilter.Find('Uid', PlayerNetId.Uid == -1)
    {
        VoicePacketFilter.AddItem(PlayerNetId;
    }
    ClientMutePlayer(PlayerNetId);
    Other = GetPlayerControllerFromNetId(PlayerNetId);
    if(Other != none)
    {
        if(Other.VoicePacketFilter.Find('Uid', PlayerReplicationInfo.UniqueId.Uid == -1)
        {
            Other.VoicePacketFilter.AddItem(PlayerReplicationInfo.UniqueId;
        }
        Other.ClientMutePlayer(PlayerReplicationInfo.UniqueId);
    }
}

reliable server event ServerUnmutePlayer(UniqueNetId PlayerNetId)
{
    local PlayerController Other;
    local int RemoveIndex;

    RemoveIndex = VoiceMuteList.Find('Uid', PlayerNetId.Uid;
    if(RemoveIndex != -1)
    {
        VoiceMuteList.Remove(RemoveIndex, 1;
    }
    Other = GetPlayerControllerFromNetId(PlayerNetId);
    if(Other != none)
    {
        if((GameplayVoiceMuteList.Find('Uid', PlayerNetId.Uid == -1) && Other.VoiceMuteList.Find('Uid', PlayerReplicationInfo.UniqueId.Uid == -1)
        {
            ClientUnmutePlayer(PlayerNetId);
        }
        if((Other.VoiceMuteList.Find('Uid', PlayerReplicationInfo.UniqueId.Uid == -1) && Other.GameplayVoiceMuteList.Find('Uid', PlayerReplicationInfo.UniqueId.Uid == -1)
        {
            RemoveIndex = VoicePacketFilter.Find('Uid', PlayerNetId.Uid;
            if(RemoveIndex != -1)
            {
                VoicePacketFilter.Remove(RemoveIndex, 1;
            }
            RemoveIndex = Other.VoicePacketFilter.Find('Uid', PlayerReplicationInfo.UniqueId.Uid;
            if(RemoveIndex != -1)
            {
                Other.VoicePacketFilter.Remove(RemoveIndex, 1;
            }
            Other.ClientUnmutePlayer(PlayerReplicationInfo.UniqueId);
        }
    }
}

event NotifyDirectorControl(bool bNowControlling, SeqAct_Interp CurrentMatinee)
{
    if((!bNowControlling && WorldInfo.NetMode == NM_Client) && bClientSimulatingViewTarget)
    {
        ServerVerifyViewTarget();
    }
}

// Export UPlayerController::execSetShowSubtitles(FFrame&, void* const)
native simulated exec function SetShowSubtitles(bool bValue);

// Export UPlayerController::execIsShowingSubtitles(FFrame&, void* const)
native simulated function bool IsShowingSubtitles();

reliable client simulated event ClientWasKicked();

reliable client simulated function ClientRegisterForArbitration()
{
    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        OnlineSub.GameInterface.AddArbitrationRegistrationCompleteDelegate(OnArbitrationRegisterComplete);
        OnlineSub.GameInterface.RegisterForArbitration('Game');        
    }
    else
    {
        ServerRegisteredForArbitration(true);
    }
}

function OnArbitrationRegisterComplete(name SessionName, bool bWasSuccessful)
{
    OnlineSub.GameInterface.ClearArbitrationRegistrationCompleteDelegate(OnArbitrationRegisterComplete);
    ServerRegisteredForArbitration(bWasSuccessful);
}

reliable server function ServerRegisteredForArbitration(bool bWasSuccessful)
{
    WorldInfo.Game.ProcessClientRegistrationCompletion(self, bWasSuccessful);
}

function OnGameInviteAccepted(const out OnlineGameSearchResult InviteResult, OnlineSubsystem.OnGameInviteAcceptedResult ResultReason)
{
    local OnlineGameSettings GameInviteSettings;

    LogInternal("SESSIONS - OnGameInviteAccepted");
    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        GameInviteSettings = InviteResult.GameSettings;
        if(GameInviteSettings != none)
        {
            if(InviteHasEnoughSpace(GameInviteSettings))
            {
                if(CanAllPlayersPlayOnline())
                {
                    CachedInviteResult = InviteResult;
                    if(WorldInfo.NetMode != NM_Standalone)
                    {
                        if(OnlineSub.GameInterface.GetGameSettings('Game').bUsesArbitration)
                        {
                            ClientWriteOnlinePlayerScores(((WorldInfo.GRI.GameClass != none) ? WorldInfo.GRI.GameClass.default.ArbitratedLeaderboardId : 0));
                        }
                        OnlineSub.GameInterface.AddEndOnlineGameCompleteDelegate(OnEndForInviteComplete);
                        OnlineSub.GameInterface.EndOnlineGame('Game');                        
                    }
                    else
                    {
                        OnlineSub.GameInterface.AddJoinOnlineGameCompleteDelegate(OnInviteJoinComplete);
                        if(!OnlineSub.GameInterface.AcceptGameInvite(byte(LocalPlayer(Player).ControllerId), 'Game', CachedInviteResult))
                        {
                            OnlineSub.GameInterface.ClearJoinOnlineGameCompleteDelegate(OnInviteJoinComplete);
                            NotifyInviteFailed();
                        }
                    }                    
                }
                else
                {
                    NotifyNotAllPlayersCanJoinInvite();
                }                
            }
            else
            {
                NotifyNotEnoughSpaceInInvite();
            }            
        }
        else
        {
            NotifyInviteFailed();
        }
    }
}

function bool InviteHasEnoughSpace(OnlineGameSettings InviteSettings)
{
    local int NumLocalPlayers;
    local PlayerController PC;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        ++ NumLocalPlayers;        
    }    
    return (InviteSettings.NumOpenPrivateConnections + InviteSettings.NumOpenPublicConnections) >= NumLocalPlayers;
}

function bool CanAllPlayersPlayOnline()
{
    local PlayerController PC;
    local LocalPlayer LocPlayer;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        LocPlayer = LocalPlayer(PC.Player);
        if(LocPlayer != none)
        {
            if((OnlineSub.PlayerInterface.GetLoginStatus(byte(LocPlayer.ControllerId)) != 2) || OnlineSub.PlayerInterface.CanPlayOnline(byte(LocPlayer.ControllerId)) == 0)
            {                
                return false;
            }
            continue;
        }        
        return false;        
    }    
    return true;
}

function ClearInviteDelegates()
{
    OnlineSub.GameInterface.ClearEndOnlineGameCompleteDelegate(OnEndForInviteComplete);
    OnlineSub.GameInterface.ClearDestroyOnlineGameCompleteDelegate(OnDestroyForInviteComplete);
    OnlineSub.GameInterface.ClearJoinOnlineGameCompleteDelegate(OnInviteJoinComplete);
}

function OnEndForInviteComplete(name SessionName, bool bWasSuccessful)
{
    OnlineSub.GameInterface.AddDestroyOnlineGameCompleteDelegate(OnDestroyForInviteComplete);
    OnlineSub.GameInterface.DestroyOnlineGame(SessionName);
}

function OnDestroyForInviteComplete(name SessionName, bool bWasSuccessful)
{
    LogInternal((("SESSIONS - Destroy for invite complete for session name" @ string(SessionName)) @ "and successful") @ string(bWasSuccessful));
    if(bWasSuccessful)
    {
        OnlineSub.GameInterface.AddJoinOnlineGameCompleteDelegate(OnInviteJoinComplete);
        if(!OnlineSub.GameInterface.AcceptGameInvite(byte(LocalPlayer(Player).ControllerId), SessionName, CachedInviteResult))
        {
            OnlineSub.GameInterface.ClearJoinOnlineGameCompleteDelegate(OnInviteJoinComplete);
            NotifyInviteFailed();
        }        
    }
    else
    {
        NotifyInviteFailed();
    }
}

function string ModifyClientURL(string URL)
{
    return URL;
}

function OnInviteJoinComplete(name SessionName, bool bWasSuccessful)
{
    local string URL;

    if(bWasSuccessful)
    {
        if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
        {
            if(OnlineSub.GameInterface.GetResolvedConnectString(SessionName, URL))
            {                
                URL $= "?bIsFromInvite";
                URL = ModifyClientURL(URL);
                LogInternal(("Resulting url is (" $ URL) $ ")");
                ClientTravel(URL, 0);
            }
        }        
    }
    else
    {
        NotifyInviteFailed();
    }
    ClearInviteDelegates();
}

function NotifyInviteFailed()
{
    LogInternal("SESSIONS - Invite handling failed");
    ClearInviteDelegates();
}

function NotifyNotAllPlayersCanJoinInvite()
{
    LogInternal("Not all local players have permission to join the game invite");
}

function NotifyNotEnoughSpaceInInvite()
{
    LogInternal("Not enough space for all local players in the game invite");
}

reliable client simulated function ClientArbitratedMatchEnded()
{
    ConsoleCommand("Disconnect");
}

reliable client simulated function ClientWriteOnlinePlayerScores(int LeaderboardId)
{
    local GameReplicationInfo GRI;
    local int Index;
    local array<OnlinePlayerScore> PlayerScores;
    local UniqueNetId ZeroUniqueId;
    local bool bIsTeamGame;
    local int ScoreIndex;

    GRI = WorldInfo.GRI;
    if(((GRI != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none)))
    {
        bIsTeamGame = ((GRI.GameClass != none) ? GRI.GameClass.default.bTeamGame : false);
        Index = 0;
        J0xF0:

        if(Index < GRI.PRIArray.Length)
        {
            if(GRI.PRIArray[Index].UniqueId != ZeroUniqueId)
            {
                if(bIsTeamGame)
                {
                    if(GRI.PRIArray[Index].Team != none)
                    {
                        ScoreIndex = PlayerScores.Length;
                        PlayerScores.Length = ScoreIndex + 1;
                        PlayerScores[ScoreIndex].PlayerID = GRI.PRIArray[Index].UniqueId;
                        PlayerScores[ScoreIndex].TeamID = GRI.PRIArray[Index].Team.TeamIndex;
                        PlayerScores[ScoreIndex].Score = int(GRI.PRIArray[Index].Team.Score);
                    }                    
                }
                else
                {
                    ScoreIndex = PlayerScores.Length;
                    PlayerScores.Length = ScoreIndex + 1;
                    PlayerScores[ScoreIndex].PlayerID = GRI.PRIArray[Index].UniqueId;
                    PlayerScores[ScoreIndex].TeamID = Index;
                    PlayerScores[ScoreIndex].Score = int(GRI.PRIArray[Index].Score);
                }
            }
            ++ Index;
            goto J0xF0;
        }
        OnlineSub.StatsInterface.WriteOnlinePlayerScores(PlayerReplicationInfo.SessionName, LeaderboardId, PlayerScores);
    }
}

reliable client simulated function ClientWriteLeaderboardStats(class<OnlineStatsWrite> OnlineStatsWriteClass, optional bool bIsIncomplete)
{
    bIsIncomplete = false;
}

reliable client simulated function ClientSetHostUniqueId(UniqueNetId InHostId);

reliable client simulated function ClientStopNetworkedVoice()
{
    local LocalPlayer LocPlayer;

    LocPlayer = LocalPlayer(Player);
    if(((LocPlayer != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.VoiceInterface, (none)))
    {
        OnlineSub.VoiceInterface.StopNetworkedVoice(byte(LocPlayer.ControllerId));
    }
}

reliable client simulated function ClientStartNetworkedVoice()
{
    local LocalPlayer LocPlayer;

    LocPlayer = LocalPlayer(Player);
    if(((LocPlayer != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.VoiceInterface, (none)))
    {
        OnlineSub.VoiceInterface.StartNetworkedVoice(byte(LocPlayer.ControllerId));
    }
}

simulated function OnDestroy(SeqAct_Destroy Action)
{
    Action.ScriptLog("Cannot use Destroy action on players");
}

final simulated function DrawDebugTextList(Canvas Canvas, float RenderDelta)
{
    local Vector CameraLoc, ScreenLoc, Offset, WorldTextLoc;
    local Rotator CameraRot;
    local int Idx;

    if(DebugTextList.Length > 0)
    {
        GetPlayerViewPoint(CameraLoc, CameraRot);
        Canvas.SetDrawColor(255, 255, 255);
        Idx = 0;
        J0x5D:

        if(Idx < DebugTextList.Length)
        {
            if(DebugTextList[Idx].SrcActor == none)
            {
                DebugTextList.Remove(-- Idx, 1;                
            }
            else
            {
                if(DebugTextList[Idx].TimeRemaining != -1)
                {
                    DebugTextList[Idx].TimeRemaining -= RenderDelta;
                    if(DebugTextList[Idx].TimeRemaining <= 0)
                    {
                        DebugTextList.Remove(-- Idx, 1;
                        goto J0x5C2;
                    }
                }
                if(DebugTextList[Idx].Font != none)
                {
                    Canvas.Font = DebugTextList[Idx].Font;                    
                }
                else
                {
                    Canvas.Font = Class'Engine'.static.GetSmallFont();
                }
                if(DebugTextList[Idx].bAbsoluteLocation)
                {
                    WorldTextLoc = VLerp(DebugTextList[Idx].SrcActorOffset, DebugTextList[Idx].SrcActorDesiredOffset, 1 - (DebugTextList[Idx].TimeRemaining / DebugTextList[Idx].Duration));                    
                }
                else
                {
                    Offset = VLerp(DebugTextList[Idx].SrcActorOffset, DebugTextList[Idx].SrcActorDesiredOffset, 1 - (DebugTextList[Idx].TimeRemaining / DebugTextList[Idx].Duration));
                    if(DebugTextList[Idx].bKeepAttachedToActor)
                    {
                        WorldTextLoc = DebugTextList[Idx].SrcActor.Location + (Offset >> CameraRot);                        
                    }
                    else
                    {
                        WorldTextLoc = DebugTextList[Idx].OrigActorLocation + (Offset >> CameraRot);
                    }
                }
                if(((WorldTextLoc - CameraLoc) Dot vector(CameraRot)) > 0)
                {
                    ScreenLoc = Canvas.Project(WorldTextLoc);
                    Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y);
                    Canvas.DrawColor = DebugTextList[Idx].TextColor;
                    Canvas.DrawText(DebugTextList[Idx].DebugText);
                }
            }
            J0x5C2:

            ++ Idx;
            goto J0x5D;
        }
    }
}

reliable client simulated event AddDebugText(string DebugText, optional Actor SrcActor, optional float Duration, optional Vector Offset, optional Vector DesiredOffset, optional Color TextColor, optional bool bSkipOverwriteCheck, optional bool bAbsoluteLocation, optional bool bKeepAttachedToActor, optional Font InFont)
{
    local int Idx;

    Duration = -1;                    
    bKeepAttachedToActor = true;    
    if((((TextColor.R == 0) && TextColor.G == 0) && TextColor.B == 0) && TextColor.A == 0)
    {
        TextColor.R = 255;
        TextColor.G = 255;
        TextColor.B = 255;
        TextColor.A = 255;
    }
    if(SrcActor != none)
    {
        if(Len(DebugText) == 0)
        {
            RemoveDebugText(SrcActor);            
        }
        else
        {
            if(!bSkipOverwriteCheck)
            {
                Idx = DebugTextList.Find('SrcActor', SrcActor;
                if(Idx == -1)
                {
                    Idx = DebugTextList.Length;
                    DebugTextList.Length = Idx + 1;
                }                
            }
            else
            {
                Idx = DebugTextList.Length;
                DebugTextList.Length = Idx + 1;
            }
            DebugTextList[Idx].SrcActor = SrcActor;
            DebugTextList[Idx].SrcActorOffset = Offset;
            DebugTextList[Idx].SrcActorDesiredOffset = DesiredOffset;
            DebugTextList[Idx].DebugText = DebugText;
            DebugTextList[Idx].TimeRemaining = Duration;
            DebugTextList[Idx].Duration = Duration;
            DebugTextList[Idx].TextColor = TextColor;
            DebugTextList[Idx].bAbsoluteLocation = bAbsoluteLocation;
            DebugTextList[Idx].bKeepAttachedToActor = bKeepAttachedToActor;
            DebugTextList[Idx].OrigActorLocation = SrcActor.Location;
            DebugTextList[Idx].Font = InFont;
        }
    }
}

reliable client final simulated event RemoveDebugText(Actor SrcActor)
{
    local int Idx;

    Idx = DebugTextList.Find('SrcActor', SrcActor;
    if(Idx != -1)
    {
        DebugTextList.Remove(Idx, 1;
    }
}

reliable client final simulated event RemoveAllDebugStrings()
{
    DebugTextList.Length = 0;
}

reliable client simulated function ClientRegisterHostStatGuid(string StatGuid)
{
    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none)))
    {
        OnlineSub.StatsInterface.AddRegisterHostStatGuidCompleteDelegate(OnRegisterHostStatGuidComplete);
        if(OnlineSub.StatsInterface.RegisterHostStatGuid(StatGuid) == false)
        {
            OnRegisterHostStatGuidComplete(false);
        }
    }
}

function OnRegisterHostStatGuidComplete(bool bWasSuccessful)
{
    local string StatGuid;

    OnlineSub.StatsInterface.ClearRegisterHostStatGuidCompleteDelegateDelegate(OnRegisterHostStatGuidComplete);
    if(bWasSuccessful)
    {
        StatGuid = OnlineSub.StatsInterface.GetClientStatGuid();
        ServerRegisterClientStatGuid(StatGuid);
    }
}

reliable server function ServerRegisterClientStatGuid(string StatGuid)
{
    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none)))
    {
        OnlineSub.StatsInterface.RegisterStatGuid(PlayerReplicationInfo.UniqueId, StatGuid);
    }
}

reliable client simulated function ClientStartOnlineGame()
{
    local OnlineGameSettings GameSettings;

    if(((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && IsPrimaryPlayer())
    {
        GameSettings = OnlineSub.GameInterface.GetGameSettings(PlayerReplicationInfo.SessionName);
        if((GameSettings != none) && (GameSettings.GameState == 1) || GameSettings.GameState == 5)
        {
            OnlineSub.GameInterface.StartOnlineGame(PlayerReplicationInfo.SessionName);
        }
    }
}

reliable client simulated function ClientEndOnlineGame()
{
    local OnlineGameSettings GameSettings;

    if(((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && IsPrimaryPlayer())
    {
        GameSettings = OnlineSub.GameInterface.GetGameSettings(PlayerReplicationInfo.SessionName);
        if((GameSettings != none) && GameSettings.GameState == 3)
        {
            OnlineSub.GameInterface.EndOnlineGame(PlayerReplicationInfo.SessionName);
        }
    }
}

function bool CanViewUserCreatedContent()
{
    local LocalPlayer LocPlayer;

    LocPlayer = LocalPlayer(Player);
    if(((LocPlayer != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
    {
        return OnlineSub.PlayerInterface.CanDownloadUserContent(byte(LocPlayer.ControllerId)) == 2;
    }
    return true;
}

function IncrementNumberOfMatchesPlayed()
{
    LogInternal("  Num Matches Played: " $ string(PlayerReplicationInfo.AutomatedTestingData.NumberOfMatchesPlayed));
    ++ PlayerReplicationInfo.AutomatedTestingData.NumberOfMatchesPlayed;
}

event SoakPause(Pawn P)
{
    LogInternal("Soak pause by " $ string(P));
    SetViewTarget(P);
    SetPause(true);
    myHUD.bShowDebugInfo = true;
}

exec function PathStep(optional int Cnt)
{
    Pawn.IncrementPathStep(Max(1, Cnt), myHUD.Canvas);
}

exec function PathChild(optional int Cnt)
{
    Pawn.IncrementPathChild(Max(1, Cnt), myHUD.Canvas);
}

exec function PathClear()
{
    Pawn.ClearPathStep();
}

reliable client simulated function ClientTravelToSession(name SessionName, class<OnlineGameSearch> SearchClass, byte PlatformSpecificInfo[80])
{
    local OnlineGameSearch Search;
    local LocalPlayer LP;
    local OnlineGameSearchResult SessionToJoin;

    LP = LocalPlayer(Player);
    if(LP != none)
    {
        Search = new SearchClass;
        if(OnlineSub.GameInterface.BindPlatformSpecificSessionToSearch(byte(LP.ControllerId), Search, PlatformSpecificInfo))
        {
            SessionToJoin = Search.Results[0];
            LogInternal(((((((("(PlayerController.ClientTravelToSession): " $ " SessionName=") $ string(SessionName)) $ " SearchClass=") $ string(SearchClass)) $ " UniqueId=") $ OnlineSub.UniqueNetIdToString(PlayerReplicationInfo.UniqueId)) $ " Session.OwnerId=") $ OnlineSub.UniqueNetIdToString(SessionToJoin.GameSettings.OwningPlayerId));
            PreJoinUpdateGameSettings(SessionName, SessionToJoin.GameSettings);
            OnlineSub.GameInterface.AddJoinOnlineGameCompleteDelegate(OnJoinTravelToSessionComplete);
            OnlineSub.GameInterface.JoinOnlineGame(byte(LP.ControllerId), SessionName, SessionToJoin);
        }
    }
}

simulated function PreJoinUpdateGameSettings(name SessionName, OnlineGameSettings GameSettings);

function OnJoinTravelToSessionComplete(name SessionName, bool bWasSuccessful)
{
    local string URL;

    if(bWasSuccessful)
    {
        if(OnlineSub.GameInterface.GetResolvedConnectString(SessionName, URL))
        {
            LogInternal(("Resulting url for 'Game' is (" $ URL) $ ")");
            ClientTravel(URL, 0);
        }
    }
}

reliable client simulated function ClientReturnToParty(UniqueNetId RequestingPlayerId)
{
    local string URL;

    WorldInfo.ToggleHostMigration(false);
    if(IsPrimaryPlayer())
    {
        if(((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
        {
            if(OnlineSub.GameInterface.GetGameSettings('Party') != none)
            {
                if(IsPartyLeader())
                {
                    URL = (((GetPartyMapName()) $ "?game=") $ (GetPartyGameTypeName())) $ "?listen";
                    WorldInfo.ServerTravel(URL, true, true);                    
                }
                else
                {
                    if(OnlineSub.GameInterface.GetResolvedConnectString('Party', URL))
                    {
                        ClientTravel(URL, 0);
                    }
                }                
            }
            else
            {                
                ConsoleCommand("disconnect");
            }            
        }
        else
        {            
            ConsoleCommand("disconnect");
        }
    }
}

reliable client simulated function ClientNotifyPartyHostLeaving(UniqueNetId PartyHostPlayerId)
{
    if((PlayerReplicationInfo != none) && PlayerReplicationInfo.UniqueId != PartyHostPlayerId)
    {
        LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Party host is leaving: ") $ " PartyHostPlayerId=") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PartyHostPlayerId));
    }
}

reliable server function ServerNotifyPartyHostLeaving(UniqueNetId PartyHostPlayerId)
{
    if(WorldInfo.Game != none)
    {
        WorldInfo.Game.TellClientsPartyHostIsLeaving(PartyHostPlayerId);
    }
}

final simulated function bool IsPrimaryPlayer()
{
    local int SSIndex;

    return !IsSplitscreenPlayer(SSIndex) || SSIndex == 0;
}

final simulated function bool IsSplitscreenPlayer(optional out int out_SplitscreenPlayerIndex)
{
    local bool bResult;
    local LocalPlayer LP;
    local NetConnection RemoteConnection;
    local ChildConnection ChildRemoteConnection;

    out_SplitscreenPlayerIndex = NetPlayerIndex;
    if(Player != none)
    {
        LP = LocalPlayer(Player);
        if(LP != none)
        {
            if(LP.Outer.GamePlayers.Length > 1)
            {
                out_SplitscreenPlayerIndex = LP.Outer.GamePlayers.Find(LP;
                bResult = true;
            }            
        }
        else
        {
            RemoteConnection = NetConnection(Player);
            if(RemoteConnection.Children.Length > 0)
            {
                out_SplitscreenPlayerIndex = 0;
                bResult = true;                
            }
            else
            {
                ChildRemoteConnection = ChildConnection(RemoteConnection);
                if(ChildRemoteConnection != none)
                {
                    if(ChildRemoteConnection.Parent != none)
                    {
                        out_SplitscreenPlayerIndex = ChildRemoteConnection.Parent.Children.Find(ChildRemoteConnection + 1;
                    }
                    bResult = true;
                }
            }
        }
    }
    return bResult;
}

simulated function PlayerReplicationInfo GetSplitscreenPlayerByIndex(optional int PlayerIndex)
{
    local PlayerReplicationInfo Result;
    local LocalPlayer LP, SplitPlayer;
    local NetConnection MasterConnection, RemoteConnection;
    local ChildConnection ChildRemoteConnection;

    PlayerIndex = 1;
    if(Player != none)
    {
        if(IsSplitscreenPlayer())
        {
            LP = LocalPlayer(Player);
            RemoteConnection = NetConnection(Player);
            if(LP != none)
            {
                if((PlayerIndex >= 0) && PlayerIndex < LP.ViewportClient.Outer.GamePlayers.Length)
                {
                    SplitPlayer = LP.ViewportClient.Outer.GamePlayers[PlayerIndex];
                    Result = SplitPlayer.Actor.PlayerReplicationInfo;                    
                }
                else
                {
                    WarnInternal((((((((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ":") @ "requested player at invalid index!") @ "PlayerIndex:'") $ string(PlayerIndex)) $ "'") @ "NumLocalPlayers:'") $ string(LP.ViewportClient.Outer.GamePlayers.Length)) $ "'");
                }                
            }
            else
            {
                if(RemoteConnection != none)
                {
                    if(WorldInfo.NetMode == NM_Client)
                    {
                        WarnInternal((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ":") @ "CALLED ON CLIENT WITH VALID REMOTE NETCONNECTION!");                        
                    }
                    else
                    {
                        ChildRemoteConnection = ChildConnection(RemoteConnection);
                        if(ChildRemoteConnection != none)
                        {
                            MasterConnection = ChildRemoteConnection.Parent;
                            if(PlayerIndex == 0)
                            {
                                Result = MasterConnection.Actor.PlayerReplicationInfo;                                
                            }
                            else
                            {
                                -- PlayerIndex;
                                if((PlayerIndex >= 0) && PlayerIndex < MasterConnection.Children.Length)
                                {
                                    ChildRemoteConnection = MasterConnection.Children[PlayerIndex];
                                    Result = ChildRemoteConnection.Actor.PlayerReplicationInfo;
                                }
                            }                            
                        }
                        else
                        {
                            if(RemoteConnection.Children.Length > 0)
                            {
                                if(PlayerIndex == 0)
                                {
                                    Result = PlayerReplicationInfo;                                    
                                }
                                else
                                {
                                    -- PlayerIndex;
                                    if((PlayerIndex >= 0) && PlayerIndex < RemoteConnection.Children.Length)
                                    {
                                        ChildRemoteConnection = RemoteConnection.Children[PlayerIndex];
                                        Result = ChildRemoteConnection.Actor.PlayerReplicationInfo;
                                    }
                                }                                
                            }
                            else
                            {
                                LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ":") @ string(Player)) @ "IS NOT THE PRIMARY CONNECTION AND HAS NO CHILD CONNECTIONS!");
                            }
                        }
                    }                    
                }
                else
                {
                    LogInternal(((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ":") @ string(Player)) @ "IS NOT A LOCALPLAYER AND NOT A REMOTECONNECTION! (No valid Player reference)");
                }
            }
        }        
    }
    else
    {
        LogInternal((((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ ":") @ "NULL value for Player!");
    }
    return Result;
}

simulated function int GetSplitscreenPlayerCount()
{
    local LocalPlayer LP;
    local NetConnection RemoteConnection;
    local int Result;

    if(IsSplitscreenPlayer())
    {
        if(Player != none)
        {
            LP = LocalPlayer(Player);
            RemoteConnection = NetConnection(Player);
            if(LP != none)
            {
                Result = LP.ViewportClient.Outer.GamePlayers.Length;                
            }
            else
            {
                if(RemoteConnection != none)
                {
                    if(ChildConnection(RemoteConnection) != none)
                    {
                        RemoteConnection = ChildConnection(RemoteConnection).Parent;
                    }
                    Result = RemoteConnection.Children.Length + 1;                    
                }
                else
                {
                    LogInternal(((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "NOT A LOCALPLAYER AND NOT A REMOTECONNECTION!");
                }
            }            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") PlayerController::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "called without a valid Player value!");
        }
    }
    return Result;
}

reliable client simulated function ClientControlMovieTexture(TextureMovie MovieTexture, SeqAct_ControlMovieTexture.EMovieControlType Mode)
{
    if(MovieTexture != none)
    {
        switch(Mode)
        {
            case 0:
                MovieTexture.Play();
                break;
            case 1:
                MovieTexture.Stop();
                break;
            case 2:
                MovieTexture.Pause();
                break;
            default:
                break;
                break;
        }
    }
}

reliable client simulated event ClientSetForceMipLevelsToBeResident(MaterialInterface Material, float ForceDuration, optional int CinematicTextureGroups)
{
    if((Material != none) && IsPrimaryPlayer())
    {
        Material.SetForceMipLevelsToBeResident(false, false, ForceDuration, CinematicTextureGroups);
    }
}

reliable client simulated event ClientPrestreamTextures(Actor ForcedActor, float ForceDuration, bool bEnableStreaming, optional int CinematicTextureGroups)
{
    CinematicTextureGroups = 0;
    if((ForcedActor != none) && IsPrimaryPlayer())
    {
        ForcedActor.PrestreamTextures(ForceDuration, bEnableStreaming, CinematicTextureGroups);
    }
}

// Export UPlayerController::execClientAddTextureStreamingLoc(FFrame&, void* const)
reliable client native final simulated event ClientAddTextureStreamingLoc(Vector InLoc, float Duration, bool bOverrideLocation);

simulated function bool IsPartyLeader()
{
    local OnlineGameSettings PartySettings;

    if((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        PartySettings = OnlineSub.GameInterface.GetGameSettings('Party');
        if(PartySettings != none)
        {
            if(PlayerReplicationInfo != none)
            {
                return PartySettings.OwningPlayerId == PlayerReplicationInfo.UniqueId;
            }
        }
    }
    return (WorldInfo.NetMode != NM_Client) && IsPrimaryPlayer();
}

static function string GetPartyMapName();

static function string GetPartyGameTypeName();

event bool GetAchievementProgression(int AchievementId, out float CurrentValue, out float MaxValue);

simulated function OnFlyThroughHasEnded(SeqAct_FlyThroughHasEnded inAction)
{
    local PlayerController PC;

    if(WorldInfo.Game.IsDoingASentinelRun())
    {
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {            
            PC.ConsoleCommand("quit");            
        }        
    }
}

function Sentinel_SetupForGamebasedTravelTheWorld();

function Sentinel_PreAcquireTravelTheWorldPoints();

function Sentinel_PostAcquireTravelTheWorldPoints();

delegate InputMatchDelegate();

protected simulated function DoForceFeedbackForScreenShake(CameraShake ShakeData, float ShakeScale);

unreliable client simulated function ClientPlayCameraShake(CameraShake Shake, optional float Scale, optional bool bTryForceFeedback, optional Camera.ECameraAnimPlaySpace PlaySpace, optional Rotator UserPlaySpaceRot)
{
    Scale = 1;    
    PlaySpace = 0;    
    if(PlayerCamera != none)
    {
        PlayerCamera.PlayCameraShake(Shake, Scale, PlaySpace, UserPlaySpaceRot);
        if(bTryForceFeedback)
        {
            DoForceFeedbackForScreenShake(Shake, Scale);
        }
    }
}

unreliable client simulated function ClientStopCameraShake(CameraShake Shake)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.StopCameraShake(Shake);
    }
}

function OnCameraShake(SeqAct_CameraShake inAction)
{
    if(inAction.InputLinks[0].bHasImpulse)
    {
        if(inAction.bRadialShake)
        {
            if(inAction.LocationActor != none)
            {
                Class'Camera'.static.PlayWorldCameraShake(inAction.Shake, inAction.LocationActor, inAction.LocationActor.Location, inAction.RadialShake_InnerRadius, inAction.RadialShake_OuterRadius, inAction.RadialShake_Falloff, inAction.bDoControllerVibration, inAction.bOrientTowardRadialEpicenter);                
            }
            else
            {
                WarnInternal(string(self) @ "Location actor needed for bRadialFalloff camera shake.");
                return;
            }            
        }
        else
        {
            ClientPlayCameraShake(inAction.Shake, inAction.ShakeScale, inAction.bDoControllerVibration, inAction.PlaySpace, ((inAction.LocationActor == none) ? rot(0, 0, 0) : inAction.LocationActor.Rotation));
        }        
    }
    else
    {
        ClientStopCameraShake(inAction.Shake);
    }
}

unreliable client simulated event ClientPlayCameraAnim(CameraAnim AnimToPlay, optional float Scale, optional float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLoop, optional bool bRandomStartTime, optional Camera.ECameraAnimPlaySpace Space, optional Rotator CustomPlaySpace)
{
    local CameraAnimInst AnimInst;

    Scale = 1;
    Rate = 1;                
    Space = 0;    
    if(PlayerCamera != none)
    {
        AnimInst = PlayerCamera.PlayCameraAnim(AnimToPlay, Rate, Scale, BlendInTime, BlendOutTime, bLoop, bRandomStartTime);
        if((AnimInst != none) && Space != 0)
        {
            AnimInst.SetPlaySpace(Space, CustomPlaySpace);
        }
    }
}

reliable client simulated event ClientStopCameraAnim(CameraAnim AnimToStop, optional bool bImmediate)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.StopAllCameraAnimsByType(AnimToStop, bImmediate);
    }
}

exec function DebugCameraAnims()
{
    bDebugCameraAnims = !bDebugCameraAnims;
    if(bDebugCameraAnims == false)
    {
        WorldInfo.FlushPersistentDebugLines();
    }
}

unreliable client simulated event ClientSpawnCameraLensEffect(class<EmitterCameraLensEffectBase> LensEffectEmitterClass)
{
    if(PlayerCamera != none)
    {
        PlayerCamera.AddCameraLensEffect(LensEffectEmitterClass);
    }
}

function OnSetSoundMode(SeqAct_SetSoundMode Action)
{
    local AudioDevice Audio;

    Audio = Class'Engine'.static.GetAudioDevice();
    if(Audio != none)
    {
        if(Action.InputLinks[0].bHasImpulse && Action.SoundMode != none)
        {
            Audio.SetSoundMode(Action.SoundMode.Name);            
        }
        else
        {
            Audio.SetSoundMode('Default');
        }
    }
}

// Export UPlayerController::execHasPeerConnection(FFrame&, void* const)
native function bool HasPeerConnection(const out UniqueNetId PeerNetId);

exec function BugItGo(coerce float X, coerce float Y, coerce float Z, coerce int Pitch, coerce int Yaw, coerce int Roll)
{
    local Vector TheLocation;
    local Rotator TheRotation;

    TheLocation.X = X;
    TheLocation.Y = Y;
    TheLocation.Z = Z;
    TheRotation.Pitch = Pitch;
    TheRotation.Yaw = Yaw;
    TheRotation.Roll = Roll;
    BugItWorker(TheLocation, TheRotation);
}

function BugItGoString(string TheLocation, string TheRotation)
{
    BugItWorker(vector(TheLocation), rotator(TheRotation));
}

function BugItWorker(Vector TheLocation, Rotator TheRotation)
{
    LogInternal(("BugItGo to:" @ string(TheLocation)) @ string(TheRotation));
    if(CheatManager != none)
    {
        CheatManager.Ghost();
    }
    ViewTarget.SetLocation(TheLocation);
    if(Pawn != none)
    {
        Pawn.FaceRotation(TheRotation, 0);
    }
    SetRotation(TheRotation);
}

exec event BugIt(optional string ScreenShotDescription)
{
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local string GoString, LocString;

    ConsoleCommand("bugscreenshot " $ ScreenShotDescription);
    GetPlayerViewPoint(ViewLocation, ViewRotation);
    if(Pawn != none)
    {
        ViewLocation = Pawn.Location;
    }
    BugItStringCreator(ViewLocation, ViewRotation, GoString, LocString);
    LogOutBugItGoToLogFile(ScreenShotDescription, GoString, LocString);
}

exec function LogLoc()
{
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local string GoString, LocString;

    GetPlayerViewPoint(ViewLocation, ViewRotation);
    if(Pawn != none)
    {
        ViewLocation = Pawn.Location;
    }
    BugItStringCreator(ViewLocation, ViewRotation, GoString, LocString);
}

exec event BugItAI(optional string ScreenShotDescription)
{
    local Vector ViewLocation;
    local Rotator ViewRotation;
    local string GoString, LocString;

    GetPlayerViewPoint(ViewLocation, ViewRotation);
    if(Pawn(ViewTarget) != none)
    {
        ViewLocation = ViewTarget.Location;        
    }
    else
    {
        if(Pawn != none)
        {
            ViewLocation = Pawn.Location;
        }
    }
    BugItStringCreator(ViewLocation, ViewRotation, GoString, LocString);    
    ConsoleCommand("debugai");
    SetTimer(0.1, false, 'DisableDebugAI');
    LogOutBugItAIGoToLogFile(ScreenShotDescription, GoString, LocString);
}

exec event BugItStringCreator(const out Vector ViewLocation, const out Rotator ViewRotation, out string GoString, out string LocString)
{
    GoString = (((((((((("BugItGo " $ string(ViewLocation.X)) $ " ") $ string(ViewLocation.Y)) $ " ") $ string(ViewLocation.Z)) $ " ") $ string(ViewRotation.Pitch)) $ " ") $ string(ViewRotation.Yaw)) $ " ") $ string(ViewRotation.Roll);
    LogInternal(GoString);
    LocString = (("?BugLoc=" $ string(ViewLocation)) $ "?BugRot=") $ string(ViewRotation);
    LogInternal(LocString);
}

event OnEngineInitialTick()
{
    if(WorldInfo.IsConsoleBuild(3))
    {        
        ConsoleCommand("mobile stoploading");
    }
}

function DebugLogPRIs()
{
    local int PlayerIndex;
    local UniqueNetId NetId;

    if((WorldInfo != none) && WorldInfo.GRI != none)
    {
        LogInternal("  Number of PRI players: " $ string(WorldInfo.GRI.PRIArray.Length));
        PlayerIndex = 0;
        J0x96:

        if(PlayerIndex < WorldInfo.GRI.PRIArray.Length)
        {
            NetId = WorldInfo.GRI.PRIArray[PlayerIndex].UniqueId;
            LogInternal(((((("    Player: " $ WorldInfo.GRI.PRIArray[PlayerIndex].PlayerName) $ " UID (") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(NetId)) $ ") PC (") $ string(WorldInfo.GRI.PRIArray[PlayerIndex].Owner)) $ ")");
            ++ PlayerIndex;
            goto J0x96;
        }
        LogInternal("");
    }
}

exec function DumpOnlineSessionState()
{
    if(CheatManager != none)
    {
        CheatManager.DumpOnlineSessionState();        
    }
    else
    {
        DebugLogPRIs();
        if(OnlineSub != none)
        {
            OnlineSub.DumpSessionState();
        }
    }
}

exec function DumpVoiceMutingState()
{
    local UniqueNetId NetId;
    local PlayerController PC;
    local int MuteIndex;

    LogInternal("");
    LogInternal("Voice state");
    LogInternal("-------------------------------------------------------------");
    LogInternal("");
    if(OnlineSub != none)
    {
        OnlineSub.DumpVoiceRegistration();
    }
    LogInternal("Muting state");
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        LogInternal("  Player: " $ PC.PlayerReplicationInfo.PlayerName);
        LogInternal("    Gameplay mutes: ");
        MuteIndex = 0;
        J0x137:

        if(MuteIndex < PC.GameplayVoiceMuteList.Length)
        {
            NetId = PC.GameplayVoiceMuteList[MuteIndex];
            LogInternal("      " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(NetId));
            ++ MuteIndex;
            goto J0x137;
        }
        LogInternal("    System mutes: ");
        MuteIndex = 0;
        J0x1FB:

        if(MuteIndex < PC.VoiceMuteList.Length)
        {
            NetId = PC.VoiceMuteList[MuteIndex];
            LogInternal("      " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(NetId));
            ++ MuteIndex;
            goto J0x1FB;
        }
        LogInternal("    Voice packet filter: ");
        MuteIndex = 0;
        J0x2C6:

        if(MuteIndex < PC.VoicePacketFilter.Length)
        {
            NetId = PC.VoicePacketFilter[MuteIndex];
            LogInternal("      " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(NetId));
            ++ MuteIndex;
            goto J0x2C6;
        }
        LogInternal("");        
    }    
}

exec function DumpPeers()
{
    local UniqueNetId NetId;
    local PlayerController PC;
    local int PeerIdx;
    local ConnectedPeerInfo PeerInfo;

    LogInternal("");
    LogInternal("Peer List");
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if((WorldInfo.NetMode == NM_Client) || !PC.IsLocalPlayerController())
        {
            LogInternal(((("  Player: " $ PC.PlayerReplicationInfo.PlayerName) $ "(") $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PC.PlayerReplicationInfo.UniqueId)) $ ")");
            LogInternal("    Peer connections: ");
            PeerIdx = 0;
            J0x15E:

            if(PeerIdx < PC.ConnectedPeers.Length)
            {
                PeerInfo = PC.ConnectedPeers[PeerIdx];
                LogInternal((("      " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(PeerInfo.PlayerID)) $ " HostLost=") $ string(PeerInfo.bLostConnectionToHost));
                ++ PeerIdx;
                goto J0x15E;
            }
            LogInternal("    Best Hosts:");
            PeerIdx = 0;
            J0x261:

            if(PeerIdx < PC.BestNextHostPeers.Length)
            {
                NetId = PC.BestNextHostPeers[PeerIdx];
                LogInternal("      " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(NetId));
                ++ PeerIdx;
                goto J0x261;
            }
            LogInternal("");
        }        
    }    
}

function DisableDebugAI()
{
    ConsoleCommand("debugai");
}

// Export UPlayerController::execLogOutBugItGoToLogFile(FFrame&, void* const)
private native final function LogOutBugItGoToLogFile(const string InScreenShotDesc, const string InGoString, const string InLocString);

// Export UPlayerController::execLogOutBugItAIGoToLogFile(FFrame&, void* const)
private native final function LogOutBugItAIGoToLogFile(const string InScreenShotDesc, const string InGoString, const string InLocString);

simulated function ReceivedGameClass(class<GameInfo> GameClass)
{
    if(PlayerInput != none)
    {
        PlayerInput.ClientInitInputSystem();
    }
}

event bool NotifyDisconnect(string Command)
{
    return false;
}

event SetMatineeConstantCameraAnim(bool bOn, byte Type, float Rate);

event SetUIScale(float fScale);

function NotifyUnsuccessfulSearch();

function OnLobbyStatusChanged(bool bInLobby);

unreliable client simulated event ClientReplicationDebug(Vector CamLocation, Vector DebugLocation, bool bClear, Color DebugColor);

state PlayerWalking
{
    ignores SeePlayer, HearNoise, Bump;

    event NotifyPhysicsVolumeChange(PhysicsVolume NewVolume)
    {
        if(NewVolume.bWaterVolume && Pawn.bCollideWorld)
        {
            GotoState(Pawn.WaterMovementState);
        }
    }

    function ProcessMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        if(Pawn == none)
        {
            return;
        }
        if(Role == ROLE_Authority)
        {
            Pawn.SetRemoteViewPitch(Rotation.Pitch);
        }
        Pawn.Acceleration = newAccel;
        CheckJumpOrDuck();
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z, newAccel;
        local Actor.EDoubleClickDir DoubleClickMove;
        local Rotator OldRotation;
        local bool bSaveJump;

        if(Pawn == none)
        {
            GotoState('Dead');            
        }
        else
        {
            GetAxes(Pawn.Rotation, X, Y, Z);
            newAccel = (PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y);
            newAccel.Z = 0;
            newAccel = Pawn.AccelRate * Normal(newAccel);
            if(IsLocalPlayerController())
            {
                AdjustPlayerWalkingMoveAccel(newAccel);
            }
            DoubleClickMove = PlayerInput.CheckForDoubleClickMove(DeltaTime / WorldInfo.TimeDilation);
            OldRotation = Rotation;
            UpdateRotation(DeltaTime);
            bDoubleJump = false;
            if(bPressedJump && Pawn.CannotJumpNow())
            {
                bSaveJump = true;
                bPressedJump = false;                
            }
            else
            {
                bSaveJump = false;
            }
            if(Role < ROLE_Authority)
            {
                ReplicateMove(DeltaTime, newAccel, DoubleClickMove, OldRotation - Rotation);                
            }
            else
            {
                ProcessMove(DeltaTime, newAccel, DoubleClickMove, OldRotation - Rotation);
            }
            bPressedJump = bSaveJump;
        }
    }

    event BeginState(name PreviousStateName)
    {
        DoubleClickDir = 0;
        bPressedJump = false;
        GroundPitch = 0;
        if(Pawn != none)
        {
            Pawn.ShouldCrouch(false);
            if((Pawn.Physics != 2) && Pawn.Physics != 10)
            {
                Pawn.SetPhysics(Pawn.WalkingPhysics);
            }
        }
    }

    event EndState(name NextStateName)
    {
        GroundPitch = 0;
        if(Pawn != none)
        {
            Pawn.SetRemoteViewPitch(0);
            if(bDuck == 0)
            {
                Pawn.ShouldCrouch(false);
            }
        }
    }
Begin:

    stop;                
}

state PlayerClimbing
{
    ignores SeePlayer, HearNoise, Bump;

    event NotifyPhysicsVolumeChange(PhysicsVolume NewVolume)
    {
        if(NewVolume.bWaterVolume)
        {
            GotoState(Pawn.WaterMovementState);            
        }
        else
        {
            GotoState(Pawn.LandMovementState);
        }
    }

    function ProcessMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        if(Pawn == none)
        {
            return;
        }
        if(Role == ROLE_Authority)
        {
            Pawn.SetRemoteViewPitch(Rotation.Pitch);
        }
        Pawn.Acceleration = newAccel;
        if(bPressedJump)
        {
            Pawn.DoJump(bUpdating);
            if(Pawn.Physics == 2)
            {
                GotoState(Pawn.LandMovementState);
            }
        }
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z, newAccel;
        local Rotator OldRotation, ViewRotation;

        GetAxes(Rotation, X, Y, Z);
        if(Pawn.OnLadder != none)
        {
            newAccel = PlayerInput.aForward * Pawn.OnLadder.ClimbDir;
            if(Pawn.OnLadder.bAllowLadderStrafing)
            {
                newAccel += (PlayerInput.aStrafe * Y);
            }            
        }
        else
        {
            newAccel = (PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y);
        }
        newAccel = Pawn.AccelRate * Normal(newAccel);
        ViewRotation = Rotation;
        SetRotation(ViewRotation);
        OldRotation = Rotation;
        UpdateRotation(DeltaTime);
        if(Role < ROLE_Authority)
        {
            ReplicateMove(DeltaTime, newAccel, 0, OldRotation - Rotation);            
        }
        else
        {
            ProcessMove(DeltaTime, newAccel, 0, OldRotation - Rotation);
        }
        bPressedJump = false;
    }

    event BeginState(name PreviousStateName)
    {
        Pawn.ShouldCrouch(false);
        bPressedJump = false;
    }

    event EndState(name NextStateName)
    {
        if(Pawn != none)
        {
            Pawn.SetRemoteViewPitch(0);
            Pawn.ShouldCrouch(false);
        }
    }
    stop;    
}

state PlayerDriving
{
    ignores SeePlayer, HearNoise, Bump, ProcessMove;

    function ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
    {
        local Vehicle CurrentVehicle;

        CurrentVehicle = Vehicle(Pawn);
        if(CurrentVehicle != none)
        {
            bPressedJump = InJump;
            CurrentVehicle.SetInputs(InForward, -InStrafe, InUp);
            CheckJumpOrDuck();
        }
    }

    function PlayerMove(float DeltaTime)
    {
        UpdateRotation(DeltaTime);
        ProcessDrive(PlayerInput.RawJoyUp, PlayerInput.RawJoyRight, PlayerInput.aUp, bPressedJump);
        if(Role < ROLE_Authority)
        {
            ServerDrive(PlayerInput.RawJoyUp, PlayerInput.RawJoyRight, PlayerInput.aUp, bPressedJump, ((Rotation.Yaw & 65535) << 16) + (Rotation.Pitch & 65535));
        }
        bPressedJump = false;
    }

    unreliable server function ServerUse()
    {
        local Vehicle CurrentVehicle;

        CurrentVehicle = Vehicle(Pawn);
        CurrentVehicle.DriverLeave(false);
    }

    event BeginState(name PreviousStateName)
    {
        CleanOutSavedMoves();
    }

    event EndState(name NextStateName)
    {
        CleanOutSavedMoves();
    }
    stop;    
}

state PlayerSwimming
{
    ignores SeePlayer, HearNoise, Bump;

    event bool NotifyLanded(Vector HitNormal, Actor FloorActor)
    {
        if(Pawn.PhysicsVolume.bWaterVolume)
        {
            Pawn.SetPhysics(3);            
        }
        else
        {
            GotoState(Pawn.LandMovementState);
        }
        return bUpdating;
    }

    event NotifyPhysicsVolumeChange(PhysicsVolume NewVolume)
    {
        local Actor HitActor;
        local Vector HitLocation, HitNormal, Checkpoint, X, Y, Z;

        if(!Pawn.bCollideActors)
        {
            GotoState(Pawn.LandMovementState);
        }
        if(Pawn.Physics != 10)
        {
            if(!NewVolume.bWaterVolume)
            {
                Pawn.SetPhysics(2);
                if(Pawn.Velocity.Z > float(0))
                {
                    GetAxes(Rotation, X, Y, Z);
                    Pawn.bUpAndOut = ((X Dot Pawn.Acceleration) > float(0)) && (Pawn.Acceleration.Z > float(0)) || Rotation.Pitch > 2048;
                    if(Pawn.bUpAndOut && Pawn.CheckWaterJump(HitNormal))
                    {
                        Pawn.Velocity.Z = Pawn.OutofWaterZ;
                        GotoState(Pawn.LandMovementState);                        
                    }
                    else
                    {
                        if((Pawn.Velocity.Z > float(160)) || !Pawn.TouchingWaterVolume())
                        {
                            GotoState(Pawn.LandMovementState);                            
                        }
                        else
                        {
                            Checkpoint = Pawn.Location;
                            Checkpoint.Z -= (Pawn.CylinderComponent.CollisionHeight + 6);
                            HitActor = Trace(HitLocation, HitNormal, Checkpoint, Pawn.Location, false);
                            if(HitActor != none)
                            {
                                GotoState(Pawn.LandMovementState);                                
                            }
                            else
                            {
                                SetTimer(0.7, false);
                            }
                        }
                    }
                }                
            }
            else
            {
                ClearTimer();
                Pawn.SetPhysics(3);
            }            
        }
        else
        {
            if(!NewVolume.bWaterVolume)
            {
                GotoState(Pawn.LandMovementState);
            }
        }
    }

    function ProcessMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        Pawn.Acceleration = newAccel;
    }

    function PlayerMove(float DeltaTime)
    {
        local Rotator OldRotation;
        local Vector X, Y, Z, newAccel;

        if(Pawn == none)
        {
            GotoState('Dead');            
        }
        else
        {
            GetAxes(Rotation, X, Y, Z);
            newAccel = ((PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y)) + (PlayerInput.aUp * vect(0, 0, 1));
            newAccel = Pawn.AccelRate * Normal(newAccel);
            OldRotation = Rotation;
            UpdateRotation(DeltaTime);
            if(Role < ROLE_Authority)
            {
                ReplicateMove(DeltaTime, newAccel, 0, OldRotation - Rotation);                
            }
            else
            {
                ProcessMove(DeltaTime, newAccel, 0, OldRotation - Rotation);
            }
            bPressedJump = false;
        }
    }

    event Timer()
    {
        if(!Pawn.PhysicsVolume.bWaterVolume && Role == ROLE_Authority)
        {
            GotoState(Pawn.LandMovementState);
        }
        ClearTimer();
    }

    event BeginState(name PreviousStateName)
    {
        ClearTimer();
        if(Pawn.Physics != 10)
        {
            Pawn.SetPhysics(3);
        }
    }
Begin:

    stop;                
}

state PlayerFlying
{
    ignores SeePlayer, HearNoise, Bump;

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z;

        GetAxes(Rotation, X, Y, Z);
        Pawn.Acceleration = ((PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y)) + (PlayerInput.aUp * vect(0, 0, 1));
        Pawn.Acceleration = Pawn.AccelRate * Normal(Pawn.Acceleration);
        if(bCheatFlying && Pawn.Acceleration == vect(0, 0, 0))
        {
            Pawn.Velocity = vect(0, 0, 0);
        }
        UpdateRotation(DeltaTime);
        if(Role < ROLE_Authority)
        {
            ReplicateMove(DeltaTime, Pawn.Acceleration, 0, rot(0, 0, 0));            
        }
        else
        {
            ProcessMove(DeltaTime, Pawn.Acceleration, 0, rot(0, 0, 0));
        }
    }

    event BeginState(name PreviousStateName)
    {
        Pawn.SetPhysics(4);
    }
    stop;    
}

state BaseSpectating
{
    function bool IsSpectating()
    {
        return true;
    }

    function bool LimitSpectatorVelocity()
    {
        if(Location.Z > WorldInfo.StallZ)
        {
            Velocity.Z = FMin(SpectatorCameraSpeed, (WorldInfo.StallZ - Location.Z) - 2);
            return true;            
        }
        else
        {
            if(Location.Z < WorldInfo.KillZ)
            {
                Velocity.Z = FMin(SpectatorCameraSpeed, (WorldInfo.KillZ - Location.Z) + 2);
                return true;
            }
        }
        return false;
    }

    function ProcessMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        local float VelSize;

        Acceleration = Normal(newAccel) * SpectatorCameraSpeed;
        VelSize = VSize(Velocity);
        if(VelSize > float(0))
        {
            Velocity = Velocity - ((Velocity - (Normal(Acceleration) * VelSize)) * FMin(DeltaTime * float(8), 1));
        }
        Velocity = Velocity + (Acceleration * DeltaTime);
        if(VSize(Velocity) > SpectatorCameraSpeed)
        {
            Velocity = Normal(Velocity) * SpectatorCameraSpeed;
        }
        LimitSpectatorVelocity();
        if(VSize(Velocity) > float(0))
        {
            MoveSmooth((float(1 + bRun) * Velocity) * DeltaTime);
            if(LimitSpectatorVelocity())
            {
                MoveSmooth((Velocity.Z * vect(0, 0, 1)) * DeltaTime);
            }
        }
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z;

        GetAxes(Rotation, X, Y, Z);
        Acceleration = ((PlayerInput.aForward * X) + (PlayerInput.aStrafe * Y)) + (PlayerInput.aUp * vect(0, 0, 1));
        UpdateRotation(DeltaTime);
        if(Role < ROLE_Authority)
        {
            ReplicateMove(DeltaTime, Acceleration, 0, rot(0, 0, 0));            
        }
        else
        {
            ProcessMove(DeltaTime, Acceleration, 0, rot(0, 0, 0));
        }
    }

    unreliable server function ServerSetSpectatorLocation(Vector NewLoc)
    {
        SetLocation(NewLoc);
        if((WorldInfo.TimeSeconds - LastSpectatorStateSynchTime) > 2)
        {
            ClientGotoState(GetStateName());
            LastSpectatorStateSynchTime = WorldInfo.TimeSeconds;
        }
    }

    function ReplicateMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        ProcessMove(DeltaTime, newAccel, DoubleClickMove, DeltaRot);
        ServerSetSpectatorLocation(Location);
        if((PlayerCamera != none) && PlayerCamera.bUseClientSideCameraUpdates)
        {
            PlayerCamera.bShouldSendClientSideCameraUpdate = true;
        }
    }

    event BeginState(name PreviousStateName)
    {
        bCollideWorld = true;
    }

    event EndState(name NextStateName)
    {
        bCollideWorld = false;
    }
    stop;    
}

state Spectating extends BaseSpectating
{
    ignores RestartLevel, Suicide, ThrowWeapon, NotifyPhysicsVolumeChange, NotifyHeadVolumeChange;

    exec function StartFire(optional byte FireModeNum)
    {
        ServerViewNextPlayer();
    }

    exec function StartAltFire(optional byte FireModeNum)
    {
        ResetCameraMode();
        ServerViewSelf();
    }

    event BeginState(name PreviousStateName)
    {
        if(Pawn != none)
        {
            SetLocation(Pawn.Location);
            UnPossess();
        }
        bCollideWorld = true;
    }

    event EndState(name NextStateName)
    {
        if(PlayerReplicationInfo != none)
        {
            if(PlayerReplicationInfo.bOnlySpectator)
            {
                LogInternal("WARNING - Spectator only player leaving spectating state to go to " $ string(NextStateName));
            }
            PlayerReplicationInfo.bIsSpectator = false;
        }
        bCollideWorld = false;
    }
    stop;    
}

auto state PlayerWaiting extends BaseSpectating
{
    ignores SeePlayer, HearNoise, NotifyBump, TakeDamage, PhysicsVolumeChange, NextWeapon, 
	    PrevWeapon, SwitchToBestWeapon, Jump, Suicide, ServerSuicide;

    reliable server function ServerChangeTeam(int N)
    {
        WorldInfo.Game.ChangeTeam(self, N, true);
    }

    reliable server function ServerRestartPlayer()
    {
        if(WorldInfo.TimeSeconds < WaitDelay)
        {
            return;
        }
        if(WorldInfo.NetMode == NM_Client)
        {
            return;
        }
        if(WorldInfo.Game.bWaitingToStartMatch)
        {
            PlayerReplicationInfo.bReadyToPlay = true;            
        }
        else
        {
            WorldInfo.Game.RestartPlayer(self);
        }
    }

    exec function StartFire(optional byte FireModeNum)
    {
        ServerRestartPlayer();
    }

    event EndState(name NextStateName)
    {
        if(PlayerReplicationInfo != none)
        {
            PlayerReplicationInfo.SetWaitingPlayer(false);
        }
        bCollideWorld = false;
    }

    simulated event BeginState(name PreviousStateName)
    {
        if(PlayerReplicationInfo != none)
        {
            PlayerReplicationInfo.SetWaitingPlayer(true);
        }
        bCollideWorld = true;
    }
    stop;    
}

state WaitingForPawn extends BaseSpectating
{
    ignores SeePlayer, HearNoise, KilledBy;

    exec function StartFire(optional byte FireModeNum)
    {
        AskForPawn();
    }

    reliable client simulated function ClientGotoState(name NewState, optional name NewLabel)
    {
        if(NewState == 'RoundEnded')
        {
            global.ClientGotoState(NewState, NewLabel);
        }
    }

    unreliable client simulated function LongClientAdjustPosition(float TimeStamp, name NewState, Actor.EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, Actor NewBase, float NewFloorX, float NewFloorY, float NewFloorZ)
    {
        if(NewState == 'RoundEnded')
        {
            GotoState(NewState);
        }
    }

    event PlayerTick(float DeltaTime)
    {
        global.PlayerTick(DeltaTime);
        if(Pawn != none)
        {
            Pawn.Controller = self;
            Pawn.BecomeViewTarget(self);
            ClientRestart(Pawn);            
        }
        else
        {
            if(!IsTimerActive() || GetTimerCount() > 1)
            {
                SetTimer(0.2, true);
                AskForPawn();
            }
        }
    }

    function ReplicateMove(float DeltaTime, Vector newAccel, Actor.EDoubleClickDir DoubleClickMove, Rotator DeltaRot)
    {
        ProcessMove(DeltaTime, newAccel, DoubleClickMove, DeltaRot);
    }

    event Timer()
    {
        AskForPawn();
    }

    event BeginState(name PreviousStateName)
    {
        SetTimer(0.2, true);
        AskForPawn();
    }

    event EndState(name NextStateName)
    {
        ResetCameraMode();
        SetTimer(0, false);
    }
    stop;    
}

state RoundEnded
{
    ignores SeePlayer, HearNoise, KilledBy, NotifyBump, HitWall, NotifyHeadVolumeChange, 
	    NotifyPhysicsVolumeChange, Falling, TakeDamage, Suicide, ServerRestartPlayer, 
	    ThrowWeapon, Use, LongClientAdjustPosition;

    function bool IsSpectating()
    {
        return true;
    }

    event Possess(Pawn aPawn, bool bVehicleTransition)
    {
        global.Possess(aPawn, bVehicleTransition);
        if(Pawn != none)
        {
            Pawn.TurnOff();
        }
    }

    reliable server function ServerRestartGame()
    {
        if(WorldInfo.Game.PlayerCanRestartGame(self))
        {
            WorldInfo.Game.ResetLevel();
        }
    }

    exec function StartFire(optional byte FireModeNum)
    {
        if(Role < ROLE_Authority)
        {
            return;
        }
        if(!bFrozen)
        {
            ServerRestartGame();            
        }
        else
        {
            if(!IsTimerActive())
            {
                SetTimer(1.5, false);
            }
        }
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z;
        local Rotator DeltaRot, ViewRotation;

        GetAxes(Rotation, X, Y, Z);
        ViewRotation = Rotation;
        DeltaRot.Yaw = int(PlayerInput.aTurn);
        DeltaRot.Pitch = int(PlayerInput.aLookUp);
        ProcessViewRotation(DeltaTime, ViewRotation, DeltaRot);
        SetRotation(ViewRotation);
        ViewShake(DeltaTime);
        if(Role < ROLE_Authority)
        {
            ReplicateMove(DeltaTime, vect(0, 0, 0), 0, rot(0, 0, 0));            
        }
        else
        {
            ProcessMove(DeltaTime, vect(0, 0, 0), 0, rot(0, 0, 0));
        }
        bPressedJump = false;
    }

    unreliable server function ServerMove(float TimeStamp, Vector InAccel, Vector ClientLoc, byte NewFlags, byte ClientRoll, int View, optional int FreeAimRot)
    {
        global.ServerMove(TimeStamp, InAccel, ClientLoc, NewFlags, ClientRoll, ((Rotation.Yaw & 65535) << 16) + (Rotation.Pitch & 65535));
    }

    function FindGoodView()
    {
        local Rotator GoodRotation;

        GoodRotation = Rotation;
        GetViewTarget().FindGoodEndView(self, GoodRotation);
        SetRotation(GoodRotation);
    }

    event Timer()
    {
        bFrozen = false;
    }

    event BeginState(name PreviousStateName)
    {
        local Pawn P;

        FOVAngle = DesiredFOV;
        bFire = 0;
        if(Pawn != none)
        {
            Pawn.TurnOff();
            StopFiring();
        }
        if(myHUD != none)
        {
            myHUD.SetShowScores(true);
        }
        bFrozen = true;
        FindGoodView();
        SetTimer(5, false);
        foreach DynamicActors(Class'Pawn', P)
        {
            P.TurnOff();            
        }        
    }

    event EndState(name NextStateName)
    {
        if(myHUD != none)
        {
            myHUD.SetShowScores(false);
        }
    }
Begin:

    stop;                
}

state Dead
{
    ignores SeePlayer, HearNoise, KilledBy, NextWeapon, PrevWeapon, ThrowWeapon;

    simulated event ReplicatedEvent(name VarName)
    {
        if(((VarName == 'Pawn') && Pawn != none) && Pawn != AcknowledgedPawn)
        {
            ClientRestart(Pawn);
        }
        global.ReplicatedEvent(VarName);
    }

    function bool IsDead()
    {
        return true;
    }

    reliable server function ServerRestartPlayer()
    {
        if(!WorldInfo.Game.PlayerCanRestart(self))
        {
            return;
        }
        super.ServerRestartPlayer();
    }

    exec function StartFire(optional byte FireModeNum)
    {
        if(bFrozen)
        {
            if(!IsTimerActive() || GetTimerCount() > MinRespawnDelay)
            {
                bFrozen = false;
            }
            return;
        }
        ServerRestartPlayer();
    }

    exec function Use()
    {
        StartFire(0);
    }

    exec function Jump()
    {
        StartFire(0);
    }

    unreliable server function ServerMove(float TimeStamp, Vector Accel, Vector ClientLoc, byte NewFlags, byte ClientRoll, int View, optional int FreeAimRot)
    {
        global.ServerMove(TimeStamp, Accel, ClientLoc, 0, ClientRoll, View);
    }

    function PlayerMove(float DeltaTime)
    {
        local Vector X, Y, Z;
        local Rotator DeltaRot, ViewRotation;

        if(!bFrozen)
        {
            if(bPressedJump)
            {
                StartFire(0);
                bPressedJump = false;
            }
            GetAxes(Rotation, X, Y, Z);
            ViewRotation = Rotation;
            DeltaRot.Yaw = int(PlayerInput.aTurn);
            DeltaRot.Pitch = int(PlayerInput.aLookUp);
            ProcessViewRotation(DeltaTime, ViewRotation, DeltaRot);
            SetRotation(ViewRotation);
            if(Role < ROLE_Authority)
            {
                ReplicateMove(DeltaTime, vect(0, 0, 0), 0, rot(0, 0, 0));
            }            
        }
        else
        {
            if(!IsTimerActive() || GetTimerCount() > MinRespawnDelay)
            {
                bFrozen = false;
            }
        }
        ViewShake(DeltaTime);
    }

    function FindGoodView()
    {
        local Vector CameraLoc;
        local Rotator CameraRot, ViewRotation;
        local int tries, besttry;
        local float bestDist, newdist;
        local int startYaw;
        local Actor TheViewTarget;

        ViewRotation = Rotation;
        ViewRotation.Pitch = 56000;
        tries = 0;
        besttry = 0;
        bestDist = 0;
        startYaw = ViewRotation.Yaw;
        TheViewTarget = GetViewTarget();
        tries = 0;
        J0x9F:

        if(tries < 16)
        {
            CameraLoc = TheViewTarget.Location;
            SetRotation(ViewRotation);
            GetPlayerViewPoint(CameraLoc, CameraRot);
            newdist = VSize(CameraLoc - TheViewTarget.Location);
            if(newdist > bestDist)
            {
                bestDist = newdist;
                besttry = tries;
            }
            ViewRotation.Yaw += 4096;
            ++ tries;
            goto J0x9F;
        }
        ViewRotation.Yaw = startYaw + (besttry * 4096);
        SetRotation(ViewRotation);
    }

    event Timer()
    {
        if(!bFrozen)
        {
            return;
        }
        bFrozen = false;
        bPressedJump = false;
    }

    event BeginState(name PreviousStateName)
    {
        if((Pawn != none) && Pawn.Controller == self)
        {
            Pawn.Controller = none;
        }
        Pawn = none;
        FOVAngle = DesiredFOV;
        Enemy = none;
        bFrozen = true;
        bPressedJump = false;
        FindGoodView();
        SetTimer(MinRespawnDelay, false);
        CleanOutSavedMoves();
    }

    event EndState(name NextStateName)
    {
        CleanOutSavedMoves();
        Velocity = vect(0, 0, 0);
        Acceleration = vect(0, 0, 0);
        if(!PlayerReplicationInfo.bOutOfLives)
        {
            ResetCameraMode();
        }
        bPressedJump = false;
        if(myHUD != none)
        {
            myHUD.SetShowScores(false);
        }
    }
Begin:

    if(LocalPlayer(Player) != none)
    {
        if(myHUD != none)
        {
            myHUD.PlayerOwnerDied();
        }
    }
    stop;        
}

defaultproperties
{
    CameraClass=Class'Camera'
    bInteractiveMode=true
    bShowKismetDrawText=true
    bIsUsingStreamingVolumes=true
    bCheckRelevancyThroughPortals=true
    MaxResponseTime=0.125
    FOVAngle=85
    DesiredFOV=85
    DefaultFOV=85
    LODDistanceFactor=1
    SavedMoveClass=Class'SavedMove'
    LastSpeedHackLog=-100
    CheatClass=Class'CheatManager'
    InputClass=Class'PlayerInput'
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__PlayerController.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    InteractDistance=512
    SpectatorCameraSpeed=600
    MinRespawnDelay=1
    MaxConcurrentHearSounds=32
    bIsPlayer=true
    bCanDoSpecial=true
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__PlayerController.CollisionCylinder'
    Components(0)=CollisionCylinder
    NetPriority=3
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__PlayerController.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}