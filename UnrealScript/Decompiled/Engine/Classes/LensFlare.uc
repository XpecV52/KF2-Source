/*******************************************************************************
 * LensFlare generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class LensFlare extends Object
    native(LensFlare)
    hidecategories(Object);

struct native transient LensFlareElementCurvePair
{
    var init string CurveName;
    var init Object CurveObject;

    structdefaultproperties
    {
        CurveName=""
        CurveObject=none
    }
};

struct native LensFlareElement
{
    /** The name of the element. (Optional) */
    var() name ElementName;
    /**  
     *The position along the ray from the source to the viewpoint to render the flare at.
     *               0.0 = At the source
     *               1.0 = The source point reflected about the view center.
     *               < 0 = The point along the ray going away from the center past the source.
     *               > 1 = The point along the ray beyond the 'end point' of the ray reflection.
     */
    var() float RayDistance;
    /** Whether the element is enabled or not */
    var() bool bIsEnabled;
    /**  
     *Whether the element value look ups should use the radial distance
     *               from the center to the edge of the screen or the ratio of the distance
     *               from the source element.
     */
    var() bool bUseSourceDistance;
    /**  
     *Whether the radial distance should be normalized to a unit value.
     *               Without this, the radial distance will be 0..1 in the horizontal and vertical cases.
     *               It will be 0..1.4 in the corners.
     */
    var() bool bNormalizeRadialDistance;
    /** Whether the element color value should be scaled by the source color. */
    var() bool bModulateColorBySource;
    /** The 'base' size of the element */
    var() Vector Size;
    /** The material(s) to use for the flare element. */
    var(Material) array<MaterialInterface> LFMaterials;
    /** Index of the material to use from the LFMaterial array. */
    var(Material) RawDistributionFloat LFMaterialIndex;
    /** Global scaling. */
    var(Scaling) RawDistributionFloat Scaling;
    /** Anamorphic scaling. */
    var(Scaling) RawDistributionVector AxisScaling;
    /** Rotation. */
    var(Rotation) RawDistributionFloat Rotation;
    /** If TRUE, always rotate the element to orient towards the source */
    var(Rotation) bool bOrientTowardsSource;
    /** Color (passed to the element material via the VertexColor expression) */
    var(Color) RawDistributionVector Color;
    /** Alpha (passed to the element material via the VertexColor expression) */
    var(Color) RawDistributionFloat Alpha;
    /** Offset. */
    var(Offset) RawDistributionVector Offset;
    /** Value to scale the AxisScaling by. Uses source to camera distance to look up the value (in Unreal units) */
    var(Scaling) RawDistributionVector DistMap_Scale;
    /** Value to scale the Color by. Uses source to camera distance to look up the value (in Unreal units) */
    var(Scaling) RawDistributionVector DistMap_Color;
    /** Value to scale the Alpha by. Uses source to camera distance to look up the value (in Unreal units) */
    var(Scaling) RawDistributionFloat DistMap_Alpha;

    structdefaultproperties
    {
        ElementName=None
        RayDistance=0
        bIsEnabled=false
        bUseSourceDistance=false
        bNormalizeRadialDistance=false
        bModulateColorBySource=false
        Size=(X=0,Y=0,Z=0)
        LFMaterials=none
        LFMaterialIndex=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        Scaling=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        AxisScaling=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        Rotation=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        bOrientTowardsSource=false
        Color=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        Alpha=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        Offset=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        DistMap_Scale=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        DistMap_Color=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
        DistMap_Alpha=(Distribution=none,Type=0,Op=0,LookupTableNumElements=0,LookupTableChunkSize=0,LookupTable=none,LookupTableTimeScale=0,LookupTableStartTime=0)
    }
};

var export editinline LensFlareElement SourceElement;
/** The StaticMesh to use as the source (optional) */
var(Source) StaticMesh SourceMesh;
var const Scene.ESceneDepthPriorityGroup SourceDPG;
/** The scene depth priority group to draw the reflection primitive(s) in. */
var(Reflections) const Scene.ESceneDepthPriorityGroup ReflectionsDPG;
var export editinline array<export editinline LensFlareElement> Reflections;
/** Viewing cone angles. */
var(Visibility) float OuterCone;
var(Visibility) float InnerCone;
var(Visibility) float ConeFudgeFactor;
var(Visibility) float Radius;
/** When true the new algorithm is used (NOTE: The new algorithm does not use ConeFudgeFactor). */
var(Visibility) bool bUseTrueConeCalculation;
/**  
 *If TRUE, use the given bounds.
 *       If FALSE and a static mesh is set for the source, the static mesh bounds will be used.
 *       If FALSE and no static mesh is set, it will use the default bounds (likely not a good thing).
 */
var(Bounds) bool bUseFixedRelativeBoundingBox;
/** Debugging helpers */
var(Debug) bool bRenderDebugLines;
var bool ThumbnailImageOutOfDate;
/** (New Algorithm only) If this is non-zero the lens flare will always draw with at least the strength specified, even behind or outside outer cone. */
var(Visibility) float MinStrength;
/**  
 *The mapping of screen coverage percentage (the result returned by occlusion checks)
 *       to the value passed into the materials for LensFlareOcclusion.
 */
var(Occlusion) RawDistributionFloat ScreenPercentageMap;
/** The fixed bounding box to use when bUseFixedRelativeBoundingBox is TRUE */
var(Bounds) Box FixedRelativeBoundingBox;
var export InterpCurveEdSetup CurveEdSetup;
var transient int ReflectionCount;
var Rotator ThumbnailAngle;
var float ThumbnailDistance;
var Texture2D ThumbnailImage;

defaultproperties
{
    SourceElement=ElementName=Source,RayDistance=0,bIsEnabled=true,bUseSourceDistance=false,bNormalizeRadialDistance=false,bModulateColorBySource=false,Size=(X=75,Y=75,Z=75),LFMaterials=none,LFMaterialIndex=Distribution=DistributionFloatConstant'Default__LensFlare.DistributionLFMaterialIndex',Type=0,Op=1,LookupTableNumElements=1,LookupTableChunkSize=1,LookupTable=/* Array type was not detected. */,0=/* Unknown default property type! */,
/* Exception thrown while deserializing LFMaterialIndex
System.ArgumentException: Requested value '3rd' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */,
/* Exception thrown while deserializing SourceElement
System.ArgumentException: Requested value '0_9474' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
    SourceDPG=ESceneDepthPriorityGroup.SDPG_World
    ReflectionsDPG=ESceneDepthPriorityGroup.SDPG_Foreground
    ConeFudgeFactor=0.5
    ScreenPercentageMap=Distribution=DistributionFloatConstantCurve'Default__LensFlare.DistributionScreenPercentageMap',Type=0,Op=1,LookupTableNumElements=1,LookupTableChunkSize=1,LookupTable=/* Array type was not detected. */,
/* Exception thrown while deserializing ScreenPercentageMap
System.ArgumentException: Requested value '0_1065353215' was not found.
   at System.Enum.TryParseEnum(Type enumType, String value, Boolean ignoreCase, EnumResult& parseResult)
   at System.Enum.Parse(Type enumType, String value, Boolean ignoreCase)
   at UELib.Core.UDefaultProperty.DeserializeTagUE3()
   at UELib.Core.UDefaultProperty.Deserialize()
   at UELib.Core.UDefaultProperty.DeserializeDefaultPropertyValue(PropertyType type, DeserializeFlags& deserializeFlags) */
}