/*******************************************************************************
 * Mutator generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Mutator extends Info
    abstract
    native
    notplaceable
    hidecategories(Navigation,Movement,Collision);

var Mutator NextMutator;
/** list of groups this mutator is in. Mutators that share any group cannot be activated simultaneously */
var() array<string> GroupNames;
var bool bUserAdded;

event PreBeginPlay()
{
    if(!MutatorIsAllowed())
    {
        Destroy();
    }
}

function bool MutatorIsAllowed()
{
    return !WorldInfo.IsDemoBuild();
}

event Destroyed()
{
    WorldInfo.Game.RemoveMutator(self);
    super(Actor).Destroyed();
}

function Mutate(string MutateString, PlayerController Sender)
{
    if(NextMutator != none)
    {
        NextMutator.Mutate(MutateString, Sender);
    }
}

function ModifyLogin(out string Portal, out string Options)
{
    if(NextMutator != none)
    {
        NextMutator.ModifyLogin(Portal, Options);
    }
}

function ModifyPlayer(Pawn Other)
{
    if(NextMutator != none)
    {
        NextMutator.ModifyPlayer(Other);
    }
}

function AddMutator(Mutator M)
{
    if(NextMutator == none)
    {
        NextMutator = M;        
    }
    else
    {
        NextMutator.AddMutator(M);
    }
}

function bool AlwaysKeep(Actor Other)
{
    if(NextMutator != none)
    {
        return NextMutator.AlwaysKeep(Other);
    }
    return false;
}

function bool IsRelevant(Actor Other)
{
    local bool bResult;

    bResult = CheckReplacement(Other);
    if(bResult && NextMutator != none)
    {
        bResult = NextMutator.IsRelevant(Other);
    }
    return bResult;
}

function bool CheckRelevance(Actor Other)
{
    local bool bResult;

    if(AlwaysKeep(Other))
    {
        return true;
    }
    bResult = IsRelevant(Other);
    return bResult;
}

function bool CheckReplacement(Actor Other)
{
    return true;
}

function NotifyLogout(Controller Exiting)
{
    if(NextMutator != none)
    {
        NextMutator.NotifyLogout(Exiting);
    }
}

function NotifyLogin(Controller NewPlayer)
{
    if(NextMutator != none)
    {
        NextMutator.NotifyLogin(NewPlayer);
    }
}

function DriverEnteredVehicle(Vehicle V, Pawn P)
{
    if(NextMutator != none)
    {
        NextMutator.DriverEnteredVehicle(V, P);
    }
}

function bool CanLeaveVehicle(Vehicle V, Pawn P)
{
    if(NextMutator != none)
    {
        return NextMutator.CanLeaveVehicle(V, P);
    }
    return true;
}

function DriverLeftVehicle(Vehicle V, Pawn P)
{
    if(NextMutator != none)
    {
        NextMutator.DriverLeftVehicle(V, P);
    }
}

function InitMutator(string Options, out string ErrorMessage)
{
    if(NextMutator != none)
    {
        NextMutator.InitMutator(Options, ErrorMessage);
    }
}

function GetSeamlessTravelActorList(bool bToEntry, out array<Actor> ActorList)
{
    if(bToEntry)
    {
        ActorList[ActorList.Length] = self;
    }
    if(NextMutator != none)
    {
        NextMutator.GetSeamlessTravelActorList(bToEntry, ActorList);
    }
}

function NavigationPoint FindPlayerStart(Controller Player, optional byte InTeam, optional string IncomingName)
{
    if(NextMutator != none)
    {
        return NextMutator.FindPlayerStart(Player, InTeam, IncomingName);        
    }
    else
    {
        return none;
    }
}

function bool HandleRestartGame()
{
    return (NextMutator != none) && NextMutator.HandleRestartGame();
}

function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
    return (NextMutator == none) || NextMutator.CheckEndGame(Winner, Reason);
}

function bool OverridePickupQuery(Pawn Other, class<Inventory> ItemClass, Actor Pickup, out byte bAllowPickup)
{
    return (NextMutator != none) && NextMutator.OverridePickupQuery(Other, ItemClass, Pickup, bAllowPickup);
}

function bool PreventDeath(Pawn Killed, Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    return (NextMutator != none) && NextMutator.PreventDeath(Killed, Killer, DamageType, HitLocation);
}

function ScoreObjective(PlayerReplicationInfo Scorer, int Score)
{
    if(NextMutator != none)
    {
        NextMutator.ScoreObjective(Scorer, Score);
    }
}

function ScoreKill(Controller Killer, Controller Killed)
{
    if(NextMutator != none)
    {
        NextMutator.ScoreKill(Killer, Killed);
    }
}

function NetDamage(int OriginalDamage, out int Damage, Pawn injured, Controller InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType, Actor DamageCauser)
{
    if(NextMutator != none)
    {
        NextMutator.NetDamage(OriginalDamage, Damage, injured, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser);
    }
}

function ModifyNextTraderIndex(out byte NextTraderIndex);

function ModifyAI(Pawn AIPawn);

function ModifyAIEnemy(AIController AI, Pawn Enemy);

function ModifyPickupFactories();

function ModifyActivatedPickupFactory(PickupFactory out_ActivatedFactory, out float out_RespawnDelay);

function ModifyZedTime(out float out_TimeSinceLastEvent, out float out_ZedTimeChance, out float out_Duration);

defaultproperties
{
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Mutator.Sprite'
    Components(0)=Sprite
    CollisionType=ECollisionType.COLLIDE_CustomDefault
}