/*******************************************************************************
 * WorldInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class WorldInfo extends ZoneInfo
    native(GameEngine)
    nativereplication
    config(Game)
    notplaceable
    hidecategories(Navigation,Movement,Collision,Actor,Advanced,Display,Events,Object,Attachment);

const MAX_BOOKMARK_NUMBER = 10;
const MAX_INSTANCES_PER_CLASS = 5;

enum ENetMode
{
    NM_Standalone,
    NM_DedicatedServer,
    NM_ListenServer,
    NM_Client,
    NM_MAX
};

enum EConsoleType
{
    CONSOLE_Any,
    CONSOLE_Xbox360,
    CONSOLE_PS3,
    CONSOLE_Mobile,
    CONSOLE_IPhone,
    CONSOLE_Android,
    CONSOLE_WiiU,
    CONSOLE_Flash,
    CONSOLE_Orbis,
    CONSOLE_MAX
};

enum EVisibilityAggressiveness
{
    VIS_LeastAggressive,
    VIS_ModeratelyAggressive,
    VIS_MostAggressive,
    VIS_Max
};

enum EPreferredLightmapType
{
    EPLT_Default,
    EPLT_Directional,
    EPLT_Simple,
    EPLT_MAX
};

enum EHostMigrationProgress
{
    HostMigration_None,
    HostMigration_FindingNewHost,
    HostMigration_MigratingAsHost,
    HostMigration_MigratingAsClient,
    HostMigration_ClientTravel,
    HostMigration_HostReadyToTravel,
    HostMigration_Failed,
    HostMigration_MAX
};

struct native NetViewer
{
    var PlayerController InViewer;
    var Actor Viewer;
    var Vector ViewLocation;
    var Vector ViewDir;

    structdefaultproperties
    {
        InViewer=none
        Viewer=none
        ViewLocation=(X=0,Y=0,Z=0)
        ViewDir=(X=0,Y=0,Z=0)
    }
};

struct native CompartmentRunList
{
    /** The rigid body compartment will run on this frame */
    var() bool RigidBody;
    /** The fluid compartment will run on this frame */
    var() bool Fluid;
    /** The cloth compartment will run on this frame */
    var() bool Cloth;
    /** The soft body compartment will run on this frame */
    var() bool SoftBody;

    structdefaultproperties
    {
        RigidBody=true
        Fluid=true
        Cloth=true
        SoftBody=true
    }
};

struct native PhysXSimulationProperties
{
    /** Whether or not to put the scene (or compartment) in PhysX hardware, if available. */
    var() bool bUseHardware;
    /**  
     *If true, substep sizes are fixed equal to TimeStep.
     *               If false, substep sizes are varied to fit an integer number of times into the frame time.
     */
    var() bool bFixedTimeStep;
    /** The fixed or maximum substep size, depending on the value of bFixedTimeStep. */
    var() float TimeStep;
    /** The maximum number of substeps allowed per frame. */
    var() int MaxSubSteps;

    structdefaultproperties
    {
        bUseHardware=false
        bFixedTimeStep=false
        TimeStep=0.02
        MaxSubSteps=5
    }
};

struct native PhysXSceneProperties
{
    /** Timing settings for the PhysX primary scene */
    var() editinline PhysXSimulationProperties PrimaryScene;
    /** Timing settings for the PhysX rigid body compartment */
    var() editinline PhysXSimulationProperties CompartmentRigidBody;
    /** Timing settings for the PhysX fluid compartment */
    var() editinline PhysXSimulationProperties CompartmentFluid;
    /** Timing settings for the PhysX cloth compartment */
    var() editinline PhysXSimulationProperties CompartmentCloth;
    /** Timing settings for the PhysX soft body compartment */
    var() editinline PhysXSimulationProperties CompartmentSoftBody;

    structdefaultproperties
    {
        PrimaryScene=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=5)
        CompartmentRigidBody=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=2)
        CompartmentFluid=(bUseHardware=true,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=1)
        CompartmentCloth=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.02,MaxSubSteps=2)
        CompartmentSoftBody=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.02,MaxSubSteps=2)
    }
};

struct native ApexModuleDestructibleSettings
{
    /**  
     *The maximum number of active PhysX actors which represent dynamic groups of chunks (islands).  If a
     *               fracturing event would cause more islands to be created, then oldest islands are released and the chunks
     *               they represent destroyed. If negative the INI setting will be used instead.
     */
    var() int MaxChunkIslandCount;
    /**  
     *The maximum number of PhysX shapes which represent destructible chunks.
     *               If a fracturing event would cause more shapes to be created, then oldest islands are released
     *               and the chunks they represent destroyed.
     */
    var() int MaxShapeCount;
    var int MaxRrbActorCount;
    /**  
     *Every destructible asset defines a min and max lifetime, and maximum separation distance for its chunks.
     *               Chunk islands are destroyed after this time or separation from their origins. This parameter sets the
     *               lifetimes and max separations within their min-max ranges. The valid range is [0,1].
     */
    var() float MaxChunkSeparationLOD<ClampMin=0.0|ClampMax=1.0>;
    /** If set, override the INI setting with Max Chunk Separation LOD in the WorldInfo properties. */
    var() bool bOverrideMaxChunkSeparationLOD;

    structdefaultproperties
    {
        MaxChunkIslandCount=-1
        MaxShapeCount=-1
        MaxRrbActorCount=-1
        MaxChunkSeparationLOD=1
        bOverrideMaxChunkSeparationLOD=false
    }
};

struct native PhysXEmitterVerticalProperties
{
    /** Parameters for emitter vertical */
    var() bool bDisableLod;
    /** Min value for particle LOD range. */
    var() int ParticlesLodMin;
    /** Max value for particle LOD range. */
    var() int ParticlesLodMax;
    /** Limit for packets per PhysXParticleSystem. Caped to 900. */
    var() int PacketsPerPhysXParticleSystemMax;
    /** Selects either cylindrical or spherical packet range culling. */
    var() bool bApplyCylindricalPacketCulling;
    /**  
     *Parameter for scaling spawn lod impact. 1.0: As much as possible lod through
     *               emitter spawn rate/lifetime control. 0.0: Lod constraint handled only through
     *               fifo control.
     */
    var() float SpawnLodVsFifoBias;

    structdefaultproperties
    {
        bDisableLod=true
        ParticlesLodMin=0
        ParticlesLodMax=15000
        PacketsPerPhysXParticleSystemMax=500
        bApplyCylindricalPacketCulling=true
        SpawnLodVsFifoBias=1
    }
};

struct native PhysXVerticalProperties
{
    /** Parameters for Emitter Vertical */
    var() editinline PhysXEmitterVerticalProperties Emitters;

    structdefaultproperties
    {
        Emitters=(bDisableLod=true,ParticlesLodMin=0,ParticlesLodMax=15000,PacketsPerPhysXParticleSystemMax=500,bApplyCylindricalPacketCulling=true,SpawnLodVsFifoBias=1)
    }
};

struct native WorldFractureSettings
{
    var float ChanceOfPhysicsChunkOverride;
    var bool bEnableChanceOfPhysicsChunkOverride;
    var bool bLimitExplosionChunkSize;
    var float MaxExplosionChunkSize;
    var bool bLimitDamageChunkSize;
    var float MaxDamageChunkSize;
    var int MaxNumFacturedChunksToSpawnInAFrame;
    var float FractureExplosionVelScale;

    structdefaultproperties
    {
        ChanceOfPhysicsChunkOverride=0
        bEnableChanceOfPhysicsChunkOverride=false
        bLimitExplosionChunkSize=false
        MaxExplosionChunkSize=0
        bLimitDamageChunkSize=false
        MaxDamageChunkSize=0
        MaxNumFacturedChunksToSpawnInAFrame=0
        FractureExplosionVelScale=0
    }
};

struct native transient ScreenMessageString
{
    var init transient QWord Key;
    var init transient string ScreenMessage;
    var init transient Color DisplayColor;
    var init transient float TimeToDisplay;
    var init transient float CurrentTimeDisplayed;

    structdefaultproperties
    {
        Key=none
        ScreenMessage=""
        DisplayColor=(B=0,G=0,R=0,A=0)
        TimeToDisplay=0
        CurrentTimeDisplayed=0
    }
};

struct native LightmassWorldInfoSettings
{
    /**  
     *Scale of the level relative to Gears of War 2 levels.
     *        All scale-dependent Lightmass setting defaults have been tweaked to work well in Gears 2 levels,
     *        Any levels with a different scale should use this scale to compensate.
     */
    var(General) float StaticLightingLevelScale;
    /**  
     *Number of times light is allowed to bounce off of surfaces, starting from the light source.
     *        0 is direct lighting only, 1 is one bounce, etc.
     *        Bounce 1 takes the most time to calculate and contributes the most to visual quality, followed by bounce 2.
     *        Successive bounces are nearly free, but have a much lower impact.
     */
    var(General) int NumIndirectLightingBounces;
    /**  
     *Color that rays which miss the scene will pick up.
     *        This is effectively a light surrounding the entire level that is shadowed, but doesn't emit indirect lighting.
     */
    var(General) Color EnvironmentColor;
    /** Scales EnvironmentColor to allow independent color and brightness controls. */
    var(General) float EnvironmentIntensity;
    /**  
     *In advanced mode the color that rays which miss the scen will pick up depends on 'sun'.
     *         The closer ray's direction is to the direction of sun the more color of sun is blended/added into picked color.
     */
    var(AdvancedEnvironmentColor) bool bEnableAdvancedEnvironmentColor;
    /** Color of the sun */
    var(AdvancedEnvironmentColor) Color EnvironmentSunColor;
    /** Scales EnvironmentSunColor to allow independent color and brightness controls. */
    var(AdvancedEnvironmentColor) float EnvironmentSunIntensity;
    /** In degrees. Range of sun color. */
    var(AdvancedEnvironmentColor) float EnvironmentLightTerminatorAngle;
    /** If this value is zeroed, the direction of dominant directional light on current scene will be used */
    var(AdvancedEnvironmentColor) Vector EnvironmentLightDirection;
    /** Scales the emissive contribution of all materials in the scene. */
    var(General) float EmissiveBoost;
    /** Scales the diffuse contribution of all materials in the scene. */
    var(General) float DiffuseBoost;
    var float SpecularBoost;
    /**  
     *Lerp factor that controls the influence of normal maps with directional lightmaps on indirect lighting.
     *        A value of 0 gives a physically correct distribution of light, which may result in little normal influence in areas only lit by indirect lighting, but less lightmap compression artifacts.
     *        A value of .8 results in 80% of the lighting being redistributed in the dominant incident lighting direction, which effectively increases the per-pixel normal's influence,
     *        But causes more severe lightmap compression artifacts.
     */
    var(General) float IndirectNormalInfluenceBoost;
    /** If TRUE, AmbientOcclusion will be enabled. */
    var(Occlusion) bool bUseAmbientOcclusion;
    /** If TRUE, Lightmass will generate static shadowing information for image reflections. */
    var(Occlusion) bool bEnableImageReflectionShadowing;
    /** How much of the AO to apply to direct lighting. */
    var(Occlusion) float DirectIlluminationOcclusionFraction;
    /** How much of the AO to apply to indirect lighting. */
    var(Occlusion) float IndirectIlluminationOcclusionFraction;
    /** Higher exponents increase contrast. */
    var(Occlusion) float OcclusionExponent;
    /** Fraction of samples taken that must be occluded in order to reach full occlusion. */
    var(Occlusion) float FullyOccludedSamplesFraction;
    /** Maximum distance for an object to cause occlusion on another object. */
    var(Occlusion) float MaxOcclusionDistance;
    /** If TRUE, override normal direct and indirect lighting with just the exported diffuse term. */
    var(Debug) bool bVisualizeMaterialDiffuse;
    /** If TRUE, override normal direct and indirect lighting with just the AO term. */
    var(Debug) bool bVisualizeAmbientOcclusion;
    /** If TRUE, compress shadowmap with DXT1. */
    var(General) bool bCompressShadowmap;

    structdefaultproperties
    {
        StaticLightingLevelScale=1
        NumIndirectLightingBounces=3
        EnvironmentColor=(B=0,G=0,R=0,A=0)
        EnvironmentIntensity=1
        bEnableAdvancedEnvironmentColor=false
        EnvironmentSunColor=(B=0,G=0,R=0,A=0)
        EnvironmentSunIntensity=1
        EnvironmentLightTerminatorAngle=90
        EnvironmentLightDirection=(X=0,Y=0,Z=0)
        EmissiveBoost=1
        DiffuseBoost=5
        SpecularBoost=1
        IndirectNormalInfluenceBoost=0.3
        bUseAmbientOcclusion=false
        bEnableImageReflectionShadowing=false
        DirectIlluminationOcclusionFraction=0.5
        IndirectIlluminationOcclusionFraction=1
        OcclusionExponent=1
        FullyOccludedSamplesFraction=1
        MaxOcclusionDistance=200
        bVisualizeMaterialDiffuse=false
        bVisualizeAmbientOcclusion=false
        bCompressShadowmap=false
    }
};

struct native NavMeshPathConstraintCacheDatum
{
    var int ListIdx;
    var NavMeshPathConstraint List[5];

    structdefaultproperties
    {
        ListIdx=0
        List[0]=none
        List[1]=none
        List[2]=none
        List[3]=none
        List[4]=none
    }
};

struct native NavMeshPathGoalEvaluatorCacheDatum
{
    var int ListIdx;
    var NavMeshPathGoalEvaluator List[5];

    structdefaultproperties
    {
        ListIdx=0
        List[0]=none
        List[1]=none
        List[2]=none
        List[3]=none
        List[4]=none
    }
};

struct native HostMigrationState
{
    var WorldInfo.EHostMigrationProgress HostMigrationProgress;
    var float HostMigrationElapsedTime;
    var float HostMigrationTravelCountdown;
    var string HostMigrationTravelURL;
    var bool bHostMigrationEnabled;

    structdefaultproperties
    {
        HostMigrationProgress=EHostMigrationProgress.HostMigration_None
        HostMigrationElapsedTime=0
        HostMigrationTravelCountdown=0
        HostMigrationTravelURL=""
        bHostMigrationEnabled=false
    }
};

struct native FlexMeshContactInfo
{
    var Vector ContactPosition;
    var Vector ContactNormal;

    structdefaultproperties
    {
        ContactPosition=(X=0,Y=0,Z=0)
        ContactNormal=(X=0,Y=0,Z=0)
    }
};

var private const bool UseCheckbackMatchmaking;
/** Whether or not post process effects should persist when this level is unloaded */
var(Rendering) config bool bPersistPostProcessToNextLevel;
/**  
 *Use this setting to turn off WholeSceneDominantShadows for the map. This can be used to circumvent the shadow graphics setting for certain maps in order to meet the performance benchmarks.
 *       USE CASE: Set the light to cast WholeSceneShadows, and check bDisableWholeSceneDominantShadow. Whole scene shadows can then be enabled based on bOverrideMapWholeSceneDominantShadowSetting system setting.
 */
var(Rendering) bool bDisableWholeSceneDominantShadow;
/** Mobile only: Enables distance-based fog globally for this level */
var(Mobile) bool bFogEnabled;
/** Mobile only: Enables bump offset mapping for this level for mobile materials that use that */
var(Mobile) bool bBumpOffsetEnabled;
/** Mobile: True to enable gamma correction for all shaders when rendering this level.  Enabling this will yield lighting that more closely resembles other platforms, but may reduce rendering performance slightly. */
var(Mobile) bool bUseGammaCorrection;
var bool bMapNeedsLightingFullyRebuilt;
var bool bMapHasMultipleDominantLightsAffectingOnePrimitive;
var bool bMapHasPathingErrors;
var bool bRequestedBlockOnAsyncLoading;
var bool bBegunPlay;
var bool bPlayersOnly;
var bool bPlayersOnlyPending;
var bool bSuspendAI;
var transient bool bDropDetail;
var transient bool bAggressiveLOD;
var bool bStartup;
var bool bPathsRebuilt;
var bool bHasPathNodes;
var const transient bool bIsMenuLevel;
var editoronly const transient bool bDebugPauseExecution;
var editoronly const transient bool bDebugStepExecution;
var transient bool bUseConsoleInput;
var bool bMapNeedsSplatterMapsRebuilt;
var bool bMapNeedsPrecomputedVisibilityRebuilt;
/**  
 *Causes the BSP build to generate as few sections as possible.
 * This is useful when you need to reduce draw calls but can reduce texture streaming efficiency and effective lightmap resolution.
 * Note - changes require a rebuild to propagate.  Also, be sure to select all surfaces and make sure they all have the same flags to minimize section count.
 */
var(Rendering) bool bMinimizeBSPSections;
/** if true, do not grant player with default inventory (presumably, the LD's will be setting it manually) */
var() bool bNoDefaultInventoryForPlayer;
/** If true, don't add "no paths from" warnings to map error list in editor.  Useful for maps that don't need AI support, but still have a few NavigationPoint actors in them. */
var() bool bNoPathWarnings;
/** Flag for controlling whether Mobile warnings are shown in map checks */
var() config bool bNoMobileMapWarnings;
var bool bHighPriorityLoading;
var bool bHighPriorityLoadingLocal;
/**  
 *Overriding is useful for doing perf testing / load testing / being able to overcome memory issues in other tools until they are fixed
 * withOUT compromising the RuleSet creation process and the application of the rulesets in the level
 */
var(ProcBuildings) bool bUseProcBuildingRulesetOverride;
var const transient bool bInteractiveMode;
/** Double buffered physics compartments enabled */
var(PhysicsAdvanced) bool bSupportDoubleBufferedPhysics;
/** If TRUE, physics simulation will ignore time elapsed between frames, and use (0.033 TimeDilation) */
var(Physics) bool bPhysicsIgnoreDeltaTime;
/** If TRUE, uses ChanceOfPhysicsChunkOverride instead of that set in the FracturedStaticMesh. */
var(Fracture) private config bool bEnableChanceOfPhysicsChunkOverride;
/** If TRUE, limit the max dimension of the bounding box of a fracture chunk due to explosion to MaxExplosionChunkSize */
var(Fracture) private config bool bLimitExplosionChunkSize;
/** If TRUE, limit the max dimension of the bounding box of a fracture chunk due to weapon damage to bLimitDamageChunkSize */
var(Fracture) private config bool bLimitDamageChunkSize;
/**  
 *Whether to place visibility cells inside Precomputed Visibility Volumes and along camera tracks in this level.
 * Precomputing visibility reduces rendering thread time at the cost of some runtime memory and somewhat increased lighting build times.
 */
var(PrecomputedVisibility) bool bPrecomputeVisibility;
/**  
 *Whether to place visibility cells on shadow casting surfaces only, or everywhere inside Precomputed Visibility Volumes.
 * Placing cells everywhere in the volumes is useful for games where the camera is not restrained to an area around the ground,
 * But generates a lot more cells than just placing on surfaces, so build times and memory usage will increase.
 */
var(PrecomputedVisibility) editconst bool bPlaceCellsOnSurfaces;
/** Whether to place visibility cells on opaque surfaces only */
var(PrecomputedVisibility) editconst bool bPlaceCellsOnOpaqueOnly;
/** Whether to store visibility data in compressed form */
var(PrecomputedVisibility) editconst bool bCompressVisibilityData;
/** Whether to allow temporal AA. */
var(Rendering) globalconfig bool bAllowTemporalAA;
var editoronly bool bUseGlobalIllumination;
/**  
 *Whether to force lightmaps and other precomputed lighting to not be created even when the engine thinks they are needed.
 * This is useful for improving iteration in levels with fully dynamic lighting and shadowing.
 * Note that any lighting and shadowing interactions that are usually precomputed will be lost if this is enabled.
 */
var(Lightmass) bool bForceNoPrecomputedLighting;
var bool bHaveActiveCrowd;
var config bool bAllowHostMigration;
var bool bGameplayFramePause;
/** If set, uses physX raycasts for visibility traces */
var(Physics) editconst bool bUsePxVisibilityCollision;
var globalconfig bool bAllowExplosionLights;
var transient bool bDropHighDetail;
/** Default post process settings used by post processing volumes. */
var(Rendering) PostProcessSettings DefaultPostProcessSettings;
/** The post process chain for the entire world */
var(Rendering) PostProcessChain WorldPostProcessChain;
/** Squint mode kernel size (same as DOF). */
var(Rendering) config float SquintModeKernelSize;
var(Rendering) float LevelShadowDepthBias;
var noimport const transient PostProcessVolume HighestPriorityPostProcessVolume;
/** Default reverb settings used by reverb volumes. */
var(Audio) config ReverbSettings DefaultReverbSettings;
/** Default interior settings used by reverb volumes. */
var(Audio) config InteriorSettings DefaultAmbientZoneSettings;
/** Mobile only: Sets the distance fog start distance.  Can be negative. */
var(Mobile) float FogStart;
/** Mobile only: Sets the distance fog end distance.  Must be larger than FogStart. */
var(Mobile) float FogEnd;
/** Mobile only: Sets the distance fog color */
var(Mobile) Color FogColor;
/** Mobile only: Sets the bump offset threshold for mobile materials that use that */
var(Mobile) float BumpEnd;
var noimport const transient ReverbVolume HighestPriorityReverbVolume;
var noimport const transient array<MassiveLODOverrideVolume> MassiveLODOverrideVolumes;
var noimport const transient array<PortalVolume> PortalVolumes;
var noimport const transient array<EnvironmentVolume> EnvironmentVolumes;
/** Level collection. ULevels are referenced by FName (Package name) to avoid serialized references. Also contains offsets in world units */
var() const editconst editinline array<editconst editinline LevelStreaming> StreamingLevels;
var transient Double LastTimeUnbuiltLightingWasEncountered;
/** Level bookmarks */
var(Editor) editoronly BookMark BookMarks[10];
/** Kismet bookmarks */
var(Editor) editoronly KismetBookMark KismetBookMarks[10];
/** Clip pad entries */
var(Editor) editoronly editinline array<editoronly editinline ClipPadEntry> ClipPadEntries;
var float TimeDilation;
var float DemoPlayTimeDilation;
var transient float TimeSeconds;
var transient float RealTimeSeconds;
var transient float AudioTimeSeconds;
var const transient float DeltaSeconds;
var transient float PauseDelay;
var transient float RealTimeToUnPause;
var PlayerReplicationInfo Pauser;
var editoronly deprecated string VisibleGroups;
var editoronly string VisibleLayers;
var Texture2D DefaultTexture;
var Texture2D WireframeTexture;
var Texture2D WhiteSquareTexture;
var Texture2D LargeVertex;
var Texture2D BSPVertex;
var array<string> DeferredExecs;
var transient GameReplicationInfo GRI;
var WorldInfo.ENetMode NetMode;
var Actor.ETravelType NextTravelType;
var WorldInfo.EVisibilityAggressiveness VisibilityAggressiveness;
var WorldInfo.EPreferredLightmapType PreferredLightmapType;
/** The lighting quality the level was last built with */
var(Lightmass) editconst EngineTypes.ELightingBuildQuality LevelLightingQuality;
var string ComputerName;
var string EngineVersion;
var string MinNetVersion;
var GameInfo Game;
/** vehicles stall if they reach this */
var(ZoneInfo) float StallZ;
var transient float WorldGravityZ;
var const globalconfig float DefaultGravityZ;
/** optional level specific gravity override set by level designer */
var(ZoneInfo) float GlobalGravityZ;
var globalconfig float RBPhysicsGravityScaling;
var private const transient NavigationPoint NavigationPointList;
var private const Controller ControllerList;
var const Pawn PawnList;
var const transient CoverLink CoverList;
var private const transient Pylon PylonList;
var float MoveRepSize;
var const array<NetViewer> ReplicationViewers;
var string NextURL;
var float NextSwitchCountdown;
/** Maximum size of textures for packed light and shadow maps */
var(Rendering) int PackedLightAndShadowMapTextureSize;
/** Default color scale for the level */
var(Rendering) Vector DefaultColorScale;
/** The default game type to use when starting this map in the game. If this value is NULL, the INI setting for default game type is used. */
var(GameType) class<GameInfo> DefaultGameType;
/**  
 *This is the list of GameTypes which this map can support.  This is used for SeekFree loading
 * code so the map has a reference to the game type it will be played with so it can cook
 * all of the specific assets
 */
var(GameType) array< class<GameInfo> > GameTypesSupportedOnThisMap;
/**  
 *This is the gametype that should be used when starting the map in PIE.
 * Note: if this value is not NULL it will override the DefaultGameType value when running PIE
 */
var(GameType) editoronly class<GameInfo> GameTypeForPIE;
var const editconst array<editconst Object> ClientDestroyedActorContent;
var const transient array<name> PreparingLevelNames;
var const transient name CommittedPersistentLevelName;
var ObjectReferencer PersistentMapForcedObjects;
var export editinline transient AudioComponent MusicComp;
var transient MusicTrackStruct CurrentMusicTrack;
var repnotify transient MusicTrackStruct ReplicatedMusicTrack;
/** title of the map displayed in the UI */
var() const localized string Title;
/** Who created this map */
var() string Author;
/** game specific map information - access through GetMapInfo()/SetMapInfo() */
var() protected export editinline MapInfo MyMapInfo;
var string EmitterPoolClassPath;
var transient EmitterPool MyEmitterPool;
var globalconfig string DecalManagerClassPath;
var transient DecalManager MyDecalManager;
var string FractureManagerClassPath;
var transient FractureManager MyFractureManager;
var string ParticleEventManagerClassPath;
var transient ParticleEventManager MyParticleEventManager;
var(ProcBuildings) ProcBuildingRuleset ProcBuildingRulesetOverride;
var const transient int SkelMeshCompTickTagCount;
/** The maximum frame time allowed for physics calculations */
var(PhysicsAdvanced) float MaxPhysicsDeltaTime;
var config int MaxPhysicsSubsteps;
/** Timing parameters for the scene, primary and compartments. */
var(PhysicsAdvanced) editinline PhysXSceneProperties PhysicsProperties;
/** Which compartments run on which frames (list is cyclic).  An empty list means all compartments run on all frames. */
var(PhysicsAdvanced) array<CompartmentRunList> CompartmentRunFrames;
/** Default skin width */
var(PhysicsAdvanced) float DefaultSkinWidth;
/** Global APEX resource budget override. If negative the INI setting will be used instead. */
var(PhysicsAdvanced) float ApexLODResourceBudget;
/** A higher value would increase the amount of resources allocated to Apex Destruction */
var(PhysicsAdvanced) float ApexDestructionLODResourceValue;
/** A higher value would increase the amount of resources allocated to Apex Clothing */
var(PhysicsAdvanced) float ApexClothingLODResourceValue;
var(PhysicsAdvanced) ApexModuleDestructibleSettings DestructibleSettings;
var PhysicsLODVerticalEmitter EmitterVertical;
/** Vertical parameters. */
var(PhysicsAdvanced) editinline PhysXVerticalProperties VerticalProperties;
var private native array<Pointer> WorldAttractors;
/** Allows global override of the ChanceOfPhysicsChunk setting. */
var(Fracture) private config float ChanceOfPhysicsChunkOverride;
/** Max dimension of the bounding box of a fracture chunk due to explosion. */
var(Fracture) private config float MaxExplosionChunkSize;
/** Max dimension of the bounding box of a fracture chunk due to weapon damage. */
var(Fracture) private config float MaxDamageChunkSize;
/** Scaling for chunk thrown out during explosion on a fractured mesh */
var(Fracture) private config float FractureExplosionVelScale;
/** Max number of Fractured Chunks to Spawn in a frame. */
var(Fracture) private int MaxNumFacturedChunksToSpawnInAFrame;
var transient int NumFacturedChunksSpawnedThisFrame;
var config float FracturedMeshWeaponDamage;
/**  
 *World space size of precomputed visibility cells in x and y.
 * Smaller sizes produce more effective occlusion culling at the cost of increased runtime memory usage and lighting build times.
 */
var(PrecomputedVisibility) editconst int VisibilityCellSize;
/** How much to jitter results from neighboring cells. Controls precomputed visibility aggresiveness */
var(PrecomputedVisibility) editconst int VisibilitySpreadingIterations;
/** How much to scale mesh bounds for visibility calculations. Controls precomputed visibility aggresiveness */
var(PrecomputedVisibility) editconst float MeshBoundsScale;
/** Max player height. Used for precomputed visibility calculations */
var(PrecomputedVisibility) editconst float PlayAreaHeight;
var int MinMeshSamples;
var int MaxMeshSamples;
var int NumCellSamples;
var int NumImportanceSamples;
var int CellRenderingBucketSize;
var int NumCellRenderingBuckets;
var int NumCellDistributionBuckets;
/** Brightness applied to the indirect lighting of character light environments that are lit by any dominant light. */
var(LightEnvironment) float CharacterLitIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>;
/** Contrast factor applied to the indirect lighting of character light environments that are lit by any dominant light. */
var(LightEnvironment) float CharacterLitIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/** Brightness applied to the indirect lighting of character light environments that are shadowed by all dominant lights. */
var(LightEnvironment) float CharacterShadowedIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>;
/** Contrast factor applied to the indirect lighting of character light environments that are shadowed by all dominant lights. */
var(LightEnvironment) float CharacterShadowedIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/**  
 *Increases the contrast of light environment lighting on characters by scaling up the brightest directions and scaling down the rest by this factor.
 * Note that this setting only affects light environments completely in shadow from all dominant lights.
 */
var(LightEnvironment) float CharacterLightingContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/**  
 *Panoramic environment texture for image reflections.
 * The texture should be laid out so that the horizon is along the bottom (v = 0) and straight up in world space is along the top (v = 1).
 * The u direction of the texture then corresponds to rotation around the Z world axis.
 */
var(Rendering) Texture2D ImageReflectionEnvironmentTexture<bShowOnlyWhenTrue=bShowD3D11Properties>;
/** Color to be multiplied against ImageReflectionEnvironmentTexture.  Alpha controls brightness. */
var(Rendering) LinearColor ImageReflectionEnvironmentColor<bShowOnlyWhenTrue=bShowD3D11Properties>;
/** Angle to rotate the environment texture around the world Z axis, in degrees. */
var(Rendering) float ImageReflectionEnvironmentRotation<bShowOnlyWhenTrue=bShowD3D11Properties>;
var native transient Map_Mirror ScreenMessages;
var native transient array<ScreenMessageString> PriorityScreenMessages;
var editoronly int MaxTrianglesPerLeaf<FixedIncrement=4|ClampMin=4|Multiple=4>;
var editoronly export editinline deprecated LightmassLevelSettings LMLevelSettings;
var editoronly native transient map<0, 0> LandscapeInfoMap;
var(Lightmass) LightmassWorldInfoSettings LightmassSettings<ScriptOrder=true>;
var native map<0, 0> NavMeshPathConstraintCache;
var native map<0, 0> NavMeshPathGoalEvaluatorCache;
var CrowdPopulationManagerBase PopulationManager;
var const transient HostMigrationState PeerHostMigration;
var config float HostMigrationTimeout;
var transient PhysicsVolume FirstPhysicsVolume;
var private FileWriter GameBalanceLog;
var InterpCurveFloat FlickerCurve;
var InterpCurveFloat PulseCurve;
var InterpCurveFloat StrobeCurve;
var InterpCurveFloat ChaoticFlickerCurve;
var InterpCurveFloat InverseChaoticFlickerCurve;
/**  
 *The lower bound to which the light brightness curves should be clamped.
 *By default, the brightness can go to 0 (fully dark). This value will prevent the
 *brightness to drop below a specified value
 */
var(LightAnimation) float FlickerBrightnessLowerBoundClamp<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
var(LightAnimation) float PulseBrightnessLowerBoundClamp<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
var(LightAnimation) float StrobeBrightnessLowerBoundClamp<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
var(LightAnimation) float ChaoticFlickerBrightnessLowerBoundClamp<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
var(LightAnimation) float InverseChaoticFlickerBrightnessLowerBoundClamp<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>;
/** MICs modified by zed time */
var(Rendering) array<MaterialInstanceConstant> ZedTimeMICs;
var globalconfig float EmitterPoolScale;
var globalconfig float DestructionLifetimeScale;
var string ImpactEffectManagerClassPath;
var transient Actor MyImpactEffectManager;
var string GoreEffectManagerClassPath;
var transient Actor MyGoreEffectManager;
var string TurbEffectPoolClassPath;
var transient Actor MyTurbEffectPool;
var string GroundFireEmitterPoolClassPath;
var transient EmitterPool GroundFireEmitterPool;
var string ImpactFXEmitterPoolClassPath;
var transient EmitterPool ImpactFXEmitterPool;
var globalconfig int MaxExplosionDecals;
var transient DecalManager ExplosionDecalManager;
var string LastSuccessfulPathBuildTime;
var transient array<FlexMeshContactInfo> FlexMeshContacts;

replication
{
     if(bNetDirty && Role == ROLE_Authority)
        Pauser, ReplicatedMusicTrack, 
        TimeDilation, WorldGravityZ, 
        bHighPriorityLoading;
}

// Export UWorldInfo::execReleaseCachedConstraintsAndEvaluators(FFrame&, void* const)
native function ReleaseCachedConstraintsAndEvaluators();

// Export UWorldInfo::execGetNavMeshPathConstraintFromCache(FFrame&, void* const)
native function NavMeshPathConstraint GetNavMeshPathConstraintFromCache(class<NavMeshPathConstraint> ConstraintClass, NavigationHandle Requestor);

// Export UWorldInfo::execGetNavMeshPathGoalEvaluatorFromCache(FFrame&, void* const)
native function NavMeshPathGoalEvaluator GetNavMeshPathGoalEvaluatorFromCache(class<NavMeshPathGoalEvaluator> GoalEvalClass, NavigationHandle Requestor);

simulated event ReplicatedEvent(name VarName)
{
    if(VarName == 'ReplicatedMusicTrack')
    {
        UpdateMusicTrack(ReplicatedMusicTrack);
    }
    super(Actor).ReplicatedEvent(VarName);
}

// Export UWorldInfo::execAddOnScreenDebugMessage(FFrame&, void* const)
native final function AddOnScreenDebugMessage(int Key, float TimeToDisplay, Color DisplayColor, string DebugMessage);

// Export UWorldInfo::execIsMenuLevel(FFrame&, void* const)
native static final function bool IsMenuLevel(optional string MapName);

// Export UWorldInfo::execSetMusicVolume(FFrame&, void* const)
native final function SetMusicVolume(float VolumeMultiplier);

// Export UWorldInfo::execUpdateMusicTrack(FFrame&, void* const)
native final function UpdateMusicTrack(MusicTrackStruct NewMusicTrack);

// Export UWorldInfo::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

// Export UWorldInfo::execGetGameSequence(FFrame&, void* const)
native final simulated function Sequence GetGameSequence();

// Export UWorldInfo::execGetAllRootSequences(FFrame&, void* const)
native final simulated function array<Sequence> GetAllRootSequences();

// Export UWorldInfo::execSetLevelRBGravity(FFrame&, void* const)
native final function SetLevelRBGravity(Vector NewGrav);

// Export UWorldInfo::execGetLocalURL(FFrame&, void* const)
native simulated function string GetLocalURL();

// Export UWorldInfo::execIsDemoBuild(FFrame&, void* const)
native static final simulated function bool IsDemoBuild();

// Export UWorldInfo::execIsConsoleDedicatedServer(FFrame&, void* const)
native static final function bool IsConsoleDedicatedServer();

// Export UWorldInfo::execIsPlayfabServer(FFrame&, void* const)
native static final function bool IsPlayfabServer();

// Export UWorldInfo::execIsE3Build(FFrame&, void* const)
native static final simulated function bool IsE3Build();

// Export UWorldInfo::execIsConsoleBuild(FFrame&, void* const)
native static final simulated function bool IsConsoleBuild(optional WorldInfo.EConsoleType ConsoleType)
{
    ConsoleType = 0;            
}

// Export UWorldInfo::execIsWithGFx(FFrame&, void* const)
native static final simulated function bool IsWithGFx();

// Export UWorldInfo::execIsPlayInEditor(FFrame&, void* const)
native static final simulated function bool IsPlayInEditor();

// Export UWorldInfo::execIsPlayInPreview(FFrame&, void* const)
native static final simulated function bool IsPlayInPreview();

// Export UWorldInfo::execIsPlayInMobilePreview(FFrame&, void* const)
native static final simulated function bool IsPlayInMobilePreview();

// Export UWorldInfo::execForceGarbageCollection(FFrame&, void* const)
native final simulated function ForceGarbageCollection(optional bool bFullPurge);

// Export UWorldInfo::execVerifyNavList(FFrame&, void* const)
native final simulated function VerifyNavList();

// Export UWorldInfo::execGetAddressURL(FFrame&, void* const)
native simulated function string GetAddressURL();

simulated function class<GameInfo> GetGameClass()
{
    if(WorldInfo.Game != none)
    {
        return WorldInfo.Game.Class;
    }
    if((GRI != none) && GRI.GameClass != none)
    {
        return GRI.GameClass;
    }
    return none;
}

simulated event ServerTravel(string URL, optional bool bAbsolute, optional bool bShouldSkipGameNotify)
{
    if(InStr(URL, "%") >= 0)
    {
        LogInternal("URL Contains illegal character '%'.");
        return;
    }
    if(((InStr(URL, ":") >= 0) || InStr(URL, "/") >= 0) || InStr(URL, "\\") >= 0)
    {
        LogInternal("URL blocked");
        return;
    }
    if((Game != none) && Game.bHasNetworkError)
    {
        LogInternal("Not traveling because of network error");
        return;
    }
    NextTravelType = ((bAbsolute) ? 0 : 2);
    if((NextURL == "") && !IsInSeamlessTravel() || bShouldSkipGameNotify)
    {
        NextURL = URL;
        if(Game != none)
        {
            if(!bShouldSkipGameNotify)
            {
                Game.ProcessServerTravel(URL, bAbsolute);
            }            
        }
        else
        {
            NextSwitchCountdown = 0;
        }
    }
}

function ThisIsNeverExecuted(DefaultPhysicsVolume P)
{
    P = none;
}

simulated function PreBeginPlay()
{
    local class<EmitterPool> PoolClass;
    local class<DecalManager> DecalManagerClass;
    local class<FractureManager> FractureManagerClass;
    local class<ParticleEventManager> ParticleEventManagerClass;
    local class<Actor> ImpactEffectManagerClass, GoreEffectManagerClass, TurbEffectPoolClass;

    super(Actor).PreBeginPlay();
    if((WorldInfo.NetMode != NM_DedicatedServer) && IsInPersistentLevel())
    {
        if(EmitterPoolClassPath != "")
        {
            PoolClass = class<EmitterPool>(DynamicLoadObject(EmitterPoolClassPath, Class'Class'));
            if(PoolClass != none)
            {
                MyEmitterPool = Spawn(PoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(DecalManagerClassPath != "")
        {
            DecalManagerClass = class<DecalManager>(DynamicLoadObject(DecalManagerClassPath, Class'Class'));
            if(DecalManagerClass != none)
            {
                MyDecalManager = Spawn(DecalManagerClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(FractureManagerClassPath != "")
        {
            FractureManagerClass = class<FractureManager>(DynamicLoadObject(FractureManagerClassPath, Class'Class'));
            if(FractureManagerClass != none)
            {
                MyFractureManager = Spawn(FractureManagerClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(ParticleEventManagerClassPath != "")
        {
            ParticleEventManagerClass = class<ParticleEventManager>(DynamicLoadObject(ParticleEventManagerClassPath, Class'Class'));
            if(ParticleEventManagerClass != none)
            {
                MyParticleEventManager = Spawn(ParticleEventManagerClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(GroundFireEmitterPoolClassPath != "")
        {
            PoolClass = class<EmitterPool>(DynamicLoadObject(GroundFireEmitterPoolClassPath, Class'Class'));
            if(PoolClass != none)
            {
                GroundFireEmitterPool = Spawn(PoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(ImpactFXEmitterPoolClassPath != "")
        {
            PoolClass = class<EmitterPool>(DynamicLoadObject(ImpactFXEmitterPoolClassPath, Class'Class'));
            if(PoolClass != none)
            {
                ImpactFXEmitterPool = Spawn(PoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
                ImpactFXEmitterPool.MaxActiveEffects *= EmitterPoolScale;
            }
        }
        if(ImpactEffectManagerClassPath != "")
        {
            ImpactEffectManagerClass = class<Actor>(DynamicLoadObject(ImpactEffectManagerClassPath, Class'Class'));
            if(ImpactEffectManagerClass != none)
            {
                MyImpactEffectManager = Spawn(ImpactEffectManagerClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(GoreEffectManagerClassPath != "")
        {
            GoreEffectManagerClass = class<Actor>(DynamicLoadObject(GoreEffectManagerClassPath, Class'Class'));
            if(GoreEffectManagerClass != none)
            {
                MyGoreEffectManager = Spawn(GoreEffectManagerClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        if(TurbEffectPoolClassPath != "")
        {
            TurbEffectPoolClass = class<Actor>(DynamicLoadObject(TurbEffectPoolClassPath, Class'Class'));
            if(TurbEffectPoolClass != none)
            {
                MyTurbEffectPool = Spawn(TurbEffectPoolClass, self,, vect(0, 0, 0), rot(0, 0, 0));
            }
        }
        ExplosionDecalManager = Spawn(Class'DecalManager', self,, vect(0, 0, 0), rot(0, 0, 0));
        ExplosionDecalManager.MaxActiveDecals = MaxExplosionDecals;
    }
}

simulated function PostBeginPlay()
{
    super(Actor).PostBeginPlay();
    if(IsConsoleBuild())
    {
        bUseConsoleInput = true;
    }
}

function Reset()
{
    super(Actor).Reset();
}

// Export UWorldInfo::execAllNavigationPoints(FFrame&, void* const)
native final iterator function AllNavigationPoints(class<NavigationPoint> BaseClass, out NavigationPoint N);

// Export UWorldInfo::execRadiusNavigationPoints(FFrame&, void* const)
native final iterator function RadiusNavigationPoints(class<NavigationPoint> BaseClass, out NavigationPoint N, Vector Point, float Radius);

// Export UWorldInfo::execNavigationPointCheck(FFrame&, void* const)
native final function NavigationPointCheck(Vector Point, Vector Extent, optional out array<NavigationPoint> Navs, optional out array<ReachSpec> Specs);

// Export UWorldInfo::execAllControllers(FFrame&, void* const)
native final iterator function AllControllers(class<Controller> BaseClass, out Controller C);

// Export UWorldInfo::execAllPawns(FFrame&, void* const)
native final iterator function AllPawns(class<Pawn> BaseClass, out Pawn P, optional Vector TestLocation, optional float TestRadius);

// Export UWorldInfo::execAllClientConnections(FFrame&, void* const)
native final iterator function AllClientConnections(out Player ClientConnection, out int ClientIP, out int ClientPort);

// Export UWorldInfo::execNotifyMatchStarted(FFrame&, void* const)
native final function NotifyMatchStarted(optional bool bShouldActivateLevelStartupEvents, optional bool bShouldActivateLevelBeginningEvents, optional bool bShouldActivateLevelLoadedEvents)
{
    bShouldActivateLevelStartupEvents = true;
    bShouldActivateLevelBeginningEvents = true;
    bShouldActivateLevelLoadedEvents = false;                    
}

// Export UWorldInfo::execPrepareMapChange(FFrame&, void* const)
native final function PrepareMapChange(const out array<name> LevelNames);

// Export UWorldInfo::execIsPreparingMapChange(FFrame&, void* const)
native final function bool IsPreparingMapChange();

// Export UWorldInfo::execIsMapChangeReady(FFrame&, void* const)
native final function bool IsMapChangeReady();

// Export UWorldInfo::execCancelPendingMapChange(FFrame&, void* const)
native final function CancelPendingMapChange();

// Export UWorldInfo::execCommitMapChange(FFrame&, void* const)
native final function CommitMapChange();

// Export UWorldInfo::execSeamlessTravel(FFrame&, void* const)
native final function SeamlessTravel(string URL, optional bool bAbsolute, init optional Guid MapPackageGuid);

// Export UWorldInfo::execIsInSeamlessTravel(FFrame&, void* const)
native final function bool IsInSeamlessTravel();

// Export UWorldInfo::execSetSeamlessTravelMidpointPause(FFrame&, void* const)
native final function SetSeamlessTravelMidpointPause(bool bNowPaused);

// Export UWorldInfo::execGetMapInfo(FFrame&, void* const)
native final function MapInfo GetMapInfo();

// Export UWorldInfo::execSetMapInfo(FFrame&, void* const)
native final function SetMapInfo(MapInfo NewMapInfo);

// Export UWorldInfo::execGetMapName(FFrame&, void* const)
native final function string GetMapName(optional bool bIncludePrefix);

// Export UWorldInfo::execGetDetailMode(FFrame&, void* const)
native final function Scene.EDetailMode GetDetailMode();

// Export UWorldInfo::execIsRecordingDemo(FFrame&, void* const)
native final function bool IsRecordingDemo();

// Export UWorldInfo::execIsPlayingDemo(FFrame&, void* const)
native final function bool IsPlayingDemo();

// Export UWorldInfo::execGetDemoFrameInfo(FFrame&, void* const)
native final function GetDemoFrameInfo(optional out int CurrentFrame, optional out int TotalFrames);

// Export UWorldInfo::execGetDemoRewindPoints(FFrame&, void* const)
native final function bool GetDemoRewindPoints(out array<int> OutRewindPoints);

// Export UWorldInfo::execDoMemoryTracking(FFrame&, void* const)
native final function DoMemoryTracking();

// Export UWorldInfo::execGetWorldFractureSettings(FFrame&, void* const)
native final function WorldFractureSettings GetWorldFractureSettings();

// Export UWorldInfo::execGetWorldInfo(FFrame&, void* const)
native static final function WorldInfo GetWorldInfo();

// Export UWorldInfo::execFindEnvironmentVolume(FFrame&, void* const)
native final function EnvironmentVolume FindEnvironmentVolume(Vector TestLocation);

simulated event bool CanBeginHostMigration()
{
    local PlayerController PC;

    foreach LocalPlayerControllers(Class'PlayerController', PC)
    {
        if(PC.IsPrimaryPlayer())
        {
            if(!PC.CanAllPlayersPlayOnline() || PC.BestNextHostPeers.Length == 0)
            {                
                return false;
            }
        }        
    }    
    return true;
}

// Export UWorldInfo::execBeginHostMigration(FFrame&, void* const)
native function bool BeginHostMigration();

simulated event NotifyHostMigrationStateChanged(WorldInfo.EHostMigrationProgress NewState, WorldInfo.EHostMigrationProgress OldState)
{
    local PlayerController PC;

    if((OldState == 0) && NewState != 0)
    {
        foreach LocalPlayerControllers(Class'PlayerController', PC)
        {
            if(PC.IsPrimaryPlayer())
            {
                PC.NotifyHostMigrationStarted();
                break;
            }            
        }        
    }
}

// Export UWorldInfo::execToggleHostMigration(FFrame&, void* const)
native function ToggleHostMigration(bool bEnabled);

// Export UWorldInfo::execClearObjectPools(FFrame&, void* const)
native final function ClearObjectPools();

// Export UWorldInfo::execGetReverbVolume(FFrame&, void* const)
native function ReverbVolume GetReverbVolume(Vector AtLocation);

// Export UWorldInfo::execGetAkEnvironmentName(FFrame&, void* const)
native function name GetAkEnvironmentName(Vector AtLocation);

// Export UWorldInfo::execLogGameBalance(FFrame&, void* const)
native function LogGameBalance(coerce string S);

// Export UWorldInfo::execTWLogsInit(FFrame&, void* const)
native function TWLogsInit();

// Export UWorldInfo::execTWLogEvent(FFrame&, void* const)
native function TWLogEvent(string EventName, PlayerReplicationInfo Info, coerce optional string P1, coerce optional string P2, coerce optional string P3, coerce optional string P4, coerce optional string P5, coerce optional string P6, coerce optional string P7, coerce optional string P8, coerce optional string P9);

// Export UWorldInfo::execTWPushLogs(FFrame&, void* const)
native function TWPushLogs();

// Export UWorldInfo::execTWRefreshTweakParams(FFrame&, void* const)
native function TWRefreshTweakParams();

// Export UWorldInfo::execTWApplyTweaks(FFrame&, void* const)
native function TWApplyTweaks();

defaultproperties
{
    bBumpOffsetEnabled=true
    bNoMobileMapWarnings=true
    bPlaceCellsOnSurfaces=true
    bCompressVisibilityData=true
    bAllowTemporalAA=true
    bUsePxVisibilityCollision=true
    bAllowExplosionLights=true
    DefaultPostProcessSettings=(bOverride_EnableBloom=false,bOverride_EnableDOF=false,bOverride_EnableMotionBlur=false,bOverride_EnableSceneEffect=false,bOverride_AllowAmbientOcclusion=false,bOverride_OverrideRimShaderColor=false,bOverride_EnableDistanceFog=false,bOverride_Bloom_Scale=true,bOverride_Bloom_Threshold=true,bOverride_Bloom_Tint=true,bOverride_Bloom_ScreenBlendThreshold=true,bOverride_Bloom_InterpolationDuration=true,bOverride_DOF_FalloffExponent=true,bOverride_DOF_BlurKernelSize=true,bOverride_DOF_BlurBloomKernelSize=true,bOverride_DOF_MaxNearBlurAmount=true,bOverride_DOF_MinBlurAmount=false,bOverride_DOF_MaxFarBlurAmount=true,bOverride_DOF_FocusType=true,bOverride_DOF_FocusInnerRadius=true,bOverride_DOF_FocusDistance=true,bOverride_DOF_FocusPosition=true,bOverride_DOF_InterpolationDuration=true,bOverride_DOF_BokehTexture=false,bOverride_MotionBlur_MaxVelocity=false,bOverride_MotionBlur_Amount=false,bOverride_MotionBlur_FullMotionBlur=false,bOverride_MotionBlur_CameraRotationThreshold=false,bOverride_MotionBlur_CameraTranslationThreshold=false,bOverride_MotionBlur_InterpolationDuration=false,bOverride_Scene_Desaturation=true,bOverride_Scene_Colorize=false,bOverride_Scene_TonemapperScale=false,bOverride_Scene_ImageGrainScale=false,bOverride_Scene_HighLights=true,bOverride_Scene_MidTones=true,bOverride_Scene_Shadows=true,bOverride_Scene_InterpolationDuration=true,bOverride_Scene_ColorGradingLUT=false,bOverride_RimShader_Color=true,bOverride_RimShader_InterpolationDuration=true,bOverride_MobileColorGrading=false,bEnableBloom=true,bEnableDOF=false,bEnableMotionBlur=true,bEnableSceneEffect=true,bAllowAmbientOcclusion=true,bOverrideRimShaderColor=false,bEnableDistanceFog=false,TripwireSettings=(bOverride_DOF_FocalDistance=false,DOF_FocalDistance=1000,bOverride_DOF_SharpRadius=false,DOF_SharpRadius=800,bOverride_DOF_FocalRadius=false,DOF_FocalRadius=1200,bOverride_DOF_MinBlurSize=false,DOF_MinBlurSize=0,bOverride_DOF_MaxNearBlurSize=false,DOF_MaxNearBlurSize=0,bOverride_DOF_MaxFarBlurSize=false,DOF_MaxFarBlurSize=0,bOverride_DOF_ExpFalloff=false,DOF_ExpFalloff=1,DOF_FG_SharpRadius=75,DOF_FG_FocalRadius=150,DOF_FG_MinBlurSize=0,DOF_FG_MaxNearBlurSize=0,DOF_FG_ExpFalloff=1,bOverride_Bloom_Intensity=false,Bloom_Intensity=1.05,bOverride_Bloom_Width=false,Bloom_Width=4,bOverride_Bloom_Exposure=false,Bloom_Exposure=1.25,bOverride_Bloom_Threshold=false,Bloom_Threshold=0.6,Bloom_InterpolationDuration=1,NoiseIntensity=1,bOverride_Fog_Start_Distance=false,Fog_Start_Distance=0,bOverride_Fog_MaxStrength_Distance=false,Fog_MaxStrength_Distance=10000,bOverride_Fog_AnimationCutoff_Distance=false,Fog_AnimationCutoff_Distance=8000,bOverride_Fog_Intensity=false,Fog_Intensity=0.3,bOverride_Fog_MinAmount=false,Fog_MinAmount=0.1,bOverride_Fog_Color=false,Fog_Color=(R=1,G=1,B=1,A=1),Fog_InterpolationDuration=3,MB_TileMaxEnabled=true,bForceGameplayDOF=false,bForceGameplayBloom=false,bForceGameplayImageGrain=false,bForceGameplayTranslucencyTint=false,bEnableScreenSpaceReflections=true,bBlurEnabled=false,BlurStrength=0),LegacySettings=(Bloom_Scale=1,Bloom_Threshold=1,Bloom_InterpolationDuration=1,DOF_BlurBloomKernelSize=16,DOF_FalloffExponent=4,DOF_BlurKernelSize=16,DOF_MaxNearBlurAmount=1,DOF_MinBlurAmount=0,DOF_MaxFarBlurAmount=1,DOF_FocusType=EFocusType.FOCUS_Distance,DOF_FocusInnerRadius=2000,DOF_FocusDistance=0,DOF_FocusPosition=(X=0,Y=0,Z=0),DOF_InterpolationDuration=1,DOF_BokehTexture=none,MotionBlur_MaxVelocity=1,MotionBlur_Amount=0.5,MotionBlur_FullMotionBlur=true,MotionBlur_CameraRotationThreshold=45,MotionBlur_CameraTranslationThreshold=10000,MotionBlur_InterpolationDuration=1,RimShader_Color=(R=0.47044,G=0.585973,B=0.827726,A=1),RimShader_InterpolationDuration=1,Scene_ImageGrainScale=0,MobileColorGrading=(TransitionTime=1,Blend=0,Desaturation=0,HighLights=(R=0.7,G=0.7,B=0.7,A=1),MidTones=(R=0,G=0,B=0,A=1),Shadows=(R=0,G=0,B=0,A=1)),MobilePostProcess=(bOverride_Mobile_BlurAmount=false,bOverride_Mobile_TransitionTime=false,bOverride_Mobile_Bloom_Scale=false,bOverride_Mobile_Bloom_Threshold=false,bOverride_Mobile_Bloom_Tint=false,bOverride_Mobile_DOF_Distance=false,bOverride_Mobile_DOF_MinRange=false,bOverride_Mobile_DOF_MaxRange=false,bOverride_Mobile_DOF_FarBlurFactor=false,Mobile_BlurAmount=16,Mobile_TransitionTime=1,Mobile_Bloom_Scale=0.5,Mobile_Bloom_Threshold=0.75,Mobile_Bloom_Tint=(R=1,G=1,B=1,A=1),Mobile_DOF_Distance=1500,Mobile_DOF_MinRange=600,Mobile_DOF_MaxRange=1200,Mobile_DOF_FarBlurFactor=1)),Bloom_Tint=(B=255,G=255,R=255,A=0),Bloom_ScreenBlendThreshold=10,Scene_Desaturation=0,Scene_Colorize=(X=1,Y=1,Z=1),Scene_TonemapperScale=1,Scene_HighLights=(X=1,Y=1,Z=1),Scene_MidTones=(X=1,Y=1,Z=1),Scene_Shadows=(X=0,Y=0,Z=0),Scene_InterpolationDuration=0,ColorGrading_LookupTable=none,ColorGradingLUT=(LUTTextures=none,LUTWeights=none))
    SquintModeKernelSize=128
    LevelShadowDepthBias=0.012
    DefaultReverbSettings=(bApplyReverb=true,ReverbType=ReverbPreset.REVERB_Default,Volume=0.5,FadeTime=2)
    DefaultAmbientZoneSettings=(bIsWorldInfo=true,ExteriorVolume=1,ExteriorTime=0.5,ExteriorLPF=1,ExteriorLPFTime=0.5,InteriorVolume=1,InteriorTime=0.5,InteriorLPF=1,InteriorLPFTime=0.5)
    FogStart=400
    FogEnd=4000
    FogColor=(B=255,G=128,R=128,A=192)
    BumpEnd=1000
    TimeDilation=1
    DemoPlayTimeDilation=1
    VisibleLayers="None"
    DefaultTexture=Texture2D'EngineResources.DefaultTexture'
    WhiteSquareTexture=Texture2D'EngineResources.WhiteSquareTexture'
    LargeVertex=Texture2D'EditorResources.LargeVertex'
    BSPVertex=Texture2D'EditorResources.BSPVertex'
    NextTravelType=ETravelType.TRAVEL_Relative
    LevelLightingQuality=ELightingBuildQuality.None
    StallZ=1000000
    DefaultGravityZ=-750
    GlobalGravityZ=-1150
    RBPhysicsGravityScaling=1
    MoveRepSize=42
    PackedLightAndShadowMapTextureSize=1024
    DefaultColorScale=(X=1,Y=1,Z=1)
    CurrentMusicTrack=(TheSoundCue=none,bAutoPlay=false,bPersistentAcrossLevels=false,FadeInTime=5,FadeInVolumeLevel=1,FadeOutTime=5,FadeOutVolumeLevel=0,MP3Filename="")
    ReplicatedMusicTrack=(TheSoundCue=none,bAutoPlay=false,bPersistentAcrossLevels=false,FadeInTime=5,FadeInVolumeLevel=1,FadeOutTime=5,FadeOutVolumeLevel=0,MP3Filename="")
    EmitterPoolClassPath="Engine.EmitterPool"
    DecalManagerClassPath="Engine.DecalManager"
    FractureManagerClassPath="Engine.FractureManager"
    MaxPhysicsDeltaTime=0.3333333
    MaxPhysicsSubsteps=5
    PhysicsProperties=(PrimaryScene=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=5),CompartmentRigidBody=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=2),CompartmentFluid=(bUseHardware=true,bFixedTimeStep=false,TimeStep=0.02,MaxSubSteps=1),CompartmentCloth=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.02,MaxSubSteps=2),CompartmentSoftBody=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.02,MaxSubSteps=2))
    DefaultSkinWidth=0.025
    ApexLODResourceBudget=-1
    ApexDestructionLODResourceValue=1000
    ApexClothingLODResourceValue=1000
    DestructibleSettings=(MaxChunkIslandCount=-1,MaxShapeCount=-1,MaxRrbActorCount=-1,MaxChunkSeparationLOD=1,bOverrideMaxChunkSeparationLOD=false)
    EmitterVertical=PhysicsLODVerticalEmitter'Default__WorldInfo.PhysicsLODVerticalEmitter0'
    VerticalProperties=(Emitters=(bDisableLod=true,ParticlesLodMin=0,ParticlesLodMax=15000,PacketsPerPhysXParticleSystemMax=500,bApplyCylindricalPacketCulling=true,SpawnLodVsFifoBias=1))
    ChanceOfPhysicsChunkOverride=1
    FractureExplosionVelScale=1
    MaxNumFacturedChunksToSpawnInAFrame=12
    FracturedMeshWeaponDamage=1
    VisibilityCellSize=200
    VisibilitySpreadingIterations=1
    MeshBoundsScale=1.1
    PlayAreaHeight=172
    MinMeshSamples=28
    MaxMeshSamples=80
    NumCellSamples=24
    NumImportanceSamples=40
    CellRenderingBucketSize=5
    NumCellRenderingBuckets=5
    NumCellDistributionBuckets=800
    CharacterLitIndirectBrightness=1
    CharacterLitIndirectContrastFactor=1
    CharacterShadowedIndirectBrightness=1
    CharacterShadowedIndirectContrastFactor=1
    CharacterLightingContrastFactor=1.5
    ImageReflectionEnvironmentColor=(R=1,G=1,B=1,A=1)
    MaxTrianglesPerLeaf=4
    LightmassSettings=(StaticLightingLevelScale=1,NumIndirectLightingBounces=3,EnvironmentColor=(B=0,G=0,R=0,A=0),EnvironmentIntensity=1,bEnableAdvancedEnvironmentColor=false,EnvironmentSunColor=(B=0,G=0,R=0,A=0),EnvironmentSunIntensity=1,EnvironmentLightTerminatorAngle=90,EnvironmentLightDirection=(X=0,Y=0,Z=0),EmissiveBoost=1,DiffuseBoost=5,SpecularBoost=1,IndirectNormalInfluenceBoost=0.3,bUseAmbientOcclusion=false,bEnableImageReflectionShadowing=false,DirectIlluminationOcclusionFraction=0.5,IndirectIlluminationOcclusionFraction=1,OcclusionExponent=1,FullyOccludedSamplesFraction=1,MaxOcclusionDistance=200,bVisualizeMaterialDiffuse=false,bVisualizeAmbientOcclusion=false,bCompressShadowmap=false)
    HostMigrationTimeout=15
    FlickerCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Constant)
    PulseCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_CurveAuto)
    StrobeCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Constant)
    ChaoticFlickerCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=0,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Constant)
    InverseChaoticFlickerCurve=(Points=/* Array type was not detected. */,InVal=0,OutVal=1,ArriveTangent=0,LeaveTangent=0,InterpMode=EInterpCurveMode.CIM_Constant)
    EmitterPoolScale=1
    DestructionLifetimeScale=1
    ImpactEffectManagerClassPath="KFGame.KFImpactEffectManager"
    GoreEffectManagerClassPath="KFGame.KFGoreManager"
    GroundFireEmitterPoolClassPath="KFGame.GroundFireEmitterPool"
    ImpactFXEmitterPoolClassPath="KFGame.KFImpactFXEmitterPool"
    MaxExplosionDecals=15
    LastSuccessfulPathBuildTime="Never!"
    Components=none
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bWorldGeometry=true
    bAlwaysRelevant=true
    bMovable=false
    bBlockActors=true
    bHiddenEd=true
}