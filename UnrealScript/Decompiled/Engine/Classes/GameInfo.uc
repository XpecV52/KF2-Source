/*******************************************************************************
 * GameInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameInfo extends Info
    native
    config(Game)
    notplaceable
    hidecategories(Navigation,Movement,Collision);

enum EStandbyType
{
    STDBY_Rx,
    STDBY_Tx,
    STDBY_BadPing,
    STDBY_MAX
};

struct native GameClassShortName
{
    var string ShortName;
    var string GameClassName;

    structdefaultproperties
    {
        ShortName=""
        GameClassName=""
    }
};

struct native GameTypePrefix
{
    var string Prefix;
    var bool bUsesCommonPackage;
    var string GameType;
    var array<string> AdditionalGameTypes;
    var array<string> ForcedObjects;

    structdefaultproperties
    {
        Prefix=""
        bUsesCommonPackage=false
        GameType=""
        AdditionalGameTypes=none
        ForcedObjects=none
    }
};

var bool bRestartLevel;
var bool bPauseable;
var bool bTeamGame;
var bool bGameEnded;
var bool bOverTime;
var bool bDelayedStart;
var bool bWaitingToStartMatch;
var globalconfig bool bChangeLevels;
var bool bAlreadyChanged;
var globalconfig bool bAdminCanPause;
var bool bGameRestarted;
var bool bLevelChange;
var globalconfig bool bKickLiveIdlers;
var bool bUsingArbitration;
var bool bHasArbitratedHandshakeBegun;
var bool bNeedsEndGameHandshake;
var bool bIsEndGameHandshakeComplete;
var bool bHasEndGameHandshakeBegun;
var bool bFixedPlayerStart;
var bool bDoFearCostFallOff;
var bool bUseSeamlessTravel;
var bool bHasNetworkError;
var const bool bRequiresPushToTalk;
var config bool bIsStandbyCheckingEnabled;
var bool bIsStandbyCheckingOn;
var bool bHasStandbyCheatTriggered;
var string CauseEventCommand;
var string BugLocString;
var string BugRotString;
var array<PlayerController> PendingArbitrationPCs;
var array<PlayerController> ArbitrationPCs;
var globalconfig float ArbitrationHandshakeTimeout;
var globalconfig float GameDifficulty;
var globalconfig int GoreLevel;
var float GameSpeed;
var class<Pawn> DefaultPawnClass;
var class<HUD> HUDType;
var class<HUD> SecondaryHUDType;
var globalconfig int MaxSpectators;
var int MaxSpectatorsAllowed;
var int NumSpectators;
var config int MaxPlayers;
var int MaxPlayersAllowed;
var int NumPlayers;
var int NumBots;
var int NumTravellingPlayers;
var int CurrentID;
var const localized string DefaultPlayerName;
var const localized string GameName;
var float FearCostFallOff;
var config int GoalScore;
var config int MaxLives;
var config int TimeLimit;
var class<LocalMessage> DeathMessageClass;
var class<GameMessage> GameMessageClass;
var Mutator BaseMutator;
var class<AccessControl> AccessControlClass;
var AccessControl AccessControl;
var class<BroadcastHandler> BroadcastHandlerClass;
var BroadcastHandler BroadcastHandler;
var class<AutoTestManager> AutoTestManagerClass;
var AutoTestManager MyAutoTestManager;
var class<PlayerController> PlayerControllerClass;
var class<PlayerReplicationInfo> PlayerReplicationInfoClass;
/** ReplicationInfo */
var() class<GameReplicationInfo> GameReplicationInfoClass;
var GameReplicationInfo GameReplicationInfo;
var CrowdPopulationManagerBase PopulationManager;
var class<CrowdPopulationManagerBase> PopulationManagerClass;
var globalconfig float MaxIdleTime;
var globalconfig float MaxTimeMargin;
var globalconfig float TimeMarginSlack;
var globalconfig float MinTimeMargin;
var array<PlayerReplicationInfo> InactivePRIArray;
var array< delegate<CanUnpause> > Pausers;
var OnlineSubsystem OnlineSub;
var PlayfabInterface PlayfabInter;
var OnlineGameInterface GameInterface;
var class<OnlineStatsWrite> OnlineStatsWriteClass;
var int LeaderboardId;
var int ArbitratedLeaderboardId;
var protected CoverReplicator CoverReplicatorBase;
var const class<OnlineGameSettings> OnlineGameSettingsClass;
var string ServerOptions;
var int AdjustedNetSpeed;
var float LastNetSpeedUpdateTime;
var globalconfig int TotalNetBandwidth;
var globalconfig int MinDynamicBandwidth;
var globalconfig int MaxDynamicBandwidth;
var config float StandbyRxCheatTime;
var config float StandbyTxCheatTime;
var config int BadPingThreshold;
var config float PercentMissingForRxStandby;
var config float PercentMissingForTxStandby;
var config float PercentForBadPing;
var config float JoinInProgressStandbyWaitTime;
var Material StreamingPauseIcon;
var() protected const array<GameClassShortName> GameInfoClassAliases;
var config string DefaultGameType;
var config array<config GameTypePrefix> DefaultMapPrefixes;
var config array<config GameTypePrefix> CustomMapPrefixes;
var config int AnimTreePoolSize;
var delegate<CanUnpause> __CanUnpause__Delegate;

// Export UGameInfo::execGetSupportedGameTypes(FFrame&, void* const)
native function bool GetSupportedGameTypes(const out string InFilename, out GameTypePrefix OutGameType, optional bool bCheckExt)
{
    bCheckExt = false;                    
}

// Export UGameInfo::execGetMapCommonPackageName(FFrame&, void* const)
native function bool GetMapCommonPackageName(const out string InFilename, out string OutCommonPackageName);

event PreBeginPlay()
{
    AdjustedNetSpeed = MaxDynamicBandwidth;
    SetGameSpeed(GameSpeed);
    GameReplicationInfo = Spawn(GameReplicationInfoClass);
    WorldInfo.GRI = GameReplicationInfo;
    InitGameReplicationInfo();
    InitCrowdPopulationManager();
}

function CoverReplicator GetCoverReplicator()
{
    if((CoverReplicatorBase == none) && WorldInfo.NetMode != NM_Standalone)
    {
        CoverReplicatorBase = Spawn(Class'CoverReplicator');
    }
    return CoverReplicatorBase;
}

event PostBeginPlay()
{
    local OnlineGameSettings GameSettings;

    if(MaxIdleTime > float(0))
    {
        MaxIdleTime = FMax(MaxIdleTime, 20);
    }
    PlayfabInter = Class'GameEngine'.static.GetPlayfabInterface();
    if(WorldInfo.IsConsoleDedicatedServer())
    {
        if((PlayfabInter != none) && PlayfabInter.GetGameSettings() == none)
        {
            PlayfabInter.CreateGameSettings(OnlineGameSettingsClass);
            GameSettings = PlayfabInter.GetGameSettings();
            GameSettings.UpdateFromURL(ServerOptions, self);
            if(!WasLaunchedByPlayfab())
            {
                UpdateGameSettings();
                PlayfabInter.ServerRegisterGame();
            }
        }        
    }
    else
    {
        if(WorldInfo.NetMode == NM_DedicatedServer)
        {
            UpdateGameSettings();
        }
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawText("Game:" $ GameName);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(WorldInfo.PopulationManager != none)
    {
        WorldInfo.PopulationManager.DisplayDebug(HUD, out_YL, out_YPos);
    }
}

function Reset()
{
    super(Actor).Reset();
    bGameEnded = false;
    bOverTime = false;
    InitGameReplicationInfo();
}

function bool ShouldReset(Actor ActorToReset)
{
    return true;
}

function ResetLevel()
{
    local Controller C;
    local Actor A;
    local Sequence GameSeq;
    local array<SequenceObject> AllSeqEvents;
    local array<int> ActivateIndices;
    local int I;

    LogInternal("Reset" @ string(self));
    foreach WorldInfo.AllControllers(Class'Controller', C)
    {
        if(PlayerController(C) != none)
        {
            PlayerController(C).ClientReset();
        }
        C.Reset();        
    }    
    foreach AllActors(Class'Actor', A)
    {
        if(((A != self) && !A.IsA('Controller')) && ShouldReset(A))
        {
            A.Reset();
        }        
    }    
    Reset();
    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.Reset();
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_LevelLoaded', true, AllSeqEvents);
        ActivateIndices[0] = 2;
        I = 0;
        J0x1D8:

        if(I < AllSeqEvents.Length)
        {
            SeqEvent_LevelLoaded(AllSeqEvents[I]).CheckActivate(WorldInfo, none, false, ActivateIndices);
            ++ I;
            goto J0x1D8;
        }
    }
}

event Timer()
{
    BroadcastHandler.UpdateSentText();
    if(bDoFearCostFallOff)
    {
        DoNavFearCostFallOff();
    }
}

// Export UGameInfo::execShouldStartInCinematicMode(FFrame&, void* const)
native final function bool ShouldStartInCinematicMode(out int OutHidePlayer, out int OutHideHud, out int OutDisableMovement, out int OutDisableTurning, out int OutDisableInput);

// Export UGameInfo::execDoNavFearCostFallOff(FFrame&, void* const)
native final function DoNavFearCostFallOff();

function NotifyNavigationChanged(NavigationPoint N);

event GameEnding()
{
    if(AccessControl != none)
    {
        AccessControl.NotifyGameEnding();
    }
    ClearOnlineDelegates();
    EndLogging("serverquit");
}

event KickIdler(PlayerController PC)
{
    LogInternal("Kicking idle player " $ PC.PlayerReplicationInfo.PlayerName);
    AccessControl.KickPlayer(PC, AccessControl.IdleKickReason);
}

event ForceKickPlayer(PlayerController PC, string KickReason)
{
    LogInternal("Force kicking player " $ PC.PlayerReplicationInfo.PlayerName);
    AccessControl.ForceKickPlayer(PC, KickReason);
}

function InitGameReplicationInfo()
{
    GameReplicationInfo.GameClass = Class;
    GameReplicationInfo.ReceivedGameClass();
}

// Export UGameInfo::execGetNetworkNumber(FFrame&, void* const)
native function string GetNetworkNumber();

function int GetNumPlayers()
{
    return NumPlayers + NumTravellingPlayers;
}

delegate bool CanUnpause()
{
    return true;
}

function bool SetPause(PlayerController PC, optional delegate<CanUnpause> CanUnpauseDelegate)
{
    local int FoundIndex;

    CanUnpauseDelegate = CanUnpause;
    if(AllowPausing(PC))
    {
        FoundIndex = Pausers.Find(CanUnpauseDelegate;
        if(FoundIndex == -1)
        {
            FoundIndex = Pausers.Length;
            Pausers.Length = FoundIndex + 1;
            Pausers[FoundIndex] = CanUnpauseDelegate;
        }
        if(WorldInfo.Pauser == none)
        {
            WorldInfo.Pauser = PC.PlayerReplicationInfo;
        }
        return true;
    }
    return false;
}

event ClearPause()
{
    local int Index;
    local delegate<CanUnpause> CanUnpauseCriteriaMet;

    if(!AllowPausing() && Pausers.Length > 0)
    {
        LogInternal(("Clearing list of UnPause delegates for" @ string(Name)) @ "because game type is not pauseable");
        Pausers.Length = 0;
    }
    Index = 0;
    J0x97:

    if(Index < Pausers.Length)
    {
        CanUnpauseCriteriaMet = Pausers[Index];
        if(CanUnpause())
        {
            Pausers.Remove(-- Index, 1;
        }
        ++ Index;
        goto J0x97;
    }
    if(Pausers.Length == 0)
    {
        WorldInfo.Pauser = none;
    }
}

// Export UGameInfo::execForceClearUnpauseDelegates(FFrame&, void* const)
native final function ForceClearUnpauseDelegates(Actor PauseActor);

function DebugPause()
{
    local int Index;
    local delegate<CanUnpause> CanUnpauseCriteriaMet;

    Index = 0;
    J0x0B:

    if(Index < Pausers.Length)
    {
        CanUnpauseCriteriaMet = Pausers[Index];
        if(CanUnpause())
        {
            LogInternal((("Pauser in index " $ string(Index)) $ " thinks it's ok to unpause:") @ string(CanUnpauseCriteriaMet));            
        }
        else
        {
            LogInternal((("Pauser in index " $ string(Index)) $ " thinks the game should remain paused:") @ string(CanUnpauseCriteriaMet));
        }
        ++ Index;
        goto J0x0B;
    }
}

function SetGameSpeed(float T)
{
    GameSpeed = FMax(T, 1E-05);
    WorldInfo.TimeDilation = GameSpeed;
    SetTimer(WorldInfo.TimeDilation, true);
}

static function bool GrabOption(out string Options, out string Result)
{
    if(Left(Options, 1) == "?")
    {
        Result = Mid(Options, 1);
        if(InStr(Result, "?") >= 0)
        {
            Result = Left(Result, InStr(Result, "?"));
        }
        Options = Mid(Options, 1);
        if(InStr(Options, "?") >= 0)
        {
            Options = Mid(Options, InStr(Options, "?"));            
        }
        else
        {
            Options = "";
        }
        return true;        
    }
    else
    {
        return false;
    }
}

static function GetKeyValue(string Pair, out string Key, out string Value)
{
    if(InStr(Pair, "=") >= 0)
    {
        Key = Left(Pair, InStr(Pair, "="));
        Value = Mid(Pair, InStr(Pair, "=") + 1);        
    }
    else
    {
        Key = Pair;
        Value = "";
    }
}

static function string ParseOption(string Options, string InKey)
{
    local string Pair, Key, Value;

    J0x00:
    if(GrabOption(Options, Pair))
    {
        GetKeyValue(Pair, Key, Value);
        if(Key ~= InKey)
        {
            return Value;
        }
        goto J0x00;
    }
    return "";
}

static function bool HasOption(string Options, string InKey)
{
    local string Pair, Key, Value;

    J0x00:
    if(GrabOption(Options, Pair))
    {
        GetKeyValue(Pair, Key, Value);
        if(Key ~= InKey)
        {
            return true;
        }
        goto J0x00;
    }
    return false;
}

static function int GetIntOption(string Options, string ParseString, int CurrentValue)
{
    local string InOpt;

    InOpt = ParseOption(Options, ParseString);
    if(InOpt != "")
    {
        return int(InOpt);
    }
    return CurrentValue;
}

static event string GetDefaultGameClassPath(string MapName, string Options, string Portal)
{
    return PathName(default.Class);
}

static event class<GameInfo> SetGameType(string MapName, string Options, string Portal)
{
    return default.Class;
}

event InitGame(string Options, out string ErrorMessage)
{
    local string InOpt, LeftOpt;
    local int pos;
    local class<AccessControl> ACClass;
    local AccessControl CurAC;
    local OnlineGameSettings GameSettings;

    MaxPlayers = Clamp(GetIntOption(Options, "MaxPlayers", MaxPlayers), 0, MaxPlayersAllowed);
    MaxSpectators = Clamp(GetIntOption(Options, "MaxSpectators", MaxSpectators), 0, MaxSpectatorsAllowed);
    GameDifficulty = FMax(0, float(GetIntOption(Options, "Difficulty", int(GameDifficulty))));
    InOpt = ParseOption(Options, "GameSpeed");
    if(InOpt != "")
    {
        LogInternal("GameSpeed" @ InOpt);
        SetGameSpeed(float(InOpt));
    }
    TimeLimit = Max(0, GetIntOption(Options, "TimeLimit", TimeLimit));
    BroadcastHandler = Spawn(BroadcastHandlerClass);
    InOpt = ParseOption(Options, "AccessControl");
    if(InOpt != "")
    {
        ACClass = class<AccessControl>(DynamicLoadObject(InOpt, Class'Class'));
    }
    if(ACClass == none)
    {
        ACClass = AccessControlClass;
    }
    LeftOpt = ParseOption(Options, "AdminName");
    InOpt = ParseOption(Options, "AdminPassword");
    if((WorldInfo.NetMode == NM_ListenServer) || WorldInfo.NetMode == NM_DedicatedServer)
    {
        if(WorldInfo.IsInSeamlessTravel())
        {
            foreach DynamicActors(Class'AccessControl', CurAC)
            {
                AccessControl = CurAC;
                break;                
            }            
        }
        if(AccessControl == none)
        {
            AccessControl = Spawn(ACClass);
        }
        if((AccessControl != none) && InOpt != "")
        {
            AccessControl.SetAdminPassword(InOpt);
        }
    }
    InOpt = ParseOption(Options, "Mutator");
    if(InOpt != "")
    {
        LogInternal("Mutators" @ InOpt);
        J0x3CB:

        if(InOpt != "")
        {
            pos = InStr(InOpt, ",");
            if(pos > 0)
            {
                LeftOpt = Left(InOpt, pos);
                InOpt = Right(InOpt, (Len(InOpt) - pos) - 1);                
            }
            else
            {
                LeftOpt = InOpt;
                InOpt = "";
            }
            AddMutator(LeftOpt, true);
            goto J0x3CB;
        }
    }
    InOpt = ParseOption(Options, "GamePassword");
    if((InOpt != "") && AccessControl != none)
    {
        AccessControl.SetGamePassword(InOpt);
        LogInternal("GamePassword" @ InOpt);
    }
    bFixedPlayerStart = (ParseOption(Options, "FixedPlayerStart")) ~= "1";
    CauseEventCommand = ParseOption(Options, "causeevent");
    if((ParseOption(Options, "AutoTests")) ~= "1")
    {
        if(MyAutoTestManager == none)
        {
            MyAutoTestManager = Spawn(AutoTestManagerClass);
        }
        MyAutoTestManager.InitializeOptions(Options);
    }
    BugLocString = ParseOption(Options, "BugLoc");
    BugRotString = ParseOption(Options, "BugRot");
    if(BaseMutator != none)
    {
        BaseMutator.InitMutator(Options, ErrorMessage);
    }
    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        GameInterface = OnlineSub.GameInterface;
        if(NotEqual_InterfaceInterface(GameInterface, (none)))
        {
            GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
            if(GameSettings != none)
            {
                bUsingArbitration = GameSettings.bUsesArbitration;
            }
        }
    }
    if(((WorldInfo.IsConsoleBuild(0) == false) && WorldInfo.NetMode != NM_Standalone) && GameSettings == none)
    {
        ServerOptions = Options;
        if(!ProcessServerLogin())
        {
            RegisterServer();
        }
    }
}

event NotifyPendingConnectionLost();

function AddMutator(string mutname, optional bool bUserAdded)
{
    local class<Mutator> mutClass;
    local Mutator mut;
    local int I;

    if(!AllowMutator(mutname))
    {
        return;
    }
    mutClass = class<Mutator>(DynamicLoadObject(mutname, Class'Class'));
    if(mutClass == none)
    {
        return;
    }
    if((mutClass.default.GroupNames.Length > 0) && BaseMutator != none)
    {
        mut = BaseMutator;
        J0xA5:

        if(mut != none)
        {
            I = 0;
            J0xBF:

            if(I < mut.GroupNames.Length)
            {
                if(mutClass.default.GroupNames.Find(mut.GroupNames[I] != -1)
                {
                    LogInternal((("Not adding " $ string(mutClass)) $ " because already have a mutator in the same group - ") $ string(mut));
                    return;
                }
                ++ I;
                goto J0xBF;
            }
            mut = mut.NextMutator;
            goto J0xA5;
        }
    }
    mut = BaseMutator;
    J0x1F0:

    if(mut != none)
    {
        if(mut.Class == mutClass)
        {
            LogInternal((("Not adding " $ string(mutClass)) $ " because this mutator is already added - ") $ string(mut));
            return;
        }
        mut = mut.NextMutator;
        goto J0x1F0;
    }
    mut = Spawn(mutClass);
    if(mut == none)
    {
        return;
    }
    mut.bUserAdded = bUserAdded;
    if(BaseMutator == none)
    {
        BaseMutator = mut;        
    }
    else
    {
        BaseMutator.AddMutator(mut);
    }
}

function RemoveMutator(Mutator MutatorToRemove)
{
    local Mutator M;

    if(BaseMutator == MutatorToRemove)
    {
        BaseMutator = MutatorToRemove.NextMutator;        
    }
    else
    {
        if(BaseMutator != none)
        {
            M = BaseMutator;
            J0x64:

            if(M != none)
            {
                if(M.NextMutator == MutatorToRemove)
                {
                    M.NextMutator = MutatorToRemove.NextMutator;
                    goto J0x10A;
                }
                M = M.NextMutator;
                goto J0x64;
            }
        }
    }
    J0x10A:

}

function ProcessServerTravel(string URL, optional bool bAbsolute)
{
    local PlayerController LocalPlayer;
    local bool bSeamless;
    local string NextMap;
    local Guid NextMapGuid;
    local int OptionStart;

    bLevelChange = true;
    EndLogging("mapchange");
    bSeamless = bUseSeamlessTravel && WorldInfo.TimeSeconds < 172800;
    if(InStr(Caps(URL), "?RESTART") != -1)
    {
        NextMap = string(WorldInfo.GetPackageName());        
    }
    else
    {
        OptionStart = InStr(URL, "?");
        if(OptionStart == -1)
        {
            NextMap = URL;            
        }
        else
        {
            NextMap = Left(URL, OptionStart);
        }
    }
    NextMapGuid = GetPackageGuid(name(NextMap));
    LocalPlayer = ProcessClientTravel(URL, NextMapGuid, bSeamless, bAbsolute);
    LogInternal("ProcessServerTravel:" @ URL);
    WorldInfo.NextURL = URL;
    if((WorldInfo.NetMode == NM_ListenServer) && LocalPlayer != none)
    {        
        WorldInfo.NextURL $= ((((((("?Team=" $ LocalPlayer.GetDefaultURL("Team")) $ "?Name=") $ LocalPlayer.GetDefaultURL("Name")) $ "?Class=") $ LocalPlayer.GetDefaultURL("Class")) $ "?Character=") $ LocalPlayer.GetDefaultURL("Character"));
    }
    if(AccessControl != none)
    {
        AccessControl.NotifyServerTravel(bSeamless);
    }
    ClearOnlineDelegates();
    if(bSeamless)
    {
        WorldInfo.SeamlessTravel(WorldInfo.NextURL, bAbsolute);
        WorldInfo.NextURL = "";        
    }
    else
    {
        if((WorldInfo.NetMode != NM_DedicatedServer) && WorldInfo.NetMode != NM_ListenServer)
        {
            WorldInfo.NextSwitchCountdown = 0;
        }
    }
}

function PlayerController ProcessClientTravel(out string URL, Guid NextMapGuid, bool bSeamless, bool bAbsolute)
{
    local PlayerController P, LP;

    foreach WorldInfo.AllControllers(Class'PlayerController', P)
    {
        if(NetConnection(P.Player) != none)
        {
            P.ClientTravel(URL, 2, bSeamless, NextMapGuid);
            continue;
        }
        LP = P;
        P.PreClientTravel(URL, ((bAbsolute) ? 0 : 2), bSeamless);        
    }    
    return LP;
}

function bool RequiresPassword()
{
    return (AccessControl != none) && AccessControl.RequiresPassword();
}

event PreLogin(string Options, string Address, const UniqueNetId UniqueId, bool bSupportsAuth, out string ErrorMessage)
{
    local bool bSpectator, bPerfTesting;

    if(((WorldInfo.NetMode != NM_Standalone) && bUsingArbitration) && bHasArbitratedHandshakeBegun)
    {
        ErrorMessage = PathName(WorldInfo.Game.GameMessageClass) $ ".ArbitrationMessage";
        return;
    }
    if((AccessControl != none) && AccessControl.IsIDBanned(UniqueId))
    {
        LogInternal(Address @ "is banned, rejecting...");
        ErrorMessage = "Engine.AccessControl.SessionBanned";
        return;
    }
    bPerfTesting = (ParseOption(Options, "AutomatedPerfTesting")) ~= "1";
    bSpectator = (bPerfTesting || (ParseOption(Options, "SpectatorOnly")) ~= "1") || (ParseOption(Options, "CauseEvent")) ~= "FlyThrough";
    if(AccessControl != none)
    {
        AccessControl.PreLogin(Options, Address, UniqueId, bSupportsAuth, ErrorMessage, bSpectator);
    }
}

// Export UGameInfo::execPauseLogin(FFrame&, void* const)
native static final function Player PauseLogin();

// Export UGameInfo::execResumeLogin(FFrame&, void* const)
native static final function ResumeLogin(Player InPlayer);

// Export UGameInfo::execRejectLogin(FFrame&, void* const)
native static final function RejectLogin(Player InPlayer, string Error);

function bool AtCapacity(bool bSpectator, const optional UniqueNetId PlayerID)
{
    if(WorldInfo.NetMode == NM_Standalone)
    {
        return false;
    }
    if(bSpectator)
    {
        return (NumSpectators >= MaxSpectators) && (WorldInfo.NetMode != NM_ListenServer) || NumPlayers > 0;        
    }
    else
    {
        return (MaxPlayers > 0) && (GetNumPlayers()) >= MaxPlayers;
    }
}

// Export UGameInfo::execGetNextPlayerID(FFrame&, void* const)
native final function int GetNextPlayerID();

function PlayerController SpawnPlayerController(Vector SpawnLocation, Rotator SpawnRotation)
{
    return Spawn(PlayerControllerClass,,, SpawnLocation, SpawnRotation);
}

event PlayerController Login(string Portal, string Options, const UniqueNetId UniqueId, out string ErrorMessage)
{
    local NavigationPoint StartSpot;
    local PlayerController NewPlayer;
    local string InName, inCharacter, InPassword;
    local byte InTeam;
    local bool bSpectator, bAdmin, bPerfTesting;
    local Rotator SpawnRotation;
    local UniqueNetId ZeroId;

    bAdmin = false;
    if(bUsingArbitration && bHasArbitratedHandshakeBegun)
    {
        ErrorMessage = ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".ArbitrationMessage>";
        return none;
    }
    if(BaseMutator != none)
    {
        BaseMutator.ModifyLogin(Portal, Options);
    }
    bPerfTesting = (ParseOption(Options, "AutomatedPerfTesting")) ~= "1";
    bSpectator = bPerfTesting || (ParseOption(Options, "SpectatorOnly")) ~= "1";
    InName = Left(ParseOption(Options, "Name"), 32);
    InTeam = byte(GetIntOption(Options, "Team", 255));
    InPassword = ParseOption(Options, "Password");
    if(AccessControl != none)
    {
        bAdmin = AccessControl.ParseAdminOptions(Options);
    }
    if(!bAdmin && AtCapacity(bSpectator))
    {
        ErrorMessage = ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".MaxedOutMessage>";
        return none;
    }
    if((WorldInfo.Game.AccessControl != none) && WorldInfo.Game.AccessControl.IsIDBanned(UniqueId))
    {
        LogInternal(InName @ "is banned, rejecting...");
        ErrorMessage = "<Strings:Engine.AccessControl.SessionBanned>";
        return none;
    }
    if(bAdmin && AtCapacity(false))
    {
        bSpectator = true;
    }
    InTeam = PickTeam(InTeam, none, UniqueId);
    StartSpot = FindPlayerStart(none, InTeam, Portal);
    if(StartSpot == none)
    {
        ErrorMessage = ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".FailedPlaceMessage>";
        return none;
    }
    SpawnRotation.Yaw = StartSpot.Rotation.Yaw;
    NewPlayer = SpawnPlayerController(StartSpot.Location, SpawnRotation);
    if(NewPlayer == none)
    {
        LogInternal("Couldn't spawn player controller of class " $ string(PlayerControllerClass));
        ErrorMessage = ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".FailedSpawnMessage>";
        return none;
    }
    NewPlayer.StartSpot = StartSpot;
    NewPlayer.PlayerReplicationInfo.PlayerID = GetNextPlayerID();
    if((AccessControl == none) || !AccessControl.IsPendingAuth(UniqueId))
    {
        NewPlayer.PlayerReplicationInfo.SetUniqueId(UniqueId);
    }
    if(((OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none))) && UniqueId != ZeroId)
    {
        WorldInfo.Game.OnlineSub.GameInterface.RegisterPlayer(PlayerReplicationInfoClass.default.SessionName, UniqueId, HasOption(Options, "bIsFromInvite"));
    }
    RecalculateSkillRating();
    if(InName == "")
    {
        InName = DefaultPlayerName $ string(NewPlayer.PlayerReplicationInfo.PlayerID);
    }
    ChangeName(NewPlayer, InName, false);
    inCharacter = ParseOption(Options, "Character");
    NewPlayer.SetCharacter(inCharacter);
    if((bSpectator || NewPlayer.PlayerReplicationInfo.bOnlySpectator) || !ChangeTeam(NewPlayer, InTeam, false))
    {
        NewPlayer.GotoState('Spectating');
        NewPlayer.PlayerReplicationInfo.bOnlySpectator = true;
        NewPlayer.PlayerReplicationInfo.bIsSpectator = true;
        NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
        return NewPlayer;
    }
    if((AccessControl != none) && AccessControl.AdminLogin(NewPlayer, InPassword))
    {
        AccessControl.AdminEntered(NewPlayer);
    }
    if(bDelayedStart)
    {
        NewPlayer.GotoState('PlayerWaiting');
        return NewPlayer;
    }
    return NewPlayer;
}

static function bool AllowAnalyticsLogging();

function ScoreDamage(int DamageAmount, int HealthBeforeDamage, Controller InstigatedBy, Pawn DamagedPawn, class<DamageType> DamageType);

event bool SeatPlayer(const UniqueNetId SeatedPlayerID);

event MakeReservations(const string URLOptions, const UniqueNetId PlayerID, out string OutError);

event bool ConfirmReservation(const UniqueNetId PlayerID);

// Export UGameInfo::execSetNeedsRestart(FFrame&, void* const)
native function SetNeedsRestart();

// Export UGameInfo::execSetNeedsReload(FFrame&, void* const)
native function SetNeedsReload();

function StartMatch()
{
    local Actor A;

    if(MyAutoTestManager != none)
    {
        MyAutoTestManager.StartMatch();
    }
    foreach AllActors(Class'Actor', A)
    {
        A.MatchStarting();        
    }    
    StartHumans();
    StartBots();
    bWaitingToStartMatch = false;
    StartOnlineGame();
    WorldInfo.NotifyMatchStarted();
}

function StartOnlineGame()
{
    local PlayerController PC;

    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            if(!PC.IsLocalPlayerController())
            {
                PC.ClientStartOnlineGame();
            }            
        }        
        GameInterface.AddStartOnlineGameCompleteDelegate(OnStartOnlineGameComplete);
        GameInterface.StartOnlineGame(PlayerReplicationInfoClass.default.SessionName);        
    }
    else
    {
        GameReplicationInfo.StartMatch();
    }
}

function OnStartOnlineGameComplete(name SessionName, bool bWasSuccessful)
{
    local PlayerController PC;
    local string StatGuid;

    GameInterface.ClearStartOnlineGameCompleteDelegate(OnStartOnlineGameComplete);
    if(bWasSuccessful && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none)))
    {
        StatGuid = OnlineSub.StatsInterface.GetHostStatGuid();
        if(StatGuid != "")
        {
            foreach WorldInfo.AllControllers(Class'PlayerController', PC)
            {
                if(PC.IsLocalPlayerController() == false)
                {
                    PC.ClientRegisterHostStatGuid(StatGuid);
                }                
            }            
        }
    }
    GameReplicationInfo.StartMatch();
}

function StartHumans()
{
    local PlayerController P;

    foreach WorldInfo.AllControllers(Class'PlayerController', P)
    {
        if(P.Pawn == none)
        {
            if(bGameEnded)
            {                
                return;
                continue;
            }
            if(P.CanRestartPlayer())
            {
                RestartPlayer(P);
            }
        }        
    }    
}

function StartBots()
{
    local Controller P;

    foreach WorldInfo.AllControllers(Class'Controller', P)
    {
        if(P.bIsPlayer && !P.IsA('PlayerController'))
        {
            if(WorldInfo.NetMode == NM_Standalone)
            {
                RestartPlayer(P);
                continue;
            }
            P.GotoState('Dead', 'MPStart');
        }        
    }    
}

function RestartPlayer(Controller NewPlayer)
{
    local NavigationPoint StartSpot;
    local int TeamNum, Idx;
    local array<SequenceObject> Events;
    local SeqEvent_PlayerSpawned SpawnedEvent;
    local LocalPlayer LP;
    local PlayerController PC;

    if((bRestartLevel && WorldInfo.NetMode != NM_DedicatedServer) && WorldInfo.NetMode != NM_ListenServer)
    {
        WarnInternal("bRestartLevel && !server, abort from RestartPlayer" @ string(WorldInfo.NetMode));
        return;
    }
    TeamNum = (((NewPlayer.PlayerReplicationInfo == none) || NewPlayer.PlayerReplicationInfo.Team == none) ? 255 : NewPlayer.PlayerReplicationInfo.Team.TeamIndex);
    StartSpot = FindPlayerStart(NewPlayer, byte(TeamNum));
    if(StartSpot == none)
    {
        if(NewPlayer.StartSpot != none)
        {
            StartSpot = NewPlayer.StartSpot;
            WarnInternal("Player start not found, using last start spot");            
        }
        else
        {
            WarnInternal("Player start not found, failed to restart player");
            return;
        }
    }
    if(NewPlayer.Pawn == none)
    {
        NewPlayer.Pawn = SpawnDefaultPawnFor(NewPlayer, StartSpot);
    }
    if(NewPlayer.Pawn == none)
    {
        LogInternal("failed to spawn player at " $ string(StartSpot));
        NewPlayer.GotoState('Dead');
        if(PlayerController(NewPlayer) != none)
        {
            PlayerController(NewPlayer).ClientGotoState('Dead', 'Begin');
        }        
    }
    else
    {
        NewPlayer.Pawn.SetAnchor(StartSpot);
        if(PlayerController(NewPlayer) != none)
        {
            PlayerController(NewPlayer).TimeMargin = -0.1;
            StartSpot.AnchoredPawn = none;
        }
        NewPlayer.Pawn.LastStartSpot = PlayerStart(StartSpot);
        NewPlayer.Pawn.LastStartTime = WorldInfo.TimeSeconds;
        NewPlayer.Possess(NewPlayer.Pawn, false);
        NewPlayer.Pawn.PlayTeleportEffect(true, true);
        NewPlayer.ClientSetRotation(NewPlayer.Pawn.Rotation, true);
        if(!WorldInfo.bNoDefaultInventoryForPlayer)
        {
            AddDefaultInventory(NewPlayer.Pawn);
        }
        SetPlayerDefaults(NewPlayer.Pawn);
        if(WorldInfo.GetGameSequence() != none)
        {
            WorldInfo.GetGameSequence().FindSeqObjectsByClass(Class'SeqEvent_PlayerSpawned', true, Events);
            Idx = 0;
            J0x674:

            if(Idx < Events.Length)
            {
                SpawnedEvent = SeqEvent_PlayerSpawned(Events[Idx]);
                if((SpawnedEvent != none) && SpawnedEvent.CheckActivate(NewPlayer, NewPlayer))
                {
                    SpawnedEvent.SpawnPoint = StartSpot;
                    SpawnedEvent.PopulateLinkedVariableValues();
                }
                ++ Idx;
                goto J0x674;
            }
        }
    }
    PC = PlayerController(NewPlayer);
    if(PC != none)
    {
        LP = LocalPlayer(PC.Player);
        if(LP != none)
        {
            LP.RemoveAllPostProcessingChains();
            LP.InsertPostProcessingChain(LP.Outer.GetWorldPostProcessChain(), -1, true);
            if(PC.myHUD != none)
            {
                PC.myHUD.NotifyBindPostProcessEffects();
            }
        }
    }
}

function Pawn SpawnDefaultPawnFor(Controller NewPlayer, NavigationPoint StartSpot)
{
    local class<Pawn> DefaultPlayerClass;
    local Rotator StartRotation;
    local Pawn ResultPawn;

    DefaultPlayerClass = GetDefaultPlayerClass(NewPlayer);
    StartRotation.Yaw = StartSpot.Rotation.Yaw;
    ResultPawn = Spawn(DefaultPlayerClass,,, StartSpot.Location, StartRotation);
    if(ResultPawn == none)
    {
        LogInternal((("Couldn't spawn player of type " $ string(DefaultPlayerClass)) $ " at ") $ string(StartSpot));
    }
    return ResultPawn;
}

function class<Pawn> GetDefaultPlayerClass(Controller C)
{
    return DefaultPawnClass;
}

function ReplicateStreamingStatus(PlayerController PC)
{
    local int LevelIndex;
    local LevelStreaming TheLevel;

    if((LocalPlayer(PC.Player) == none) && ChildConnection(PC.Player) == none)
    {
        if(WorldInfo.CommittedPersistentLevelName != 'None')
        {
            PC.ClientPrepareMapChange(WorldInfo.CommittedPersistentLevelName, true, true);
            PC.ClientCommitMapChange();
        }
        if(WorldInfo.StreamingLevels.Length > 0)
        {
            LevelIndex = 0;
            J0x116:

            if(LevelIndex < WorldInfo.StreamingLevels.Length)
            {
                TheLevel = WorldInfo.StreamingLevels[LevelIndex];
                if(TheLevel != none)
                {
                    LogInternal(((((((((((("levelStatus: " $ string(TheLevel.PackageName)) $ " ") $ string(TheLevel.bShouldBeVisible)) $ " ") $ string(TheLevel.bIsVisible)) $ " ") $ string(TheLevel.bShouldBeLoaded)) $ " ") $ string(TheLevel.LoadedLevel)) $ " ") $ string(TheLevel.bHasLoadRequestPending)) $ " ");
                    PC.ClientUpdateLevelStreamingStatus(TheLevel.PackageName, TheLevel.bShouldBeLoaded, TheLevel.bShouldBeVisible, TheLevel.bShouldBlockOnLoad);
                }
                ++ LevelIndex;
                goto J0x116;
            }
            PC.ClientFlushLevelStreaming();
        }
        if(WorldInfo.PreparingLevelNames.Length > 0)
        {
            LevelIndex = 0;
            J0x37B:

            if(LevelIndex < WorldInfo.PreparingLevelNames.Length)
            {
                PC.ClientPrepareMapChange(WorldInfo.PreparingLevelNames[LevelIndex], LevelIndex == 0, LevelIndex == (WorldInfo.PreparingLevelNames.Length - 1));
                ++ LevelIndex;
                goto J0x37B;
            }
        }
    }
}

function GenericPlayerInitialization(Controller C)
{
    local PlayerController PC;

    PC = PlayerController(C);
    if(PC != none)
    {
        UpdateBestNextHosts();
        UpdateGameplayMuteList(PC);
        PC.ClientSetHUD(HUDType);
        PC.ClientSetSecondaryHUD(SecondaryHUDType);
        ReplicateStreamingStatus(PC);
        if(CoverReplicatorBase != none)
        {
            PC.SpawnCoverReplicator();
        }
        PC.ClientSetOnlineStatus();
    }
    if(BaseMutator != none)
    {
        BaseMutator.NotifyLogin(C);
    }
}

function int BestNextHostSort(PlayerController A, PlayerController B)
{
    local int Result;

    if(((A.ConnectedPeers.Length == B.ConnectedPeers.Length) && A.PlayerReplicationInfo != none) && B.PlayerReplicationInfo != none)
    {
        Result = FCeil(float(B.PlayerReplicationInfo.StartTime)) - FCeil(float(A.PlayerReplicationInfo.StartTime));        
    }
    else
    {
        Result = A.ConnectedPeers.Length - B.ConnectedPeers.Length;
    }
    return Result;
}

function UpdateBestNextHosts()
{
    local PlayerController PC;
    local array<PlayerController> SortedPCList;
    local UniqueNetId SortedPlayerIdList[10], ZeroId;
    local int Idx, NumEntries;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(((!PC.IsLocalPlayerController() && PC.PlayerReplicationInfo != none) && PC.PlayerReplicationInfo.UniqueId != ZeroId) && PC.IsPrimaryPlayer())
        {
            SortedPCList.AddItem(PC;
        }        
    }    
    SortedPCList.Sort(BestNextHostSort;
    NumEntries = Min(SortedPCList.Length, 10);
    Idx = 0;
    J0x145:

    if(Idx < NumEntries)
    {
        SortedPlayerIdList[Idx] = SortedPCList[Idx].PlayerReplicationInfo.UniqueId;
        ++ Idx;
        goto J0x145;
    }
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(!PC.IsLocalPlayerController())
        {
            PC.ClientUpdateBestNextHosts(SortedPlayerIdList, byte(NumEntries));
        }        
    }    
}

event PostLogin(PlayerController NewPlayer)
{
    local string Address, StatGuid;
    local int pos, I;
    local Sequence GameSeq;
    local array<SequenceObject> AllInterpActions;
    local int HidePlayer, HideHUD, DisableMovement, DisableTurning, DisableInput;

    if(NewPlayer.PlayerReplicationInfo.bOnlySpectator)
    {
        ++ NumSpectators;        
    }
    else
    {
        if(WorldInfo.IsInSeamlessTravel() || NewPlayer.HasClientLoadedCurrentWorld())
        {
            ++ NumPlayers;            
        }
        else
        {
            ++ NumTravellingPlayers;
        }
    }
    UpdateGameSettingsCounts();
    Address = NewPlayer.GetPlayerNetworkAddress();
    pos = InStr(Address, ":");
    NewPlayer.PlayerReplicationInfo.SavedNetworkAddress = ((pos > 0) ? Left(Address, pos) : Address);
    FindInactivePRI(NewPlayer);
    if(!bDelayedStart)
    {
        bRestartLevel = false;
        if(bWaitingToStartMatch)
        {
            StartMatch();            
        }
        else
        {
            RestartPlayer(NewPlayer);
        }
        bRestartLevel = default.bRestartLevel;
    }
    if(NewPlayer.Pawn != none)
    {
        NewPlayer.Pawn.ClientSetRotation(NewPlayer.Pawn.Rotation);
    }
    NewPlayer.ClientCapBandwidth(NewPlayer.Player.CurrentNetSpeed);
    UpdateNetSpeeds();
    GenericPlayerInitialization(NewPlayer);
    if((GameReplicationInfo.bMatchHasBegun && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.StatsInterface, (none)))
    {
        StatGuid = OnlineSub.StatsInterface.GetHostStatGuid();
        if(StatGuid != "")
        {
            NewPlayer.ClientRegisterHostStatGuid(StatGuid);
        }
    }
    if(bRequiresPushToTalk && !WorldInfo.IsConsoleDedicatedServer())
    {
        NewPlayer.ClientStopNetworkedVoice();        
    }
    else
    {
        NewPlayer.ClientStartNetworkedVoice();
    }
    if(NewPlayer.PlayerReplicationInfo.bOnlySpectator)
    {
        NewPlayer.ClientGotoState('Spectating');
    }
    GameSeq = WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(Class'SeqAct_Interp', true, AllInterpActions);
        I = 0;
        J0x4E8:

        if(I < AllInterpActions.Length)
        {
            SeqAct_Interp(AllInterpActions[I]).AddPlayerToDirectorTracks(NewPlayer);
            ++ I;
            goto J0x4E8;
        }
    }
    if(ShouldStartInCinematicMode(HidePlayer, HideHUD, DisableMovement, DisableTurning, DisableInput))
    {
        NewPlayer.SetCinematicMode(true, HidePlayer == 1, HideHUD == 1, DisableMovement == 1, DisableTurning == 1, DisableInput == 1);
    }
    if(AccessControl != none)
    {
        AccessControl.PostLogin(NewPlayer);
    }
}

function UpdateNetSpeeds()
{
    local int NewNetSpeed;
    local PlayerController PC;
    local OnlineGameSettings GameSettings;

    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
    }
    if(((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.NetMode == NM_Standalone) || (GameSettings != none) && GameSettings.bIsLanMatch)
    {
        return;
    }
    if((WorldInfo.TimeSeconds - LastNetSpeedUpdateTime) < 1)
    {
        SetTimer(1, false, 'UpdateNetSpeeds');
        return;
    }
    LastNetSpeedUpdateTime = WorldInfo.TimeSeconds;
    NewNetSpeed = CalculatedNetSpeed();
    LogInternal((("New Dynamic NetSpeed " $ string(NewNetSpeed)) $ " vs old ") $ string(AdjustedNetSpeed), 'DevNet');
    if(AdjustedNetSpeed != NewNetSpeed)
    {
        AdjustedNetSpeed = NewNetSpeed;
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            PC.SetNetSpeed(AdjustedNetSpeed);            
        }        
    }
}

function int CalculatedNetSpeed()
{
    return Clamp(TotalNetBandwidth / Max(NumPlayers, 1), MinDynamicBandwidth, MaxDynamicBandwidth);
}

event PreExit()
{
    if(AccessControl != none)
    {
        AccessControl.NotifyExit();
    }
    ClearOnlineDelegates();
}

function Logout(Controller Exiting)
{
    local PlayerController PC;
    local int PCIndex;

    PC = PlayerController(Exiting);
    if(PC != none)
    {
        if((AccessControl != none) && AccessControl.AdminLogout(PlayerController(Exiting)))
        {
            AccessControl.AdminExited(PlayerController(Exiting));
        }
        if(PC.PlayerReplicationInfo.bOnlySpectator)
        {
            -- NumSpectators;            
        }
        else
        {
            if(WorldInfo.IsInSeamlessTravel() || PC.HasClientLoadedCurrentWorld())
            {
                -- NumPlayers;                
            }
            else
            {
                -- NumTravellingPlayers;
            }
            UpdateGameSettingsCounts();
        }
        if((bUsingArbitration && bHasArbitratedHandshakeBegun) && !bHasEndGameHandshakeBegun)
        {
            LogInternal(("Player " $ PC.PlayerReplicationInfo.PlayerName) $ " has dropped");
        }
        UnregisterPlayer(PC);
        if(bUsingArbitration)
        {
            PCIndex = ArbitrationPCs.Find(PC;
            if(PCIndex != -1)
            {
                ArbitrationPCs.Remove(PCIndex, 1;
            }
        }
    }
    if(BaseMutator != none)
    {
        BaseMutator.NotifyLogout(Exiting);
    }
    if(PC != none)
    {
        UpdateNetSpeeds();
    }
}

function UnregisterPlayer(PlayerController PC)
{
    local UniqueNetId ZeroId;

    if((((WorldInfo.NetMode != NM_Standalone) && NotEqual_InterfaceInterface(GameInterface, (none))) && PC.PlayerReplicationInfo.UniqueId != ZeroId) && GameInterface.GetGameSettings(PC.PlayerReplicationInfo.SessionName) != none)
    {
        GameInterface.UnregisterPlayer(PC.PlayerReplicationInfo.SessionName, PC.PlayerReplicationInfo.UniqueId);
    }
}

event AcceptInventory(Pawn PlayerPawn);

event AddDefaultInventory(Pawn P)
{
    P.AddDefaultInventory();
    if(P.InvManager == none)
    {
        WarnInternal("GameInfo::AddDefaultInventory - P.InvManager == None");
    }
}

function Mutate(string MutateString, PlayerController Sender)
{
    if(BaseMutator != none)
    {
        BaseMutator.Mutate(MutateString, Sender);
    }
}

function SetPlayerDefaults(Pawn PlayerPawn)
{
    PlayerPawn.AirControl = PlayerPawn.default.AirControl;
    PlayerPawn.GroundSpeed = PlayerPawn.default.GroundSpeed;
    PlayerPawn.WaterSpeed = PlayerPawn.default.WaterSpeed;
    PlayerPawn.AirSpeed = PlayerPawn.default.AirSpeed;
    PlayerPawn.Acceleration = PlayerPawn.default.Acceleration;
    PlayerPawn.AccelRate = PlayerPawn.default.AccelRate;
    PlayerPawn.JumpZ = PlayerPawn.default.JumpZ;
    if(BaseMutator != none)
    {
        BaseMutator.ModifyPlayer(PlayerPawn);
    }
    PlayerPawn.PhysicsVolume.ModifyPlayer(PlayerPawn);
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    local Controller C;

    foreach WorldInfo.AllControllers(Class'Controller', C)
    {
        C.NotifyKilled(Killer, Killed, KilledPawn, DamageType);        
    }    
}

function Killed(Controller Killer, Controller KilledPlayer, Pawn KilledPawn, class<DamageType> DamageType)
{
    if((KilledPlayer != none) && KilledPlayer.bIsPlayer)
    {
        KilledPlayer.PlayerReplicationInfo.IncrementDeaths();
        KilledPlayer.PlayerReplicationInfo.SetNetUpdateTime(FMin(KilledPlayer.PlayerReplicationInfo.NetUpdateTime, WorldInfo.TimeSeconds + (0.3 * FRand())));
        BroadcastDeathMessage(Killer, KilledPlayer, DamageType);
    }
    if(KilledPlayer != none)
    {
        ScoreKill(Killer, KilledPlayer);
    }
    DiscardInventory(KilledPawn, Killer);
    NotifyKilled(Killer, KilledPlayer, KilledPawn, DamageType);
}

function bool PreventDeath(Pawn KilledPawn, Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    if(BaseMutator == none)
    {
        return false;
    }
    return BaseMutator.PreventDeath(KilledPawn, Killer, DamageType, HitLocation);
}

function BroadcastDeathMessage(Controller Killer, Controller Other, class<DamageType> DamageType)
{
    if((Killer == Other) || Killer == none)
    {
        BroadcastLocalized(self, DeathMessageClass, 1, none, Other.PlayerReplicationInfo, DamageType);        
    }
    else
    {
        BroadcastLocalized(self, DeathMessageClass, 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo, DamageType);
    }
}

function Kick(string S)
{
    if(AccessControl != none)
    {
        AccessControl.Kick(S);
    }
}

function KickBan(string S)
{
    if(AccessControl != none)
    {
        AccessControl.KickBan(S);
    }
}

function bool CanSpectate(PlayerController Viewer, PlayerReplicationInfo ViewTarget)
{
    return true;
}

function ReduceDamage(out int Damage, Pawn injured, Controller InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType, Actor DamageCauser)
{
    local int OriginalDamage;

    OriginalDamage = Damage;
    if(injured.PhysicsVolume.bNeutralZone || injured.InGodMode())
    {
        Damage = 0;
        return;
    }
    if(BaseMutator != none)
    {
        BaseMutator.NetDamage(OriginalDamage, Damage, injured, InstigatedBy, HitLocation, Momentum, DamageType, DamageCauser);
    }
}

function bool CheckRelevance(Actor Other)
{
    if(BaseMutator == none)
    {
        return true;
    }
    return BaseMutator.CheckRelevance(Other);
}

function bool ShouldRespawn(PickupFactory Other)
{
    return WorldInfo.NetMode != NM_Standalone;
}

function bool PickupQuery(Pawn Other, class<Inventory> ItemClass, Actor Pickup)
{
    local byte bAllowPickup;

    if((BaseMutator != none) && BaseMutator.OverridePickupQuery(Other, ItemClass, Pickup, bAllowPickup))
    {
        return bool(bAllowPickup);
    }
    if(Other.InvManager == none)
    {
        return false;        
    }
    else
    {
        return Other.InvManager.HandlePickupQuery(ItemClass, Pickup);
    }
}

function DiscardInventory(Pawn Other, optional Controller Killer)
{
    if(Other.InvManager != none)
    {
        Other.InvManager.DiscardInventory();
    }
}

function ChangeName(Controller Other, coerce string S, bool bNameChange)
{
    if(S == "")
    {
        return;
    }
    Other.PlayerReplicationInfo.SetPlayerName(S);
}

function bool ChangeTeam(Controller Other, int N, bool bNewTeam)
{
    return true;
}

function byte PickTeam(byte Current, Controller C, const out UniqueNetId PlayerID)
{
    return Current;
}

function SendPlayer(PlayerController aPlayer, string URL)
{
    aPlayer.ClientTravel(URL, 2);
}

function string GetNextMap();

function bool GetTravelType()
{
    return false;
}

function RestartGame()
{
    local string NextMap, TransitionMapCmdLine, URLString;
    local int URLMapLen, MapNameLen;

    if(bUsingArbitration)
    {
        if(bIsEndGameHandshakeComplete)
        {
            NotifyArbitratedMatchEnd();
        }
        return;
    }
    if((BaseMutator != none) && BaseMutator.HandleRestartGame())
    {
        return;
    }
    if(bGameRestarted)
    {
        return;
    }
    bGameRestarted = true;
    if(bChangeLevels && !bAlreadyChanged)
    {
        bAlreadyChanged = true;
        if((MyAutoTestManager != none) && MyAutoTestManager.bUsingAutomatedTestingMapList)
        {
            NextMap = MyAutoTestManager.GetNextAutomatedTestingMap();            
        }
        else
        {
            NextMap = GetNextMap();
        }
        if(NextMap != "")
        {
            if((MyAutoTestManager == none) || !MyAutoTestManager.bUsingAutomatedTestingMapList)
            {
                WorldInfo.ServerTravel(NextMap, GetTravelType());                
            }
            else
            {
                if(!MyAutoTestManager.bAutomatedTestingWithOpen)
                {
                    URLString = WorldInfo.GetLocalURL();
                    URLMapLen = Len(URLString);
                    MapNameLen = InStr(URLString, "?");
                    if(MapNameLen != -1)
                    {
                        URLString = Right(URLString, URLMapLen - MapNameLen);
                    }
                    TransitionMapCmdLine = ((NextMap $ URLString) $ "?AutomatedTestingMapIndex=") $ string(MyAutoTestManager.AutomatedTestingMapIndex);
                    LogInternal(">>> Issuing server travel on " $ TransitionMapCmdLine);
                    WorldInfo.ServerTravel(TransitionMapCmdLine, GetTravelType());                    
                }
                else
                {
                    TransitionMapCmdLine = (((("?AutomatedTestingMapIndex=" $ string(MyAutoTestManager.AutomatedTestingMapIndex)) $ "?NumberOfMatchesPlayed=") $ string(MyAutoTestManager.NumberOfMatchesPlayed)) $ "?NumMapListCyclesDone=") $ string(MyAutoTestManager.NumMapListCyclesDone);
                    LogInternal((">>> Issuing open command on " $ NextMap) $ TransitionMapCmdLine);                    
                    ConsoleCommand(("open " $ NextMap) $ TransitionMapCmdLine);
                }
            }
            return;
        }
    }
    WorldInfo.ServerTravel("?Restart", GetTravelType());
}

event Broadcast(Actor Sender, coerce string msg, optional name Type)
{
    BroadcastHandler.Broadcast(Sender, msg, Type);
}

function BroadcastTeam(Controller Sender, coerce string msg, optional name Type)
{
    BroadcastHandler.BroadcastTeam(Sender, msg, Type);
}

event BroadcastLocalized(Actor Sender, class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    BroadcastHandler.AllowBroadcastLocalized(Sender, Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
}

event BroadcastLocalizedTeam(int TeamIndex, Actor Sender, class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    BroadcastHandler.AllowBroadcastLocalizedTeam(TeamIndex, Sender, Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
}

function bool CheckModifiedEndGame(PlayerReplicationInfo Winner, string Reason)
{
    return (BaseMutator != none) && !BaseMutator.CheckEndGame(Winner, Reason);
}

function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
    local Controller P;

    if(CheckModifiedEndGame(Winner, Reason))
    {
        return false;
    }
    foreach WorldInfo.AllControllers(Class'Controller', P)
    {
        P.GameHasEnded();        
    }    
    return true;
}

function WriteOnlineStats()
{
    local PlayerController PC;
    local OnlineGameSettings CurrentSettings;

    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        CurrentSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
        if((CurrentSettings != none) && CurrentSettings.bUsesStats)
        {
            foreach WorldInfo.AllControllers(Class'PlayerController', PC)
            {
                if(PC.IsLocalPlayerController() == false)
                {
                    PC.ClientWriteLeaderboardStats(OnlineStatsWriteClass);
                }                
            }            
            foreach WorldInfo.AllControllers(Class'PlayerController', PC)
            {
                if(PC.IsLocalPlayerController())
                {
                    PC.ClientWriteLeaderboardStats(OnlineStatsWriteClass);
                }                
            }            
        }
    }
}

function WriteOnlinePlayerScores()
{
    local PlayerController PC;

    if(bUsingArbitration)
    {
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            PC.ClientWriteOnlinePlayerScores(ArbitratedLeaderboardId);            
        }                
    }
    else
    {
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            if(PC.IsLocalPlayerController())
            {
                PC.ClientWriteOnlinePlayerScores(LeaderboardId);
                break;
            }            
        }        
    }
}

function EndGame(PlayerReplicationInfo Winner, string Reason)
{
    if(!CheckEndGame(Winner, Reason))
    {
        bOverTime = true;
        return;
    }
    SetTimer(1.5, false, 'PerformEndGameHandling');
    bGameEnded = true;
    EndLogging(Reason);
}

function PerformEndGameHandling()
{
    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        WriteOnlineStats();
        WriteOnlinePlayerScores();
        EndOnlineGame();
        if(bUsingArbitration)
        {
            PendingArbitrationPCs.Length = 0;
            ArbitrationPCs.Length = 0;
            NotifyArbitratedMatchEnd();
        }
    }
}

function EndOnlineGame()
{
    local PlayerController PC;

    GameReplicationInfo.EndGame();
    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        foreach WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            if(!PC.IsLocalPlayerController())
            {
                PC.ClientEndOnlineGame();
            }            
        }        
        GameInterface.EndOnlineGame(PlayerReplicationInfoClass.default.SessionName);
    }
}

function GameEventsPoll();

function EndLogging(string Reason);

function bool ShouldSpawnAtStartSpot(Controller Player)
{
    return (((WorldInfo.NetMode == NM_Standalone) && Player != none) && Player.StartSpot != none) && bWaitingToStartMatch || (Player.PlayerReplicationInfo != none) && Player.PlayerReplicationInfo.bWaitingPlayer;
}

function NavigationPoint FindPlayerStart(Controller Player, optional byte InTeam, optional string IncomingName)
{
    local NavigationPoint N, BestStart;
    local Teleporter Tel;

    if(BaseMutator != none)
    {
        N = BaseMutator.FindPlayerStart(Player, InTeam, IncomingName);
        if(N != none)
        {
            return N;
        }
    }
    if(IncomingName != "")
    {
        foreach WorldInfo.AllNavigationPoints(Class'Teleporter', Tel)
        {
            if(string(Tel.Tag) ~= IncomingName)
            {                
                return Tel;
            }            
        }        
    }
    if(ShouldSpawnAtStartSpot(Player))
    {
        return Player.StartSpot;
    }
    BestStart = ChoosePlayerStart(Player, InTeam);
    if((BestStart == none) && Player == none)
    {
        LogInternal("Warning - PATHS NOT DEFINED or NO PLAYERSTART with positive rating");
        foreach AllActors(Class'NavigationPoint', N)
        {
            BestStart = N;
            break;            
        }        
    }
    return BestStart;
}

function PlayerStart ChoosePlayerStart(Controller Player, optional byte InTeam)
{
    local PlayerStart P, BestStart;
    local float BestRating, NewRating;
    local byte Team;

    Team = ((((Player != none) && Player.PlayerReplicationInfo != none) && Player.PlayerReplicationInfo.Team != none) ? byte(Player.PlayerReplicationInfo.Team.TeamIndex) : InTeam);
    foreach WorldInfo.AllNavigationPoints(Class'PlayerStart', P)
    {
        NewRating = RatePlayerStart(P, Team, Player);
        if(NewRating > BestRating)
        {
            BestRating = NewRating;
            BestStart = P;
        }        
    }    
    return BestStart;
}

function float RatePlayerStart(PlayerStart P, byte Team, Controller Player)
{
    local float Rating;

    if(!P.bEnabled)
    {
        return 5;        
    }
    else
    {
        Rating = 10;
        if(P.bPrimaryStart)
        {
            Rating += 10;
        }
        if(P.TeamIndex == Team)
        {
            Rating += 15;
        }
        return Rating;
    }
}

function AddObjectiveScore(PlayerReplicationInfo Scorer, int Score)
{
    if(Scorer != none)
    {
        Scorer.Score += float(Score);
    }
    if(BaseMutator != none)
    {
        BaseMutator.ScoreObjective(Scorer, Score);
    }
}

function ScoreObjective(PlayerReplicationInfo Scorer, int Score)
{
    AddObjectiveScore(Scorer, Score);
    CheckScore(Scorer);
}

function bool CheckScore(PlayerReplicationInfo Scorer)
{
    return true;
}

function ScoreKill(Controller Killer, Controller Other)
{
    if((Killer == Other) || Killer == none)
    {
        if((Other != none) && Other.PlayerReplicationInfo != none)
        {
            Other.PlayerReplicationInfo.Score -= float(1);
            Other.PlayerReplicationInfo.bForceNetUpdate = true;
        }        
    }
    else
    {
        if(Killer.PlayerReplicationInfo != none)
        {
            Killer.PlayerReplicationInfo.Score += float(1);
            Killer.PlayerReplicationInfo.bForceNetUpdate = true;
            ++ Killer.PlayerReplicationInfo.Kills;
        }
    }
    ModifyScoreKill(Killer, Other);
    if((Killer != none) || MaxLives > 0)
    {
        CheckScore(Killer.PlayerReplicationInfo);
    }
}

function ModifyScoreKill(Controller Killer, Controller Other)
{
    if(BaseMutator != none)
    {
        BaseMutator.ScoreKill(Killer, Other);
    }
}

function DriverEnteredVehicle(Vehicle V, Pawn P)
{
    if(BaseMutator != none)
    {
        BaseMutator.DriverEnteredVehicle(V, P);
    }
}

function bool CanLeaveVehicle(Vehicle V, Pawn P)
{
    if(BaseMutator == none)
    {
        return true;
    }
    return BaseMutator.CanLeaveVehicle(V, P);
}

function DriverLeftVehicle(Vehicle V, Pawn P)
{
    if(BaseMutator != none)
    {
        BaseMutator.DriverLeftVehicle(V, P);
    }
}

function bool PlayerCanRestartGame(PlayerController aPlayer)
{
    return true;
}

function bool PlayerCanRestart(PlayerController aPlayer)
{
    return true;
}

static function bool AllowMutator(string MutatorClassName)
{
    return !Class'WorldInfo'.static.IsDemoBuild();
}

function bool AllowCheats(PlayerController P)
{
    return WorldInfo.NetMode == NM_Standalone;
}

function bool AllowPausing(optional PlayerController PC)
{
    return (bPauseable || WorldInfo.NetMode == NM_Standalone) || bAdminCanPause && AccessControl.IsAdmin(PC);
}

event PreCommitMapChange(string PreviousMapName, string NextMapName);

event PostCommitMapChange();

function AddInactivePRI(PlayerReplicationInfo PRI, PlayerController PC)
{
    local int I;
    local PlayerReplicationInfo NewPRI, CurrentPRI;
    local bool bIsConsole;

    if(!PRI.bFromPreviousLevel && !PRI.bOnlySpectator)
    {
        NewPRI = PRI.Duplicate();
        WorldInfo.GRI.RemovePRI(NewPRI);
        NewPRI.RemoteRole = ROLE_None;
        NewPRI.LifeSpan = 300;
        bIsConsole = WorldInfo.IsConsoleBuild();
        I = 0;
        J0x12B:

        if(I < InactivePRIArray.Length)
        {
            CurrentPRI = InactivePRIArray[I];
            if((((CurrentPRI == none) || CurrentPRI.bDeleteMe) || !bIsConsole && CurrentPRI.SavedNetworkAddress == NewPRI.SavedNetworkAddress) || bIsConsole && CurrentPRI.UniqueId == NewPRI.UniqueId)
            {
                InactivePRIArray.Remove(I, 1;
                -- I;
            }
            ++ I;
            goto J0x12B;
        }
        InactivePRIArray[InactivePRIArray.Length] = NewPRI;
        if(InactivePRIArray.Length > 16)
        {
            InactivePRIArray.Remove(0, InactivePRIArray.Length - 16;
        }
    }
    PRI.Destroy();
    RecalculateSkillRating();
}

function bool FindInactivePRI(PlayerController PC)
{
    local string NewNetworkAddress, NewName;
    local int I;
    local PlayerReplicationInfo OldPRI, CurrentPRI;
    local bool bIsConsole;

    if(PC.PlayerReplicationInfo.bOnlySpectator)
    {
        return false;
    }
    bIsConsole = WorldInfo.IsConsoleBuild();
    NewNetworkAddress = PC.PlayerReplicationInfo.SavedNetworkAddress;
    NewName = PC.PlayerReplicationInfo.PlayerName;
    I = 0;
    J0xE9:

    if(I < InactivePRIArray.Length)
    {
        CurrentPRI = InactivePRIArray[I];
        if((CurrentPRI == none) || CurrentPRI.bDeleteMe)
        {
            InactivePRIArray.Remove(I, 1;
            -- I;            
        }
        else
        {
            if((bIsConsole && CurrentPRI.UniqueId == PC.PlayerReplicationInfo.UniqueId) || (!bIsConsole && CurrentPRI.SavedNetworkAddress ~= NewNetworkAddress) && CurrentPRI.PlayerName ~= NewName)
            {
                OldPRI = PC.PlayerReplicationInfo;
                PC.PlayerReplicationInfo = CurrentPRI;
                PC.PlayerReplicationInfo.SetOwner(PC);
                PC.PlayerReplicationInfo.RemoteRole = ROLE_SimulatedProxy;
                PC.PlayerReplicationInfo.LifeSpan = 0;
                OverridePRI(PC, OldPRI);
                WorldInfo.GRI.AddPRI(PC.PlayerReplicationInfo);
                InactivePRIArray.Remove(I, 1;
                OldPRI.bIsInactive = true;
                OldPRI.Destroy();
                return true;
            }
        }
        ++ I;
        goto J0xE9;
    }
    return false;
}

function OverridePRI(PlayerController PC, PlayerReplicationInfo OldPRI)
{
    PC.PlayerReplicationInfo.OverrideWith(OldPRI);
}

event GetSeamlessTravelActorList(bool bToEntry, out array<Actor> ActorList)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < WorldInfo.GRI.PRIArray.Length)
    {
        WorldInfo.GRI.PRIArray[I].bFromPreviousLevel = true;
        WorldInfo.GRI.PRIArray[I].bForceNetUpdate = true;
        ActorList[ActorList.Length] = WorldInfo.GRI.PRIArray[I];
        ++ I;
        goto J0x0B;
    }
    if(bToEntry)
    {
        ActorList[ActorList.Length] = WorldInfo.GRI;
        if(BroadcastHandler != none)
        {
            ActorList[ActorList.Length] = BroadcastHandler;
        }
    }
    if(BaseMutator != none)
    {
        BaseMutator.GetSeamlessTravelActorList(bToEntry, ActorList);
    }
    if(MyAutoTestManager != none)
    {
        ActorList[ActorList.Length] = MyAutoTestManager;
    }
    if(AccessControl != none)
    {
        ActorList[ActorList.Length] = AccessControl;
    }
}

// Export UGameInfo::execSwapPlayerControllers(FFrame&, void* const)
native final function SwapPlayerControllers(PlayerController OldPC, PlayerController NewPC);

event PostSeamlessTravel()
{
    local Controller C;

    foreach WorldInfo.AllControllers(Class'Controller', C)
    {
        if(C.bIsPlayer)
        {
            if(PlayerController(C) == none)
            {
                HandleSeamlessTravelPlayer(C);
                continue;
            }
            if(!C.PlayerReplicationInfo.bOnlySpectator)
            {
                ++ NumTravellingPlayers;
            }
            if(PlayerController(C).HasClientLoadedCurrentWorld())
            {
                HandleSeamlessTravelPlayer(C);
            }
        }        
    }    
    if((bWaitingToStartMatch && !bDelayedStart) && (NumPlayers + NumBots) > 0)
    {
        StartMatch();
    }
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        UpdateGameSettings();
    }
}

function UpdateGameSettings();

event HandleSeamlessTravelPlayer(out Controller C)
{
    local Rotator StartRotation;
    local NavigationPoint StartSpot;
    local PlayerController PC, NewPC;
    local PlayerReplicationInfo OldPRI;

    LogInternal(">> GameInfo::HandleSeamlessTravelPlayer:" @ string(C), 'SeamlessTravel');
    PC = PlayerController(C);
    if((PC != none) && PC.Class != PlayerControllerClass)
    {
        if(PC.Player != none)
        {
            NewPC = SpawnPlayerController(PC.Location, PC.Rotation);
            if(NewPC == none)
            {
                WarnInternal(((("Failed to spawn new PlayerController for" @ PC.GetHumanReadableName()) @ "(old class") @ string(PC.Class)) $ ")");
                PC.Destroy();
                return;                
            }
            else
            {
                PC.CleanUpAudioComponents();
                PC.SeamlessTravelTo(NewPC);
                NewPC.SeamlessTravelFrom(PC);
                SwapPlayerControllers(PC, NewPC);
                PC = NewPC;
                C = NewPC;
            }            
        }
        else
        {
            PC.Destroy();
        }        
    }
    else
    {
        C.PlayerReplicationInfo.Reset();
        OldPRI = C.PlayerReplicationInfo;
        C.InitPlayerReplicationInfo();
        OldPRI.SeamlessTravelTo(C.PlayerReplicationInfo);
        OldPRI.Destroy();
    }
    if(!bTeamGame && C.PlayerReplicationInfo.Team != none)
    {
        C.PlayerReplicationInfo.Team.Destroy();
        C.PlayerReplicationInfo.Team = none;
    }
    StartSpot = FindPlayerStart(C, C.GetTeamNum());
    if(StartSpot == none)
    {
        WarnInternal(GameMessageClass.default.FailedPlaceMessage);        
    }
    else
    {
        StartRotation.Yaw = StartSpot.Rotation.Yaw;
        C.SetLocation(StartSpot.Location);
        C.SetRotation(StartRotation);
    }
    C.StartSpot = StartSpot;
    if(PC != none)
    {
        PC.CleanUpAudioComponents();
        PC.ClientInitializeDataStores();
        SetSeamlessTravelViewTarget(PC);
        if(PC.PlayerReplicationInfo.bOnlySpectator)
        {
            PC.GotoState('Spectating');
            PC.PlayerReplicationInfo.bIsSpectator = true;
            PC.PlayerReplicationInfo.bOutOfLives = true;
            ++ NumSpectators;            
        }
        else
        {
            ++ NumPlayers;
            -- NumTravellingPlayers;
            PC.GotoState('PlayerWaiting');
        }        
    }
    else
    {
        ++ NumBots;
        C.GotoState('RoundEnded');
    }
    GenericPlayerInitialization(C);
    LogInternal("<< GameInfo::HandleSeamlessTravelPlayer:" @ string(C), 'SeamlessTravel');
}

function SetSeamlessTravelViewTarget(PlayerController PC)
{
    PC.SetViewTarget(PC);
}

function UpdateGameSettingsCounts()
{
    local OnlineGameSettings GameSettings;

    if(NotEqual_InterfaceInterface(GameInterface, (none)))
    {
        GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
        if((GameSettings != none) && GameSettings.bIsLanMatch)
        {
            GameSettings.NumOpenPublicConnections = GameSettings.NumPublicConnections - (GetNumPlayers());
            if(GameSettings.NumOpenPublicConnections < 0)
            {
                GameSettings.NumOpenPublicConnections = 0;
            }
        }
    }
}

function ProcessClientRegistrationCompletion(PlayerController PC, bool bWasSuccessful);

function StartArbitrationRegistration();

function StartArbitratedMatch();

function RegisterServerForArbitration();

function ArbitrationRegistrationComplete(name SessionName, bool bWasSuccessful);

function bool MatchIsInProgress()
{
    return true;
}

function NotifyArbitratedMatchEnd()
{
    local PlayerController PC;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC.IsLocalPlayerController() == false)
        {
            PC.ClientArbitratedMatchEnded();
        }        
    }    
    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC.IsLocalPlayerController())
        {
            PC.ClientArbitratedMatchEnded();
        }        
    }    
}

function UpdateGameplayMuteList(PlayerController PC)
{
    PC.bHasVoiceHandshakeCompleted = true;
    PC.ClientVoiceHandshakeComplete();
}

function RecalculateSkillRating()
{
    local int Index;
    local array<UniqueNetId> Players;
    local UniqueNetId ZeroId;

    if(((WorldInfo.NetMode != NM_Standalone) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        Index = 0;
        J0x7C:

        if(Index < GameReplicationInfo.PRIArray.Length)
        {
            if(ZeroId != GameReplicationInfo.PRIArray[Index].UniqueId)
            {
                Players[Players.Length] = GameReplicationInfo.PRIArray[Index].UniqueId;
            }
            ++ Index;
            goto J0x7C;
        }
        if(Players.Length > 0)
        {
            OnlineSub.GameInterface.RecalculateSkillRating(PlayerReplicationInfoClass.default.SessionName, Players);
        }
    }
}

event MatineeCancelled();

function bool ProcessServerLogin()
{
    if(OnlineSub != none)
    {
        if(NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
        {
            OnlineSub.PlayerInterface.AddLoginChangeDelegate(OnLoginChange);
            OnlineSub.PlayerInterface.AddLoginFailedDelegate(0, OnLoginFailed);
            if(OnlineSub.PlayerInterface.AutoLogin() == false)
            {
                ClearAutoLoginDelegates();
                return false;
            }
            return true;
        }
    }
    return false;
}

function ClearAutoLoginDelegates()
{
    if(NotEqual_InterfaceInterface(OnlineSub.PlayerInterface, (none)))
    {
        OnlineSub.PlayerInterface.ClearLoginChangeDelegate(OnLoginChange);
        OnlineSub.PlayerInterface.ClearLoginFailedDelegate(0, OnLoginFailed);
    }
}

function OnLoginFailed(byte LocalUserNum, OnlineSubsystem.EOnlineServerConnectionStatus ErrorCode)
{
    ClearAutoLoginDelegates();
}

function OnLoginChange(byte LocalUserNum)
{
    ClearAutoLoginDelegates();
    RegisterServer();
}

function RegisterServer()
{
    local OnlineGameSettings GameSettings;

    if(((OnlineGameSettingsClass != none) && OnlineSub != none) && NotEqual_InterfaceInterface(OnlineSub.GameInterface, (none)))
    {
        GameSettings = new OnlineGameSettingsClass;
        GameSettings.UpdateFromURL(ServerOptions, self);
        if(((AccessControl != none) && (WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.NetMode == NM_ListenServer) && GameSettings.bIsLanMatch)
        {
            LogInternal("Disabling all authentication, due to bIsLanMatch being set to true");
            AccessControl.ClearAuthDelegates(false);
        }
        OnlineSub.GameInterface.AddCreateOnlineGameCompleteDelegate(OnServerCreateComplete);
        if(!OnlineSub.GameInterface.CreateOnlineGame(0, PlayerReplicationInfoClass.default.SessionName, GameSettings))
        {
            OnlineSub.GameInterface.ClearCreateOnlineGameCompleteDelegate(OnServerCreateComplete);
        }        
    }
    else
    {
        WarnInternal("No game settings to register with the online service. Game won't be advertised");
    }
}

function OnServerCreateComplete(name SessionName, bool bWasSuccessful)
{
    local OnlineGameSettings GameSettings;

    GameInterface.ClearCreateOnlineGameCompleteDelegate(OnServerCreateComplete);
    if(bWasSuccessful == false)
    {
        GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
        if((GameSettings != none) && GameSettings.bIsLanMatch == false)
        {
            WarnInternal("Failed to register game with online service. Registering as a LAN match");
            GameSettings.bIsLanMatch = true;
            GameInterface.AddCreateOnlineGameCompleteDelegate(OnServerCreateComplete);
            if(!GameInterface.CreateOnlineGame(0, SessionName, GameSettings))
            {
                GameInterface.ClearCreateOnlineGameCompleteDelegate(OnServerCreateComplete);
            }            
        }
        else
        {
            WarnInternal("Failed to register game with online service. Game won't be advertised");
        }        
    }
    else
    {
        if(((OnlineSub.Class.Name == 'OnlineSubsystemSteamworks') && AccessControl != none) && EqualEqual_InterfaceInterface(AccessControl.CachedAuthInt, (none)))
        {
            AccessControl.InitAuthHooks();
            AccessControl.OnAuthReady();
        }
        UpdateGameSettings();
    }
}

function TellClientsToReturnToPartyHost()
{
    local PlayerController PC;
    local OnlineGameSettings GameSettings;
    local UniqueNetId RequestingPlayerId;

    OnlineSub = Class'GameEngine'.static.GetOnlineSubsystem();
    if(OnlineSub != none)
    {
        GameInterface = OnlineSub.GameInterface;
        if(NotEqual_InterfaceInterface(GameInterface, (none)))
        {
            GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
            if(GameSettings != none)
            {
                RequestingPlayerId = GameSettings.OwningPlayerId;                
            }
            else
            {
                foreach LocalPlayerControllers(Class'PlayerController', PC)
                {
                    if(PC.IsPrimaryPlayer() && PC.PlayerReplicationInfo != none)
                    {
                        RequestingPlayerId = PC.PlayerReplicationInfo.UniqueId;
                        break;
                    }                    
                }                
            }
            foreach WorldInfo.AllControllers(Class'PlayerController', PC)
            {
                if(!PC.IsLocalPlayerController() && PC.IsPrimaryPlayer())
                {
                    PC.ClientReturnToParty(RequestingPlayerId);
                }                
            }            
            foreach LocalPlayerControllers(Class'PlayerController', PC)
            {
                if(PC.IsPrimaryPlayer())
                {
                    PC.ClientReturnToParty(RequestingPlayerId);
                    break;
                }                
            }            
        }
    }
}

function TellClientsPartyHostIsLeaving(UniqueNetId PartyHostPlayerId)
{
    local PlayerController PC;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(PC.IsPrimaryPlayer())
        {
            PC.ClientNotifyPartyHostLeaving(PartyHostPlayerId);
        }        
    }    
}

function TellClientsToTravelToSession(name SessionName, class<OnlineGameSearch> SearchClass, byte PlatformSpecificInfo[80])
{
    local PlayerController PC;

    foreach WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        if(!PC.IsLocalPlayerController() && PC.IsPrimaryPlayer())
        {
            PC.ClientTravelToSession(SessionName, SearchClass, PlatformSpecificInfo);
        }        
    }    
}

exec function DoTravelTheWorld()
{
    if(MyAutoTestManager != none)
    {
        GotoState('TravelTheWorld');
        MyAutoTestManager.DoTravelTheWorld();
    }
}

// Export UGameInfo::execSetBandwidthLimit(FFrame&, void* const)
native exec function SetBandwidthLimit(float AsyncIOBandwidthLimit);

function bool IsAutomatedPerfTesting()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.bAutomatedPerfTesting;
}

function bool IsCheckingForFragmentation()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.bCheckingForFragmentation;
}

function bool IsCheckingForMemLeaks()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.bCheckingForMemLeaks;
}

function bool IsDoingASentinelRun()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.bDoingASentinelRun;
}

function bool ShouldAutoContinueToNextRound()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.bAutoContinueToNextRound;
}

function bool CheckForSentinelRun()
{
    return (MyAutoTestManager != none) && MyAutoTestManager.CheckForSentinelRun();
}

simulated exec function BeginBVT(coerce optional string TagDesc)
{
    if(MyAutoTestManager == none)
    {
        MyAutoTestManager = Spawn(AutoTestManagerClass);
    }
    MyAutoTestManager.BeginSentinelRun("BVT", "", TagDesc);
    MyAutoTestManager.SetTimer(3, true, 'DoTimeBasedSentinelStatGathering');
}

// Export UGameInfo::execEnableStandbyCheatDetection(FFrame&, void* const)
native function EnableStandbyCheatDetection(bool bIsEnabled);

event StandbyCheatDetected(GameInfo.EStandbyType StandbyType);

function OnDestroyOnlineGameComplete(name SessionName, bool bWasSuccessful)
{
    if(!ProcessServerLogin())
    {
        RegisterServer();
    }
    GameInterface.ClearDestroyOnlineGameCompleteDelegate(OnDestroyOnlineGameComplete);
}

event OnEngineHasLoaded();

function InitCrowdPopulationManager()
{
    if(PopulationManagerClass != none)
    {
        PopulationManager = Spawn(PopulationManagerClass);
    }
}

function ClearOnlineDelegates();

event OnRetreivedPFInternalUserData(const string ForPlayerId, array<string> Keys, array<string> Values);

// Export UGameInfo::execWasLaunchedByPlayfab(FFrame&, void* const)
native function bool WasLaunchedByPlayfab();

event string GetFriendlyNameForCurrentGameMode();

event bool GetRequiresPassword()
{
    return RequiresPassword();
}

auto state PendingMatch
{
    function bool MatchIsInProgress()
    {
        return false;
    }

    function StartMatch()
    {
        if(bUsingArbitration)
        {
            StartArbitrationRegistration();            
        }
        else
        {
            global.StartMatch();
        }
    }

    function StartArbitrationRegistration()
    {
        local PlayerController PC;
        local UniqueNetId HostId;
        local OnlineGameSettings GameSettings;

        if(!bHasArbitratedHandshakeBegun)
        {
            bHasArbitratedHandshakeBegun = true;
            GameSettings = GameInterface.GetGameSettings(PlayerReplicationInfoClass.default.SessionName);
            HostId = GameSettings.OwningPlayerId;
            PendingArbitrationPCs.Length = 0;
            foreach WorldInfo.AllControllers(Class'PlayerController', PC)
            {
                if(!PC.IsLocalPlayerController())
                {
                    PC.ClientSetHostUniqueId(HostId);
                    PC.ClientRegisterForArbitration();
                    PendingArbitrationPCs[PendingArbitrationPCs.Length] = PC;
                    continue;
                }
                ArbitrationPCs[ArbitrationPCs.Length] = PC;                
            }            
            SetTimer(ArbitrationHandshakeTimeout, false, 'ArbitrationTimeout');
        }
    }

    function RegisterServerForArbitration()
    {
        if(NotEqual_InterfaceInterface(GameInterface, (none)))
        {
            GameInterface.AddArbitrationRegistrationCompleteDelegate(ArbitrationRegistrationComplete);
            GameInterface.RegisterForArbitration(PlayerReplicationInfoClass.default.SessionName);            
        }
        else
        {
            ArbitrationRegistrationComplete(PlayerReplicationInfoClass.default.SessionName, true);
        }
    }

    function ArbitrationRegistrationComplete(name SessionName, bool bWasSuccessful)
    {
        GameInterface.ClearArbitrationRegistrationCompleteDelegate(ArbitrationRegistrationComplete);
        if(bWasSuccessful)
        {
            StartArbitratedMatch();            
        }
        else
        {            
            ConsoleCommand("Disconnect");
        }
    }

    function ArbitrationTimeout()
    {
        local int Index;

        Index = 0;
        J0x0B:

        if(Index < PendingArbitrationPCs.Length)
        {
            AccessControl.KickPlayer(PendingArbitrationPCs[Index], ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".MaxedOutMessage>");
            ++ Index;
            goto J0x0B;
        }
        PendingArbitrationPCs.Length = 0;
        RegisterServerForArbitration();
    }

    function StartArbitratedMatch()
    {
        bNeedsEndGameHandshake = true;
        global.StartMatch();
    }

    function ProcessClientRegistrationCompletion(PlayerController PC, bool bWasSuccessful)
    {
        local int FoundIndex;

        FoundIndex = PendingArbitrationPCs.Find(PC;
        if(FoundIndex != -1)
        {
            PendingArbitrationPCs.Remove(FoundIndex, 1;
            if(bWasSuccessful)
            {
                ArbitrationPCs[ArbitrationPCs.Length] = PC;                
            }
            else
            {
                AccessControl.KickPlayer(PC, ("<Strings:" $ PathName(WorldInfo.Game.GameMessageClass)) $ ".MaxedOutMessage>");
            }
        }
        if(PendingArbitrationPCs.Length == 0)
        {
            SetTimer(0, false, 'ArbitrationTimeout');
            RegisterServerForArbitration();
        }
    }

    event EndState(name NextStateName)
    {
        SetTimer(0, false, 'ArbitrationTimeout');
        if(NotEqual_InterfaceInterface(GameInterface, (none)))
        {
            GameInterface.ClearArbitrationRegistrationCompleteDelegate(ArbitrationRegistrationComplete);
        }
    }
    stop;    
}

state TravelTheWorld
{    stop;    
}

defaultproperties
{
    bRestartLevel=true
    bPauseable=true
    bDelayedStart=true
    bChangeLevels=true
    GameSpeed=1
    HUDType=Class'HUD'
    MaxSpectators=2
    MaxSpectatorsAllowed=32
    MaxPlayers=12
    MaxPlayersAllowed=32
    CurrentID=1
    DefaultPlayerName="Player"
    GameName="Game"
    FearCostFallOff=0.95
    DeathMessageClass=Class'LocalMessage'
    GameMessageClass=Class'GameMessage'
    AccessControlClass=Class'AccessControl'
    BroadcastHandlerClass=Class'BroadcastHandler'
    AutoTestManagerClass=Class'AutoTestManager'
    PlayerControllerClass=Class'PlayerController'
    PlayerReplicationInfoClass=Class'PlayerReplicationInfo'
    GameReplicationInfoClass=Class'GameReplicationInfo'
    TimeMarginSlack=1.35
    MinTimeMargin=-1
    LeaderboardId=-131072
    ArbitratedLeaderboardId=-65536
    TotalNetBandwidth=32000
    MinDynamicBandwidth=4000
    MaxDynamicBandwidth=7000
    StreamingPauseIcon=Material'EngineResources.M_StreamingPause'
    GameInfoClassAliases(0)=(ShortName="BenchMark",GameClassName="KFGameContent.KFGameInfo_BenchMark")
    GameInfoClassAliases(1)=(ShortName="Survival",GameClassName="KFGameContent.KFGameInfo_Survival")
    GameInfoClassAliases(2)=(ShortName="Versus",GameClassName="KFGameContent.KFGameInfo_VersusSurvival")
    DefaultGameType="KFGameContent.KFGameInfo_Survival"
    Components=none
    CollisionType=ECollisionType.COLLIDE_CustomDefault
}