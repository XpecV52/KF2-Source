/*******************************************************************************
 * PhysicsVolume generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class PhysicsVolume extends Volume
    native
    nativereplication
    placeable
    hidecategories(Navigation,Object,Movement,Display);

struct CheckpointRecord
{
    var bool bPainCausing;
    var bool bActive;

    structdefaultproperties
    {
        bPainCausing=false
        bActive=false
    }
};

/**  
 *This property is a bit like gravity, though it can be used to apply force in any
 * direction using the three axes. Objects within the volume will be accelerated
 * up to the designated velocity while taking friction values into effect
 */
var() interp Vector ZoneVelocity;
/** Will the zone velocity affect walking? */
var() bool bVelocityAffectsWalking;
/** This property activates the ability to cause damage. Used in conjunction with DamagePerSecond and PainInterval */
var() bool bPainCausing;
/** If this property is TRUE AI should not treat paths inside this volume differently even if the volume causes pain */
var() bool bAIShouldIgnorePain;
/** This property describes whether or not pain should be caused when something enters the volume - this is in addition to damage per second. NB. bPainCausing must be set to TRUE to activate this */
var() bool bEntryPain;
var bool BACKUP_bPainCausing;
/** Destroys most actors which enter it */
var() bool bDestructive;
/** If set, any items dropped within this volume will have a limited lifetime */
var() bool bNoInventory;
/** this velocity zone should impart velocity to projectiles and effects */
var() bool bMoveProjectiles;
/** this velocity zone should bounce actors that land in it */
var() bool bBounceVelocity;
/** Players can't take damage in this zone */
var() bool bNeutralZone;
/** If TRUE, crowd agents entering this volume play their death animation */
var() bool bCrowdAgentsPlayDeathAnim;
/** By default, the origin of an Actor must be inside a PhysicsVolume for it to affect it. If this flag is true though, if this Actor touches the volume at all, it will affect it */
var() bool bPhysicsOnContact;
var bool bWaterVolume;
/** This property allows you to control how much friction you will have as you move across the ground while within the volume. This can be used to simulate slippery surfaces such as ice or oil */
var() float GroundFriction;
/** Terminal velocity */
var() float TerminalVelocity;
/** This property allows a volume to damage a player as long as they are within it. Using a negative value will allow the volume to have a regenerative effect. NB. bPainCausing must be set to TRUE to activate this */
var() float DamagePerSec;
/** When damage is applied to an object, it is done so using a specific DamageType. Each available DamageType has a KDamageImpulse property which controls the magnitude of the impulse to be applied along the momentum vector. Runtime users should be aware that due to the lack of default weapons and the limited number of damage types, this property will not be extremely useful. */
var() class<DamageType> DamageType<AllowAbstract=>;
/** This property determines which PhysicsVolume takes precedence if they overlap */
var() int Priority;
/** This property controls the amount of friction applied by the volume as you move through it. The higher this value, the harder it will feel to move through */
var() float FluidFriction;
/** Amount of time, in seconds, between damage applications. NB. bPainCausing must be set to TRUE to activate this */
var() float PainInterval;
/** This controls the force that will be applied to PHYS_RigidBody objects in this volume to get them to match the ZoneVelocity */
var() float RigidBodyDamping;
/** Applies a cap on the maximum damping force that is applied to objects */
var() float MaxDampingForce;
var Info PainTimer;
var Controller DamageInstigator;
var transient PhysicsVolume NextPhysicsVolume;

// Export UPhysicsVolume::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

// Export UPhysicsVolume::execGetZoneVelocityForActor(FFrame&, void* const)
native function Vector GetZoneVelocityForActor(Actor TheActor);

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    BACKUP_bPainCausing = bPainCausing;
    if(Role < ROLE_Authority)
    {
        return;
    }
    if(bPainCausing)
    {
        PainTimer = Spawn(Class'VolumeTimer', self);
    }
}

function Reset()
{
    bPainCausing = BACKUP_bPainCausing;
    bForceNetUpdate = true;
}

event PhysicsChangedFor(Actor Other);

event ActorEnteredVolume(Actor Other);

event ActorLeavingVolume(Actor Other);

event PawnEnteredVolume(Pawn Other);

event PawnLeavingVolume(Pawn Other);

simulated function OnToggle(SeqAct_Toggle inAction)
{
    if(!bStatic || RemoteRole > ROLE_None)
    {
        super.OnToggle(inAction);
    }
    if(inAction.InputLinks[0].bHasImpulse)
    {
        bPainCausing = BACKUP_bPainCausing;        
    }
    else
    {
        if(inAction.InputLinks[1].bHasImpulse)
        {
            bPainCausing = false;            
        }
        else
        {
            if(inAction.InputLinks[2].bHasImpulse)
            {
                bPainCausing = !bPainCausing && BACKUP_bPainCausing;
            }
        }
    }
}

simulated event CollisionChanged();

function TimerPop(VolumeTimer T)
{
    local Actor A;

    if(T == PainTimer)
    {
        if(!bPainCausing)
        {
            return;
        }
        foreach TouchingActors(Class'Actor', A)
        {
            if(A.bCanBeDamaged && !A.bStatic)
            {
                CausePainTo(A);
            }            
        }        
    }
}

simulated event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    super(Actor).Touch(Other, OtherComp, HitLocation, HitNormal);
    if((Other == none) || Other.bStatic)
    {
        return;
    }
    if((bNoInventory && DroppedPickup(Other) != none) && Other.Owner == none)
    {
        Other.LifeSpan = 1.5;
        return;
    }
    if(bMoveProjectiles && ZoneVelocity != vect(0, 0, 0))
    {
        if(Other.Physics == 6)
        {
            Other.Velocity += ZoneVelocity;            
        }
        else
        {
            if(((Other.Base == none) && Other.IsA('Emitter')) && Other.Physics == 0)
            {
                Other.SetPhysics(6);
                Other.Velocity += ZoneVelocity;
            }
        }
    }
    if(bPainCausing)
    {
        if(Other.bDestroyInPainVolume)
        {
            Other.VolumeBasedDestroy(self);
            return;
        }
        if(bEntryPain && Other.bCanBeDamaged)
        {
            CausePainTo(Other);
        }
    }
}

function CausePainTo(Actor Other)
{
    if(DamagePerSec > float(0))
    {
        if(WorldInfo.bSoftKillZ && Other.Physics != 1)
        {
            return;
        }
        if((DamageType == none) || DamageType == Class'DamageType')
        {
            LogInternal((("No valid damagetype (" $ string(DamageType)) $ ") specified for ") $ PathName(self));
        }
        Other.TakeDamage(int(DamagePerSec * PainInterval), DamageInstigator, Location, vect(0, 0, 1), DamageType,, self);        
    }
    else
    {
        Other.HealDamage(int(-DamagePerSec * PainInterval), DamageInstigator, DamageType);
    }
}

function ModifyPlayer(Pawn PlayerPawn);

function NotifyPawnBecameViewTarget(Pawn P, PlayerController PC);

function OnSetDamageInstigator(SeqAct_SetDamageInstigator Action)
{
    DamageInstigator = Action.GetController(Action.DamageInstigator);
}

function bool ShouldSaveForCheckpoint()
{
    return bPainCausing != BACKUP_bPainCausing;
}

function CreateCheckpointRecord(out CheckpointRecord Record)
{
    Record.bPainCausing = bPainCausing;
}

function ApplyCheckpointRecord(const out CheckpointRecord Record)
{
    bPainCausing = Record.bPainCausing;
}

defaultproperties
{
    bVelocityAffectsWalking=true
    bEntryPain=true
    GroundFriction=8
    TerminalVelocity=4000
    DamageType=Class'DamageType'
    FluidFriction=0.3
    PainInterval=1
    MaxDampingForce=1000000
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        BlockZeroExtent=true
    object end
    // Reference: BrushComponent'Default__PhysicsVolume.BrushComponent0'
    BrushComponent=BrushComponent0
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        BlockZeroExtent=true
    object end
    // Reference: BrushComponent'Default__PhysicsVolume.BrushComponent0'
    Components(0)=BrushComponent0
    CollisionType=ECollisionType.COLLIDE_TouchAll
    bAlwaysRelevant=true
    bOnlyDirtyReplication=true
    bForceAllowKismetModification=true
    NetUpdateFrequency=0.1
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
        BlockZeroExtent=true
    object end
    // Reference: BrushComponent'Default__PhysicsVolume.BrushComponent0'
    CollisionComponent=BrushComponent0
}