/*******************************************************************************
 * SkeletalMeshComponent generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SkeletalMeshComponent extends MeshComponent
    native(SkeletalMesh)
    editinlinenew
    noexport
    hidecategories(Object);

enum EMaxDistanceScaleMode
{
    MDSM_Multiply,
    MDSM_Substract,
    MDSM_MAX
};

enum EInstanceWeightUsage
{
    IWU_PartialSwap,
    IWU_FullSwap,
    IWU_MAX
};

enum ERootMotionMode
{
    RMM_Translate,
    RMM_Velocity,
    RMM_Ignore,
    RMM_Accel,
    RMM_Relative,
    RMM_MAX
};

enum ERootMotionRotationMode
{
    RMRM_Ignore,
    RMRM_RotateActor,
    RMRM_MAX
};

enum EAnimRotationOnly
{
    EARO_AnimSet,
    EARO_ForceEnabled,
    EARO_ForceDisabled,
    EARO_MAX
};

enum EFaceFXBlendMode
{
    FXBM_Overwrite,
    FXBM_Additive,
    FXBM_MAX
};

enum EFaceFXRegOp
{
    FXRO_Add,
    FXRO_Multiply,
    FXRO_Replace,
    FXRO_MAX
};

enum EBoneVisibilityStatus
{
    BVS_HiddenByParent,
    BVS_Visible,
    BVS_ExplicitlyHidden,
    BVS_MAX
};

enum EPhysBodyOp
{
    PBO_None,
    PBO_Term,
    PBO_Disable,
    PBO_MAX
};

struct ActiveMorph
{
    var MorphTarget Target;
    var float Weight;

    structdefaultproperties
    {
        Target=none
        Weight=0
    }
};

struct Attachment
{
    /** Attachments. */
    var() export editinline ActorComponent Component;
    /** Attachments. */
    var() name BoneName;
    /** Attachments. */
    var() Vector RelativeLocation;
    /** Attachments. */
    var() Rotator RelativeRotation;
    /** Attachments. */
    var() Vector RelativeScale;

    structdefaultproperties
    {
        Component=none
        BoneName=None
        RelativeLocation=(X=0,Y=0,Z=0)
        RelativeRotation=(Pitch=0,Yaw=0,Roll=0)
        RelativeScale=(X=1,Y=1,Z=1)
    }
};

struct BonePair
{
    var name Bones[2];

    structdefaultproperties
    {
        Bones[0]=None
        Bones[1]=None
    }
};

struct SkelMeshComponentLODInfo
{
    var const array<bool> HiddenMaterials;
    var const bool bNeedsInstanceWeightUpdate;
    var const bool bAlwaysUseInstanceWeights;
    var const transient SkeletalMeshComponent.EInstanceWeightUsage InstanceWeightUsage;
    var const transient int InstanceWeightIdx;

    structdefaultproperties
    {
        HiddenMaterials=none
        bNeedsInstanceWeightUpdate=false
        bAlwaysUseInstanceWeights=false
        InstanceWeightUsage=EInstanceWeightUsage.IWU_PartialSwap
        InstanceWeightIdx=0
    }
};

/** The skeletal mesh used by this component. */
var() SkeletalMesh SkeletalMesh;
var export editinline SkeletalMeshComponent AttachedToSkelComponent;
/**  
 *This should point to the AnimTree in a content package.
 *       BeginPlay on this SkeletalMeshComponent will instance (copy) the tree and assign the instance to the Animations pointer.
 */
var() const AnimTree AnimTreeTemplate;
/**  
 *This is the unique instance of the AnimTree used by this SkeletalMeshComponent.
 *       THIS SHOULD NEVER POINT TO AN ANIMTREE IN A CONTENT PACKAGE.
 */
var() const export editinline AnimNode Animations<MaxPropertyDepth=3>;
var const transient array<AnimNode> AnimTickArray;
var const transient array<AnimNode> AnimAlwaysTickArray;
var const transient array<int> AnimTickRelevancyArray;
var const transient array<float> AnimTickWeightsArray;
var const transient array<SkelControlBase> SkelControlTickArray;
/**  
 *Physics and collision information used for this SkeletalMesh, set up in PhAT.
 *       This is used for per-bone hit detection, accurate bounding box calculation and ragdoll physics for example.
 */
var() const PhysicsAsset PhysicsAsset;
var const export editinline transient PhysicsAssetInstance PhysicsAssetInstance;
/**  
 *Physics and collision information used for this SkeletalMesh, set up in PhAT.
 * This is used for flex when you felt your main PhysicsAsset is too complicated for flex, you could create simple one here.
 */
var() const PhysicsAsset PhysicsAssetForFlex;
var const export editinline transient PhysicsAssetInstance PhysicsAssetInstanceForFlex;
var transient bool bUpdateFlexKinematicBonesFromAnimation;
var native const transient Pointer ApexClothing;
/** Influence of rigid body physics on the mesh's pose (0.0 == use only animation, 1.0 == use only physics) */
var() interp float PhysicsWeight;
/** Used to scale speed of all animations on this skeletal mesh. */
var() float GlobalAnimRateScale;
/**  
 *Allows adjusting the desired streaming distance of streaming textures that uses UV 0.
 * 1.0 is the default, whereas a higher value makes the textures stream in sooner from far away.
 * A lower value (0.0-1.0) makes the textures stream in later (you have to be closer).
 */
var() float StreamingDistanceMultiplier;
var native const transient Pointer MeshObject;
var() Color WireframeColor;
var native const transient array<BoneAtom> SpaceBases;
var native const transient array<BoneAtom> LocalAtoms;
var native const transient array<BoneAtom> CachedLocalAtoms;
var native const transient array<BoneAtom> CachedSpaceBases;
var const int LowUpdateFrameRate;
var native const transient array<byte> RequiredBones;
var native const transient array<byte> ComposeOrderedRequiredBones;
/**  
 *If set, this SkeletalMeshComponent will not use its Animations pointer to do its own animation blending, but will
 *       use the SpaceBases array in the ParentAnimComponent. This is used when constructing a character using multiple skeletal meshes sharing the same
 *       skeleton within the same Actor.
 */
var() const export editinline SkeletalMeshComponent ParentAnimComponent;
var native const transient array<int> ParentBoneMap;
/**  
 *The set of AnimSets that will be looked in to find a particular sequence, specified by name in an AnimNodeSequence.
 *       Array is search from last to first element, so you can replace a particular sequence but putting a set containing the new version later in the array.
 *       You will need to call SetAnim again on nodes that may be affected by any changes you make to this array.
 */
var() array<AnimSet> AnimSets;
var native const transient array<AnimSet> TemporarySavedAnimSets;
/**  
 *Array of MorphTargetSets that will be looked in to find a particular MorphTarget, specified by name.
 *       It is searched in the same way as the AnimSets array above.
 */
var() array<MorphTargetSet> MorphSets;
var transient array<ActiveMorph> ActiveMorphs;
var transient array<ActiveMorph> ActiveCurveMorphs;
var native const map<0, 0> MorphTargetIndexMap;
var duplicatetransient const array<Attachment> Attachments;
var const transient array<byte> SkelControlIndex;
var const transient array<byte> PostPhysSkelControlIndex;
/** If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1). */
var() int ForcedLodModel;
/**  
 *This is the min LOD that this component will use.  (e.g. if set to 2 then only 2+ LOD Models will be used.) This is useful to set on
 * meshes which are known to be a certain distance away and still want to have better LODs when zoomed in on them.
 */
var() int MinLodModel;
var int PredictedLODLevel;
var int OldPredictedLODLevel;
var() float AnimationLODDistanceFactor;
/** Rate of update for skeletal meshes that are below AnimationLODDistanceFactor. For example if set to 3, animations will be updated once every three frames. */
var() int AnimationLODFrameRate;
var const float MaxDistanceFactor;
var editoronly transient int ChunkIndexPreview;
var editoronly transient int SectionIndexPreview;
var int bForceWireframe;
var int bForceRefpose;
var int bOldForceRefPose;
/** Skip UpdateSkelPose. */
var() bool bNoSkeletonUpdate;
var int bDisplayBones;
var int bShowPrePhysBones;
var int bHideSkin;
var int bForceRawOffset;
var int bIgnoreControllers;
var int bTransformFromAnimParent;
var const transient int TickTag;
var const transient int InitTag;
var const transient int CachedAtomsTag;
var const int bUseSingleBodyPhysics;
var transient int bRequiredBonesUpToDate;
var float MinDistFactorForKinematicUpdate;
var transient int FramesPhysicsAsleep;
var const transient int SkipRateForTickAnimNodesAndGetBoneAtoms;
var const transient bool bSkipTickAnimNodes;
var const transient bool bSkipGetBoneAtoms;
var const transient bool bInterpolateBoneAtoms;
var const transient bool bHasValidBodies;
var bool bSkipAllUpdateWhenPhysicsAsleep;
/** When true, skip using the physics asset etc. and always use the fixed bounds defined in the SkeletalMesh. */
var() bool bComponentUseFixedSkelBounds;
/**  
 *When true, we will just using the bounds from our ParentAnimComponent.  This is useful for when we have a Mesh Parented
 * to the main SkelMesh (e.g. outline mesh or a full body overdraw effect that is toggled) that is always going to be the same
 * bounds as parent.  We want to do no calculations in that case.
 */
var() bool bUseBoundsFromParentAnimComponent;
/** If TRUE, when updating bounds from a PhysicsAsset, consider _all_ BodySetups, not just those flagged with bConsiderForBounds. */
var() bool bConsiderAllBodiesForBounds;
/**  
 *If true, update skeleton/attachments even when our Owner has not been rendered recently
 * @note if this is false, bone information may not be accurate, so be careful setting this to false if bone info is relevant to gameplay
 * @note you can use ForceSkelUpdate() to force an update
 * @note: In the output from SHOWSKELCOMPTICKTIME you want UpdatePoseTotal to be 0 when this is FALSE for a specific component
 */
var() bool bUpdateSkelWhenNotRendered;
var bool bIgnoreControllersWhenNotRendered;
var bool bTickAnimNodesWhenNotRendered;
var const bool bNotUpdatingKinematicDueToDistance;
/** force root motion to be discarded, no matter what the AnimNodeSequence(s) are set to do */
var() bool bForceDiscardRootMotion;
/** Call RootMotionProcessed notification on Owner */
var() bool bNotifyRootMotionProcessed;
var bool bRootMotionModeChangeNotify;
var bool bRootMotionExtractedNotify;
var transient bool bProcessingRootMotion;
/** If true, FaceFX will not automatically create material instances. */
var() bool bDisableFaceFXMaterialInstanceCreation;
/** If true, disable FaceFX entirely for this component */
var() bool bDisableFaceFX;
var const transient bool bAnimTreeInitialised;
var private transient bool bForceMeshObjectUpdate;
/**  
 *Indicates whether this SkeletalMeshComponent should have a physics engine representation of its state.
 *       @see SetHasPhysicsAssetInstance
 */
var() const bool bHasPhysicsAssetInstance;
/** If we are running physics, should we update bFixed bones based on the animation bone positions. */
var() bool bUpdateKinematicBonesFromAnimation;
/**  
 *If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the
 *       ragdoll based on the animation.
 */
var() bool bUpdateJointsFromAnimation;
var const bool bSkelCompFixed;
var const bool bHasHadPhysicsBlendedIn;
/**  
 *If true, attachments will be updated twice a frame - once in Tick and again when UpdateTransform is called.
 *       This can resolve some 'frame behind' issues if an attachment need to be in the correct location for it's Tick, but at a cost.
 */
var() bool bForceUpdateAttachmentsInTick;
var transient bool bEnableFullAnimWeightBodies;
/**  
 *If true, when this skeletal mesh overlaps a physics volume, each body of it will be tested against the volume, so only limbs
 *       actually in the volume will be affected. Useful when gibbing bodies.
 */
var() bool bPerBoneVolumeEffects;
/** If true, use per-bone motion blur on this skeletal mesh. */
var() bool bPerBoneMotionBlur;
/** If true, will move the Actors Location to match the root rigid body location when in PHYS_RigidBody. */
var() bool bSyncActorLocationToRootRigidBody;
var const bool bUseRawData;
var bool bDisableWarningWhenAnimNotFound;
var bool bOverrideAttachmentOwnerVisibility;
var const transient bool bNeedsToDeleteHitMask;
var bool bPauseAnims;
var bool bChartDistanceFactor;
var bool bEnableLineCheckWithBounds;
var transient bool bCanHighlightSelectedSections;
/** Update Morph when ParentAnimComponent exists */
var() bool bUpdateMorphWhenParentAnimComponentExists;
var Vector LineCheckBoundsScale;
/**  
 *Whether cloth simulation should currently be used on this SkeletalMeshComponent.
 *       @see SetEnableClothSimulation
 */
var(Cloth) const bool bEnableClothSimulation;
/** Turns off all cloth collision so not checks are done (improves performance). */
var(Cloth) const bool bDisableClothCollision;
/** If true, cloth is 'frozen' and no simulation is taking place for it, though it will keep its shape. */
var(Cloth) const bool bClothFrozen;
/** If true, cloth will automatically have bClothFrozen set when it is not rendered, and have it turned off when it is seen. */
var(Cloth) bool bAutoFreezeClothWhenNotRendered;
/** If true, cloth will be awake when a level is started, otherwise it will be instantly put to sleep. */
var(Cloth) bool bClothAwakeOnStartup;
/** It true, clamp velocity of cloth particles to be within ClothBaseVelClampRange of Base velocity. */
var(Cloth) bool bClothBaseVelClamp;
/** It true, interp velocity of cloth particles towards Base velocity, using ClothBaseVelClampRange as the interp rate (0..1). */
var(Cloth) bool bClothBaseVelInterp;
/** If true, fixed verts of the cloth are attached in the physics to the physics body that this components actor is attached to. */
var(Cloth) bool bAttachClothVertsToBaseBody;
/** Whether this cloth is on a non-animating static object. */
var(Cloth) bool bIsClothOnStaticObject;
var bool bUpdatedFixedClothVerts;
/** Whether should do positional box dampening */
var(Cloth) bool bClothPositionalDampening;
/** Whether wind direction is relative to owner rotation or not */
var(Cloth) bool bClothWindRelativeToOwner;
var transient bool bRecentlyRendered;
var bool bCacheAnimSequenceNodes;
var const transient bool bNeedsInstanceWeightUpdate;
var const transient bool bAlwaysUseInstanceWeights;
var const transient bool bUpdateComposeSkeletonPasses;
var native const transient bool bValidTemporarySavedAnimSets;
var native const transient array<BonePair> InstanceVertexWeightBones;
var const transient array<SkelMeshComponentLODInfo> LODInfo;
var const Vector FrozenLocalToWorldPos;
var const Rotator FrozenLocalToWorldRot;
/** Constant force applied to all vertices in the cloth. */
var(Cloth) const Vector ClothExternalForce;
/** 'Wind' force applied to cloth. Force on each vertex is based on the dot product between the wind vector and the surface normal. */
var(Cloth) Vector ClothWind;
/** The time it takes for the cloth to reach the wind velocity. A value of .01 should get you a quick response. Setting this value to 0.0 turns the wind off. */
var(Cloth) float ClothWindBlendTime;
/** Specifies the deviation in degrees of the vertical and horizontal wind direction */
var(Cloth) float ClothWindDirectionDeviationAngle;
/** The period of each sinusoidal cycle of the wind oscillation in seconds. */
var(Cloth) float ClothWindDirectionOscillationPeriod;
/** The deviation in the strength of the wind */
var(Cloth) float ClothWindStrengthDeviationPercentage;
/** The period of each sinusoidal cycle of the wind strength oscillation in seconds. */
var(Cloth) float ClothWindStrengthOscillationPeriod;
var native transient Pointer ClothWindDirectionVO1;
var native transient Pointer ClothWindDirectionVO2;
var native transient Pointer ClothWindStrengthVO;
var native transient Matrix ClothWindDirectionMatrix;
var native transient float ClothWindStrength;
/**  
 *If bClothBaseVelClamp is TRUE, amount of variance from base's velocity the cloth is allowed.
 *       If bClothBaseVelInterp is TRUE, how fast cloth verts are pushed towards base velocity (0..1)
 */
var(Cloth) Vector ClothBaseVelClampRange;
/** How much to blend in results from cloth simulation with results from regular skinning. */
var(Cloth) float ClothBlendWeight;
var float ClothDynamicBlendWeight;
/** Distance factor below which cloth should be fully animated. -1.0 indicates always physics. */
var(Cloth) float ClothBlendMinDistanceFactor;
/** Distance factor above which cloth should be fully simulated. */
var(Cloth) float ClothBlendMaxDistanceFactor;
/** Distance from the owner in relative frame (max == pos XYZ, min == neg XYZ) */
var(Cloth) Vector MinPosDampRange;
/** Distance from the owner in relative frame (max == pos XYZ, min == neg XYZ) */
var(Cloth) Vector MaxPosDampRange;
/** Dampening scale applied to cloth particle velocity when approaching boundaries of PosDampRange */
var(Cloth) Vector MinPosDampScale;
/** Dampening scale applied to cloth particle velocity when approaching boundaries of PosDampRange */
var(Cloth) Vector MaxPosDampScale;
var native const transient Pointer ClothSim;
var native const transient int SceneIndex;
var const array<Vector> ClothMeshPosData;
var const array<Vector> ClothMeshNormalData;
var const array<int> ClothMeshIndexData;
var int NumClothMeshVerts;
var int NumClothMeshIndices;
var const array<int> ClothMeshParentData;
var int NumClothMeshParentIndices;
var native const transient array<Vector> ClothMeshWeldedPosData;
var native const transient array<Vector> ClothMeshWeldedNormalData;
var native const transient array<int> ClothMeshWeldedIndexData;
var int ClothDirtyBufferFlag;
/** Enum indicating what type of object this cloth should be considered for rigid body collision. */
var(Cloth) const PrimitiveComponent.ERBCollisionChannel ClothRBChannel;
/** Types of objects that this cloth will collide with. */
var(Cloth) const RBCollisionChannelContainer ClothRBCollideWithChannels;
/** How much force to apply to cloth, in relation to the force(from a force field) applied to rigid bodies(zero applies no force to cloth, 1 applies the same) */
var(Cloth) const float ClothForceScale;
/** Amount to scale impulses applied to cloth simulation. */
var(Cloth) float ClothImpulseScale;
/**  
 *The cloth tear factor for this SkeletalMeshComponent, negative values take the tear factor from the SkeletalMesh.
 *    Note: UpdateClothParams() should be called after modification so that the changes are reflected in the simulation.
 */
var(Cloth) const float ClothAttachmentTearFactor;
/** If TRUE, soft body uses compartment in physics scene (usually with fixed timstep for better behaviour) */
var(Cloth) const bool bClothUseCompartment;
/** If TRUE, cloth will collide with scene shapes */
var(Cloth) const bool bClothUseSceneCollision;
/** If the distance traveled between frames exceeds this value the vertices will be reset to avoid stretching. */
var(Cloth) const float MinDistanceForClothReset;
var const transient Vector LastClothLocation;
/** Enum indicating what type of object this apex clothing should be considered for rigid body collision. */
var(ApexClothing) const PrimitiveComponent.ERBCollisionChannel ApexClothingRBChannel;
/** Types of objects that this clothing will collide with. */
var(ApexClothing) const RBCollisionChannelContainer ApexClothingRBCollideWithChannels;
/** Enum indicating what channel the apex clothing collision shapes should be placed in */
var(ApexClothing) const PrimitiveComponent.ERBCollisionChannel ApexClothingCollisionRBChannel;
/** If true, the clothing actor will stop simulating when it is not rendered */
var(ApexClothing) bool bAutoFreezeApexClothingWhenNotRendered;
/** If TRUE, WindVelocity is applied in the local space of the component, rather than world space. */
var(ApexClothing) bool bLocalSpaceWind;
/** The Wind Velocity applied to Apex Clothing */
var(ApexClothing) interp Vector WindVelocity;
/** Time taken for ApexClothing to reach WindVelocity */
var(ApexClothing) interp float WindVelocityBlendTime;
/** Maximum noise amplitude */
var(ApexClothing) float WindStrengthNoiseBounds;
/** Maximum wind strength change per second */
var(ApexClothing) float WindStrengthNoiseStepSize;
/** Higher probability to stay around the center */
var(ApexClothing) bool bWindStrengthNoiseCentered;
/** Maximum angle (in radian) on direction noise */
var(ApexClothing) float WindDirNoiseBounds;
/** Maximum angle change  (in radian per second) */
var(ApexClothing) float WindDirNoiseStepSize;
/** Higher probability to stay around the center */
var(ApexClothing) bool bWindDirNoiseCentered;
var transient float WindCurrentStrengthNoise;
var transient Vector WindCurrentDirNoise;
var const transient bool bSkipInitClothing;
var native const transient Pointer SoftBodySim;
var native const transient int SoftBodySceneIndex;
/** Whether soft-body simulation should currently be used on this SkeletalMeshComponent. */
var(SoftBody) const bool bEnableSoftBodySimulation;
var const array<Vector> SoftBodyTetraPosData;
var const array<int> SoftBodyTetraIndexData;
var int NumSoftBodyTetraVerts;
var int NumSoftBodyTetraIndices;
/** Amount to scale impulses applied to soft body simulation. */
var(SoftBody) float SoftBodyImpulseScale;
/** If true, the soft-body is 'frozen' and no simulation is taking place for it, though it will keep its shape. */
var(SoftBody) const bool bSoftBodyFrozen;
/** If true, the soft-body will automatically have bSoftBodyFrozen set when it is not rendered, and have it turned off when it is seen. */
var(SoftBody) bool bAutoFreezeSoftBodyWhenNotRendered;
/** If true, the soft-body will be awake when a level is started, otherwise it will be instantly put to sleep. */
var(SoftBody) bool bSoftBodyAwakeOnStartup;
/** If TRUE, soft body uses compartment in physics scene (usually with fixed timstep for better behaviour) */
var(SoftBody) const bool bSoftBodyUseCompartment;
/** Enum indicating what type of object this soft-body should be considered for rigid body collision. */
var(SoftBody) const PrimitiveComponent.ERBCollisionChannel SoftBodyRBChannel;
/** Types of objects that this soft-body will collide with. */
var(SoftBody) const RBCollisionChannelContainer SoftBodyRBCollideWithChannels;
var native const transient Pointer SoftBodyASVPlane;
var Material LimitMaterial;
var transient BoneAtom RootMotionDelta;
var transient Vector RootMotionVelocity;
var const transient Vector RootBoneTranslation;
var Vector RootMotionAccelScale;
var() SkeletalMeshComponent.ERootMotionMode RootMotionMode;
var const SkeletalMeshComponent.ERootMotionMode PreviousRMM;
var SkeletalMeshComponent.ERootMotionMode PendingRMM;
var SkeletalMeshComponent.ERootMotionMode OldPendingRMM;
var const int bRMMOneFrameDelay;
var() SkeletalMeshComponent.ERootMotionRotationMode RootMotionRotationMode;
/** SkeletalMeshComponent settings for AnimRotationOnly */
var() SkeletalMeshComponent.EAnimRotationOnly AnimRotationOnly;
/** How FaceFX transforms should be blended with skeletal mesh */
var() SkeletalMeshComponent.EFaceFXBlendMode FaceFXBlendMode;
var native transient Pointer FaceFXActorInstance;
var export editinline AudioComponent CachedFaceFXAudioComp;
var const transient array<byte> BoneVisibilityStates;
var AkEvent CachedFaceFxAkEvent;
var const transient BoneAtom LocalToWorldBoneAtom;
var transient float ProgressiveDrawingFraction;
var transient byte CustomSortAlternateIndexMode;
var transient array<name> MorphTargetsQueried;
var export editinline SkeletalMeshComponent LODParent;
/** Whether the primitive supports cheap on/off environment preshadows from the dominant directional light */
var(Lighting) bool bAllowBooleanPreshadows;
var transient float InterpolatedBooleanPreshadowFactor;
var transient float CurrentBooleanPreshadowFactor;
var transient float LastBooleanPreshadowFactor;
var transient Double LastBooleanPreshadowUpdateTime;
/** Whether to use based on distance factor tick optimization. */
var(Optimization) const bool bUseTickOptimization;
var const int TickCount;
var const transient int LastDropRate;
var const transient float LastDropRateChange;
var const transient float AccumulatedDroppedDeltaTime;
var const transient float ComponentDroppedDeltaTime;

// Export USkeletalMeshComponent::execAttachComponent(FFrame&, void* const)
native final function AttachComponent(ActorComponent Component, name BoneName, optional Vector RelativeLocation, optional Rotator RelativeRotation, optional Vector RelativeScale);

// Export USkeletalMeshComponent::execDetachComponent(FFrame&, void* const)
native final function DetachComponent(ActorComponent Component);

// Export USkeletalMeshComponent::execAttachComponentToSocket(FFrame&, void* const)
native final function AttachComponentToSocket(ActorComponent Component, name SocketName);

// Export USkeletalMeshComponent::execGetSocketWorldLocationAndRotation(FFrame&, void* const)
native final function bool GetSocketWorldLocationAndRotation(name InSocketName, out Vector OutLocation, optional out Rotator OutRotation, optional int Space);

// Export USkeletalMeshComponent::execGetSocketMatrix(FFrame&, void* const)
native final function Matrix GetSocketMatrix(name SocketName);

// Export USkeletalMeshComponent::execGetSocketByName(FFrame&, void* const)
native final function SkeletalMeshSocket GetSocketByName(name InSocketName);

// Export USkeletalMeshComponent::execGetSocketBoneName(FFrame&, void* const)
native final function name GetSocketBoneName(name InSocketName);

// Export USkeletalMeshComponent::execFindComponentAttachedToBone(FFrame&, void* const)
native final function ActorComponent FindComponentAttachedToBone(name InBoneName);

// Export USkeletalMeshComponent::execIsComponentAttached(FFrame&, void* const)
native final function bool IsComponentAttached(ActorComponent Component, optional name BoneName);

// Export USkeletalMeshComponent::execAttachedComponents(FFrame&, void* const)
native final iterator function AttachedComponents(class<ActorComponent> BaseClass, out ActorComponent OutComponent);

// Export USkeletalMeshComponent::execGetTransformMatrix(FFrame&, void* const)
native final function Matrix GetTransformMatrix();

// Export USkeletalMeshComponent::execSetSkeletalMesh(FFrame&, void* const)
native final simulated function SetSkeletalMesh(SkeletalMesh NewMesh, optional bool bKeepSpaceBases);

// Export USkeletalMeshComponent::execSetPhysicsAsset(FFrame&, void* const)
native final simulated function SetPhysicsAsset(PhysicsAsset NewPhysicsAsset, optional PhysicsAsset NewPhysicsAssetForFlex, optional bool bForceReInit);

// Export USkeletalMeshComponent::execSetForceRefPose(FFrame&, void* const)
native final simulated function SetForceRefPose(bool bNewForceRefPose);

// Export USkeletalMeshComponent::execSetEnableClothSimulation(FFrame&, void* const)
native final simulated function SetEnableClothSimulation(bool bInEnable);

// Export USkeletalMeshComponent::execSetClothFrozen(FFrame&, void* const)
native final simulated function SetClothFrozen(bool bNewFrozen);

// Export USkeletalMeshComponent::execSetEnableClothingSimulation(FFrame&, void* const)
native final simulated function SetEnableClothingSimulation(bool bInEnable);

// Export USkeletalMeshComponent::execUpdateClothParams(FFrame&, void* const)
native final simulated function UpdateClothParams();

// Export USkeletalMeshComponent::execSetClothExternalForce(FFrame&, void* const)
native final simulated function SetClothExternalForce(Vector InForce);

// Export USkeletalMeshComponent::execSetAttachClothVertsToBaseBody(FFrame&, void* const)
native final simulated function SetAttachClothVertsToBaseBody(bool bAttachVerts);

// Export USkeletalMeshComponent::execResetClothVertsToRefPose(FFrame&, void* const)
native final simulated function ResetClothVertsToRefPose();

// Export USkeletalMeshComponent::execForceApexClothingTeleportAndReset(FFrame&, void* const)
native final simulated function ForceApexClothingTeleportAndReset();

// Export USkeletalMeshComponent::execForceApexClothingTeleport(FFrame&, void* const)
native final simulated function ForceApexClothingTeleport();

// Export USkeletalMeshComponent::execGetClothAttachmentResponseCoefficient(FFrame&, void* const)
native final simulated function float GetClothAttachmentResponseCoefficient();

// Export USkeletalMeshComponent::execGetClothAttachmentTearFactor(FFrame&, void* const)
native final simulated function float GetClothAttachmentTearFactor();

// Export USkeletalMeshComponent::execGetClothBendingStiffness(FFrame&, void* const)
native final simulated function float GetClothBendingStiffness();

// Export USkeletalMeshComponent::execGetClothCollisionResponseCoefficient(FFrame&, void* const)
native final simulated function float GetClothCollisionResponseCoefficient();

// Export USkeletalMeshComponent::execGetClothDampingCoefficient(FFrame&, void* const)
native final simulated function float GetClothDampingCoefficient();

// Export USkeletalMeshComponent::execGetClothFlags(FFrame&, void* const)
native final simulated function int GetClothFlags();

// Export USkeletalMeshComponent::execGetClothFriction(FFrame&, void* const)
native final simulated function float GetClothFriction();

// Export USkeletalMeshComponent::execGetClothPressure(FFrame&, void* const)
native final simulated function float GetClothPressure();

// Export USkeletalMeshComponent::execGetClothSleepLinearVelocity(FFrame&, void* const)
native final simulated function float GetClothSleepLinearVelocity();

// Export USkeletalMeshComponent::execGetClothSolverIterations(FFrame&, void* const)
native final simulated function int GetClothSolverIterations();

// Export USkeletalMeshComponent::execGetClothStretchingStiffness(FFrame&, void* const)
native final simulated function float GetClothStretchingStiffness();

// Export USkeletalMeshComponent::execGetClothTearFactor(FFrame&, void* const)
native final simulated function float GetClothTearFactor();

// Export USkeletalMeshComponent::execGetClothThickness(FFrame&, void* const)
native final simulated function float GetClothThickness();

// Export USkeletalMeshComponent::execSetClothAttachmentResponseCoefficient(FFrame&, void* const)
native final simulated function SetClothAttachmentResponseCoefficient(float ClothAttachmentResponseCoefficient);

// Export USkeletalMeshComponent::execSetClothAttachmentTearFactor(FFrame&, void* const)
native final simulated function SetClothAttachmentTearFactor(float ClothAttachTearFactor);

// Export USkeletalMeshComponent::execSetClothBendingStiffness(FFrame&, void* const)
native final simulated function SetClothBendingStiffness(float ClothBendingStiffness);

// Export USkeletalMeshComponent::execSetClothCollisionResponseCoefficient(FFrame&, void* const)
native final simulated function SetClothCollisionResponseCoefficient(float ClothCollisionResponseCoefficient);

// Export USkeletalMeshComponent::execSetClothDampingCoefficient(FFrame&, void* const)
native final simulated function SetClothDampingCoefficient(float ClothDampingCoefficient);

// Export USkeletalMeshComponent::execSetClothFlags(FFrame&, void* const)
native final simulated function SetClothFlags(int ClothFlags);

// Export USkeletalMeshComponent::execSetClothFriction(FFrame&, void* const)
native final simulated function SetClothFriction(float ClothFriction);

// Export USkeletalMeshComponent::execSetClothPressure(FFrame&, void* const)
native final simulated function SetClothPressure(float ClothPressure);

// Export USkeletalMeshComponent::execSetClothSleepLinearVelocity(FFrame&, void* const)
native final simulated function SetClothSleepLinearVelocity(float ClothSleepLinearVelocity);

// Export USkeletalMeshComponent::execSetClothSolverIterations(FFrame&, void* const)
native final simulated function SetClothSolverIterations(int ClothSolverIterations);

// Export USkeletalMeshComponent::execSetClothStretchingStiffness(FFrame&, void* const)
native final simulated function SetClothStretchingStiffness(float ClothStretchingStiffness);

// Export USkeletalMeshComponent::execSetClothTearFactor(FFrame&, void* const)
native final simulated function SetClothTearFactor(float ClothTearFactor);

// Export USkeletalMeshComponent::execSetClothThickness(FFrame&, void* const)
native final simulated function SetClothThickness(float ClothThickness);

// Export USkeletalMeshComponent::execSetClothSleep(FFrame&, void* const)
native final simulated function SetClothSleep(bool IfClothSleep);

// Export USkeletalMeshComponent::execSetClothPosition(FFrame&, void* const)
native final simulated function SetClothPosition(Vector ClothOffSet);

// Export USkeletalMeshComponent::execSetClothVelocity(FFrame&, void* const)
native final simulated function SetClothVelocity(Vector VelocityOffSet);

// Export USkeletalMeshComponent::execAttachClothToCollidingShapes(FFrame&, void* const)
native final simulated function AttachClothToCollidingShapes(bool AttatchTwoWay, bool AttachTearable);

// Export USkeletalMeshComponent::execEnableClothValidBounds(FFrame&, void* const)
native final simulated function EnableClothValidBounds(bool IfEnableClothValidBounds);

// Export USkeletalMeshComponent::execSetClothValidBounds(FFrame&, void* const)
native final simulated function SetClothValidBounds(Vector ClothValidBoundsMin, Vector ClothValidBoundsMax);

// Export USkeletalMeshComponent::execUpdateSoftBodyParams(FFrame&, void* const)
native final simulated function UpdateSoftBodyParams();

// Export USkeletalMeshComponent::execSetSoftBodyFrozen(FFrame&, void* const)
native final simulated function SetSoftBodyFrozen(bool bNewFrozen);

// Export USkeletalMeshComponent::execWakeSoftBody(FFrame&, void* const)
native final simulated function WakeSoftBody();

// Export USkeletalMeshComponent::execFindAnimSequence(FFrame&, void* const)
native final function AnimSequence FindAnimSequence(name AnimSeqName);

// Export USkeletalMeshComponent::execSaveAnimSets(FFrame&, void* const)
native final function SaveAnimSets();

// Export USkeletalMeshComponent::execRestoreSavedAnimSets(FFrame&, void* const)
native final function RestoreSavedAnimSets();

final function float GetAnimRateByDuration(name AnimSeqName, float Duration)
{
    local AnimSequence AnimSeq;

    AnimSeq = FindAnimSequence(AnimSeqName);
    if((AnimSeq == none) || AnimSeq.RateScale <= 0)
    {
        return 1;
    }
    return AnimSeq.SequenceLength / (Duration * AnimSeq.RateScale);
}

final function float GetAnimLength(name AnimSeqName)
{
    local AnimSequence AnimSeq;

    AnimSeq = FindAnimSequence(AnimSeqName);
    if((AnimSeq == none) || AnimSeq.RateScale <= 0)
    {
        return 0;
    }
    return AnimSeq.SequenceLength / AnimSeq.RateScale;
}

// Export USkeletalMeshComponent::execFindMorphTarget(FFrame&, void* const)
native final function MorphTarget FindMorphTarget(name MorphTargetName);

// Export USkeletalMeshComponent::execFindAnimNode(FFrame&, void* const)
native final function AnimNode FindAnimNode(name InNodeName);

// Export USkeletalMeshComponent::execAllAnimNodes(FFrame&, void* const)
native final iterator function AllAnimNodes(class<AnimNode> BaseClass, out AnimNode Node);

// Export USkeletalMeshComponent::execFindSkelControl(FFrame&, void* const)
native final function SkelControlBase FindSkelControl(name InControlName);

// Export USkeletalMeshComponent::execFindMorphNode(FFrame&, void* const)
native final function MorphNodeBase FindMorphNode(name InNodeName);

// Export USkeletalMeshComponent::execGetBoneQuaternion(FFrame&, void* const)
native final function Quat GetBoneQuaternion(name BoneName, optional int Space);

// Export USkeletalMeshComponent::execGetBoneLocation(FFrame&, void* const)
native final function Vector GetBoneLocation(name BoneName, optional int Space);

// Export USkeletalMeshComponent::execMatchRefBone(FFrame&, void* const)
native final function int MatchRefBone(name BoneName);

// Export USkeletalMeshComponent::execGetBoneName(FFrame&, void* const)
native final function name GetBoneName(int BoneIndex);

// Export USkeletalMeshComponent::execGetBoneMatrix(FFrame&, void* const)
native final function Matrix GetBoneMatrix(int BoneIndex);

// Export USkeletalMeshComponent::execGetParentBone(FFrame&, void* const)
native final function name GetParentBone(name BoneName);

// Export USkeletalMeshComponent::execGetBoneNames(FFrame&, void* const)
native final function GetBoneNames(out array<name> BoneNames);

// Export USkeletalMeshComponent::execBoneIsChildOf(FFrame&, void* const)
native final function bool BoneIsChildOf(name BoneName, name ParentBoneName);

// Export USkeletalMeshComponent::execGetRefPosePosition(FFrame&, void* const)
native final function Vector GetRefPosePosition(int BoneIndex);

// Export USkeletalMeshComponent::execGetBoneAxis(FFrame&, void* const)
native final function Vector GetBoneAxis(name BoneName, Core.Object.EAxis Axis);

// Export USkeletalMeshComponent::execTransformToBoneSpace(FFrame&, void* const)
native final function TransformToBoneSpace(name BoneName, Vector InPosition, Rotator InRotation, out Vector OutPosition, out Rotator OutRotation);

// Export USkeletalMeshComponent::execTransformFromBoneSpace(FFrame&, void* const)
native final function TransformFromBoneSpace(name BoneName, Vector InPosition, Rotator InRotation, out Vector OutPosition, out Rotator OutRotation);

// Export USkeletalMeshComponent::execFindClosestBone(FFrame&, void* const)
native final function name FindClosestBone(Vector TestLocation, optional out Vector BoneLocation, optional float IgnoreScale);

// Export USkeletalMeshComponent::execFindClosestBones(FFrame&, void* const)
native final function bool FindClosestBones(Vector TestLocation, int NumBones, out array<name> ClosestBonesList, optional array<name> SearchBonesList, optional float IgnoreScale);

// Export USkeletalMeshComponent::execGetClosestCollidingBoneLocation(FFrame&, void* const)
native final function Vector GetClosestCollidingBoneLocation(Vector TestLocation, bool bCheckZeroExtent, bool bCheckNonZeroExtent);

// Export USkeletalMeshComponent::execSetAnimTreeTemplate(FFrame&, void* const)
native final function SetAnimTreeTemplate(AnimTree NewTemplate);

// Export USkeletalMeshComponent::execSetParentAnimComponent(FFrame&, void* const)
native final function SetParentAnimComponent(SkeletalMeshComponent NewParentAnimComp);

// Export USkeletalMeshComponent::execUpdateParentBoneMap(FFrame&, void* const)
native final function UpdateParentBoneMap();

// Export USkeletalMeshComponent::execInitSkelControls(FFrame&, void* const)
native final function InitSkelControls();

// Export USkeletalMeshComponent::execInitMorphTargets(FFrame&, void* const)
native final function InitMorphTargets();

// Export USkeletalMeshComponent::execFindConstraintIndex(FFrame&, void* const)
native final function int FindConstraintIndex(name ConstraintName);

// Export USkeletalMeshComponent::execFindConstraintBoneName(FFrame&, void* const)
native final function name FindConstraintBoneName(int ConstraintIndex);

// Export USkeletalMeshComponent::execFindBodyInstanceNamed(FFrame&, void* const)
native final function RB_BodyInstance FindBodyInstanceNamed(name BoneName);

// Export USkeletalMeshComponent::execSetHasPhysicsAssetInstance(FFrame&, void* const)
native final function SetHasPhysicsAssetInstance(bool bHasInstance, optional bool bUseCurrentPosition);

// Export USkeletalMeshComponent::execUpdateRBBonesFromSpaceBases(FFrame&, void* const)
native final function UpdateRBBonesFromSpaceBases(bool bMoveUnfixedBodies, bool bTeleport);

// Export USkeletalMeshComponent::execForceSkelUpdate(FFrame&, void* const)
native final function ForceSkelUpdate();

// Export USkeletalMeshComponent::execUpdateAnimations(FFrame&, void* const)
native final function UpdateAnimations();

// Export USkeletalMeshComponent::execGetBonesWithinRadius(FFrame&, void* const)
native final function bool GetBonesWithinRadius(Vector Origin, float Radius, int TraceFlags, out array<name> out_Bones);

// Export USkeletalMeshComponent::execAddInstanceVertexWeightBoneParented(FFrame&, void* const)
native final function AddInstanceVertexWeightBoneParented(name BoneName, optional bool bPairWithParent)
{
    bPairWithParent = true;                
}

// Export USkeletalMeshComponent::execRemoveInstanceVertexWeightBoneParented(FFrame&, void* const)
native final function RemoveInstanceVertexWeightBoneParented(name BoneName);

// Export USkeletalMeshComponent::execFindInstanceVertexweightBonePair(FFrame&, void* const)
native final function int FindInstanceVertexweightBonePair(BonePair Bones);

// Export USkeletalMeshComponent::execUpdateInstanceVertexWeightBones(FFrame&, void* const)
native final function UpdateInstanceVertexWeightBones(array<BonePair> BonePairs);

// Export USkeletalMeshComponent::execToggleInstanceVertexWeights(FFrame&, void* const)
native final function ToggleInstanceVertexWeights(bool bEnable, int LODIdx);

// Export USkeletalMeshComponent::execPlayFaceFXAnim(FFrame&, void* const)
native final function bool PlayFaceFXAnim(FaceFXAnimSet FaceFXAnimSetRef, string AnimName, string GroupName, SoundCue SoundCueToPlay, AkEvent AkEventToPlay);

// Export USkeletalMeshComponent::execStopFaceFXAnim(FFrame&, void* const)
native final function StopFaceFXAnim();

// Export USkeletalMeshComponent::execIsPlayingFaceFXAnim(FFrame&, void* const)
native final function bool IsPlayingFaceFXAnim();

// Export USkeletalMeshComponent::execDeclareFaceFXRegister(FFrame&, void* const)
native final function DeclareFaceFXRegister(string RegName);

// Export USkeletalMeshComponent::execGetFaceFXRegister(FFrame&, void* const)
native final function float GetFaceFXRegister(string RegName);

// Export USkeletalMeshComponent::execSetFaceFXRegister(FFrame&, void* const)
native final function SetFaceFXRegister(string RegName, float RegVal, SkeletalMeshComponent.EFaceFXRegOp RegOp, optional float InterpDuration);

// Export USkeletalMeshComponent::execSetFaceFXRegisterEx(FFrame&, void* const)
native final function SetFaceFXRegisterEx(string RegName, SkeletalMeshComponent.EFaceFXRegOp RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration);

// Export USkeletalMeshComponent::execHideBone(FFrame&, void* const)
native final function HideBone(int BoneIndex, SkeletalMeshComponent.EPhysBodyOp PhysBodyOption);

// Export USkeletalMeshComponent::execUnHideBone(FFrame&, void* const)
native final function UnHideBone(int BoneIndex);

// Export USkeletalMeshComponent::execIsBoneHidden(FFrame&, void* const)
native final function bool IsBoneHidden(int BoneIndex);

// Export USkeletalMeshComponent::execHideBoneByName(FFrame&, void* const)
native final function HideBoneByName(name BoneName, SkeletalMeshComponent.EPhysBodyOp PhysBodyOption);

// Export USkeletalMeshComponent::execUnHideBoneByName(FFrame&, void* const)
native final function UnHideBoneByName(name BoneName);

// Export USkeletalMeshComponent::execUpdateMeshForBrokenConstraints(FFrame&, void* const)
native final simulated function UpdateMeshForBrokenConstraints();

// Export USkeletalMeshComponent::execShowMaterialSection(FFrame&, void* const)
native final simulated function ShowMaterialSection(int MaterialID, bool bShow, int LODIndex);

function PlayAnim(name AnimName, optional float Duration, optional bool bLoop, optional bool bRestartIfAlreadyPlaying, optional float StartTime, optional bool bPlayBackwards)
{
    local AnimNodeSequence AnimNode;
    local float DesiredRate;

    bRestartIfAlreadyPlaying = true;
    StartTime = 0;
    bPlayBackwards = false;
    AnimNode = AnimNodeSequence(Animations);
    if((AnimNode == none) && Animations.IsA('AnimTree'))
    {
        AnimNode = AnimNodeSequence(AnimTree(Animations).Children[0].Anim);
    }
    if(AnimNode == none)
    {
        WarnInternal(("Base animation node is not an AnimNodeSequence (Owner:" @ string(Owner)) $ ")");        
    }
    else
    {
        if((AnimNode.AnimSeq != none) && AnimNode.AnimSeq.SequenceName == AnimName)
        {
            DesiredRate = ((Duration > 0) ? AnimNode.AnimSeq.SequenceLength / (Duration * AnimNode.AnimSeq.RateScale) : 1);
            DesiredRate = ((bPlayBackwards) ? -DesiredRate : DesiredRate);
            if(bRestartIfAlreadyPlaying || !AnimNode.bPlaying)
            {
                AnimNode.PlayAnim(bLoop, DesiredRate, StartTime);                
            }
            else
            {
                AnimNode.Rate = DesiredRate;
                AnimNode.bLooping = bLoop;
            }            
        }
        else
        {
            AnimNode.SetAnim(AnimName);
            if(AnimNode.AnimSeq != none)
            {
                DesiredRate = ((Duration > 0) ? AnimNode.AnimSeq.SequenceLength / (Duration * AnimNode.AnimSeq.RateScale) : 1);
                DesiredRate = ((bPlayBackwards) ? -DesiredRate : DesiredRate);
                AnimNode.PlayAnim(bLoop, DesiredRate, StartTime);
            }
        }
    }
}

function StopAnim()
{
    local AnimNodeSequence AnimNode;

    AnimNode = AnimNodeSequence(Animations);
    if((AnimNode == none) && Animations.IsA('AnimTree'))
    {
        AnimNode = AnimNodeSequence(AnimTree(Animations).Children[0].Anim);
    }
    if(AnimNode == none)
    {
        WarnInternal(("Base animation node is not an AnimNodeSequence (Owner:" @ string(Owner)) $ ")");        
    }
    else
    {
        AnimNode.StopAnim();
    }
}

event bool CreateForceField(const AnimNotify_ForceField AnimNotifyData)
{
    local editinline NxForceFieldComponent NewForceFieldComponent;

    NewForceFieldComponent = new (self) AnimNotifyData.ForceFieldComponent.Class (AnimNotifyData.ForceFieldComponent);
    NewForceFieldComponent.DoInitRBPhys();
    if(AnimNotifyData.SocketName != 'None')
    {
        AttachComponentToSocket(NewForceFieldComponent, AnimNotifyData.SocketName);        
    }
    else
    {
        if(AnimNotifyData.BoneName != 'None')
        {
            AttachComponent(NewForceFieldComponent, AnimNotifyData.BoneName);
        }
    }
    return true;
}

event bool PlayParticleEffect(const AnimNotify_PlayParticleEffect AnimNotifyData)
{
    local Vector Loc;
    local Rotator Rot;
    local WorldInfo WI;
    local editinline ParticleSystemComponent PSC, EmitterPSC;
    local bool bPlayNonExtreme;

    WI = Class'WorldInfo'.static.GetWorldInfo();
    if(WI.NetMode == NM_DedicatedServer)
    {
        LogInternal("(SkeletalMeshComponent): PlayParticleEffect on dedicated server!");
        return true;
    }
    if(AnimNotifyData.PSTemplate == none)
    {
        return false;
    }
    bPlayNonExtreme = (AnimNotifyData.bIsExtremeContent && Class'Engine'.static.IsGame()) && !WI.GRI.ShouldShowGore();
    if(bPlayNonExtreme && AnimNotifyData.PSNonExtremeContentTemplate == none)
    {
        return false;
    }
    if(AnimNotifyData.bAttach)
    {
        PSC = new (self) Class'ParticleSystemComponent';
        if(bPlayNonExtreme)
        {
            PSC.SetTemplate(AnimNotifyData.PSNonExtremeContentTemplate);            
        }
        else
        {
            PSC.SetTemplate(AnimNotifyData.PSTemplate);
        }
        if(AnimNotifyData.SocketName != 'None')
        {
            AttachComponentToSocket(PSC, AnimNotifyData.SocketName);            
        }
        else
        {
            if(AnimNotifyData.BoneName != 'None')
            {
                AttachComponent(PSC, AnimNotifyData.BoneName);
            }
        }
        PSC.ActivateSystem(true);
        PSC.__OnSystemFinished__Delegate = SkelMeshCompOnParticleSystemFinished;        
    }
    else
    {
        if(AnimNotifyData.SocketName != 'None')
        {
            GetSocketWorldLocationAndRotation(AnimNotifyData.SocketName, Loc, Rot);            
        }
        else
        {
            if(AnimNotifyData.BoneName != 'None')
            {
                Loc = GetBoneLocation(AnimNotifyData.BoneName);
                Rot = rot(0, 0, 1);                
            }
            else
            {
                Loc = GetPosition();
                Rot = rot(0, 0, 1);
            }
        }
        if(((Owner != none) && Owner.WorldInfo != none) && Owner.WorldInfo.MyEmitterPool != none)
        {
            if(bPlayNonExtreme)
            {
                EmitterPSC = Owner.WorldInfo.MyEmitterPool.SpawnEmitter(AnimNotifyData.PSNonExtremeContentTemplate, Loc, Rot);                
            }
            else
            {
                EmitterPSC = Owner.WorldInfo.MyEmitterPool.SpawnEmitter(AnimNotifyData.PSTemplate, Loc, Rot);
            }            
        }
        else
        {
            if(Class'Engine'.static.IsGame())
            {
                PSC = new (self) Class'ParticleSystemComponent';
                PSC.SetTemplate(AnimNotifyData.PSTemplate);
                PSC.SetAbsolute(true, true, true);
                PSC.SetTranslation(Loc);
                PSC.SetRotation(Rot);
                PSC.ActivateSystem(true);
                PSC.__OnSystemFinished__Delegate = SkelMeshCompOnParticleSystemFinished;                
            }
            else
            {
                if(Class'Engine'.static.IsEditor())
                {
                    PSC = new (self) Class'ParticleSystemComponent';
                    PSC.SetTemplate(AnimNotifyData.PSTemplate);
                    PSC.SetAbsolute(true, true, true);
                    PSC.SetTranslation(Loc);
                    PSC.SetRotation(Rot);
                    if(AnimNotifyData.SocketName != 'None')
                    {
                        AttachComponentToSocket(PSC, AnimNotifyData.SocketName);                        
                    }
                    else
                    {
                        if(AnimNotifyData.BoneName != 'None')
                        {
                            AttachComponent(PSC, AnimNotifyData.BoneName);
                        }
                    }
                    PSC.ActivateSystem(true);
                    PSC.__OnSystemFinished__Delegate = SkelMeshCompOnParticleSystemFinished;                    
                }
                else
                {
                    return false;
                }
            }
        }
    }
    if(((PSC != none) && AnimNotifyData.BoneSocketModuleActorName != 'None') && Owner != none)
    {
        PSC.SetLightingChannels(LightingChannels);
        PSC.SetActorParameter(AnimNotifyData.BoneSocketModuleActorName, Owner);
    }
    if((PSC != none) && Owner != none)
    {
        Owner.OnAnimNotifyParticleSystemSpawned(AnimNotifyData, PSC);
    }
    if((EmitterPSC != none) && Owner != none)
    {
        Owner.OnAnimNotifyParticleSystemSpawned(AnimNotifyData, EmitterPSC);
    }
    return true;
}

simulated function SkelMeshCompOnParticleSystemFinished(ParticleSystemComponent PSC)
{
    DetachComponent(PSC);
}

final simulated function ToggleAlternateBoneWeights(name InBoneName)
{
    local int LODIdx;

    LODIdx = 0;
    J0x0B:

    if(LODIdx < LODInfo.Length)
    {
        if(LODInfo[LODIdx].InstanceWeightUsage == 0)
        {
            ToggleInstanceVertexWeights(true, LODIdx);
        }
        ++ LODIdx;
        goto J0x0B;
    }
    AddInstanceVertexWeightBoneParented(InBoneName);
}

final simulated function BreakConstraint(name InBoneName)
{
    local int ConstraintIndex, LODIdx;
    local RB_ConstraintInstance Constraint;
    local RB_ConstraintSetup ConstraintSetup;
    local RB_BodyInstance Body;
    local int BodyIndex;

    ConstraintIndex = FindConstraintIndex(InBoneName);
    if(ConstraintIndex == -1)
    {
        return;
    }
    Constraint = PhysicsAssetInstance.Constraints[ConstraintIndex];
    if(Constraint.bTerminated)
    {
        return;
    }
    LODIdx = 0;
    J0x93:

    if(LODIdx < LODInfo.Length)
    {
        if(LODInfo[LODIdx].InstanceWeightUsage == 0)
        {
            ToggleInstanceVertexWeights(true, LODIdx);
        }
        ++ LODIdx;
        goto J0x93;
    }
    AddInstanceVertexWeightBoneParented(InBoneName);
    ConstraintSetup = PhysicsAsset.ConstraintSetup[Constraint.ConstraintIndex];
    Body = FindBodyInstanceNamed(ConstraintSetup.JointName);
    if((Body != none) && Body.IsFixed())
    {
        Body.SetFixed(false);
    }
    Constraint.TermConstraint();
    UpdateMeshForBrokenConstraints();
    BodyIndex = PhysicsAsset.FindBodyIndex(InBoneName);
    if(BodyIndex != -1)
    {
        if(PhysicsAsset.BodySetup[BodyIndex].bConsiderForBounds && PhysicsAsset.BodySetup[BodyIndex].bNoCollision)
        {
            HideBoneByName(InBoneName, 0);
        }
    }
}

final simulated function bool IsBrokenConstraint(name InBoneName)
{
    local int ConstraintIndex;
    local RB_ConstraintInstance Constraint;

    ConstraintIndex = FindConstraintIndex(InBoneName);
    if(ConstraintIndex == -1)
    {
        return false;
    }
    Constraint = PhysicsAssetInstance.Constraints[ConstraintIndex];
    return Constraint.bTerminated;
}

// Export USkeletalMeshComponent::execGetPosition(FFrame&, void* const)
native function Vector GetPosition();

// Export USkeletalMeshComponent::execGetRotation(FFrame&, void* const)
native function Rotator GetRotation();

// Export USkeletalMeshComponent::execSetMaterial(FFrame&, void* const)
native function SetMaterial(int ElementIndex, MaterialInterface Material);

// Export USkeletalMeshComponent::execSetLODParent(FFrame&, void* const)
native final function SetLODParent(SkeletalMeshComponent NewLODParent);

defaultproperties
{
    GlobalAnimRateScale=1
    StreamingDistanceMultiplier=1
    WireframeColor=(B=255,G=255,R=221,A=255)
    LowUpdateFrameRate=2
    AnimationLODFrameRate=2
    ChunkIndexPreview=-1
    SectionIndexPreview=-1
    bTransformFromAnimParent=1
    bUpdateSkelWhenNotRendered=true
    bTickAnimNodesWhenNotRendered=true
    bUpdateKinematicBonesFromAnimation=true
    bSyncActorLocationToRootRigidBody=true
    LineCheckBoundsScale=(X=1,Y=1,Z=1)
    bAutoFreezeClothWhenNotRendered=true
    bCacheAnimSequenceNodes=true
    ClothWindBlendTime=5
    ClothBlendWeight=1
    ClothBlendMinDistanceFactor=-1
    ClothRBChannel=ERBCollisionChannel.RBCC_Cloth
    ClothImpulseScale=1
    ClothAttachmentTearFactor=-1
    MinDistanceForClothReset=256
    ApexClothingRBChannel=ERBCollisionChannel.RBCC_Clothing
    ApexClothingRBCollideWithChannels=(Default=true,Nothing=false,Pawn=false,Vehicle=false,Water=false,GameplayPhysics=true,EffectPhysics=true,Untitled1=false,Untitled2=false,Untitled3=false,Untitled4=false,Cloth=false,FluidDrain=false,SoftBody=false,FracturedMeshPart=false,BlockingVolume=true,DeadPawn=false,Clothing=false,ClothingCollision=true,Pickup=false,FlexAsset=false,CanBecomeDynamic=false,KnockedDownPawn=false,Visibility=false)
    ApexClothingCollisionRBChannel=ERBCollisionChannel.RBCC_ClothingCollision
    bAutoFreezeApexClothingWhenNotRendered=true
    SoftBodyImpulseScale=1
    bSoftBodyUseCompartment=true
    SoftBodyRBChannel=ERBCollisionChannel.RBCC_SoftBody
    RootMotionAccelScale=(X=1,Y=1,Z=1)
    RootMotionMode=ERootMotionMode.RMM_Ignore
    PreviousRMM=ERootMotionMode.RMM_Ignore
    FaceFXBlendMode=EFaceFXBlendMode.FXBM_Additive
    ProgressiveDrawingFraction=1
    bAllowBooleanPreshadows=true
    InterpolatedBooleanPreshadowFactor=-1
    bUseTickOptimization=true
    ReplacementPrimitive=none
    bAcceptsDynamicDecals=false
    TickGroup=ETickingGroup.TG_PreAsyncWork
}