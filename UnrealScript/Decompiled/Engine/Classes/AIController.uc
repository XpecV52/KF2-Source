/*******************************************************************************
 * AIController generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AIController extends Controller
    native(AI)
    notplaceable
    hidecategories(Navigation);

var float Skill;
var Actor ScriptedMoveTarget;
var Route ScriptedRoute;
var bool bReverseScriptedRoute;
var int ScriptedRouteIndex;
var Actor ScriptedFocus;

event PreBeginPlay()
{
    super(Actor).PreBeginPlay();
    if(bDeleteMe)
    {
        return;
    }
    if(WorldInfo.Game != none)
    {
        Skill += WorldInfo.Game.GameDifficulty;
    }
    Skill = FClamp(Skill, 0, 3);
}

event AILog_Internal(coerce string LogText, optional name LogCategory, optional bool bForce, optional bool BugIt, optional bool bSkipExtraInfo);

function Reset()
{
    super.Reset();
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local int I;
    local string T;
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    super.DisplayDebug(HUD, out_YL, out_YPos);
    if(HUD.ShouldDisplayDebug('AI'))
    {
        Canvas.DrawColor.B = 255;
        if(((Pawn != none) && MoveTarget != none) && Pawn.ReachedDestination(MoveTarget))
        {
            Canvas.DrawText((((("     Skill " $ string(Skill)) $ " NAVIGATION MoveTarget ") $ (GetItemName(string(MoveTarget)))) $ "(REACHED) MoveTimer ") $ string(MoveTimer), false);            
        }
        else
        {
            Canvas.DrawText((((("     Skill " $ string(Skill)) $ " NAVIGATION MoveTarget ") $ (GetItemName(string(MoveTarget)))) $ " MoveTimer ") $ string(MoveTimer), false);
        }
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((((("      Destination " $ string(GetDestinationPosition())) $ " Focus ") $ (GetItemName(string(Focus)))) $ " Preparing Move ") $ string(bPreparingMove), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        Canvas.DrawText((("     RouteGoal " $ (GetItemName(string(RouteGoal)))) $ " RouteDist ") $ string(RouteDist), false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        I = 0;
        J0x3DC:

        if(I < RouteCache.Length)
        {
            if(RouteCache[I] == none)
            {
                if(I > 5)
                {
                    T = (T $ "--") $ (GetItemName(string(RouteCache[I - 1])));
                }
                goto J0x4B7;                
            }
            else
            {
                if(I < 5)
                {
                    T = (T $ (GetItemName(string(RouteCache[I])))) $ "-";
                }
            }
            ++ I;
            goto J0x3DC;
        }
        J0x4B7:

        Canvas.DrawText("     RouteCache: " $ T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
}

event SetTeam(int inTeamIdx)
{
    WorldInfo.Game.ChangeTeam(self, inTeamIdx, true);
}

simulated event GetPlayerViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    if(Pawn != none)
    {
        out_Location = Pawn.Location;
        out_Rotation = Pawn.Rotation;        
    }
    else
    {
        super.GetPlayerViewPoint(out_Location, out_Rotation);
    }
}

function OnAIMoveToActor(SeqAct_AIMoveToActor Action)
{
    local Actor destActor;
    local SeqVar_Object ObjVar;

    ClearLatentAction(Class'SeqAct_AIMoveToActor', true, Action);
    destActor = Action.PickDestination(Pawn);
    if(destActor != none)
    {
        ScriptedRoute = Route(destActor);
        if(ScriptedRoute != none)
        {
            if(ScriptedRoute.RouteList.Length == 0)
            {
                WarnInternal("Invalid route with empty MoveList for scripted move");                
            }
            else
            {
                ScriptedRouteIndex = 0;
                if(!IsInState('ScriptedRouteMove'))
                {
                    PushState('ScriptedRouteMove');
                }
            }            
        }
        else
        {
            ScriptedMoveTarget = destActor;
            if(!IsInState('ScriptedMove'))
            {
                PushState('ScriptedMove');
            }
        }
        ScriptedFocus = none;
        foreach Action.LinkedVariables(Class'SeqVar_Object', ObjVar, "Look At")
        {
            ScriptedFocus = Actor(ObjVar.GetObjectValue());
            if(ScriptedFocus != none)
            {
                break;
            }            
        }                
    }
    else
    {
        WarnInternal("Invalid destination for scripted move");
    }
}

function NotifyWeaponFired(Weapon W, byte FireMode);

function NotifyWeaponFinishedFiring(Weapon W, byte FireMode);

function bool CanFireWeapon(Weapon Wpn, byte FireModeNum)
{
    return true;
}

state ScriptedMove
{
    event PoppedState()
    {
        if(ScriptedRoute == none)
        {
            ClearLatentAction(Class'SeqAct_AIMoveToActor', ScriptedMoveTarget == none);
        }
        ScriptedMoveTarget = none;
    }

    event PushedState()
    {
        if(Pawn != none)
        {
            Pawn.SetMovementPhysics();
        }
    }
    J0x00:
    if(((Pawn != none) && ScriptedMoveTarget != none) && !Pawn.ReachedDestination(ScriptedMoveTarget))
    {
        if(ActorReachable(ScriptedMoveTarget))
        {
            MoveToward(ScriptedMoveTarget, ScriptedFocus);            
        }
        else
        {
            MoveTarget = FindPathToward(ScriptedMoveTarget);
            if(MoveTarget != none)
            {
                MoveToward(MoveTarget, ScriptedFocus);                
            }
            else
            {
                WarnInternal("Failed to find path to" @ string(ScriptedMoveTarget));
                ScriptedMoveTarget = none;
            }
        }
        goto J0x00;
    }
    PopState();
    stop;                
}

state ScriptedRouteMove
{
    event PoppedState()
    {
        ClearLatentAction(Class'SeqAct_AIMoveToActor', ScriptedRoute == none);
        ScriptedRoute = none;
    }
    J0x00:
    if((((Pawn != none) && ScriptedRoute != none) && ScriptedRouteIndex < ScriptedRoute.RouteList.Length) && ScriptedRouteIndex >= 0)
    {
        ScriptedMoveTarget = ScriptedRoute.RouteList[ScriptedRouteIndex].Actor;
        if(ScriptedMoveTarget != none)
        {
            PushState('ScriptedMove');
        }
        if((Pawn != none) && Pawn.ReachedDestination(ScriptedRoute.RouteList[ScriptedRouteIndex].Actor))
        {
            if(bReverseScriptedRoute)
            {
                -- ScriptedRouteIndex;                
            }
            else
            {
                ++ ScriptedRouteIndex;
            }            
        }
        else
        {
            WarnInternal("Aborting scripted route");
            ScriptedRoute = none;
            PopState();
        }
        goto J0x00;
    }
    if(((Pawn != none) && ScriptedRoute != none) && ScriptedRoute.RouteList.Length > 0)
    {
        switch(ScriptedRoute.RouteType)
        {
            case 0:
                PopState();
                break;
            case 1:
                bReverseScriptedRoute = !bReverseScriptedRoute;
                if(bReverseScriptedRoute)
                {
                    -- ScriptedRouteIndex;                    
                }
                else
                {
                    ++ ScriptedRouteIndex;
                }
                goto 'Begin';
                break;
            case 2:
                ScriptedRouteIndex = 0;
                goto 'Begin';
                break;
            default:
                WarnInternal("Unknown route type");
                ScriptedRoute = none;
                PopState();
                break;
                break;
        }        
    }
    else
    {
        ScriptedRoute = none;
        PopState();
    }
    WarnInternal("Reached end of state execution");
    ScriptedRoute = none;
    PopState();
    stop;                
}

defaultproperties
{
    bCanDoSpecial=true
    bAdjustFromWalls=true
    MinHitWall=-0.5
}