/*******************************************************************************
 * CheatManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CheatManager extends Object within PlayerController
    native;

var const localized string ViewingFrom;
var const localized string OwnCamera;

exec function FXPlay(class<Pawn> aClass, string FXAnimPath)
{
    local Pawn P, ClosestPawn;
    local float ThisDistance, ClosestPawnDistance;
    local string FxAnimGroup, FxAnimName;
    local int dotPos;

    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        ClosestPawn = none;
        ClosestPawnDistance = 1E+07;
        foreach Outer.DynamicActors(Class'Pawn', P)
        {
            if(ClassIsChildOf(P.Class, aClass) && P != PlayerController(Outer.Owner).Pawn)
            {
                ThisDistance = VSize(P.Location - PlayerController(Outer.Owner).Pawn.Location);
                if(ThisDistance < ClosestPawnDistance)
                {
                    ClosestPawn = P;
                    ClosestPawnDistance = ThisDistance;
                }
            }            
        }        
        if(ClosestPawn.Mesh != none)
        {
            dotPos = InStr(FXAnimPath, ".");
            if(dotPos != -1)
            {
                FxAnimGroup = Left(FXAnimPath, dotPos);
                FxAnimName = Right(FXAnimPath, (Len(FXAnimPath) - dotPos) - 1);
                ClosestPawn.Mesh.PlayFaceFXAnim(none, FxAnimName, FxAnimGroup, none, none);
            }
        }
    }
}

exec function FXStop(class<Pawn> aClass)
{
    local Pawn P, ClosestPawn;
    local float ThisDistance, ClosestPawnDistance;

    if(Outer.WorldInfo.NetMode == NM_Standalone)
    {
        ClosestPawn = none;
        ClosestPawnDistance = 1E+07;
        foreach Outer.DynamicActors(Class'Pawn', P)
        {
            if(ClassIsChildOf(P.Class, aClass) && P != PlayerController(Outer.Owner).Pawn)
            {
                ThisDistance = VSize(P.Location - PlayerController(Outer.Owner).Pawn.Location);
                if(ThisDistance < ClosestPawnDistance)
                {
                    ClosestPawn = P;
                    ClosestPawnDistance = ThisDistance;
                }
            }            
        }        
        if(ClosestPawn.Mesh != none)
        {
            ClosestPawn.Mesh.StopFaceFXAnim();
        }
    }
}

exec function DebugAI(coerce optional name Category);

exec function EditAIByTrace()
{
    local Vector CamLoc;
    local Rotator CamRot;
    local Vector HitLocation, HitNormal;
    local Pawn HitPawn;
    local Controller C;

    Outer.GetPlayerViewPoint(CamLoc, CamRot);
    HitPawn = Pawn(Outer.Trace(HitLocation, HitNormal, CamLoc + (vector(CamRot) * float(10000)), CamLoc, true, vect(10, 10, 10)));
    if(HitPawn != none)
    {
        C = HitPawn.Controller;
        if((C == none) && HitPawn.DrivenVehicle != none)
        {
            C = HitPawn.DrivenVehicle.Controller;
        }
        if(C != none)
        {            
            Outer.ConsoleCommand("EDITACTOR NAME=" $ string(C.Name), true);
        }
    }
}

exec function DebugPause()
{
    Outer.WorldInfo.Game.DebugPause();
}

exec function ListDynamicActors()
{
    local Actor A;
    local int I;

    foreach Outer.DynamicActors(Class'Actor', A)
    {
        ++ I;
        LogInternal(string(I) @ string(A));        
    }    
    LogInternal("Num dynamic actors: " $ string(I));
}

exec function FreezeFrame(float Delay)
{
    Outer.WorldInfo.Game.SetPause(Outer, Outer.CanUnpause);
    Outer.WorldInfo.PauseDelay = Outer.WorldInfo.TimeSeconds + Delay;
}

exec function WriteToLog(string Param)
{
    LogInternal("NOW! " $ Param);
}

exec function KillViewedActor()
{
    if(Outer.ViewTarget != none)
    {
        if((Pawn(Outer.ViewTarget) != none) && Pawn(Outer.ViewTarget).Controller != none)
        {
            Pawn(Outer.ViewTarget).Controller.Destroy();
        }
        Outer.ViewTarget.Destroy();
        Outer.SetViewTarget(none);
    }
}

exec function Teleport()
{
    local Actor HitActor;
    local Vector HitNormal, HitLocation, ViewLocation;
    local Rotator ViewRotation;

    Outer.GetPlayerViewPoint(ViewLocation, ViewRotation);
    HitActor = Outer.Trace(HitLocation, HitNormal, ViewLocation + (float(1000000) * vector(ViewRotation)), ViewLocation, true);
    if(HitActor != none)
    {
        HitLocation += (HitNormal * 4);
    }
    Outer.ViewTarget.SetLocation(HitLocation);
}

exec function ChangeSize(float F)
{
    Outer.Pawn.CylinderComponent.SetCylinderSize(Outer.Pawn.default.CylinderComponent.CollisionRadius * F, Outer.Pawn.default.CylinderComponent.CollisionHeight * F);
    Outer.Pawn.SetDrawScale(F);
    Outer.Pawn.SetLocation(Outer.Pawn.Location);
}

exec function EndPath();

exec function Amphibious()
{
    Outer.Pawn.UnderWaterTime = 999999;
}

exec function Fly()
{
    if((Outer.Pawn != none) && Outer.Pawn.CheatFly())
    {
        Outer.ClientMessage("You feel much lighter");
        Outer.bCheatFlying = true;
        Outer.GotoState('PlayerFlying');
    }
}

exec function Walk()
{
    Outer.bCheatFlying = false;
    if((Outer.Pawn != none) && Outer.Pawn.CheatWalk())
    {
        Outer.Restart(false);
    }
}

exec function Ghost()
{
    if((Outer.Pawn != none) && Outer.Pawn.CheatGhost())
    {
        Outer.bCheatFlying = true;
        Outer.GotoState('PlayerFlying');        
    }
    else
    {
        Outer.bCollideWorld = false;
    }
    Outer.ClientMessage("You feel ethereal");
}

exec function AllAmmo();

exec function God()
{
    if(Outer.bGodMode)
    {
        Outer.bGodMode = false;
        Outer.ClientMessage("God mode off");
        return;
    }
    Outer.bGodMode = true;
    Outer.ClientMessage("God Mode on");
}

exec function Slomo(float T)
{
    Outer.WorldInfo.Game.SetGameSpeed(T);
}

exec function SetJumpZ(float F)
{
    Outer.Pawn.JumpZ = F;
}

exec function SetGravity(float F)
{
    Outer.WorldInfo.WorldGravityZ = F;
}

exec function SetSpeed(float F)
{
    Outer.Pawn.GroundSpeed = Outer.Pawn.default.GroundSpeed * F;
    Outer.Pawn.WaterSpeed = Outer.Pawn.default.WaterSpeed * F;
}

exec function KillAll(class<Actor> aClass)
{
    local Actor A;
    local PlayerController PC;

    foreach Outer.WorldInfo.AllControllers(Class'PlayerController', PC)
    {
        PC.ClientMessage("Killed all " $ string(aClass));        
    }    
    if(ClassIsChildOf(aClass, Class'Pawn'))
    {
        KillAllPawns(class<Pawn>(aClass));
        return;
    }
    foreach Outer.DynamicActors(Class'Actor', A)
    {
        if(ClassIsChildOf(A.Class, aClass))
        {
            A.Destroy();
        }        
    }    
}

function KillAllPawns(class<Pawn> aClass)
{
    local Pawn P;

    foreach Outer.DynamicActors(Class'Pawn', P)
    {
        if(ClassIsChildOf(P.Class, aClass) && !P.IsPlayerPawn())
        {
            if(P.Controller != none)
            {
                P.Controller.Destroy();
            }
            P.Destroy();
        }        
    }    
}

exec function KillPawns()
{
    KillAllPawns(Class'Pawn');
}

exec function Avatar(name ClassName)
{
    local Pawn P, TargetPawn, FirstPawn, OldPawn;
    local bool bPickNextPawn;

    foreach Outer.DynamicActors(Class'Pawn', P)
    {
        if(P == Outer.Pawn)
        {
            bPickNextPawn = true;
            continue;
        }
        if(P.IsA(ClassName))
        {
            if(FirstPawn == none)
            {
                FirstPawn = P;
            }
            if(bPickNextPawn)
            {
                TargetPawn = P;
                break;
            }
        }        
    }    
    if(TargetPawn == none)
    {
        TargetPawn = FirstPawn;
    }
    if(TargetPawn != none)
    {
        TargetPawn.DetachFromController(true);
        if(Outer.Pawn != none)
        {
            OldPawn = Outer.Pawn;
            Outer.Pawn.DetachFromController();
        }
        Outer.Possess(TargetPawn, false);
        if(OldPawn != none)
        {
            OldPawn.SpawnDefaultController();
        }        
    }
    else
    {
        LogInternal(("Avatar: Couldn't find any Pawn to possess of class '" $ string(ClassName)) $ "'");
    }
}

exec function Summon(string ClassName)
{
    local class<Actor> NewClass;
    local Vector SpawnLoc;

    LogInternal("Fabricate " $ ClassName);
    NewClass = class<Actor>(DynamicLoadObject(ClassName, Class'Class'));
    if(NewClass != none)
    {
        if(Outer.Pawn != none)
        {
            SpawnLoc = Outer.Pawn.Location;            
        }
        else
        {
            SpawnLoc = Outer.Location;
        }
        Outer.Spawn(NewClass,,, (SpawnLoc + (float(72) * vector(Outer.Rotation))) + (vect(0, 0, 1) * float(15)));
    }
}

exec function Weapon GiveWeapon(string WeaponClassStr)
{
    local Weapon Weap;
    local class<Weapon> WeaponClass;

    WeaponClass = class<Weapon>(DynamicLoadObject(WeaponClassStr, Class'Class'));
    Weap = Weapon(Outer.Pawn.FindInventoryType(WeaponClass));
    if(Weap != none)
    {
        return Weap;
    }
    return Weapon(Outer.Pawn.CreateInventory(WeaponClass));
}

exec function PlayersOnly()
{
    if(Outer.WorldInfo.bPlayersOnly || Outer.WorldInfo.bPlayersOnlyPending)
    {
        Outer.WorldInfo.bPlayersOnly = false;
        Outer.WorldInfo.bPlayersOnlyPending = false;        
    }
    else
    {
        Outer.WorldInfo.bPlayersOnlyPending = !Outer.WorldInfo.bPlayersOnlyPending;
    }
}

exec function SuspendAI()
{
    Outer.WorldInfo.bSuspendAI = !Outer.WorldInfo.bSuspendAI;
}

exec function DestroyFractures(optional float Radius)
{
    local FracturedStaticMeshActor FracActor;

    if(Radius == 0)
    {
        Radius = 256;
    }
    foreach Outer.CollidingActors(Class'FracturedStaticMeshActor', FracActor, Radius, Outer.Pawn.Location, true)
    {
        if(FracActor.Physics == 0)
        {
            FracActor.BreakOffPartsInRadius(Outer.Pawn.Location, Radius, 500, true);
        }        
    }    
}

exec function FractureAllMeshes()
{
    local FracturedStaticMeshActor FracActor;

    foreach Outer.AllActors(Class'FracturedStaticMeshActor', FracActor)
    {
        FracActor.HideOneFragment();        
    }    
}

exec function FractureAllMeshesToMaximizeMemoryUsage()
{
    local FracturedStaticMeshActor FracActor;

    foreach Outer.AllActors(Class'FracturedStaticMeshActor', FracActor)
    {
        FracActor.HideFragmentsToMaximizeMemoryUsage();        
    }    
}

exec function RememberSpot()
{
    if(Outer.Pawn != none)
    {
        Outer.SetDestinationPosition(Outer.Pawn.Location);        
    }
    else
    {
        Outer.SetDestinationPosition(Outer.Location);
    }
}

exec function ViewSelf(optional bool bQuiet)
{
    Outer.ResetCameraMode();
    if(Outer.Pawn != none)
    {
        Outer.SetViewTarget(Outer.Pawn);        
    }
    else
    {
        Outer.SetViewTarget(Outer);
    }
    if(!bQuiet)
    {
        Outer.ClientMessage(OwnCamera, 'Event');
    }
    Outer.FixFOV();
}

exec function ViewPlayer(string S)
{
    local Controller P;

    foreach Outer.WorldInfo.AllControllers(Class'Controller', P)
    {
        if(P.bIsPlayer && P.PlayerReplicationInfo.PlayerName ~= S)
        {
            break;
        }        
    }    
    if(P.Pawn != none)
    {
        Outer.ClientMessage(ViewingFrom @ P.PlayerReplicationInfo.PlayerName, 'Event');
        Outer.SetViewTarget(P.Pawn);
    }
}

exec function ViewActor(name actorName)
{
    local Actor A;

    foreach Outer.AllActors(Class'Actor', A)
    {
        if(A.Name == actorName)
        {
            Outer.SetViewTarget(A);
            Outer.SetCameraMode('ThirdPerson');            
            return;
        }        
    }    
}

exec function ViewBot()
{
    local Actor first;
    local bool bFound;
    local AIController C;

    foreach Outer.WorldInfo.AllControllers(Class'AIController', C)
    {
        if((C.Pawn != none) && C.PlayerReplicationInfo != none)
        {
            if(bFound || first == none)
            {
                first = C;
                if(bFound)
                {
                    break;
                }
            }
            if(C.PlayerReplicationInfo == Outer.RealViewTarget)
            {
                bFound = true;
            }
        }        
    }    
    if(first != none)
    {
        LogInternal("view " $ string(first));
        Outer.SetViewTarget(first);
        Outer.SetCameraMode('ThirdPerson');
        Outer.FixFOV();        
    }
    else
    {
        ViewSelf(true);
    }
}

exec function ViewClass(class<Actor> aClass)
{
    local Actor Other, first;
    local bool bFound;

    first = none;
    foreach Outer.AllActors(aClass, Other)
    {
        if(bFound || first == none)
        {
            first = Other;
            if(bFound)
            {
                break;
            }
        }
        if(Other == Outer.ViewTarget)
        {
            bFound = true;
        }        
    }    
    if(first != none)
    {
        if(Pawn(first) != none)
        {
            Outer.ClientMessage(ViewingFrom @ first.GetHumanReadableName(), 'Event');            
        }
        else
        {
            Outer.ClientMessage(ViewingFrom @ string(first), 'Event');
        }
        Outer.SetViewTarget(first);
        Outer.FixFOV();        
    }
    else
    {
        ViewSelf(false);
    }
}

exec function Loaded()
{
    if(Outer.WorldInfo.NetMode != NM_Standalone)
    {
        return;
    }
    AllWeapons();
    AllAmmo();
}

exec function AllWeapons();

function SetLevelStreamingStatus(name PackageName, bool bShouldBeLoaded, bool bShouldBeVisible)
{
    local PlayerController PC;
    local int I;

    if(PackageName != 'All')
    {
        foreach Outer.WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            PC.ClientUpdateLevelStreamingStatus(PackageName, bShouldBeLoaded, bShouldBeVisible, false);            
        }                
    }
    else
    {
        foreach Outer.WorldInfo.AllControllers(Class'PlayerController', PC)
        {
            I = 0;
            J0xF6:

            if(I < Outer.WorldInfo.StreamingLevels.Length)
            {
                PC.ClientUpdateLevelStreamingStatus(Outer.WorldInfo.StreamingLevels[I].PackageName, bShouldBeLoaded, bShouldBeVisible, false);
                ++ I;
                goto J0xF6;
            }            
        }        
    }
}

exec function StreamLevelIn(name PackageName)
{
    SetLevelStreamingStatus(PackageName, true, true);
}

exec function OnlyLoadLevel(name PackageName)
{
    SetLevelStreamingStatus(PackageName, true, false);
}

exec function StreamLevelOut(name PackageName)
{
    SetLevelStreamingStatus(PackageName, false, false);
}

exec function TestLevel()
{
    local Actor A, Found;
    local bool bFoundErrors;

    foreach Outer.AllActors(Class'Actor', A)
    {
        bFoundErrors = bFoundErrors || A.CheckForErrors();
        if(bFoundErrors && Found == none)
        {
            Found = A;
        }        
    }    
    if(bFoundErrors)
    {
        LogInternal("Found problem with " $ string(Found));
        assert(false);
    }
}

exec function DumpOnlineSessionState()
{
    local int PlayerIndex;

    if(Outer.WorldInfo.NetMode != NM_Client)
    {
        LogInternal("");
        LogInternal("GameInfo state");
        LogInternal("-------------------------------------------------------------");
        LogInternal("");
        LogInternal("Class: " $ string(Outer.WorldInfo.Game.Class.Name));
        LogInternal("  MaxPlayersAllowed: " $ string(Outer.WorldInfo.Game.MaxPlayersAllowed));
        LogInternal("  MaxPlayers: " $ string(Outer.WorldInfo.Game.MaxPlayers));
        LogInternal("  NumPlayers: " $ string(Outer.WorldInfo.Game.NumPlayers));
        LogInternal("  MaxSpectatorsAllowed: " $ string(Outer.WorldInfo.Game.MaxSpectatorsAllowed));
        LogInternal("  MaxSpectators: " $ string(Outer.WorldInfo.Game.MaxSpectators));
        LogInternal("  NumSpectators: " $ string(Outer.WorldInfo.Game.NumSpectators));
        LogInternal("  NumBots: " $ string(Outer.WorldInfo.Game.NumBots));
        LogInternal("  bUseSeamlessTravel: " $ string(Outer.WorldInfo.Game.bUseSeamlessTravel));
        LogInternal("  bRequiresPushToTalk: " $ string(Outer.WorldInfo.Game.bRequiresPushToTalk));
        LogInternal("  bHasNetworkError: " $ string(Outer.WorldInfo.Game.bHasNetworkError));
        LogInternal("  OnlineGameSettingsClass: " $ string(Outer.WorldInfo.Game.OnlineGameSettingsClass));
        LogInternal("  OnlineStatsWriteClass: " $ string(Outer.WorldInfo.Game.OnlineStatsWriteClass));
        LogInternal("  bUsingArbitration: " $ string(Outer.WorldInfo.Game.bUsingArbitration));
        if(Outer.WorldInfo.Game.bUsingArbitration)
        {
            LogInternal("  bHasArbitratedHandshakeBegun: " $ string(Outer.WorldInfo.Game.bHasArbitratedHandshakeBegun));
            LogInternal("  bNeedsEndGameHandshake: " $ string(Outer.WorldInfo.Game.bNeedsEndGameHandshake));
            LogInternal("  bIsEndGameHandshakeComplete: " $ string(Outer.WorldInfo.Game.bIsEndGameHandshakeComplete));
            LogInternal("  bHasEndGameHandshakeBegun: " $ string(Outer.WorldInfo.Game.bHasEndGameHandshakeBegun));
            LogInternal("  ArbitrationHandshakeTimeout: " $ string(Outer.WorldInfo.Game.ArbitrationHandshakeTimeout));
            LogInternal("  Number of pending arbitration PCs: " $ string(Outer.WorldInfo.Game.PendingArbitrationPCs.Length));
            PlayerIndex = 0;
            J0x927:

            if(PlayerIndex < Outer.WorldInfo.Game.PendingArbitrationPCs.Length)
            {
                LogInternal(((("    Player: " $ Outer.WorldInfo.Game.PendingArbitrationPCs[PlayerIndex].PlayerReplicationInfo.PlayerName) $ " PC (") $ string(Outer.WorldInfo.Game.PendingArbitrationPCs[PlayerIndex].Name)) $ ")");
                ++ PlayerIndex;
                goto J0x927;
            }
            LogInternal("  Number of arbitration PCs: " $ string(Outer.WorldInfo.Game.ArbitrationPCs.Length));
            PlayerIndex = 0;
            J0xB0E:

            if(PlayerIndex < Outer.WorldInfo.Game.ArbitrationPCs.Length)
            {
                LogInternal(((("    Player: " $ Outer.WorldInfo.Game.ArbitrationPCs[PlayerIndex].PlayerReplicationInfo.PlayerName) $ " PC (") $ string(Outer.WorldInfo.Game.ArbitrationPCs[PlayerIndex].Name)) $ ")");
                ++ PlayerIndex;
                goto J0xB0E;
            }
        }
    }
    Outer.DebugLogPRIs();
    if(Outer.OnlineSub != none)
    {
        Outer.OnlineSub.DumpSessionState();
    }
}

exec function SetOnlineDebugLevel(int DebugLevel)
{
    if(Outer.OnlineSub != none)
    {
        Outer.OnlineSub.SetDebugSpewLevel(DebugLevel);
    }
}

exec function TestNavMeshPath(optional bool bDrawPath)
{
    local Actor HitActor;
    local Vector HitLoc, HitNorm, Start, End;
    local Rotator Rot;

    bDrawPath = true;
    if(Outer.NavigationHandle == none)
    {
        Outer.NavigationHandle = new (Outer) Class'NavigationHandle';
    }
    Outer.GetPlayerViewPoint(Start, Rot);
    End = Start + (vector(Rot) * float(10000));
    HitActor = Outer.Trace(HitLoc, HitNorm, End, Start, false);
    if(HitActor != none)
    {
        Class'NavMeshPath_Toward'.static.TowardPoint(Outer.NavigationHandle, HitLoc);
        Class'NavMeshGoal_At'.static.AtLocation(Outer.NavigationHandle, HitLoc);
        Outer.NavigationHandle.bDebugConstraintsAndGoalEvals = true;
        Outer.NavigationHandle.bUltraVerbosePathDebugging = true;
        if(Outer.NavigationHandle.FindPath())
        {
            Outer.DrawDebugLine(HitLoc, Start, 0, 255, 0, true);
            Outer.DrawDebugCoordinateSystem(HitLoc, rot(0, 0, 0), 25, true);
            if(bDrawPath)
            {
                Outer.NavigationHandle.DrawPathCache(,, true);
            }            
        }
        else
        {
            Outer.DrawDebugLine(HitLoc, Start, 255, 0, 0, true);
            Outer.DrawDebugCoordinateSystem(HitLoc, rot(0, 0, 0), 25, true);
            Outer.DrawDebugBox(Outer.Pawn.Location, Outer.Pawn.GetCollisionExtent(), 255, 0, 0, true);
        }
    }
}

exec function TestPylonConnectivity()
{
    local Pylon Py;

    foreach Outer.AllActors(Class'Pylon', Py)
    {
        Py.VerifyTopLevelConnections();        
    }    
}

exec function VerbosePathDebug()
{
    local Vector HitLoc, HitNorm, Start, End;
    local Rotator Rot;
    local Pawn P;

    Outer.GetPlayerViewPoint(Start, Rot);
    End = Start + (vector(Rot) * float(10000));
    foreach Outer.TraceActors(Class'Pawn', P, HitLoc, HitNorm, End, Start, vect(1, 1, 1))
    {
        Outer.Pawn.MessagePlayer("Verbosepathdebug trace hit" @ string(P));
        if((P != none) && P.Controller != none)
        {
            P.Controller.NavigationHandle.bUltraVerbosePathDebugging = !P.Controller.NavigationHandle.bUltraVerbosePathDebugging;
        }        
    }    
}

function InitCheatManager();

// Export UCheatManager::execLogPlaySoundCalls(FFrame&, void* const)
native exec function LogPlaySoundCalls(bool bShouldLog);

// Export UCheatManager::execLogParticleActivateSystemCalls(FFrame&, void* const)
native exec function LogParticleActivateSystemCalls(bool bShouldLog);

// Export UCheatManager::execVerifyNavMeshObjects(FFrame&, void* const)
native exec function VerifyNavMeshObjects();

// Export UCheatManager::execDrawUnsupportingEdges(FFrame&, void* const)
native exec function DrawUnsupportingEdges(coerce string PawnClassName);

exec function NavMeshVerification(optional float interval)
{
    interval = 0.5;
    if(interval < float(0))
    {
        Outer.ClearTimer('VerifyNavMeshObjects', Outer);        
    }
    else
    {
        Outer.SetTimer(interval, true, 'VerifyNavMeshObjects', Outer);
    }
}

// Export UCheatManager::execPrintAllPathObjectEdges(FFrame&, void* const)
native exec function PrintAllPathObjectEdges();

// Export UCheatManager::execPrintNavMeshObstacles(FFrame&, void* const)
native exec function PrintNavMeshObstacles();

// Export UCheatManager::execVerifyNavMeshCoverRefs(FFrame&, void* const)
native exec function VerifyNavMeshCoverRefs();

exec function ToggleAILogging()
{
    local Engine Eng;

    Eng = Class'Engine'.static.GetEngine();
    if(Outer.Pawn != none)
    {
        if(Eng.bDisableAILogging)
        {
            Outer.Pawn.MessagePlayer("OK! AI logging is now ON");            
        }
        else
        {
            Outer.Pawn.MessagePlayer("OK! AI logging is now OFF");
        }
    }
    Eng.bDisableAILogging = !Eng.bDisableAILogging;
}

exec function DebugIniLocPatcher()
{
    if((Outer.OnlineSub != none) && Outer.OnlineSub.Patcher != none)
    {
        Outer.OnlineSub.Patcher.DownloadFiles();
    }
}

exec function DebugDownloadTitleFile(string Filename, optional bool bFromCache)
{
    if(Outer.OnlineSub != none)
    {
        if(bFromCache)
        {
            if(NotEqual_InterfaceInterface(Outer.OnlineSub.TitleFileCacheInterface, (none)))
            {
                LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "starting file load for") @ Filename);
                Outer.OnlineSub.TitleFileCacheInterface.AddLoadTitleFileCompleteDelegate(OnLoadComplete);
                Outer.OnlineSub.TitleFileCacheInterface.LoadTitleFile(Filename);                
            }
            else
            {
                LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "OnlineTitleFileCacheInterface not supported");
            }            
        }
        else
        {
            if(NotEqual_InterfaceInterface(Outer.OnlineSub.TitleFileInterface, (none)))
            {
                LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "starting file download request for") @ Filename);
                Outer.OnlineSub.TitleFileInterface.AddReadTitleFileCompleteDelegate(OnDownloadComplete);
                Outer.OnlineSub.TitleFileInterface.ReadTitleFile(Filename);                
            }
            else
            {
                LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "OnlineTitleFileInterface not supported");
            }
        }
    }
}

function OnDownloadComplete(bool bWasSuccessful, string Filename)
{
    Outer.OnlineSub.TitleFileInterface.ClearReadTitleFileCompleteDelegate(OnDownloadComplete);
    LogInternal(((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "download completed") @ "bWasSuccessful=") $ string(bWasSuccessful)) @ "FileName=") $ Filename);
    if(bWasSuccessful)
    {
        DebugSaveTitleFile(Filename);
    }
}

function OnLoadComplete(bool bWasSuccessful, string Filename)
{
    Outer.OnlineSub.TitleFileCacheInterface.ClearLoadTitleFileCompleteDelegate(OnLoadComplete);
    LogInternal(((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "load completed") @ "bWasSuccessful=") $ string(bWasSuccessful)) @ "FileName=") $ Filename);
    DebugDownloadTitleFile(Filename, false);
}

exec function DebugSaveTitleFile(string Filename)
{
    local array<byte> FileContents;

    if(Outer.OnlineSub != none)
    {
        if(NotEqual_InterfaceInterface(Outer.OnlineSub.TitleFileInterface, (none)))
        {
            if(Outer.OnlineSub.TitleFileInterface.GetTitleFileContents(Filename, FileContents))
            {
                LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "found file in download cache. using file contents from download cache:") @ Filename);                
            }
            else
            {
                LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "couldn't find file in download cache:") @ Filename);
            }            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "OnlineTitleFileInterface not supported");
        }
        if(NotEqual_InterfaceInterface(Outer.OnlineSub.TitleFileCacheInterface, (none)))
        {
            LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "starting file save for") @ Filename);
            Outer.OnlineSub.TitleFileCacheInterface.AddSaveTitleFileCompleteDelegate(OnSaveComplete);
            Outer.OnlineSub.TitleFileCacheInterface.SaveTitleFile(Filename, "TestName.ini", FileContents);            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "OnlineTitleFileCacheInterface not supported");
        }
    }
}

function OnSaveComplete(bool bWasSuccessful, string Filename)
{
    Outer.OnlineSub.TitleFileCacheInterface.ClearSaveTitleFileCompleteDelegate(OnSaveComplete);
    LogInternal(((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "save completed") @ "bWasSuccessful=") $ string(bWasSuccessful)) @ "FileName=") $ Filename);
}

exec function DebugDeleteTitleFiles()
{
    if(Outer.OnlineSub != none)
    {
        if(NotEqual_InterfaceInterface(Outer.OnlineSub.TitleFileCacheInterface, (none)))
        {
            LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "deleting all title files in cache dir");
            if(Outer.OnlineSub.TitleFileCacheInterface.DeleteTitleFiles(0))
            {
                LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "delete succeeded");                
            }
            else
            {
                LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "cant delete. file ops in progress");
            }            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "OnlineTitleFileCacheInterface not supported");
        }
    }
}

exec function DebugEmsDownload()
{
    if((Outer.OnlineSub != none) && Outer.OnlineSub.Patcher != none)
    {
        Outer.OnlineSub.Patcher.DownloadFiles();
    }
}

// Export UCheatManager::execDumpCoverStats(FFrame&, void* const)
native exec function DumpCoverStats();

exec function DrawLocation(Vector Loc)
{
    Outer.DrawDebugCoordinateSystem(Loc, rot(0, 0, 0), 50, true);
}

exec function DrawLocationXYZ(float X, float Y, float Z)
{
    local Vector DrawSpot;

    DrawSpot.X = X;
    DrawSpot.Y = Y;
    DrawSpot.Z = Z;
    Outer.DrawDebugCoordinateSystem(DrawSpot, rot(0, 0, 0), 150, true);
}

exec function DebugNotification(string MessageBody, int SecondsFromNow)
{
    local AppNotificationsBase AppNotification;
    local NotificationInfo NotificationInfo;
    local NotificationMessageInfo MessageInfo;

    AppNotification = Class'PlatformInterfaceBase'.static.GetAppNotificationsInterface();
    if(AppNotification != none)
    {
        NotificationInfo.BadgeNumber = 1;
        NotificationInfo.MessageBody = MessageBody;
        MessageInfo.Key = "test key 1";
        MessageInfo.Value = "test val 1";
        NotificationInfo.MessageInfo.AddItem(MessageInfo;
        MessageInfo.Key = "test key 2";
        MessageInfo.Value = "test val 2";
        NotificationInfo.MessageInfo.AddItem(MessageInfo;
        LogInternal(((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "") @ " MessageBody=") $ MessageBody) @ " SecondsFromNow=") $ string(SecondsFromNow));
        AppNotification.__OnReceivedLocalNotification__Delegate = OnReceivedLocalNotificationDebug;
        AppNotification.ScheduleLocalNotification(NotificationInfo, SecondsFromNow);
    }
}

private final function OnReceivedLocalNotificationDebug(const out NotificationInfo Notification, bool bWasAppActive)
{
    LogInternal((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "bWasAppActive=") $ string(bWasAppActive));
    Class'PlatformInterfaceBase'.static.GetAppNotificationsInterface().DebugLogNotification(Notification);
}

exec function DebugQueryUserFiles(string UserId)
{
    if((Outer.OnlineSub != none) && NotEqual_InterfaceInterface(Outer.OnlineSub.UserCloudInterface, (none)))
    {
        Outer.OnlineSub.UserCloudInterface.AddEnumerateUserFileCompleteDelegate(OnEnumerateUserFilesComplete);
        Outer.OnlineSub.UserCloudInterface.EnumerateUserFiles(UserId);
    }
}

private final function OnEnumerateUserFilesComplete(bool bWasSuccessful, string UserId)
{
    Outer.OnlineSub.UserCloudInterface.ClearEnumerateUserFileCompleteDelegate(OnEnumerateUserFilesComplete);    
    Outer.ConsoleCommand("obj dump" @ string(Outer.OnlineSub.UserCloudInterface.Name));
    LogInternal(((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "") $ " bWasSuccessful=") $ string(bWasSuccessful)) $ " UserId=") $ UserId);
}

exec function DebugWriteUserFile(string UserId, string Filename)
{
    local int Idx;
    local array<byte> FileContents;

    if((Outer.OnlineSub != none) && NotEqual_InterfaceInterface(Outer.OnlineSub.UserCloudInterface, (none)))
    {
        Idx = 0;
        J0x7B:

        if(Idx < 1000)
        {
            FileContents[Idx] = byte(Idx);
            ++ Idx;
            goto J0x7B;
        }
        Outer.OnlineSub.UserCloudInterface.AddWriteUserFileCompleteDelegate(OnWriteUserFileComplete);
        Outer.OnlineSub.UserCloudInterface.WriteUserFile(UserId, Filename, FileContents);
    }
}

private final function OnWriteUserFileComplete(bool bWasSuccessful, string UserId, string Filename)
{
    Outer.OnlineSub.UserCloudInterface.ClearWriteUserFileCompleteDelegate(OnWriteUserFileComplete);    
    Outer.ConsoleCommand("obj dump" @ string(Outer.OnlineSub.UserCloudInterface.Name));
    LogInternal(((((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "") $ " bWasSuccessful=") $ string(bWasSuccessful)) $ " UserId=") $ UserId) $ " FileName=") $ Filename);
}

exec function DebugReadUserFile(string UserId, string Filename)
{
    if((Outer.OnlineSub != none) && NotEqual_InterfaceInterface(Outer.OnlineSub.UserCloudInterface, (none)))
    {
        Outer.OnlineSub.UserCloudInterface.AddReadUserFileCompleteDelegate(OnReadUserFileComplete);
        Outer.OnlineSub.UserCloudInterface.ReadUserFile(UserId, Filename);
    }
}

private final function OnReadUserFileComplete(bool bWasSuccessful, string UserId, string Filename)
{
    local array<byte> FileContents;

    Outer.OnlineSub.UserCloudInterface.ClearReadUserFileCompleteDelegate(OnReadUserFileComplete);
    Outer.OnlineSub.UserCloudInterface.GetFileContents(UserId, Filename, FileContents);    
    Outer.ConsoleCommand("obj dump" @ string(Outer.OnlineSub.UserCloudInterface.Name));
    LogInternal(((((((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "") $ " bWasSuccessful=") $ string(bWasSuccessful)) $ " UserId=") $ UserId) $ " FileName=") $ Filename) $ " FileContents=") $ string(FileContents.Length));
}

exec function DebugDeleteUserFile(string UserId, string Filename)
{
    if((Outer.OnlineSub != none) && NotEqual_InterfaceInterface(Outer.OnlineSub.UserCloudInterface, (none)))
    {
        Outer.OnlineSub.UserCloudInterface.AddDeleteUserFileCompleteDelegate(OnDeleteUserFileComplete);
        Outer.OnlineSub.UserCloudInterface.DeleteUserFile(UserId, Filename, true, true);
    }
}

private final function OnDeleteUserFileComplete(bool bWasSuccessful, string UserId, string Filename)
{
    Outer.OnlineSub.UserCloudInterface.ClearDeleteUserFileCompleteDelegate(OnDeleteUserFileComplete);    
    Outer.ConsoleCommand("obj dump" @ string(Outer.OnlineSub.UserCloudInterface.Name));
    LogInternal(((((((((((("(" $ string(Name)) $ ") CheatManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "") $ " bWasSuccessful=") $ string(bWasSuccessful)) $ " UserId=") $ UserId) $ " FileName=") $ Filename);
}

exec function TestHttp(string Verb, string Payload, string URL, optional bool bSendParallelRequest)
{
    local HttpRequestInterface R;

    R = Class'HttpFactory'.static.CreateRequest();
    R.__OnProcessRequestComplete__Delegate = OnRequestComplete;
    LogInternal("Created request");
    R.SetURL(URL);
    if(Len(Verb) > 0)
    {
        R.SetVerb(Verb);        
    }
    else
    {
        LogInternal("No Verb given, using the defaults.");
    }
    if(Len(Payload) > 0)
    {
        R.SetContentAsString(Payload);        
    }
    else
    {
        LogInternal("No payload given.");
    }
    LogInternal("Creating request for URL:" @ URL);
    LogInternal("Key1 =" @ R.GetURLParameter("Key1"));
    LogInternal("Key2 =" @ R.GetURLParameter("Key2"));
    LogInternal("Key3NoValue =" @ R.GetURLParameter("Key3NoValue"));
    LogInternal("NonexistentKey =" @ R.GetURLParameter("NonexistentKey"));
    LogInternal("NonExistentHeader =" @ R.GetHeader("NonExistentHeader"));
    LogInternal("CustomHeaderName =" @ R.GetHeader("CustomHeaderName"));
    LogInternal("ContentType =" @ R.GetContentType());
    LogInternal("ContentLength =" @ string(R.GetContentLength()));
    LogInternal("URL =" @ R.GetURL());
    LogInternal("Verb =" @ R.GetVerb());
    if(!R.ProcessRequest())
    {
        LogInternal("ProcessRequest failed. Unsuppress DevHttpRequest to see more details.");        
    }
    else
    {
        LogInternal("Request sent");
    }
    if(bSendParallelRequest)
    {
        if(!Class'HttpFactory'.static.CreateRequest().SetURL("http://www.epicgames.com").SetVerb("GET").SetHeader("Test", "Value").SetProcessRequestCompleteDelegate(OnRequestComplete).ProcessRequest())
        {
            LogInternal("ProcessRequest for parallel request failed. Unsuppress DevHttpRequest to see more details.");            
        }
        else
        {
            LogInternal("Parallel Request sent");
        }
    }
}

function OnRequestComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface Response, bool bDidSucceed)
{
    local array<string> Headers;
    local string Header, Payload;
    local int PayloadIndex;

    LogInternal("Got response!!!!!!! Succeeded=" @ string(bDidSucceed));
    LogInternal("URL=" @ OriginalRequest.GetURL());
    if(Response != none)
    {
        LogInternal("ResponseURL=" @ Response.GetURL());
        LogInternal("Response Code=" @ string(Response.GetResponseCode()));
        Headers = Response.GetHeaders();
        foreach Headers(Header,)
        {
            LogInternal("Header:" @ Header);            
        }        
        Payload = Response.GetContentAsString();
        if(Len(Payload) > 1024)
        {
            PayloadIndex = 0;
            LogInternal("Payload:");
            J0x181:

            if(PayloadIndex < Len(Payload))
            {
                LogInternal("    " @ Mid(Payload, PayloadIndex, 1024));
                PayloadIndex = PayloadIndex + 1024;
                goto J0x181;
            }            
        }
        else
        {
            LogInternal("Payload:" @ Payload);
        }
    }
}

exec function SendAnalyticsEvent(string EventName, optional string AttributeName, optional string AttributeValue)
{
    local AnalyticEventsBase Analytics;

    Analytics = Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface();
    if(Len(AttributeName) > 0)
    {
        Analytics.LogStringEventParam(EventName, AttributeName, AttributeValue, false);        
    }
    else
    {
        Analytics.LogStringEvent(EventName, false);
    }
}

exec function SendAnalyticsUserAttributeEvent(string AttributeName, string AttributeValue)
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().LogUserAttributeUpdate(AttributeName, AttributeValue);
}

exec function SendAnalyticsItemPurchaseEvent(string ItemId, string Currency, int PerItemCost, int ItemQuantity)
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().LogItemPurchaseEvent(ItemId, Currency, PerItemCost, ItemQuantity);
}

exec function SendAnalyticsCurrencyPurchaseEvent(string GameCurrencyType, int GameCurrencyAmount, string RealCurrencyType, float RealMoneyCost, string PaymentProvider)
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().LogCurrencyPurchaseEvent(GameCurrencyType, GameCurrencyAmount, RealCurrencyType, RealMoneyCost, PaymentProvider);
}

exec function SendAnalyticsCurrencyGivenEvent(string GameCurrencyType, int GameCurrencyAmount)
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().LogCurrencyGivenEvent(GameCurrencyType, GameCurrencyAmount);
}

exec function SendAnalyticsCachedEvents()
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().SendCachedEvents();
}

exec function SetAnalyticsUserId(string UserId)
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().SetUserId(UserId);
    LogInternal("Analytics UserId set to:" @ UserId);
}

// Export UCheatManager::execGetAnalyticsUserId(FFrame&, void* const)
native exec function GetAnalyticsUserId();

exec function AnalyticsStartSession()
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().StartSession();
}

exec function AnalyticsEndSession()
{
    Class'PlatformInterfaceBase'.static.GetAnalyticEventsInterface().EndSession();
}

defaultproperties
{
    ViewingFrom="Now viewing from"
    OwnCamera="Now viewing from own camera"
}