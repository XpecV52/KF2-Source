/*******************************************************************************
 * HUD generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class HUD extends Actor
    transient
    native
    config(Game)
    notplaceable
    hidecategories(Navigation);

struct native ConsoleMessage
{
    var string Text;
    var Color TextColor;
    var float MessageLife;
    var PlayerReplicationInfo PRI;

    structdefaultproperties
    {
        Text=""
        TextColor=(B=0,G=0,R=0,A=0)
        MessageLife=0
        PRI=none
    }
};

struct native HudLocalizedMessage
{
    var class<LocalMessage> Message;
    var string StringMessage;
    var int Switch;
    var float EndOfLife;
    var float Lifetime;
    var float PosY;
    var Color DrawColor;
    var int FontSize;
    var Font StringFont;
    var float DX;
    var float DY;
    var bool Drawn;
    var int Count;
    var Object OptionalObject;

    structdefaultproperties
    {
        Message=none
        StringMessage=""
        Switch=0
        EndOfLife=0
        Lifetime=0
        PosY=0
        DrawColor=(B=0,G=0,R=0,A=0)
        FontSize=0
        StringFont=none
        DX=0
        DY=0
        Drawn=false
        Count=0
        OptionalObject=none
    }
};

struct native KismetDrawTextInfo
{
    var() string MessageText;
    var string AppendedText;
    var() Font MessageFont;
    var() Vector2D MessageFontScale;
    var() Vector2D MessageOffset;
    var() Color MessageColor;
    var float MessageEndTime;

    structdefaultproperties
    {
        MessageText=""
        AppendedText=""
        MessageFont=none
        MessageFontScale=(X=0,Y=0)
        MessageOffset=(X=0,Y=0)
        MessageColor=(B=0,G=0,R=0,A=0)
        MessageEndTime=0
    }
};

var const Color WhiteColor;
var const Color GreenColor;
var const Color RedColor;
var PlayerController PlayerOwner;
var transient bool bLostFocusPaused;
var config bool bShowHUD;
var bool bShowScores;
var bool bShowDebugInfo;
/** Display indication of bad connection (set in C++ based on lag and packetloss). */
var() bool bShowBadConnectionAlert;
var config bool bShowDirectorInfoDebug;
var config bool bShowDirectorInfoHUD;
var globalconfig bool bMessageBeep;
var bool bRenderFullScreen;
var bool bScaleCanvasForCinematicMode;
var bool bShowOverlays;
var globalconfig float HudCanvasScale;
var array<Actor> PostRenderedActors;
var array<ConsoleMessage> ConsoleMessages;
var const Color ConsoleColor;
var config int ConsoleMessageCount;
var globalconfig int ConsoleFontSize;
var globalconfig int MessageFontOffset;
var int MaxHUDAreaMessageCount;
var() transient HudLocalizedMessage LocalMessages[8];
/**  
 *Canvas to Draw HUD on.
 * NOTE: a new Canvas is given every frame, only draw on it from the HUD::PostRender() event
 */
var() float ConsoleMessagePosX;
/**  
 *Canvas to Draw HUD on.
 * NOTE: a new Canvas is given every frame, only draw on it from the HUD::PostRender() event
 */
var() float ConsoleMessagePosY;
var Canvas Canvas;
var transient float LastHUDRenderTime;
var transient float RenderDelta;
var transient float SizeX;
var transient float SizeY;
var transient float CenterX;
var transient float CenterY;
var transient float RatioX;
var transient float RatioY;
var globalconfig array<config name> DebugDisplay;
var array<KismetDrawTextInfo> KismetTextInfo;

// Export UHUD::execDraw3DLine(FFrame&, void* const)
native final function Draw3DLine(Vector Start, Vector End, Color LineColor);

// Export UHUD::execDraw2DLine(FFrame&, void* const)
native final function Draw2DLine(int X1, int Y1, int X2, int Y2, Color LineColor);

event PostBeginPlay()
{
    super.PostBeginPlay();
    PlayerOwner = PlayerController(Owner);
    NotifyBindPostProcessEffects();
}

// Export UHUD::execDrawActorOverlays(FFrame&, void* const)
native function DrawActorOverlays(Vector ViewPoint, Rotator ViewRotation);

function RemovePostRenderedActor(Actor A)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PostRenderedActors.Length)
    {
        if(PostRenderedActors[I] == A)
        {
            PostRenderedActors[I] = none;
            return;
        }
        ++ I;
        goto J0x0B;
    }
}

function AddPostRenderedActor(Actor A)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < PostRenderedActors.Length)
    {
        if(PostRenderedActors[I] == A)
        {
            return;
        }
        ++ I;
        goto J0x0B;
    }
    I = 0;
    J0x5F:

    if(I < PostRenderedActors.Length)
    {
        if(PostRenderedActors[I] == none)
        {
            PostRenderedActors[I] = A;
            return;
        }
        ++ I;
        goto J0x5F;
    }
    PostRenderedActors[PostRenderedActors.Length] = A;
}

exec function ToggleHUD()
{
    bShowHUD = !bShowHUD;
}

exec function ShowHUD()
{
    ToggleHUD();
}

exec function ShowScores()
{
    SetShowScores(!bShowScores);
}

exec function SetShowScores(bool bNewValue)
{
    bShowScores = bNewValue;
}

exec function ShowDebug(optional name DebugType)
{
    local bool bRemoved;

    if(DebugType == 'None')
    {
        bShowDebugInfo = !bShowDebugInfo;        
    }
    else
    {
        if(bShowDebugInfo)
        {
            if(-1 != DebugDisplay.RemoveItem(DebugType)
            {
                bRemoved = true;
            }
        }
        if(!bRemoved)
        {
            DebugDisplay[DebugDisplay.Length] = DebugType;
        }
        bShowDebugInfo = true;
        SaveConfig();
    }
}

function bool ShouldDisplayDebug(name DebugType)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < DebugDisplay.Length)
    {
        if(DebugDisplay[I] == DebugType)
        {
            return true;
        }
        ++ I;
        goto J0x0B;
    }
    return false;
}

exec function ToggleDirectorInfoHUD()
{
    bShowDirectorInfoHUD = !bShowDirectorInfoHUD;
}

exec function ToggleDirectorInfoDebug()
{
    bShowDirectorInfoDebug = !bShowDirectorInfoDebug;
}

function ShowDebugInfo(out float out_YL, out float out_YPos)
{
    PlayerOwner.ViewTarget.DisplayDebug(self, out_YL, out_YPos);
    if(ShouldDisplayDebug('Game'))
    {
        WorldInfo.Game.DisplayDebug(self, out_YL, out_YPos);
    }
    if((ShouldDisplayDebug('AI')) && Pawn(PlayerOwner.ViewTarget) != none)
    {
        DrawRoute(Pawn(PlayerOwner.ViewTarget));
    }
}

function DrawRoute(Pawn Target)
{
    local int I;
    local Controller C;
    local Vector Start, RealStart, Dest;
    local bool bPath;
    local Actor FirstRouteCache;
    local Pylon FoundPylon;

    C = Target.Controller;
    if(C == none)
    {
        return;
    }
    if(C.CurrentPath != none)
    {
        Start = C.CurrentPath.Start.Location;        
    }
    else
    {
        Start = Target.Location;
    }
    RealStart = Start;
    if(C.bAdjusting)
    {
        Draw3DLine(C.Pawn.Location, C.GetAdjustLocation(), MakeColor(255, 0, 255, 255));
        Start = C.GetAdjustLocation();
    }
    Dest = C.GetDestinationPosition();
    foreach WorldInfo.AllNavigationPoints(Class'Pylon', FoundPylon)
    {
        break;        
    }    
    if(FoundPylon != none)
    {
        if(C.NavigationHandle == none)
        {
            C.NavigationHandle = new (C) Class'NavigationHandle';
        }
        Class'NavMeshPath_Toward'.static.TowardPoint(C.NavigationHandle, Dest);
        Class'NavMeshGoal_At'.static.AtLocation(C.NavigationHandle, Dest);
        C.NavigationHandle.bVisualPathDebugging = true;
        if(C.NavigationHandle.FindPath())
        {
            DrawDebugCoordinateSystem(Dest, rot(0, 0, 0), 25, true);
            C.NavigationHandle.DrawPathCache(,, true);            
        }
        else
        {
            DrawDebugCoordinateSystem(Dest, rot(0, 0, 0), 25, true);
            DrawDebugBox(Target.Location, Target.GetCollisionExtent(), 255, 0, 0, true);
        }
        return;
    }
    if(C.RouteCache.Length > 0)
    {
        FirstRouteCache = C.RouteCache[0];
    }
    if((C == PlayerOwner) || (C.MoveTarget == FirstRouteCache) && C.MoveTarget != none)
    {
        if((C == PlayerOwner) && Dest != vect(0, 0, 0))
        {
            if(C.PointReachable(Dest))
            {
                Draw3DLine(C.Pawn.Location, Dest, MakeColor(255, 255, 255, 255));
                return;
            }
            C.FindPathTo(Dest);
        }
        if(C.RouteCache.Length > 0)
        {
            I = 0;
            J0x603:

            if(I < C.RouteCache.Length)
            {
                if(C.RouteCache[I] == none)
                {
                    goto J0x724;
                }
                bPath = true;
                Draw3DLine(Start, C.RouteCache[I].Location, MakeColor(0, 255, 0, 255));
                Start = C.RouteCache[I].Location;
                ++ I;
                goto J0x603;
            }
            J0x724:

            if(bPath)
            {
                Draw3DLine(RealStart, Dest, MakeColor(255, 255, 255, 255));
            }
        }        
    }
    else
    {
        if(Target.Velocity != vect(0, 0, 0))
        {
            Draw3DLine(RealStart, Dest, MakeColor(255, 255, 255, 255));
        }
    }
    if(C == PlayerOwner)
    {
        return;
    }
    Draw3DLine(Target.Location + (Target.BaseEyeHeight * vect(0, 0, 1)), C.GetFocalPoint(), MakeColor(255, 0, 0, 255));
}

function PreCalcValues()
{
    SizeX = float(Canvas.SizeX);
    SizeY = float(Canvas.SizeY);
    CenterX = SizeX * 0.5;
    CenterY = SizeY * 0.5;
    RatioX = SizeX / 1024;
    RatioY = SizeY / 768;
}

event PostRender()
{
    local float XL, YL, YPos;

    RenderDelta = WorldInfo.TimeSeconds - LastHUDRenderTime;
    if((SizeX != float(Canvas.SizeX)) || SizeY != float(Canvas.SizeY))
    {
        PreCalcValues();
    }
    if(PlayerOwner != none)
    {
        PlayerOwner.DrawDebugTextList(Canvas, RenderDelta);
    }
    if(bShowDebugInfo)
    {
        Canvas.Font = Class'Engine'.static.GetTinyFont();
        Canvas.DrawColor = ConsoleColor;
        Canvas.StrLen("X", XL, YL);
        YPos = 0;
        ShowDebugInfo(YL, YPos);        
    }
    else
    {
        if(bShowHUD)
        {
            if(!bShowScores)
            {
                DrawHUD();
                DisplayConsoleMessages();
                DisplayLocalMessages();
                DisplayKismetMessages();
            }
        }
    }
    if(bShowBadConnectionAlert)
    {
        DisplayBadConnectionAlert();
    }
    LastHUDRenderTime = WorldInfo.TimeSeconds;
}

function DrawHUD()
{
    local Vector ViewPoint;
    local Rotator ViewRotation;

    if(bShowOverlays && PlayerOwner != none)
    {
        Canvas.Font = GetFontSizeIndex(0);
        PlayerOwner.GetPlayerViewPoint(ViewPoint, ViewRotation);
        DrawActorOverlays(ViewPoint, ViewRotation);
    }
    PlayerOwner.DrawHUD(self);
}

function DisplayBadConnectionAlert();

function ClearMessage(out HudLocalizedMessage M)
{
    M.Message = none;
    M.StringFont = none;
}

function Message(PlayerReplicationInfo PRI, coerce string msg, name MsgType, optional float Lifetime)
{
    local string ThePlayerName;

    if(bMessageBeep)
    {
        PlayerOwner.PlayBeepSound();
    }
    if((MsgType == 'Say') || MsgType == 'TeamSay')
    {
        ThePlayerName = ((PRI != none) ? PRI.PlayerName : "");
        msg = (ThePlayerName $ ": ") $ msg;
    }
    AddConsoleMessage(msg, Class'LocalMessage', PRI, Lifetime);
}

function DisplayConsoleMessages()
{
    local int Idx, XPos, YPos;
    local float XL, YL;

    if(ConsoleMessages.Length == 0)
    {
        return;
    }
    Idx = 0;
    J0x1D:

    if(Idx < ConsoleMessages.Length)
    {
        if((ConsoleMessages[Idx].Text == "") || ConsoleMessages[Idx].MessageLife < WorldInfo.TimeSeconds)
        {
            ConsoleMessages.Remove(-- Idx, 1;
        }
        ++ Idx;
        goto J0x1D;
    }
    XPos = int(((ConsoleMessagePosX * HudCanvasScale) * float(Canvas.SizeX)) + (((1 - HudCanvasScale) / 2) * float(Canvas.SizeX)));
    YPos = int(((ConsoleMessagePosY * HudCanvasScale) * float(Canvas.SizeY)) + (((1 - HudCanvasScale) / 2) * float(Canvas.SizeY)));
    Canvas.Font = Class'Engine'.static.GetSmallFont();
    Canvas.DrawColor = ConsoleColor;
    Canvas.TextSize("A", XL, YL);
    YPos -= int(YL * float(ConsoleMessages.Length));
    YPos -= int(YL);
    Idx = 0;
    J0x2AD:

    if(Idx < ConsoleMessages.Length)
    {
        if(ConsoleMessages[Idx].Text == "")
        {            
        }
        else
        {
            if((ShouldShowConsoleMessage(ConsoleMessages[Idx])) == false)
            {                
            }
            else
            {
                Canvas.StrLen(ConsoleMessages[Idx].Text, XL, YL);
                Canvas.SetPos(float(XPos), float(YPos));
                Canvas.DrawColor = ConsoleMessages[Idx].TextColor;
                Canvas.DrawText(ConsoleMessages[Idx].Text, false);
                YPos += int(YL);
            }
        }
        ++ Idx;
        goto J0x2AD;
    }
}

function bool ShouldShowConsoleMessage(const ConsoleMessage InConsoleMessage)
{
    return true;
}

function AddConsoleMessage(string M, class<LocalMessage> InMessageClass, PlayerReplicationInfo PRI, optional float Lifetime)
{
    local int Idx, MsgIdx;

    MsgIdx = -1;
    if(bMessageBeep && InMessageClass.default.bBeep)
    {
        PlayerOwner.PlayBeepSound();
    }
    if(ConsoleMessages.Length < ConsoleMessageCount)
    {
        MsgIdx = ConsoleMessages.Length;        
    }
    else
    {
        Idx = 0;
        J0x9A:

        if((Idx < ConsoleMessages.Length) && MsgIdx == -1)
        {
            if(ConsoleMessages[Idx].Text == "")
            {
                MsgIdx = Idx;
            }
            ++ Idx;
            goto J0x9A;
        }
    }
    if((MsgIdx == ConsoleMessageCount) || MsgIdx == -1)
    {
        Idx = 0;
        J0x14C:

        if(Idx < (ConsoleMessageCount - 1))
        {
            ConsoleMessages[Idx] = ConsoleMessages[Idx + 1];
            ++ Idx;
            goto J0x14C;
        }
        MsgIdx = ConsoleMessageCount - 1;
    }
    if(MsgIdx >= ConsoleMessages.Length)
    {
        ConsoleMessages.Length = MsgIdx + 1;
    }
    ConsoleMessages[MsgIdx].Text = M;
    if(Lifetime != 0)
    {
        ConsoleMessages[MsgIdx].MessageLife = WorldInfo.TimeSeconds + Lifetime;        
    }
    else
    {
        ConsoleMessages[MsgIdx].MessageLife = WorldInfo.TimeSeconds + InMessageClass.default.Lifetime;
    }
    ConsoleMessages[MsgIdx].TextColor = InMessageClass.static.GetConsoleColor(PRI);
    ConsoleMessages[MsgIdx].PRI = PRI;
}

function LocalizedMessage(class<LocalMessage> InMessageClass, PlayerReplicationInfo RelatedPRI_1, PlayerReplicationInfo RelatedPRI_2, string CriticalString, int Switch, float Position, float Lifetime, int FontSize, Color DrawColor, optional Object OptionalObject)
{
    local int I, LocalMessagesArrayCount, MessageCount;

    if((InMessageClass == none) || CriticalString == "")
    {
        return;
    }
    if(bMessageBeep && InMessageClass.default.bBeep)
    {
        PlayerOwner.PlayBeepSound();
    }
    if(!InMessageClass.default.bIsSpecial)
    {
        AddConsoleMessage(CriticalString, InMessageClass, RelatedPRI_1);
        return;
    }
    LocalMessagesArrayCount = 8;
    I = LocalMessagesArrayCount;
    if(InMessageClass.default.bIsUnique)
    {
        I = 0;
        J0x10C:

        if(I < LocalMessagesArrayCount)
        {
            if(LocalMessages[I].Message == InMessageClass)
            {
                if(InMessageClass.default.bCountInstances && LocalMessages[I].StringMessage ~= CriticalString)
                {
                    MessageCount = ((LocalMessages[I].Count == 0) ? 2 : LocalMessages[I].Count + 1);
                }
                goto J0x223;
            }
            ++ I;
            goto J0x10C;
        }
        J0x223:
        
    }
    else
    {
        if(InMessageClass.default.bIsPartiallyUnique)
        {
            I = 0;
            J0x253:

            if(I < LocalMessagesArrayCount)
            {
                if((LocalMessages[I].Message == InMessageClass) && InMessageClass.static.PartiallyDuplicates(Switch, LocalMessages[I].Switch, OptionalObject, LocalMessages[I].OptionalObject))
                {
                    goto J0x331;
                }
                ++ I;
                goto J0x253;
            }
        }
    }
    J0x331:

    if(I == LocalMessagesArrayCount)
    {
        I = 0;
        J0x353:

        if(I < LocalMessagesArrayCount)
        {
            if(LocalMessages[I].Message == none)
            {
                goto J0x3A7;
            }
            ++ I;
            goto J0x353;
        }
    }
    J0x3A7:

    if(I == LocalMessagesArrayCount)
    {
        I = 0;
        J0x3C9:

        if(I < (LocalMessagesArrayCount - 1))
        {
            LocalMessages[I] = LocalMessages[I + 1];
            ++ I;
            goto J0x3C9;
        }
    }
    ClearMessage(LocalMessages[I]);
    AddLocalizedMessage(I, InMessageClass, CriticalString, Switch, Position, Lifetime, FontSize, DrawColor, MessageCount, OptionalObject);
}

function AddLocalizedMessage(int Index, class<LocalMessage> InMessageClass, string CriticalString, int Switch, float Position, float Lifetime, int FontSize, Color DrawColor, optional int MessageCount, optional Object OptionalObject)
{
    LocalMessages[Index].Message = InMessageClass;
    LocalMessages[Index].Switch = Switch;
    LocalMessages[Index].EndOfLife = Lifetime + WorldInfo.TimeSeconds;
    LocalMessages[Index].StringMessage = CriticalString;
    LocalMessages[Index].Lifetime = Lifetime;
    LocalMessages[Index].PosY = Position;
    LocalMessages[Index].DrawColor = DrawColor;
    LocalMessages[Index].FontSize = FontSize;
    LocalMessages[Index].Count = MessageCount;
    LocalMessages[Index].OptionalObject = OptionalObject;
}

function GetScreenCoords(float PosY, out float ScreenX, out float ScreenY, out HudLocalizedMessage InMessage)
{
    ScreenX = 0.5 * Canvas.ClipX;
    ScreenY = ((PosY * HudCanvasScale) * Canvas.ClipY) + (((1 - HudCanvasScale) * 0.5) * Canvas.ClipY);
    ScreenX -= (InMessage.DX * 0.5);
    ScreenY -= (InMessage.DY * 0.5);
}

function DrawMessage(int I, float PosY, out float DX, out float DY)
{
    local float FadeValue, ScreenX, ScreenY;

    FadeValue = FMin(1, LocalMessages[I].EndOfLife - WorldInfo.TimeSeconds);
    Canvas.DrawColor = LocalMessages[I].DrawColor;
    Canvas.DrawColor.A = byte(FadeValue * float(Canvas.DrawColor.A));
    Canvas.Font = LocalMessages[I].StringFont;
    GetScreenCoords(PosY, ScreenX, ScreenY, LocalMessages[I]);
    DX = LocalMessages[I].DX / Canvas.ClipX;
    DY = LocalMessages[I].DY / Canvas.ClipY;
    DrawMessageText(LocalMessages[I], ScreenX, ScreenY);
    LocalMessages[I].Drawn = true;
}

function DrawMessageText(HudLocalizedMessage LocalMessage, float ScreenX, float ScreenY)
{
    local FontRenderInfo FontInfo;

    Canvas.SetPos(ScreenX, ScreenY);
    FontInfo.bClipText = true;
    Canvas.DrawText(LocalMessage.StringMessage, false,,, FontInfo);
}

function DisplayLocalMessages()
{
    local float PosY, DY, DX;
    local int I, J, LocalMessagesArrayCount, AreaMessageCount;
    local float FadeValue;
    local int FontSize;

    if(LocalMessages[0].Message == none)
    {
        return;
    }
    Canvas.Reset(true);
    LocalMessagesArrayCount = 8;
    I = 0;
    J0x5D:

    if(I < LocalMessagesArrayCount)
    {
        if(LocalMessages[I].Message == none)
        {
            goto J0x428;
        }
        LocalMessages[I].Drawn = false;
        if(LocalMessages[I].StringFont == none)
        {
            FontSize = LocalMessages[I].FontSize + MessageFontOffset;
            LocalMessages[I].StringFont = GetFontSizeIndex(FontSize);
            Canvas.Font = LocalMessages[I].StringFont;
            Canvas.TextSize(LocalMessages[I].StringMessage, DX, DY);
            LocalMessages[I].DX = DX;
            LocalMessages[I].DY = DY;
            if(LocalMessages[I].StringFont == none)
            {
                J = I;
                J0x2AA:

                if(J < (LocalMessagesArrayCount - 1))
                {
                    LocalMessages[J] = LocalMessages[J + 1];
                    ++ J;
                    goto J0x2AA;
                }
                ClearMessage(LocalMessages[J]);
                -- I;
                goto J0x41A;
            }
        }
        FadeValue = LocalMessages[I].EndOfLife - WorldInfo.TimeSeconds;
        if(FadeValue <= 0)
        {
            J = I;
            J0x39D:

            if(J < (LocalMessagesArrayCount - 1))
            {
                LocalMessages[J] = LocalMessages[J + 1];
                ++ J;
                goto J0x39D;
            }
            ClearMessage(LocalMessages[J]);
            -- I;            
        }
        J0x41A:

        ++ I;
        goto J0x5D;
    }
    J0x428:

    I = 0;
    J0x433:

    if(I < LocalMessagesArrayCount)
    {
        if(LocalMessages[I].Message == none)
        {
            goto J0x650;
        }
        if(LocalMessages[I].Drawn)
        {            
        }
        else
        {
            PosY = LocalMessages[I].PosY;
            AreaMessageCount = 0;
            J = I;
            J0x4F4:

            if(J < LocalMessagesArrayCount)
            {
                if(LocalMessages[J].Drawn || LocalMessages[I].PosY != LocalMessages[J].PosY)
                {                    
                }
                else
                {
                    DrawMessage(J, PosY, DX, DY);
                    PosY += DY;
                    ++ AreaMessageCount;
                }
                ++ J;
                goto J0x4F4;
            }
            if(AreaMessageCount > MaxHUDAreaMessageCount)
            {
                LocalMessages[I].EndOfLife = WorldInfo.TimeSeconds;
            }
        }
        ++ I;
        goto J0x433;
    }
    J0x650:

}

function DisplayKismetMessages()
{
    local int KismetTextIdx;

    KismetTextIdx = 0;
    J0x0B:

    if(KismetTextIdx < KismetTextInfo.Length)
    {
        if((KismetTextInfo[KismetTextIdx].MessageEndTime > float(0)) && KismetTextInfo[KismetTextIdx].MessageEndTime <= WorldInfo.TimeSeconds)
        {
            KismetTextInfo.Remove(KismetTextIdx, 1;            
        }
        else
        {
            DrawText(KismetTextInfo[KismetTextIdx].MessageText $ KismetTextInfo[KismetTextIdx].AppendedText, KismetTextInfo[KismetTextIdx].MessageOffset, KismetTextInfo[KismetTextIdx].MessageFont, KismetTextInfo[KismetTextIdx].MessageFontScale, KismetTextInfo[KismetTextIdx].MessageColor);
            ++ KismetTextIdx;
        }
        goto J0x0B;
    }
}

function DrawText(string Text, Vector2D Position, Font TextFont, Vector2D FontScale, Color TextColor, const optional out FontRenderInfo RenderInfo)
{
    local float XL, YL;

    Canvas.Font = TextFont;
    Canvas.TextSize(Text, XL, YL);
    Canvas.SetPos(((Canvas.ClipX / float(2)) - (XL / float(2))) + Position.X, ((Canvas.ClipY / float(3)) - (YL / float(2))) + Position.Y);
    Canvas.SetDrawColor(TextColor.R, TextColor.G, TextColor.B, TextColor.A);
    Canvas.super(HUD).DrawText(Text, false, FontScale.X, FontScale.Y, RenderInfo);
}

static function Font GetFontSizeIndex(int FontSize)
{
    if(FontSize == 0)
    {
        return Class'Engine'.static.GetTinyFont();        
    }
    else
    {
        if(FontSize == 1)
        {
            return Class'Engine'.static.GetSmallFont();            
        }
        else
        {
            if(FontSize == 2)
            {
                return Class'Engine'.static.GetMediumFont();                
            }
            else
            {
                if(FontSize == 3)
                {
                    return Class'Engine'.static.GetLargeFont();                    
                }
                else
                {
                    return Class'Engine'.static.GetLargeFont();
                }
            }
        }
    }
}

function PlayerOwnerDied();

function NotifyBindPostProcessEffects();

event OnLostFocusPause(bool bEnable)
{
    if(bLostFocusPaused == bEnable)
    {
        return;
    }
    if(WorldInfo.NetMode != NM_Client)
    {
        bLostFocusPaused = bEnable;
        PlayerOwner.SetPause(bEnable);
    }
}

defaultproperties
{
    WhiteColor=(B=255,G=255,R=255,A=255)
    GreenColor=(B=0,G=255,R=0,A=255)
    RedColor=(B=0,G=0,R=255,A=255)
    bShowHUD=true
    bMessageBeep=true
    bScaleCanvasForCinematicMode=true
    HudCanvasScale=0.95
    ConsoleColor=(B=253,G=216,R=153,A=255)
    ConsoleMessageCount=4
    ConsoleFontSize=5
    MaxHUDAreaMessageCount=3
    ConsoleMessagePosY=0.8
    DebugDisplay(0)=AI
    CollisionType=ECollisionType.COLLIDE_CustomDefault
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bHidden=true
}