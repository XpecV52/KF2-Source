/*******************************************************************************
 * GameViewportClient generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameViewportClient extends ScriptViewportClient within Engine
    transient
    native
    config(Engine);

enum ESplitScreenType
{
    eSST_NONE,
    eSST_2P_HORIZONTAL,
    eSST_2P_VERTICAL,
    eSST_3P_FAVOR_TOP,
    eSST_3P_FAVOR_BOTTOM,
    eSST_4P,
    eSST_MAX
};

enum ESafeZoneType
{
    eSZ_TOP,
    eSZ_BOTTOM,
    eSZ_LEFT,
    eSZ_RIGHT,
    eSZ_MAX
};

enum ESetMode
{
    SetMode_Toggle,
    SetMode_Enable,
    SetMode_Disable,
    SetMode_MAX
};

struct native ShowFlags_Mirror
{
    var native const QWord flags0;
    var native const QWord flags1;
};

struct ExportShowFlags_Mirror extends ShowFlags_Mirror
{
};

struct native TitleSafeZoneArea
{
    var float MaxPercentX;
    var float MaxPercentY;
    var float RecommendedPercentX;
    var float RecommendedPercentY;

    structdefaultproperties
    {
        MaxPercentX=0
        MaxPercentY=0
        RecommendedPercentX=0
        RecommendedPercentY=0
    }
};

struct native PerPlayerSplitscreenData
{
    var float SizeX;
    var float SizeY;
    var float OriginX;
    var float OriginY;

    structdefaultproperties
    {
        SizeX=0
        SizeY=0
        OriginX=0
        OriginY=0
    }
};

struct native SplitscreenData
{
    var array<PerPlayerSplitscreenData> PlayerData;

    structdefaultproperties
    {
        PlayerData=none
    }
};

struct native DebugDisplayProperty
{
    var Object Obj;
    var name PropertyName;
    var bool bSpecialProperty;

    structdefaultproperties
    {
        Obj=none
        PropertyName=None
        bSpecialProperty=false
    }
};

var private native const noexport Pointer VfTable_FExec;
var const Pointer Viewport;
var const Pointer ViewportFrame;
var init protected array<init Interaction> GlobalInteractions;
var class<UIInteraction> UIControllerClass;
var UIInteraction UIController;
var Console ViewportConsole;
var const ExportShowFlags_Mirror ShowFlags;
var const localized string LoadingMessage;
var const localized string SavingMessage;
var const localized string ConnectingMessage;
var const localized string PausedMessage;
var const localized string PrecachingMessage;
var bool bShowTitleSafeZone;
var transient bool bDisplayHardwareMouseCursor;
var transient bool bOverrideDiffuseAndSpecular;
var transient bool bIsPlayInEditorViewport;
var transient bool bShowSystemMouseCursor;
var bool bDisableWorldRendering;
var bool bCapturedWorldRendering;
var config bool bDebugNoGFxUI;
var bool bAllowInputFromMultipleControllers;
var bool bNeedsNewGamepadPairingForControllerDisconnect;
var bool bNeedsNewGamepadPairingForNewProfile;
var TitleSafeZoneArea TitleSafeZone;
var array<SplitscreenData> SplitscreenInfo;
var protected GameViewportClient.ESplitScreenType DesiredSplitscreenType;
var protected GameViewportClient.ESplitScreenType ActiveSplitscreenType;
var const GameViewportClient.ESplitScreenType Default2PSplitType;
var const GameViewportClient.ESplitScreenType Default3PSplitType;
var string ProgressMessage[2];
var float ProgressTimeOut;
var float ProgressFadeTime;
var array<DebugDisplayProperty> DebugProperties;
var native const Pointer ScaleformInteraction;
var delegate<HandleInputKey> __HandleInputKey__Delegate;
var delegate<HandleInputAxis> __HandleInputAxis__Delegate;
var delegate<HandleInputChar> __HandleInputChar__Delegate;

delegate bool HandleInputKey(int ControllerId, name Key, Core.Object.EInputEvent EventType, float AmountDepressed, optional bool bGamepad);

delegate bool HandleInputAxis(int ControllerId, name Key, float Delta, float DeltaTime, bool bGamepad);

delegate bool HandleInputChar(int ControllerId, string Unicode);

// Export UGameViewportClient::execConsoleCommand(FFrame&, void* const)
native function string ConsoleCommand(string Command);

// Export UGameViewportClient::execGetViewportSize(FFrame&, void* const)
native final function GetViewportSize(out Vector2D out_ViewportSize);

// Export UGameViewportClient::execIsFullScreenViewport(FFrame&, void* const)
native final function bool IsFullScreenViewport();

// Export UGameViewportClient::execGetMousePosition(FFrame&, void* const)
native final function Vector2D GetMousePosition();

// Export UGameViewportClient::execShouldForceFullscreenViewport(FFrame&, void* const)
native final function bool ShouldForceFullscreenViewport();

// Export UGameViewportClient::execGetNumCustomInteractions(FFrame&, void* const)
native function int GetNumCustomInteractions();

// Export UGameViewportClient::execGetCustomInteractionClass(FFrame&, void* const)
native function class<UIInteraction> GetCustomInteractionClass(int InIndex);

// Export UGameViewportClient::execSetCustomInteractionObject(FFrame&, void* const)
native function SetCustomInteractionObject(Interaction InInteraction);

// Export UGameViewportClient::execNotifySplitscreenLayoutChanged(FFrame&, void* const)
native function NotifySplitscreenLayoutChanged();

// Export UGameViewportClient::execForceUpdateMouseCursor(FFrame&, void* const)
native function ForceUpdateMouseCursor(bool bSetCursor);

// Export UGameViewportClient::execSetMouse(FFrame&, void* const)
native function SetMouse(int X, int Y);

event LocalPlayer CreatePlayer(int ControllerId, out string OutError, bool bSpawnActor)
{
    local LocalPlayer NewPlayer;
    local int InsertIndex;

    LogInternal(((("Creating new player with ControllerId" @ string(ControllerId)) @ "(") $ string(Outer.GamePlayers.Length)) @ "existing players)", 'PlayerManagement');
    assert(Outer.LocalPlayerClass != none);
    NewPlayer = new (Outer) Outer.LocalPlayerClass;
    NewPlayer.ViewportClient = self;
    NewPlayer.ControllerId = ControllerId;
    InsertIndex = AddLocalPlayer(NewPlayer);
    if(bSpawnActor && InsertIndex != -1)
    {
        if(Outer.GetCurrentWorldInfo().NetMode != NM_Client)
        {
            if(!NewPlayer.SpawnPlayActor("", OutError))
            {
                RemoveLocalPlayer(NewPlayer);
                NewPlayer = none;
            }            
        }
        else
        {
            NewPlayer.SendSplitJoin();
        }
    }
    if(OutError != "")
    {
        LogInternal("Player creation failed with error:" @ OutError);        
    }
    else
    {
        LogInternal(((((((("Successfully created new player with ControllerId" @ string(ControllerId)) $ ":") @ string(NewPlayer)) @ "- inserted into GamePlayers array at index") @ string(InsertIndex)) @ "(") $ string(Outer.GamePlayers.Length)) @ "existing players)", 'PlayerManagement');
        if((NewPlayer != none) && InsertIndex != -1)
        {
            NotifyPlayerAdded(InsertIndex, NewPlayer);
        }
    }
    return NewPlayer;
}

event bool RemovePlayer(LocalPlayer ExPlayer)
{
    local int OldIndex, I;
    local array<int> IDMappings;

    if(ExPlayer.Actor.Role == ROLE_Authority)
    {
        LogInternal(((((((("Removing player" @ string(ExPlayer)) @ " with ControllerId") @ string(ExPlayer.ControllerId)) @ "at index") @ string(Outer.GamePlayers.Find(ExPlayer)) @ "(") $ string(Outer.GamePlayers.Length)) @ "existing players)", 'PlayerManagement');
        ExPlayer.ViewportClient = none;
        if(ExPlayer.Actor != none)
        {
            ExPlayer.Actor.Destroy();
        }
        OldIndex = RemoveLocalPlayer(ExPlayer);
        if(OldIndex != -1)
        {
            NotifyPlayerRemoved(OldIndex, ExPlayer);
        }
        if(OldIndex != Outer.GamePlayers.Length)
        {
            I = 0;
            J0x20C:

            if(I < Outer.GamePlayers.Length)
            {
                if(I < OldIndex)
                {
                    IDMappings.AddItem(I;                    
                }
                else
                {
                    IDMappings.AddItem(I + 1;
                }
                ++ I;
                goto J0x20C;
            }
        }
        if(IDMappings.Length > 0)
        {
            FixupOwnerReferences(IDMappings);
        }
        LogInternal(((((((("Finished removing player " @ string(ExPlayer)) @ " with ControllerId") @ string(ExPlayer.ControllerId)) @ "at index") @ string(OldIndex)) @ "(") $ string(Outer.GamePlayers.Length)) @ "remaining players)", 'PlayerManagement');
        return true;        
    }
    else
    {
        LogInternal(((((("Not removing player" @ string(ExPlayer)) @ " with ControllerId") @ string(ExPlayer.ControllerId)) @ "because player does not have appropriate role (") $ string(GetEnum(Enum'ENetRole', ExPlayer.Actor.Role))) $ ")", 'PlayerManagement');
        return false;
    }
}

final event LocalPlayer FindPlayerByControllerId(int ControllerId)
{
    local int PlayerIndex;

    PlayerIndex = 0;
    J0x0B:

    if(PlayerIndex < Outer.GamePlayers.Length)
    {
        if(Outer.GamePlayers[PlayerIndex].ControllerId == ControllerId)
        {
            return Outer.GamePlayers[PlayerIndex];
        }
        ++ PlayerIndex;
        goto J0x0B;
    }
    return none;
}

event bool Init(out string OutError)
{
    local PlayerManagerInteraction PlayerInteraction;
    local int NumCustomInteractions;
    local class<UIInteraction> CustomInteractionClass;
    local UIInteraction CustomInteraction;
    local int Idx;

    assert(Outer.ConsoleClass != none);
    ActiveSplitscreenType = DesiredSplitscreenType;
    ViewportConsole = new (self) Outer.ConsoleClass;
    if((InsertInteraction(ViewportConsole)) == -1)
    {
        OutError = "Failed to add interaction to GlobalInteractions array:" @ string(ViewportConsole);
        return false;
    }
    NumCustomInteractions = GetNumCustomInteractions();
    Idx = 0;
    J0xF3:

    if(Idx < NumCustomInteractions)
    {
        CustomInteractionClass = GetCustomInteractionClass(Idx);
        CustomInteraction = new (self) CustomInteractionClass;
        if((InsertInteraction(CustomInteraction)) == -1)
        {
            OutError = "Failed to add interaction to GlobalInteractions array:" @ string(CustomInteraction);
            return false;
        }
        SetCustomInteractionObject(CustomInteraction);
        ++ Idx;
        goto J0xF3;
    }
    assert(UIControllerClass != none);
    UIController = new (self) UIControllerClass;
    if((InsertInteraction(UIController)) == -1)
    {
        OutError = "Failed to add interaction to GlobalInteractions array:" @ string(UIController);
        return false;
    }
    PlayerInteraction = new (self) Class'PlayerManagerInteraction';
    if((InsertInteraction(PlayerInteraction)) == -1)
    {
        OutError = "Failed to add interaction to GlobalInteractions array:" @ string(PlayerInteraction);
        return false;
    }
    if(bDebugNoGFxUI)
    {
        DebugSetUISystemEnabled(true, false);
    }
    return CreateInitialPlayer(OutError);
}

function bool CreateInitialPlayer(out string OutError)
{
    local int ControllerId;
    local bool bFoundInitialGamepad, bResult;

    ControllerId = 0;
    J0x0B:

    if(ControllerId < 24)
    {
        if(UIController.IsLoggedIn(ControllerId))
        {
            bFoundInitialGamepad = true;
            bResult = (CreatePlayer(ControllerId, OutError, false)) != none;
            goto J0x8F;
        }
        ++ ControllerId;
        goto J0x0B;
    }
    J0x8F:

    if(!bFoundInitialGamepad || !bResult)
    {
        ControllerId = 0;
        J0xBA:

        if(ControllerId < 24)
        {
            if(UIController.IsGamepadConnected(ControllerId))
            {
                bFoundInitialGamepad = true;
                bResult = (CreatePlayer(ControllerId, OutError, false)) != none;
                goto J0x13D;
            }
            ++ ControllerId;
            goto J0xBA;
        }
    }
    J0x13D:

    if(!bFoundInitialGamepad || !bResult)
    {
        bResult = (CreatePlayer(0, OutError, false)) != none;
    }
    return bResult;
}

event int InsertInteraction(Interaction NewInteraction, optional int InIndex)
{
    local int Result;

    InIndex = -1;
    Result = -1;
    if(NewInteraction != none)
    {
        if(InIndex == -1)
        {
            InIndex = GlobalInteractions.Length;
        }
        if(InIndex >= 0)
        {
            Result = Clamp(InIndex, 0, GlobalInteractions.Length);
            GlobalInteractions.Insert(Result, 1;
            GlobalInteractions[Result] = NewInteraction;
            NewInteraction.Init();
            NewInteraction.OnInitialize();            
        }
        else
        {
            WarnInternal("Invalid insertion index specified:" @ string(InIndex));
        }
    }
    return Result;
}

event GameSessionEnded()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < GlobalInteractions.Length)
    {
        GlobalInteractions[I].NotifyGameSessionEnded();
        ++ I;
        goto J0x0B;
    }
}

function SetSplitscreenConfiguration(GameViewportClient.ESplitScreenType SplitType)
{
    DesiredSplitscreenType = SplitType;
}

function GameViewportClient.ESplitScreenType GetSplitscreenConfiguration()
{
    return ActiveSplitscreenType;
}

function UpdateActiveSplitscreenType()
{
    local GameViewportClient.ESplitScreenType SplitType;

    SplitType = DesiredSplitscreenType;
    switch(Outer.GamePlayers.Length)
    {
        case 0:
        case 1:
            SplitType = 0;
            break;
        case 2:
            if((SplitType != 1) && SplitType != 2)
            {
                SplitType = Default2PSplitType;
            }
            break;
        case 3:
            if((SplitType != 3) && SplitType != 4)
            {
                SplitType = Default3PSplitType;
            }
            break;
        default:
            SplitType = 5;
            break;
            break;
    }
    ActiveSplitscreenType = SplitType;
}

event LayoutPlayers()
{
    local int Idx;
    local GameViewportClient.ESplitScreenType SplitType, PreviousSplitType;

    PreviousSplitType = GetSplitscreenConfiguration();
    UpdateActiveSplitscreenType();
    SplitType = GetSplitscreenConfiguration();
    Idx = 0;
    J0x3D:

    if(Idx < Outer.GamePlayers.Length)
    {
        if((SplitType < SplitscreenInfo.Length) && Idx < SplitscreenInfo[SplitType].PlayerData.Length)
        {
            Outer.GamePlayers[Idx].Size.X = SplitscreenInfo[SplitType].PlayerData[Idx].SizeX;
            Outer.GamePlayers[Idx].Size.Y = SplitscreenInfo[SplitType].PlayerData[Idx].SizeY;
            Outer.GamePlayers[Idx].Origin.X = SplitscreenInfo[SplitType].PlayerData[Idx].OriginX;
            Outer.GamePlayers[Idx].Origin.Y = SplitscreenInfo[SplitType].PlayerData[Idx].OriginY;            
        }
        else
        {
            Outer.GamePlayers[Idx].Size.X = 0;
            Outer.GamePlayers[Idx].Size.Y = 0;
            Outer.GamePlayers[Idx].Origin.X = 0;
            Outer.GamePlayers[Idx].Origin.Y = 0;
        }
        ++ Idx;
        goto J0x3D;
    }
    if(PreviousSplitType != SplitType)
    {
        NotifySplitscreenLayoutChanged();
    }
}

event GetSubtitleRegion(out Vector2D MinPos, out Vector2D MaxPos)
{
    MaxPos.X = 1;
    MaxPos.Y = ((Outer.GamePlayers.Length == 1) ? 0.9 : 0.5);
}

final function int ConvertLocalPlayerToGamePlayerIndex(LocalPlayer LPlayer)
{
    return Outer.GamePlayers.Find(LPlayer;
}

final function bool HasTopSafeZone(int LocalPlayerIndex)
{
    switch(GetSplitscreenConfiguration())
    {
        case 0:
        case 2:
            return true;
        case 1:
        case 3:
            return ((LocalPlayerIndex == 0) ? true : false);
        case 4:
        case 5:
            return ((LocalPlayerIndex < 2) ? true : false);
        default:
            return false;
            break;
    }
}

final function bool HasBottomSafeZone(int LocalPlayerIndex)
{
    switch(GetSplitscreenConfiguration())
    {
        case 0:
        case 2:
            return true;
        case 1:
        case 3:
            return ((LocalPlayerIndex == 0) ? false : true);
        case 4:
        case 5:
            return ((LocalPlayerIndex > 1) ? true : false);
        default:
            return false;
            break;
    }
}

final function bool HasLeftSafeZone(int LocalPlayerIndex)
{
    switch(GetSplitscreenConfiguration())
    {
        case 0:
        case 1:
            return true;
        case 2:
            return ((LocalPlayerIndex == 0) ? true : false);
        case 3:
            return ((LocalPlayerIndex < 2) ? true : false);
        case 4:
        case 5:
            return (((LocalPlayerIndex == 0) || LocalPlayerIndex == 2) ? true : false);
        default:
            return false;
            break;
    }
}

final function bool HasRightSafeZone(int LocalPlayerIndex)
{
    switch(GetSplitscreenConfiguration())
    {
        case 0:
        case 1:
            return true;
        case 2:
        case 4:
            return ((LocalPlayerIndex > 0) ? true : false);
        case 3:
            return ((LocalPlayerIndex == 1) ? false : true);
        case 5:
            return (((LocalPlayerIndex == 0) || LocalPlayerIndex == 2) ? false : true);
        default:
            return false;
            break;
    }
}

final function GetPixelSizeOfScreen(out float out_Width, out float out_Height, Canvas Canvas, int LocalPlayerIndex)
{
    switch(GetSplitscreenConfiguration())
    {
        case 0:
            out_Width = Canvas.ClipX;
            out_Height = Canvas.ClipY;
            return;
        case 1:
            out_Width = Canvas.ClipX;
            out_Height = Canvas.ClipY * float(2);
            return;
        case 2:
            out_Width = Canvas.ClipX * float(2);
            out_Height = Canvas.ClipY;
            return;
        case 3:
            if(LocalPlayerIndex == 0)
            {
                out_Width = Canvas.ClipX;                
            }
            else
            {
                out_Width = Canvas.ClipX * float(2);
            }
            out_Height = Canvas.ClipY * float(2);
            return;
        case 4:
            if(LocalPlayerIndex == 2)
            {
                out_Width = Canvas.ClipX;                
            }
            else
            {
                out_Width = Canvas.ClipX * float(2);
            }
            out_Height = Canvas.ClipY * float(2);
            return;
        case 5:
            out_Width = Canvas.ClipX * float(2);
            out_Height = Canvas.ClipY * float(2);
            return;
        default:
            break;
    }
}

final function CalculateSafeZoneValues(out float out_Horizontal, out float out_Vertical, Canvas Canvas, int LocalPlayerIndex, bool bUseMaxPercent)
{
    local float ScreenWidth, ScreenHeight, XSafeZoneToUse, YSafeZoneToUse;

    XSafeZoneToUse = ((bUseMaxPercent) ? TitleSafeZone.MaxPercentX : TitleSafeZone.RecommendedPercentX);
    YSafeZoneToUse = ((bUseMaxPercent) ? TitleSafeZone.MaxPercentY : TitleSafeZone.RecommendedPercentY);
    GetPixelSizeOfScreen(ScreenWidth, ScreenHeight, Canvas, LocalPlayerIndex);
    out_Horizontal = (ScreenWidth * (float(1) - XSafeZoneToUse)) / 2;
    out_Vertical = (ScreenHeight * (float(1) - YSafeZoneToUse)) / 2;
}

final function bool CalculateDeadZoneForAllSides(LocalPlayer LPlayer, Canvas Canvas, out float fTopSafeZone, out float fBottomSafeZone, out float fLeftSafeZone, out float fRightSafeZone, optional bool bUseMaxPercent)
{
    local bool bHasTopSafeZone, bHasBottomSafeZone, bHasRightSafeZone, bHasLeftSafeZone;
    local int LocalPlayerIndex;
    local float HorizSafeZoneValue, VertSafeZoneValue;

    if(LPlayer != none)
    {
        LocalPlayerIndex = ConvertLocalPlayerToGamePlayerIndex(LPlayer);
        if(LocalPlayerIndex != -1)
        {
            bHasTopSafeZone = HasTopSafeZone(LocalPlayerIndex);
            bHasBottomSafeZone = HasBottomSafeZone(LocalPlayerIndex);
            bHasLeftSafeZone = HasLeftSafeZone(LocalPlayerIndex);
            bHasRightSafeZone = HasRightSafeZone(LocalPlayerIndex);
            if(((bHasTopSafeZone || bHasBottomSafeZone) || bHasLeftSafeZone) || bHasRightSafeZone)
            {
                CalculateSafeZoneValues(HorizSafeZoneValue, VertSafeZoneValue, Canvas, LocalPlayerIndex, bUseMaxPercent);
                if(bHasTopSafeZone)
                {
                    fTopSafeZone = VertSafeZoneValue;                    
                }
                else
                {
                    fTopSafeZone = 0;
                }
                if(bHasBottomSafeZone)
                {
                    fBottomSafeZone = VertSafeZoneValue;                    
                }
                else
                {
                    fBottomSafeZone = 0;
                }
                if(bHasLeftSafeZone)
                {
                    fLeftSafeZone = HorizSafeZoneValue;                    
                }
                else
                {
                    fLeftSafeZone = 0;
                }
                if(bHasRightSafeZone)
                {
                    fRightSafeZone = HorizSafeZoneValue;                    
                }
                else
                {
                    fRightSafeZone = 0;
                }
                return true;
            }
        }
    }
    return false;
}

event Tick(float DeltaTime);

function DrawTitleSafeArea(Canvas Canvas)
{
    Canvas.SetDrawColor(255, 0, 0, 255);
    Canvas.SetPos((Canvas.ClipX * (float(1) - TitleSafeZone.MaxPercentX)) / 2, (Canvas.ClipY * (float(1) - TitleSafeZone.MaxPercentY)) / 2);
    Canvas.DrawBox(Canvas.ClipX * TitleSafeZone.MaxPercentX, Canvas.ClipY * TitleSafeZone.MaxPercentY);
    Canvas.SetDrawColor(255, 255, 0, 255);
    Canvas.SetPos((Canvas.ClipX * (float(1) - TitleSafeZone.RecommendedPercentX)) / 2, (Canvas.ClipY * (float(1) - TitleSafeZone.RecommendedPercentY)) / 2);
    Canvas.DrawBox(Canvas.ClipX * TitleSafeZone.RecommendedPercentX, Canvas.ClipY * TitleSafeZone.RecommendedPercentY);
}

event PostRender(Canvas Canvas)
{
    if(bShowTitleSafeZone)
    {
        DrawTitleSafeArea(Canvas);
    }
    if(ViewportConsole != none)
    {
        ViewportConsole.PostRender_Console(Canvas);
    }
    DrawTransition(Canvas);
}

function DisplayProgressMessage(Canvas Canvas)
{
    local int I, LineCount;
    local float FontDX, FontDY, X, Y;
    local byte Alpha;
    local float TimeLeft;

    TimeLeft = ProgressTimeOut - Class'Engine'.static.GetCurrentWorldInfo().TimeSeconds;
    Alpha = ((TimeLeft >= ProgressFadeTime) ? 255 : byte((float(255) * TimeLeft) / ProgressFadeTime));
    LineCount = 0;
    I = 0;
    J0xA0:

    if(I < 2)
    {
        if(ProgressMessage[I] != "")
        {
            ++ LineCount;
        }
        ++ I;
        goto J0xA0;
    }
    Canvas.Font = Class'Engine'.static.GetMediumFont();
    Canvas.TextSize("A", FontDX, FontDY);
    X = 0.5 * float(Canvas.SizeX);
    Y = 0.5 * float(Canvas.SizeY);
    Y -= (FontDY * (float(LineCount) / 2));
    Canvas.DrawColor.R = 255;
    Canvas.DrawColor.G = 255;
    Canvas.DrawColor.B = 255;
    I = 0;
    J0x288:

    if(I < 2)
    {
        if(ProgressMessage[I] != "")
        {
            Canvas.DrawColor.A = Alpha;
            Canvas.TextSize(ProgressMessage[I], FontDX, FontDY);
            Canvas.SetPos(X - (FontDX / 2), Y);
            Canvas.DrawText(ProgressMessage[I]);
            Y += FontDY;
        }
        ++ I;
        goto J0x288;
    }
}

function DrawTransition(Canvas Canvas)
{
    switch(Outer.TransitionType)
    {
        case 2:
            DrawTransitionMessage(Canvas, LoadingMessage);
            break;
        case 3:
            DrawTransitionMessage(Canvas, SavingMessage);
            break;
        case 4:
            DrawTransitionMessage(Canvas, ConnectingMessage);
            break;
        case 5:
            DrawTransitionMessage(Canvas, PrecachingMessage);
            break;
        case 1:
            DrawTransitionMessage(Canvas, PausedMessage);
            break;
        default:
            break;
    }
}

function DrawTransitionMessage(Canvas Canvas, string Message)
{
    local float XL, YL;

    Canvas.Font = Class'Engine'.static.GetLargeFont();
    Canvas.bCenter = false;
    Canvas.StrLen(Message, XL, YL);
    Canvas.SetPos((0.5 * (Canvas.ClipX - XL)) + float(1), ((0.66 * Canvas.ClipY) - (YL * 0.5)) + float(1));
    Canvas.SetDrawColor(0, 0, 0);
    Canvas.DrawText(Message, false);
    Canvas.SetPos(0.5 * (Canvas.ClipX - XL), (0.66 * Canvas.ClipY) - (YL * 0.5));
    Canvas.SetDrawColor(0, 0, 255);
    Canvas.DrawText(Message, false);
}

final function NotifyPlayerAdded(int PlayerIndex, LocalPlayer AddedPlayer)
{
    local int InteractionIndex;

    LayoutPlayers();
    InteractionIndex = 0;
    J0x15:

    if(InteractionIndex < GlobalInteractions.Length)
    {
        if(GlobalInteractions[InteractionIndex] != none)
        {
            GlobalInteractions[InteractionIndex].NotifyPlayerAdded(PlayerIndex, AddedPlayer);
        }
        ++ InteractionIndex;
        goto J0x15;
    }
}

final function NotifyPlayerRemoved(int PlayerIndex, LocalPlayer RemovedPlayer)
{
    local int InteractionIndex;

    LayoutPlayers();
    InteractionIndex = GlobalInteractions.Length - 1;
    J0x21:

    if(InteractionIndex >= 0)
    {
        if(GlobalInteractions[InteractionIndex] != none)
        {
            GlobalInteractions[InteractionIndex].NotifyPlayerRemoved(PlayerIndex, RemovedPlayer);
        }
        -- InteractionIndex;
        goto J0x21;
    }
}

private final function int AddLocalPlayer(LocalPlayer NewPlayer)
{
    local int InsertIndex;

    InsertIndex = -1;
    if(NewPlayer != none)
    {
        InsertIndex = Outer.GamePlayers.Length;
        Outer.GamePlayers[InsertIndex] = NewPlayer;
    }
    return InsertIndex;
}

private final function int RemoveLocalPlayer(LocalPlayer ExistingPlayer)
{
    local int Index;

    Index = Outer.GamePlayers.Find(ExistingPlayer;
    if(Index != -1)
    {
        Outer.GamePlayers.Remove(Index, 1;
    }
    return Index;
}

event SetProgressMessage(PlayerController.EProgressMessageType MessageType, string Message, optional string Title, optional bool bIgnoreFutureNetworkMessages)
{
    local WorldInfo WI;

    WI = Class'Engine'.static.GetCurrentWorldInfo();
    if(MessageType == 0)
    {
        ClearProgressMessages();        
    }
    else
    {
        if((MessageType == 4) || MessageType == 7)
        {
            if(((WI != none) && WI.NetMode == NM_Client) && WI.BeginHostMigration())
            {
                LogInternal((((((((((("(" $ string(Name)) $ ") GameViewportClient::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "MessageType=") $ string(MessageType)) @ "Message=") $ Message) @ ": host migration started.. ") $ string(WI.PeerHostMigration.HostMigrationProgress), 'DevNet');                
            }
            else
            {
                if(!Outer.GamePlayers[0].Actor.bIgnoreNetworkMessages)
                {
                    LogInternal(((((((((("(" $ string(Name)) $ ") GameViewportClient::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "MessageType=") $ string(MessageType)) @ "Message=") $ Message) @ ": host migration not enabled.. handling connection error.", 'DevNet');
                    NotifyConnectionError(MessageType, Message, Title);
                }
            }            
        }
        else
        {
            if(MessageType == 6)
            {
                Outer.GamePlayers[0].Actor.bIgnoreNetworkMessages = false;
                NotifyConnectionError(MessageType, Message, Title);                
            }
            else
            {
                if(Title != "")
                {
                    ProgressMessage[0] = Title;
                    ProgressMessage[1] = Message;                    
                }
                else
                {
                    ProgressMessage[1] = "";
                    ProgressMessage[0] = Message;
                }
            }
        }
    }
    if(!Outer.GamePlayers[0].Actor.bIgnoreNetworkMessages)
    {
        Outer.GamePlayers[0].Actor.bIgnoreNetworkMessages = bIgnoreFutureNetworkMessages;
    }
}

function NotifyConnectionError(PlayerController.EProgressMessageType MessageType, optional string Message, optional string Title)
{
    local WorldInfo WI;

    Message = Localize("Errors", "ConnectionFailed", "Engine");
    Title = Localize("Errors", "ConnectionFailed_Title", "Engine");
    WI = Class'Engine'.static.GetCurrentWorldInfo();
    LogInternal((((((((((((((((("(" $ string(Name)) $ ") GameViewportClient::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Title:'") $ Title) $ "'") @ "Message:'") $ Message) $ "'") @ "NetMode:'") $ string(GetEnum(Enum'ENetMode', WI.NetMode))) $ "'") @ "Map:'") $ WI.GetURLMap()) $ "'", 'DevNet');
    if(WI.NetMode != NM_Standalone)
    {
        if(WI.Game != none)
        {
            WI.Game.bHasNetworkError = true;
        }        
        ConsoleCommand("start ?failed");
    }
}

exec event SetProgressTime(float T)
{
    ProgressTimeOut = T + Class'Engine'.static.GetCurrentWorldInfo().TimeSeconds;
}

exec function ClearProgressMessages()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < 2)
    {
        ProgressMessage[I] = "";
        ++ I;
        goto J0x0B;
    }
}

// Export UGameViewportClient::execGetPlayerOwner(FFrame&, void* const)
native final function LocalPlayer GetPlayerOwner(int PlayerIndex);

// Export UGameViewportClient::execFixupOwnerReferences(FFrame&, void* const)
native final function FixupOwnerReferences(array<int> IDMappings);

function OnPrimaryPlayerSwitch(LocalPlayer OldPrimaryPlayer, LocalPlayer NewPrimaryPlayer);

function BecomePrimaryPlayer(int PlayerIndex)
{
    local array<LocalPlayer> OtherPlayers;
    local LocalPlayer PlayerOwner, NextPlayer, OriginalPrimaryPlayer;
    local int NumPlayersRemoved, I, Count;
    local array<int> IDMappings;

    if(((UIController != none) && PlayerIndex > 0) && PlayerIndex < UIController.GetPlayerCount())
    {
        OriginalPrimaryPlayer = GetPlayerOwner(0);
        PlayerOwner = GetPlayerOwner(PlayerIndex);
        if(PlayerOwner == none)
        {
            LogInternal(("GameViewportClient:BecomePrimaryPlayer has failed to find the player owner for index" @ string(PlayerIndex)) @ "ABORTING!!!");
            return;
        }
        if(PlayerOwner != none)
        {
            NextPlayer = OriginalPrimaryPlayer;
            NumPlayersRemoved = 0;
            J0x134:

            if((NextPlayer != none) && NextPlayer != PlayerOwner)
            {
                UIController.NotifyPlayerRemoved(0, NextPlayer);
                UIController.Outer.Outer.GamePlayers.Remove(0, 1;
                OtherPlayers.AddItem(NextPlayer;
                NextPlayer = GetPlayerOwner(0);
                ++ NumPlayersRemoved;
                goto J0x134;
            }
            I = 0;
            J0x215:

            if(I < UIController.Outer.Outer.GamePlayers.Length)
            {
                IDMappings.AddItem(I + NumPlayersRemoved;
                ++ I;
                goto J0x215;
            }
            Count = 0;
            J0x2A6:

            if(OtherPlayers.Length > 0)
            {
                NextPlayer = OtherPlayers[0];
                UIController.Outer.Outer.GamePlayers.AddItem(NextPlayer;
                UIController.NotifyPlayerAdded(UIController.Outer.Outer.GamePlayers.Length - 1, NextPlayer);
                OtherPlayers.Remove(0, 1;
                IDMappings.AddItem(Count;
                ++ Count;
                goto J0x2A6;
            }
        }
        NextPlayer = GetPlayerOwner(0);
        if(OriginalPrimaryPlayer != NextPlayer)
        {
            LayoutPlayers();
            FixupOwnerReferences(IDMappings);
            NextPlayer.Actor.ReloadProfileSettings();
            OnPrimaryPlayerSwitch(OriginalPrimaryPlayer, NextPlayer);
        }
    }
}

// Export UGameViewportClient::execEnableScaleform(FFrame&, void* const)
native final function EnableScaleform();

// Export UGameViewportClient::execDisableScaleform(FFrame&, void* const)
native final function DisableScaleform();

// Export UGameViewportClient::execIsScaleformEnabled(FFrame&, void* const)
native final function bool IsScaleformEnabled();

// Export UGameViewportClient::execDebugSetUISystemEnabled(FFrame&, void* const)
native function DebugSetUISystemEnabled(bool bOldUISystemActive, bool bGFxUISystemActive);

simulated event SetHardwareMouseCursorVisibility(bool bIsVisible)
{
    local Vector2D ViewportSize;

    if(bIsVisible && !bDisplayHardwareMouseCursor)
    {
        GetViewportSize(ViewportSize);
        SetMouse(int(ViewportSize.X / float(2)), int(ViewportSize.Y / float(2)));
    }
    bDisplayHardwareMouseCursor = bIsVisible;
    ForceUpdateMouseCursor(true);
}

defaultproperties
{
    UIControllerClass=Class'UIInteraction'
    LoadingMessage="LOADING"
    SavingMessage="SAVING"
    ConnectingMessage="CONNECTING"
    PausedMessage="PAUSED"
    PrecachingMessage="PRECACHING"
    TitleSafeZone=(MaxPercentX=0.9,MaxPercentY=0.9,RecommendedPercentX=0.8,RecommendedPercentY=0.8)
    SplitscreenInfo(0)=(PlayerData=((SizeX=1,SizeY=1,OriginX=0,OriginY=0)))
    SplitscreenInfo(1)=(PlayerData=((SizeX=1,SizeY=0.5,OriginX=0,OriginY=0),(SizeX=1,SizeY=0.5,OriginX=0,OriginY=0.5)))
    SplitscreenInfo(2)=(PlayerData=((SizeX=0.5,SizeY=1,OriginX=0,OriginY=0),(SizeX=0.5,SizeY=1,OriginX=0.5,OriginY=0)))
    SplitscreenInfo(3)=(PlayerData=((SizeX=1,SizeY=0.5,OriginX=0,OriginY=0),(SizeX=0.5,SizeY=0.5,OriginX=0,OriginY=0.5),(SizeX=0.5,SizeY=0.5,OriginX=0.5,OriginY=0.5)))
    SplitscreenInfo(4)=(PlayerData=((SizeX=0.5,SizeY=0.5,OriginX=0,OriginY=0),(SizeX=0.5,SizeY=0.5,OriginX=0.5,OriginY=0),(SizeX=1,SizeY=0.5,OriginX=0,OriginY=0.5)))
    SplitscreenInfo(5)=(PlayerData=((SizeX=0.5,SizeY=0.5,OriginX=0,OriginY=0),(SizeX=0.5,SizeY=0.5,OriginX=0.5,OriginY=0),(SizeX=0.5,SizeY=0.5,OriginX=0,OriginY=0.5),(SizeX=0.5,SizeY=0.5,OriginX=0.5,OriginY=0.5)))
    Default2PSplitType=ESplitScreenType.eSST_2P_HORIZONTAL
    Default3PSplitType=ESplitScreenType.eSST_3P_FAVOR_TOP
    ProgressTimeOut=8
    ProgressFadeTime=1
}