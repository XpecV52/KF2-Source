/*******************************************************************************
 * NavigationPoint generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NavigationPoint extends Actor
    native
    notplaceable
    hidecategories(Navigation,Lighting,LightColor,Force)
    classgroup(Navigation);

const INFINITE_PATH_COST = 10000000;

struct native NavigationOctreeObject
{
    var Box BoundingBox;
    var Vector BoxCenter;
    var native const transient Pointer OctreeNode;
    var const noexport Object Owner;
    var const noexport byte OwnerType;

    structdefaultproperties
    {
        BoundingBox=(Min=(X=0,Y=0,Z=0),Max=(X=0,Y=0,Z=0),IsValid=0)
        BoxCenter=(X=0,Y=0,Z=0)
        Owner=none
        OwnerType=0
    }
};

struct native DebugNavCost
{
    var string Desc;
    var int Cost;

    structdefaultproperties
    {
        Desc=""
        Cost=0
    }
};

struct CheckpointRecord
{
    var bool bDisabled;
    var bool bBlocked;

    structdefaultproperties
    {
        bDisabled=false
        bBlocked=false
    }
};

var transient bool bEndPoint;
var transient bool bTransientEndPoint;
var transient bool bHideEditorPaths;
var transient bool bCanReach;
/** this node is currently unuseable */
var() bool bBlocked;
/** reachspecs from this path only in the direction the path is facing (180 degrees) */
var() bool bOneWayPath;
var bool bNeverUseStrafing;
var bool bAlwaysUseStrafing;
var const bool bForceNoStrafing;
var const bool bAutoBuilt;
var bool bSpecialMove;
var() bool bAllowPathConnections;
var() editconst bool bWallNode;
/** Tag identifier that can be used when debugging AI. For example, the 'AIPathTo <DebugTag>' will force a debug NPC to path to the NavigatioNPoint with a matching DebugTag */
var() bool bNoAutoConnect;
/** Notification will be sent to pawn when/if this node is added to its RouteCache, to allow early special handling */
var(KFPathnode) duplicatetransient bool bNotifyOnAddToRouteCache;
var const bool bNotBased;
var const bool bPathsChanged;
/** used by path building - means no automatically generated paths are sourced from this node */
var() bool bDestinationOnly;
var bool bSourceOnly;
var bool bSpecialForced;
var bool bMustBeReachable;
var bool bBlockable;
var bool bFlyingPreferred;
var bool bMayCausePain;
var transient bool bAlreadyVisited;
/** if true, forced paths to this node will have max width to accomodate vehicles */
var() bool bVehicleDestination;
var() bool bMakeSourceOnly;
var bool bMustTouchToReach;
var bool bCanWalkOnToReach;
var bool bBuildLongPaths;
/** indicates vehicles cannot use this node */
var(VehicleUsage) bool bBlockedForVehicles;
/** vehicles with bUsePreferredVehiclePaths set (large vehicles, usually) will prioritize using these nodes */
var(VehicleUsage) bool bPreferredVehiclePath;
var const bool bHasCrossLevelPaths;
var transient bool bShouldSaveForCheckpoint;
var(KFPathnode) bool bConnectToSameFloorOnly;
/**  
 *When true, this NavigationPoint will not allow other NavigationPoints to connect to it, and it will not
 *       allow itself to connect to other NavigationPoints - unless it is a forced path connection.
 */
var() bool bNoAutoConnectBiDirectional;
/** Flagged during pathbuilding for navigation points with no reachspecs. */
var() editconst bool bBadPlacement;
/** Flagged during pathbuilding for nodes that are considered unnecessary. */
var() editconst bool bUnnecessaryNavPoint;
var native const transient NavigationOctreeObject NavOctreeObject;
/** Brightness of light(s) affecting this navigation point (calculated when building paths) */
var() editconst float Luminance;
var LinearColor Intensity;
var(KFPathnode) duplicatetransient name DebugTag;
/** List of navigation points to prevent paths being built to */
var() duplicatetransient const editconst array<editconst editinline ReachSpec> PathList;
var() duplicatetransient editoronly array<editoronly ActorReference> EditorProscribedPaths;
/** List of navigation points to force paths to be built to */
var() duplicatetransient editoronly array<editoronly ActorReference> EditorForcedPaths;
/** List of volumes containing this navigation point relevant for gameplay */
var() const editconst array<editconst ActorReference> Volumes;
var int visitedWeight;
var const int bestPathWeight;
var private const NavigationPoint nextNavigationPoint;
var const NavigationPoint nextOrdered;
var const NavigationPoint prevOrdered;
var const NavigationPoint previousPath;
var int Cost;
/** Extra weight added by level designer */
var() int ExtraCost;
var transient int TransientCost;
var transient int FearCost;
var transient array<DebugNavCost> CostArray;
var DroppedPickup InventoryCache;
var float InventoryDist;
var const float LastDetourWeight;
var export editinline CylinderComponent CylinderComponent;
/** path size of the largest ReachSpec in this node's PathList */
var() const editconst Cylinder MaxPathSize;
/** GUID used for linking paths across levels */
var() duplicatetransient const editconst Guid NavGuid;
var const export editinline transient SpriteComponent GoodSprite;
var const export editinline transient SpriteComponent BadSprite;
/** Which navigation network does this navigation point connect to? */
var() const editconst int NetworkID;
var transient Pawn AnchoredPawn;
var transient float LastAnchoredPawnTime;

// Export UNavigationPoint::execGetBoundingCylinder(FFrame&, void* const)
native function GetBoundingCylinder(out float CollisionRadius, out float CollisionHeight);

// Export UNavigationPoint::execGetReachSpecTo(FFrame&, void* const)
native final function ReachSpec GetReachSpecTo(NavigationPoint Nav, optional class<ReachSpec> SpecClass, optional Pawn CheckPawn);

// Export UNavigationPoint::execIsUsableAnchorFor(FFrame&, void* const)
native function bool IsUsableAnchorFor(Pawn P);

// Export UNavigationPoint::execCanTeleport(FFrame&, void* const)
native function bool CanTeleport(Actor A);

event int SpecialCost(Pawn Seeker, ReachSpec Path);

event bool Accept(Actor Incoming, Actor Source)
{
    local bool bResult;

    bResult = Incoming.SetLocation(Location);
    if(bResult)
    {
        Incoming.Velocity = vect(0, 0, 0);
        Incoming.SetRotation(Rotation);
    }
    Incoming.PlayTeleportEffect(true, false);
    return bResult;
}

event float DetourWeight(Pawn Other, float PathWeight);

event bool SuggestMovePreparation(Pawn Other)
{
    return Other.SpecialMoveTo(Other.Anchor, self, Other.Controller.MoveTarget);
}

function bool ProceedWithMove(Pawn Other)
{
    return true;
}

static final function NavigationPoint GetNearestNavToActor(Actor ChkActor, optional class<NavigationPoint> RequiredClass, optional array<NavigationPoint> ExcludeList, optional float MinDist)
{
    local NavigationPoint Nav, BestNav;
    local float Dist, bestDist;

    if(ChkActor != none)
    {
        foreach ChkActor.WorldInfo.AllNavigationPoints(Class'NavigationPoint', Nav)
        {
            if(((RequiredClass == none) || Nav.Class == RequiredClass) && ExcludeList.Find(Nav == -1)
            {
                Dist = VSize(Nav.Location - ChkActor.Location);
                if(Dist > MinDist)
                {
                    if((BestNav == none) || Dist < bestDist)
                    {
                        BestNav = Nav;
                        bestDist = Dist;
                    }
                }
            }            
        }        
    }
    return BestNav;
}

static final function NavigationPoint GetNearestNavToPoint(Actor ChkActor, Vector ChkPoint, optional class<NavigationPoint> RequiredClass, optional array<NavigationPoint> ExcludeList)
{
    local NavigationPoint Nav, BestNav;
    local float Dist, bestDist;

    if(ChkActor != none)
    {
        foreach ChkActor.WorldInfo.AllNavigationPoints(Class'NavigationPoint', Nav)
        {
            if(((RequiredClass == none) || Nav.Class == RequiredClass) && ExcludeList.Find(Nav == -1)
            {
                Dist = VSize(Nav.Location - ChkPoint);
                if((BestNav == none) || Dist < bestDist)
                {
                    BestNav = Nav;
                    bestDist = Dist;
                }
            }            
        }        
    }
    return BestNav;
}

// Export UNavigationPoint::execGetAllNavInRadius(FFrame&, void* const)
native static final function bool GetAllNavInRadius(Actor ChkActor, Vector ChkPoint, float Radius, out array<NavigationPoint> out_NavList, optional bool bSkipBlocked, optional int inNetworkID, optional Cylinder MinSize)
{
    inNetworkID = -1;                                        
}

// Export UNavigationPoint::execIsOnDifferentNetwork(FFrame&, void* const)
native final function bool IsOnDifferentNetwork(NavigationPoint Nav);

function OnToggle(SeqAct_Toggle inAction)
{
    if(inAction.InputLinks[0].bHasImpulse)
    {
        bBlocked = false;        
    }
    else
    {
        if(inAction.InputLinks[1].bHasImpulse)
        {
            bBlocked = true;            
        }
        else
        {
            if(inAction.InputLinks[2].bHasImpulse)
            {
                bBlocked = !bBlocked;
            }
        }
    }
    WorldInfo.Game.NotifyNavigationChanged(self);
    bShouldSaveForCheckpoint = true;
}

simulated event ShutDown()
{
    super.ShutDown();
    bBlocked = true;
    WorldInfo.Game.NotifyNavigationChanged(self);
    bShouldSaveForCheckpoint = true;
}

function bool ShouldSaveForCheckpoint()
{
    return bShouldSaveForCheckpoint;
}

function CreateCheckpointRecord(out CheckpointRecord Record)
{
    Record.bBlocked = bBlocked;
}

function ApplyCheckpointRecord(const out CheckpointRecord Record)
{
    bBlocked = Record.bBlocked;
    bShouldSaveForCheckpoint = true;
}

simulated event string GetDebugAbbrev()
{
    return "NP?";
}

defaultproperties
{
    bAllowPathConnections=true
    bMayCausePain=true
    bMustTouchToReach=true
    Intensity=(R=0,G=0,B=0,A=1)
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=50
        CollisionRadius=50
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__NavigationPoint.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_NavP'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__NavigationPoint.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        Sprite=Texture2D'EditorResources.Bad'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
        Scale=0.25
    object end
    // Reference: SpriteComponent'Default__NavigationPoint.Sprite2'
    BadSprite=Sprite2
    NetworkID=-1
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_NavP'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
    object end
    // Reference: SpriteComponent'Default__NavigationPoint.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        Sprite=Texture2D'EditorResources.Bad'
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
        HiddenGame=true
        HiddenEditor=true
        AlwaysLoadOnClient=false
        AlwaysLoadOnServer=false
        Scale=0.25
    object end
    // Reference: SpriteComponent'Default__NavigationPoint.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(B=255,G=200,R=150,A=255)
        bTreatAsASprite=true
        SpriteCategoryName=Navigation
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__NavigationPoint.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=50
        CollisionRadius=50
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__NavigationPoint.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__NavigationPoint.PathRenderer'
    Components(4)=PathRenderer
    bStatic=true
    bNoDelete=true
    bCollideWhenPlacing=true
    bForceAllowKismetModification=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=50
        CollisionRadius=50
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__NavigationPoint.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}