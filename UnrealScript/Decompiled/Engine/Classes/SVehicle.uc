/*******************************************************************************
 * SVehicle generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SVehicle extends Vehicle
    abstract
    native(Physics)
    nativereplication
    config(Game)
    placeable
    hidecategories(Navigation);

struct native VehicleState
{
    var RigidBodyState RBState;
    var byte ServerBrake;
    var byte ServerGas;
    var byte ServerSteering;
    var byte ServerRise;
    var bool bServerHandbrake;
    var int ServerView;

    structdefaultproperties
    {
        RBState=(Position=(X=0,Y=0,Z=0),Quaternion=(W=0,X=0,Y=0,Z=0),LinVel=(X=0,Y=0,Z=0),AngVel=(X=0,Y=0,Z=0),bNewData=0)
        ServerBrake=0
        ServerGas=0
        ServerSteering=0
        ServerRise=0
        bServerHandbrake=false
        ServerView=0
    }
};

var native const Pointer PVehicle;
var native const Pointer MyVehicleManager;
/** Chassis mass */
var(Vehicle) float ChassisMass;
/** If this vehicle is a tank */
var(Vehicle) bool bIsTank;
/** Enable debug rendering for this vehicle */
var(Vehicle) bool bEnableDebugRendering;
var bool bInReverseMode;
/** Use the stay-upright world constraint */
var(UprightConstraint) bool bStayUpright;
var bool bUseSuspensionAxis;
var bool bUpdateWheelShapes;
var const bool bVehicleOnGround;
var const bool bVehicleOnWater;
var const bool bIsInverted;
var const bool bChassisTouchingGround;
var const bool bWasChassisTouchingGroundLastTick;
var bool bCanFlip;
var bool bFlipRight;
var bool bIsUprighting;
var bool bOutputHandbrake;
var bool bHoldingDownHandbrake;
var int DebugRenderActiveGraphChannelWheel;
var int DebugRenderActiveGraphChannelEngine;
/** Object containing the actual vehicle simulation paramters and code. Allows you to 'plug' different vehicle types in. */
var() noclear const export editinline SVehicleSimBase SimObj;
/** Data for each wheel. Very important to list in this order FrontLeft, FrontRight, RearLeft, RearRight. */
var() export editinline array<export editinline SVehicleWheel> Wheels;
/** Center of mass location of the vehicle, in local space. */
var() Vector COMOffset;
/** Inertia Tensor Multipler - allows you to scale the components of the pre-calculated inertia tensor */
var() Vector InertiaTensorMultiplier;
/** Angle at which the vehicle will resist rolling */
var(UprightConstraint) float StayUprightRollResistAngle;
/** Angle at which the vehicle will resist pitching */
var(UprightConstraint) float StayUprightPitchResistAngle;
/** Amount of spring past the limit angles */
var(UprightConstraint) float StayUprightStiffness;
/** Amount of dampening past the limit angles */
var(UprightConstraint) float StayUprightDamping;
var export editinline RB_StayUprightSetup StayUprightConstraintSetup;
var export editinline RB_ConstraintInstance StayUprightConstraintInstance;
var float HeavySuspensionShiftPercent;
/** Vehicle total speed will be capped to this value */
var() float MaxSpeed;
/** Vehicle angular velocity will be capped to this value */
var() float MaxAngularVelocity;
var const float TimeOffGround;
/** Scales the lifting force applied to the vehicle during uprighting. */
var(Uprighting) float UprightLiftStrength;
/** Scales the torque applied to the vehicle during uprighting. */
var(Uprighting) float UprightTorqueStrength;
/** Time in seconds to apply uprighting force/torque. */
var(Uprighting) float UprightTime;
var float UprightStartTime;
/** Ambient engine-running sound.  Pitch modulated based on RPMS. */
var(Sounds) const editconst export editinline AudioComponent EngineSound;
/** Volume-modulated wheel squeeling. */
var(Sounds) const editconst export editinline AudioComponent SquealSound;
/** Played when the vehicle slams into things. */
var(Sounds) SoundCue CollisionSound;
/** Engine startup sound played upon entering the vehicle. */
var(Sounds) SoundCue EnterVehicleSound;
/** Engine switch-off sound played upon exiting the vhicle. */
var(Sounds) SoundCue ExitVehicleSound;
/** Minimum time passed between the triggering collision sounds; generally set to longest collision sound. */
var(Sounds) float CollisionIntervalSecs;
/** Slip velocity cuttoff below which no wheel squealing is heard. */
var(Sounds) const float SquealThreshold;
/** Lateral Slip velocity cut off below which no wheel squealing is heard */
var(Sounds) const float SquealLatThreshold;
/** multiplier for volume level of Lateral squeals relative to straight slip squeals. */
var(Sounds) const float LatAngleVolumeMult;
/** Time delay between the engine startup sound and the engine idling sound. */
var(Sounds) const float EngineStartOffsetSecs;
/** Time delay between the engine shutdown sound and the deactivation of the engine idling sound. */
var(Sounds) const float EngineStopOffsetSecs;
var float LastCollisionSoundTime;
var float OutputBrake;
var float OutputGas;
var float OutputSteering;
var float OutputRise;
var float ForwardVel;
var int NumPoweredWheels;
/** camera */
var() Vector BaseOffset;
var() float CamDist;
var int DriverViewPitch;
var int DriverViewYaw;
var native const VehicleState VState;
var native const float AngErrorAccumulator;
var float RadialImpulseScaling;

replication
{
     if(Physics == 10)
        MaxSpeed, VState;
}

// Export USVehicle::execAddForce(FFrame&, void* const)
native function AddForce(Vector Force);

// Export USVehicle::execAddImpulse(FFrame&, void* const)
native function AddImpulse(Vector Impulse);

// Export USVehicle::execAddTorque(FFrame&, void* const)
native function AddTorque(Vector Torque);

// Export USVehicle::execIsSleeping(FFrame&, void* const)
native function bool IsSleeping();

// Export USVehicle::execDrawGraphsAndPrintTireSurfaceTypes(FFrame&, void* const)
native function DrawGraphsAndPrintTireSurfaceTypes(HUD HUD, float YL, float YPos);

// Export USVehicle::execSetWheelCollision(FFrame&, void* const)
native final function SetWheelCollision(int WheelNum, bool bCollision);

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    if(EngineSound != none)
    {
        EngineSound.bShouldRemainActiveIfDropped = true;
    }
    if((CollisionSound != none) && CollisionIntervalSecs <= 0)
    {
        CollisionIntervalSecs = CollisionSound.GetCueDuration() / WorldInfo.TimeDilation;
    }
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    local int WheelIndex;
    local editinline SVehicleWheel Wheel;

    super(Pawn).PostInitAnimTree(SkelComp);
    if(SkelComp == Mesh)
    {
        WheelIndex = 0;
        J0x35:

        if(WheelIndex < Wheels.Length)
        {
            Wheel = Wheels[WheelIndex];
            Wheel.WheelControl = SkelControlWheel(Mesh.FindSkelControl(Wheel.SkelControlName));
            ++ WheelIndex;
            goto J0x35;
        }
    }
}

simulated event Destroyed()
{
    super.Destroyed();
    StopVehicleSounds();
}

simulated function TurnOff()
{
    super(Pawn).TurnOff();
    StopVehicleSounds();
}

simulated function StopVehicleSounds()
{
    if(EngineSound != none)
    {
        EngineSound.Stop();
    }
    if(SquealSound != none)
    {
        SquealSound.Stop();
    }
}

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    local Vector HitLocation, Dir, NewDir;
    local float Dist, DamageScale;
    local TraceHitInfo HitInfo;

    DamageFalloffExponent = 1;
    if(Role < ROLE_Authority)
    {
        return;
    }
    HitLocation = Location;
    Dir = Location - HurtOrigin;
    CheckHitInfo(HitInfo, Mesh, Dir, HitLocation);
    NewDir = HitLocation - HurtOrigin;
    Dist = VSize(NewDir);
    if(bFullDamage)
    {
        DamageScale = 1;        
    }
    else
    {
        if(Dist > DamageRadius)
        {
            return;            
        }
        else
        {
            DamageScale = FMax(0, 1 - (Dist / DamageRadius));
            DamageScale = DamageScale ** DamageFalloffExponent;
        }
    }
    RadialImpulseScaling = DamageScale;
    TakeDamage(int(BaseDamage * DamageScale), InstigatedBy, HitLocation, (DamageScale * Momentum) * Normal(Dir), DamageType, HitInfo, DamageCauser);
    RadialImpulseScaling = 1;
    if(Health > 0)
    {
        DriverRadiusDamage(BaseDamage, DamageRadius, InstigatedBy, DamageType, Momentum, HurtOrigin, DamageCauser);
    }
}

// Export USVehicle::execInitVehicleRagdoll(FFrame&, void* const)
native function InitVehicleRagdoll(SkeletalMesh RagdollMesh, PhysicsAsset RagdollPhysAsset, Vector ActorMove, bool bClearAnimTree);

function AddVelocity(Vector NewVelocity, Vector HitLocation, class<DamageType> DamageType, optional TraceHitInfo HitInfo)
{
    if(!IsZero(NewVelocity))
    {
        NewVelocity = (((RadialImpulseScaling * MomentumMult) * DamageType.default.VehicleMomentumScaling) * DamageType.default.KDamageImpulse) * Normal(NewVelocity);
        if(!bIgnoreForces && !IsZero(NewVelocity))
        {
            if(Location.Z > WorldInfo.StallZ)
            {
                NewVelocity.Z = FMin(NewVelocity.Z, 0);
            }
            if(InGodMode())
            {
                NewVelocity *= 0.25;
            }
            Mesh.AddImpulse(NewVelocity, HitLocation);
        }
    }
    RadialImpulseScaling = 1;
}

function bool Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    if(super.Died(Killer, DamageType, HitLocation))
    {
        bDriving = false;
        AddVelocity(TearOffMomentum, HitLocation, DamageType);
        return true;
    }
    return false;
}

simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
{
    local Vector pos, HitLocation, HitNormal;

    GetActorEyesViewPoint(out_CamLoc, out_CamRot);
    out_CamLoc += BaseOffset;
    pos = out_CamLoc - (vector(out_CamRot) * CamDist);
    if(Trace(HitLocation, HitNormal, pos, out_CamLoc, false, vect(0, 0, 0)) != none)
    {
        out_CamLoc = HitLocation + (HitNormal * float(2));        
    }
    else
    {
        out_CamLoc = pos;
    }
    return true;
}

simulated function name GetDefaultCameraMode(PlayerController RequestedBy)
{
    return 'Default';
}

function bool TryToDrive(Pawn P)
{
    if((bIsInverted && !bVehicleOnGround) && VSize(Velocity) <= 0.1)
    {
        if(bCanFlip)
        {
            bIsUprighting = true;
            UprightStartTime = WorldInfo.TimeSeconds;
        }
        return false;
    }
    return super.TryToDrive(P);
}

// Export USVehicle::execHasWheelsOnGround(FFrame&, void* const)
native simulated function bool HasWheelsOnGround();

simulated function StartEngineSound()
{
    if(EngineSound != none)
    {
        EngineSound.Play();
    }
    ClearTimer('StartEngineSound');
    ClearTimer('StopEngineSound');
}

simulated function StartEngineSoundTimed()
{
    if(EngineStartOffsetSecs > 0)
    {
        ClearTimer('StopEngineSound');
        SetTimer(EngineStartOffsetSecs, false, 'StartEngineSound');        
    }
    else
    {
        StartEngineSound();
    }
}

simulated function StopEngineSound()
{
    if(EngineSound != none)
    {
        EngineSound.Stop();
    }
    ClearTimer('StartEngineSound');
    ClearTimer('StopEngineSound');
}

simulated function StopEngineSoundTimed()
{
    if(EngineStopOffsetSecs > 0)
    {
        ClearTimer('StartEngineSound');
        SetTimer(EngineStopOffsetSecs, false, 'StopEngineSound');        
    }
    else
    {
        StopEngineSound();
    }
}

simulated function VehiclePlayEnterSound()
{
    if(EnterVehicleSound != none)
    {
        PlaySound(EnterVehicleSound);
    }
    StartEngineSoundTimed();
}

simulated function VehiclePlayExitSound()
{
    if(ExitVehicleSound != none)
    {
        PlaySound(ExitVehicleSound);
    }
    StopEngineSoundTimed();
}

simulated function DrivingStatusChanged()
{
    bUpdateWheelShapes = true;
    if(bDriving)
    {
        VehiclePlayEnterSound();        
    }
    else
    {
        if(Health > 0)
        {
            VehiclePlayExitSound();
        }
    }
}

simulated event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex)
{
    if((CollisionSound != none) && (WorldInfo.TimeSeconds - LastCollisionSoundTime) > CollisionIntervalSecs)
    {
        PlaySound(CollisionSound, true);
        LastCollisionSoundTime = WorldInfo.TimeSeconds;
    }
}

simulated event SuspensionHeavyShift(float Delta);

function PostTeleport(Teleporter OutTeleporter)
{
    Mesh.SetRBPosition(Location);
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local array<string> DebugInfo;
    local int I;

    super.DisplayDebug(HUD, out_YL, out_YPos);
    GetSVehicleDebug(DebugInfo);
    HUD.Canvas.SetDrawColor(0, 255, 0);
    I = 0;
    J0x7E:

    if(I < DebugInfo.Length)
    {
        HUD.Canvas.DrawText("  " @ DebugInfo[I]);
        out_YPos += out_YL;
        HUD.Canvas.SetPos(4, out_YPos);
        ++ I;
        goto J0x7E;
    }
    DisplayWheelsDebug(HUD, out_YL);
    if(bEnableDebugRendering)
    {
        DrawGraphsAndPrintTireSurfaceTypes(HUD, out_YL, out_YPos);
    }
}

simulated function DisplayWheelsDebug(HUD HUD, float YL)
{
    local int I, J;
    local Vector WorldLoc, ScreenLoc, X, Y, Z, EndPoint,
	    ScreenEndPoint;

    local Color SaveColor;
    local float LastForceValue, GraphScale, ForceValue;
    local Vector ForceValueLoc;

    if(SimObj == none)
    {
        return;
    }
    GraphScale = 100;
    SaveColor = HUD.Canvas.DrawColor;
    I = 0;
    J0x68:

    if(I < Wheels.Length)
    {
        GetAxes(Rotation, X, Y, Z);
        WorldLoc = Location + (Wheels[I].WheelPosition >> Rotation);
        ScreenLoc = HUD.Canvas.Project(WorldLoc);
        if((((ScreenLoc.X >= float(0)) && ScreenLoc.X < HUD.Canvas.ClipX) && ScreenLoc.Y >= float(0)) && ScreenLoc.Y < HUD.Canvas.ClipY)
        {
            HUD.Canvas.DrawColor = MakeColor(255, 255, 0, 255);
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y);
            HUD.Canvas.DrawText("Force " $ string(Wheels[I].ContactForce));
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y - (float(1) * YL));
            HUD.Canvas.DrawText("SR " $ string(Wheels[I].LongSlipRatio));
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y - (float(2) * YL));
            HUD.Canvas.DrawText(((("SA " $ string(Wheels[I].LatSlipAngle * 57.29578)) $ " (") $ string(Wheels[I].LatSlipAngle)) $ ")");
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y - (float(3) * YL));
            HUD.Canvas.DrawText("Torque " $ string(Wheels[I].MotorTorque));
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y - (float(4) * YL));
            HUD.Canvas.DrawText("SpinVel " $ string(Wheels[I].SpinVel));
            HUD.Canvas.DrawColor = HUD.RedColor;
            EndPoint = (WorldLoc + ((Wheels[I].LongImpulse * float(100)) * Wheels[I].LongDirection)) - (Wheels[I].WheelRadius * Z);
            ScreenEndPoint = HUD.Canvas.Project(EndPoint);
            DrawDebugLine(WorldLoc - (Wheels[I].WheelRadius * Z), EndPoint, 255, 0, 0);
            HUD.Canvas.SetPos(ScreenEndPoint.X, ScreenEndPoint.Y);
            HUD.Canvas.DrawText(string(Wheels[I].LongImpulse));
            HUD.Canvas.DrawColor = HUD.GreenColor;
            EndPoint = (WorldLoc + ((Wheels[I].LatImpulse * float(100)) * Wheels[I].LatDirection)) - (Wheels[I].WheelRadius * Z);
            ScreenEndPoint = HUD.Canvas.Project(EndPoint);
            DrawDebugLine(WorldLoc - (Wheels[I].WheelRadius * Z), EndPoint, 0, 255, 0);
            HUD.Canvas.SetPos(ScreenEndPoint.X, ScreenEndPoint.Y);
            HUD.Canvas.DrawText(string(Wheels[I].LatImpulse));
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y + YL);
            HUD.Canvas.DrawText(string(Wheels[I].LatImpulse));
            HUD.Canvas.DrawColor = MakeColor(255, 255, 255, 255);
            HUD.Draw2DLine(int(ScreenLoc.X), int(ScreenLoc.Y), int(ScreenLoc.X + GraphScale), int(ScreenLoc.Y), MakeColor(0, 0, 255, 255));
            HUD.Canvas.SetPos(ScreenLoc.X + GraphScale, ScreenLoc.Y);
            HUD.Canvas.DrawText(string(3.141593 * 0.5));
            HUD.Draw2DLine(int(ScreenLoc.X), int(ScreenLoc.Y), int(ScreenLoc.X), int(ScreenLoc.Y - GraphScale), MakeColor(0, 0, 255, 255));
            HUD.Canvas.SetPos(ScreenLoc.X, ScreenLoc.Y - GraphScale);
            HUD.Canvas.DrawText(string(SimObj.WheelLatExtremumValue));
            LastForceValue = 0;
            J = 0;
            J0x1021:

            if(float(J) <= GraphScale)
            {
                ForceValue = HermiteEval(float(J) * ((3.141593 * 0.5) / GraphScale));
                ForceValue = (ForceValue / SimObj.WheelLatExtremumValue) * GraphScale;
                HUD.Draw2DLine(int(ScreenLoc.X + float(J - 1)), int(ScreenLoc.Y - LastForceValue), int(ScreenLoc.X + float(J)), int(ScreenLoc.Y - ForceValue), MakeColor(0, 255, 0, 255));
                LastForceValue = ForceValue;
                ++ J;
                goto J0x1021;
            }
            ForceValue = HermiteEval(Abs(Wheels[I].LatSlipAngle));
            ForceValueLoc.X = ScreenLoc.X + ((Abs(Wheels[I].LatSlipAngle) / (3.141593 * 0.5)) * GraphScale);
            ForceValueLoc.Y = ScreenLoc.Y - ((ForceValue / SimObj.WheelLatExtremumValue) * GraphScale);
            HUD.Draw2DLine(int(ForceValueLoc.X - float(5)), int(ForceValueLoc.Y), int(ForceValueLoc.X + float(5)), int(ForceValueLoc.Y), MakeColor(255, 0, 0, 255));
            HUD.Draw2DLine(int(ForceValueLoc.X), int(ForceValueLoc.Y - float(5)), int(ForceValueLoc.X), int(ForceValueLoc.Y + float(5)), MakeColor(255, 0, 0, 255));
            HUD.Canvas.SetPos(ScreenLoc.X, ForceValueLoc.Y);
            HUD.Canvas.DrawText(string(ForceValue));
            HUD.Canvas.SetPos(ForceValueLoc.X, ScreenLoc.Y + YL);
            HUD.Canvas.DrawText(string(Wheels[I].LatSlipAngle));
        }
        ++ I;
        goto J0x68;
    }
    HUD.Canvas.DrawColor = SaveColor;
}

simulated function float HermiteEval(float Slip)
{
    local float LatExtremumSlip, LatExtremumValue, LatAsymptoteSlip, LatAsymptoteValue, SlipSquared, SlipCubed,
	    C0, C1, C3;

    LatExtremumSlip = SimObj.WheelLatExtremumSlip;
    LatExtremumValue = SimObj.WheelLatExtremumValue;
    LatAsymptoteSlip = SimObj.WheelLatAsymptoteSlip;
    LatAsymptoteValue = SimObj.WheelLatAsymptoteValue;
    if(Slip < LatExtremumSlip)
    {
        Slip /= LatExtremumSlip;
        SlipSquared = Slip * Slip;
        SlipCubed = SlipSquared * Slip;
        C3 = (-2 * SlipCubed) + (3 * SlipSquared);
        C1 = (SlipCubed - (2 * SlipSquared)) + Slip;
        return (C1 + C3) * LatExtremumValue;        
    }
    else
    {
        if(Slip > LatAsymptoteSlip)
        {
            return LatAsymptoteValue;            
        }
        else
        {
            Slip /= (LatAsymptoteSlip - LatExtremumSlip);
            Slip -= LatExtremumSlip;
            SlipSquared = Slip * Slip;
            SlipCubed = SlipSquared * Slip;
            C3 = (-2 * SlipCubed) + (3 * SlipSquared);
            C0 = ((2 * SlipCubed) - (3 * SlipSquared)) + 1;
            return (C0 * LatExtremumValue) + (C3 * LatAsymptoteValue);
        }
    }
}

simulated function GetSVehicleDebug(out array<string> DebugInfo)
{
    DebugInfo[DebugInfo.Length] = "----Vehicle----: ";
    DebugInfo[DebugInfo.Length] = ((("Speed: " $ string(VSize(Velocity))) $ " Unreal -- ") $ string(VSize(Velocity) * 0.0426125)) $ " MPH";
    if(Wheels.Length > 0)
    {
        DebugInfo[DebugInfo.Length] = "MotorTorque: " $ string(Wheels[0].MotorTorque);
    }
    DebugInfo[DebugInfo.Length] = "Throttle: " $ string(OutputGas);
    DebugInfo[DebugInfo.Length] = "Brake: " $ string(OutputBrake);
}

defaultproperties
{
    ChassisMass=1500
    bEnableDebugRendering=true
    bCanFlip=true
    InertiaTensorMultiplier=(X=1,Y=1,Z=1)
    StayUprightConstraintSetup=RB_StayUprightSetup'Default__SVehicle.MyStayUprightSetup'
    StayUprightConstraintInstance=RB_ConstraintInstance'Default__SVehicle.MyStayUprightConstraintInstance'
    HeavySuspensionShiftPercent=0.5
    MaxSpeed=2500
    MaxAngularVelocity=75000
    UprightLiftStrength=225
    UprightTorqueStrength=50
    UprightTime=1.5
    SquealThreshold=250
    SquealLatThreshold=250
    LatAngleVolumeMult=1
    EngineStartOffsetSecs=2
    EngineStopOffsetSecs=1
    BaseOffset=(X=0,Y=0,Z=128)
    CamDist=512
    RadialImpulseScaling=1
    begin object name=SVehicleMesh class=SkeletalMeshComponent
        bUseSingleBodyPhysics=1
        bForceDiscardRootMotion=true
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_Vehicle
        CollideActors=true
        BlockActors=true
        BlockZeroExtent=true
        BlockNonZeroExtent=true
        BlockRigidBody=true
        bNotifyRigidBodyCollision=true
        RBCollideWithChannels=(Default=true,Vehicle=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
        ScriptRigidBodyCollisionThreshold=250
    object end
    // Reference: SkeletalMeshComponent'Default__SVehicle.SVehicleMesh'
    Mesh=SVehicleMesh
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__SVehicle.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__SVehicle.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=SVehicleMesh class=SkeletalMeshComponent
        bUseSingleBodyPhysics=1
        bForceDiscardRootMotion=true
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_Vehicle
        CollideActors=true
        BlockActors=true
        BlockZeroExtent=true
        BlockNonZeroExtent=true
        BlockRigidBody=true
        bNotifyRigidBodyCollision=true
        RBCollideWithChannels=(Default=true,Vehicle=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
        ScriptRigidBodyCollisionThreshold=250
    object end
    // Reference: SkeletalMeshComponent'Default__SVehicle.SVehicleMesh'
    Components(1)=SVehicleMesh
    Physics=EPhysics.PHYS_RigidBody
    TickGroup=ETickingGroup.TG_PostAsyncWork
    bNetInitialRotation=true
    bBlocksTeleport=true
    bEdShouldSnap=true
    begin object name=SVehicleMesh class=SkeletalMeshComponent
        bUseSingleBodyPhysics=1
        bForceDiscardRootMotion=true
        ReplacementPrimitive=none
        RBChannel=ERBCollisionChannel.RBCC_Vehicle
        CollideActors=true
        BlockActors=true
        BlockZeroExtent=true
        BlockNonZeroExtent=true
        BlockRigidBody=true
        bNotifyRigidBodyCollision=true
        RBCollideWithChannels=(Default=true,Vehicle=true,GameplayPhysics=true,EffectPhysics=true,BlockingVolume=true)
        ScriptRigidBodyCollisionThreshold=250
    object end
    // Reference: SkeletalMeshComponent'Default__SVehicle.SVehicleMesh'
    CollisionComponent=SVehicleMesh
}