/*******************************************************************************
 * MobileMenuList generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MobileMenuList extends MobileMenuObject;

const NumInDragHistory = 4;

struct SelectedMenuItem
{
    var int Index;
    var float Offset;
    var bool bEndOfList;

    structdefaultproperties
    {
        Index=0
        Offset=0
        bEndOfList=false
    }
};

struct DragHistoryData
{
    var float TouchTime;
    var float TouchCoord;

    structdefaultproperties
    {
        TouchTime=0
        TouchCoord=0
    }
};

struct MenuListDragInfo
{
    var bool bIsDragging;
    var MobileMenuListItem TouchedItem;
    var SelectedMenuItem OrigSelectedItem;
    var Vector2D StartTouch;
    var float TouchTime;
    var float ScrollAmount;
    var float AbsScrollAmount;
    var DragHistoryData UpdateHistory[4];
    var int NumUpdates;
    var bool bHasSelectedChanged;

    structdefaultproperties
    {
        bIsDragging=false
        TouchedItem=none
        OrigSelectedItem=(Index=0,Offset=0,bEndOfList=false)
        StartTouch=(X=0,Y=0)
        TouchTime=0
        ScrollAmount=0
        AbsScrollAmount=0
        UpdateHistory[0]=(TouchTime=0,TouchCoord=0)
        UpdateHistory[1]=(TouchTime=0,TouchCoord=0)
        UpdateHistory[2]=(TouchTime=0,TouchCoord=0)
        UpdateHistory[3]=(TouchTime=0,TouchCoord=0)
        NumUpdates=0
        bHasSelectedChanged=false
    }
};

struct MenuListMovementInfo
{
    var bool bIsMoving;
    var SelectedMenuItem OrigSelectedItem;
    var float FullMovement;
    var float TotalTime;
    var float CurrentTime;

    structdefaultproperties
    {
        bIsMoving=false
        OrigSelectedItem=(Index=0,Offset=0,bEndOfList=false)
        FullMovement=0
        TotalTime=0
        CurrentTime=0
    }
};

/** Vertical or horizontal list supported */
var(DefaultInit) bool bIsVerticalList;
/** On short list, might want to disable all scrolling */
var(DefaultInit) bool bDisableScrolling;
/** When user stops moving, should the closest item move to the selected position */
var(DefaultInit) bool bForceSelectedToLineup;
var bool bTapToScrollToItem;
var bool bLoops;
/** Offset from Top/Left of list that determines 'selected' item - init as percentage of Width/Height depending on bIsVerticalList */
var(DefaultInit) float SelectedOffset;
var array<MobileMenuListItem> Items;
var SelectedMenuItem SelectedItem;
var MenuListDragInfo Drag;
var MenuListMovementInfo Movement;
var float Deacceleration;
var float EaseOutExp;
var IntPoint ScreenSize;
var int FirstVisible;
var int LastVisible;
var int NumShowEndOfList;
var float EndOfListSupression;

function InitMenuObject(MobilePlayerInput PlayerInput, MobileMenuScene Scene, int ScreenWidth, int ScreenHeight, bool bIsFirstInitialization)
{
    ScreenSize.X = ScreenWidth;
    ScreenSize.Y = ScreenHeight;
    super.InitMenuObject(PlayerInput, Scene, ScreenWidth, ScreenHeight, bIsFirstInitialization);
    SelectedOffset *= ((bIsVerticalList) ? Height : Width);
}

function AddItem(MobileMenuListItem Item, optional int Index)
{
    Index = -1;
    if(Index < 0)
    {
        Index = Items.Length + (Index + 1);
    }
    Items.InsertItem(Index, Item;
}

function int Num()
{
    return Items.Length;
}

function MobileMenuListItem GetSelected()
{
    local MobileMenuListItem Item;

    if((SelectedItem.Index >= 0) && SelectedItem.Index < Items.Length)
    {
        Item = Items[SelectedItem.Index];
        if((Item != none) && !Item.bIsVisible)
        {
            Item = none;
        }
        return Item;
    }
    return none;
}

function float GetAmountSelected(MobileMenuListItem Item)
{
    local MobileMenuListItem Selected;
    local float Half;

    Selected = GetSelected();
    if(Item == Selected)
    {
        Half = ((bIsVerticalList) ? Item.Height : Item.Width) * 0.5;
        return FMax(0.0001, FMin(1, 1 - (Abs(SelectedItem.Offset) / Half)));
    }
    return 0;
}

function int GetVisibleIndexOfSelected()
{
    local MobileMenuListItem Item, Selected;
    local int Index;

    Selected = GetSelected();
    Index = 0;
    foreach Items(Item,)
    {
        if(Item == Selected)
        {            
            return Index;
        }
        if(Item.bIsVisible)
        {
            ++ Index;
        }        
    }    
    return -1;
}

function int SetSelectedToVisibleIndex(int VisibleIndex)
{
    local int Index;

    Index = 0;
    J0x0B:

    if(Index < Items.Length)
    {
        if(Items[Index].bIsVisible)
        {
            if(VisibleIndex <= 0)
            {
                SelectedItem.Index = Index;
                return Index;
            }
            -- VisibleIndex;
        }
        ++ Index;
        goto J0x0B;
    }
    SelectedItem.Index = -1;
    return -1;
}

function int GetNumVisible()
{
    local int Index, Count;

    Index = 0;
    J0x0B:

    if(Index < Items.Length)
    {
        if(Items[Index].bIsVisible)
        {
            ++ Count;
        }
        ++ Index;
        goto J0x0B;
    }
    return Count;
}

function bool SetSelectedItem(int ItemIndex, optional bool bForceAll)
{
    bForceAll = false;
    if((ItemIndex >= 0) && ItemIndex < Items.Length)
    {
        if(Items[ItemIndex].bIsVisible)
        {
            SelectedItem.Index = ItemIndex;
            if(bForceAll)
            {
                Drag.OrigSelectedItem = SelectedItem;
                Movement.OrigSelectedItem = SelectedItem;
            }
            return true;
        }
    }
    return false;
}

event bool OnTouch(Engine.Interaction.ETouchType EventType, float TouchX, float TouchY, MobileMenuObject ObjectOver, float DeltaTime)
{
    local float Velocity, SwipeDelta, FinalScrollDist, CalcScrollDist, SwipeTime;

    local MobileMenuListItem Selected;
    local int Index, Index0;
    local bool bUdpateTouchItem;

    TouchX -= Left;
    TouchY -= Top;
    Drag.TouchTime += DeltaTime;
    if(EventType == 0)
    {
        Movement.bIsMoving = false;
        Drag.bIsDragging = true;
        Drag.OrigSelectedItem = SelectedItem;
        Drag.StartTouch.X = TouchX;
        Drag.StartTouch.Y = TouchY;
        Drag.ScrollAmount = 0;
        Drag.AbsScrollAmount = 0;
        Drag.bHasSelectedChanged = false;
        Drag.TouchTime = 0;
        Drag.NumUpdates = 0;
        Index = 0;
        J0x1E7:

        if(Index < 4)
        {
            Drag.UpdateHistory[Index].TouchTime = 0;
            ++ Index;
            goto J0x1E7;
        }
        Drag.TouchedItem = GetItemClickPosition(TouchX, TouchY);
        if(Drag.TouchedItem != none)
        {
            Drag.bIsDragging = !Drag.TouchedItem.OnTouch(EventType, TouchX, TouchY, DeltaTime);
        }        
    }
    else
    {
        if(!Drag.bIsDragging)
        {
            bUdpateTouchItem = true;            
        }
        else
        {
            if((EventType == 3) || EventType == 4)
            {
                bUdpateTouchItem = true;
                Drag.bIsDragging = false;
                Movement.bIsMoving = true;
                Movement.CurrentTime = 0;
                Movement.OrigSelectedItem = SelectedItem;
                if((!Drag.bHasSelectedChanged && Drag.StartTouch.X == TouchX) && Drag.StartTouch.Y == TouchY)
                {
                    Selected = GetSelected();
                    if((Drag.TouchTime > 0.05) && bTapToScrollToItem)
                    {
                        if(bIsVerticalList)
                        {
                            FinalScrollDist = TouchY - (SelectedOffset + (Selected.Height / float(2)));                            
                        }
                        else
                        {
                            FinalScrollDist = TouchX - (SelectedOffset + (Selected.Width / float(2)));
                        }
                    }                    
                }
                else
                {
                    if(Drag.NumUpdates >= 2)
                    {
                        Index = (Drag.NumUpdates - 1) % 4;
                        Index0 = (Drag.NumUpdates - Min(Drag.NumUpdates, 4)) % 4;
                        SwipeDelta = -Drag.UpdateHistory[Index].TouchCoord - Drag.UpdateHistory[Index0].TouchCoord;
                        SwipeTime = Drag.UpdateHistory[Index].TouchTime - Drag.UpdateHistory[Index0].TouchTime;
                        Velocity = ((SwipeTime > float(0)) ? SwipeDelta / SwipeTime : 0);
                        FinalScrollDist = Square(Velocity) / (2 * Deacceleration);
                    }
                }
                if(bDisableScrolling)
                {
                    FinalScrollDist = 0;
                }
                if(SwipeDelta < float(0))
                {
                    CalcScrollDist = CalculateSelectedItem(SelectedItem, -FinalScrollDist, true);                    
                }
                else
                {
                    CalcScrollDist = CalculateSelectedItem(SelectedItem, FinalScrollDist, true);
                }
                if(!bForceSelectedToLineup && !SelectedItem.bEndOfList)
                {
                    if(SwipeDelta < float(0))
                    {
                        CalcScrollDist = -FinalScrollDist;                        
                    }
                    else
                    {
                        CalcScrollDist = FinalScrollDist;
                    }
                }
                SelectedItem = Movement.OrigSelectedItem;
                Movement.TotalTime = Sqrt(Abs(CalcScrollDist) / (2 * Deacceleration));
                Movement.FullMovement = CalcScrollDist;                
            }
            else
            {
                Drag.UpdateHistory[Drag.NumUpdates % 4].TouchTime = Drag.TouchTime;
                Drag.UpdateHistory[Drag.NumUpdates % 4].TouchCoord = ((bIsVerticalList) ? TouchY : TouchX);
                ++ Drag.NumUpdates;
                if(Drag.OrigSelectedItem.Index != SelectedItem.Index)
                {
                    Drag.bHasSelectedChanged = true;
                }
                Drag.ScrollAmount = ((bIsVerticalList) ? Drag.StartTouch.Y - TouchY : Drag.StartTouch.X - TouchX);
                Index = (Drag.NumUpdates - 1) % 4;
                Index0 = (Drag.NumUpdates - Min(Drag.NumUpdates, 4)) % 4;
                SwipeDelta = Abs(Drag.UpdateHistory[Index].TouchCoord - Drag.UpdateHistory[Index0].TouchCoord);
                if(bDisableScrolling)
                {
                    Drag.ScrollAmount = 0;
                    SwipeDelta = 0;
                }
                Drag.AbsScrollAmount += SwipeDelta;
            }
        }
    }
    if(bUdpateTouchItem)
    {
        if(Drag.TouchedItem != none)
        {
            if(Drag.TouchedItem == (GetItemClickPosition(TouchX, TouchY)))
            {
                Drag.TouchedItem.OnTouch(EventType, TouchX, TouchY, DeltaTime);                
            }
            else
            {
                Drag.TouchedItem.OnTouch(EventType, -1, -1, DeltaTime);
            }
        }
    }
    return true;
}

function MobileMenuListItem GetItemClickPosition(out float MouseX, out float MouseY)
{
    local int ScrollAmount, CurIndex, ScrollSize;
    local MobileMenuListItem Item;

    ScrollAmount = int(((bIsVerticalList) ? MouseY : MouseX));
    ScrollAmount -= int(SelectedOffset);
    CurIndex = int(FMax(0, float(SelectedItem.Index)));
    if(CurIndex >= Items.Length)
    {
        return none;
    }
    Item = Items[CurIndex];
    ScrollSize = ItemScrollSize(Item);
    J0xC8:

    if(ScrollAmount < 0)
    {
        if(CurIndex > 0)
        {
            -- CurIndex;            
        }
        else
        {
            if(bLoops)
            {
                CurIndex = Items.Length - 1;                
            }
            else
            {
                goto J0x191;
            }
        }
        Item = Items[CurIndex];
        if(Item.bIsVisible)
        {
            ScrollSize = ItemScrollSize(Item);
            ScrollAmount += ScrollSize;
        }
        goto J0xC8;
    }
    J0x191:

    if(ScrollAmount > ScrollSize)
    {
        if(CurIndex < (Items.Length - 1))
        {
            ++ CurIndex;            
        }
        else
        {
            if(bLoops)
            {
                CurIndex = 0;                
            }
            else
            {
                goto J0x262;
            }
        }
        Item = Items[CurIndex];
        if(Item.bIsVisible)
        {
            ScrollAmount -= ScrollSize;
            ScrollSize = ItemScrollSize(Item);
        }
        goto J0x191;
    }
    J0x262:

    if(bIsVerticalList)
    {
        MouseY = float(ScrollAmount);
        if((ScrollAmount < 0) || float(ScrollAmount) > Item.Height)
        {
            Item = none;
        }        
    }
    else
    {
        MouseX = float(ScrollAmount);
        if((ScrollAmount < 0) || float(ScrollAmount) > Item.Width)
        {
            Item = none;
        }
    }
    return Item;
}

function float CalculateSelectedItem(out SelectedMenuItem Selected, float ScrollAmount, bool bForceZeroAdjustment)
{
    local float AdjustValue, ScrollSize, Scrolled, HalfScroll;
    local int CurIndex;
    local MobileMenuListItem Item;

    AdjustValue = Selected.Offset;
    Scrolled = AdjustValue;
    ScrollAmount -= AdjustValue;
    CurIndex = int(FMax(0, float(Selected.Index)));
    if(CurIndex >= Items.Length)
    {
        return 0;
    }
    Item = Items[CurIndex];
    ScrollSize = float(ItemScrollSize(Item));
    Selected.bEndOfList = false;
    J0xF7:

    if(ScrollAmount < float(0))
    {
        if(CurIndex > 0)
        {
            -- CurIndex;            
        }
        else
        {
            if(bLoops)
            {
                CurIndex = Items.Length - 1;                
            }
            else
            {
                ScrollAmount *= EndOfListSupression;
                Selected.bEndOfList = true;
                goto J0x231;
            }
        }
        Item = Items[CurIndex];
        if(Item.bIsVisible)
        {
            ScrollSize = float(ItemScrollSize(Item));
            ScrollAmount += ScrollSize;
            Scrolled -= ScrollSize;
            Selected.Index = CurIndex;
        }
        goto J0xF7;
    }
    J0x231:

    HalfScroll = ScrollSize / float(2);
    J0x24A:

    if(ScrollAmount > HalfScroll)
    {
        if(CurIndex < (Items.Length - (NumShowEndOfList + 1)))
        {
            ++ CurIndex;            
        }
        else
        {
            if(bLoops)
            {
                CurIndex = 0;                
            }
            else
            {
                ScrollAmount -= HalfScroll;
                ScrollAmount *= EndOfListSupression;
                ScrollAmount += HalfScroll;
                Selected.bEndOfList = true;
                goto J0x3BD;
            }
        }
        Item = Items[CurIndex];
        if(Item.bIsVisible)
        {
            ScrollAmount -= ScrollSize;
            Scrolled += ScrollSize;
            Selected.Index = CurIndex;
            ScrollSize = float(ItemScrollSize(Item));
        }
        goto J0x24A;
    }
    J0x3BD:

    if(bForceZeroAdjustment)
    {
        Selected.Offset = 0;        
    }
    else
    {
        Selected.Offset = -ScrollAmount;
        Scrolled -= ScrollAmount;
    }
    return Scrolled;
}

function UpdateScroll(float DeltaTime)
{
    local float ScrollAmount;

    if(Drag.bIsDragging)
    {
        SelectedItem = Drag.OrigSelectedItem;
        ScrollAmount = Drag.ScrollAmount;        
    }
    else
    {
        if(Movement.bIsMoving)
        {
            SelectedItem = Movement.OrigSelectedItem;
            Movement.CurrentTime += DeltaTime;
            if(Movement.CurrentTime < Movement.TotalTime)
            {
                ScrollAmount = FInterpEaseOut(0, Movement.FullMovement, Movement.CurrentTime / Movement.TotalTime, EaseOutExp);                
            }
            else
            {
                ScrollAmount = Movement.FullMovement;
                Movement.bIsMoving = false;
            }            
        }
        else
        {
            return;
        }
    }
    CalculateSelectedItem(SelectedItem, ScrollAmount, false);
}

function RenderObject(Canvas Canvas, float DeltaTime)
{
    local MobileMenuListItem Item;
    local float OrgX, OrgY;
    local int VpEnd, CurIndex, first, Last, SelectedIdx, NumItems,
	    RealIndex;

    local Vector2D VpPos, VpSize;

    NumItems = Items.Length;
    if(NumItems == 0)
    {
        return;
    }
    UpdateScroll(DeltaTime);
    VpSize.X = Width;
    VpSize.Y = Height;
    SelectedIdx = int(FMax(0, float(SelectedItem.Index)));
    if(bLoops)
    {
        SelectedIdx += NumItems;
    }
    first = SelectedIdx;
    if(bIsVerticalList)
    {
        VpPos.X = Left;
        VpPos.Y = (Top + SelectedOffset) + SelectedItem.Offset;
        VpEnd = int(Top + Height);
        J0x18B:

        if((first > 0) && VpPos.Y > Top)
        {
            -- first;
            Item = Items[first % NumItems];
            if(Item.bIsVisible)
            {
                VpPos.Y -= Item.Height;
            }
            goto J0x18B;
        }        
    }
    else
    {
        VpPos.X = (Left + SelectedOffset) + SelectedItem.Offset;
        VpPos.Y = Top;
        VpEnd = int(Left + Width);
        J0x2F2:

        if((first > 0) && VpPos.X > Left)
        {
            -- first;
            Item = Items[first % NumItems];
            if(Item.bIsVisible)
            {
                VpPos.X -= Item.Width;
            }
            goto J0x2F2;
        }
    }
    J0x3C1:

    if((first + 1) < NumItems)
    {
        Item = Items[first];
        if(Item.bIsVisible)
        {
            goto J0x42B;
        }
        ++ first;
        goto J0x3C1;
    }
    J0x42B:

    Last = first;
    CurIndex = 0;
    J0x449:

    if(CurIndex < NumItems)
    {
        RealIndex = ((bLoops) ? (first + CurIndex) % NumItems : first + CurIndex);
        if(RealIndex >= NumItems)
        {
            goto J0x729;
        }
        Item = Items[RealIndex];
        if(Item.bIsVisible)
        {
            Last = first + CurIndex;
            if(bIsVerticalList)
            {
                VpSize.Y = Item.Height;
                Item.VpPos = VpPos;
                Item.VpSize = VpSize;
                VpPos.Y += VpSize.Y;
                if(VpPos.Y >= float(VpEnd))
                {
                    goto J0x729;
                }                
            }
            else
            {
                VpSize.X = Item.Width;
                Item.VpPos = VpPos;
                Item.VpSize = VpSize;
                VpPos.X += VpSize.X;
                if(VpPos.X >= float(VpEnd))
                {
                    goto J0x729;
                }
            }
        }
        ++ CurIndex;
        goto J0x449;
    }
    J0x729:

    OrgX = Canvas.OrgX;
    OrgY = Canvas.OrgY;
    CurIndex = first;
    J0x78C:

    if(CurIndex < SelectedIdx)
    {
        Item = Items[CurIndex % NumItems];
        if(Item.bIsVisible)
        {
            Canvas.SetOrigin(Item.VpPos.X, Item.VpPos.Y);
            Item.RenderItem(self, Canvas, DeltaTime);
        }
        ++ CurIndex;
        goto J0x78C;
    }
    CurIndex = Last;
    J0x8C1:

    if(CurIndex >= SelectedIdx)
    {
        Item = Items[CurIndex % NumItems];
        if(Item.bIsVisible)
        {
            Canvas.SetOrigin(Item.VpPos.X, Item.VpPos.Y);
            Item.RenderItem(self, Canvas, DeltaTime);
        }
        -- CurIndex;
        goto J0x8C1;
    }
    FirstVisible = first;
    LastVisible = Last;
    Canvas.OrgX = OrgX;
    Canvas.OrgY = OrgY;
}

function int ItemScrollSize(MobileMenuListItem Item)
{
    return int(((bIsVerticalList) ? Item.Height : Item.Width));
}

defaultproperties
{
    bIsVerticalList=true
    bForceSelectedToLineup=true
    bTapToScrollToItem=true
    Deacceleration=1500
    EaseOutExp=4
    EndOfListSupression=0.4
    bIsActive=true
}