/*******************************************************************************
 * GameThirdPersonCameraMode generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameThirdPersonCameraMode extends Object
    native(Camera)
    config(Camera);

enum ECameraViewportTypes
{
    CVT_16to9_Full,
    CVT_16to9_VertSplit,
    CVT_16to9_HorizSplit,
    CVT_4to3_Full,
    CVT_4to3_HorizSplit,
    CVT_4to3_VertSplit,
    CVT_MAX
};

struct native ViewOffsetData
{
    /** View point offset for high player view pitch */
    var() Vector OffsetHigh;
    /** View point offset for medium (horizon) player view pitch */
    var() Vector OffsetMid;
    /** View point offset for low player view pitch */
    var() Vector OffsetLow;

    structdefaultproperties
    {
        OffsetHigh=(X=0,Y=0,Z=0)
        OffsetMid=(X=0,Y=0,Z=0)
        OffsetLow=(X=0,Y=0,Z=0)
    }
};

var transient GameThirdPersonCamera ThirdPersonCam;
/** FOV for camera to use */
var() const config float FOVAngle;
/** Blend Time to and from this view mode */
var() float BlendTime;
/**  
 *True if, while in this mode, the camera should be tied to the viewtarget rotation.
 * This is typical for the normal walking-around camera, since the controls rotate the controller
 * and the camera follows.  This can be false if you want free control of the camera, independent
 * of the viewtarget's orient -- we use this for vehicles.  Note that if this is false,
 */
var() protected const bool bLockedToViewTarget;
/**  
 *True if, while in this mode, looking around should be directly mapped to stick position
 * as opposed to relative to previous camera positions.
 */
var() protected const bool bDirectLook;
/**  
 *True if, while in this mode, the camera should interpolate towards a following position
 * in relation to the target and it's motion.  Ignored if bLockedToViewTarget is set to true.
 */
var() protected const bool bFollowTarget;
/** True means camera will attempt to smoothly interpolate to its new position.  False will snap it to it's new position. */
var() bool bInterpLocation;
/**  
 *This is a special case of origin location interpolation. If true, interpolaton will be done on each axis independently, with the specified speeds.
 *  Ignored if bInterpLocation is false.
 */
var() protected bool bUsePerAxisOriginLocInterp;
/** True means camera will attempt to smoothly interpolate to its new rotation.  False will snap it to it's new rotation. */
var() bool bInterpRotation;
/** Whether rotation interpolation happens at constant speed or not */
var() bool bRotInterpSpeedConstant;
/** True to turn do predictive camera avoidance, false otherwise */
var() const bool bDoPredictiveAvoidance;
/** TRUE to do a raytrace from camera base loc to worst loc, just to be sure it's cool.  False to skip it */
var() const bool bValidateWorstLoc;
/** If TRUE, all camera collision is disabled */
var() bool bSkipCameraCollision;
/** TRUE to smooth the interp between high/mid/low, false to blend linearly between high <-> mid <-> low */
var() protected const bool bSmoothViewOffsetPitchChanges;
/** whether delta or actual view offset should be applied to the camera location */
var() bool bApplyDeltaViewOffset;
/** Optional parameters for DOF adjustments. */
var(DepthOfField) protected const bool bAdjustDOF;
var protected transient bool bDOFUpdated;
var bool bNoFOVPostProcess;
/** If TRUE ViewOffset will only be interpolated between camera mode transitions, and then be instantaneous */
var() bool bInterpViewOffsetOnlyForCamTransition;
/**  
 ** How fast the camera should track to follow behind the viewtarget.  0.f for no following.
 * * Only used if bLockedToViewTarget is FALSE
 */
var() protected const float FollowingInterpSpeed_Pitch;
var() protected const float FollowingInterpSpeed_Yaw;
var() protected const float FollowingInterpSpeed_Roll;
/** Actual following interp speed gets scaled from FollowingInterpSpeed to zero between velocities of this value and zero. */
var() protected const float FollowingCameraVelThreshold;
/** Controls interpolation speed of location for camera origin.  Ignored if bInterpLocation is false. */
var() protected float OriginLocInterpSpeed;
var() protected Vector PerAxisOriginLocInterpSpeed;
/** Controls interpolation speed of rotation for the camera origin.  Ignored if bInterpRotation is false. */
var() protected float OriginRotInterpSpeed;
/** Adjustment vector to apply to camera view offset when target is strafing to the left */
var() protected const Vector StrafeLeftAdjustment;
/** Adjustment vector to apply to camera view offset when target is strafing to the right */
var() protected const Vector StrafeRightAdjustment;
/** Velocity at (and above) which the full adjustment should be applied. */
var() protected const float StrafeOffsetScalingThreshold;
/** Interpolation speed for interpolating to a NONZERO strafe offsets.  Higher is faster/tighter interpolation. */
var() protected const float StrafeOffsetInterpSpeedIn;
/** Interpolation speed for interpolating to a ZERO strafe offset.  Higher is faster/tighter interpolation. */
var() protected const float StrafeOffsetInterpSpeedOut;
var protected transient Vector LastStrafeOffset;
/** Adjustment vector to apply to camera view offset when target is moving forward */
var() protected const Vector RunFwdAdjustment;
/** Adjustment vector to apply to camera view offset when target is moving backward */
var() protected const Vector RunBackAdjustment;
/** Velocity at (and above) which the full adjustment should be applied. */
var() protected const float RunOffsetScalingThreshold;
/** Interpolation speed for interpolating to a NONZERO offset.  Higher is faster/tighter interpolation. */
var() protected const float RunOffsetInterpSpeedIn;
/** Interpolation speed for interpolating to a ZERO offset.  Higher is faster/tighter interpolation. */
var() protected const float RunOffsetInterpSpeedOut;
var protected transient Vector LastRunOffset;
/**  
 *An offset from the location of the viewtarget, in the viewtarget's local space.
 *  Used to calculate the "worst case" camera location, which is where the camera should retreat to
 *  if tightly obstructed.
 */
var() protected Vector WorstLocOffset;
/** Offset, in the camera target's local space, from the camera target to the camera's origin. */
var() protected const Vector TargetRelativeCameraOriginOffset;
/** contains offsets from camera target to camera loc */
var() protected const ViewOffsetData ViewOffset;
/** viewoffset adjustment vectors for each possible viewport type, so the game looks close to the same in each */
var() protected const ViewOffsetData ViewOffset_ViewportAdjustments[ECameraViewportTypes];
var(DepthOfField) protected const float DOF_FalloffExponent;
var(DepthOfField) protected const float DOF_BlurKernelSize;
var(DepthOfField) protected const float DOF_FocusInnerRadius;
var(DepthOfField) protected const float DOF_MaxNearBlurAmount;
var(DepthOfField) protected const float DOF_MaxFarBlurAmount;
var protected transient float LastDOFRadius;
var protected transient float LastDOFDistance;
var(DepthOfField) protected const float DOFDistanceInterpSpeed;
var(DepthOfField) protected const Vector DOFTraceExtent;
/** Maps out how the DOF inner radius changes over distance. */
var(DepthOfField) protected const float DOF_RadiusFalloff;
var(DepthOfField) protected const Vector2D DOF_RadiusRange;
var(DepthOfField) protected const Vector2D DOF_RadiusDistRange;
var float ViewOffsetInterp;
/** We optionally interpolate the results of AdjustViewOffset() to prevent pops when a cameramode changes its adjustment suddenly. */
var() protected float OffsetAdjustmentInterpSpeed;
var protected transient GameThirdPersonCameraMode.ECameraViewportTypes CurrentViewportType;

function Init();

function OnBecomeActive(Pawn TargetPawn, GameThirdPersonCameraMode PrevMode)
{
    if(BlendTime > 0)
    {
        ViewOffsetInterp = 1 / BlendTime;        
    }
    else
    {
        ViewOffsetInterp = 0;
    }
}

function OnBecomeInActive(Pawn TargetPawn, GameThirdPersonCameraMode NewMode);

event Vector AdjustViewOffset(Pawn P, Vector Offset)
{
    return Offset;
}

function float GetDesiredFOV(Pawn ViewedPawn)
{
    return FOVAngle;
}

simulated event Vector GetCameraWorstCaseLoc(Pawn TargetPawn, TViewTarget CurrentViewTarget)
{
    return TargetPawn.Location + (WorstLocOffset >> TargetPawn.Rotation);
}

simulated function bool SetFocusPoint(Pawn ViewedPawn)
{
    return false;
}

simulated function ProcessViewRotation(float DeltaTime, Actor ViewTarget, out Rotator out_ViewRotation, out Rotator out_DeltaRot);

protected simulated function Vector GetDOFFocusLoc(Actor TraceOwner, Vector StartTrace, Vector EndTrace)
{
    return DOFTrace(TraceOwner, StartTrace, EndTrace);
}

protected simulated function Vector DOFTrace(Actor TraceOwner, Vector StartTrace, Vector EndTrace)
{
    local Vector HitLocation, HitNormal;
    local Actor HitActor;

    HitActor = TraceOwner.Trace(HitLocation, HitNormal, EndTrace, StartTrace, true, DOFTraceExtent,, TraceOwner.1);
    if(HitActor == none)
    {
        HitLocation = EndTrace;
    }
    if(HitActor != none)
    {
        if(!HitActor.bBlockActors && HitActor.IsA('Trigger') || HitActor.IsA('TriggerVolume'))
        {
            HitActor.bProjTarget = false;
            HitLocation = DOFTrace(TraceOwner, HitLocation, EndTrace);
            HitActor.bProjTarget = true;
        }
    }
    return HitLocation;
}

simulated function UpdatePostProcess(const out TViewTarget VT, float DeltaTime)
{
    local Vector FocusLoc, StartTrace, EndTrace, CamDir;
    local float FocusDist, SubjectDist, Pct;

    bDOFUpdated = false;
    if(bAdjustDOF)
    {
        CamDir = vector(VT.POV.Rotation);
        StartTrace = VT.POV.Location + (CamDir * float(10));
        EndTrace = StartTrace + (CamDir * float(50000));
        FocusLoc = GetDOFFocusLoc(VT.Target, StartTrace, EndTrace);
        SubjectDist = VSize(FocusLoc - StartTrace);
        if(!ThirdPersonCam.bResetCameraInterpolation)
        {
            FocusDist = FInterpTo(LastDOFDistance, SubjectDist, DeltaTime, DOFDistanceInterpSpeed);            
        }
        else
        {
            FocusDist = SubjectDist;
        }
        LastDOFDistance = FocusDist;
        Pct = GetRangePctByValue(DOF_RadiusDistRange, FocusDist);
        LastDOFRadius = GetRangeValueByPct(DOF_RadiusRange, FClamp(Pct, 0, 1) ** DOF_RadiusFalloff);
        bDOFUpdated = true;
    }
}

simulated function ModifyPostProcessSettings(out PostProcessSettings PP)
{
    if(bDOFUpdated)
    {
        PP.bEnableDOF = true;
        PP.LegacySettings.DOF_FalloffExponent = DOF_FalloffExponent;
        PP.LegacySettings.DOF_BlurKernelSize = DOF_BlurKernelSize;
        PP.LegacySettings.DOF_MaxNearBlurAmount = DOF_MaxNearBlurAmount;
        PP.LegacySettings.DOF_MaxFarBlurAmount = DOF_MaxFarBlurAmount;
        PP.LegacySettings.DOF_FocusType = 0;
        PP.LegacySettings.DOF_FocusInnerRadius = DOF_FocusInnerRadius;
        PP.LegacySettings.DOF_FocusDistance = LastDOFDistance;
        PP.LegacySettings.DOF_FocusInnerRadius = LastDOFRadius;
        bDOFUpdated = false;
    }
}

// Export UGameThirdPersonCameraMode::execSetViewOffset(FFrame&, void* const)
native final function SetViewOffset(const out ViewOffsetData NewViewOffset);

defaultproperties
{
    BlendTime=0.67
    bLockedToViewTarget=true
    bInterpLocation=true
    bDoPredictiveAvoidance=true
    bValidateWorstLoc=true
    bInterpViewOffsetOnlyForCamTransition=true
    OriginLocInterpSpeed=8
    StrafeOffsetInterpSpeedIn=12
    StrafeOffsetInterpSpeedOut=20
    RunOffsetInterpSpeedIn=6
    RunOffsetInterpSpeedOut=12
    WorstLocOffset=(X=-8,Y=1,Z=90)
    DOF_FalloffExponent=1
    DOF_BlurKernelSize=3
    DOF_MaxNearBlurAmount=0.6
    DOF_MaxFarBlurAmount=1
    DOFDistanceInterpSpeed=10
    DOF_RadiusFalloff=1
    DOF_RadiusRange=(X=2500,Y=60000)
    DOF_RadiusDistRange=(X=1000,Y=50000)
    OffsetAdjustmentInterpSpeed=12
}