/*******************************************************************************
 * GameAICmd_Hover_MoveToGoal generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameAICmd_Hover_MoveToGoal extends GameAICommand within GameAIController;

var transient Actor Path;
var transient Actor Find;
var transient Actor Goal;
var float Radius;
var transient bool bWasFiring;
var float DesiredHoverHeight;
var transient float CurrentHoverHeight;
var float SubGoalReachDist;
var float GoalDistance;
var transient Vector MoveVectDest;
var transient ReachSpec CurrentSpec;

static function bool MoveToGoal(GameAIController AI, Actor InGoal, float InGoalDistance, float InHoverHeight)
{
    local GameAICmd_Hover_MoveToGoal Cmd;

    if(((AI != none) && AI.Pawn != none) && AI.Pawn.bCanFly)
    {
        Cmd = new (AI) Class'GameAICmd_Hover_MoveToGoal';
        if(Cmd != none)
        {
            Cmd.GoalDistance = InGoalDistance;
            Cmd.Goal = InGoal;
            Cmd.DesiredHoverHeight = InHoverHeight;
            Cmd.CurrentHoverHeight = InHoverHeight;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    GotoState('Moving');
}

function bool HandlePathObstruction(Actor BlockedBy)
{
    Outer.MoveTimer = -1;
    GotoState('MoveDown');
    return false;
}

function bool IsEnemyBasedOnInterpActor(Pawn InEnemy)
{
    return false;
}

state MoveDown extends DebugState
{
    function Vector GetMoveDest()
    {
        local float Height, RadRad;
        local NavigationPoint PtForHeight;
        local Vector Dest, HitLocation, HitNormal;
        local Actor HitActor;

        if(Outer.Pawn.Anchor != none)
        {
            PtForHeight = Outer.Pawn.Anchor;            
        }
        else
        {
            if((Outer.RouteCache.Length > 0) && Outer.RouteCache[0] != none)
            {
                PtForHeight = Outer.RouteCache[0];
            }
        }
        if(PtForHeight != none)
        {
            PtForHeight.GetBoundingCylinder(RadRad, Height);
            CurrentHoverHeight = float(Max(0, int(Height - (Outer.Pawn.GetCollisionHeight() * 0.5))));
            Dest = PtForHeight.Location;
            Dest.Z = PtForHeight.Location.Z + CurrentHoverHeight;            
        }
        else
        {
            HitActor = Outer.Trace(HitLocation, HitNormal, Outer.Pawn.Location + vect(0, 0, -4096), Outer.Pawn.Location);
            if(HitActor != none)
            {
                Dest = HitLocation;
                Dest.Z += (Outer.Pawn.GetCollisionHeight() * 1.5);                
            }
            else
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal(string(GetFuncName()) @ "Could not find good hover height!");
                }
                Dest = Outer.Pawn.Location;
            }
        }
        return Dest;
    }
Begin:

    Outer.MoveTo(GetMoveDest());
    Outer.Sleep(1);
    GotoState('Moving');
    stop;                
}

state Moving extends DebugState
{
    final function bool ReachedDest(Actor Dest)
    {
        local float latDistSq, VertDist;

        latDistSq = VSizeSq2D(Outer.Pawn.Location - Dest.Location);
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("LatDist:" @ string(Sqrt(latDistSq)));
        }
        if(latDistSq < (SubGoalReachDist * SubGoalReachDist))
        {
            VertDist = Abs(Outer.Pawn.Location.Z - Dest.Location.Z);
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal("VertDist:" @ string(VertDist));
            }
            if(VertDist < float(Max(int(SubGoalReachDist), int(CurrentHoverHeight + (Outer.Pawn.GetCollisionHeight() * float(2))))))
            {
                return true;
            }
        }
        return false;
    }

    protected final function bool PopNextNode(out Vector Dest)
    {
        J0x00:
        if((Outer.RouteCache.Length > 0) && Outer.RouteCache[0] != none)
        {
            if(ReachedDest(Outer.RouteCache[0]))
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal("Reached route cache 0:" @ string(Outer.RouteCache[0]));
                }
                Outer.Pawn.SetAnchor(Outer.RouteCache[0]);
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal("Remove from route:" @ string(Outer.RouteCache[0]), 'Move');
                }
                Outer.RouteCache_RemoveIndex(0);
                CurrentHoverHeight = DesiredHoverHeight;                
            }
            else
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal("Did NOT reach route cache 0:" @ string(Outer.RouteCache[0]));
                }
                goto J0x2E0;
            }
            goto J0x00;
        }
        J0x2E0:

        if(Outer.RouteCache.Length < 1)
        {
            return false;
        }
        CurrentSpec = Outer.Pawn.Anchor.GetReachSpecTo(Outer.RouteCache[0]);
        Dest = Outer.RouteCache[0].Location;
        return true;
    }
Begin:

    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("BEGIN TAG" @ string(GetStateName()));
    }
    Find = Goal;
    Radius = Outer.Pawn.GetCollisionRadius() + Outer.Enemy.GetCollisionRadius();
    if((IsEnemyBasedOnInterpActor(Outer.Enemy)) == true)
    {
        Find = Outer.Enemy.Base;
        Radius = 0;
    }
    Radius = FMax(Radius, GoalDistance);
    if(Outer.ActorReachable(Find))
    {
        MoveVectDest = Find.Location;
        MoveVectDest.Z += CurrentHoverHeight;
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Moving directly to " $ string(Find));
        }
        Outer.MoveTo(MoveVectDest, Outer.Enemy);        
    }
    GotoState('DelaySuccess');
    stop;        
}

defaultproperties
{
    SubGoalReachDist=768
}