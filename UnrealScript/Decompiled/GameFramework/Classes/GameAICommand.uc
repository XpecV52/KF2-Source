/*******************************************************************************
 * GameAICommand generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameAICommand extends AICommandBase within GameAIController
    abstract
    native;

/** Current child node executing on top of this command */
var() const editinline transient GameAICommand ChildCommand;
/** Exiting status of the last child command to execute */
var() const transient name ChildStatus;
/** Extra reference to the AI this command is being used by */
var() transient GameAIController GameAIOwner;
/** Exiting status of this command */
var() transient name Status;
var bool bAllowNewSameClassInstance;
var bool bReplaceActiveSameClassInstance;
var private transient bool bAborted;
var bool bIgnoreNotifies;
var bool bIgnoreStepAside;
var private transient bool bPendingPop;
var bool bDisableSteering;
var string HistoryString;

static function bool InitCommandUserActor(GameAIController AI, Actor UserActor)
{
    return InitCommand(AI);
}

static function bool InitCommand(GameAIController AI)
{
    local GameAICommand Cmd;

    if(AI != none)
    {
        Cmd = new (AI) default.Class;
        if(Cmd != none)
        {
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

final event InternalPrePushed(GameAIController AI)
{
    GameAIOwner = AI;
    PrePushed(AI);
}

final event InternalPushed()
{
    GotoState('Auto');
    Pushed();
}

event InternalPopped()
{
    Popped();
    GameAIOwner = none;
    PostPopped();
}

final event InternalPaused(GameAICommand NewCommand)
{
    Paused(NewCommand);
}

final event InternalResumed(name OldCommandName)
{
    Resumed(OldCommandName);
}

final event InternalTick(float DeltaTime)
{
    Tick(DeltaTime);
}

// Export UGameAICommand::execShouldIgnoreNotifies(FFrame&, void* const)
native final function bool ShouldIgnoreNotifies();

function Tick(float DeltaTime);

function bool AllowTransitionTo(class<GameAICommand> AttemptCommand)
{
    return (ChildCommand == none) || ChildCommand.AllowTransitionTo(AttemptCommand);
}

function bool AllowStateTransitionTo(name StateName)
{
    return (ChildCommand == none) || ChildCommand.AllowStateTransitionTo(StateName);
}

function PrePushed(GameAIController AI);

function PostPopped();

function Pushed()
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("COMMAND PUSHED:" @ string(self), 'GameAICommand');
    }
}

function Popped()
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((("COMMAND POPPED:" @ string(self)) @ "with") @ string(Status), 'GameAICommand');
    }
}

function Paused(GameAICommand NewCommand)
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((("COMMAND PAUSED:" @ string(self)) @ "by") @ string(NewCommand), 'GameAICommand');
    }
}

function Resumed(name OldCommandName)
{
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((((("COMMAND RESUMED:" @ string(self)) @ "from") @ string(OldCommandName)) @ "with") @ string(ChildStatus), 'GameAICommand');
    }
}

event string GetDumpString()
{
    return string(self);
}

event DrawDebug(HUD H, name Category);

function GetDebugOverheadText(PlayerController PC, out array<string> OutText);

event string GetDebugVerboseText();

function NotifyNeedRepath();

function bool MoveUnreachable(Vector AttemptedDest, Actor AttemptedTarget);

function bool HandlePathObstruction(Actor BlockedBy)
{
    if(ChildCommand != none)
    {
        return ChildCommand.HandlePathObstruction(BlockedBy);
    }
    return false;
}

state DebugState
{
    function BeginState(name PreviousStateName)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("BEGINSTATE" @ string(PreviousStateName), 'State');
        }
    }

    function EndState(name NextStateName)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("ENDSTATE" @ string(NextStateName), 'State');
        }
    }

    function PushedState()
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("PUSHED", 'State');
        }
    }

    function PoppedState()
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("POPPED", 'State');
        }
    }

    function ContinuedState()
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("CONTINUED", 'State');
        }
    }

    function PausedState()
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("PAUSED", 'State');
        }
    }
    stop;    
}

state DelayFailure extends DebugState
{Begin:

    Outer.Sleep(0.5);
    Status = 'Failure';
    Outer.PopCommand(self);
    stop;                
}

state DelaySuccess extends DebugState
{Begin:

    Outer.Sleep(0.1);
    Status = 'Success';
    Outer.PopCommand(self);
    stop;                
}

defaultproperties
{
    HistoryString="[I]"
}