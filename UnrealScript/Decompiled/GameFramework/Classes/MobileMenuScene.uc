/*******************************************************************************
 * MobileMenuScene generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MobileMenuScene extends Object
    native;

var(UI) string MenuName;
var(UI) export editinline array<export editinline MobileMenuObject> MenuObjects;
/** Allows for a single font for all buttons in a scene */
var(UI) Font SceneCaptionFont;
/** A reference to the input owner */
var(UI) MobilePlayerInput InputOwner;
var(UI) bool bSceneDoesNotRequireInput;
var(Options) bool bRelativeLeft;
var(Options) bool bRelativeTop;
var(Options) bool bRelativeWidth;
var(Options) bool bRelativeHeight;
var(Options) bool bApplyGlobalScaleLeft;
var(Options) bool bApplyGlobalScaleTop;
var(Options) bool bApplyGlobalScaleWidth;
var(Options) bool bApplyGlobalScaleHeight;
/** Which touchpad this menu will respond to */
var(UI) byte TouchpadIndex;
/** Positions and sizing */
var(Positions) float Left;
var(Positions) float Top;
var(Positions) float Width;
var(Positions) float Height;
var float InitialLeft;
var float InitialTop;
var float InitialWidth;
var float InitialHeight;
/** This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones */
var(Options) float AuthoredGlobalScale;
/** The general opacity of the scene */
var(Options) float Opacity;
/** Holds a reference to the sound to play when a touch occurs in the mobile menu system */
var(Sounds) SoundCue UITouchSound;
/** Holds a reference to the sound to play when a touch occurs in the mobile menu system */
var(Sounds) SoundCue UIUnTouchSound;

// Export UMobileMenuScene::execGetGlobalScaleX(FFrame&, void* const)
native static final function float GetGlobalScaleX();

// Export UMobileMenuScene::execGetGlobalScaleY(FFrame&, void* const)
native static final function float GetGlobalScaleY();

event InitMenuScene(MobilePlayerInput PlayerInput, int ScreenWidth, int ScreenHeight, bool bIsFirstInitialization)
{
    local int I, X, Y, W, H;

    SceneCaptionFont = GetSceneFont();
    InputOwner = PlayerInput;
    if(bIsFirstInitialization)
    {
        InitialTop = Top;
        InitialLeft = Left;
        InitialWidth = Width;
        InitialHeight = Height;        
    }
    else
    {
        Top = InitialTop;
        Left = InitialLeft;
        Width = InitialWidth;
        Height = InitialHeight;
    }
    X = int(((bRelativeLeft) ? float(ScreenWidth) * Left : Left));
    Y = int(((bRelativeTop) ? float(ScreenHeight) * Top : Top));
    W = int(((bRelativeWidth) ? float(ScreenWidth) * Width : Width));
    H = int(((bRelativeHeight) ? float(ScreenHeight) * Height : Height));
    if(bApplyGlobalScaleLeft)
    {
        X *= (GetGlobalScaleX() / AuthoredGlobalScale);
    }
    if(bApplyGlobalScaleTop)
    {
        Y *= (GetGlobalScaleY() / AuthoredGlobalScale);
    }
    if(bApplyGlobalScaleWidth)
    {
        W *= (GetGlobalScaleX() / AuthoredGlobalScale);
    }
    if(bApplyGlobalScaleHeight)
    {
        H *= (GetGlobalScaleY() / AuthoredGlobalScale);
    }
    Left = float(((X >= 0) ? X : X + ScreenWidth));
    Top = float(((Y >= 0) ? Y : Y + ScreenHeight));
    Width = float(((W >= 0) ? W : W + ScreenWidth));
    Height = float(((H >= 0) ? H : H + ScreenHeight));
    I = 0;
    J0x35E:

    if(I < MenuObjects.Length)
    {
        MenuObjects[I].InitMenuObject(InputOwner, self, ScreenWidth, ScreenHeight, bIsFirstInitialization);
        ++ I;
        goto J0x35E;
    }
}

function Font GetSceneFont()
{
    return Class'Engine'.static.GetSmallFont();
}

function RenderScene(Canvas Canvas, float RenderDelta)
{
    local MobileMenuObject MenuObject;

    foreach MenuObjects(MenuObject,)
    {
        if(MenuObject.bTellSceneBeforeRendering)
        {
            PreRenderMenuObject(MenuObject, Canvas, RenderDelta);
        }
        if(!MenuObject.bIsHidden)
        {
            MenuObject.RenderObject(Canvas, RenderDelta);
        }        
    }    
}

function PreRenderMenuObject(MobileMenuObject MenuObject, Canvas Canvas, float RenderDelta);

event OnTouch(MobileMenuObject Sender, Engine.Interaction.ETouchType EventType, float TouchX, float TouchY);

event bool OnSceneTouch(Engine.Interaction.ETouchType EventType, float TouchX, float TouchY, bool bInside)
{
    return false;
}

function Opened(string Mode);

function MadeTopMenu();

function bool Closing()
{
    return true;
}

function Closed()
{
    CleanUpScene();
}

// Export UMobileMenuScene::execCleanUpScene(FFrame&, void* const)
native function CleanUpScene();

function MobileMenuObject FindMenuObject(string Tag)
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < MenuObjects.Length)
    {
        if(Caps(MenuObjects[Idx].Tag) == Caps(Tag))
        {
            return MenuObjects[Idx];
        }
        ++ Idx;
        goto J0x0B;
    }
    return none;
}

function bool MobileMenuCommand(string Command)
{
    return false;
}

defaultproperties
{
    AuthoredGlobalScale=2
    Opacity=1
}