/*******************************************************************************
 * GameCrowdDestination generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameCrowdDestination extends GameCrowdInteractionPoint
    native
    placeable
    hidecategories(Navigation,Advanced,Collision,Display,Actor,Movement,Physics)
    implements(GameCrowdSpawnInterface,EditorLinkSelectionInterface);

var private native const noexport Pointer VfTable_IEditorLinkSelectionInterface;
/** If TRUE, kill crowd members when they reach this destination. */
var() bool bKillWhenReached;
/** whether agents previous destination can be used as a destination if in list of NextDestinations */
var() bool bAllowAsPreviousDestination;
/** Don't go to this destination if panicked */
var() bool bAvoidWhenPanicked;
/** Don't perform kismet or custom behavior at this destination if panicked */
var() bool bSkipBehaviorIfPanicked;
/** Always run toward this destination */
var() bool bFleeDestination;
/** Must reach this destination exactly - will force movement when close */
var() bool bMustReachExactly;
var bool bHasRestrictions;
/** True if spawning permitted at this node */
var(Spawning) bool bAllowsSpawning;
var(Spawning) bool bAllowCloudSpawning;
var(Spawning) bool bAllowVisibleSpawning;
/** Spawn in a line rather than in a circle. */
var(Spawning) bool bLineSpawner;
/** Whether to spawn agents only at the edge of the circle, or at any point within the circle. */
var(Spawning) bool bSpawnAtEdge;
/** Whether agent should stop on reach edge of destination radius (if not reach exactly), or have a "soft" perimeter */
var() bool bSoftPerimeter;
var bool bIsVisible;
var bool bWillBeVisible;
var bool bCanSpawnHereNow;
var bool bIsBeyondSpawnDistance;
var bool bAdjacentToVisibleNode;
var bool bHasNavigationMesh;
/** randomly pick from this list of active destinations */
var() duplicatetransient array<GameCrowdDestination> NextDestinations;
/** queue point to use if this destination is at capacity */
var() duplicatetransient GameCrowdDestinationQueuePoint QueueHead;
/** How many agents can simultaneously have this as a destination */
var() int Capacity;
/** Adjusts the likelihood of agents to select this destination from list at previous destination */
var() float Frequency;
var private int CustomerCount;
/** if set, only agents of this class can use this destination */
var(Restrictions) array< class<GameCrowdAgent> > SupportedAgentClasses;
/** if set, agents from this archetype can use this destination */
var(Restrictions) array<Object> SupportedArchetypes;
/** if set, agents of this class cannot use this destination */
var(Restrictions) array< class<GameCrowdAgent> > RestrictedAgentClasses;
/** if set, agents from this archetype cannot use this destination */
var(Restrictions) array<Object> RestrictedArchetypes;
var float ExactReachTolerance;
/** Type of interaction */
var() name InteractionTag;
/** Time before an agent is allowed to attempt this sort of interaction again */
var() float InteractionDelay;
/** Agents reaching this destination will pick a behavior from this list */
var() array<BehaviorEntry> ReachedBehaviors;
var GameCrowdAgent AgentEnRoute;
var float Priority;
var float LastSpawnTime;
var transient GameCrowdPopulationManager MyPopMgr;

// Export UGameCrowdDestination::execReachedByAgent(FFrame&, void* const)
native simulated function bool ReachedByAgent(GameCrowdAgent Agent, Vector TestPosition, bool bTestExactly);

simulated function PostBeginPlay()
{
    local int I;
    local GameCrowdPopulationManager PopMgr;

    super(Actor).PostBeginPlay();
    bHasRestrictions = (((SupportedAgentClasses.Length > 0) || SupportedArchetypes.Length > 0) || RestrictedAgentClasses.Length > 0) || RestrictedArchetypes.Length > 0;
    if((QueueHead != none) || bKillWhenReached)
    {
        bAllowsSpawning = false;
    }
    I = 0;
    J0x8D:

    if(I < ReachedBehaviors.Length)
    {
        if(ReachedBehaviors[I].BehaviorArchetype == none)
        {
            WarnInternal((string(self) $ " missing BehaviorArchetype at ReachedBehavior ") $ string(I));
            ReachedBehaviors.Remove(I, 1;
            -- I;
        }
        ++ I;
        goto J0x8D;
    }
    PopMgr = GameCrowdPopulationManager(WorldInfo.PopulationManager);
    if(PopMgr != none)
    {
        PopMgr.AddSpawnPoint(self);
    }
}

simulated function Destroyed()
{
    super(Actor).Destroyed();
    if(MyPopMgr != none)
    {
        MyPopMgr.RemoveSpawnPoint(self);
    }
}

simulated event ReachedDestination(GameCrowdAgent Agent)
{
    local int I, J;
    local SeqEvent_CrowdAgentReachedDestination ReachedEvent;
    local bool bEventActivated;

    I = 0;
    J0x0B:

    if(I < GeneratedEvents.Length)
    {
        ReachedEvent = SeqEvent_CrowdAgentReachedDestination(GeneratedEvents[I]);
        J = 0;
        J0x54:

        if(J < ReachedEvent.OutputLinks[0].Links.Length)
        {
            ReachedEvent.OutputLinks[0].Links[J].LinkedOp.bActive = false;
            ++ J;
            goto J0x54;
        }
        bEventActivated = ReachedEvent.CheckActivate(self, Agent);
        goto J0x154;
        ++ I;
        goto J0x0B;
    }
    J0x154:

    if(bKillWhenReached)
    {
        DecrementCustomerCount(Agent);
        Agent.CurrentDestination = none;
        Agent.KillAgent();
        return;
    }
    if(InteractionTag != 'None')
    {
        I = Agent.RecentInteractions.Add(1;
        Agent.RecentInteractions[I].InteractionTag = InteractionTag;
        if(InteractionDelay > 0)
        {
            Agent.RecentInteractions[I].InteractionDelay = WorldInfo.TimeSeconds + InteractionDelay;
        }
    }
    if((Agent.BehaviorDestination != self) && (Agent.CurrentBehavior == none) || Agent.CurrentBehavior.AllowBehaviorAt(self))
    {
        if(ReachedBehaviors.Length > 0)
        {
            Agent.PickBehaviorFrom(ReachedBehaviors);
        }
        if(ReachedEvent != none)
        {
            Agent.BehaviorDestination = self;
        }
    }
    if(!bEventActivated && NextDestinations.Length > 0)
    {
        PickNewDestinationFor(Agent, false);
        if(Agent.CurrentDestination == none)
        {
            if((Agent.NotVisibleLifeSpan > 0) && (WorldInfo.TimeSeconds - Agent.LastRenderTime) > Agent.NotVisibleLifeSpan)
            {
                Agent.KillAgent();                
            }
            else
            {
                PickNewDestinationFor(Agent, true);
            }
        }
    }
    if(Agent.MyGroup != none)
    {
        Agent.MyGroup.UpdateDestinations(Agent.CurrentDestination);
    }
}

simulated function PickNewDestinationFor(GameCrowdAgent Agent, bool bIgnoreRestrictions)
{
    local int I;
    local float DestinationFrequencySum, DestinationPickValue;
    local array<GameCrowdDestination> DestOptions;

    DecrementCustomerCount(Agent);
    Agent.CurrentDestination = none;
    Agent.BehaviorDestination = none;
    I = 0;
    J0x5E:

    if(I < NextDestinations.Length)
    {
        if(((NextDestinations[I] != none) && NextDestinations[I].bHasNavigationMesh) && bIgnoreRestrictions || NextDestinations[I].AllowableDestinationFor(Agent))
        {
            DestinationFrequencySum += (NextDestinations[I].Frequency * (((!bIsVisible && Agent.bPreferVisibleDestination) && NextDestinations[I].bIsVisible || NextDestinations[I].bWillBeVisible) ? 2 : 1));
            DestOptions.AddItem(NextDestinations[I];
        }
        ++ I;
        goto J0x5E;
    }
    DestinationPickValue = DestinationFrequencySum * FRand();
    DestinationFrequencySum = 0;
    I = 0;
    J0x232:

    if(I < DestOptions.Length)
    {
        if((DestOptions[I] != none) && DestOptions[I].bHasNavigationMesh)
        {
            DestinationFrequencySum += (DestOptions[I].Frequency * (((!bIsVisible && Agent.bPreferVisibleDestination) && DestOptions[I].bIsVisible || DestOptions[I].bWillBeVisible) ? 2 : 1));
            if(DestinationPickValue < DestinationFrequencySum)
            {
                Agent.SetCurrentDestination(DestOptions[I]);
                Agent.PreviousDestination = self;
                Agent.UpdateIntermediatePoint();
                goto J0x3FB;
            }
        }
        ++ I;
        goto J0x232;
    }
    J0x3FB:

    Agent.PreviousDestination = self;
}

simulated event DecrementCustomerCount(GameCrowdAgent DepartingAgent)
{
    local GameCrowdDestinationQueuePoint QP;
    local bool bIsInQueue;

    if(DepartingAgent.CurrentDestination == self)
    {
        QP = QueueHead;
        J0x37:

        if(QP != none)
        {
            if(QP.QueuedAgent == DepartingAgent)
            {
                bIsInQueue = true;
                QP.ClearQueue(DepartingAgent);
                goto J0xD4;
            }
            QP = QP.NextQueuePosition;
            goto J0x37;
        }
        J0xD4:

        if(!bIsInQueue)
        {
            -- CustomerCount;
            if((QueueHead != none) && QueueHead.HasCustomer())
            {
                QueueHead.AdvanceCustomerTo(self);
            }
        }
    }
}

simulated event IncrementCustomerCount(GameCrowdAgent ArrivingAgent)
{
    if((AtCapacity()) || (QueueHead != none) && QueueHead.bPendingAdvance)
    {
        if((QueueHead != none) && QueueHead.HasSpace())
        {
            if((((AgentEnRoute != none) && AgentEnRoute.CurrentBehavior == none) && !ReachedByAgent(AgentEnRoute, AgentEnRoute.Location, false)) && VSizeSq(ArrivingAgent.Location - Location) < VSizeSq(AgentEnRoute.Location - Location))
            {
                QueueHead.AddCustomer(AgentEnRoute, self);
                AgentEnRoute = ArrivingAgent;                
            }
            else
            {
                QueueHead.AddCustomer(ArrivingAgent, self);
            }            
        }
        else
        {
            if(QueueHead != none)
            {
                WarnInternal((((string(self) $ " added customer ") $ string(ArrivingAgent)) $ " beyond capacity with queue ") $ string(QueueHead));
            }
        }        
    }
    else
    {
        AgentEnRoute = ArrivingAgent;
        ++ CustomerCount;
    }
}

simulated function bool AtCapacity(optional byte CheckCnt)
{
    return (CustomerCount + CheckCnt) >= Capacity;
}

simulated event bool AllowableDestinationFor(GameCrowdAgent Agent)
{
    local int I;
    local bool bSupported;

    if(!bHasNavigationMesh || !bIsEnabled)
    {
        return false;
    }
    if(bIsBeyondSpawnDistance)
    {
        return false;
    }
    if(!bAllowAsPreviousDestination && Agent.PreviousDestination == self)
    {
        return false;
    }
    if((Agent.CurrentBehavior != none) && !Agent.CurrentBehavior.AllowThisDestination(self))
    {
        return false;
    }
    if((((Agent.MyGroup != none) && AtCapacity(byte(Agent.MyGroup.Members.Length - 1))) || AtCapacity()) || (QueueHead != none) && !QueueHead.HasSpace())
    {
        return false;
    }
    if(InteractionTag != 'None')
    {
        I = Agent.RecentInteractions.Find('InteractionTag', InteractionTag;
        if((I != -1) && (Agent.RecentInteractions[I].InteractionDelay == 0) || WorldInfo.TimeSeconds < Agent.RecentInteractions[I].InteractionDelay)
        {
            return false;            
        }
        else
        {
            if(I != -1)
            {
                Agent.RecentInteractions.Remove(I, 1;
            }
        }
    }
    if(bHasRestrictions)
    {
        if((SupportedAgentClasses.Length > 0) || SupportedArchetypes.Length > 0)
        {
            bSupported = false;
            I = 0;
            J0x316:

            if(I < SupportedAgentClasses.Length)
            {
                if(ClassIsChildOf(Agent.Class, SupportedAgentClasses[I]))
                {
                    bSupported = true;
                    goto J0x382;
                }
                ++ I;
                goto J0x316;
            }
            J0x382:

            if(!bSupported)
            {
                I = 0;
                J0x39C:

                if(I < SupportedArchetypes.Length)
                {
                    if(SupportedArchetypes[I] == Agent.MyArchetype)
                    {
                        bSupported = true;
                        goto J0x407;
                    }
                    ++ I;
                    goto J0x39C;
                }
            }
            J0x407:

            if(!bSupported)
            {
                return false;
            }
        }
        I = 0;
        J0x423:

        if(I < RestrictedAgentClasses.Length)
        {
            if(ClassIsChildOf(Agent.Class, RestrictedAgentClasses[I]))
            {
                return false;
            }
            ++ I;
            goto J0x423;
        }
        I = 0;
        J0x48D:

        if(I < RestrictedArchetypes.Length)
        {
            if(RestrictedArchetypes[I] == Agent.MyArchetype)
            {
                return false;
            }
            ++ I;
            goto J0x48D;
        }
    }
    return true;
}

simulated function float GetSpawnRadius()
{
    return CylinderComponent.CollisionRadius;
}

simulated function GetSpawnPosition(SeqAct_GameCrowdSpawner Spawner, out Vector SpawnPos, out Rotator SpawnRot)
{
    local Vector SpawnLine;
    local float RandScale;

    if(bLineSpawner)
    {
        RandScale = -1 + (2 * FRand());
        SpawnLine = vect(0, 1, 0) >> Rotation;
        SpawnPos = Location + ((RandScale * SpawnLine) * (GetSpawnRadius()));
        SpawnRot.Yaw = Rotation.Yaw;        
    }
    else
    {
        SpawnRot = RotRand(false);
        SpawnRot.Pitch = 0;
        if(bSpawnAtEdge)
        {
            SpawnPos = Location + ((vect(1, 0, 0) * (GetSpawnRadius())) >> SpawnRot);            
        }
        else
        {
            SpawnPos = Location + (((vect(1, 0, 0) * FRand()) * (GetSpawnRadius())) >> SpawnRot);
        }
    }
}

simulated function bool AnalyzeSpawnPoint(const out array<CrowdSpawnerPlayerInfo> PlayerInfo, float MaxSpawnDistSq, bool bForceNavMeshPathing, NavigationHandle NavHandle)
{
    local Actor HitActor;
    local Vector HitLocation, HitNormal;
    local int NextIdx, PlayerIdx;
    local GameCrowdDestination NextGCD;
    local float DistFromView, DistFromPred;

    bIsVisible = true;
    bAdjacentToVisibleNode = false;
    bWillBeVisible = false;
    Priority = 0;
    bCanSpawnHereNow = false;
    bHasNavigationMesh = true;
    bIsBeyondSpawnDistance = true;
    PlayerIdx = 0;
    J0x62:

    if(PlayerIdx < PlayerInfo.Length)
    {
        DistFromView = VSizeSq(PlayerInfo[PlayerIdx].ViewLocation - Location);
        DistFromPred = VSizeSq(PlayerInfo[PlayerIdx].PredictLocation - Location);
        if(FMin(DistFromView, DistFromPred) < MaxSpawnDistSq)
        {
            bIsBeyondSpawnDistance = false;
            goto J0x133;
        }
        ++ PlayerIdx;
        goto J0x62;
    }
    J0x133:

    if(bIsEnabled && bAllowsSpawning)
    {
        if(bForceNavMeshPathing && NavHandle.LineCheck(Location, Location - (vect(0, 0, 3) * CylinderComponent.CollisionHeight), vect(0, 0, 0)))
        {
            bHasNavigationMesh = false;            
        }
        else
        {
            if(!bIsBeyondSpawnDistance)
            {
                bCanSpawnHereNow = true;
                bIsVisible = false;
                PlayerIdx = 0;
                J0x211:

                if(PlayerIdx < PlayerInfo.Length)
                {
                    HitActor = Trace(HitLocation, HitNormal, Location, PlayerInfo[PlayerIdx].ViewLocation, false);
                    if(HitActor == none)
                    {
                        bIsVisible = true;
                        goto J0x2A7;
                    }
                    ++ PlayerIdx;
                    goto J0x211;
                }
                J0x2A7:

                if(!bIsVisible)
                {
                    PlayerIdx = 0;
                    J0x2C1:

                    if(PlayerIdx < PlayerInfo.Length)
                    {
                        HitActor = Trace(HitLocation, HitNormal, Location, PlayerInfo[PlayerIdx].PredictLocation, false);
                        if(HitActor == none)
                        {
                            bWillBeVisible = true;
                            goto J0x357;
                        }
                        ++ PlayerIdx;
                        goto J0x2C1;
                    }
                }
            }
            J0x357:

            if(bIsVisible)
            {
                NextIdx = 0;
                J0x36F:

                if(NextIdx < NextDestinations.Length)
                {
                    NextGCD = NextDestinations[NextIdx];
                    if((((NextGCD != none) && NextGCD.bIsVisible) && NextGCD.bCanSpawnHereNow) && !NextGCD.bIsBeyondSpawnDistance)
                    {
                        bAdjacentToVisibleNode = true;
                        if(bIsBeyondSpawnDistance)
                        {
                            bCanSpawnHereNow = true;
                        }
                    }
                    ++ NextIdx;
                    goto J0x36F;
                }
            }
        }
        return true;
    }
    return false;
}

simulated function PrioritizeSpawnPoint(const out array<CrowdSpawnerPlayerInfo> PlayerInfo, float MaxSpawnDist)
{
    local float DistToSpawn;
    local int PlayerIdx;

    DistToSpawn = 999999;
    PlayerIdx = 0;
    J0x1A:

    if(PlayerIdx < PlayerInfo.Length)
    {
        DistToSpawn = FMin(DistToSpawn, VSize(Location - PlayerInfo[PlayerIdx].ViewLocation));
        ++ PlayerIdx;
        goto J0x1A;
    }
    Priority = 1 - ((MaxSpawnDist - DistToSpawn) / MaxSpawnDist);
    if(bWillBeVisible)
    {
        Priority *= 10;        
    }
    else
    {
        if(bAdjacentToVisibleNode)
        {
            Priority *= 5;
        }
    }
    Priority *= FMin(WorldInfo.TimeSeconds - LastSpawnTime, 10);
}

function float GetDestinationRadius()
{
    return CylinderComponent.CollisionRadius;
}

simulated function DrawDebug(const out array<CrowdSpawnerPlayerInfo> PlayerInfo, optional bool bPresistent)
{
    local int PlayerIdx;
    local Vector Extent;

    Extent.X = CylinderComponent.CollisionRadius;
    Extent.Y = CylinderComponent.CollisionRadius;
    Extent.Z = CylinderComponent.CollisionHeight * 2;
    PlayerIdx = 0;
    J0xC4:

    if(PlayerIdx < PlayerInfo.Length)
    {
        if(bIsBeyondSpawnDistance)
        {
            DrawDebugLine(Location, PlayerInfo[PlayerIdx].ViewLocation, 255, 0, 0, bPresistent);
            if(PlayerIdx == 0)
            {
                DrawDebugSphere(Location, 20, 20, 255, 0, 0, bPresistent);
            }            
        }
        else
        {
            if(!bIsEnabled || !bAllowsSpawning)
            {
                if(PlayerIdx == 0)
                {
                    DrawDebugLine(Location, PlayerInfo[PlayerIdx].ViewLocation, 128, 0, 0, bPresistent);
                }
                DrawDebugSphere(Location, 20, 20, 128, 0, 0, bPresistent);                
            }
            else
            {
                if(bIsVisible)
                {
                    if(PlayerIdx == 0)
                    {
                        DrawDebugLine(Location, PlayerInfo[PlayerIdx].ViewLocation, 255, 0, 0, bPresistent);
                    }
                    DrawDebugBox(Location, Extent, 255, 0, 0, bPresistent);                    
                }
                else
                {
                    if(PlayerIdx == 0)
                    {
                        DrawDebugLine(Location, PlayerInfo[PlayerIdx].ViewLocation, 0, 255, 0, bPresistent);
                    }
                    DrawDebugBox(Location, Extent, 0, 255, 0, bPresistent);
                }
            }
        }
        ++ PlayerIdx;
        goto J0xC4;
    }
    if(bAdjacentToVisibleNode)
    {
        DrawDebugStar(Location, 8, 0, 255, 0, bPresistent);
    }
    if(bWillBeVisible)
    {
        DrawDebugStar(Location + vect(0, 0, 8), 8, 0, 0, 255, bPresistent);
    }
    if(bCanSpawnHereNow)
    {
        DrawDebugStar(Location + vect(0, 0, 16), 8, 255, 255, 255, bPresistent);
    }
}

defaultproperties
{
    bSkipBehaviorIfPanicked=true
    bAllowsSpawning=true
    bAllowCloudSpawning=true
    bSoftPerimeter=true
    bHasNavigationMesh=true
    Capacity=1000
    Frequency=1
    ExactReachTolerance=3
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestination.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestination.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.Crowd.T_Crowd_Destination'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__GameCrowdDestination.Sprite'
    Components(1)=Sprite
    begin object name=ConnectionRenderer class=GameDestinationConnRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: GameDestinationConnRenderingComponent'Default__GameCrowdDestination.ConnectionRenderer'
    Components(2)=ConnectionRenderer
    bStatic=true
    bForceAllowKismetModification=true
    begin object name=CollisionCylinder class=CylinderComponent
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestination.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    SupportedEvents=/* Array type was not detected. */
}