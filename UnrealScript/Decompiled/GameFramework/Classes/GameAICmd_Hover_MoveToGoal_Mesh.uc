/*******************************************************************************
 * GameAICmd_Hover_MoveToGoal_Mesh generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameAICmd_Hover_MoveToGoal_Mesh extends GameAICommand within GameAIController;

var transient Actor Find;
var float Radius;
var transient bool bWasFiring;
var bool bFinalApproach;
var bool bFallbackMoveToMesh;
var float DesiredHoverHeight;
var transient float CurrentHoverHeight;
var float SubGoalReachDist;
var transient float GoalDistance;
var transient Vector IntermediatePoint;
var transient Vector LastMovePoint;
var transient int NumMovePointFails;
var int MaxMovePointFails;
var transient Vector FallbackDest;
var transient Actor MoveToActor;
var BasedPosition LastMoveTargetPathLocation;
var transient Vector InitialFinalDestination;

static function bool HoverToGoal(GameAIController AI, Actor InGoal, float InGoalDistance, float InHoverHeight)
{
    local GameAICmd_Hover_MoveToGoal_Mesh Cmd;

    if(((AI != none) && AI.Pawn != none) && AI.Pawn.bCanFly)
    {
        Cmd = new (AI) Class'GameAICmd_Hover_MoveToGoal_Mesh';
        if(Cmd != none)
        {
            Cmd.GoalDistance = InGoalDistance;
            Cmd.MoveToActor = InGoal;
            Cmd.InitialFinalDestination = InGoal.GetDestination(AI);
            Cmd.DesiredHoverHeight = InHoverHeight;
            Cmd.CurrentHoverHeight = InHoverHeight;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

static function bool HoverToPoint(GameAIController AI, Vector InPoint, float InGoalDistance, float InHoverHeight)
{
    local GameAICmd_Hover_MoveToGoal_Mesh Cmd;

    if(((AI != none) && AI.Pawn != none) && AI.Pawn.bCanFly)
    {
        Cmd = new (AI) Class'GameAICmd_Hover_MoveToGoal_Mesh';
        if(Cmd != none)
        {
            Cmd.GoalDistance = InGoalDistance;
            Cmd.MoveToActor = none;
            Cmd.InitialFinalDestination = InPoint;
            Cmd.DesiredHoverHeight = InHoverHeight;
            Cmd.CurrentHoverHeight = InHoverHeight;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

static function bool HoverBackToMesh(GameAIController AI)
{
    local GameAICmd_Hover_MoveToGoal_Mesh Cmd;

    if(((AI != none) && AI.Pawn != none) && AI.Pawn.bCanFly)
    {
        Cmd = new (AI) Class'GameAICmd_Hover_MoveToGoal_Mesh';
        if(Cmd != none)
        {
            Cmd.bFallbackMoveToMesh = true;
            AI.PushCommand(Cmd);
            return true;
        }
    }
    return false;
}

function Pushed()
{
    super.Pushed();
    if(bFallbackMoveToMesh)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Going into breadcrumb fallback state to get back onto navmesh CurLoc:" @ string(Outer.Pawn.Location));
        }
        GotoState('Fallback_Breadcrumbs');
        return;
    }
    if(!Outer.NavigationHandle.ComputeValidFinalDestination(InitialFinalDestination))
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal(("ABORTING! Final destination" @ string(InitialFinalDestination)) @ "is not reachable! (ComputeValidFinalDestination returned FALSE)");
        }
        GotoState('DelayFailure');        
    }
    else
    {
        if(!Outer.NavigationHandle.SetFinalDestination(InitialFinalDestination))
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal(("ABORTING! Final destination" @ string(InitialFinalDestination)) @ "is not reachable! (SetFinalDestination returned FALSE)");
            }
            GotoState('DelayFailure');            
        }
        else
        {
            GotoState('Moving');
        }
    }
}

function Popped()
{
    super.Popped();
    Outer.ClearLatentAction(Class'SeqAct_AIMoveToActor', Status != 'Success');
    Outer.NavigationHandle.PathCache_Empty();
    if(Outer.Pawn != none)
    {
        Outer.Pawn.ZeroMovementVariables();
        Outer.Pawn.DestinationOffset = 0;
    }
    Outer.ReachedMoveGoal();
}

function Tick(float DeltaTime)
{
    super.Tick(DeltaTime);
    if(ShouldUpdateBreadCrumbs())
    {
        Outer.NavigationHandle.UpdateBreadCrumbs(Outer.Pawn.Location);
    }
    Outer.NavigationHandle.DrawBreadCrumbs();
}

function bool HandlePathObstruction(Actor BlockedBy)
{
    Outer.MoveTimer = -1;
    GotoState('Fallback_Breadcrumbs');
    return false;
}

function ReEvaluatePath();

function bool HasReachedGoal()
{
    if(Outer.Pawn == none)
    {
        return true;
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal((string(GetFuncName()) @ string(bFinalApproach)) @ string(MoveToActor));
    }
    if(bFinalApproach && MoveToActor != none)
    {
        return Outer.Pawn.ReachedDestination(MoveToActor);
    }
    if(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination) != vect(0, 0, 0))
    {
        if(VSize(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination) - Outer.Pawn.Location) < GoalDistance)
        {
            return true;
        }
        return Outer.Pawn.ReachedPoint(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination), none);
    }
    return false;
}

function bool ShouldUpdateBreadCrumbs()
{
    return true;
}

function bool IsEnemyBasedOnInterpActor(Pawn InEnemy)
{
    return false;
}

event DrawDebug(HUD H, name Category)
{
    super.DrawDebug(H, Category);
    if(Category != 'Pathing')
    {
        return;
    }
    Outer.DrawDebugLine(Outer.Pawn.Location, Outer.GetDestinationPosition(), 0, 0, 255);
    Outer.DrawDebugLine(Outer.Pawn.Location, Outer.BP2Vect(Outer.NavigationHandle.FinalDestination), 0, 255, 0);
    Outer.NavigationHandle.DrawPathCache(vect(0, 0, 15));
}

state DelayFailure
{
    ignores HandlePathObstruction;
Begin:

    Outer.Sleep(0.5);
    Status = 'Failure';
    Outer.PopCommand(self);
    stop;                
}

state MoveDown extends DebugState
{
    function Vector GetMoveDest()
    {
        local Vector HitLocation, HitNormal, Dest;
        local Actor HitActor;

        if(Outer.NavigationHandle.LineCheck(Outer.Pawn.Location, Outer.Pawn.Location + vect(0, 0, -4096), vect(5, 5, 5), HitLocation, HitNormal))
        {
            HitActor = Outer.Trace(HitLocation, HitNormal, Outer.Pawn.Location + vect(0, 0, -4096), Outer.Pawn.Location);
            if(HitActor == none)
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal(string(GetFuncName()) @ "Could not find surface to adjust height to!");
                }
                return Outer.Pawn.Location;
            }
        }
        Dest = HitLocation;
        Dest.Z += (Outer.Pawn.GetCollisionHeight() * 1.5);
        return Dest;
    }
Begin:

    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("Moving down!");
    }
    Outer.MoveTo(GetMoveDest());
    Outer.Sleep(1);
    GotoState('Moving');
    stop;                    
}

state Moving extends DebugState
{
    final function float GetMoveDestinationOffset()
    {
        if(bFinalApproach)
        {
            return GoalDistance;            
        }
        else
        {
            return SubGoalReachDist - Outer.Pawn.GetCollisionRadius();
        }
    }
CheckMove:

    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("CHECKMOVE TAG");
    }
    if(HasReachedGoal())
    {
        goto 'ReachedGoal';
    }
Begin:


    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("BEGIN TAG" @ string(GetStateName()));
    }
    if(Outer.Enemy != none)
    {
        Radius = Outer.Pawn.GetCollisionRadius() + Outer.Enemy.GetCollisionRadius();
    }
    Radius = FMax(Radius, GoalDistance);
    Outer.NavigationHandle.SetFinalDestination(InitialFinalDestination);
    if(Outer.NavigationHandle.PointReachable(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination)))
    {
        IntermediatePoint = Outer.BP2Vect(Outer.NavigationHandle.FinalDestination);        
    }
    else
    {
        if(MoveToActor != none)
        {
            if(!Outer.NavigationHandle.SetFinalDestination(MoveToActor.GetDestination(Outer)))
            {
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal(("ABORTING! Final destination" @ string(InitialFinalDestination)) @ "is not reachable! (SetFinalDestination returned FALSE)");
                }
                goto 'FailedMove';
            }
        }
        if(!Outer.GeneratePathToLocation(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination), GoalDistance, true))
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal((("Couldn't generate path to location" @ string(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination))) @ "from") @ string(Outer.Pawn.Location));
            }
            GotoState('Fallback_Breadcrumbs');
        }
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Generated path...");
        }
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal((("Found path!" @ "BP2Vect(NavigationHandle.FinalDestination):'") $ string(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination))) $ "'", 'Move');
        }
        if(!Outer.NavigationHandle.GetNextMoveLocation(IntermediatePoint, SubGoalReachDist))
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal("Generated path, but couldn't retrieve next move location?");
            }
            goto 'FailedMove';
        }
    }
    if(MoveToActor != none)
    {
        Outer.Vect2BP(LastMoveTargetPathLocation, MoveToActor.GetDestination(Outer));
    }
    J0x868:

    if(true)
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Still moving to" @ string(IntermediatePoint), 'Loop');
        }
        bFinalApproach = VSizeSq(IntermediatePoint - Outer.BP2Vect(Outer.NavigationHandle.FinalDestination)) < 1;
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Calling MoveTo -- " @ string(IntermediatePoint));
        }
        if(bFinalApproach && MoveToActor != none)
        {
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal((" - Final approach to" @ string(MoveToActor)) $ ", using MoveToward()");
            }
            Outer.Vect2BP(LastMoveTargetPathLocation, MoveToActor.GetDestination(Outer));
            Outer.NavigationHandle.SetFinalDestination(MoveToActor.GetDestination(Outer));
            Outer.MoveToward(MoveToActor, Outer.Enemy, GetMoveDestinationOffset(), false);            
        }
        else
        {
            if(Outer.Enemy == none)
            {
                Outer.SetFocalPoint(IntermediatePoint);
            }
            Outer.MoveTo(IntermediatePoint, Outer.Enemy, GetMoveDestinationOffset());
        }
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("MoveTo Finished -- " @ string(IntermediatePoint));
        }
        if(HasReachedGoal())
        {
            goto 'CheckMove';            
        }
        else
        {
            if((MoveToActor != none) && VSize(MoveToActor.GetDestination(Outer) - Outer.BP2Vect(LastMoveTargetPathLocation)) > 512)
            {
                Outer.Vect2BP(LastMoveTargetPathLocation, MoveToActor.GetDestination(Outer));
                if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                {
                    Outer.AILog_Internal("Repathing because target moved:" @ string(MoveToActor));
                }
                goto 'CheckMove';                
            }
            else
            {
                if(!Outer.NavigationHandle.GetNextMoveLocation(IntermediatePoint, SubGoalReachDist))
                {
                    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                    {
                        Outer.AILog_Internal("Couldn't get next move location");
                    }
                    if(!bFinalApproach && ((MoveToActor != none) ? Outer.ActorReachable(MoveToActor) : Outer.PointReachable(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination))))
                    {
                        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                        {
                            Outer.AILog_Internal("Target is directly reachable; try direct move");
                        }
                        IntermediatePoint = ((MoveToActor != none) ? MoveToActor.GetDestination(Outer) : Outer.BP2Vect(Outer.NavigationHandle.FinalDestination));
                        Outer.Sleep(RandRange(0.1, 0.175));                        
                    }
                    else
                    {
                        Outer.Sleep(0.1);
                        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                        {
                            Outer.AILog_Internal("GetNextMoveLocation returned false, and finaldest is not directly reachable");
                        }
                        goto 'FailedMove';
                    }                    
                }
                else
                {
                    if(VSize(IntermediatePoint - LastMovePoint) < (Outer.Pawn.GetCollisionRadius() * 0.1))
                    {
                        ++ NumMovePointFails;
                        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                        {
                            Outer.AILog_Internal(((((((((("WARNING: Got same move location... something's wrong?!" @ "LastMovePoint:'") $ string(LastMovePoint)) $ "'") @ "IntermediatePoint:'") $ string(IntermediatePoint)) $ "'") @ "Delta") @ string(VSize(LastMovePoint - IntermediatePoint))) @ "ChkDist") @ string(Outer.Pawn.GetCollisionRadius() * 0.1));
                        }                        
                    }
                    else
                    {
                        NumMovePointFails = 0;
                    }
                    LastMovePoint = IntermediatePoint;
                    if((NumMovePointFails >= MaxMovePointFails) && MaxMovePointFails >= 0)
                    {
                        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                        {
                            Outer.AILog_Internal("ERROR: Got same move location 5x in a row.. something's wrong! bailing from this move");
                        }
                        goto 'FailedMove';                        
                    }
                    else
                    {
                        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
                        {
                            Outer.AILog_Internal(((("NextMove" @ string(IntermediatePoint)) @ "NumMovePointFails:'") $ string(NumMovePointFails)) $ "'");
                        }
                    }
                }
            }
        }
        goto J0x868;
    }
    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("Reached end of move loop??");
    }
    goto 'CheckMove';
FailedMove:


    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("Failed move.  Now ZeroMovementVariables");
    }
    Outer.MoveTo(Outer.Pawn.Location);
    Outer.Pawn.ZeroMovementVariables();
    GotoState('DelayFailure');
ReachedGoal:


    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal(("Reached move point:" @ string(Outer.BP2Vect(Outer.NavigationHandle.FinalDestination))) @ string(VSize(Outer.Pawn.Location - Outer.BP2Vect(Outer.NavigationHandle.FinalDestination))));
    }
    Status = 'Success';
    Outer.PopCommand(self);
    stop;                
}

state Fallback_Breadcrumbs extends DebugState
{
    function bool ShouldUpdateBreadCrumbs()
    {
        return false;
    }

    function bool HandlePathObstruction(Actor BlockedBy)
    {
        Outer.Pawn.SetLocation(IntermediatePoint);
        Outer.MoveTimer = -1;
        GotoState('Fallback_Breadcrumbs', 'Begin');
        return true;
    }
Begin:

    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("trying to move back along breadcrumb path");
    }
    if(Outer.NavigationHandle.GetNextBreadCrumb(IntermediatePoint))
    {
        if(!Class'Engine'.static.GetEngine().bDisableAILogging)
        {
            Outer.AILog_Internal("Moving to breadcrumb pos:" $ string(IntermediatePoint));
        }
        Outer.MoveToDirectNonPathPos(IntermediatePoint);
        if(!Outer.NavigationHandle.IsAnchorInescapable())
        {
            GotoState('Moving');
        }
        Outer.Sleep(0.1);
        goto 'Begin';        
    }
    else
    {
        if(!Outer.NavigationHandle.IsAnchorInescapable())
        {
            GotoState('Moving', 'Begin');            
        }
        else
        {
            GotoState('Fallback_FindNearbyMeshPoint');
        }
    }
    stop;            
}

state Fallback_FindNearbyMeshPoint extends DebugState
{
    function bool FindAPointWhereICanHoverTo(out Vector out_FallbackDest, float Inradius, optional float MinRadius, optional float entityRadius, optional bool bDirectOnly, optional int MaxPoints, optional float ValidHitBoxSize)
    {
        local Vector Retval;
        local array<Vector> poses;
        local Vector Extent, validhitbox;

        MinRadius = 0;
        entityRadius = 32;
        bDirectOnly = true;
        MaxPoints = -1;        
        Extent.X = entityRadius;
        Extent.Y = entityRadius;
        Extent.Z = entityRadius;
        validhitbox = vect(1, 1, 1) * ValidHitBoxSize;
        Outer.NavigationHandle.GetValidPositionsForBox(Outer.Pawn.Location, Inradius, Extent, bDirectOnly, poses, MaxPoints, MinRadius, validhitbox);
        if(poses.Length > 0)
        {
            Retval = poses[Rand(poses.Length)];
            if(VSize(Retval) == 0)
            {
                out_FallbackDest = vect(0, 0, 0);
                return false;
            }
            if(!Class'Engine'.static.GetEngine().bDisableAILogging)
            {
                Outer.AILog_Internal(("Retval:'" $ string(Retval)) $ "'");
            }
            out_FallbackDest = Retval;
            return true;
        }
        out_FallbackDest = vect(0, 0, 0);
        return false;
    }

    function bool ShouldUpdateBreadCrumbs()
    {
        return false;
    }
Begin:

    if(!Class'Engine'.static.GetEngine().bDisableAILogging)
    {
        Outer.AILog_Internal("Fallback! We now try MoveTo directly to a point that is avail to us");
    }
    if(!FindAPointWhereICanHoverTo(FallbackDest, 2048))
    {
        GotoState('MoveDown');        
    }
    else
    {
        Outer.MoveToDirectNonPathPos(FallbackDest,, SubGoalReachDist);
        Outer.Sleep(0.5);
        if(bFallbackMoveToMesh)
        {
            GotoState('DelaySuccess');            
        }
        else
        {
            GotoState('Moving', 'Begin');
        }
    }
    stop;            
}

defaultproperties
{
    SubGoalReachDist=128
    MaxMovePointFails=5
}