/*******************************************************************************
 * MobilePlayerInput generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MobilePlayerInput extends PlayerInput within GamePlayerController
    transient
    native
    config(Game)
    hidecategories(Object,UIRoot);

const NumTouchDataEntries = 5;

enum EUIOrientation
{
    UI_Unknown,
    UI_Portait,
    UI_PortaitUpsideDown,
    UI_LandscapeRight,
    UI_LandscapeLeft,
    UI_MAX
};

struct native TouchDataEvent
{
    var Engine.Interaction.ETouchType EventType;
    var byte TouchpadIndex;
    var Vector2D Location;
    var Double DeviceTime;

    structdefaultproperties
    {
        EventType=ETouchType.Touch_Began
        TouchpadIndex=0
        Location=(X=0,Y=0)
        DeviceTime=none
    }
};

struct native TouchData
{
    var int Handle;
    var byte TouchpadIndex;
    var Vector2D Location;
    var float TotalMoveDistance;
    var Double InitialDeviceTime;
    var float TouchDuration;
    var Double MoveEventDeviceTime;
    var float MoveDeltaTime;
    var bool bInUse;
    var MobileInputZone Zone;
    var Engine.Interaction.ETouchType State;
    var array<TouchDataEvent> Events;
    var float LastActiveTime;

    structdefaultproperties
    {
        Handle=0
        TouchpadIndex=0
        Location=(X=0,Y=0)
        TotalMoveDistance=0
        InitialDeviceTime=none
        TouchDuration=0
        MoveEventDeviceTime=none
        MoveDeltaTime=0
        bInUse=false
        Zone=none
        State=ETouchType.Touch_Began
        Events=none
        LastActiveTime=0
    }
};

struct native MobileInputGroup
{
    var string GroupName;
    var editinline array<editinline MobileInputZone> AssociatedZones;

    structdefaultproperties
    {
        GroupName=""
        AssociatedZones=none
    }
};

struct native MobileInputZoneClassMap
{
    var string Name;
    var class<MobileInputZone> ClassType;

    structdefaultproperties
    {
        Name=""
        ClassType=none
    }
};

var(Input) TouchData Touches[5];
var MobileMenuObject InteractiveObject;
var Double InteractiveObjectLastTime;
/** Holds a list of available groups */
var(Input) editinline array<editinline MobileInputGroup> MobileInputGroups;
/** Holds the index of the current group */
var(Input) int CurrentMobileGroup;
/** Holds a list of mobile input zones. */
var(Input) editinline array<editinline MobileInputZone> MobileInputZones;
var array<MobileInputZoneClassMap> MobileInputZoneClasses;
/** Holds the current Tilt value for mobile devices */
var(Input) float MobilePitch;
/** Holds the center value for the pitch. */
var(Input) float MobilePitchCenter;
/** Pitch sensitivity */
var(Input) float MobilePitchMultiplier;
/** Holds the current Yaw value for mobile devices */
var(Input) float MobileYaw;
/** Holds the center value for the Yaw. */
var(Input) float MobileYawCenter;
/** Pitch sensitivity */
var(Input) float MobileYawMultiplier;
/** How much of a dead zone should the pitch have */
var(Input) config float MobilePitchDeadzoneSize;
/** How much of a dead zone should the yaw have */
var(Input) config float MobileYawDeadzoneSize;
/** Used to determine if a touch is a double tap */
var(Input) config float MobileDoubleTapTime;
/** You have to hold down a tap at least this long to register it as a tap */
var(Input) config float MobileMinHoldForTap;
/** Used to determine how quickly to send repeat events for touch+held */
var(Input) config float MobileTapRepeatTime;
/** If true, we want to allow input to occur during a cinematic */
var(Input) bool bAllowTouchesInCinematic;
/** If set to true, then touches will be ignored */
var(Input) bool bDisableTouchInput;
/**  
 *if set pass absolute touch locations instead of relative to the viewport location
 * (i.e. if this is true don't subtract MobileViewportOffset from touch locations)
 */
var(Input) config bool bAbsoluteTouchLocations;
/** If true this will collapse similar mobile inputs so that they won't get processed */
var(Input) config bool bCollapseTouchInput;
/** This will be set in NativeInitializeInputZones if -SimMobile is on the command line. */
var(Debug) bool bFakeMobileTouches;
/** Ability to disable rendering of scenes. */
var(Debug) bool bDisableSceneRender;
/** Holds the amount of time that a zone can go without input before being consider timed out */
var(Input) config float ZoneTimeout;
/** This is the menu stack. */
var(menus) array<MobileMenuScene> MobileMenuStack;
/** Used for debugging native code */
var(Debug) string NativeDebugString;
/** Holds the amount of time the view port has been inactive */
var(Current) float MobileInactiveTime;
/** Holds a list of handlers looking to listen in on Motion events */
var(Current) array<SeqEvent_MobileBase> MobileSeqEventHandlers;
/** Holds a list of handlers looking to listen in on raw touch events */
var(Current) array<SeqEvent_MobileRawInput> MobileRawInputSeqEventHandlers;
var Vector2D MobileViewportOffset;
var Vector2D MobileViewportSize;
var delegate<OnTouchNotHandledInMenu> __OnTouchNotHandledInMenu__Delegate;
var delegate<OnPreviewTouch> __OnPreviewTouch__Delegate;
var delegate<OnInputTouch> __OnInputTouch__Delegate;

// Export UMobilePlayerInput::execProcessMobileInput(FFrame&, void* const)
native function ProcessMobileInput(float DeltaTime);

// Export UMobilePlayerInput::execCancelMobileInput(FFrame&, void* const)
native function CancelMobileInput();

event PlayerInput(float DeltaTime)
{
    ProcessMobileInput(DeltaTime);
    super.PlayerInput(DeltaTime);
}

delegate OnTouchNotHandledInMenu();

delegate bool OnPreviewTouch(float X, float Y, int TouchpadIndex);

delegate OnInputTouch(int Handle, Engine.Interaction.ETouchType Type, Vector2D TouchLocation, float DeviceTimestamp, int TouchpadIndex);

// Export UMobilePlayerInput::execNativeInitializeInputSystem(FFrame&, void* const)
native function NativeInitializeInputSystem();

// Export UMobilePlayerInput::execNativeInitializeInputZones(FFrame&, void* const)
native function NativeInitializeInputZones(bool bIsFirstInitialize);

// Export UMobilePlayerInput::execConditionalUpdateInputZones(FFrame&, void* const)
native function ConditionalUpdateInputZones(int NewViewportX, int NewViewportY, int NewViewportSizeX, int NewViewportSizeY);

// Export UMobilePlayerInput::execSendInputKey(FFrame&, void* const)
native function SendInputKey(name Key, Core.Object.EInputEvent Event, float AmountDepressed);

// Export UMobilePlayerInput::execSendInputAxis(FFrame&, void* const)
native function SendInputAxis(name Key, float Delta, float DeltaTime);

// Export UMobilePlayerInput::execProcessWorldTouch(FFrame&, void* const)
native function bool ProcessWorldTouch(MobileInputZone Zone, Engine.Interaction.ETouchType EventType, Vector2D TouchLocation);

function InitInputSystem()
{
    super.InitInputSystem();
    InitTouchSystem();
}

function ClientInitInputSystem()
{
    super.ClientInitInputSystem();
    InitTouchSystem();
}

function InitTouchSystem()
{
    NativeInitializeInputSystem();
    if(bFakeMobileTouches || Outer.WorldInfo.IsConsoleBuild(3))
    {
        InitializeInputZones();
    }
}

function InitializeInputZones()
{
    local int I, J;
    local MobileInputZone Zone;
    local class<FrameworkGame> FrameworkGameClass;

    if(MobileInputGroups.Length > 0)
    {
        return;
    }
    FrameworkGameClass = class<FrameworkGame>(Outer.WorldInfo.GRI.GameClass);
    if(FrameworkGameClass != none)
    {
        MobileInputGroups.Length = FrameworkGameClass.default.RequiredMobileInputConfigs.Length;
        I = 0;
        J0xB1:

        if(I < FrameworkGameClass.default.RequiredMobileInputConfigs.Length)
        {
            MobileInputGroups[I].GroupName = FrameworkGameClass.default.RequiredMobileInputConfigs[I].GroupName;
            J = 0;
            J0x14B:

            if(J < FrameworkGameClass.default.RequiredMobileInputConfigs[I].RequireZoneNames.Length)
            {
                Zone = FindorAddZone(FrameworkGameClass.default.RequiredMobileInputConfigs[I].RequireZoneNames[J]);
                MobileInputGroups[I].AssociatedZones.AddItem(Zone;
                ++ J;
                goto J0x14B;
            }
            ++ I;
            goto J0xB1;
        }
        LocalPlayer(Outer.Player).ViewportClient.GetViewportSize(MobileViewportSize);
        NativeInitializeInputZones(true);
        RefreshKismetLinks();
    }
}

function SwapZoneOwners()
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileInputZones.Length)
    {
        MobileInputZones[I].InputOwner = self;
        ++ I;
        goto J0x0B;
    }
}

event RefreshKismetLinks()
{
    local array<SequenceObject> MobileInputSeqEvents;
    local Sequence GameSeq;
    local int I;

    GameSeq = Outer.WorldInfo.GetGameSequence();
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_MobileBase', true, MobileInputSeqEvents);
        I = 0;
        J0x8A:

        if(I < MobileInputSeqEvents.Length)
        {
            SeqEvent_MobileBase(MobileInputSeqEvents[I]).RegisterEvent();
            ++ I;
            goto J0x8A;
        }
        MobileInputSeqEvents.Length = 0;
        GameSeq.FindSeqObjectsByClass(Class'SeqEvent_MobileRawInput', true, MobileInputSeqEvents);
        I = 0;
        J0x12B:

        if(I < MobileInputSeqEvents.Length)
        {
            SeqEvent_MobileRawInput(MobileInputSeqEvents[I]).RegisterEvent();
            ++ I;
            goto J0x12B;
        }
    }
}

function AddKismetEventHandler(SeqEvent_MobileBase NewHandler)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileSeqEventHandlers.Length)
    {
        if(MobileSeqEventHandlers[I] == NewHandler)
        {
            return;
        }
        ++ I;
        goto J0x0B;
    }
    I = 0;
    J0x5F:

    if(I < MobileSeqEventHandlers.Length)
    {
        if(MobileSeqEventHandlers[I] == none)
        {
            MobileSeqEventHandlers[I] = NewHandler;
            return;
        }
        ++ I;
        goto J0x5F;
    }
    MobileSeqEventHandlers.AddItem(NewHandler;
}

function AddKismetRawInputEventHandler(SeqEvent_MobileRawInput NewHandler)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileRawInputSeqEventHandlers.Length)
    {
        if(MobileRawInputSeqEventHandlers[I] == NewHandler)
        {
            return;
        }
        ++ I;
        goto J0x0B;
    }
    I = 0;
    J0x5F:

    if(I < MobileRawInputSeqEventHandlers.Length)
    {
        if(MobileRawInputSeqEventHandlers[I] == none)
        {
            MobileRawInputSeqEventHandlers[I] = NewHandler;
            return;
        }
        ++ I;
        goto J0x5F;
    }
    MobileRawInputSeqEventHandlers.AddItem(NewHandler;
}

function MobileInputZone FindZone(string ZoneName)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileInputZones.Length)
    {
        if(MobileInputZones[I].Name == name(ZoneName))
        {
            return MobileInputZones[I];
        }
        ++ I;
        goto J0x0B;
    }
    return none;
}

function MobileInputZone FindorAddZone(string ZoneName)
{
    local MobileInputZone Zone;
    local class<MobileInputZone> ClassType;
    local int ClassIndex;

    Zone = FindZone(ZoneName);
    if(Zone == none)
    {
        ClassType = Class'MobileInputZone';
        ClassIndex = 0;
        J0x4A:

        if(ClassIndex < MobileInputZoneClasses.Length)
        {
            if(ZoneName == MobileInputZoneClasses[ClassIndex].Name)
            {
                ClassType = MobileInputZoneClasses[ClassIndex].ClassType;
                goto J0xD7;
            }
            ++ ClassIndex;
            goto J0x4A;
        }
        J0xD7:

        Zone = new (none, ZoneName) ClassType;
        Zone.InputOwner = self;
        MobileInputZones.AddItem(Zone;
    }
    return Zone;
}

function bool HasZones()
{
    return (MobileInputGroups.Length > 0) && CurrentMobileGroup < MobileInputGroups.Length;
}

function array<MobileInputZone> GetCurrentZones()
{
    return MobileInputGroups[CurrentMobileGroup].AssociatedZones;
}

exec function ActivateInputGroup(string GroupName)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileInputGroups.Length)
    {
        if(MobileInputGroups[I].GroupName == GroupName)
        {
            CurrentMobileGroup = I;
            return;
        }
        ++ I;
        goto J0x0B;
    }
    LogInternal(("Attempted to activate a mobile input group" @ GroupName) @ "that did not exist.");
}

exec function SetMobileInputConfig(string GroupName)
{
    local int NewConfig;

    NewConfig = 0;
    J0x0B:

    if(NewConfig < MobileInputGroups.Length)
    {
        if(MobileInputGroups[NewConfig].GroupName ~= GroupName)
        {
            goto J0x68;
        }
        ++ NewConfig;
        goto J0x0B;
    }
    J0x68:

    if(NewConfig < MobileInputGroups.Length)
    {
        CurrentMobileGroup = NewConfig;        
    }
    else
    {
        WarnInternal("Could not find a MobileInputGroup called" @ GroupName);
    }
}

event MobileMenuScene OpenMenuScene(class<MobileMenuScene> SceneClass, optional string Mode)
{
    local MobileMenuScene Scene;
    local Vector2D ViewportSize;

    if(SceneClass != none)
    {
        Scene = new (Outer) SceneClass;
        if(Scene != none)
        {
            LocalPlayer(Outer.Player).ViewportClient.GetViewportSize(ViewportSize);
            Scene.InitMenuScene(self, int(ViewportSize.X), int(ViewportSize.Y), true);
            MobileMenuStack.InsertItem(0, Scene;
            Scene.Opened(Mode);
            Scene.MadeTopMenu();
            return Scene;            
        }
        else
        {
            LogInternal("Could not create menu scene " $ string(SceneClass));
        }
    }
    return none;
}

event CloseMenuScene(MobileMenuScene SceneToClose)
{
    local int I, Idx;
    local bool bClosedTopMenu;

    if(SceneToClose.Closing())
    {
        Idx = -1;
        I = 0;
        J0x3C:

        if(I < MobileMenuStack.Length)
        {
            if(MobileMenuStack[I] == SceneToClose)
            {
                Idx = I;
                goto J0x99;
            }
            ++ I;
            goto J0x3C;
        }
        J0x99:

        if(Idx >= 0)
        {
            bClosedTopMenu = Idx == 0;
            MobileMenuStack.Remove(Idx, 1;
            SceneToClose.Closed();
            if(bClosedTopMenu)
            {
                if(MobileMenuStack.Length > 0)
                {
                    MobileMenuStack[0].MadeTopMenu();
                }
            }
        }
    }
}

event CloseAllMenus()
{
    J0x00:
    if(MobileMenuStack.Length > 0)
    {
        CloseMenuScene(MobileMenuStack[MobileMenuStack.Length - 1]);
        goto J0x00;
    }
}

event RenderMenus(Canvas Canvas, float RenderDelta)
{
    local int I;

    Canvas.Reset();
    if(bDisableSceneRender)
    {
        return;
    }
    I = MobileMenuStack.Length - 1;
    J0x46:

    if(I >= 0)
    {
        MobileMenuStack[I].RenderScene(Canvas, RenderDelta);
        -- I;
        goto J0x46;
    }
}

function PreClientTravel(string PendingURL, Engine.Actor.ETravelType TravelType, bool bIsSeamlessTravel)
{
    local int I;

    super.PreClientTravel(PendingURL, TravelType, bIsSeamlessTravel);
    I = MobileMenuStack.Length - 1;
    J0x3D:

    if(I >= 0)
    {
        MobileMenuStack[I].Closed();
        -- I;
        goto J0x3D;
    }
}

exec function SceneRenderToggle()
{
    bDisableSceneRender = !bDisableSceneRender;
}

exec function MobileMenuCommand(string MenuCommand)
{
    local int I;

    I = 0;
    J0x0B:

    if(I < MobileMenuStack.Length)
    {
        if(MobileMenuStack[I].MobileMenuCommand(MenuCommand))
        {
            return;
        }
        ++ I;
        goto J0x0B;
    }
}

exec function MobileMenuScene OpenMobileMenu(string MenuClassName)
{
    local class<MobileMenuScene> MenuClass;

    MenuClass = class<MobileMenuScene>(DynamicLoadObject(MenuClassName, Class'Class'));
    if(MenuClass != none)
    {
        return OpenMenuScene(MenuClass);
    }
    return none;
}

exec function MobileMenuScene OpenMobileMenuMode(string MenuClassName, string Mode)
{
    local class<MobileMenuScene> MenuClass;

    MenuClass = class<MobileMenuScene>(DynamicLoadObject(MenuClassName, Class'Class'));
    if(MenuClass != none)
    {
        return OpenMenuScene(MenuClass, Mode);
    }
    return none;
}
