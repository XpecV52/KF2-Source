/*******************************************************************************
 * GameCrowdBehavior_PlayAnimation generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameCrowdBehavior_PlayAnimation extends GameCrowdAgentBehavior
    native;

/** List of animations to play */
var() array<name> AnimationList;
/** Time to blend into next animation. */
var() float BlendInTime;
/** Time to blend out of animation. */
var() float BlendOutTime;
/** Whether to use root motion. */
var() bool bUseRootMotion;
/** If true, face player before starting animation. */
var() bool bLookAtPlayer;
/** If true, loop the animation in the list specified by LoopIndex. */
var() bool bLooping;
/** Whether should blend between animations in the list.  Set True if they don't match at start/end */
var() bool bBlendBetweenAnims;
var Actor CustomActionTarget;
/** Which animation to loop in AnimationList if bLooping == TRUE */
var() int LoopIndex;
/** How long to loop the animation if bLooping == TRUE, -1.f == infinite */
var() float LoopTime;
var SeqAct_PlayAgentAnimation AnimSequence;
var int AnimationIndex;

function InitBehavior(GameCrowdAgent Agent)
{
    local PlayerController PC, ClosestPC;
    local float ClosestDist, newdist;
    local GameCrowdAgentSkeletal SkAgent;

    super.InitBehavior(Agent);
    if(CustomActionTarget != none)
    {
        ActionTarget = CustomActionTarget;        
    }
    else
    {
        if(bLookAtPlayer)
        {
            ClosestDist = 1000000;
            foreach Agent.LocalPlayerControllers(Class'PlayerController', PC)
            {
                if(PC.Pawn != none)
                {
                    newdist = VSize(PC.Pawn.Location - Agent.Location);
                    if(newdist < ClosestDist)
                    {
                        ClosestDist = newdist;
                        ClosestPC = PC;
                    }
                }                
            }            
            if(ClosestPC != none)
            {
                ActionTarget = ClosestPC.Pawn;
            }
        }
    }
    SkAgent = GameCrowdAgentSkeletal(Agent);
    if(SkAgent == none)
    {
        WarnInternal((("PlayAnimation behavior " $ string(self)) $ " called on non-skeletal agent ") $ string(Agent));
        return;
    }
    AnimationIndex = 0;
    if(!bFaceActionTargetFirst)
    {
        PlayAgentAnimationNow();
    }
}

event FinishedTargetRotation()
{
    PlayAgentAnimationNow();
}

// Export UGameCrowdBehavior_PlayAnimation::execSetSequenceOutput(FFrame&, void* const)
native function SetSequenceOutput();

event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    ++ AnimationIndex;
    if(AnimationList.Length > AnimationIndex)
    {
        PlayAgentAnimationNow();        
    }
    else
    {
        if((AnimSequence != none) && AnimSequence.OutputLinks[0].Links.Length > 0)
        {
            SetSequenceOutput();
            MyAgent.ClearLatentAction(Class'SeqAct_PlayAgentAnimation', false);
            AnimSequence.ActivateOutputLink(0);
        }
        MyAgent.StopBehavior();
    }
}

function PlayAgentAnimationNow()
{
    local float CurrentBlendInTime, CurrentBlendOutTime;
    local GameCrowdAgentSkeletal MySkAgent;

    MySkAgent = GameCrowdAgentSkeletal(MyAgent);
    bFaceActionTargetFirst = false;
    MySkAgent.SetRootMotion(bUseRootMotion);
    CurrentBlendInTime = 0;
    CurrentBlendOutTime = 0;
    if(bLooping && AnimationIndex == LoopIndex)
    {
        if(bBlendBetweenAnims || AnimationIndex == 0)
        {
            CurrentBlendInTime = BlendInTime;
        }
        MySkAgent.FullBodySlot.PlayCustomAnim(AnimationList[AnimationIndex], 1, CurrentBlendInTime, CurrentBlendOutTime, bLooping, true);
        if(LoopTime > 0)
        {
            MySkAgent.SetTimer(LoopTime, false, 'OnAnimEnd');
        }        
    }
    else
    {
        if(bBlendBetweenAnims)
        {
            CurrentBlendInTime = BlendInTime;
            CurrentBlendOutTime = BlendOutTime;            
        }
        else
        {
            if(AnimationIndex == 0)
            {
                CurrentBlendInTime = BlendInTime;
            }
        }
        MySkAgent.FullBodySlot.PlayCustomAnim(AnimationList[AnimationIndex], 1, CurrentBlendInTime, CurrentBlendOutTime, false, true);
        MySkAgent.FullBodySlot.SetActorAnimEndNotification(true);
    }
    if(AnimSequence != none)
    {
        AnimSequence.ActivateOutputLink(2);
    }
}

function StopBehavior()
{
    GameCrowdAgentSkeletal(MyAgent).FullBodySlot.StopCustomAnim(BlendOutTime);
    GameCrowdAgentSkeletal(MyAgent).SetRootMotion(false);
    super.StopBehavior();
}

function string GetBehaviorString()
{
    local string BehaviorString;

    BehaviorString = "Behavior: " $ string(self);
    if(bFaceActionTargetFirst)
    {
        BehaviorString = (BehaviorString @ "Turning toward ") $ string(ActionTarget);        
    }
    else
    {
        if((AnimationList.Length <= AnimationIndex) || AnimationList[AnimationIndex] == 'None')
        {
            BehaviorString = BehaviorString @ "MISSING ANIMATION";            
        }
        else
        {
            BehaviorString = (BehaviorString @ "Playing ") $ string(AnimationList[AnimationIndex]);
        }
    }
    return BehaviorString;
}

defaultproperties
{
    BlendInTime=0.2
    BlendOutTime=0.2
    LoopTime=-1
    bIdleBehavior=true
}