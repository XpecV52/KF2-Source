/*******************************************************************************
 * GameCrowdAgent generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameCrowdAgent extends CrowdAgentBase
    abstract
    native
    hidecategories(Navigation,Advanced,Attachment,Collision,Object)
    implements(Interface_RVO);

enum EConformType
{
    CFM_NavMesh,
    CFM_BSP,
    CFM_World,
    CFM_None,
    CFM_MAX
};

struct native AvoidOtherSampleItem
{
    var() int RotOffset;
    var() byte NumMagSamples;
    var() bool bFallbackOnly;

    structdefaultproperties
    {
        RotOffset=0
        NumMagSamples=0
        bFallbackOnly=false
    }
};

struct native RecentInteraction
{
    var name InteractionTag;
    var float InteractionDelay;

    structdefaultproperties
    {
        InteractionTag=None
        InteractionDelay=0
    }
};

struct native BehaviorEntry
{
    /** Archetype based on a GameCrowdAgentBehavior class */
    var() GameCrowdAgentBehavior BehaviorArchetype;
    /** Optional actor to look at when performing this behavior */
    var() Actor LookAtActor;
    /** How often this behavior is picked = BehaviorFrequency/(sum of BehaviorFrequencies) */
    var() float BehaviorFrequency;
    /** If true, agent will never repeat this behavior */
    var() bool bNeverRepeat;
    var bool bHasBeenUsed;
    var bool bCanBeUsed;

    structdefaultproperties
    {
        BehaviorArchetype=none
        LookAtActor=none
        BehaviorFrequency=1
        bNeverRepeat=false
        bHasBeenUsed=false
        bCanBeUsed=false
    }
};

var private native const noexport Pointer VfTable_IInterface_RVO;
var GameCrowdGroup MyGroup;
var Vector PreferredVelocity;
var Vector PendingVelocity;
var GameCrowdDestination CurrentDestination;
var GameCrowdDestination BehaviorDestination;
var GameCrowdDestination PreviousDestination;
var float InterpZTranslation;
/** Current health of agent */
var() int Health;
/** How long dead body stays around */
var(Behavior) float DeadBodyDuration;
var const editconst export editinline DynamicLightEnvironmentComponent LightEnvironment;
var transient int ConformTraceFrameCount;
var transient array<NearbyDynamicItem> NearbyDynamics;
var bool bUniformScale;
/** Whether to have obstacle mesh block agents */
var(Pathing) bool bCheckForObstacles;
/** If TRUE, use navmesh for pathing */
var(Pathing) bool bUseNavMeshPathing;
var bool bWantsSeePlayerNotification;
/** Whether agent is allowed to pitch as he rotates toward his current velocity */
var(Movement) bool bAllowPitching;
var bool bHitObstacle;
var bool bBadHitNormal;
var bool bSimulateThisTick;
var bool bPotentialEncounter;
var bool bIsPanicked;
var bool bWantsGroupIdle;
/** If true, agent will prefer destinations with line of sight to player if starting from non-L.O.S. destination */
var() bool bPreferVisibleDestination;
/** If true, prefer visible destination only for first destination chosen after spawn */
var() bool bPreferVisibleDestinationOnSpawn;
var bool bHasNotifiedSpawner;
var bool bIsInSpawnPool;
var(Debug) bool bPaused;
/** How agent conforms to surfaces */
var(Movement) GameCrowdAgent.EConformType ConformType;
/** How far to trace to conform agent to the bsp/world. */
var(Movement) float ConformTraceDist;
/** Every how many frames the ground conforming line check is done. */
var(Movement) int ConformTraceInterval;
var int CurrentConformTraceInterval;
var float LastGroundZ;
/** Controls how far around an agent the system looks when finding the average speed. */
var(Pathing) float AwareRadius;
/** The radius used to check overlap between agents (basically how big an agent is). */
var(Pathing) float AvoidOtherRadius;
var(Pathing) array<AvoidOtherSampleItem> AvoidOtherSampleList;
var(Pathing) float PENALTY_COEFF_ANGLETOGOAL;
var(Pathing) float PENALTY_COEFF_ANGLETOVEL;
var(Pathing) float PENALTY_COEFF_MAG;
var(Pathing) float MIN_PENALTY_THRESHOLD;
var(Pathing) float LastProgressTime;
var(Pathing) float LastFallbackActiveTime;
var(Pathing) float MaxPathLaneValue;
var(Pathing) float CurrentPathLaneValue;
var(Pathing) int ExtraPathCost;
/** When a 'target' action occurs, agent will rotate to face the CrowdAttractor. This controls how fast that turn happens */
var(Movement) float RotateToTargetSpeed;
/** Crowd agents rotate to face the direction they are travelling. This value limits how quickly they turn to do this, to avoid them spinning too quickly */
var(Movement) float MaxYawRate;
/** Min 3D drawscale to apply to the agent mesh */
var(Rendering) Vector MeshMinScale3D;
/** Max 3D drawscale to apply to the agent mesh */
var(Rendering) Vector MeshMaxScale3D;
var float EyeZOffset;
/** Distance to LOD out proximity checks for non-visible agents */
var(LOD) float ProximityLODDist;
/** Distance to LOD out proximity checks for visible agents */
var(LOD) float VisibleProximityLODDist;
var Vector LastKnownGoodPosition;
/** Distance from ground to agent center (used to adjust foot positioning) */
var(Rendering) float GroundOffset;
var Vector IntermediatePoint;
var Vector SearchExtent;
var class<NavigationHandle> NavigationHandleClass;
var NavigationHandle NavigationHandle;
var int ObstacleCheckCount;
var float WalkableFloorZ;
var float LastPathingAttempt;
var float LastUpdateTime;
/** how long to wait before killing this agent when it isn't visible */
var(LOD) float NotVisibleLifeSpan;
var GameCrowdAgent MyArchetype;
/** Max walking speed (if not using root motion velocity) */
var(Movement) float MaxWalkingSpeed;
/** Max running speed (if not using root motion velocity) */
var(Movement) float MaxRunningSpeed;
var float MaxSpeed;
var array<RecentInteraction> RecentInteractions;
var float BeaconMaxDist;
var Vector BeaconOffset;
var const Texture2D BeaconTexture;
var const LinearColor BeaconColor;
/** Ambient Sound cue played by this agent */
var() SoundCue AmbientSoundCue;
var export editinline AudioComponent AmbientSoundComponent;
var GameCrowdAgentBehavior CurrentBehavior;
var float CurrentBehaviorActivationTime;
/** Behaviors to choose from when encounter another agent (only if no current behavior) */
var(Behavior) array<BehaviorEntry> EncounterAgentBehaviors;
/** Behaviors to choose from when see player (only if no current behavior) */
var(Behavior) array<BehaviorEntry> SeePlayerBehaviors;
var float MaxSeePlayerDistSq;
/** How often see player event can be triggered.  If 0, never retriggers */
var(Behavior) float SeePlayerInterval;
/** Behaviors to choose from when agent spawns. */
var(Behavior) array<BehaviorEntry> SpawnBehaviors;
/** Behaviors to choose from when agent panicks. */
var(Behavior) array<BehaviorEntry> UneasyBehaviors;
var(Behavior) array<BehaviorEntry> AlertBehaviors;
var(Behavior) array<BehaviorEntry> PanicBehaviors;
/** Behaviors to choose from randomly at RandomBehaviorInterval. */
var(Behavior) array<BehaviorEntry> RandomBehaviors;
/** Behaviors to choose from when the agent takes damage. */
var(Behavior) array<BehaviorEntry> TakeDamageBehaviors;
/** Average time between random behavior attempt (only if visible to player and no current behavior) */
var(Behavior) float RandomBehaviorInterval;
var float ForceUpdateTime;
var float ReachThreshold;
/** Behaviors to choose from when waiting for other group members. */
var(Behavior) array<BehaviorEntry> GroupWaitingBehaviors;
/** Try to keep Members this close together - probably will be obsolete when have formations */
var(Behavior) float DesiredGroupRadius;
var float DesiredGroupRadiusSq;
var float MaxLOSLifeDistanceSq;
var GameCrowdSpawnerInterface MySpawner;
var Vector SpawnOffset;
var float InitialLastRenderTime;
var(Debug) Color DebugAgentColor;
var(Debug) GameCrowdDestination DebugSpawnDest;

// Export UGameCrowdAgent::execGetCollisionExtent(FFrame&, void* const)
native function Vector GetCollisionExtent();

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    Health = -1;
    LifeSpan = -0.1;
}

// Export UGameCrowdAgent::execIsPanicked(FFrame&, void* const)
native function bool IsPanicked();

function bool PickBehaviorFrom(array<BehaviorEntry> BehaviorList, optional Vector BestCameraLoc)
{
    local Vector CameraLoc;
    local Rotator CameraRot;
    local PlayerController PC;
    local float BestDistSq, NewDistSq;
    local int I;
    local float FreqSum, RandPick;

    BestCameraLoc = vect(0, 0, 0);
    if(BestCameraLoc == vect(0, 0, 0))
    {
        BestDistSq = 9E+07;
        foreach LocalPlayerControllers(Class'PlayerController', PC)
        {
            PC.GetPlayerViewPoint(CameraLoc, CameraRot);
            NewDistSq = VSizeSq(CameraLoc - Location);
            if(NewDistSq < BestDistSq)
            {
                BestDistSq = NewDistSq;
                BestCameraLoc = CameraLoc;
            }            
        }        
    }
    I = 0;
    J0xF5:

    if(I < BehaviorList.Length)
    {
        if(BehaviorList[I].BehaviorArchetype == none)
        {
            WarnInternal(((string(self) @ string(MyArchetype)) $ " No behavior archetype for behavior entry ") $ string(I));            
        }
        else
        {
            BehaviorList[I].bCanBeUsed = (!BehaviorList[I].bHasBeenUsed || !BehaviorList[I].bNeverRepeat) && BehaviorList[I].BehaviorArchetype.CanBeUsedBy(self, BestCameraLoc);
            if(BehaviorList[I].bCanBeUsed)
            {
                FreqSum += BehaviorList[I].BehaviorFrequency;
            }
        }
        ++ I;
        goto J0xF5;
    }
    RandPick = FMax(1, FreqSum) * FRand();
    if(RandPick >= FreqSum)
    {
        return false;
    }
    I = 0;
    J0x2FE:

    if(I < BehaviorList.Length)
    {
        if(BehaviorList[I].bCanBeUsed)
        {
            RandPick -= BehaviorList[I].BehaviorFrequency;
            if(RandPick < 0)
            {
                ActivateBehavior(BehaviorList[I].BehaviorArchetype, BehaviorList[I].LookAtActor);
                BehaviorList[I].bHasBeenUsed = true;
                return true;
            }
        }
        ++ I;
        goto J0x2FE;
    }
    return false;
}

event WaitForGroupMembers()
{
    local int I;

    PickBehaviorFrom(GroupWaitingBehaviors);
    if(CurrentBehavior != none)
    {
        CurrentBehavior.ActionTarget = MyGroup.Members[0];
        I = 0;
        J0x6D:

        if(I < MyGroup.Members.Length)
        {
            if((((MyGroup.Members[I] != none) && !MyGroup.Members[I].bDeleteMe) && VSizeSq(MyGroup.Members[I].Location - Location) > DesiredGroupRadiusSq) && (MyGroup.Members[I].Velocity Dot (Location - MyGroup.Members[I].Location)) > 0)
            {
                CurrentBehavior.ActionTarget = MyGroup.Members[I];
                goto J0x252;
            }
            ++ I;
            goto J0x6D;
        }
    }
    J0x252:

}

event SetCurrentDestination(GameCrowdDestination NewDest)
{
    if(NewDest != CurrentDestination)
    {
        if(CurrentBehavior != none)
        {
            CurrentBehavior.ChangingDestination(NewDest);
        }
        CurrentDestination = NewDest;
        CurrentDestination.IncrementCustomerCount(self);
        ReachThreshold = ((CurrentDestination.bSoftPerimeter) ? 0.5 + (0.5 * FRand()) : 1);
    }
}

function SetMaxSpeed()
{
    MaxSpeed = ((IsPanicked()) ? MaxRunningSpeed : MaxWalkingSpeed);
}

simulated function PostBeginPlay()
{
    local Vector AgentScale3D;
    local int I;
    local float MaxSeePlayerDist;

    super(Actor).PostBeginPlay();
    if(bDeleteMe)
    {
        return;
    }
    WorldInfo.bHaveActiveCrowd = true;
    if(bUniformScale)
    {
        AgentScale3D = MeshMinScale3D + (FRand() * (MeshMaxScale3D - MeshMinScale3D));        
    }
    else
    {
        AgentScale3D.X = RandRange(MeshMinScale3D.X, MeshMaxScale3D.X);
        AgentScale3D.Y = RandRange(MeshMinScale3D.Y, MeshMaxScale3D.Y);
        AgentScale3D.Z = RandRange(MeshMinScale3D.Z, MeshMaxScale3D.Z);
    }
    SetDrawScale3D(AgentScale3D);
    LastKnownGoodPosition = Location;
    LastKnownGoodPosition.Z += EyeZOffset;
    ForceUpdateTime = WorldInfo.TimeSeconds;
    SetMaxSpeed();
    if(AmbientSoundCue != none)
    {
        AmbientSoundComponent = new (self) Class'AudioComponent';
        if(AmbientSoundComponent != none)
        {
            AttachComponent(AmbientSoundComponent);
            AmbientSoundComponent.SoundCue = AmbientSoundCue;
            AmbientSoundComponent.Play();
        }
    }
    bWantsSeePlayerNotification = SeePlayerBehaviors.Length > 0;
    I = 0;
    J0x2C6:

    if(I < SeePlayerBehaviors.Length)
    {
        MaxSeePlayerDist = FMax(MaxSeePlayerDist, SeePlayerBehaviors[I].BehaviorArchetype.MaxPlayerDistance);
        ++ I;
        goto J0x2C6;
    }
    MaxSeePlayerDistSq = MaxSeePlayerDist * MaxSeePlayerDist;
    DesiredGroupRadiusSq = DesiredGroupRadius * DesiredGroupRadius;
    if(RandomBehaviors.Length > 0)
    {
        SetTimer((0.8 + (0.4 * FRand())) * RandomBehaviorInterval, true, 'TryRandomBehavior');
    }
}

event KillAgent()
{
    if(bIsInSpawnPool)
    {
        return;
    }
    LifeSpan = -0.1;
    TimeSinceLastTick = 1000;
}

function ResetPooledAgent()
{
    bIsInSpawnPool = false;
    SetHidden(false);
    BehaviorDestination = none;
    PreviousDestination = none;
    LifeSpan = 0;
    Health = default.Health;
    TimeSinceLastTick = 0;
    LastKnownGoodPosition = Location;
    LastKnownGoodPosition.Z += EyeZOffset;
    ForceUpdateTime = WorldInfo.TimeSeconds;
    SetMaxSpeed();
    if(RandomBehaviors.Length > 0)
    {
        SetTimer((0.8 + (0.4 * FRand())) * RandomBehaviorInterval, true, 'TryRandomBehavior');
    }
}

simulated function Destroyed()
{
    super(Actor).Destroyed();
    if(NotEqual_InterfaceInterface(MySpawner, (none)) && !bHasNotifiedSpawner)
    {
        bHasNotifiedSpawner = true;
        MySpawner.AgentDestroyed(self);
    }
    if(CurrentDestination != none)
    {
        CurrentDestination.DecrementCustomerCount(self);
        CurrentDestination = none;
    }
    if(MyGroup != none)
    {
        MyGroup.RemoveMember(self);
    }
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local string T;
    local Canvas Canvas;

    super(Actor).DisplayDebug(HUD, out_YL, out_YPos);
    Canvas = HUD.Canvas;
    Canvas.SetPos(4, out_YPos);
    Canvas.SetDrawColor(255, 0, 0);
    T = GetDebugName();
    if(bDeleteMe)
    {
        T = T $ " DELETED (bDeleteMe == true)";
    }
    if(T != "")
    {
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
    }
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawText((((((("Location:" @ string(Location)) @ "Rotation:") @ string(Rotation)) @ " Speed: ") $ string(VSize(Velocity))) @ "ZVel") @ string(Velocity.Z), false);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText((((("Hit obestacle:" @ string(bHitObstacle)) @ "BadHitNormal:") @ string(bBadHitNormal)) @ "count") @ string(ObstacleCheckCount), false);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    Canvas.DrawText((((("Current conform interval:" @ string(CurrentConformTraceInterval)) @ "Base Conform Interval:") @ string(ConformTraceInterval)) @ " Last Ground Z ") @ string(LastGroundZ), false);
    out_YPos += out_YL;
    Canvas.SetPos(4, out_YPos);
    if(CurrentDestination == none)
    {
        Canvas.DrawText("NO DESTINATION", false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);        
    }
    else
    {
        if(NavigationHandle != none)
        {
            NavigationHandle.DrawPathCache();
        }
        T = "DESTINATION " $ string(CurrentDestination);
        if(MyGroup != none)
        {
            T = (T $ " Group ") $ string(MyGroup);
            DrawDebugLine(MyGroup.Members[0].Location, Location, 255, 128, 0, false);
        }
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4, out_YPos);
        if(IntermediatePoint == CurrentDestination.Location)
        {
            DrawDebugLine(IntermediatePoint, Location, 0, 128, 255, false);            
        }
        else
        {
            DrawDebugLine(IntermediatePoint, Location, 0, 255, 0, false);
            DrawDebugLine(CurrentDestination.Location, Location, 255, 255, 0, false);
        }
    }
}

simulated function SetLighting(bool bEnableLightEnvironment, LightingChannelContainer AgentLightingChannel, bool bCastShadows)
{
    if(bEnableLightEnvironment)
    {
        LightEnvironment.SetEnabled(true);        
    }
    else
    {
        DetachComponent(LightEnvironment);
    }
}

simulated function Vector GetAttemptedSpawnLocation(float Pct, Vector CurPos, float CurRadius, Vector DestPos, float DestRadius)
{
    local float MaxLateralOffset, LateralOffset;
    local Vector LateralDir;

    MaxLateralOffset = CurRadius + (Pct * (DestRadius - CurRadius));
    LateralDir = Normal((CurPos - DestPos) Cross vect(0, 0, 1));
    LateralOffset = RandRange(-MaxLateralOffset, MaxLateralOffset);
    return ((Pct * DestPos) + ((1 - Pct) * CurPos)) + (LateralOffset * LateralDir);
}

simulated function InitializeAgent(Actor SpawnLoc, const out array<CrowdSpawnerPlayerInfo> PlayerInfo, GameCrowdAgent AgentTemplate, GameCrowdGroup NewGroup, float AgentWarmupTime, bool bWarmupPosition, bool bCheckWarmupVisibility)
{
    local bool bGroupDestination, bRealPreferVisible;
    local GameCrowdDestination SpawnDest;
    local float TryPct, MaxSpawnDist, DestDist, StartDist;
    local Vector TryLoc;
    local Actor HitActor;
    local Vector HitLocation, HitNormal, NearestViewLocation, YAdjust;
    local bool bVisibleTryLoc, bFoundOption;
    local int CheckCnt, MaxCheckCnt, OptionIdx;
    local array<Vector> TryOptions;
    local float SpawnDestRadius, TravelDestRadius;
    local int PlayerIdx;
    local float NearestViewDistSq, ViewDistSq;
    local bool bVisibleOption;

    MyArchetype = AgentTemplate;
    LastRenderTime = WorldInfo.TimeSeconds + (AgentWarmupTime * (0.5 + FRand()));
    InitialLastRenderTime = LastRenderTime;
    if(NewGroup != none)
    {
        NewGroup.AddMember(self);
        if(NewGroup.Members.Length > 1)
        {
            bGroupDestination = true;
            SetCurrentDestination(NewGroup.Members[0].CurrentDestination);
        }
    }
    if(!bGroupDestination)
    {
        SpawnDest = GameCrowdDestination(SpawnLoc);
        if(SpawnDest != none)
        {
            DebugSpawnDest = SpawnDest;
            SetCurrentDestination(SpawnDest);
            bRealPreferVisible = bPreferVisibleDestination;
            bPreferVisibleDestination = bPreferVisibleDestinationOnSpawn || !SpawnDest.bWillBeVisible;
            LastRenderTime = WorldInfo.TimeSeconds;
            CurrentDestination.ReachedDestination(self);
            bPreferVisibleDestination = bRealPreferVisible;
            if(CurrentDestination == none)
            {
                WarnInternal("INITIALIZING - NO CURRENTDESTINATION AFTER REACHING " $ string(SpawnDest));
            }
            if(bWarmupPosition)
            {
                PlayerIdx = 0;
                J0x27C:

                if(PlayerIdx < PlayerInfo.Length)
                {
                    ViewDistSq = VSizeSq(PlayerInfo[PlayerIdx].ViewLocation - SpawnDest.Location);
                    if((NearestViewDistSq == 0) || ViewDistSq < NearestViewDistSq)
                    {
                        NearestViewDistSq = ViewDistSq;
                        NearestViewLocation = PlayerInfo[PlayerIdx].ViewLocation;
                    }
                    ++ PlayerIdx;
                    goto J0x27C;
                }
                if((NewGroup == none) || NewGroup.Members.Length == 1)
                {
                    TryPct = FRand();
                    MaxSpawnDist = ((NotEqual_InterfaceInterface(MySpawner, (none))) ? MySpawner.GetMaxSpawnDist() : 0);
                    if(SpawnDest.bIsBeyondSpawnDistance && NotEqual_InterfaceInterface(MySpawner, (none)))
                    {
                        DestDist = VSize(CurrentDestination.Location - NearestViewLocation);
                        if(CurrentDestination.bIsBeyondSpawnDistance || DestDist > MaxSpawnDist)
                        {
                            TryPct = ((DestDist < VSizeSq(SpawnDest.Location - NearestViewLocation)) ? 1 : 0);                            
                        }
                        else
                        {
                            StartDist = VSize(SpawnDest.Location - NearestViewLocation);
                            if(StartDist > DestDist)
                            {
                                TryPct = 1 - ((MaxSpawnDist - DestDist) / (StartDist - DestDist));
                                TryPct *= 0.9;                                
                            }
                            else
                            {
                                TryPct = 0;
                            }
                        }                        
                    }
                    else
                    {
                        if(!SpawnDest.bWillBeVisible)
                        {
                            TryPct = (0.5 * TryPct) + 0.5;                            
                        }
                        else
                        {
                            TryPct *= 0.9;
                        }
                    }
                    SpawnDestRadius = SpawnDest.GetDestinationRadius();
                    TravelDestRadius = ((CurrentDestination != none) ? CurrentDestination.GetDestinationRadius() : SpawnDestRadius);
                    TryLoc = GetAttemptedSpawnLocation(TryPct, SpawnDest.Location, SpawnDestRadius, CurrentDestination.Location, TravelDestRadius);
                    bVisibleTryLoc = false;
                    if(NavigationHandle != none)
                    {
                        bFoundOption = false;
                        CheckCnt = 0;
                        MaxCheckCnt = 4;
                        J0x715:

                        if((CheckCnt < MaxCheckCnt) && !bFoundOption)
                        {
                            TryOptions.Length = 0;
                            NavigationHandle.GetValidPositionsForBox(TryLoc, 128, GetCollisionExtent(), false, TryOptions, 1);
                            OptionIdx = 0;
                            J0x798:

                            if(OptionIdx < TryOptions.Length)
                            {
                                bVisibleOption = false;
                                PlayerIdx = 0;
                                J0x7C7:

                                if(PlayerIdx < PlayerInfo.Length)
                                {
                                    HitActor = Trace(HitLocation, HitNormal, PlayerInfo[PlayerIdx].ViewLocation, TryOptions[OptionIdx], false);
                                    if(HitActor == none)
                                    {
                                        bVisibleOption = true;
                                        goto J0x86A;                                        
                                    }
                                    ++ PlayerIdx;
                                    goto J0x7C7;
                                }
                                J0x86A:

                                if(!bVisibleOption)
                                {
                                    bFoundOption = true;
                                    TryLoc = TryOptions[OptionIdx];
                                    goto J0x8B3;
                                }
                                ++ OptionIdx;
                                goto J0x798;
                            }
                            J0x8B3:

                            if(!bFoundOption)
                            {
                                TryPct *= 0.5;
                                TryLoc = GetAttemptedSpawnLocation(TryPct, SpawnDest.Location, SpawnDestRadius, CurrentDestination.Location, TravelDestRadius);
                                ++ CheckCnt;
                            }
                            goto J0x715;
                        }
                        bVisibleTryLoc = !bFoundOption;
                    }
                    if(!bVisibleTryLoc)
                    {
                        SpawnOffset = TryLoc;
                        SetLocation(TryLoc);
                        if((SpawnDest.bWillBeVisible && CurrentDestination.bIsVisible) && FRand() < 0.5)
                        {
                            PreviousDestination = CurrentDestination;
                            CurrentDestination.DecrementCustomerCount(self);
                            CurrentDestination = none;
                            BehaviorDestination = none;
                            SetCurrentDestination(SpawnDest);
                        }                        
                    }
                    else
                    {
                        PlayerIdx = 0;
                        J0xA4E:

                        if(PlayerIdx < PlayerInfo.Length)
                        {
                            HitActor = Trace(HitLocation, HitNormal, Location, PlayerInfo[PlayerIdx].ViewLocation, false);
                            if(HitActor == none)
                            {
                                SetLocation(SpawnDest.Location);
                                goto J0xAF9;
                            }
                            ++ PlayerIdx;
                            goto J0xA4E;
                        }
                    }
                    J0xAF9:
                    
                }
                else
                {
                    TryLoc = SpawnOffset;
                    TryPct = (2 * FRand()) - 1;
                    YAdjust = TryLoc + ((TryPct * AvoidOtherRadius) * Normal((CurrentDestination.Location - SpawnDest.Location) Cross vect(0, 0, 1)));
                    HitActor = Trace(HitLocation, HitNormal, YAdjust, CurrentDestination.Location, false);
                    if(HitActor == none)
                    {
                        TryLoc = YAdjust;
                    }
                    HitActor = Trace(HitLocation, HitNormal, TryLoc - vect(0, 0, 250), TryLoc, false);
                    if(HitActor != none)
                    {
                        TryLoc.Z = (HitLocation.Z + GroundOffset) + 5;
                    }
                    SetLocation(TryLoc);
                }
            }
        }
    }
    LastKnownGoodPosition = Location;
    LastKnownGoodPosition.Z += EyeZOffset;
    if(SpawnBehaviors.Length > 0)
    {
        PlaySpawnBehavior();
    }
    UpdateIntermediatePoint();
    InitDebugColor();
}

simulated function OnPlayAgentAnimation(SeqAct_PlayAgentAnimation Action)
{
    CurrentDestination.ReachedDestination(self);
}

simulated event PlayIdleAnimation();

simulated event StopIdleAnimation();

event HandlePotentialAgentEncounter()
{
    if(CurrentBehavior == none)
    {
        PickBehaviorFrom(EncounterAgentBehaviors);
    }
}

function PlaySpawnBehavior()
{
    if(CurrentBehavior == none)
    {
        PickBehaviorFrom(SpawnBehaviors);
    }
}

event NotifySeePlayer(PlayerController PC)
{
    local bool bFoundBehavior;
    local int I;

    bWantsSeePlayerNotification = false;
    if(CurrentBehavior == none)
    {
        if(!PickBehaviorFrom(SeePlayerBehaviors, PC.Pawn.Location))
        {
            I = 0;
            J0x71:

            if(I < SeePlayerBehaviors.Length)
            {
                if(!SeePlayerBehaviors[I].bNeverRepeat || !SeePlayerBehaviors[I].bHasBeenUsed)
                {
                    bFoundBehavior = true;
                    goto J0x100;
                }
                ++ I;
                goto J0x71;
            }
            J0x100:

            if(!bFoundBehavior)
            {
                SeePlayerInterval = 0;
            }
        }
    }
    if(SeePlayerInterval > 0)
    {
        SetTimer((0.8 + (0.4 * FRand())) * SeePlayerInterval, false, 'ResetSeePlayer');
    }
}

function TryRandomBehavior()
{
    local bool bFoundBehavior;
    local int I;

    if((CurrentBehavior == none) && (WorldInfo.TimeSeconds - LastRenderTime) < 0.1)
    {
        if(!PickBehaviorFrom(RandomBehaviors))
        {
            I = 0;
            J0x68:

            if(I < RandomBehaviors.Length)
            {
                if(!RandomBehaviors[I].bNeverRepeat || !RandomBehaviors[I].bHasBeenUsed)
                {
                    bFoundBehavior = true;
                    goto J0xF7;
                }
                ++ I;
                goto J0x68;
            }
            J0xF7:

            if(!bFoundBehavior)
            {
                ClearTimer('TryRandomBehavior');
            }
        }
    }
}

function ResetSeePlayer()
{
    bWantsSeePlayerNotification = true;
}

event ActivateBehavior(GameCrowdAgentBehavior NewBehaviorArchetype, optional Actor LookAtActor)
{
    StopBehavior();
    if(NewBehaviorArchetype == none)
    {
        WarnInternal((("Illegal behavior " $ string(NewBehaviorArchetype)) $ " for ") $ string(self));
        return;
    }
    SetCurrentBehavior(NewBehaviorArchetype);
    if(LookAtActor != none)
    {
        CurrentBehavior.ActionTarget = LookAtActor;
    }
    if(CurrentBehavior != none)
    {
        CurrentBehavior.InitBehavior(self);
    }
}

function ActivateInstancedBehavior(GameCrowdAgentBehavior NewBehaviorObject)
{
    StopBehavior();
    CurrentBehavior = NewBehaviorObject;
    CurrentBehavior.InitBehavior(self);
}

event HandleBehaviorEvent(GameCrowdAgentBehavior.ECrowdBehaviorEvent EventType, Actor InInstigator, bool bViralCause, bool bPropagateViralFlag)
{
    local bool bActivatedBehavior;

    switch(EventType)
    {
        case 1:
            bActivatedBehavior = PickBehaviorFrom(SpawnBehaviors);
            break;
        case 2:
            bActivatedBehavior = PickBehaviorFrom(RandomBehaviors);
            break;
        case 3:
            bActivatedBehavior = PickBehaviorFrom(SeePlayerBehaviors);
            break;
        case 4:
            bActivatedBehavior = PickBehaviorFrom(EncounterAgentBehaviors);
            break;
        case 5:
            bActivatedBehavior = PickBehaviorFrom(TakeDamageBehaviors);
            break;
        case 6:
            bActivatedBehavior = PickBehaviorFrom(GroupWaitingBehaviors);
            break;
        case 7:
            bActivatedBehavior = PickBehaviorFrom(UneasyBehaviors);
            break;
        case 8:
            bActivatedBehavior = PickBehaviorFrom(AlertBehaviors);
            break;
        case 9:
            bActivatedBehavior = PickBehaviorFrom(PanicBehaviors);
            break;
        default:
            break;
    }
    if(bActivatedBehavior && CurrentBehavior != none)
    {
        if(bPropagateViralFlag)
        {
            CurrentBehavior.bIsViralBehavior = bViralCause;
        }
        CurrentBehavior.ActivatedBy(InInstigator);
    }
}

event StopBehavior()
{
    if(CurrentBehavior != none)
    {
        CurrentBehavior.StopBehavior();
        CurrentBehavior = none;
    }
}

// Export UGameCrowdAgent::execSetCurrentBehavior(FFrame&, void* const)
native final function SetCurrentBehavior(GameCrowdAgentBehavior BehaviorArchetype);

// Export UGameCrowdAgent::execIsIdle(FFrame&, void* const)
native function bool IsIdle();

simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
{
    local Vector HitNormal;
    local float Radius;

    Radius = 20;
    if(Trace(out_CamLoc, HitNormal, Location - ((vector(out_CamRot) * Radius) * float(20)), Location, false) == none)
    {
        out_CamLoc = Location - ((vector(out_CamRot) * Radius) * float(20));
    }
    return false;
}

event UpdateIntermediatePoint(optional Actor DestinationActor)
{
    if(DestinationActor == none)
    {
        if(CurrentBehavior != none)
        {
            DestinationActor = CurrentBehavior.GetDestinationActor();            
        }
        else
        {
            DestinationActor = CurrentDestination;
        }
        if(DestinationActor == none)
        {
            return;
        }
    }
    if(!bUseNavMeshPathing)
    {
        IntermediatePoint = DestinationActor.Location;        
    }
    else
    {
        IntermediatePoint = GeneratePathToActor(DestinationActor);
        if(IntermediatePoint == vect(0, 0, 0))
        {
            IntermediatePoint = DestinationActor.Location;
        }
    }
}

// Export UGameCrowdAgent::execPlayDeath(FFrame&, void* const)
native function PlayDeath(Vector KillMomentum);

simulated event FireDeathEvent()
{
    TriggerEventClass(Class'SeqEvent_Death', self);
}

function TakeDamage(int DamageAmount, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    if(Health > 0)
    {
        Health -= DamageAmount;
        if(Health <= 0)
        {
            Health = -1;
            SetCollision(false, false, false);
            PlayDeath((Normal(Momentum) * DamageType.default.KDamageImpulse) + (vect(0, 0, 1) * DamageType.default.KDeathUpKick));            
        }
        else
        {
            if(CurrentBehavior == none)
            {
                PickBehaviorFrom(TakeDamageBehaviors);
            }
        }
    }
}

event OverlappedActorEvent(Actor A);

event InitNavigationHandle()
{
    if(NavigationHandleClass != none)
    {
        NavigationHandle = new (self) NavigationHandleClass;
    }
}

event Vector GeneratePathToActor(Actor Goal, optional float WithinDistance, optional bool bAllowPartialPath)
{
    local Vector NextDest;

    LastPathingAttempt = WorldInfo.TimeSeconds;
    NextDest = Goal.Location;
    if(NavigationHandle == none)
    {
        InitNavigationHandle();
    }
    if((NavigationHandle != none) && !NavigationHandle.ActorReachable(Goal))
    {
        Class'NavMeshPath_Toward'.static.TowardGoal(NavigationHandle, Goal);
        Class'NavMeshGoal_At'.static.AtActor(NavigationHandle, Goal, WithinDistance, bAllowPartialPath);
        if(NavigationHandle.FindPath())
        {
            NavigationHandle.GetNextMoveLocation(NextDest, SearchExtent.X);
        }
        NavigationHandle.ClearConstraints();
    }
    return NextDest;
}

// Export UGameCrowdAgent::execNativePostRenderFor(FFrame&, void* const)
native simulated function NativePostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir);

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir)
{
    local float NameXL, TextXL, BehavXL, TextYL, YL, XL;

    local Vector ScreenLoc;
    local string ScreenName, DestString, BehaviorString;
    local FontRenderInfo FontInfo;

    ScreenLoc = Canvas.Project(Location + BeaconOffset);
    if((((ScreenLoc.X < float(0)) || ScreenLoc.X >= Canvas.ClipX) || ScreenLoc.Y < float(0)) || ScreenLoc.Y >= Canvas.ClipY)
    {
        return;
    }
    ScreenName = "Agent" @ string(self);
    if(MyGroup != none)
    {
        ScreenName = (ScreenName $ " Group ") $ string(MyGroup);
        DrawDebugLine(MyGroup.Members[0].Location, Location, 255, 0, 255, false);
    }
    ScreenName = (ScreenName @ "Last Rendered") @ string(WorldInfo.TimeSeconds - LastRenderTime);
    Canvas.StrLen(ScreenName, NameXL, TextYL);
    XL = FMax(XL, NameXL);
    YL += TextYL;
    DestString = GetDestString();
    Canvas.StrLen(DestString, TextXL, TextYL);
    XL = FMax(XL, TextXL);
    YL += TextYL;
    BehaviorString = GetBehaviorString();
    Canvas.StrLen(BehaviorString, BehavXL, TextYL);
    XL = FMax(XL, BehavXL);
    YL += TextYL;
    Canvas.SetPos(ScreenLoc.X - (0.7 * XL), ScreenLoc.Y - (1.8 * YL));
    Canvas.DrawTile(BeaconTexture, 1.4 * XL, 1.2 * YL, 0, 0, 31, 31, BeaconColor);
    Canvas.DrawColor = Class'HUD'.default.GreenColor;
    Canvas.SetPos(ScreenLoc.X - (0.5 * NameXL), ScreenLoc.Y - (1.7 * YL));
    FontInfo.bClipText = true;
    Canvas.DrawText(ScreenName, true,,, FontInfo);
    Canvas.SetPos(ScreenLoc.X - (0.5 * TextXL), (ScreenLoc.Y - (1.7 * YL)) + (1.1 * TextYL));
    FontInfo.bClipText = true;
    Canvas.DrawText(DestString, true,,, FontInfo);
    Canvas.SetPos(ScreenLoc.X - (0.5 * BehavXL), (ScreenLoc.Y - (1.7 * YL)) + (2.2 * TextYL));
    FontInfo.bClipText = true;
    Canvas.DrawText(BehaviorString, true,,, FontInfo);
    if(CurrentDestination != none)
    {
        DrawDebugLine(Location, CurrentDestination.Location, 255, 255, 0, false);
    }
}

function string GetDestString()
{
    local string DestString;

    DestString = ((CurrentDestination == none) ? "NO DESTINATION" : "" $ string(CurrentDestination));
    if(IsIdle())
    {
        DestString = (((CurrentDestination != none) && CurrentDestination.ReachedByAgent(self, Location, true)) ? "Idle at " $ DestString : "Idle en route to " $ DestString);        
    }
    else
    {
        DestString = "Moving to " $ DestString;
    }
    return DestString;
}

function string GetBehaviorString()
{
    local string BehaviorString;

    if(CurrentBehavior != none)
    {
        BehaviorString = CurrentBehavior.GetBehaviorString();        
    }
    else
    {
        BehaviorString = "Moving between Destinations";
    }
    return BehaviorString;
}

simulated function InitDebugColor()
{
    DebugAgentColor.G = byte(50 + Rand(205));
}

defaultproperties
{
    Health=100
    DeadBodyDuration=10
    begin object name=MyLightEnvironment class=DynamicLightEnvironmentComponent
        MinTimeBetweenFullUpdates=2
    object end
    // Reference: DynamicLightEnvironmentComponent'Default__GameCrowdAgent.MyLightEnvironment'
    LightEnvironment=MyLightEnvironment
    bUniformScale=true
    bUseNavMeshPathing=true
    bPreferVisibleDestinationOnSpawn=true
    ConformTraceDist=35
    ConformTraceInterval=10
    CurrentConformTraceInterval=10
    AwareRadius=256
    AvoidOtherRadius=32
    AvoidOtherSampleList(0)=(RotOffset=0,NumMagSamples=10,bFallbackOnly=false)
    AvoidOtherSampleList(1)=(RotOffset=2048,NumMagSamples=8,bFallbackOnly=false)
    AvoidOtherSampleList(2)=(RotOffset=-2048,NumMagSamples=8,bFallbackOnly=false)
    AvoidOtherSampleList(3)=(RotOffset=4096,NumMagSamples=6,bFallbackOnly=false)
    AvoidOtherSampleList(4)=(RotOffset=-4096,NumMagSamples=6,bFallbackOnly=false)
    AvoidOtherSampleList(5)=(RotOffset=6144,NumMagSamples=4,bFallbackOnly=false)
    AvoidOtherSampleList(6)=(RotOffset=-6144,NumMagSamples=4,bFallbackOnly=false)
    AvoidOtherSampleList(7)=(RotOffset=8192,NumMagSamples=4,bFallbackOnly=false)
    AvoidOtherSampleList(8)=(RotOffset=-8192,NumMagSamples=4,bFallbackOnly=false)
    AvoidOtherSampleList(9)=(RotOffset=12288,NumMagSamples=2,bFallbackOnly=false)
    AvoidOtherSampleList(10)=(RotOffset=-12288,NumMagSamples=2,bFallbackOnly=false)
    AvoidOtherSampleList(11)=(RotOffset=16384,NumMagSamples=1,bFallbackOnly=true)
    AvoidOtherSampleList(12)=(RotOffset=-16384,NumMagSamples=1,bFallbackOnly=true)
    AvoidOtherSampleList(13)=(RotOffset=24576,NumMagSamples=1,bFallbackOnly=true)
    AvoidOtherSampleList(14)=(RotOffset=-24576,NumMagSamples=1,bFallbackOnly=true)
    AvoidOtherSampleList(15)=(RotOffset=32768,NumMagSamples=1,bFallbackOnly=true)
    PENALTY_COEFF_ANGLETOGOAL=2.5
    PENALTY_COEFF_ANGLETOVEL=1
    PENALTY_COEFF_MAG=1
    MIN_PENALTY_THRESHOLD=0.05
    MaxPathLaneValue=10
    ExtraPathCost=50
    RotateToTargetSpeed=30000
    MaxYawRate=40000
    MeshMinScale3D=(X=1,Y=1,Z=1)
    MeshMaxScale3D=(X=1,Y=1,Z=1)
    EyeZOffset=40
    ProximityLODDist=2000
    VisibleProximityLODDist=5000
    GroundOffset=86
    SearchExtent=(X=32,Y=32,Z=86)
    NavigationHandleClass=Class'Engine.NavigationHandle'
    WalkableFloorZ=0.7
    NotVisibleLifeSpan=10
    MaxWalkingSpeed=100
    MaxRunningSpeed=300
    BeaconMaxDist=1500
    BeaconOffset=(X=0,Y=0,Z=140)
    BeaconTexture=Texture2D'EngineResources.WhiteSquareTexture'
    BeaconColor=(R=0.5,G=0.5,B=0.5,A=0.5)
    RandomBehaviorInterval=30
    ReachThreshold=1
    DesiredGroupRadius=200
    MaxLOSLifeDistanceSq=4E+08
    begin object name=MyLightEnvironment class=DynamicLightEnvironmentComponent
        MinTimeBetweenFullUpdates=2
    object end
    // Reference: DynamicLightEnvironmentComponent'Default__GameCrowdAgent.MyLightEnvironment'
    Components(0)=MyLightEnvironment
    Physics=EPhysics.PHYS_Interpolating
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bCollideActors=true
    bProjTarget=true
    bNoEncroachCheck=true
    SupportedEvents=/* Array type was not detected. */
}