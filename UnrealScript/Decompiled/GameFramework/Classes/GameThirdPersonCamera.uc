/*******************************************************************************
 * GameThirdPersonCamera generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameThirdPersonCamera extends GameCameraBase
    native(Camera);

struct native CamFocusPointParams
{
    /** Actor to focus on. */
    var() Actor FocusActor;
    /** Bone name to focus on.  Ignored if FocusActor is None or has no SkeletalMeshComponent */
    var() name FocusBoneName;
    /** Focus point location in world space.  Ignored if FocusActor is not None. */
    var() Vector FocusWorldLoc;
    /** If >0, FOV to force upon camera while looking at this point (degrees) */
    var() float CameraFOV;
    /** Interpolation speed (X=slow/focus loc moving, Y=fast/focus loc steady/blending out) */
    var() Vector2D InterpSpeedRange;
    /** FOV where target is considered in focus, no correction is made.  X is yaw tolerance, Y is pitch tolerance. */
    var() Vector2D InFocusFOV;
    /** If FALSE, focus only if point roughly in view; if TRUE, focus no matter where player is looking */
    var() bool bAlwaysFocus;
    /** If TRUE, camera adjusts to keep player in view, if FALSE the camera remains fixed and just rotates in place */
    var() bool bAdjustCamera;
    /** If TRUE, ignore world trace to find a good spot */
    var() bool bIgnoreTrace;
    /** Offsets the pitch.  e.g. 20 will look 20 degrees above the target */
    var() float FocusPitchOffsetDeg;

    structdefaultproperties
    {
        FocusActor=none
        FocusBoneName=None
        FocusWorldLoc=(X=0,Y=0,Z=0)
        CameraFOV=0
        InterpSpeedRange=(X=0,Y=0)
        InFocusFOV=(X=0,Y=0)
        bAlwaysFocus=false
        bAdjustCamera=false
        bIgnoreTrace=false
        FocusPitchOffsetDeg=0
    }
};

struct native PenetrationAvoidanceFeeler
{
    /** rotator describing deviance from main ray */
    var() Rotator AdjustmentRot;
    /** how much this feeler affects the final position if it hits the world */
    var() float WorldWeight;
    /** how much this feeler affects the final position if it hits a Pawn (setting to 0 will not attempt to collide with pawns at all) */
    var() float PawnWeight;
    /** extent to use for collision when firing this ray */
    var() Vector Extent;
    /** minimum frame interval between traces with this feeler if nothing was hit last frame */
    var() int TraceInterval;
    var transient int FramesUntilNextTrace;

    structdefaultproperties
    {
        AdjustmentRot=(Pitch=0,Yaw=0,Roll=0)
        WorldWeight=0
        PawnWeight=0
        Extent=(X=0,Y=0,Z=0)
        TraceInterval=0
        FramesUntilNextTrace=0
    }
};

var float WorstLocBlockedPct;
/** camera extent scale to use when calculating penetration for this segment */
var() float WorstLocPenetrationExtentScale;
/** Time to transition from blocked location to ideal position, after camera collision with geometry. */
var() float PenetrationBlendOutTime;
/** Time to transition from ideal location to blocked position, after camera collision with geometry. (used only by predictive feelers) */
var() float PenetrationBlendInTime;
var protected float PenetrationBlockedPct;
/** camera extent scale to use when calculating penetration for this segment */
var() float PenetrationExtentScale;
var transient Vector LastActualOriginOffset;
var transient Vector LastActualCameraOrigin;
var transient Rotator LastActualCameraOriginRot;
/** origin offset interpolation speed */
var() float OriginOffsetInterpSpeed;
var transient Vector LastViewOffset;
var transient float LastCamFOV;
var transient Vector LastIdealCameraOrigin;
var transient Rotator LastIdealCameraOriginRot;
/** Base camera position when walking */
var() protected editinline GameThirdPersonCameraMode ThirdPersonCamDefault;
var() protected class<GameThirdPersonCameraMode> ThirdPersonCamDefaultClass;
/** Current GearCam Mode */
var() editinline transient GameThirdPersonCameraMode CurrentCamMode;
var transient float LastHeightAdjustment;
var transient float LastPitchAdjustment;
var transient float LastYawAdjustment;
var transient float LeftoverPitchAdjustment;
/** move back pct based on move up */
var(Focus) float Focus_BackOffStrength;
/** Z offset step for every try */
var(Focus) float Focus_StepHeightAdjustment;
/** number of tries to have focus in view */
var(Focus) int Focus_MaxTries;
/** time it takes for fast interpolation speed to kick in */
var(Focus) float Focus_FastAdjustKickInTime;
var protected transient float LastFocusChangeTime;
var protected transient Vector ActualFocusPointWorldLoc;
var protected transient Vector LastFocusPointLoc;
/** current focus point */
var(Focus) CamFocusPointParams FocusPoint;
var bool bFocusPointSet;
var protected transient bool bFocusPointSuccessful;
var bool bDoingACameraTurn;
var protected bool bTurnAlignTargetWhenFinished;
/** toggles debug mode */
var() bool bDrawDebug;
var transient bool bDoingDirectLook;
/** Change in camera mode happened this frame - reset on first call to PlayerUpdateCamera */
var(Debug) bool bDebugChangedCameraMode;
var transient bool bDoSeamlessPivotTransition;
var protected float TurnCurTime;
var protected int TurnStartAngle;
var protected int TurnEndAngle;
var protected float TurnTotalTime;
var protected float TurnDelay;
var protected transient int LastPostCamTurnYaw;
var transient int DirectLookYaw;
var() float DirectLookInterpSpeed;
var() float WorstLocInterpSpeed;
var transient Vector LastWorstLocationLocal;
var transient Vector LastWorstLocation;
var transient Vector LastPreModifierCameraLoc;
var transient Rotator LastPreModifierCameraRot;
var() array<PenetrationAvoidanceFeeler> PenetrationAvoidanceFeelers;
var protectedwrite transient Vector LastOffsetAdjustment;

protected function GameThirdPersonCameraMode CreateCameraMode(class<GameThirdPersonCameraMode> ModeClass)
{
    local GameThirdPersonCameraMode NewMode;

    NewMode = new (self) ModeClass;
    NewMode.ThirdPersonCam = self;
    NewMode.Init();
    return NewMode;
}

function Reset()
{
    bResetCameraInterpolation = true;
}

function Init()
{
    if(ThirdPersonCamDefault == none)
    {
        ThirdPersonCamDefault = CreateCameraMode(ThirdPersonCamDefaultClass);
    }
}

event float GetDesiredFOV(Pawn ViewedPawn)
{
    if((bFocusPointSet && FocusPoint.CameraFOV > 0) && bFocusPointSuccessful)
    {
        return FocusPoint.CameraFOV;
    }
    return CurrentCamMode.GetDesiredFOV(ViewedPawn);
}

function UpdateCamera(Pawn P, GamePlayerCamera CameraActor, float DeltaTime, out TViewTarget OutVT)
{
    if((P == none) && OutVT.Target != none)
    {
        OutVT.Target.GetActorEyesViewPoint(OutVT.POV.Location, OutVT.POV.Rotation);
        PlayerCamera.ApplyCameraModifiers(DeltaTime, OutVT.POV);        
    }
    else
    {
        if((P != none) && P.CalcCamera(DeltaTime, OutVT.POV.Location, OutVT.POV.Rotation, OutVT.POV.FOV))
        {
            PlayerCamera.ApplyCameraModifiers(DeltaTime, OutVT.POV);
            return;            
        }
        else
        {
            UpdateCameraMode(P);
            if(CurrentCamMode != none)
            {
                PlayerUpdateCamera(P, CameraActor, DeltaTime, OutVT);
                CurrentCamMode.UpdatePostProcess(OutVT, DeltaTime);                
            }
            else
            {
                WarnInternal(string(GetFuncName()) @ "CameraMode == None!!!");
            }
        }
    }
    bResetCameraInterpolation = false;
}

// Export UGameThirdPersonCamera::execPlayerUpdateCamera(FFrame&, void* const)
protected native function PlayerUpdateCamera(Pawn P, GamePlayerCamera CameraActor, float DeltaTime, out TViewTarget OutVT);

function BeginTurn(int StartAngle, int EndAngle, float TimeSec, optional float DelaySec, optional bool bAlignTargetWhenFinished)
{
    if(PlayerCamera.bUseClientSideCameraUpdates && !PlayerCamera.PCOwner.IsLocalPlayerController())
    {
        return;
    }
    bDoingACameraTurn = true;
    TurnTotalTime = TimeSec;
    TurnDelay = DelaySec;
    TurnCurTime = 0;
    TurnStartAngle = StartAngle;
    TurnEndAngle = EndAngle;
    bTurnAlignTargetWhenFinished = bAlignTargetWhenFinished;
}

// Export UGameThirdPersonCamera::execEndTurn(FFrame&, void* const)
native function EndTurn();

function AdjustTurn(int AngleOffset)
{
    TurnStartAngle += AngleOffset;
    TurnEndAngle += AngleOffset;
}

function SetFocusOnLoc(Vector FocusWorldLoc, Vector2D InterpSpeedRange, Vector2D InFocusFOV, optional float CameraFOV, optional bool bAlwaysFocus, optional bool bAdjustCamera, optional bool bIgnoreTrace, optional float FocusPitchOffsetDeg)
{
    if((((LastPitchAdjustment != float(0)) || LastYawAdjustment != float(0)) && !bAdjustCamera) && FocusPoint.bAdjustCamera)
    {
        ClearFocusPoint(true);
    }
    FocusPoint.FocusWorldLoc = FocusWorldLoc;
    FocusPoint.FocusActor = none;
    FocusPoint.FocusBoneName = 'None';
    FocusPoint.InterpSpeedRange = InterpSpeedRange;
    FocusPoint.InFocusFOV = InFocusFOV;
    FocusPoint.CameraFOV = CameraFOV;
    FocusPoint.bAlwaysFocus = bAlwaysFocus;
    FocusPoint.bAdjustCamera = bAdjustCamera;
    FocusPoint.bIgnoreTrace = bIgnoreTrace;
    FocusPoint.FocusPitchOffsetDeg = FocusPitchOffsetDeg;
    bFocusPointSet = true;
    LastFocusChangeTime = PlayerCamera.WorldInfo.TimeSeconds;
    LastFocusPointLoc = GetActualFocusLocation();
    bFocusPointSuccessful = false;
}

function SetFocusOnActor(Actor FocusActor, name FocusBoneName, Vector2D InterpSpeedRange, Vector2D InFocusFOV, optional float CameraFOV, optional bool bAlwaysFocus, optional bool bAdjustCamera, optional bool bIgnoreTrace, optional float FocusPitchOffsetDeg)
{
    if((((LastPitchAdjustment != float(0)) || LastYawAdjustment != float(0)) && !bAdjustCamera) && FocusPoint.bAdjustCamera)
    {
        ClearFocusPoint(true);
    }
    FocusPoint.FocusActor = FocusActor;
    FocusPoint.FocusBoneName = FocusBoneName;
    FocusPoint.InterpSpeedRange = InterpSpeedRange;
    FocusPoint.InFocusFOV = InFocusFOV;
    FocusPoint.CameraFOV = CameraFOV;
    FocusPoint.bAlwaysFocus = bAlwaysFocus;
    FocusPoint.bAdjustCamera = bAdjustCamera;
    FocusPoint.bIgnoreTrace = bIgnoreTrace;
    FocusPoint.FocusPitchOffsetDeg = FocusPitchOffsetDeg;
    bFocusPointSet = true;
    LastFocusChangeTime = PlayerCamera.WorldInfo.TimeSeconds;
    LastFocusPointLoc = GetActualFocusLocation();
    bFocusPointSuccessful = false;
}

function Actor GetFocusActor()
{
    return ((bFocusPointSet) ? FocusPoint.FocusActor : none);
}

function ClearFocusPoint(optional bool bLeaveCameraRotation)
{
    bFocusPointSet = false;
    if(bLeaveCameraRotation && FocusPoint.bAdjustCamera)
    {
        LastPitchAdjustment = 0;
        LastYawAdjustment = 0;
        LeftoverPitchAdjustment = 0;
        if(PlayerCamera.PCOwner != none)
        {
            PlayerCamera.PCOwner.SetRotation(LastPreModifierCameraRot);
        }
    }
}

protected event UpdateFocusPoint(Pawn P)
{
    if(bDoingACameraTurn)
    {
        ClearFocusPoint();        
    }
    else
    {
        if((CurrentCamMode == none) || CurrentCamMode.SetFocusPoint(P) == false)
        {
            ClearFocusPoint();
        }
    }
    if(bFocusPointSet)
    {
        LastFocusPointLoc = ActualFocusPointWorldLoc;
        ActualFocusPointWorldLoc = GetActualFocusLocation();
    }
}

protected function Vector GetActualFocusLocation()
{
    local Vector FocusLoc;
    local editinline SkeletalMeshComponent ComponentIt;

    if(FocusPoint.FocusActor != none)
    {
        FocusLoc = FocusPoint.FocusActor.Location;
        if(FocusPoint.FocusBoneName != 'None')
        {
            foreach FocusPoint.FocusActor.ComponentList(Class'SkeletalMeshComponent', ComponentIt)
            {
                if(ComponentIt.MatchRefBone(FocusPoint.FocusBoneName) != -1)
                {
                    FocusLoc = ComponentIt.GetBoneLocation(FocusPoint.FocusBoneName);
                    break;
                }                
            }            
        }        
    }
    else
    {
        FocusLoc = FocusPoint.FocusWorldLoc;
    }
    return FocusLoc;
}

function AdjustFocusPointInterpolation(Rotator Delta)
{
    if(bFocusPointSet && FocusPoint.bAdjustCamera)
    {
        Delta = Normalize(Delta);
        LastYawAdjustment -= float(Delta.Yaw);
        LastPitchAdjustment -= float(Delta.Pitch);
    }
}

function GameThirdPersonCameraMode FindBestCameraMode(Pawn P)
{
    if(P != none)
    {
        return ThirdPersonCamDefault;
    }
    return none;
}

protected final function UpdateCameraMode(Pawn P)
{
    local GameThirdPersonCameraMode NewCamMode;

    NewCamMode = FindBestCameraMode(P);
    if(NewCamMode != CurrentCamMode)
    {
        if(CurrentCamMode != none)
        {
            CurrentCamMode.OnBecomeInActive(P, NewCamMode);
        }
        if(NewCamMode != none)
        {
            NewCamMode.OnBecomeActive(P, CurrentCamMode);
        }
        bDebugChangedCameraMode = true;
        CurrentCamMode = NewCamMode;
    }
}

function ProcessViewRotation(float DeltaTime, Actor ViewTarget, out Rotator out_ViewRotation, out Rotator out_DeltaRot)
{
    if(CurrentCamMode != none)
    {
        CurrentCamMode.ProcessViewRotation(DeltaTime, ViewTarget, out_ViewRotation, out_DeltaRot);
    }
}

function OnBecomeActive(GameCameraBase OldCamera)
{
    if(!PlayerCamera.bInterpolateCamChanges)
    {
        Reset();
    }
    super.OnBecomeActive(OldCamera);
}

event ModifyPostProcessSettings(out PostProcessSettings PP)
{
    if(CurrentCamMode != none)
    {
        CurrentCamMode.ModifyPostProcessSettings(PP);
    }
}

function ResetInterpolation()
{
    super.ResetInterpolation();
    LastHeightAdjustment = 0;
    LastYawAdjustment = 0;
    LastPitchAdjustment = 0;
    LeftoverPitchAdjustment = 0;
}

defaultproperties
{
    WorstLocPenetrationExtentScale=1
    PenetrationBlendOutTime=0.15
    PenetrationBlendInTime=0.1
    PenetrationBlockedPct=1
    PenetrationExtentScale=1
    OriginOffsetInterpSpeed=8
    ThirdPersonCamDefaultClass=Class'GameThirdPersonCameraMode_Default'
    Focus_BackOffStrength=0.33
    Focus_StepHeightAdjustment=64
    Focus_MaxTries=4
    Focus_FastAdjustKickInTime=0.5
    DirectLookInterpSpeed=6
    WorstLocInterpSpeed=8
    PenetrationAvoidanceFeelers(0)=(AdjustmentRot=(Pitch=0,Yaw=0,Roll=0),WorldWeight=1,PawnWeight=1,Extent=(X=14,Y=14,Z=14),TraceInterval=0,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(1)=(AdjustmentRot=(Pitch=0,Yaw=3072,Roll=0),WorldWeight=0.75,PawnWeight=0.75,Extent=(X=0,Y=0,Z=0),TraceInterval=3,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(2)=(AdjustmentRot=(Pitch=0,Yaw=-3072,Roll=0),WorldWeight=0.75,PawnWeight=0.75,Extent=(X=0,Y=0,Z=0),TraceInterval=3,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(3)=(AdjustmentRot=(Pitch=0,Yaw=6144,Roll=0),WorldWeight=0.5,PawnWeight=0.5,Extent=(X=0,Y=0,Z=0),TraceInterval=5,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(4)=(AdjustmentRot=(Pitch=0,Yaw=-6144,Roll=0),WorldWeight=0.5,PawnWeight=0.5,Extent=(X=0,Y=0,Z=0),TraceInterval=5,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(5)=(AdjustmentRot=(Pitch=3640,Yaw=0,Roll=0),WorldWeight=1,PawnWeight=1,Extent=(X=0,Y=0,Z=0),TraceInterval=4,FramesUntilNextTrace=0)
    PenetrationAvoidanceFeelers(6)=(AdjustmentRot=(Pitch=-3640,Yaw=0,Roll=0),WorldWeight=0.5,PawnWeight=0.5,Extent=(X=0,Y=0,Z=0),TraceInterval=4,FramesUntilNextTrace=0)
    bResetCameraInterpolation=true
}