/*******************************************************************************
 * MobileMenuObject generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MobileMenuObject extends Object
    native;

struct native UVCoords
{
    var() bool bCustomCoords;
    /** The UV coords. */
    var() float U;
    /** The UV coords. */
    var() float V;
    /** The UV coords. */
    var() float UL;
    /** The UV coords. */
    var() float VL;

    structdefaultproperties
    {
        bCustomCoords=false
        U=0
        V=0
        UL=0
        VL=0
    }
};

var transient bool bHasBeenInitialized;
var bool bRelativeLeft;
var bool bRelativeTop;
var bool bRelativeWidth;
var bool bRelativeHeight;
var bool bApplyGlobalScaleLeft;
var bool bApplyGlobalScaleTop;
var bool bApplyGlobalScaleWidth;
var bool bApplyGlobalScaleHeight;
var bool bHeightRelativeToWidth;
var bool bXOffsetIsActual;
var bool bYOffsetIsActual;
var bool bIsActive;
var bool bIsHidden;
var bool bIsTouched;
var bool bIsHighlighted;
var bool bTellSceneBeforeRendering;
var float Left;
var float Top;
var float Width;
var float Height;
var float InitialLeft;
var float InitialTop;
var float InitialWidth;
var float InitialHeight;
/** This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones */
var(Bounds) float AuthoredGlobalScale;
var float TopLeeway;
var float BottomLeeway;
var float LeftLeeway;
var float RightLeeway;
var float XOffset;
var float YOffset;
var string Tag;
var MobilePlayerInput InputOwner;
var float Opacity;
var MobileMenuScene OwnerScene;
var string RelativeToTag;
var MobileMenuObject RelativeTo;

event bool OnTouch(Engine.Interaction.ETouchType EventType, float TouchX, float TouchY, MobileMenuObject ObjectOver, float DeltaTime)
{
    return false;
}

event GetRealPosition(out float PosX, out float PosY)
{
    if(RelativeTo == none)
    {
        PosX = OwnerScene.Left + Left;
        PosY = OwnerScene.Top + Top;        
    }
    else
    {
        RelativeTo.GetRealPosition(PosX, PosY);
        PosX += Left;
        PosY += Top;
    }
}

function InitMenuObject(MobilePlayerInput PlayerInput, MobileMenuScene Scene, int ScreenWidth, int ScreenHeight, bool bIsFirstInitialization)
{
    local int X, Y, W, H, oX, oY,
	    RelativeIdx;

    InputOwner = PlayerInput;
    OwnerScene = Scene;
    if(Len(RelativeToTag) > 0)
    {
        RelativeIdx = int(RelativeToTag);
        if(string(RelativeIdx) != RelativeToTag)
        {
            RelativeTo = Scene.FindMenuObject(RelativeToTag);            
        }
        else
        {
            RelativeIdx += Scene.MenuObjects.Find(self;
            RelativeTo = Scene.MenuObjects[RelativeIdx];
        }
    }
    if(!bHasBeenInitialized || !bIsFirstInitialization)
    {
        if(bIsFirstInitialization)
        {
            InitialTop = Top;
            InitialLeft = Left;
            InitialWidth = Width;
            InitialHeight = Height;            
        }
        else
        {
            Top = InitialTop;
            Left = InitialLeft;
            Width = InitialWidth;
            Height = InitialHeight;
        }
        X = int(((bRelativeLeft) ? Scene.Width * Left : Left));
        Y = int(((bRelativeTop) ? Scene.Height * Top : Top));
        W = int(((bRelativeWidth) ? Scene.Width * Width : Width));
        if(bHeightRelativeToWidth)
        {
            H = int(float(W) * Height);            
        }
        else
        {
            H = int(((bRelativeHeight) ? Scene.Height * Height : Height));
        }
        if(bApplyGlobalScaleLeft)
        {
            X *= (Scene.GetGlobalScaleX() / AuthoredGlobalScale);
        }
        if(bApplyGlobalScaleTop)
        {
            Y *= (Scene.GetGlobalScaleY() / AuthoredGlobalScale);
        }
        if(bApplyGlobalScaleWidth)
        {
            W *= (Scene.GetGlobalScaleX() / AuthoredGlobalScale);
        }
        if(bApplyGlobalScaleHeight)
        {
            H *= (Scene.GetGlobalScaleY() / AuthoredGlobalScale);
        }
        if(RelativeTo == none)
        {
            if(X < 0)
            {
                X = int(Scene.Width + float(X));
            }
            if(Y < 0)
            {
                Y = int(Scene.Height + float(Y));
            }
            if(W < 0)
            {
                W = int(Scene.Width + float(W));
            }
            if(H < 0)
            {
                H = int(Scene.Height + float(H));
            }
        }
        Left = float(X);
        Top = float(Y);
        Width = float(W);
        Height = float(H);
        oX = int(((bXOffsetIsActual) ? XOffset : Width * XOffset));
        oY = int(((bYOffsetIsActual) ? YOffset : Height * YOffset));
        Left -= float(oX);
        Top -= float(oY);
    }
    bHasBeenInitialized = true;
}

function SetCanvasPos(Canvas Canvas, optional float OffsetX, optional float OffsetY)
{
    local float PosX, PosY;

    OffsetX = 0;
    OffsetY = 0;
    GetRealPosition(PosX, PosY);
    Canvas.SetPos(PosX + OffsetX, PosY + OffsetY);
}

function RenderObject(Canvas Canvas, float DeltaTime);

defaultproperties
{
    AuthoredGlobalScale=2
    Opacity=1
}