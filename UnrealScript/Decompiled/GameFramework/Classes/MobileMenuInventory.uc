/*******************************************************************************
 * MobileMenuInventory generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MobileMenuInventory extends MobileMenuObject;

struct RenderElementInfo
{
    var bool bIsDragItem;
    var int Index;

    structdefaultproperties
    {
        bIsDragItem=false
        Index=0
    }
};

struct DragElementInfo
{
    var bool bIsDragging;
    var int IndexFrom;
    var bool bIsOver;
    var int IndexOver;
    var bool bCanDropInOver;
    var Vector2D OrigTouch;
    var Vector2D CurTouch;
    var Engine.Interaction.ETouchType EventType;

    structdefaultproperties
    {
        bIsDragging=false
        IndexFrom=0
        bIsOver=false
        IndexOver=0
        bCanDropInOver=false
        OrigTouch=(X=0,Y=0)
        CurTouch=(X=0,Y=0)
        EventType=ETouchType.Touch_Began
    }
};

var array<MobileMenuElement> Slots;
var array<MobileMenuElement> Items;
var float SideLeewayPercent;
var RenderElementInfo CurrentElement;
var DragElementInfo Drag;
var Vector2D ScaleSize;
var bool bRenderDragItem;
var delegate<OnUpdateItemInSlot> __OnUpdateItemInSlot__Delegate;
var delegate<DoCanPutItemInSlot> __DoCanPutItemInSlot__Delegate;
var delegate<OnUpdateDrag> __OnUpdateDrag__Delegate;

delegate OnUpdateItemInSlot(MobileMenuInventory FromInv, int SlotIndex);

delegate bool DoCanPutItemInSlot(MobileMenuInventory FromInv, MobileMenuElement Item, MobileMenuElement ToSlot, int ToIdx, int FromIdx);

delegate OnUpdateDrag(const out DragElementInfo Before, const out DragElementInfo After);

function InitMenuObject(MobilePlayerInput PlayerInput, MobileMenuScene Scene, int ScreenWidth, int ScreenHeight, bool bIsFirstInitialization)
{
    local MobileMenuElement Element;

    ScaleSize.X = Width;
    ScaleSize.Y = Height;
    super.InitMenuObject(PlayerInput, Scene, ScreenWidth, ScreenHeight, bIsFirstInitialization);
    ScaleSize.X = Width / ScaleSize.X;
    ScaleSize.Y = Height / ScaleSize.Y;
    foreach Slots(Element,)
    {
        ScaleSlot(Element);        
    }    
    foreach Items(Element,)
    {
        ScaleSlot(Element);        
    }    
    Items.Length = Slots.Length;
}

function int AddSlot(MobileMenuElement Slot)
{
    if(Slot != none)
    {
        Slots.AddItem(Slot;
        if(bHasBeenInitialized)
        {
            ScaleSlot(Slot);
        }
        return Slots.Length - 1;
    }
    return -1;
}

private final function ScaleSlot(MobileMenuElement Slot)
{
    Slot.VpPos.X *= ScaleSize.X;
    Slot.VpPos.Y *= ScaleSize.Y;
    Slot.VpSize.X *= ScaleSize.X;
    Slot.VpSize.Y *= ScaleSize.Y;
}

function bool CanPutItemInSlot(MobileMenuElement Item, MobileMenuElement ToSlot, int ToIdx, optional int FromIdx)
{
    FromIdx = -1;
    if(((Item == none) || FromIdx == ToIdx) || ToIdx < 0)
    {
        return false;
    }
    if(__DoCanPutItemInSlot__Delegate != none)
    {
        return DoCanPutItemInSlot(self, Item, ToSlot, ToIdx, FromIdx);
    }
    return true;
}

event bool OnTouch(Engine.Interaction.ETouchType EventType, float TouchX, float TouchY, MobileMenuObject ObjectOver, float DeltaTime)
{
    local DragElementInfo OrigDrag;

    OrigDrag = Drag;
    Drag.EventType = EventType;
    TouchX -= Left;
    TouchY -= Top;
    Drag.CurTouch.X = TouchX;
    Drag.CurTouch.Y = TouchY;
    switch(EventType)
    {
        case 0:
            InitDragAt(int(TouchX), int(TouchY));
            if(__OnUpdateDrag__Delegate != none)
            {
                OnUpdateDrag(OrigDrag, Drag);
            }
            return true;
        case 1:
        case 2:
            if(!Drag.bIsDragging)
            {
                InitDragAt(int(TouchX), int(TouchY));                
            }
            else
            {
                Drag.IndexOver = FindSlotIndexAt(TouchX, TouchY);
                Drag.bIsOver = Drag.IndexOver >= 0;
            }
            Drag.bCanDropInOver = Drag.bIsOver && CanPutItemInSlot(Items[Drag.IndexFrom], Slots[Drag.IndexOver], Drag.IndexOver, Drag.IndexFrom);
            if(__OnUpdateDrag__Delegate != none)
            {
                OnUpdateDrag(OrigDrag, Drag);
            }
            return true;
        case 3:
            if(Drag.bIsDragging)
            {
                if(!Drag.bIsOver)
                {
                    Drag.IndexOver = FindSlotIndexAt(TouchX, TouchY);
                    Drag.bIsOver = Drag.IndexOver >= 0;
                }
                Drag.bCanDropInOver = Drag.bIsOver && CanPutItemInSlot(Items[Drag.IndexFrom], Slots[Drag.IndexOver], Drag.IndexOver, Drag.IndexFrom);
                if(Drag.bCanDropInOver)
                {
                    SwapItemsInSlots(Drag.IndexOver, Drag.IndexFrom);
                }
            }
            break;
        case 4:
            break;
        default:
            break;
    }
    Drag.bIsDragging = false;
    if(__OnUpdateDrag__Delegate != none)
    {
        OnUpdateDrag(OrigDrag, Drag);
    }
    Drag.bCanDropInOver = false;
    Drag.bIsOver = false;
    return true;
}

function bool SwapItemsInSlots(int Slot0, int Slot1)
{
    local MobileMenuElement Element0, Element1;

    Element0 = Items[Slot0];
    Element1 = Items[Slot1];
    if((Element0 == none) || CanPutItemInSlot(Element0, Slots[Slot1], Slot1, Slot0))
    {
        if((Element1 == none) || CanPutItemInSlot(Element1, Slots[Slot0], Slot0, Slot1))
        {
            Items[Slot0] = Element1;
            Items[Slot1] = Element0;
            UpdateItemInSlot(Slot0);
            UpdateItemInSlot(Slot1);
            return true;
        }
    }
    return false;
}

function MobileMenuElement AddItemToSlot(MobileMenuElement Element, int ToSlot)
{
    local MobileMenuElement PrevElement;

    if(CanPutItemInSlot(Element, Slots[ToSlot], ToSlot))
    {
        PrevElement = Items[ToSlot];
        Items[ToSlot] = Element;
        UpdateItemInSlot(ToSlot);
        return PrevElement;
    }
    return none;
}

protected function UpdateItemInSlot(int InSlot)
{
    local MobileMenuElement Element, Slot;

    Element = Items[InSlot];
    if(Element != none)
    {
        Slot = Slots[InSlot];
        Element.VpPos = Slot.VpPos;
        Element.VpSize = Slot.VpSize;
    }
    if(__OnUpdateItemInSlot__Delegate != none)
    {
        OnUpdateItemInSlot(self, InSlot);
    }
}

function InitDragAt(int TouchX, int TouchY)
{
    Drag.IndexFrom = FindSlotIndexAt(float(TouchX), float(TouchY));
    Drag.bIsDragging = (Drag.IndexFrom >= 0) && Items[Drag.IndexFrom] != none;
    Drag.IndexOver = Drag.IndexFrom;
    Drag.bIsOver = Drag.IndexFrom >= 0;
    Drag.bCanDropInOver = false;
    Drag.OrigTouch.X = float(TouchX);
    Drag.OrigTouch.Y = float(TouchY);
}

function int FindSlotIndexAt(float X, float Y)
{
    local MobileMenuElement Element;
    local float ExtraX, ExtraY;
    local int Idx;

    Idx = -1;
    foreach Slots(Element,)
    {
        ++ Idx;
        if(Element.bIsActive)
        {
            ExtraX = Element.VpSize.X * SideLeewayPercent;
            ExtraY = Element.VpSize.Y * SideLeewayPercent;
            if(X < (Element.VpPos.X - ExtraX))
            {
                continue;
                goto J0x289;
            }
            if(Y < (Element.VpPos.Y - ExtraY))
            {
                continue;
                goto J0x289;
            }
            if(X > ((Element.VpPos.X + Element.VpSize.X) + ExtraX))
            {
                continue;
                goto J0x289;
            }
            if(Y > ((Element.VpPos.Y + Element.VpSize.Y) + ExtraY))
            {
                continue;
                goto J0x289;
            }            
            return Idx;
        }        
    }
    J0x289:
    
    return -1;
}

function int GetIndexOfItem(MobileMenuElement Item)
{
    return Items.Find(Item;
}

function RenderObject(Canvas Canvas, float DeltaTime)
{
    local MobileMenuElement Element;
    local float OrgX, OrgY;

    OrgX = Canvas.OrgX;
    OrgY = Canvas.OrgY;
    CurrentElement.bIsDragItem = false;
    CurrentElement.Index = 0;
    foreach Slots(Element,)
    {
        if(Element.bIsVisible)
        {
            Canvas.SetOrigin(Left + Element.VpPos.X, Top + Element.VpPos.Y);
            Element.RenderElement(self, Canvas, DeltaTime, Opacity);
        }
        ++ CurrentElement.Index;        
    }    
    CurrentElement.Index = 0;
    J0x1D6:

    if(CurrentElement.Index < Items.Length)
    {
        Element = Items[CurrentElement.Index];
        if((Element != none) && Element.bIsVisible)
        {
            Canvas.SetOrigin(Left + Element.VpPos.X, Top + Element.VpPos.Y);
            Element.RenderElement(self, Canvas, DeltaTime, Opacity);
        }
        ++ CurrentElement.Index;
        goto J0x1D6;
    }
    Canvas.OrgX = OrgX;
    Canvas.OrgY = OrgY;
    if(bRenderDragItem)
    {
        RenderDragItem(Canvas, DeltaTime);
    }
}

function RenderDragItem(Canvas Canvas, float DeltaTime)
{
    local MobileMenuElement Element;
    local float OrgX, OrgY;

    if(Drag.bIsDragging)
    {
        OrgX = Canvas.OrgX;
        OrgY = Canvas.OrgY;
        CurrentElement.bIsDragItem = true;
        CurrentElement.Index = Drag.IndexFrom;
        Element = Items[Drag.IndexFrom];
        Canvas.SetOrigin(Left + Drag.CurTouch.X, Top + Drag.CurTouch.Y);
        Element.RenderElement(self, Canvas, DeltaTime, Opacity);
        Canvas.OrgX = OrgX;
        Canvas.OrgY = OrgY;
    }
}

defaultproperties
{
    SideLeewayPercent=0.1
    bRenderDragItem=true
    bIsActive=true
}