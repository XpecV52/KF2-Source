/*******************************************************************************
 * GameCrowdAgentSkeletal generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameCrowdAgentSkeletal extends GameCrowdAgent
    abstract
    native
    hidecategories(Navigation,Advanced,Attachment,Collision,Object);

struct native GameCrowdAttachmentInfo
{
    /** Pointer to mesh to attach */
    var() StaticMesh StaticMesh;
    /** Chance of choosing this attachment. */
    var() float Chance;
    /** Scaling applied to mesh when attached */
    var() Vector Scale3D;

    structdefaultproperties
    {
        StaticMesh=none
        Chance=1
        Scale3D=(X=1,Y=1,Z=1)
    }
};

struct native GameCrowdAttachmentList
{
    /** Name of socket to attach mesh to */
    var() name SocketName;
    /** List of possible meshes to attach to this socket. */
    var() array<GameCrowdAttachmentInfo> List;

    structdefaultproperties
    {
        SocketName=None
        List=none
    }
};

/** SkeletalMeshComponent used for crowd member mesh */
var(Rendering) export editinline SkeletalMeshComponent SkeletalMeshComponent;
var AnimNodeBlend SpeedBlendNode;
var AnimNodeSlot FullBodySlot;
var AnimNodeSequence ActionSeqNode;
var AnimNodeSequence WalkSeqNode;
var AnimNodeSequence RunSeqNode;
var AnimTree AgentTree;
/** The names of the animation loops to use when moving slowly */
var(Rendering) array<name> WalkAnimNames;
/** The name of the animations to use when moving more quickly */
var(Rendering) array<name> RunAnimNames;
/** The name of the animations to use when not moving (and not playing a custom animation) */
var(Rendering) array<name> IdleAnimNames;
/** Set of possible animation names to play when agent dies */
var(Behavior) array<name> DeathAnimNames;
/** Below this speed, the walking animation is used (if the AnimTree has a SpeedBlendNode, and not using root motion) */
var(SpeedBlendAnim) float SpeedBlendStart;
/** Above this speed, the running animation is used. Between this and SpeedBlendStart the animations are blended (if the AnimTree has a SpeedBlendNode, and not using root motion) */
var(SpeedBlendAnim) float SpeedBlendEnd;
/** This controls how the animation playback rate changes based on the speed of the agent (if not using root motion) */
var(SpeedBlendAnim) float AnimVelRate;
/** Limits how quickly blending between running and walking can happen. (if not using root motion) */
var(SpeedBlendAnim) float MaxSpeedBlendChangeSpeed;
/** Name of sync group for movement, whose rate is scaled  (if not using root motion) */
var(SpeedBlendAnim) name MoveSyncGroupName;
/** List of sets of meshes to attach to agent. */
var(Rendering) array<GameCrowdAttachmentList> Attachments;
/** Maximum time to try to rotate toward a target before playing animation */
var(Behavior) float MaxTargetAcquireTime;
/** If true, clamp velocity based on root motion in movement animations */
var(Rendering) bool bUseRootMotionVelocity;
/** If true, then allow enabling/disable of the skeleton based on whether the crowd agent is ticking or not */
var(Rendering) bool bAllowSkeletonUpdateChangeBasedOnTickResult;
/** If true, always tick when not visible */
var(Tick) bool bTickWhenNotVisible;
var bool bIsPlayingIdleAnimation;
var bool bIsPlayingDeathAnimation;
var bool bIsPlayingImportantAnimation;
var bool bAnimateThisTick;
/** If the crowd agent isn't visible for this length of time (in seconds), then stop ticking */
var(Tick) float NotVisibleDisableTickTime;
/** Maximum distance from camera at which this agent should be animated */
var(LOD) float MaxAnimationDistance;
var float MaxAnimationDistanceSq;

simulated function PostBeginPlay()
{
    super.PostBeginPlay();
    if(bDeleteMe)
    {
        return;
    }
    SpeedBlendNode = AnimNodeBlend(SkeletalMeshComponent.FindAnimNode('SpeedBlendNode'));
    FullBodySlot = AnimNodeSlot(SkeletalMeshComponent.FindAnimNode('ActionBlendNode'));
    ActionSeqNode = AnimNodeSequence(SkeletalMeshComponent.FindAnimNode('ActionSeqNode'));
    WalkSeqNode = AnimNodeSequence(SkeletalMeshComponent.FindAnimNode('WalkSeqNode'));
    RunSeqNode = AnimNodeSequence(SkeletalMeshComponent.FindAnimNode('RunSeqNode'));
    AgentTree = AnimTree(SkeletalMeshComponent.Animations);
    if((WalkSeqNode != none) && WalkAnimNames.Length > 0)
    {
        WalkSeqNode.SetAnim(WalkAnimNames[Rand(WalkAnimNames.Length)]);
    }
    if((RunSeqNode != none) && RunAnimNames.Length > 0)
    {
        RunSeqNode.SetAnim(RunAnimNames[Rand(RunAnimNames.Length)]);
    }
    if(ActionSeqNode != none)
    {
        ActionSeqNode.bZeroRootTranslation = true;
    }
    if(bUseRootMotionVelocity)
    {
        SkeletalMeshComponent.RootMotionMode = 3;
        WalkSeqNode.SetRootBoneAxisOption(2, 2, 2);
        RunSeqNode.SetRootBoneAxisOption(2, 2, 2);
    }
    MaxAnimationDistanceSq = MaxAnimationDistance * MaxAnimationDistance;
}

simulated function SetLighting(bool bEnableLightEnvironment, LightingChannelContainer AgentLightingChannel, bool bCastShadows)
{
    super.SetLighting(bEnableLightEnvironment, AgentLightingChannel, bCastShadows);
    SkeletalMeshComponent.SetLightingChannels(AgentLightingChannel);
    CreateAttachments();
    SkeletalMeshComponent.CastShadow = bCastShadows;
    SkeletalMeshComponent.bCastDynamicShadow = bCastShadows;
    SkeletalMeshComponent.ForceUpdate(false);
}

// Export UGameCrowdAgentSkeletal::execPlayDeath(FFrame&, void* const)
native function PlayDeath(Vector KillMomentum);

// Export UGameCrowdAgentSkeletal::execSetRootMotion(FFrame&, void* const)
native function SetRootMotion(bool bRootMotionEnabled);

simulated function OnPlayAgentAnimation(SeqAct_PlayAgentAnimation Action)
{
    if(Action.InputLinks[1].bHasImpulse)
    {
        Action.ActivateOutputLink(1);
        StopBehavior();
        if(CurrentDestination.ReachedByAgent(self, Location, false))
        {
            CurrentDestination.ReachedDestination(self);
        }        
    }
    else
    {
        Action.SetCurrentAnimationActionFor(self);
    }
}

event ClearLatentAnimation()
{
    ClearLatentAction(Class'SeqAct_PlayAgentAnimation', false);
}

simulated event PlayIdleAnimation()
{
    bIsPlayingIdleAnimation = true;
    FullBodySlot.PlayCustomAnim(IdleAnimNames[Rand(IdleAnimNames.Length)], 1, 0.1, 0.1, true, false);
}

simulated event StopIdleAnimation()
{
    FullBodySlot.StopCustomAnim(0.1);
    bIsPlayingIdleAnimation = false;
}

event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    if(CurrentBehavior != none)
    {
        CurrentBehavior.OnAnimEnd(SeqNode, PlayedTime, ExcessTime);
    }
}

simulated function CreateAttachments()
{
    local int AttachIdx, InfoIdx, PickedInfoIdx;
    local float ChanceTotal, RandVal;
    local editinline StaticMeshComponent StaticMeshComp;
    local bool bUseSocket, bUseBone;

    AttachIdx = 0;
    J0x0B:

    if(AttachIdx < Attachments.Length)
    {
        if(Attachments[AttachIdx].List.Length == 0)
        {            
        }
        else
        {
            ChanceTotal = 0;
            InfoIdx = 0;
            J0x6D:

            if(InfoIdx < Attachments[AttachIdx].List.Length)
            {
                ChanceTotal += Attachments[AttachIdx].List[InfoIdx].Chance;
                ++ InfoIdx;
                goto J0x6D;
            }
            RandVal = FRand() * ChanceTotal;
            ChanceTotal = 0;
            InfoIdx = 0;
            J0x12F:

            if(InfoIdx < Attachments[AttachIdx].List.Length)
            {
                ChanceTotal += Attachments[AttachIdx].List[InfoIdx].Chance;
                if(ChanceTotal >= RandVal)
                {
                    PickedInfoIdx = InfoIdx;
                    goto J0x1ED;
                }
                ++ InfoIdx;
                goto J0x12F;
            }
            J0x1ED:

            if(Attachments[AttachIdx].List[PickedInfoIdx].StaticMesh != none)
            {
                bUseSocket = SkeletalMeshComponent.GetSocketByName(Attachments[AttachIdx].SocketName) != none;
                bUseBone = SkeletalMeshComponent.MatchRefBone(Attachments[AttachIdx].SocketName) != -1;
                if(bUseSocket || bUseBone)
                {
                    StaticMeshComp = new (self) Class'StaticMeshComponent';
                    StaticMeshComp.SetStaticMesh(Attachments[AttachIdx].List[PickedInfoIdx].StaticMesh);
                    StaticMeshComp.SetActorCollision(false, false);
                    StaticMeshComp.SetScale3D(Attachments[AttachIdx].List[PickedInfoIdx].Scale3D);
                    StaticMeshComp.SetLightEnvironment(LightEnvironment);
                    if(bUseSocket)
                    {
                        SkeletalMeshComponent.AttachComponentToSocket(StaticMeshComp, Attachments[AttachIdx].SocketName);                        
                    }
                    else
                    {
                        SkeletalMeshComponent.AttachComponent(StaticMeshComp, Attachments[AttachIdx].SocketName);
                    }                    
                }
                else
                {
                    LogInternal(((("CrowdAgent: WARNING: Could not find socket or bone called '" $ string(Attachments[AttachIdx].SocketName)) $ "' for mesh '") @ string(Attachments[AttachIdx].List[PickedInfoIdx].StaticMesh)) $ "'");
                }
            }
        }
        ++ AttachIdx;
        goto J0x0B;
    }
}

defaultproperties
{
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        bUpdateSkelWhenNotRendered=false
        bTickAnimNodesWhenNotRendered=false
        bEnableLineCheckWithBounds=true
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__GameCrowdAgentSkeletal.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        bCastDynamicShadow=false
        CollideActors=true
        BlockZeroExtent=true
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true)
    object end
    // Reference: SkeletalMeshComponent'Default__GameCrowdAgentSkeletal.SkeletalMeshComponent0'
    SkeletalMeshComponent=SkeletalMeshComponent0
    SpeedBlendStart=150
    SpeedBlendEnd=180
    AnimVelRate=0.0098
    MaxSpeedBlendChangeSpeed=2
    MoveSyncGroupName=MoveGroup
    MaxTargetAcquireTime=5
    bAllowSkeletonUpdateChangeBasedOnTickResult=true
    NotVisibleDisableTickTime=0.2
    MaxAnimationDistance=12000
    LightEnvironment=DynamicLightEnvironmentComponent'Default__GameCrowdAgentSkeletal.MyLightEnvironment'
    Components(0)=DynamicLightEnvironmentComponent'Default__GameCrowdAgentSkeletal.MyLightEnvironment'
    begin object name=SkeletalMeshComponent0 class=SkeletalMeshComponent
        bUpdateSkelWhenNotRendered=false
        bTickAnimNodesWhenNotRendered=false
        bEnableLineCheckWithBounds=true
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__GameCrowdAgentSkeletal.MyLightEnvironment'
        RBChannel=ERBCollisionChannel.RBCC_GameplayPhysics
        bCastDynamicShadow=false
        CollideActors=true
        BlockZeroExtent=true
        RBCollideWithChannels=(Default=true,GameplayPhysics=true,EffectPhysics=true)
    object end
    // Reference: SkeletalMeshComponent'Default__GameCrowdAgentSkeletal.SkeletalMeshComponent0'
    Components(1)=SkeletalMeshComponent0
}