/*******************************************************************************
 * OnlineImageDownloaderWeb generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class OnlineImageDownloaderWeb extends Object
    config(Engine);

enum EOnlineImageDownloadState
{
    PIDS_NotStarted,
    PIDS_Downloading,
    PIDS_Succeeded,
    PIDS_Failed,
    PIDS_MAX
};

struct OnlineImageDownload
{
    var string URL;
    var HttpRequestInterface HTTPRequest;
    var OnlineImageDownloaderWeb.EOnlineImageDownloadState State;
    var bool bPendingRemoval;
    var Texture2DDynamic Texture;

    structdefaultproperties
    {
        URL=""
        HTTPRequest=none
        State=EOnlineImageDownloadState.PIDS_NotStarted
        bPendingRemoval=false
        Texture=none
    }
};

var array<OnlineImageDownload> DownloadImages;
var config int MaxSimultaneousDownloads;
var delegate<OnOnlineImageDownloaded> __OnOnlineImageDownloaded__Delegate;

delegate OnOnlineImageDownloaded(OnlineImageDownload CachedEntry);

function Texture GetOnlineImageTexture(string URL)
{
    local int FoundIdx;

    FoundIdx = DownloadImages.Find('URL', URL;
    if((FoundIdx != -1) && DownloadImages[FoundIdx].State == 2)
    {
        return DownloadImages[FoundIdx].Texture;
    }
    return none;
}

function RequestOnlineImages(array<string> URLs)
{
    local string URL;
    local int FoundIdx, Idx;

    Idx = 0;
    J0x0B:

    if(Idx < DownloadImages.Length)
    {
        DownloadImages[Idx].bPendingRemoval = URLs.Find(DownloadImages[Idx].URL == -1;
        ++ Idx;
        goto J0x0B;
    }
    foreach URLs(URL,)
    {
        FoundIdx = DownloadImages.Find('URL', URL;
        if(FoundIdx != -1)
        {
            OnOnlineImageDownloaded(DownloadImages[FoundIdx]);            
        }
        else
        {
            FoundIdx = DownloadImages.Find('bPendingRemoval', true;
            if(FoundIdx == -1)
            {
                FoundIdx = DownloadImages.Length;
                DownloadImages.Length = DownloadImages.Length + 1;
            }
            DownloadImages[FoundIdx].URL = URL;
            DownloadImages[FoundIdx].HTTPRequest = none;
            DownloadImages[FoundIdx].State = 0;
            DownloadImages[FoundIdx].bPendingRemoval = false;
            if(DownloadImages[FoundIdx].Texture == none)
            {
                DownloadImages[FoundIdx].Texture = Class'Texture2DDynamic'.static.Create(50, 50);
            }
        }        
    }    
    Idx = 0;
    J0x29E:

    if(Idx < DownloadImages.Length)
    {
        if(DownloadImages[Idx].bPendingRemoval)
        {
            DownloadImages.Remove(-- Idx, 1;
        }
        ++ Idx;
        goto J0x29E;
    }
    DownloadNextImage();
}

function int GetNumPendingDownloads()
{
    local int Idx, Count;

    Idx = 0;
    J0x0B:

    if(Idx < DownloadImages.Length)
    {
        if(DownloadImages[Idx].State == 1)
        {
            ++ Count;
        }
        ++ Idx;
        goto J0x0B;
    }
    return Count;
}

function ClearDownloads(array<string> URLs)
{
    local int Idx;

    Idx = 0;
    J0x0B:

    if(Idx < DownloadImages.Length)
    {
        if(URLs.Find(DownloadImages[Idx].URL != -1)
        {
            DownloadImages.Remove(-- Idx, 1;
        }
        ++ Idx;
        goto J0x0B;
    }
}

function ClearAllDownloads()
{
    DownloadImages.Length = 0;
}

private final function DownloadNextImage()
{
    local int Idx, PendingDownloads;

    PendingDownloads = GetNumPendingDownloads();
    Idx = 0;
    J0x1F:

    if(Idx < DownloadImages.Length)
    {
        if(PendingDownloads >= MaxSimultaneousDownloads)
        {
            goto J0x265;
        }
        if(DownloadImages[Idx].State == 0)
        {
            DownloadImages[Idx].HTTPRequest = Class'HttpFactory'.static.CreateRequest();
            if(DownloadImages[Idx].HTTPRequest != none)
            {
                DownloadImages[Idx].HTTPRequest.SetVerb("GET");
                DownloadImages[Idx].HTTPRequest.SetURL(DownloadImages[Idx].URL);
                DownloadImages[Idx].HTTPRequest.SetProcessRequestCompleteDelegate(OnDownloadComplete);
                if(DownloadImages[Idx].HTTPRequest.ProcessRequest())
                {
                    DownloadImages[Idx].State = 1;
                    ++ PendingDownloads;
                }
            }
        }
        ++ Idx;
        goto J0x1F;
    }
    J0x265:

}

private final function OnDownloadComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface Response, bool bDidSucceed)
{
    local int FoundIdx;
    local array<byte> JPEGData;

    FoundIdx = DownloadImages.Find('HTTPRequest', OriginalRequest;
    if(FoundIdx != -1)
    {
        if(((bDidSucceed && Response != none) && Response.GetResponseCode() == 200) && InStr(Response.GetHeader("Content-Type"), "jpeg", false, true) != -1)
        {
            DownloadImages[FoundIdx].State = 2;
            Response.GetContent(JPEGData);
            DownloadImages[FoundIdx].Texture.UpdateMipFromJPEG(0, JPEGData);            
        }
        else
        {
            DownloadImages[FoundIdx].State = 3;
        }
        OnOnlineImageDownloaded(DownloadImages[FoundIdx]);
        DownloadImages[FoundIdx].HTTPRequest = none;
    }
    DownloadNextImage();
}

function DebugDraw(Canvas Canvas)
{
    local float PosX, PosY;
    local int Idx;

    PosX = 0;
    PosY = 0;
    Idx = 0;
    J0x29:

    if(Idx < DownloadImages.Length)
    {
        if(DownloadImages[Idx].State == 2)
        {
            Canvas.SetDrawColor(255, 255, 255, 255);
            Canvas.SetPos(PosX, PosY);
            Canvas.DrawTexture(DownloadImages[Idx].Texture, 1);
            Canvas.SetDrawColor(0, 255, 0, 255);
            Canvas.SetPos(PosX, PosY);
            Canvas.DrawBox(float(DownloadImages[Idx].Texture.SizeX), float(DownloadImages[Idx].Texture.SizeY));
            PosY += float(DownloadImages[Idx].Texture.SizeY);            
        }
        else
        {
            Canvas.DrawBox(50, 50);
            PosY += float(50);
        }
        if(PosY > Canvas.ClipY)
        {
            PosY = 0;
            PosX += float(50);
        }
        ++ Idx;
        goto J0x29;
    }
}

defaultproperties
{
    MaxSimultaneousDownloads=8
}