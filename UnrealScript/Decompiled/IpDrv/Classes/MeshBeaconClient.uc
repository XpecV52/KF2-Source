/*******************************************************************************
 * MeshBeaconClient generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MeshBeaconClient extends MeshBeacon
    native
    config(Engine);

enum EMeshBeaconClientState
{
    MBCS_None,
    MBCS_Connecting,
    MBCS_Connected,
    MBCS_ConnectionFailed,
    MBCS_AwaitingResponse,
    MBCS_Closed,
    MBCS_MAX
};

struct native ClientConnectionRequest
{
    var UniqueNetId PlayerNetId;
    var Engine.OnlineSubsystem.ENATType NatType;
    var bool bCanHostVs;
    var float GoodHostRatio;
    var array<ConnectionBandwidthStats> BandwidthHistory;
    var int MinutesSinceLastTest;

    structdefaultproperties
    {
        PlayerNetId=(Uid=none)
        NatType=ENATType.NAT_Unknown
        bCanHostVs=false
        GoodHostRatio=0
        BandwidthHistory=none
        MinutesSinceLastTest=0
    }
};

struct native ClientBandwidthTestData
{
    var MeshBeacon.EMeshBeaconBandwidthTestType TestType;
    var MeshBeacon.EMeshBeaconBandwidthTestState CurrentState;
    var int NumBytesToSendTotal;
    var int NumBytesSentTotal;
    var int NumBytesSentLast;
    var float ElapsedTestTime;

    structdefaultproperties
    {
        TestType=EMeshBeaconBandwidthTestType.MB_BandwidthTestType_Upstream
        CurrentState=EMeshBeaconBandwidthTestState.MB_BandwidthTestState_NotStarted
        NumBytesToSendTotal=0
        NumBytesSentTotal=0
        NumBytesSentLast=0
        ElapsedTestTime=0
    }
};

var const OnlineGameSearchResult HostPendingRequest;
var const ClientConnectionRequest ClientPendingRequest;
var ClientBandwidthTestData CurrentBandwidthTest;
var MeshBeaconClient.EMeshBeaconClientState ClientBeaconState;
var MeshBeacon.EMeshBeaconPacketType ClientBeaconRequestType;
var config float ConnectionRequestTimeout;
var float ConnectionRequestElapsedTime;
var config string ResolverClassName;
var class<ClientBeaconAddressResolver> ResolverClass;
var ClientBeaconAddressResolver Resolver;
var transient bool bUsingRegisteredAddr;
var delegate<OnConnectionRequestResult> __OnConnectionRequestResult__Delegate;
var delegate<OnReceivedBandwidthTestRequest> __OnReceivedBandwidthTestRequest__Delegate;
var delegate<OnReceivedBandwidthTestResults> __OnReceivedBandwidthTestResults__Delegate;
var delegate<OnTravelRequestReceived> __OnTravelRequestReceived__Delegate;
var delegate<OnCreateNewSessionRequestReceived> __OnCreateNewSessionRequestReceived__Delegate;

// Export UMeshBeaconClient::execDestroyBeacon(FFrame&, void* const)
native event DestroyBeacon();

// Export UMeshBeaconClient::execRequestConnection(FFrame&, void* const)
native function bool RequestConnection(const out OnlineGameSearchResult DesiredHost, const out ClientConnectionRequest ClientRequest, bool bRegisterSecureAddress);

// Export UMeshBeaconClient::execBeginBandwidthTest(FFrame&, void* const)
native function bool BeginBandwidthTest(MeshBeacon.EMeshBeaconBandwidthTestType TestType, int TestBufferSize);

delegate OnConnectionRequestResult(MeshBeacon.EMeshBeaconConnectionResult ConnectionResult);

delegate OnReceivedBandwidthTestRequest(MeshBeacon.EMeshBeaconBandwidthTestType TestType);

delegate OnReceivedBandwidthTestResults(MeshBeacon.EMeshBeaconBandwidthTestType TestType, MeshBeacon.EMeshBeaconBandwidthTestResult TestResult, const out ConnectionBandwidthStats BandwidthStats);

delegate OnTravelRequestReceived(name SessionName, class<OnlineGameSearch> SearchClass, const out byte PlatformSpecificInfo[80]);

delegate OnCreateNewSessionRequestReceived(name SessionName, class<OnlineGameSearch> SearchClass, const out array<PlayerMember> Players);

// Export UMeshBeaconClient::execSendHostNewGameSessionResponse(FFrame&, void* const)
native function bool SendHostNewGameSessionResponse(bool bSuccess, name SessionName, class<OnlineGameSearch> SearchClass, const out byte PlatformSpecificInfo[80]);

function DumpInfo()
{
    local int HistoryIdx;

    LogInternal("Debug info for Beacon: " $ string(BeaconName), 'DevBeacon');
    LogInternal("", 'DevBeacon');
    LogInternal("Client entry: ", 'DevBeacon');
    LogInternal("	PlayerNetId: " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(ClientPendingRequest.PlayerNetId), 'DevBeacon');
    LogInternal("	NatType: " $ string(ClientPendingRequest.NatType), 'DevBeacon');
    LogInternal("	GoodHostRatio: " $ string(ClientPendingRequest.GoodHostRatio), 'DevBeacon');
    LogInternal("	bCanHostVs: " $ string(ClientPendingRequest.bCanHostVs), 'DevBeacon');
    LogInternal("	MinutesSinceLastTest: " $ string(ClientPendingRequest.MinutesSinceLastTest), 'DevBeacon');
    LogInternal("	BandwidthTest.CurrentState: " $ string(CurrentBandwidthTest.CurrentState), 'DevBeacon');
    LogInternal("	BandwidthTest.TestType: " $ string(CurrentBandwidthTest.TestType), 'DevBeacon');
    LogInternal("	Bandwidth History: " $ string(ClientPendingRequest.BandwidthHistory.Length), 'DevBeacon');
    HistoryIdx = 0;
    J0x281:

    if(HistoryIdx < ClientPendingRequest.BandwidthHistory.Length)
    {
        LogInternal(((((("		" $ " Upstream bytes/sec: ") $ string(ClientPendingRequest.BandwidthHistory[HistoryIdx].UpstreamRate)) $ " Downstream bytes/sec: ") $ string(ClientPendingRequest.BandwidthHistory[HistoryIdx].DownstreamRate)) $ " Roundrtrip msec: ") $ string(ClientPendingRequest.BandwidthHistory[HistoryIdx].RoundtripLatency), 'DevBeacon');
        ++ HistoryIdx;
        goto J0x281;
    }
}

function DebugRender(Canvas Canvas)
{
    local int HistoryIdx;
    local float XL, YL, Offset;

    Offset = 50;
    Canvas.Font = Class'Engine'.static.GetTinyFont();
    Canvas.StrLen("============================================================", XL, YL);
    Canvas.SetPos(Offset, Offset);
    Canvas.SetDrawColor(0, 0, 255, 64);
    Canvas.DrawTile(Canvas.DefaultTexture, XL, float(Canvas.SizeY) - (Offset * float(2)), 0, 0, 1, 1);
    Canvas.SetPos(Offset, Offset);
    Canvas.SetDrawColor(255, 255, 255);
    Canvas.DrawText("Debug info for Beacon: " $ string(BeaconName));
    Canvas.DrawText("");
    Canvas.DrawText("Client entry: ");
    Canvas.StrLen("============================================================", XL, YL);
    Canvas.SetPos(Canvas.CurX + float(10), Canvas.CurY);
    Canvas.DrawText("PlayerNetId: " $ Class'OnlineSubsystem'.static.UniqueNetIdToString(ClientPendingRequest.PlayerNetId));
    Canvas.DrawText("NatType: " $ string(ClientPendingRequest.NatType));
    Canvas.DrawText("GoodHostRatio: " $ string(ClientPendingRequest.GoodHostRatio));
    Canvas.DrawText("bCanHostVs: " $ string(ClientPendingRequest.bCanHostVs));
    Canvas.DrawText("MinutesSinceLastTest: " $ string(ClientPendingRequest.MinutesSinceLastTest));
    Canvas.DrawText("Current BandwidthTest: ");
    Canvas.SetPos(Canvas.CurX + float(10), Canvas.CurY);
    Canvas.DrawText("CurrentState: " $ string(CurrentBandwidthTest.CurrentState));
    Canvas.DrawText("TestType: " $ string(CurrentBandwidthTest.TestType));
    Canvas.DrawText("NumBytesToSendTotal: " $ string(CurrentBandwidthTest.NumBytesToSendTotal));
    Canvas.DrawText("NumBytesSentTotal: " $ string(CurrentBandwidthTest.NumBytesSentTotal));
    Canvas.SetPos(Canvas.CurX - float(10), Canvas.CurY);
    Canvas.DrawText("Bandwidth History: " $ string(ClientPendingRequest.BandwidthHistory.Length));
    Canvas.SetPos(Canvas.CurX + float(10), Canvas.CurY);
    HistoryIdx = 0;
    J0x845:

    if(HistoryIdx < ClientPendingRequest.BandwidthHistory.Length)
    {
        Canvas.DrawText(((" Upstream bytes/sec: " $ string(ClientPendingRequest.BandwidthHistory[HistoryIdx].UpstreamRate)) $ " Roundrtrip msec: ") $ string(ClientPendingRequest.BandwidthHistory[HistoryIdx].RoundtripLatency));
        ++ HistoryIdx;
        goto J0x845;
    }
}
