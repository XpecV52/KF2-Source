/*******************************************************************************
 * McpMessageManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class McpMessageManager extends McpMessageBase
    native
    config(Engine);

struct native McpCompressMessageRequest
{
    var array<byte> SourceBuffer;
    var array<byte> DestBuffer;
    var int OutCompressedSize;
    var HttpRequestInterface Request;
    var native Pointer CompressionWorker;

    structdefaultproperties
    {
        SourceBuffer=none
        DestBuffer=none
        OutCompressedSize=0
        Request=none
    }
};

struct native McpUncompressMessageRequest
{
    var string MessageId;
    var array<byte> SourceBuffer;
    var array<byte> DestBuffer;
    var int OutUncompressedSize;
    var native Pointer UncompressionWorker;

    structdefaultproperties
    {
        MessageId=""
        SourceBuffer=none
        DestBuffer=none
        OutUncompressedSize=0
    }
};

var private native const noexport Pointer VfTable_FTickableObject;
var config string CreateMessageUrl;
var config string DeleteMessageUrl;
var config string QueryMessagesUrl;
var config string QueryMessageContentsUrl;
var config string DeleteAllMessagesUrl;
var native array<McpCompressMessageRequest> CompressMessageRequests;
var native array<McpUncompressMessageRequest> UncompressMessageRequests;

// Export UMcpMessageManager::execStartAsyncCompression(FFrame&, void* const)
native function bool StartAsyncCompression(McpMessageBase.EMcpMessageCompressionType MessageCompressionType, const out array<byte> MessageContent, HttpRequestInterface Request);

// Export UMcpMessageManager::execStartAsyncUncompression(FFrame&, void* const)
native function bool StartAsyncUncompression(string MessageId, McpMessageBase.EMcpMessageCompressionType MessageCompressionType, const out array<byte> MessageContent);

event FinishedAsyncUncompression(bool bWasSuccessful, const out array<byte> UncompressedMessageContents, string MessageId)
{
    if(!CacheMessageContents(UncompressedMessageContents, MessageId))
    {
        LogInternal((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName()));
    }
    OnQueryMessageContentsComplete(MessageId, bWasSuccessful, "");
}

function CreateMessage(const out array<string> ToUniqueUserIds, string FromUniqueUserId, string FromFriendlyName, string MessageType, string PushMessage, string ValidUntil, const out array<byte> MessageContents)
{
    local string URL;
    local HttpRequestInterface CreateMessageRequest;
    local McpMessage Message;
    local string ToUniqueUserIdsStr;
    local int Idx;

    CreateMessageRequest = Class'HttpFactory'.static.CreateRequest();
    if(CreateMessageRequest != none)
    {
        Idx = 0;
        J0x43:

        if(Idx < ToUniqueUserIds.Length)
        {            
            ToUniqueUserIdsStr $= ToUniqueUserIds[Idx];
            if((ToUniqueUserIds.Length - Idx) > 1)
            {                
                ToUniqueUserIdsStr $= ",";
            }
            ++ Idx;
            goto J0x43;
        }
        URL = ((((((((((((((((GetBaseURL()) $ CreateMessageUrl) $ (GetAppAccessURL())) $ "&toUniqueUserIds=") $ ToUniqueUserIdsStr) $ "&fromUniqueUserId=") $ FromUniqueUserId) $ "&fromFriendlyName=") $ FromFriendlyName) $ "&messageType=") $ MessageType) $ "&pushMessage=") $ PushMessage) $ "&messageCompressionType=") $ string(CompressionType)) $ "&validUntil=") $ ValidUntil;
        CreateMessageRequest.SetURL(URL);
        CreateMessageRequest.SetHeader("Content-Type", "multipart/form-data");
        CreateMessageRequest.SetVerb("POST");
        CreateMessageRequest.__OnProcessRequestComplete__Delegate = OnCreateMessageRequestComplete;
        if((CompressionType == 1) || CompressionType == 2)
        {
            if(!StartAsyncCompression(CompressionType, MessageContents, CreateMessageRequest))
            {
                OnCreateMessageComplete(Message, false, "Failed to Start Async Compression.");
            }            
        }
        else
        {
            CreateMessageRequest.SetContent(MessageContents);
            if(!CreateMessageRequest.ProcessRequest())
            {
                LogInternal(((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Failed to process web request for URL(") $ URL) $ ")");
            }
            LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ " URL is ") $ URL);
        }
    }
}

function OnCreateMessageRequestComplete(HttpRequestInterface CreateMessageRequest, HttpResponseInterface HttpResponse, bool bWasSuccessful)
{
    local int ResponseCode;
    local string Content;
    local McpMessage CreatedMessage;

    ResponseCode = 500;
    if((HttpResponse != none) && CreateMessageRequest != none)
    {
        ResponseCode = HttpResponse.GetResponseCode();
        bWasSuccessful = bWasSuccessful && ResponseCode == 201;
        Content = HttpResponse.GetContentAsString();
        if(bWasSuccessful)
        {
            LogInternal(((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Message created.");            
        }
        else
        {
            LogInternal(((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ " CreateMessage query did not return a message.");
        }
    }
    OnCreateMessageComplete(CreatedMessage, bWasSuccessful, Content);
}

function DeleteMessage(string MessageId)
{
    local string URL;
    local HttpRequestInterface DeleteMessageRequest;

    DeleteMessageRequest = Class'HttpFactory'.static.CreateRequest();
    if(DeleteMessageRequest != none)
    {
        URL = ((((GetBaseURL()) $ DeleteMessageUrl) $ (GetAppAccessURL())) $ "&messageId=") $ MessageId;
        DeleteMessageRequest.SetVerb("DELETE");
        DeleteMessageRequest.SetURL(URL);
        DeleteMessageRequest.__OnProcessRequestComplete__Delegate = OnDeleteMessageRequestComplete;
        if(!DeleteMessageRequest.ProcessRequest())
        {
            LogInternal(((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Failed to process web request for URL(") $ URL) $ ")");
        }
        LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ "URL is ") $ URL);
    }
}

function OnDeleteMessageRequestComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface HttpResponse, bool bWasSuccessful)
{
    local int ResponseCode;
    local string Content, MessageId;

    ResponseCode = 500;
    if(HttpResponse != none)
    {
        ResponseCode = HttpResponse.GetResponseCode();
        MessageId = HttpResponse.GetURLParameter("MessageId");
        ResponseCode = HttpResponse.GetResponseCode();
        Content = HttpResponse.GetContentAsString();
    }
    bWasSuccessful = bWasSuccessful && ResponseCode == 200;
    OnDeleteMessageComplete(MessageId, bWasSuccessful, Content);
}

function QueryMessages(string ToUniqueUserId)
{
    local string URL;
    local HttpRequestInterface QueryMessagesRequest;

    QueryMessagesRequest = Class'HttpFactory'.static.CreateRequest();
    if(QueryMessagesRequest != none)
    {
        URL = ((((GetBaseURL()) $ QueryMessagesUrl) $ (GetAppAccessURL())) $ "&uniqueUserId=") $ ToUniqueUserId;
        QueryMessagesRequest.SetURL(URL);
        QueryMessagesRequest.SetVerb("GET");
        QueryMessagesRequest.__OnProcessRequestComplete__Delegate = OnQueryMessagesRequestComplete;
        LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "URL: ") $ URL);
        if(!QueryMessagesRequest.ProcessRequest())
        {
            LogInternal(((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Failed to process web request for URL(") $ URL) $ ")");
        }
    }
}

private final function OnQueryMessagesRequestComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface HttpResponse, bool bWasSuccessful)
{
    local int ResponseCode;
    local string Error, JsonString;
    local JsonObject ParsedJson;
    local int JsonIndex;
    local McpMessage Message;
    local string MessageCompressionTypeString;

    ResponseCode = 500;
    if((HttpResponse != none) && OriginalRequest != none)
    {
        ResponseCode = HttpResponse.GetResponseCode();
        bWasSuccessful = bWasSuccessful && ResponseCode == 200;
        if(bWasSuccessful)
        {
            JsonString = HttpResponse.GetContentAsString();
            if(JsonString != "")
            {
                ParsedJson = Class'JsonObject'.static.DecodeJson(JsonString);
                JsonIndex = 0;
                J0x102:

                if(JsonIndex < ParsedJson.ObjectArray.Length)
                {
                    Message.MessageId = ParsedJson.ObjectArray[JsonIndex].GetStringValue("message_id");
                    Message.ToUniqueUserId = ParsedJson.ObjectArray[JsonIndex].GetStringValue("to_unique_user_id");
                    Message.FromUniqueUserId = ParsedJson.ObjectArray[JsonIndex].GetStringValue("from_unique_user_id");
                    Message.FromFriendlyName = ParsedJson.ObjectArray[JsonIndex].GetStringValue("from_friendly_name");
                    Message.MessageType = ParsedJson.ObjectArray[JsonIndex].GetStringValue("message_type");
                    MessageCompressionTypeString = ParsedJson.ObjectArray[JsonIndex].GetStringValue("message_compression_type");
                    Message.ValidUntil = ParsedJson.ObjectArray[JsonIndex].GetStringValue("valid_until");
                    switch(MessageCompressionTypeString)
                    {
                        case "MMCT_LZO":
                            Message.MessageCompressionType = 1;
                            break;
                        case "MMCT_ZLIB":
                            Message.MessageCompressionType = 2;
                            break;
                        default:
                            Message.MessageCompressionType = 0;
                            break;
                    }
                    CacheMessage(Message);
                    ++ JsonIndex;
                    goto J0x102;
                }                
            }
            else
            {
                Error = "Query did not return any content in it's response.";
                LogInternal(((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ Error);
            }            
        }
        else
        {
            Error = HttpResponse.GetContentAsString();
        }
    }
    OnQueryMessagesComplete(Message.ToUniqueUserId, bWasSuccessful, Error);
}

function GetMessageList(string ToUniqueUserId, out McpMessageList MessageList)
{
    local int MessageListIndex;

    MessageListIndex = MessageLists.Find('ToUniqueUserId', ToUniqueUserId;
    if(MessageListIndex != -1)
    {
        MessageList = MessageLists[MessageListIndex];        
    }
    else
    {
        LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ " Requester Id not found or MessageLists is empty. Using ToUniqueUserId: ") $ ToUniqueUserId);
    }
}

function QueryMessageContents(string MessageId)
{
    local string URL;
    local HttpRequestInterface QueryMessageContentsRequest;

    QueryMessageContentsRequest = Class'HttpFactory'.static.CreateRequest();
    if(QueryMessageContentsRequest != none)
    {
        URL = ((((GetBaseURL()) $ QueryMessageContentsUrl) $ (GetAppAccessURL())) $ "&messageId=") $ MessageId;
        QueryMessageContentsRequest.SetURL(URL);
        QueryMessageContentsRequest.SetVerb("GET");
        QueryMessageContentsRequest.__OnProcessRequestComplete__Delegate = OnQueryMessageContentsRequestComplete;
        LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "URL: ") $ URL);
        if(!QueryMessageContentsRequest.ProcessRequest())
        {
            LogInternal(((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ "Failed to process web request for URL(") $ URL) $ ")");
        }
    }
}

private final function OnQueryMessageContentsRequestComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface HttpResponse, bool bWasSuccessful)
{
    local int ResponseCode;
    local array<byte> MessageContents;
    local string MessageId;
    local McpMessage Message;

    ResponseCode = 500;
    if((HttpResponse != none) && OriginalRequest != none)
    {
        MessageId = OriginalRequest.GetURLParameter("messageId");
        ResponseCode = HttpResponse.GetResponseCode();
        bWasSuccessful = bWasSuccessful && ResponseCode == 200;
        if(bWasSuccessful && Len(MessageId) > 0)
        {
            HttpResponse.GetContent(MessageContents);
            LogInternal((("MessageId:" $ MessageId) $ " Compressed Message Contents Length:") $ string(MessageContents.Length));
            if(MessageContents.Length > 0)
            {
                GetMessageById(MessageId, Message);
                if(Message.MessageCompressionType == 0)
                {
                    CacheMessageContents(MessageContents, MessageId);
                    OnQueryMessageContentsComplete(MessageId, bWasSuccessful, HttpResponse.GetContentAsString());                    
                }
                else
                {
                    if(!StartAsyncUncompression(MessageId, Message.MessageCompressionType, MessageContents))
                    {
                        OnQueryMessageContentsComplete(MessageId, false, "Could not Start AsyncDecompression");
                    }
                }                
            }
            else
            {
                OnQueryMessageContentsComplete(MessageId, false, "Query did not return any content in it's response.");
            }            
        }
        else
        {
            OnQueryMessageContentsComplete(MessageId, false, HttpResponse.GetContentAsString());
        }        
    }
    else
    {
        OnQueryMessageContentsComplete(MessageId, false, "There was No HttpResponse or Request");
    }
}

function bool GetMessageContents(string MessageId, out array<byte> MessageContents)
{
    local bool bWasSuccessful;
    local int MessageContentsIndex;

    MessageContentsIndex = MessageContentsList.Find('MessageId', MessageId;
    if(MessageContentsIndex != -1)
    {
        MessageContents = MessageContentsList[MessageContentsIndex].MessageContents;
        bWasSuccessful = true;        
    }
    else
    {
        bWasSuccessful = false;
    }
    return bWasSuccessful;
}

function CacheMessage(McpMessage Message)
{
    local int AddAt, MessageIndex, MessageListIndex;
    local McpMessageList UserMessageList;
    local bool bWasFound;

    bWasFound = false;
    MessageListIndex = MessageLists.Find('ToUniqueUserId', Message.ToUniqueUserId;
    if(MessageListIndex != -1)
    {
        UserMessageList = MessageLists[MessageListIndex];
        MessageIndex = 0;
        J0x83:

        if((MessageIndex < UserMessageList.Messages.Length) && !bWasFound)
        {
            bWasFound = Message.MessageId == UserMessageList.Messages[MessageIndex].MessageId;
            ++ MessageIndex;
            goto J0x83;
        }
        if(!bWasFound)
        {
            AddAt = UserMessageList.Messages.Length;
            UserMessageList.Messages.Length = AddAt + 1;
            UserMessageList.Messages[AddAt] = Message;
            MessageLists[MessageListIndex] = UserMessageList;
        }
        LogInternal((((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) $ " MessageId: ") $ UserMessageList.Messages[AddAt].MessageId);        
    }
    else
    {
        AddAt = MessageLists.Length;
        MessageLists.Length = AddAt + 1;
        MessageLists[AddAt].ToUniqueUserId = Message.ToUniqueUserId;
        MessageLists[AddAt].Messages[0] = Message;
    }
}

function bool GetMessageById(string MessageId, out McpMessage Message)
{
    local int MessageListsSize, MessageListsItr, MessageItr;

    MessageListsSize = MessageLists.Length;
    MessageListsItr = 0;
    J0x1F:

    if(MessageListsItr < MessageListsSize)
    {
        MessageItr = 0;
        J0x41:

        if(MessageItr < MessageLists[MessageListsItr].Messages.Length)
        {
            if(MessageLists[MessageListsItr].Messages[MessageItr].MessageId == MessageId)
            {
                Message = MessageLists[MessageListsItr].Messages[MessageItr];
                return true;
            }
            ++ MessageItr;
            goto J0x41;
        }
        ++ MessageListsItr;
        goto J0x1F;
    }
    return false;
}

function bool CacheMessageContents(const out array<byte> MessageContents, string MessageId)
{
    local int MessageContentsIndex;
    local bool bWasSuccessful;

    bWasSuccessful = false;
    if((MessageContents.Length > 0) && Len(MessageId) > 0)
    {
        MessageContentsIndex = MessageContentsList.Find('MessageId', MessageId;
        if(MessageContentsIndex != -1)
        {
            MessageContentsList[MessageContentsIndex].MessageContents = MessageContents;
            bWasSuccessful = true;            
        }
        else
        {
            MessageContentsIndex = MessageContentsList.Length;
            MessageContentsList.Length = MessageContentsList.Length + 1;
            MessageContentsList[MessageContentsIndex].MessageId = MessageId;
            MessageContentsList[MessageContentsIndex].MessageContents = MessageContents;
            bWasSuccessful = true;
        }        
    }
    else
    {
        LogInternal(((((("(" $ string(Name)) $ ") McpMessageManager::") $ string(GetStateName())) $ ":") $ string(GetFuncName())) @ " Either the MessageContents or MessageId were not Specified.");
    }
    return bWasSuccessful;
}

defaultproperties
{
    CreateMessageUrl="/messagecreate"
    DeleteMessageUrl="/messagedelete"
    QueryMessagesUrl="/messagelist"
    QueryMessageContentsUrl="/messagecontents"
    CompressionType=EMcpMessageCompressionType.MMCT_LZO
}